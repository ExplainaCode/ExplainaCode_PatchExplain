record_number,buggy_code,fixed_code,code_similarity
173001,"public boolean sendResponse(RequestID id,Message message){
  if (requestChannels.containsKey(id)) {
    LOG.log(Level.SEVERE,""String_Node_Str"");
    return false;
  }
  SocketChannel channel=requestChannels.get(id);
  if (!socketChannels.contains(channel)) {
    LOG.log(Level.WARNING,""String_Node_Str"");
    return false;
  }
  byte[] data=message.toByteArray();
  int clientWorkerId=requestToWorkers.get(id);
  String messageType=message.getDescriptorForType().getFullName();
  int capacity=id.getId().length + data.length + 4;
  ByteBuffer buffer=ByteBuffer.allocate(capacity);
  buffer.put(id.getId());
  ByteUtils.packString(messageType,buffer);
  buffer.putInt(clientWorkerId);
  buffer.put(data);
  TCPMessage request=server.send(channel,buffer,capacity,0);
  return request != null;
}","/** 
 * Send a response to a request id
 * @param id request id
 * @param message message
 * @return true if response was accepted
 */
public boolean sendResponse(RequestID id,Message message){
  if (requestChannels.containsKey(id)) {
    LOG.log(Level.SEVERE,""String_Node_Str"");
    return false;
  }
  SocketChannel channel=requestChannels.get(id);
  if (!socketChannels.contains(channel)) {
    LOG.log(Level.WARNING,""String_Node_Str"");
    return false;
  }
  byte[] data=message.toByteArray();
  int clientWorkerId=requestToWorkers.get(id);
  String messageType=message.getDescriptorForType().getFullName();
  int capacity=id.getId().length + data.length + 4;
  ByteBuffer buffer=ByteBuffer.allocate(capacity);
  buffer.put(id.getId());
  ByteUtils.packString(messageType,buffer);
  buffer.putInt(workerId);
  buffer.put(data);
  TCPMessage request=server.send(channel,buffer,capacity,0);
  if (request != null) {
    requestChannels.remove(id);
    requestToWorkers.remove(id);
    return true;
  }
 else {
    return false;
  }
}",0.849015317286652
173002,"@Override public void onReceiveComplete(SocketChannel ch,TCPMessage readRequest){
  ByteBuffer data=readRequest.getByteBuffer();
  byte[] id=new byte[RequestID.ID_SIZE];
  data.get(id);
  String messageType=ByteUtils.unPackString(data);
  int serverWorkerId=data.getInt();
  RequestID requestID=RequestID.fromBytes(id);
  Message.Builder builder=messageBuilders.get(messageType);
  if (builder == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    builder.mergeFrom(data.array());
    Message m=builder.build();
    MessageHandler handler=responseHandlers.get(messageType);
    if (handler == null) {
      LOG.log(Level.WARNING,""String_Node_Str"" + messageType);
    }
 else {
      handler.onMessage(requestID,serverWorkerId,m);
    }
  }
 catch (  InvalidProtocolBufferException e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}","@Override public void onReceiveComplete(SocketChannel ch,TCPMessage readRequest){
  ByteBuffer data=readRequest.getByteBuffer();
  byte[] id=new byte[RequestID.ID_SIZE];
  data.get(id);
  String messageType=ByteUtils.unPackString(data);
  int serverWorkerId=data.getInt();
  RequestID requestID=RequestID.fromBytes(id);
  Message.Builder builder=messageBuilders.get(messageType);
  if (builder == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    builder.clear();
    int headerLength=8 + id.length + messageType.getBytes().length;
    int dataLength=readRequest.getLength() - headerLength;
    byte[] d=new byte[dataLength];
    data.get(d);
    builder.mergeFrom(d);
    Message m=builder.build();
    MessageHandler handler=responseHandlers.get(messageType);
    if (handler == null) {
      LOG.log(Level.WARNING,""String_Node_Str"" + messageType);
    }
 else {
      handler.onMessage(requestID,serverWorkerId,m);
    }
  }
 catch (  InvalidProtocolBufferException e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}",0.8897020386826974
173003,"@Override public void onReceiveComplete(SocketChannel channel,TCPMessage readRequest){
  ByteBuffer data=readRequest.getByteBuffer();
  byte[] id=new byte[RequestID.ID_SIZE];
  data.get(id);
  String messageType=ByteUtils.unPackString(data);
  int clientId=data.getInt();
  RequestID requestID=RequestID.fromBytes(id);
  Message.Builder builder=messageBuilders.get(messageType);
  if (builder == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    builder.mergeFrom(data.array());
    Message m=builder.build();
    MessageHandler handler=requestHandlers.get(messageType);
    handler.onMessage(requestID,clientId,m);
    requestToWorkers.put(requestID,clientId);
    requestChannels.put(requestID,channel);
  }
 catch (  InvalidProtocolBufferException e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}","@Override public void onReceiveComplete(SocketChannel channel,TCPMessage readRequest){
  ByteBuffer data=readRequest.getByteBuffer();
  byte[] id=new byte[RequestID.ID_SIZE];
  data.get(id);
  String messageType=ByteUtils.unPackString(data);
  int clientId=data.getInt();
  RequestID requestID=RequestID.fromBytes(id);
  Message.Builder builder=messageBuilders.get(messageType);
  if (builder == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    builder.clear();
    int headerLength=8 + id.length + messageType.getBytes().length;
    int dataLength=readRequest.getLength() - headerLength;
    byte[] d=new byte[dataLength];
    data.get(d);
    builder.mergeFrom(d);
    Message m=builder.build();
    MessageHandler handler=requestHandlers.get(messageType);
    handler.onMessage(requestID,clientId,m);
    requestToWorkers.put(requestID,clientId);
    requestChannels.put(requestID,channel);
  }
 catch (  InvalidProtocolBufferException e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}",0.8862533692722372
173004,"@Override public void onMessage(RequestID id,int workerId,Message message){
  if (message instanceof Network.Ping) {
    System.out.println(""String_Node_Str"");
  }
}","@Override public void onMessage(RequestID id,int workerId,Message message){
  if (message instanceof Network.Ping) {
    System.out.println(""String_Node_Str"");
    LOG.log(Level.INFO,""String_Node_Str"");
  }
}",0.8847184986595175
173005,"public void prepare(){
  outputCollection=new DefaultOutputCollection(outQueue);
  task.prepare(config,new TaskContext(0,0,""String_Node_Str"",0));
}","public void prepare(){
  outputCollection=new DefaultOutputCollection(outQueue);
  task.prepare(config,new TaskContext(0,0,""String_Node_Str"",0,outputCollection));
}",0.945337620578778
173006,"public void prepare(){
  outputCollection=new DefaultOutputCollection(outQueue);
  task.prepare(config,new TaskContext(0,0,""String_Node_Str"",0));
}","public void prepare(){
  outputCollection=new DefaultOutputCollection(outQueue);
  task.prepare(config,new TaskContext(0,0,""String_Node_Str"",0,outputCollection));
}",0.945337620578778
173007,"public void execute(ExecutionPlan execution){
  Map<Integer,INodeInstance> nodes=execution.getNodes();
  tasks=new ArrayBlockingQueue<>(nodes.size() * 2);
  tasks.addAll(nodes.values());
  for (int i=0; i < numThreads; i++) {
    Thread t=new Thread(new Worker());
    t.start();
    threads.add(t);
  }
}","public void execute(ExecutionPlan execution){
  Map<Integer,INodeInstance> nodes=execution.getNodes();
  tasks=new ArrayBlockingQueue<>(nodes.size() * 2);
  tasks.addAll(nodes.values());
  for (  INodeInstance node : tasks) {
    node.prepare();
  }
  for (int i=0; i < numThreads; i++) {
    Thread t=new Thread(new Worker());
    t.start();
    threads.add(t);
  }
}",0.9063893016344724
173008,"@Override public void init(Config config,int id,ResourcePlan resourcePlan){
  Generator g=new Generator();
  Receiver r=new Receiver();
  GraphBuilder builder=GraphBuilder.newBuilder();
  builder.addSource(""String_Node_Str"",g);
  builder.addSink(""String_Node_Str"",r);
  DataFlowTaskGraph graph=builder.build();
  RoundRobinTaskScheduling roundRobinTaskScheduling=new RoundRobinTaskScheduling();
  roundRobinTaskScheduling.initialize(config);
  WorkerPlan workerPlan=createWorkerPlan(resourcePlan);
  TaskSchedulePlan taskSchedulePlan=roundRobinTaskScheduling.schedule(graph,workerPlan);
  TWSNetwork network=new TWSNetwork(config,resourcePlan.getThisId());
  DefaultExecutor defaultExecutor=new DefaultExecutor(resourcePlan,network);
  ExecutionPlan plan=defaultExecutor.schedule(config,graph,taskSchedulePlan);
  while (true) {
    network.getChannel().progress();
  }
}","@Override public void init(Config config,int id,ResourcePlan resourcePlan){
  Generator g=new Generator();
  Receiver r=new Receiver();
  GraphBuilder builder=GraphBuilder.newBuilder();
  builder.addSource(""String_Node_Str"",g);
  builder.setParallelism(""String_Node_Str"",4);
  builder.addSink(""String_Node_Str"",r);
  builder.setParallelism(""String_Node_Str"",4);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",512);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",1000);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",2);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",300);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",1000);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",2);
  DataFlowTaskGraph graph=builder.build();
  RoundRobinTaskScheduling roundRobinTaskScheduling=new RoundRobinTaskScheduling();
  roundRobinTaskScheduling.initialize(config);
  WorkerPlan workerPlan=createWorkerPlan(resourcePlan);
  TaskSchedulePlan taskSchedulePlan=roundRobinTaskScheduling.schedule(graph,workerPlan);
  TWSNetwork network=new TWSNetwork(config,resourcePlan.getThisId());
  DefaultExecutor defaultExecutor=new DefaultExecutor(resourcePlan,network);
  ExecutionPlan plan=defaultExecutor.schedule(config,graph,taskSchedulePlan);
  while (true) {
    network.getChannel().progress();
  }
}",0.7508896797153025
173009,"/** 
 * This method generate the container -> instance map
 */
public static Map<Integer,List<InstanceId>> RoundRobinSchedulingAlgorithm(Set<Vertex> taskVertexSet,int numberOfContainers){
  int taskIndex=1;
  int globalTaskIndex=1;
  TaskAttributes taskAttributes=new TaskAttributes();
  Map<Integer,List<InstanceId>> roundrobinAllocation=new HashMap<>();
  try {
    int totalInstances=taskAttributes.getTotalNumberOfInstances(taskVertexSet);
    Map<String,Integer> parallelTaskMap=taskAttributes.getParallelTaskMap(taskVertexSet);
    LOG.info(String.format(""String_Node_Str"" + numberOfContainers + ""String_Node_Str""+ ""String_Node_Str""+ totalInstances));
    for (int i=1; i <= numberOfContainers; i++) {
      roundrobinAllocation.put(i,new ArrayList<InstanceId>());
    }
    LOG.info(String.format(""String_Node_Str"" + roundrobinAllocation));
    System.out.println();
    for (    String task : parallelTaskMap.keySet()) {
      int numberOfInstances=parallelTaskMap.get(task);
      for (int i=0; i < numberOfInstances; i++) {
        roundrobinAllocation.get(taskIndex).add(new InstanceId(task,globalTaskIndex,i));
        if (taskIndex != numberOfContainers) {
          taskIndex=taskIndex + 1;
        }
 else {
          taskIndex=1;
        }
        globalTaskIndex+=1;
      }
    }
    LOG.info(String.format(""String_Node_Str"" + roundrobinAllocation));
    LOG.info(""String_Node_Str"");
  }
 catch (  NullPointerException ne) {
    ne.printStackTrace();
  }
  return roundrobinAllocation;
}","/** 
 * This method generate the container -> instance map
 */
public static Map<Integer,List<InstanceId>> RoundRobinSchedulingAlgorithm(Set<Vertex> taskVertexSet,int numberOfContainers){
  int taskIndex=1;
  int globalTaskIndex=1;
  TaskAttributes taskAttributes=new TaskAttributes();
  Map<Integer,List<InstanceId>> roundrobinAllocation=new HashMap<>();
  try {
    int totalInstances=taskAttributes.getTotalNumberOfInstances(taskVertexSet);
    Map<String,Integer> parallelTaskMap=taskAttributes.getParallelTaskMap(taskVertexSet);
    LOG.info(String.format(""String_Node_Str"" + numberOfContainers + ""String_Node_Str""+ ""String_Node_Str""+ totalInstances));
    for (int i=0; i < numberOfContainers; i++) {
      roundrobinAllocation.put(i,new ArrayList<InstanceId>());
    }
    LOG.info(String.format(""String_Node_Str"" + roundrobinAllocation));
    System.out.println();
    for (    String task : parallelTaskMap.keySet()) {
      int numberOfInstances=parallelTaskMap.get(task);
      for (int i=0; i < numberOfInstances; i++) {
        roundrobinAllocation.get(taskIndex).add(new InstanceId(task,globalTaskIndex,i));
        if (taskIndex != numberOfContainers) {
          taskIndex=taskIndex + 1;
        }
 else {
          taskIndex=1;
        }
        globalTaskIndex+=1;
      }
    }
    LOG.info(String.format(""String_Node_Str"" + roundrobinAllocation));
    LOG.info(""String_Node_Str"");
  }
 catch (  NullPointerException ne) {
    ne.printStackTrace();
  }
  return roundrobinAllocation;
}",0.9990029910269193
173010,"private void init(List<KeyValue> inMemoryValues){
  for (int i=0; i < noOfFiles; i++) {
    String fileName=folder + ""String_Node_Str"" + i;
    Triple<List<KeyValue>,Long,Long> fileParts=FileLoader.openFilePart(fileName,0,openBytes,keyType,dataType,deserializer);
    openList.add(new FilePart(fileParts));
  }
  openList.add(new FilePart(new ImmutableTriple<>(inMemoryValues,0l,0l)));
  for (int i=0; i < openList.size(); i++) {
    FilePart p=openList.get(i);
    List<KeyValue> list=p.keyValues.getLeft();
    if (list.size() > p.currentIndex) {
      heap.insert(list.get(p.currentIndex),i);
      p.currentIndex++;
    }
  }
}","private void init(List<KeyValue> inMemoryValues){
  for (int i=0; i < noOfFiles; i++) {
    String fileName=folder + ""String_Node_Str"" + i;
    Triple<List<KeyValue>,Long,Long> fileParts=FileLoader.openFilePart(fileName,0,openBytes,keyType,dataType,deserializer);
    openList.add(new FilePart(fileParts));
  }
  openList.add(new FilePart(new ImmutableTriple<>(inMemoryValues,0L,0L)));
  for (int i=0; i < openList.size(); i++) {
    FilePart p=openList.get(i);
    List<KeyValue> list=p.keyValues.getLeft();
    if (list.size() > p.currentIndex) {
      heap.insert(list.get(p.currentIndex),i);
      p.currentIndex++;
    }
  }
}",0.9968304278922344
173011,"public FilePart(Triple<List<KeyValue>,Long,Long> keyValues){
  this.keyValues=keyValues;
}","FilePart(Triple<List<KeyValue>,Long,Long> keyValues){
  this.keyValues=keyValues;
}",0.9595375722543352
173012,"@Override public void init(Config config,int id,ResourcePlan resourcePlan){
  Generator g=new Generator();
  Receiver r=new Receiver();
  GraphBuilder builder=GraphBuilder.newBuilder();
  builder.addSource(""String_Node_Str"",g);
  builder.setParallelism(""String_Node_Str"",4);
  builder.addSink(""String_Node_Str"",r);
  builder.setParallelism(""String_Node_Str"",4);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",512);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",1000);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",2);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",300);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",1000);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",2);
  builder.connect(""String_Node_Str"",""String_Node_Str"",Operations.PARTITION);
  DataFlowTaskGraph graph=builder.build();
  RoundRobinTaskScheduling roundRobinTaskScheduling=new RoundRobinTaskScheduling();
  roundRobinTaskScheduling.initialize(config);
  WorkerPlan workerPlan=createWorkerPlan(resourcePlan);
  TaskSchedulePlan taskSchedulePlan=roundRobinTaskScheduling.schedule(graph,workerPlan);
  TWSNetwork network=new TWSNetwork(config,resourcePlan.getThisId());
  DefaultExecutor defaultExecutor=new DefaultExecutor(resourcePlan,network);
  ExecutionPlan plan=defaultExecutor.schedule(config,graph,taskSchedulePlan);
  while (true) {
    network.getChannel().progress();
  }
}","@Override public void init(Config config,int id,ResourcePlan resourcePlan){
  Generator g=new Generator();
  Receiver r=new Receiver();
  GraphBuilder builder=GraphBuilder.newBuilder();
  builder.addSource(""String_Node_Str"",g);
  builder.setParallelism(""String_Node_Str"",4);
  builder.addSink(""String_Node_Str"",r);
  builder.setParallelism(""String_Node_Str"",4);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",512);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",1000);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",2);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",300);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",1000);
  builder.addConfiguration(""String_Node_Str"",""String_Node_Str"",2);
  builder.connect(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",Operations.PARTITION);
  DataFlowTaskGraph graph=builder.build();
  RoundRobinTaskScheduling roundRobinTaskScheduling=new RoundRobinTaskScheduling();
  roundRobinTaskScheduling.initialize(config);
  WorkerPlan workerPlan=createWorkerPlan(resourcePlan);
  TaskSchedulePlan taskSchedulePlan=roundRobinTaskScheduling.schedule(graph,workerPlan);
  TWSNetwork network=new TWSNetwork(config,resourcePlan.getThisId());
  DefaultExecutor defaultExecutor=new DefaultExecutor(resourcePlan,network);
  ExecutionPlan plan=defaultExecutor.schedule(config,graph,taskSchedulePlan);
  while (true) {
    network.getChannel().progress();
  }
}",0.9938482570061518
173013,"/** 
 * Create an instance of a task,
 * @param cfg the configuration
 * @param ip instance plan
 * @param vertex vertex
 */
private void createInstances(Config cfg,TaskSchedulePlan.TaskInstancePlan ip,Vertex vertex){
  byte[] taskBytes=kryoMemorySerializer.serialize(vertex.getTask());
  INode newInstance=(INode)kryoMemorySerializer.deserialize(taskBytes);
  int taskId=taskIdGenerator.generateGlobalTaskId(vertex.getName(),ip.getTaskId(),ip.getTaskIndex());
  if (newInstance instanceof ITask) {
    taskInstances.put(vertex.getName(),taskId,new TaskInstance((ITask)newInstance,new ArrayBlockingQueue<>(1024),new ArrayBlockingQueue<>(1024),cfg,edgeGenerator));
  }
 else   if (newInstance instanceof ISource) {
    sourceInstances.put(vertex.getName(),taskId,new SourceInstance((ISource)newInstance,new ArrayBlockingQueue<>(1024),cfg));
  }
 else   if (newInstance instanceof ISink) {
    sinkInstances.put(vertex.getName(),taskId,new SinkInstance((ISink)newInstance,new ArrayBlockingQueue<>(1024),cfg));
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * Create an instance of a task,
 * @param cfg the configuration
 * @param ip instance plan
 * @param vertex vertex
 */
private INodeInstance createInstances(Config cfg,TaskSchedulePlan.TaskInstancePlan ip,Vertex vertex){
  byte[] taskBytes=kryoMemorySerializer.serialize(vertex.getTask());
  INode newInstance=(INode)kryoMemorySerializer.deserialize(taskBytes);
  int taskId=taskIdGenerator.generateGlobalTaskId(vertex.getName(),ip.getTaskId(),ip.getTaskIndex());
  if (newInstance instanceof ITask) {
    TaskInstance v=new TaskInstance((ITask)newInstance,new ArrayBlockingQueue<>(1024),new ArrayBlockingQueue<>(1024),cfg,edgeGenerator);
    taskInstances.put(vertex.getName(),taskId,v);
    return v;
  }
 else   if (newInstance instanceof ISource) {
    SourceInstance v=new SourceInstance((ISource)newInstance,new ArrayBlockingQueue<>(1024),cfg);
    sourceInstances.put(vertex.getName(),taskId,v);
    return v;
  }
 else   if (newInstance instanceof ISink) {
    SinkInstance v=new SinkInstance((ISink)newInstance,new ArrayBlockingQueue<>(1024),cfg);
    sinkInstances.put(vertex.getName(),taskId,v);
    return v;
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.8287098194627918
173014,"@Override public ExecutionPlan schedule(Config cfg,DataFlowTaskGraph taskGraph,TaskSchedulePlan taskSchedule){
  noOfThreads=ExecutorContext.threadsPerContainer(cfg);
  TaskPlan taskPlan=TaskPlanBuilder.build(resourcePlan,taskSchedule,taskIdGenerator);
  ParallelOperationFactory opFactory=new ParallelOperationFactory(cfg,network.getChannel(),taskPlan,edgeGenerator);
  Map<Integer,TaskSchedulePlan.ContainerPlan> containersMap=taskSchedule.getContainersMap();
  TaskSchedulePlan.ContainerPlan conPlan=containersMap.get(workerId);
  if (conPlan == null) {
    LOG.log(Level.INFO,""String_Node_Str"" + workerId);
    return null;
  }
  Set<TaskSchedulePlan.TaskInstancePlan> instancePlan=conPlan.getTaskInstances();
  for (  TaskSchedulePlan.TaskInstancePlan ip : instancePlan) {
    Vertex v=taskGraph.vertex(ip.getTaskName());
    if (v == null) {
      throw new RuntimeException(""String_Node_Str"" + ip.getTaskName());
    }
    INode node=v.getTask();
    if (node instanceof ITask || node instanceof ISource) {
      Set<Edge> edges=taskGraph.outEdges(v);
      for (      Edge e : edges) {
        Vertex child=taskGraph.childOfTask(v,e.getName());
        Set<Integer> srcTasks=taskIdGenerator.getTaskIds(v.getName(),ip.getTaskId(),taskGraph);
        Set<Integer> tarTasks=taskIdGenerator.getTaskIds(child.getName(),getTaskIdOfTask(child.getName(),taskSchedule),taskGraph);
        if (!parOpTable.contains(v.getName(),e.getName())) {
          parOpTable.put(v.getName(),e.getName(),new Communication(e,v.getName(),child.getName(),srcTasks,tarTasks));
          sendTable.put(v.getName(),e.getName(),new Communication(e,v.getName(),child.getName(),srcTasks,tarTasks));
        }
      }
    }
    if (node instanceof ITask || node instanceof ISink) {
      Set<Edge> parentEdges=taskGraph.inEdges(v);
      for (      Edge e : parentEdges) {
        Vertex parent=taskGraph.getParentOfTask(v,e.getName());
        Set<Integer> srcTasks=taskIdGenerator.getTaskIds(parent.getName(),getTaskIdOfTask(parent.getName(),taskSchedule),taskGraph);
        Set<Integer> tarTasks=taskIdGenerator.getTaskIds(v.getName(),ip.getTaskId(),taskGraph);
        if (!parOpTable.contains(parent.getName(),e.getName())) {
          parOpTable.put(parent.getName(),e.getName(),new Communication(e,parent.getName(),v.getName(),srcTasks,tarTasks));
          recvTable.put(parent.getName(),e.getName(),new Communication(e,parent.getName(),v.getName(),srcTasks,tarTasks));
        }
      }
    }
    createInstances(cfg,ip,v);
  }
  ExecutionPlan execution=new ExecutionPlan();
  for (  Table.Cell<String,String,Communication> cell : parOpTable.cellSet()) {
    Communication c=cell.getValue();
    IParallelOperation op=opFactory.build(c.getEdge(),c.getSourceTasks(),c.getTargetTasks(),DataType.OBJECT);
    Set<Integer> sourcesOfThisWorker=intersectionOfTasks(conPlan,c.getSourceTasks());
    Set<Integer> targetsOfThisWorker=intersectionOfTasks(conPlan,c.getTargetTasks());
    for (    Integer i : sourcesOfThisWorker) {
      if (taskInstances.contains(c.getSourceTask(),i)) {
        TaskInstance taskInstance=taskInstances.get(c.getSourceTasks(),i);
        taskInstance.registerOutParallelOperation(c.getEdge().getName(),op);
      }
 else       if (sourceInstances.contains(c.getSourceTask(),i)) {
        SourceInstance sourceInstance=sourceInstances.get(c.getSourceTask(),i);
        sourceInstance.registerOutParallelOperation(c.getEdge().getName(),op);
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + c.getSourceTask());
      }
    }
    for (    Integer i : targetsOfThisWorker) {
      if (taskInstances.contains(c.getTargetTask(),i)) {
        TaskInstance taskInstance=taskInstances.get(c.getTargetTask(),i);
        op.register(i,taskInstance.getInQueue());
      }
 else       if (sinkInstances.contains(c.getTargetTask(),i)) {
        SinkInstance sourceInstance=sinkInstances.get(c.getTargetTask(),i);
        op.register(i,sourceInstance.getInQueue());
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + c.getTargetTask());
      }
    }
    execution.add(op);
  }
  ThreadSharingExecutor threadSharingExecutor=new ThreadSharingExecutor(noOfThreads,network.getChannel());
  threadSharingExecutor.execute(execution);
  return execution;
}","@Override public ExecutionPlan schedule(Config cfg,DataFlowTaskGraph taskGraph,TaskSchedulePlan taskSchedule){
  noOfThreads=ExecutorContext.threadsPerContainer(cfg);
  TaskPlan taskPlan=TaskPlanBuilder.build(resourcePlan,taskSchedule,taskIdGenerator);
  ParallelOperationFactory opFactory=new ParallelOperationFactory(cfg,network.getChannel(),taskPlan,edgeGenerator);
  Map<Integer,TaskSchedulePlan.ContainerPlan> containersMap=taskSchedule.getContainersMap();
  TaskSchedulePlan.ContainerPlan conPlan=containersMap.get(workerId);
  if (conPlan == null) {
    LOG.log(Level.INFO,""String_Node_Str"" + workerId);
    return null;
  }
  ExecutionPlan execution=new ExecutionPlan();
  Set<TaskSchedulePlan.TaskInstancePlan> instancePlan=conPlan.getTaskInstances();
  for (  TaskSchedulePlan.TaskInstancePlan ip : instancePlan) {
    Vertex v=taskGraph.vertex(ip.getTaskName());
    if (v == null) {
      throw new RuntimeException(""String_Node_Str"" + ip.getTaskName());
    }
    INode node=v.getTask();
    if (node instanceof ITask || node instanceof ISource) {
      Set<Edge> edges=taskGraph.outEdges(v);
      for (      Edge e : edges) {
        Vertex child=taskGraph.childOfTask(v,e.getName());
        Set<Integer> srcTasks=taskIdGenerator.getTaskIds(v.getName(),ip.getTaskId(),taskGraph);
        Set<Integer> tarTasks=taskIdGenerator.getTaskIds(child.getName(),getTaskIdOfTask(child.getName(),taskSchedule),taskGraph);
        if (!parOpTable.contains(v.getName(),e.getName())) {
          parOpTable.put(v.getName(),e.getName(),new Communication(e,v.getName(),child.getName(),srcTasks,tarTasks));
          sendTable.put(v.getName(),e.getName(),new Communication(e,v.getName(),child.getName(),srcTasks,tarTasks));
        }
      }
    }
    if (node instanceof ITask || node instanceof ISink) {
      Set<Edge> parentEdges=taskGraph.inEdges(v);
      for (      Edge e : parentEdges) {
        Vertex parent=taskGraph.getParentOfTask(v,e.getName());
        Set<Integer> srcTasks=taskIdGenerator.getTaskIds(parent.getName(),getTaskIdOfTask(parent.getName(),taskSchedule),taskGraph);
        Set<Integer> tarTasks=taskIdGenerator.getTaskIds(v.getName(),ip.getTaskId(),taskGraph);
        if (!parOpTable.contains(parent.getName(),e.getName())) {
          parOpTable.put(parent.getName(),e.getName(),new Communication(e,parent.getName(),v.getName(),srcTasks,tarTasks));
          recvTable.put(parent.getName(),e.getName(),new Communication(e,parent.getName(),v.getName(),srcTasks,tarTasks));
        }
      }
    }
    INodeInstance iNodeInstance=createInstances(cfg,ip,v);
    execution.addNodes(taskIdGenerator.generateGlobalTaskId(v.getName(),ip.getTaskId(),ip.getTaskIndex()),iNodeInstance);
  }
  for (  Table.Cell<String,String,Communication> cell : parOpTable.cellSet()) {
    Communication c=cell.getValue();
    IParallelOperation op=opFactory.build(c.getEdge(),c.getSourceTasks(),c.getTargetTasks(),DataType.OBJECT);
    Set<Integer> sourcesOfThisWorker=intersectionOfTasks(conPlan,c.getSourceTasks());
    Set<Integer> targetsOfThisWorker=intersectionOfTasks(conPlan,c.getTargetTasks());
    for (    Integer i : sourcesOfThisWorker) {
      if (taskInstances.contains(c.getSourceTask(),i)) {
        TaskInstance taskInstance=taskInstances.get(c.getSourceTasks(),i);
        taskInstance.registerOutParallelOperation(c.getEdge().getName(),op);
      }
 else       if (sourceInstances.contains(c.getSourceTask(),i)) {
        SourceInstance sourceInstance=sourceInstances.get(c.getSourceTask(),i);
        sourceInstance.registerOutParallelOperation(c.getEdge().getName(),op);
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + c.getSourceTask());
      }
    }
    for (    Integer i : targetsOfThisWorker) {
      if (taskInstances.contains(c.getTargetTask(),i)) {
        TaskInstance taskInstance=taskInstances.get(c.getTargetTask(),i);
        op.register(i,taskInstance.getInQueue());
      }
 else       if (sinkInstances.contains(c.getTargetTask(),i)) {
        SinkInstance sourceInstance=sinkInstances.get(c.getTargetTask(),i);
        op.register(i,sourceInstance.getInQueue());
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + c.getTargetTask());
      }
    }
    execution.addOps(op);
  }
  ThreadSharingExecutor threadSharingExecutor=new ThreadSharingExecutor(noOfThreads,network.getChannel());
  threadSharingExecutor.execute(execution);
  return execution;
}",0.9716905444126076
173015,"public Vertex getParentOfTask(Vertex task,String edge){
  Set<Edge> edges=inEdges(task);
  Edge taskEdge=null;
  for (  Edge e : edges) {
    if (e.getName().equals(edge)) {
      taskEdge=e;
    }
  }
  if (taskEdge != null) {
    return connectedChildTask(task,taskEdge);
  }
 else {
    return null;
  }
}","public Vertex getParentOfTask(Vertex task,String edge){
  Set<Edge> edges=inEdges(task);
  Edge taskEdge=null;
  for (  Edge e : edges) {
    if (e.getName().equals(edge)) {
      taskEdge=e;
    }
  }
  if (taskEdge != null) {
    return connectedParentTask(task,taskEdge);
  }
 else {
    return null;
  }
}",0.9821717990275528
173016,"public static List<Object> readFile(String fileName,MessageType dataType,KryoMemorySerializer deserializer){
  String outFileName=Paths.get(fileName).toString();
  FileChannel rwChannel;
  try {
    rwChannel=new RandomAccessFile(outFileName,""String_Node_Str"").getChannel();
    ByteBuffer os=rwChannel.map(FileChannel.MapMode.READ_ONLY,0,rwChannel.size());
    List<Object> values=new ArrayList<>();
    int totalRead=0;
    while (totalRead < rwChannel.size()) {
      int keySize=os.getInt();
      Object value=null;
      int dataSize=os.getInt();
      value=deserialize(dataType,deserializer,os,dataSize);
      values.add(value);
    }
    rwChannel.close();
    return values;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","public static List<Object> readFile(String fileName,MessageType dataType,KryoMemorySerializer deserializer){
  String outFileName=Paths.get(fileName).toString();
  FileChannel rwChannel;
  try {
    rwChannel=new RandomAccessFile(outFileName,""String_Node_Str"").getChannel();
    ByteBuffer os=rwChannel.map(FileChannel.MapMode.READ_ONLY,0,rwChannel.size());
    List<Object> values=new ArrayList<>();
    int totalRead=0;
    while (totalRead < rwChannel.size()) {
      Object value;
      int dataSize=os.getInt();
      value=deserialize(dataType,deserializer,os,dataSize);
      values.add(value);
    }
    rwChannel.close();
    return values;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9756427604871448
173017,"public OpenFile(FileChannel rwChannel,ByteBuffer buffer){
  this.rwChannel=rwChannel;
  this.byteBuffer=buffer;
}","public OpenFile(FileChannel rwChannel,ByteBuffer byteBuffer,List<KeyValue> kValues,int total){
  this.rwChannel=rwChannel;
  this.byteBuffer=byteBuffer;
  this.keyValues=kValues;
  this.totalBytes=total;
}",0.6477987421383647
173018,"/** 
 * This method initialize the config values received from the user and set the default instance value and container maximum value.
 * @param cfg1
 */
public void initialize(Config cfg1){
  this.cfg=cfg1;
  this.instanceRAM=1024.0;
  this.instanceDisk=1000.0;
  this.instanceCPU=5.0;
  LOG.info(""String_Node_Str"" + ""String_Node_Str"" + instanceRAM + ""String_Node_Str""+ ""String_Node_Str""+ instanceDisk+ ""String_Node_Str""+ ""String_Node_Str""+ instanceCPU);
  this.defaultResourceValue=new Resource(this.instanceRAM,this.instanceDisk,this.instanceCPU);
  this.instanceRAM=this.defaultResourceValue.getRam() * DEFAULT_NUMBER_INSTANCES_PER_CONTAINER;
  this.instanceDisk=this.defaultResourceValue.getDisk() * DEFAULT_NUMBER_INSTANCES_PER_CONTAINER;
  this.instanceCPU=this.defaultResourceValue.getCpu() * DEFAULT_NUMBER_INSTANCES_PER_CONTAINER;
  this.paddingPercentage=DEFAULT_CONTAINER_PADDING_PERCENTAGE;
  this.maximumContainerResourceValue=new Resource((double)Math.round(TaskScheduleUtils.increaseBy(instanceRAM,paddingPercentage)),(double)Math.round(TaskScheduleUtils.increaseBy(instanceDisk,paddingPercentage)),(double)Math.round(TaskScheduleUtils.increaseBy(instanceCPU,paddingPercentage)));
  LOG.info(""String_Node_Str"" + ""String_Node_Str"" + this.maximumContainerResourceValue.getRam() + ""String_Node_Str""+ ""String_Node_Str""+ this.maximumContainerResourceValue.getDisk()+ ""String_Node_Str""+ ""String_Node_Str""+ this.maximumContainerResourceValue.getCpu());
}","/** 
 * This method initialize the config values received from the user and set the default instance value and container maximum value.
 * @param cfg1
 */
public void initialize(Config cfg1){
  this.cfg=cfg1;
  this.instanceRAM=1024.0;
  this.instanceDisk=1000.0;
  this.instanceCPU=5.0;
  this.defaultResourceValue=new Resource(this.instanceRAM,this.instanceDisk,this.instanceCPU);
  this.instanceRAM=this.defaultResourceValue.getRam() * DEFAULT_NUMBER_INSTANCES_PER_CONTAINER;
  this.instanceDisk=this.defaultResourceValue.getDisk() * DEFAULT_NUMBER_INSTANCES_PER_CONTAINER;
  this.instanceCPU=this.defaultResourceValue.getCpu() * DEFAULT_NUMBER_INSTANCES_PER_CONTAINER;
  this.paddingPercentage=DEFAULT_CONTAINER_PADDING_PERCENTAGE;
  this.maximumContainerResourceValue=new Resource((double)Math.round(TaskScheduleUtils.increaseBy(instanceRAM,paddingPercentage)),(double)Math.round(TaskScheduleUtils.increaseBy(instanceDisk,paddingPercentage)),(double)Math.round(TaskScheduleUtils.increaseBy(instanceCPU,paddingPercentage)));
  LOG.info(""String_Node_Str"" + ""String_Node_Str"" + instanceRAM + ""String_Node_Str""+ ""String_Node_Str""+ instanceDisk+ ""String_Node_Str""+ ""String_Node_Str""+ instanceCPU);
  LOG.info(""String_Node_Str"" + ""String_Node_Str"" + this.maximumContainerResourceValue.getRam() + ""String_Node_Str""+ ""String_Node_Str""+ this.maximumContainerResourceValue.getDisk()+ ""String_Node_Str""+ ""String_Node_Str""+ this.maximumContainerResourceValue.getCpu());
}",0.8845628415300546
173019,"public void setStoreBased(boolean storeBased){
  isStoreBased=storeBased;
  if (isStoreBased) {
    opertionID=(int)System.currentTimeMillis();
    this.kryoSerializer=new KryoSerializer();
    Path dataPath=new Path(""String_Node_Str"" + this.executor);
    this.memoryManager=new LMDBMemoryManager(dataPath);
    if (!isKeyed) {
      this.operationMemoryManager=memoryManager.addOperation(opertionID,MessageTypeUtils.toDataMessageType(type));
    }
 else {
      this.operationMemoryManager=memoryManager.addOperation(opertionID,MessageTypeUtils.toDataMessageType(type),MessageTypeUtils.toDataMessageType(keyType));
    }
  }
}","public void setStoreBased(boolean storeBased){
  isStoreBased=storeBased;
  if (isStoreBased) {
    opertionID=(int)System.currentTimeMillis();
    this.kryoSerializer=new KryoSerializer();
    Path dataPath=new Path(MPIContext.networkStoragePath(config) + ""String_Node_Str"" + this.executor);
    this.memoryManager=new LMDBMemoryManager(dataPath);
    if (!isKeyed) {
      this.operationMemoryManager=memoryManager.addOperation(opertionID,MessageTypeUtils.toDataMessageType(type));
    }
 else {
      this.operationMemoryManager=memoryManager.addOperation(opertionID,MessageTypeUtils.toDataMessageType(type),MessageTypeUtils.toDataMessageType(keyType));
    }
  }
}",0.9691358024691358
173020,"/** 
 * Initialize
 * @param cfg
 * @param t
 * @param tPlan
 * @param ed
 */
public void init(Config cfg,MessageType t,TaskPlan tPlan,int ed){
  this.config=cfg;
  this.instancePlan=tPlan;
  this.type=t;
  this.edge=ed;
  router=new BinaryTreeRouter(cfg,tPlan,source,destinations);
  if (this.finalReceiver != null) {
    this.finalReceiver.init(cfg,this,receiveExpectedTaskIds());
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  LOG.info(String.format(""String_Node_Str"",executor,router.sendQueueIds()));
  Map<Integer,Queue<Pair<Object,MPIMessage>>> pendingReceiveMessagesPerSource=new HashMap<>();
  Map<Integer,Queue<MPIMessage>> pendingReceiveDeSerializations=new HashMap<>();
  Map<Integer,MessageSerializer> serializerMap=new HashMap<>();
  Map<Integer,MessageDeSerializer> deSerializerMap=new HashMap<>();
  Set<Integer> srcs=router.sendQueueIds();
  for (  int s : srcs) {
    ArrayBlockingQueue<Pair<Object,MPISendMessage>> pendingSendMessages=new ArrayBlockingQueue<Pair<Object,MPISendMessage>>(MPIContext.sendPendingMax(cfg));
    pendingSendMessagesPerSource.put(s,pendingSendMessages);
    serializerMap.put(s,new MPIMessageSerializer(new KryoSerializer()));
  }
  int maxReceiveBuffers=MPIContext.receiveBufferCount(cfg);
  int receiveExecutorsSize=receivingExecutors().size();
  if (receiveExecutorsSize == 0) {
    receiveExecutorsSize=1;
  }
  Set<Integer> execs=router.receivingExecutors();
  for (  int e : execs) {
    int capacity=maxReceiveBuffers * 2 * receiveExecutorsSize;
    Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=new ArrayBlockingQueue<Pair<Object,MPIMessage>>(capacity);
    pendingReceiveMessagesPerSource.put(e,pendingReceiveMessages);
    pendingReceiveDeSerializations.put(e,new ArrayBlockingQueue<MPIMessage>(capacity));
    deSerializerMap.put(e,new MPIMessageDeSerializer(new KryoSerializer()));
  }
  delegete.init(cfg,t,tPlan,ed,router.receivingExecutors(),router.isLastReceiver(),this,pendingSendMessagesPerSource,pendingReceiveMessagesPerSource,pendingReceiveDeSerializations,serializerMap,deSerializerMap,false);
}","/** 
 * Initialize
 * @param cfg
 * @param t
 * @param tPlan
 * @param ed
 */
public void init(Config cfg,MessageType t,TaskPlan tPlan,int ed){
  this.config=cfg;
  this.instancePlan=tPlan;
  this.type=t;
  this.edge=ed;
  this.executor=tPlan.getThisExecutor();
  router=new BinaryTreeRouter(cfg,tPlan,source,destinations);
  if (this.finalReceiver != null) {
    this.finalReceiver.init(cfg,this,receiveExpectedTaskIds());
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  LOG.info(String.format(""String_Node_Str"",executor,router.sendQueueIds()));
  Map<Integer,Queue<Pair<Object,MPIMessage>>> pendingReceiveMessagesPerSource=new HashMap<>();
  Map<Integer,Queue<MPIMessage>> pendingReceiveDeSerializations=new HashMap<>();
  Map<Integer,MessageSerializer> serializerMap=new HashMap<>();
  Map<Integer,MessageDeSerializer> deSerializerMap=new HashMap<>();
  Set<Integer> srcs=router.sendQueueIds();
  for (  int s : srcs) {
    ArrayBlockingQueue<Pair<Object,MPISendMessage>> pendingSendMessages=new ArrayBlockingQueue<Pair<Object,MPISendMessage>>(MPIContext.sendPendingMax(cfg));
    pendingSendMessagesPerSource.put(s,pendingSendMessages);
    serializerMap.put(s,new MPIMessageSerializer(new KryoSerializer()));
  }
  int maxReceiveBuffers=MPIContext.receiveBufferCount(cfg);
  int receiveExecutorsSize=receivingExecutors().size();
  if (receiveExecutorsSize == 0) {
    receiveExecutorsSize=1;
  }
  Set<Integer> execs=router.receivingExecutors();
  for (  int e : execs) {
    int capacity=maxReceiveBuffers * 2 * receiveExecutorsSize;
    Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=new ArrayBlockingQueue<Pair<Object,MPIMessage>>(capacity);
    pendingReceiveMessagesPerSource.put(e,pendingReceiveMessages);
    pendingReceiveDeSerializations.put(e,new ArrayBlockingQueue<MPIMessage>(capacity));
    deSerializerMap.put(e,new MPIMessageDeSerializer(new KryoSerializer()));
  }
  delegete.init(cfg,t,tPlan,ed,router.receivingExecutors(),router.isLastReceiver(),this,pendingSendMessagesPerSource,pendingReceiveMessagesPerSource,pendingReceiveDeSerializations,serializerMap,deSerializerMap,false);
}",0.9902958579881656
173021,"private void sendProgress(Queue<Pair<Object,MPISendMessage>> pendingSendMessages,int sendId){
  boolean canProgress=true;
  while (pendingSendMessages.size() > 0 && canProgress) {
    Pair<Object,MPISendMessage> pair=pendingSendMessages.peek();
    MPISendMessage mpiSendMessage=pair.getValue();
    Object messageObject=pair.getKey();
    if (mpiSendMessage.serializedState() == MPISendMessage.SendState.INIT) {
      for (      Integer i : mpiSendMessage.getInternalSends()) {
        boolean receiveAccepted;
        if (isStoreBased && isLastReceiver) {
          serializeAndWriteToMemoryManager(mpiSendMessage,messageObject);
          receiveAccepted=receiver.receiveSendInternally(mpiSendMessage.getSource(),i,mpiSendMessage.getPath(),mpiSendMessage.getFlags(),operationMemoryManager);
        }
 else {
          lock.lock();
          try {
            receiveAccepted=receiver.receiveSendInternally(mpiSendMessage.getSource(),i,mpiSendMessage.getPath(),mpiSendMessage.getFlags(),messageObject);
          }
  finally {
            lock.unlock();
          }
        }
        if (!receiveAccepted) {
          canProgress=false;
          break;
        }
      }
      if (canProgress) {
        mpiSendMessage.setSendState(MPISendMessage.SendState.SENT_INTERNALLY);
      }
    }
    if (canProgress) {
      if (mpiSendMessage.getExternalSends().size() == 0) {
        pendingSendMessages.poll();
        continue;
      }
      MPISendMessage message=(MPISendMessage)messageSerializer.get(sendId).build(pair.getKey(),mpiSendMessage);
      if (message.serializedState() == MPISendMessage.SendState.SERIALIZED) {
        List<Integer> exRoutes=new ArrayList<>(mpiSendMessage.getExternalSends());
        int startOfExternalRouts=mpiSendMessage.getAcceptedExternalSends();
        int noOfExternalSends=startOfExternalRouts;
        for (int i=startOfExternalRouts; i < exRoutes.size(); i++) {
          boolean sendAccepted=sendMessageToTarget(message.getMPIMessage(),exRoutes.get(i));
          if (!sendAccepted) {
            canProgress=false;
            break;
          }
 else {
            sendCount++;
            mpiSendMessage.incrementAcceptedExternalSends();
            noOfExternalSends++;
          }
        }
        if (noOfExternalSends == exRoutes.size()) {
          mpiSendMessage.setSendState(MPISendMessage.SendState.FINISHED);
          pendingSendMessages.poll();
        }
      }
 else {
        break;
      }
    }
  }
}","private void sendProgress(Queue<Pair<Object,MPISendMessage>> pendingSendMessages,int sendId){
  boolean canProgress=true;
  while (pendingSendMessages.size() > 0 && canProgress) {
    Pair<Object,MPISendMessage> pair=pendingSendMessages.peek();
    MPISendMessage mpiSendMessage=pair.getValue();
    Object messageObject=pair.getKey();
    if (mpiSendMessage.serializedState() == MPISendMessage.SendState.INIT) {
      int startOfInternalRouts=mpiSendMessage.getAcceptedInternalSends();
      List<Integer> inRoutes=new ArrayList<>(mpiSendMessage.getInternalSends());
      for (int i=startOfInternalRouts; i < mpiSendMessage.getInternalSends().size(); i++) {
        boolean receiveAccepted;
        if (isStoreBased && isLastReceiver) {
          serializeAndWriteToMemoryManager(mpiSendMessage,messageObject);
          receiveAccepted=receiver.receiveSendInternally(mpiSendMessage.getSource(),inRoutes.get(i),mpiSendMessage.getPath(),mpiSendMessage.getFlags(),operationMemoryManager);
        }
 else {
          lock.lock();
          try {
            receiveAccepted=receiver.receiveSendInternally(mpiSendMessage.getSource(),inRoutes.get(i),mpiSendMessage.getPath(),mpiSendMessage.getFlags(),messageObject);
          }
  finally {
            lock.unlock();
          }
        }
        if (!receiveAccepted) {
          canProgress=false;
          break;
        }
        mpiSendMessage.incrementAcceptedInternalSends();
      }
      if (canProgress) {
        mpiSendMessage.setSendState(MPISendMessage.SendState.SENT_INTERNALLY);
      }
    }
    if (canProgress) {
      if (mpiSendMessage.getExternalSends().size() == 0) {
        pendingSendMessages.poll();
        continue;
      }
      MPISendMessage message=(MPISendMessage)messageSerializer.get(sendId).build(pair.getKey(),mpiSendMessage);
      if (message.serializedState() == MPISendMessage.SendState.SERIALIZED) {
        List<Integer> exRoutes=new ArrayList<>(mpiSendMessage.getExternalSends());
        int startOfExternalRouts=mpiSendMessage.getAcceptedExternalSends();
        int noOfExternalSends=startOfExternalRouts;
        for (int i=startOfExternalRouts; i < exRoutes.size(); i++) {
          boolean sendAccepted=sendMessageToTarget(message.getMPIMessage(),exRoutes.get(i));
          if (!sendAccepted) {
            canProgress=false;
            break;
          }
 else {
            sendCount++;
            mpiSendMessage.incrementAcceptedExternalSends();
            noOfExternalSends++;
          }
        }
        if (noOfExternalSends == exRoutes.size()) {
          mpiSendMessage.setSendState(MPISendMessage.SendState.FINISHED);
          pendingSendMessages.poll();
        }
      }
 else {
        break;
      }
    }
  }
}",0.9276644863409004
173022,"public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    LOG.info(String.format(""String_Node_Str"",id,e.getKey(),e.getValue().toString()));
  }
}","public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    LOG.info(String.format(""String_Node_Str"",id,e.getKey(),e.getValue().toString()));
    receiveIds.put(e.getKey(),new ArrayList<>());
  }
}",0.9100719424460432
173023,"@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  count++;
  if (count % 1 == 0) {
    LOG.info(""String_Node_Str"" + source + ""String_Node_Str""+ target+ ""String_Node_Str""+ count);
  }
  return true;
}","@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  try {
    count++;
    if (count % 1 == 0) {
      LOG.info(""String_Node_Str"" + source + ""String_Node_Str""+ target+ ""String_Node_Str""+ count);
    }
    IntData data=(IntData)object;
    int sequence=data.getId();
    List<Integer> list=receiveIds.get(target);
    list.add(sequence);
    Set<Integer> r=new HashSet<>(list);
    if (list.size() != r.size()) {
      LOG.log(Level.INFO,""String_Node_Str"",new RuntimeException(""String_Node_Str""));
    }
  }
 catch (  NullPointerException e) {
    LOG.log(Level.INFO,""String_Node_Str"" + source + ""String_Node_Str""+ target+ ""String_Node_Str""+ count+ ""String_Node_Str""+ receiveIds,e);
  }
  return true;
}",0.447821681864235
173024,"@Override public void run(){
  LOG.log(Level.INFO,""String_Node_Str"");
  for (int i=0; i < 1000; i++) {
    IntData data=generateData();
    while (!broadcast.send(NO_OF_TASKS,data,0)) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    sendCount++;
    Thread.yield();
  }
  status=Status.MAP_FINISHED;
}","@Override public void run(){
  LOG.log(Level.INFO,""String_Node_Str"");
  for (int i=0; i < 1000; i++) {
    IntData data=generateData();
    data.setId(i);
    while (!broadcast.send(NO_OF_TASKS,data,0)) {
      broadcast.progress();
    }
    sendCount++;
    Thread.yield();
  }
  status=Status.MAP_FINISHED;
}",0.7804878048780488
173025,"protected void releaseTheBuffers(int id,MPIMessage message){
  if (MPIMessageDirection.IN == message.getMessageDirection()) {
    Queue<MPIBuffer> list=receiveBuffers.get(id);
    for (    MPIBuffer buffer : message.getBuffers()) {
      buffer.getByteBuffer().clear();
      if (!list.offer(buffer)) {
        throw new RuntimeException(""String_Node_Str"");
      }
      receiveBufferReleaseCount++;
    }
    if (completionListener != null) {
      completionListener.completed(message.getOriginatingId());
    }
  }
 else   if (MPIMessageDirection.OUT == message.getMessageDirection()) {
    Queue<MPIBuffer> queue=sendBuffers;
    for (    MPIBuffer buffer : message.getBuffers()) {
      buffer.getByteBuffer().clear();
      if (!queue.offer(buffer)) {
        throw new RuntimeException(""String_Node_Str"");
      }
      sendBufferReleaseCount++;
    }
  }
}","protected void releaseTheBuffers(int id,MPIMessage message){
  if (MPIMessageDirection.IN == message.getMessageDirection()) {
    Queue<MPIBuffer> list=receiveBuffers.get(id);
    for (    MPIBuffer buffer : message.getBuffers()) {
      buffer.getByteBuffer().clear();
      if (!list.offer(buffer)) {
        throw new RuntimeException(String.format(""String_Node_Str"",executor,message.getHeader().getDestinationIdentifier()));
      }
      receiveBufferReleaseCount++;
    }
    if (completionListener != null) {
      completionListener.completed(message.getOriginatingId());
    }
  }
 else   if (MPIMessageDirection.OUT == message.getMessageDirection()) {
    ArrayBlockingQueue<MPIBuffer> queue=(ArrayBlockingQueue<MPIBuffer>)sendBuffers;
    for (    MPIBuffer buffer : message.getBuffers()) {
      buffer.getByteBuffer().clear();
      if (!queue.offer(buffer)) {
        String s=""String_Node_Str"";
        for (        Map.Entry<Integer,Queue<MPIBuffer>> e : receiveBuffers.entrySet()) {
          s+=e.getKey() + ""String_Node_Str"" + e.getValue().size()+ ""String_Node_Str"";
        }
        LOG.info(String.format(""String_Node_Str"",executor,sendCount,receiveCount,sendBufferReleaseCount,receiveBufferReleaseCount,s,sendsOfferred,sendsPartialOfferred));
        ((TWSMPIChannel)channel).setDebug(true);
        throw new RuntimeException(String.format(""String_Node_Str"",executor,message.getOriginatingId(),queue.size(),queue.remainingCapacity()));
      }
      sendBufferReleaseCount++;
    }
  }
}",0.7062289562289562
173026,"/** 
 * Progress the communications that are pending
 */
public void progress(){
  while (pendingSends.size() > 0) {
    MPISendRequests sendRequests=pendingSends.poll();
    if (sendRequests != null) {
      postMessage(sendRequests);
      waitForCompletionSends.add(sendRequests);
    }
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    if (debug) {
      LOG.info(String.format(""String_Node_Str"",executor,receiveRequests.rank,receiveRequests.availableBuffers.size(),receiveRequests.availableBuffers.peek()));
    }
    if (receiveRequests.availableBuffers.size() > 0) {
      postReceive(receiveRequests);
    }
  }
  Iterator<MPISendRequests> sendRequestsIterator=waitForCompletionSends.iterator();
  while (sendRequestsIterator.hasNext()) {
    MPISendRequests sendRequests=sendRequestsIterator.next();
    Iterator<MPIRequest> requestIterator=sendRequests.pendingSends.iterator();
    while (requestIterator.hasNext()) {
      MPIRequest r=requestIterator.next();
      try {
        Status status=r.request.testStatus();
        if (status != null) {
          completedSendCount++;
          requestIterator.remove();
        }
      }
 catch (      MPIException e) {
        throw new RuntimeException(""String_Node_Str"" + sendRequests.rank,e);
      }
    }
    if (sendRequests.pendingSends.size() == 0) {
      sendRequests.callback.onSendComplete(sendRequests.rank,sendRequests.edge,sendRequests.message);
      sendRequestsIterator.remove();
    }
  }
  if (false) {
    LOG.info(String.format(""String_Node_Str"",executor,sendCount,completedSendCount,receiveCount,pendingReceiveCount,pendingSends.size(),waitForCompletionSends.size()));
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    try {
      Iterator<MPIRequest> requestIterator=receiveRequests.pendingRequests.iterator();
      while (requestIterator.hasNext()) {
        MPIRequest r=requestIterator.next();
        Status status=r.request.testStatus();
        if (status != null) {
          if (!status.isCancelled()) {
            ++receiveCount;
            r.buffer.setSize(status.getCount(MPI.BYTE));
            receiveRequests.callback.onReceiveComplete(receiveRequests.rank,receiveRequests.edge,r.buffer);
            requestIterator.remove();
          }
 else {
            throw new RuntimeException(""String_Node_Str"");
          }
        }
      }
    }
 catch (    MPIException e) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
}","/** 
 * Progress the communications that are pending
 */
public void progress(){
  while (pendingSends.size() > 0) {
    MPISendRequests sendRequests=pendingSends.poll();
    if (sendRequests != null) {
      postMessage(sendRequests);
      waitForCompletionSends.add(sendRequests);
    }
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    if (debug) {
      LOG.info(String.format(""String_Node_Str"",executor,receiveRequests.rank,receiveRequests.availableBuffers.size(),receiveRequests.availableBuffers.peek()));
    }
    if (receiveRequests.availableBuffers.size() > 0) {
      postReceive(receiveRequests);
    }
  }
  Iterator<MPISendRequests> sendRequestsIterator=waitForCompletionSends.iterator();
  boolean canProgress=true;
  while (sendRequestsIterator.hasNext() && canProgress) {
    MPISendRequests sendRequests=sendRequestsIterator.next();
    Iterator<MPIRequest> requestIterator=sendRequests.pendingSends.iterator();
    while (requestIterator.hasNext()) {
      MPIRequest r=requestIterator.next();
      try {
        Status status=r.request.testStatus();
        if (status != null) {
          completedSendCount++;
          requestIterator.remove();
        }
 else {
          canProgress=false;
          break;
        }
      }
 catch (      MPIException e) {
        throw new RuntimeException(""String_Node_Str"" + sendRequests.rank,e);
      }
    }
    if (sendRequests.pendingSends.size() == 0) {
      sendRequests.callback.onSendComplete(sendRequests.rank,sendRequests.edge,sendRequests.message);
      sendRequestsIterator.remove();
    }
  }
  if (false) {
    LOG.info(String.format(""String_Node_Str"",executor,sendCount,completedSendCount,receiveCount,pendingReceiveCount,pendingSends.size(),waitForCompletionSends.size()));
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    try {
      Iterator<MPIRequest> requestIterator=receiveRequests.pendingRequests.iterator();
      while (requestIterator.hasNext()) {
        MPIRequest r=requestIterator.next();
        Status status=r.request.testStatus();
        if (status != null) {
          if (!status.isCancelled()) {
            ++receiveCount;
            r.buffer.setSize(status.getCount(MPI.BYTE));
            receiveRequests.callback.onReceiveComplete(receiveRequests.rank,receiveRequests.edge,r.buffer);
            requestIterator.remove();
          }
 else {
            throw new RuntimeException(""String_Node_Str"");
          }
        }
 else {
          break;
        }
      }
    }
 catch (    MPIException e) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
}",0.973829708809436
173027,"@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  this.executor=op.getTaskPlan().getThisExecutor();
  this.operation=op;
  this.sendPendingMax=MPIContext.sendPendingMax(cfg);
  this.reducedValues=new ArrayBlockingQueue<>(sendPendingMax);
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,Queue<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    Map<Integer,Integer> totalCountsPerTask=new HashMap<>();
    for (    int i : e.getValue()) {
      messagesPerTask.put(i,new ArrayBlockingQueue<>(sendPendingMax * 4));
      countsPerTask.put(i,0);
      totalCountsPerTask.put(i,0);
    }
    LOG.fine(String.format(""String_Node_Str"",executor,e.getKey(),e.getValue().toString()));
    messages.put(e.getKey(),messagesPerTask);
    counts.put(e.getKey(),countsPerTask);
    totalCounts.put(e.getKey(),totalCountsPerTask);
  }
}","@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  this.executor=op.getTaskPlan().getThisExecutor();
  this.operation=op;
  this.sendPendingMax=MPIContext.sendPendingMax(cfg);
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,Queue<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    Map<Integer,Integer> totalCountsPerTask=new HashMap<>();
    for (    int i : e.getValue()) {
      messagesPerTask.put(i,new ArrayBlockingQueue<>(sendPendingMax));
      countsPerTask.put(i,0);
      totalCountsPerTask.put(i,0);
    }
    LOG.fine(String.format(""String_Node_Str"",executor,e.getKey(),e.getValue().toString()));
    reducedValuesMap.put(e.getKey(),new ArrayBlockingQueue<>(sendPendingMax));
    messages.put(e.getKey(),messagesPerTask);
    counts.put(e.getKey(),countsPerTask);
    totalCounts.put(e.getKey(),totalCountsPerTask);
  }
}",0.9246646026831784
173028,"@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  Queue<Object> m=messages.get(target).get(source);
  Integer c=counts.get(target).get(source);
  if (m.size() >= sendPendingMax * 4) {
    canAdd=false;
    onMessageAttempts++;
  }
 else {
    onMessageAttempts=0;
    m.offer(object);
    counts.get(target).put(source,c + 1);
    Integer tc=totalCounts.get(target).get(source);
    totalCounts.get(target).put(source,tc + 1);
  }
  return canAdd;
}","@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  Queue<Object> m=messages.get(target).get(source);
  Integer c=counts.get(target).get(source);
  if (m.size() >= sendPendingMax) {
    canAdd=false;
    onMessageAttempts++;
  }
 else {
    onMessageAttempts=0;
    m.offer(object);
    counts.get(target).put(source,c + 1);
    Integer tc=totalCounts.get(target).get(source);
    totalCounts.get(target).put(source,tc + 1);
  }
  return canAdd;
}",0.9961089494163424
173029,"@Override public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    Map<Integer,Queue<Object>> messagePerTarget=messages.get(t);
    Map<Integer,Integer> countsPerTarget=counts.get(t);
    Map<Integer,Integer> totalCountMap=totalCounts.get(t);
    while (canProgress) {
      boolean found=true;
      for (      Map.Entry<Integer,Queue<Object>> e : messagePerTarget.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
      }
      if (found && reducedValues.size() < sendPendingMax) {
        Object previous=null;
        for (        Map.Entry<Integer,Queue<Object>> e : messagePerTarget.entrySet()) {
          if (previous == null) {
            previous=e.getValue().poll();
          }
 else {
            Object current=e.getValue().poll();
            previous=reduceFunction.reduce(previous,current);
          }
        }
        if (previous != null) {
          reducedValues.offer(previous);
        }
        progressAttempts=0;
      }
 else {
        progressAttempts++;
      }
      if (reducedValues.size() > 0) {
        Object previous=reducedValues.peek();
        boolean handle=handleMessage(t,previous,0,destination);
        if (handle) {
          reducedValues.poll();
          for (          Map.Entry<Integer,Integer> e : countsPerTarget.entrySet()) {
            Integer i=e.getValue();
            countsPerTarget.put(e.getKey(),i - 1);
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}","@Override public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    Map<Integer,Queue<Object>> messagePerTarget=messages.get(t);
    Map<Integer,Integer> countsPerTarget=counts.get(t);
    Map<Integer,Integer> totalCountMap=totalCounts.get(t);
    Queue<Object> reducedValues=this.reducedValuesMap.get(t);
    while (canProgress) {
      boolean found=true;
      for (      Map.Entry<Integer,Queue<Object>> e : messagePerTarget.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
      }
      if (found && reducedValues.size() < sendPendingMax) {
        Object previous=null;
        for (        Map.Entry<Integer,Queue<Object>> e : messagePerTarget.entrySet()) {
          if (previous == null) {
            previous=e.getValue().poll();
          }
 else {
            Object current=e.getValue().poll();
            previous=reduceFunction.reduce(previous,current);
          }
        }
        if (previous != null) {
          reducedValues.offer(previous);
        }
        progressAttempts=0;
      }
 else {
        progressAttempts++;
      }
      if (reducedValues.size() > 0) {
        Object previous=reducedValues.peek();
        boolean handle=handleMessage(t,previous,0,destination);
        if (handle) {
          reducedValues.poll();
          for (          Map.Entry<Integer,Integer> e : countsPerTarget.entrySet()) {
            Integer i=e.getValue();
            countsPerTarget.put(e.getKey(),i - 1);
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}",0.5379786566227244
173030,"@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  executor=op.getTaskPlan().getThisExecutor();
  sendPendingMax=MPIContext.sendPendingMax(cfg);
  isStoreBased=false;
  LOG.fine(String.format(""String_Node_Str"",executor,expectedIds));
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,List<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Boolean> finishedPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    for (    int i : e.getValue()) {
      messagesPerTask.put(i,new ArrayList<Object>());
      finishedPerTask.put(i,false);
      countsPerTask.put(i,0);
    }
    messages.put(e.getKey(),messagesPerTask);
    finished.put(e.getKey(),finishedPerTask);
    finalMessages.put(e.getKey(),new ArrayList<>());
    counts.put(e.getKey(),countsPerTask);
    batchDone.put(e.getKey(),false);
  }
  this.memoryManagers=new HashMap<>();
  this.dataFlowOperation=op;
  this.executor=dataFlowOperation.getTaskPlan().getThisExecutor();
  this.gatherBatchReceiver.init(cfg,op,expectedIds);
}","@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  executor=op.getTaskPlan().getThisExecutor();
  sendPendingMax=MPIContext.sendPendingMax(cfg);
  isStoreBased=false;
  LOG.fine(String.format(""String_Node_Str"",executor,expectedIds));
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,Queue<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Boolean> finishedPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    for (    int i : e.getValue()) {
      messagesPerTask.put(i,new ArrayBlockingQueue<>(sendPendingMax));
      finishedPerTask.put(i,false);
      countsPerTask.put(i,0);
    }
    messages.put(e.getKey(),messagesPerTask);
    finished.put(e.getKey(),finishedPerTask);
    finalMessages.put(e.getKey(),new ArrayList<>());
    counts.put(e.getKey(),countsPerTask);
    batchDone.put(e.getKey(),false);
  }
  this.memoryManagers=new HashMap<>();
  this.dataFlowOperation=op;
  this.executor=dataFlowOperation.getTaskPlan().getThisExecutor();
  this.gatherBatchReceiver.init(cfg,op,expectedIds);
}",0.9768477292965272
173031,"@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  List<Object> m=messages.get(target).get(source);
  Map<Integer,Boolean> finishedMessages=finished.get(target);
  if (m.size() > sendPendingMax) {
    canAdd=false;
  }
 else {
    if (object instanceof MPIMessage) {
      ((MPIMessage)object).incrementRefCount();
    }
 else     if (object instanceof OperationMemoryManager) {
      isStoreBased=true;
      memoryManagers.put(target,(OperationMemoryManager)object);
    }
    Integer c=counts.get(target).get(source);
    counts.get(target).put(source,c + 1);
    if (!isStoreBased) {
      m.add(object);
    }
    if ((flags & MessageFlags.FLAGS_LAST) == MessageFlags.FLAGS_LAST) {
      finishedMessages.put(source,true);
    }
  }
  return canAdd;
}","@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  Queue<Object> m=messages.get(target).get(source);
  Map<Integer,Boolean> finishedMessages=finished.get(target);
  if (m.size() >= sendPendingMax) {
    canAdd=false;
  }
 else {
    if (object instanceof MPIMessage) {
      ((MPIMessage)object).incrementRefCount();
    }
 else     if (object instanceof OperationMemoryManager) {
      isStoreBased=true;
      memoryManagers.put(target,(OperationMemoryManager)object);
    }
    Integer c=counts.get(target).get(source);
    counts.get(target).put(source,c + 1);
    if (!isStoreBased) {
      m.add(object);
    }
    if ((flags & MessageFlags.FLAGS_LAST) == MessageFlags.FLAGS_LAST) {
      finishedMessages.put(source,true);
    }
  }
  return canAdd;
}",0.993924665856622
173032,"/** 
 * Method used to progress work
 */
public void progress(){
  for (  int t : messages.keySet()) {
    if (batchDone.get(t)) {
      continue;
    }
    boolean allFinished=true;
    Map<Integer,List<Object>> map=messages.get(t);
    Map<Integer,Boolean> finishedForTarget=finished.get(t);
    Map<Integer,Integer> countMap=counts.get(t);
    if (!isStoreBased) {
      boolean found=true;
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        if (e.getValue().size() == 0 && !finishedForTarget.get(e.getKey())) {
          found=false;
        }
        if (!finishedForTarget.get(e.getKey())) {
          allFinished=false;
        }
      }
      if (found) {
        List<Object> out=new ArrayList<>();
        for (        Map.Entry<Integer,List<Object>> e : map.entrySet()) {
          List<Object> valueList=e.getValue();
          if (valueList.size() > 0) {
            Object value=valueList.get(0);
            out.add(value);
            allFinished=false;
            valueList.remove(0);
          }
        }
        finalMessages.get(t).addAll(out);
      }
 else {
        allFinished=false;
      }
    }
 else {
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        if (!finishedForTarget.get(e.getKey())) {
          allFinished=false;
        }
      }
    }
    if (allFinished) {
      batchDone.put(t,true);
      if (!isStoreBased) {
        gatherBatchReceiver.receive(t,finalMessages.get(t).iterator());
      }
 else {
        gatherBatchReceiver.receive(t,memoryManagers.get(t).iterator());
      }
    }
  }
}","/** 
 * Method used to progress work
 */
public void progress(){
  for (  int t : messages.keySet()) {
    if (batchDone.get(t)) {
      continue;
    }
    boolean allFinished=true;
    Map<Integer,Queue<Object>> map=messages.get(t);
    Map<Integer,Boolean> finishedForTarget=finished.get(t);
    Map<Integer,Integer> countMap=counts.get(t);
    if (!isStoreBased) {
      boolean found=true;
      for (      Map.Entry<Integer,Queue<Object>> e : map.entrySet()) {
        if (e.getValue().size() == 0 && !finishedForTarget.get(e.getKey())) {
          found=false;
        }
        if (!finishedForTarget.get(e.getKey())) {
          allFinished=false;
        }
      }
      if (found) {
        List<Object> out=new ArrayList<>();
        for (        Map.Entry<Integer,Queue<Object>> e : map.entrySet()) {
          Queue<Object> valueList=e.getValue();
          if (valueList.size() > 0) {
            Object value=valueList.poll();
            out.add(value);
            allFinished=false;
          }
        }
        finalMessages.get(t).addAll(out);
      }
 else {
        allFinished=false;
      }
    }
 else {
      for (      Map.Entry<Integer,Queue<Object>> e : map.entrySet()) {
        if (!finishedForTarget.get(e.getKey())) {
          allFinished=false;
        }
      }
    }
    if (allFinished) {
      batchDone.put(t,true);
      if (!isStoreBased) {
        gatherBatchReceiver.receive(t,finalMessages.get(t).iterator());
      }
 else {
        gatherBatchReceiver.receive(t,memoryManagers.get(t).iterator());
      }
    }
  }
}",0.9721342621912604
173033,"@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  executor=op.getTaskPlan().getThisExecutor();
  sendPendingMax=MPIContext.sendPendingMax(cfg);
  LOG.fine(String.format(""String_Node_Str"",executor,expectedIds));
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,List<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Boolean> finishedPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    for (    int i : e.getValue()) {
      messagesPerTask.put(i,new ArrayList<Object>());
      finishedPerTask.put(i,false);
      countsPerTask.put(i,0);
    }
    messages.put(e.getKey(),messagesPerTask);
    finished.put(e.getKey(),finishedPerTask);
    counts.put(e.getKey(),countsPerTask);
    batchDone.put(e.getKey(),false);
  }
  this.dataFlowOperation=op;
  this.executor=dataFlowOperation.getTaskPlan().getThisExecutor();
}","@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  executor=op.getTaskPlan().getThisExecutor();
  sendPendingMax=MPIContext.sendPendingMax(cfg);
  LOG.fine(String.format(""String_Node_Str"",executor,expectedIds));
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,Queue<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Boolean> finishedPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    for (    int i : e.getValue()) {
      messagesPerTask.put(i,new ArrayBlockingQueue<>(sendPendingMax));
      finishedPerTask.put(i,false);
      countsPerTask.put(i,0);
    }
    messages.put(e.getKey(),messagesPerTask);
    finished.put(e.getKey(),finishedPerTask);
    counts.put(e.getKey(),countsPerTask);
    batchDone.put(e.getKey(),false);
  }
  this.dataFlowOperation=op;
  this.executor=dataFlowOperation.getTaskPlan().getThisExecutor();
}",0.9728033472803348
173034,"@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  if (messages.get(target) == null) {
    throw new RuntimeException(String.format(""String_Node_Str"",executor,target));
  }
  List<Object> m=messages.get(target).get(source);
  Map<Integer,Boolean> finishedMessages=finished.get(target);
  if (m.size() > sendPendingMax) {
    canAdd=false;
  }
 else {
    if (object instanceof MPIMessage) {
      ((MPIMessage)object).incrementRefCount();
    }
    Integer c=counts.get(target).get(source);
    counts.get(target).put(source,c + 1);
    m.add(object);
    if ((flags & MessageFlags.FLAGS_LAST) == MessageFlags.FLAGS_LAST) {
      finishedMessages.put(source,true);
    }
  }
  return canAdd;
}","@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  if (messages.get(target) == null) {
    throw new RuntimeException(String.format(""String_Node_Str"",executor,target));
  }
  Queue<Object> m=messages.get(target).get(source);
  Map<Integer,Boolean> finishedMessages=finished.get(target);
  if (m.size() >= sendPendingMax) {
    canAdd=false;
  }
 else {
    if (object instanceof MPIMessage) {
      ((MPIMessage)object).incrementRefCount();
    }
    Integer c=counts.get(target).get(source);
    counts.get(target).put(source,c + 1);
    m.add(object);
    if ((flags & MessageFlags.FLAGS_LAST) == MessageFlags.FLAGS_LAST) {
      finishedMessages.put(source,true);
    }
  }
  return canAdd;
}",0.993421052631579
173035,"@Override public void progress(){
  for (  int t : messages.keySet()) {
    if (batchDone.get(t)) {
      continue;
    }
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,List<Object>> map=messages.get(t);
      Map<Integer,Boolean> finishedForTarget=finished.get(t);
      Map<Integer,Integer> countMap=counts.get(t);
      boolean found=true;
      boolean allFinished=true;
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        if (e.getValue().size() == 0 && !finishedForTarget.get(e.getKey())) {
          found=false;
          canProgress=false;
        }
        if (!finishedForTarget.get(e.getKey())) {
          allFinished=false;
        }
      }
      if (found) {
        List<Object> out=new ArrayList<>();
        for (        Map.Entry<Integer,List<Object>> e : map.entrySet()) {
          List<Object> valueList=e.getValue();
          if (valueList.size() > 0) {
            Object value=valueList.get(0);
            out.add(value);
          }
        }
        int flags=0;
        if (allFinished) {
          boolean last=true;
          for (          Map.Entry<Integer,List<Object>> e : map.entrySet()) {
            List<Object> valueList=e.getValue();
            if (valueList.size() > 1) {
              last=false;
            }
          }
          if (last) {
            flags=MessageFlags.FLAGS_LAST;
          }
        }
        if (dataFlowOperation.sendPartial(t,out,flags,destination)) {
          boolean allZero=true;
          for (          Map.Entry<Integer,List<Object>> e : map.entrySet()) {
            List<Object> value=e.getValue();
            if (value.size() > 0) {
              value.remove(0);
            }
            if (value.size() != 0) {
              allZero=false;
            }
          }
          for (          Map.Entry<Integer,Integer> e : countMap.entrySet()) {
            Integer i=e.getValue();
            e.setValue(i - 1);
          }
          if (allFinished && allZero) {
            batchDone.put(t,true);
            break;
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}","@Override public void progress(){
  for (  int t : messages.keySet()) {
    if (batchDone.get(t)) {
      continue;
    }
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,Queue<Object>> map=messages.get(t);
      Map<Integer,Boolean> finishedForTarget=finished.get(t);
      Map<Integer,Integer> countMap=counts.get(t);
      boolean found=true;
      boolean allFinished=true;
      for (      Map.Entry<Integer,Queue<Object>> e : map.entrySet()) {
        if (e.getValue().size() == 0 && !finishedForTarget.get(e.getKey())) {
          found=false;
          canProgress=false;
        }
        if (!finishedForTarget.get(e.getKey())) {
          allFinished=false;
        }
      }
      if (found) {
        List<Object> out=new ArrayList<>();
        for (        Map.Entry<Integer,Queue<Object>> e : map.entrySet()) {
          Queue<Object> valueList=e.getValue();
          if (valueList.size() > 0) {
            Object value=valueList.peek();
            out.add(value);
          }
        }
        int flags=0;
        if (allFinished) {
          boolean last=true;
          for (          Map.Entry<Integer,Queue<Object>> e : map.entrySet()) {
            Queue<Object> valueList=e.getValue();
            if (valueList.size() > 1) {
              last=false;
            }
          }
          if (last) {
            flags=MessageFlags.FLAGS_LAST;
          }
        }
        if (dataFlowOperation.sendPartial(t,out,flags,destination)) {
          boolean allZero=true;
          for (          Map.Entry<Integer,Queue<Object>> e : map.entrySet()) {
            Queue<Object> value=e.getValue();
            if (value.size() > 0) {
              value.poll();
            }
            if (value.size() != 0) {
              allZero=false;
            }
          }
          for (          Map.Entry<Integer,Integer> e : countMap.entrySet()) {
            Integer i=e.getValue();
            e.setValue(i - 1);
          }
          if (allFinished && allZero) {
            batchDone.put(t,true);
            break;
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}",0.9779223797350686
173036,"public AllGatherStreamingFinalReceiver(MPIDataFlowBroadcast broadcast){
  this.broadcast=broadcast;
}","public AllGatherStreamingFinalReceiver(MPIDataFlowBroadcast broadcast,GatherBatchReceiver gatherRecvr){
  super(gatherRecvr);
  this.broadcast=broadcast;
}",0.7890625
173037,"private void receiveDeserializeProgress(MPIMessage currentMessage,int receiveId){
  if (currentMessage == null) {
    return;
  }
  int id=currentMessage.getOriginatingId();
  if (isStoreBased && isLastReceiver) {
    LOG.info(""String_Node_Str"");
    writeToMemoryManager(currentMessage,receiveId);
    currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
    if (!receiver.receiveMessage(currentMessage,operationMemoryManager)) {
      return;
    }
  }
 else {
    Object object=messageDeSerializer.get(receiveId).build(currentMessage,currentMessage.getHeader().getEdge());
    Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=pendingReceiveMessagesPerSource.get(id);
    currentMessage.setReceivedState(MPIMessage.ReceivedState.INIT);
    if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
      throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
    }
  }
}","private void receiveDeserializeProgress(MPIMessage currentMessage,int receiveId){
  if (currentMessage == null) {
    return;
  }
  int id=currentMessage.getOriginatingId();
  if (isStoreBased && isLastReceiver) {
    writeToMemoryManager(currentMessage,receiveId);
    currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
    if (!receiver.receiveMessage(currentMessage,operationMemoryManager)) {
      return;
    }
  }
 else {
    Object object=messageDeSerializer.get(receiveId).build(currentMessage,currentMessage.getHeader().getEdge());
    Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=pendingReceiveMessagesPerSource.get(id);
    currentMessage.setReceivedState(MPIMessage.ReceivedState.INIT);
    if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
      throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
    }
  }
}",0.9823056300268096
173038,"/** 
 * Desetrialize
 */
public static Pair<Object,Integer> deserializeKey(MessageType keyType,List<MPIBuffer> buffers,KryoSerializer serializer){
  int currentIndex=0;
  int keyLength=0;
  Object key=null;
switch (keyType) {
case INTEGER:
    currentIndex=getReadIndex(buffers,currentIndex,4);
  ByteBuffer byteBuffer=buffers.get(currentIndex).getByteBuffer();
LOG.info(String.format(""String_Node_Str"",byteBuffer.position()));
key=byteBuffer.getInt();
keyLength=4;
break;
case SHORT:
currentIndex=getReadIndex(buffers,currentIndex,2);
key=buffers.get(currentIndex).getByteBuffer().getShort();
keyLength=2;
break;
case LONG:
currentIndex=getReadIndex(buffers,currentIndex,8);
key=buffers.get(currentIndex).getByteBuffer().getInt();
keyLength=8;
break;
case DOUBLE:
currentIndex=getReadIndex(buffers,currentIndex,8);
key=buffers.get(currentIndex).getByteBuffer().getInt();
keyLength=8;
break;
case OBJECT:
currentIndex=getReadIndex(buffers,currentIndex,4);
keyLength=buffers.get(currentIndex).getByteBuffer().getInt();
key=DataDeserializer.deserializeObject(buffers,keyLength,serializer);
break;
case BYTE:
currentIndex=getReadIndex(buffers,currentIndex,4);
keyLength=buffers.get(currentIndex).getByteBuffer().getInt();
key=readBytes(buffers,keyLength);
break;
case STRING:
currentIndex=getReadIndex(buffers,currentIndex,4);
keyLength=buffers.get(currentIndex).getByteBuffer().getInt();
key=new String(readBytes(buffers,keyLength));
break;
default :
break;
}
return new ImmutablePair<>(key,keyLength);
}","/** 
 * Desetrialize
 */
public static Pair<Object,Integer> deserializeKey(MessageType keyType,List<MPIBuffer> buffers,KryoSerializer serializer){
  int currentIndex=0;
  int keyLength=0;
  Object key=null;
switch (keyType) {
case INTEGER:
    currentIndex=getReadIndex(buffers,currentIndex,4);
  ByteBuffer byteBuffer=buffers.get(currentIndex).getByteBuffer();
key=byteBuffer.getInt();
keyLength=4;
break;
case SHORT:
currentIndex=getReadIndex(buffers,currentIndex,2);
key=buffers.get(currentIndex).getByteBuffer().getShort();
keyLength=2;
break;
case LONG:
currentIndex=getReadIndex(buffers,currentIndex,8);
key=buffers.get(currentIndex).getByteBuffer().getInt();
keyLength=8;
break;
case DOUBLE:
currentIndex=getReadIndex(buffers,currentIndex,8);
key=buffers.get(currentIndex).getByteBuffer().getInt();
keyLength=8;
break;
case OBJECT:
currentIndex=getReadIndex(buffers,currentIndex,4);
keyLength=buffers.get(currentIndex).getByteBuffer().getInt();
key=DataDeserializer.deserializeObject(buffers,keyLength,serializer);
break;
case BYTE:
currentIndex=getReadIndex(buffers,currentIndex,4);
keyLength=buffers.get(currentIndex).getByteBuffer().getInt();
key=readBytes(buffers,keyLength);
break;
case STRING:
currentIndex=getReadIndex(buffers,currentIndex,4);
keyLength=buffers.get(currentIndex).getByteBuffer().getInt();
key=new String(readBytes(buffers,keyLength));
break;
default :
break;
}
return new ImmutablePair<>(key,keyLength);
}",0.9775357385976856
173039,"public static DataMessageType toDataMessageType(MessageType a){
switch (a) {
case INTEGER:
    return DataMessageType.INTEGER;
case CHAR:
  return DataMessageType.CHAR;
case BYTE:
return DataMessageType.BYTE;
case STRING:
return DataMessageType.STRING;
case LONG:
return DataMessageType.LONG;
case DOUBLE:
return DataMessageType.DOUBLE;
case OBJECT:
return DataMessageType.DOUBLE;
case BUFFER:
return DataMessageType.BUFFER;
case EMPTY:
return DataMessageType.EMPTY;
case SHORT:
return DataMessageType.SHORT;
default :
throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
}
}","public static DataMessageType toDataMessageType(MessageType a){
switch (a) {
case INTEGER:
    return DataMessageType.INTEGER;
case CHAR:
  return DataMessageType.CHAR;
case BYTE:
return DataMessageType.BYTE;
case STRING:
return DataMessageType.STRING;
case LONG:
return DataMessageType.LONG;
case DOUBLE:
return DataMessageType.DOUBLE;
case OBJECT:
return DataMessageType.OBJECT;
case BUFFER:
return DataMessageType.BUFFER;
case EMPTY:
return DataMessageType.EMPTY;
case SHORT:
return DataMessageType.SHORT;
default :
throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
}
}",0.9898132427843804
173040,"private void receiveDeserializeProgress(MPIMessage currentMessage,int receiveId){
  if (currentMessage == null) {
    return;
  }
  int id=currentMessage.getOriginatingId();
  if (isStoreBased && isLastReceiver) {
    writeToMemoryManager(currentMessage,receiveId);
    currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
    if (!receiver.receiveMessage(currentMessage,operationMemoryManager)) {
      return;
    }
  }
 else {
    Object object=messageDeSerializer.get(receiveId).build(currentMessage,currentMessage.getHeader().getEdge());
    Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=pendingReceiveMessagesPerSource.get(id);
    currentMessage.setReceivedState(MPIMessage.ReceivedState.INIT);
    if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
      throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
    }
  }
}","private void receiveDeserializeProgress(MPIMessage currentMessage,int receiveId){
  if (currentMessage == null) {
    return;
  }
  int id=currentMessage.getOriginatingId();
  if (isStoreBased && isLastReceiver) {
    writeToMemoryManager(currentMessage,receiveId);
    currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
    if (!receiver.receiveMessage(currentMessage,operationMemoryManager)) {
      return;
    }
    currentMessage.incrementRefCount();
    currentMessage.release();
  }
 else {
    Object object=messageDeSerializer.get(receiveId).build(currentMessage,currentMessage.getHeader().getEdge());
    Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=pendingReceiveMessagesPerSource.get(id);
    currentMessage.setReceivedState(MPIMessage.ReceivedState.INIT);
    if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
      throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
    }
  }
}",0.9631966351209252
173041,"public void setStoreBased(boolean storeBased){
  isStoreBased=storeBased;
  if (isStoreBased) {
    opertionID=(int)System.currentTimeMillis();
    this.kryoSerializer=new KryoSerializer();
    Path dataPath=new Path(""String_Node_Str"");
    this.memoryManager=new LMDBMemoryManager(dataPath);
    if (!isKeyed) {
      this.operationMemoryManager=memoryManager.addOperation(opertionID,MessageTypeConverter.toDataMessageType(type));
    }
 else {
      this.operationMemoryManager=memoryManager.addOperation(opertionID,MessageTypeConverter.toDataMessageType(type),MessageTypeConverter.toDataMessageType(keyType));
    }
  }
}","public void setStoreBased(boolean storeBased){
  isStoreBased=storeBased;
  if (isStoreBased) {
    opertionID=(int)System.currentTimeMillis();
    this.kryoSerializer=new KryoSerializer();
    Path dataPath=new Path(""String_Node_Str"" + this.executor);
    this.memoryManager=new LMDBMemoryManager(dataPath);
    if (!isKeyed) {
      this.operationMemoryManager=memoryManager.addOperation(opertionID,MessageTypeConverter.toDataMessageType(type));
    }
 else {
      this.operationMemoryManager=memoryManager.addOperation(opertionID,MessageTypeConverter.toDataMessageType(type),MessageTypeConverter.toDataMessageType(keyType));
    }
  }
}",0.9873417721518988
173042,"@Override public Object getDataBuffers(Object partialObject,int edge){
  MPIMessage currentMessage=(MPIMessage)partialObject;
  MessageType type=currentMessage.getType();
  if (!keyed) {
    return DataDeserializer.getAsByteBuffer(currentMessage.getBuffers(),currentMessage.getHeader().getLength(),type);
  }
 else {
    Pair<Integer,ByteBuffer> keyPair=KeyDeserializer.getKeyAsByteBuffer(currentMessage.getKeyType(),currentMessage.getBuffers());
    ByteBuffer data=DataDeserializer.getAsByteBuffer(currentMessage.getBuffers(),currentMessage.getHeader().getLength() - keyPair.getKey(),type);
    return new ImmutablePair<>(keyPair.getValue(),data);
  }
}","@Override public Object getDataBuffers(Object partialObject,int edge){
  MPIMessage currentMessage=(MPIMessage)partialObject;
  MessageType type=currentMessage.getType();
  if (!keyed) {
    return DataDeserializer.getAsByteBuffer(currentMessage.getBuffers(),currentMessage.getHeader().getLength(),type);
  }
 else {
    Pair<Integer,ByteBuffer> keyPair=KeyDeserializer.getKeyAsByteBuffer(currentMessage.getKeyType(),currentMessage.getBuffers());
    MessageType keyType=currentMessage.getKeyType();
    ByteBuffer data;
    if (keyType == MessageType.BUFFER || keyType == MessageType.STRING || keyType == MessageType.BYTE || keyType == MessageType.OBJECT) {
      data=DataDeserializer.getAsByteBuffer(currentMessage.getBuffers(),currentMessage.getHeader().getLength() - keyPair.getKey() - 4,type);
    }
 else {
      data=DataDeserializer.getAsByteBuffer(currentMessage.getBuffers(),currentMessage.getHeader().getLength() - keyPair.getKey(),type);
    }
    return new ImmutablePair<>(keyPair.getValue(),data);
  }
}",0.7825567502986858
173043,"private Object buildMessage(MPIMessage message){
  MessageType type=message.getType();
  if (!keyed) {
    return DataDeserializer.deserializeData(message.getBuffers(),message.getHeader().getLength(),serializer,type);
  }
 else {
    Pair<Object,Integer> keyPair=KeyDeserializer.deserializeKey(message.getKeyType(),message.getBuffers(),serializer);
    return DataDeserializer.deserializeData(message.getBuffers(),message.getHeader().getLength() - keyPair.getValue(),serializer,type);
  }
}","private Object buildMessage(MPIMessage message){
  MessageType type=message.getType();
  if (!keyed) {
    return DataDeserializer.deserializeData(message.getBuffers(),message.getHeader().getLength(),serializer,type);
  }
 else {
    Pair<Object,Integer> keyPair=KeyDeserializer.deserializeKey(message.getKeyType(),message.getBuffers(),serializer);
    MessageType keyType=message.getKeyType();
    if (keyType == MessageType.BUFFER || keyType == MessageType.STRING || keyType == MessageType.BYTE || keyType == MessageType.OBJECT) {
      return DataDeserializer.deserializeData(message.getBuffers(),message.getHeader().getLength() - keyPair.getValue() - 4,serializer,type);
    }
 else {
      return DataDeserializer.deserializeData(message.getBuffers(),message.getHeader().getLength() - keyPair.getValue(),serializer,type);
    }
  }
}",0.7379518072289156
173044,"/** 
 * Serialized the message into the buffer
 * @param payload
 * @param sendMessage
 * @param buffer
 * @return true if the message is completely written
 */
private boolean serializeBody(Object payload,MPISendMessage sendMessage,MPIBuffer buffer){
  MessageType type=sendMessage.getMPIMessage().getType();
  if (type == MessageType.OBJECT || type == MessageType.INTEGER || type == MessageType.LONG || type == MessageType.DOUBLE || type == MessageType.BYTE || type == MessageType.STRING) {
    if (!keyed) {
      return serializeData(payload,sendMessage.getSerializationState(),buffer,type);
    }
 else {
      KeyedContent keyedContent=(KeyedContent)payload;
      return serializeKeyedData(keyedContent.getObject(),keyedContent.getSource(),sendMessage.getSerializationState(),buffer,type,keyedContent.getKeyType());
    }
  }
  if (type == MessageType.BUFFER) {
    return serializeBuffer(payload,sendMessage,buffer);
  }
  return false;
}","/** 
 * Serialized the message into the buffer
 * @return true if the message is completely written
 */
private boolean serializeBody(Object payload,MPISendMessage sendMessage,MPIBuffer buffer){
  MessageType type=sendMessage.getMPIMessage().getType();
  if (type == MessageType.OBJECT || type == MessageType.INTEGER || type == MessageType.LONG || type == MessageType.DOUBLE || type == MessageType.BYTE || type == MessageType.STRING) {
    if (!keyed) {
      return serializeData(payload,sendMessage.getSerializationState(),buffer,type);
    }
 else {
      KeyedContent keyedContent=(KeyedContent)payload;
      return serializeKeyedData(keyedContent.getObject(),keyedContent.getSource(),sendMessage.getSerializationState(),buffer,type,keyedContent.getKeyType());
    }
  }
  if (type == MessageType.BUFFER) {
    return serializeBuffer(payload,sendMessage,buffer);
  }
  return false;
}",0.9689373297002724
173045,"@Override public Object getDataBuffers(Object partialObject,int edge){
  MPIMessage currentMessage=(MPIMessage)partialObject;
  int readLength=0;
  int bufferIndex=0;
  List<MPIBuffer> buffers=currentMessage.getBuffers();
  List<Object> returnList=new ArrayList<>();
  MessageHeader header=currentMessage.getHeader();
  if (header == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  while (readLength < header.getLength()) {
    List<MPIBuffer> messageBuffers=new ArrayList<>();
    MPIBuffer mpiBuffer=buffers.get(bufferIndex);
    ByteBuffer byteBuffer=mpiBuffer.getByteBuffer();
    int length=byteBuffer.getInt();
    int tempLength=0;
    int tempBufferIndex=bufferIndex;
    while (tempLength < length) {
      mpiBuffer=buffers.get(tempBufferIndex);
      messageBuffers.add(mpiBuffer);
      tempLength+=mpiBuffer.getByteBuffer().remaining();
      tempBufferIndex++;
    }
    Object object=getSingleDataBuffers(currentMessage,messageBuffers,length);
    readLength+=length + 4;
    if (keyed) {
      readLength+=4;
    }
    byteBuffer=mpiBuffer.getByteBuffer();
    if (byteBuffer.remaining() > 0) {
      bufferIndex=tempBufferIndex - 1;
    }
 else {
      bufferIndex=tempBufferIndex;
    }
    returnList.add(object);
  }
  return returnList;
}","@Override public Object getDataBuffers(Object partialObject,int edge){
  MPIMessage currentMessage=(MPIMessage)partialObject;
  int readLength=0;
  int bufferIndex=0;
  List<MPIBuffer> buffers=currentMessage.getBuffers();
  List<Object> returnList=new ArrayList<>();
  MessageHeader header=currentMessage.getHeader();
  if (header == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  while (readLength < header.getLength()) {
    List<MPIBuffer> messageBuffers=new ArrayList<>();
    MPIBuffer mpiBuffer=buffers.get(bufferIndex);
    ByteBuffer byteBuffer=mpiBuffer.getByteBuffer();
    int length=byteBuffer.getInt();
    int tempLength=0;
    int tempBufferIndex=bufferIndex;
    while (tempLength < length) {
      mpiBuffer=buffers.get(tempBufferIndex);
      messageBuffers.add(mpiBuffer);
      tempLength+=mpiBuffer.getByteBuffer().remaining();
      tempBufferIndex++;
    }
    Object object=getSingleDataBuffers(currentMessage,messageBuffers,length);
    readLength+=length + 4;
    if (keyed && (currentMessage.getKeyType() == MessageType.BUFFER || currentMessage.getKeyType() == MessageType.STRING || currentMessage.getKeyType() == MessageType.BYTE || currentMessage.getKeyType() == MessageType.OBJECT)) {
      readLength+=4;
    }
    byteBuffer=mpiBuffer.getByteBuffer();
    if (byteBuffer.remaining() > 0) {
      bufferIndex=tempBufferIndex - 1;
    }
 else {
      bufferIndex=tempBufferIndex;
    }
    returnList.add(object);
  }
  return returnList;
}",0.9232995658465992
173046,"@Override public Object build(Object partialObject,int edge){
  MPIMessage currentMessage=(MPIMessage)partialObject;
  int readLength=0;
  int bufferIndex=0;
  List<MPIBuffer> buffers=currentMessage.getBuffers();
  List<Object> returnList=new ArrayList<>();
  MessageHeader header=currentMessage.getHeader();
  if (header == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  while (readLength < header.getLength()) {
    List<MPIBuffer> messageBuffers=new ArrayList<>();
    MPIBuffer mpiBuffer=buffers.get(bufferIndex);
    ByteBuffer byteBuffer=mpiBuffer.getByteBuffer();
    int length=byteBuffer.getInt();
    int tempLength=0;
    int tempBufferIndex=bufferIndex;
    while (tempLength < length) {
      mpiBuffer=buffers.get(tempBufferIndex);
      messageBuffers.add(mpiBuffer);
      tempLength+=mpiBuffer.getByteBuffer().remaining();
      tempBufferIndex++;
    }
    Object object=buildMessage(currentMessage,messageBuffers,length);
    readLength+=length + 4;
    if (keyed) {
      readLength+=4;
    }
    byteBuffer=mpiBuffer.getByteBuffer();
    if (byteBuffer.remaining() > 0) {
      bufferIndex=tempBufferIndex - 1;
    }
 else {
      bufferIndex=tempBufferIndex;
    }
    returnList.add(object);
  }
  return returnList;
}","@Override public Object build(Object partialObject,int edge){
  MPIMessage currentMessage=(MPIMessage)partialObject;
  int readLength=0;
  int bufferIndex=0;
  List<MPIBuffer> buffers=currentMessage.getBuffers();
  List<Object> returnList=new ArrayList<>();
  MessageHeader header=currentMessage.getHeader();
  if (header == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  while (readLength < header.getLength()) {
    List<MPIBuffer> messageBuffers=new ArrayList<>();
    MPIBuffer mpiBuffer=buffers.get(bufferIndex);
    ByteBuffer byteBuffer=mpiBuffer.getByteBuffer();
    int length=byteBuffer.getInt();
    int tempLength=0;
    int tempBufferIndex=bufferIndex;
    while (tempLength < length) {
      mpiBuffer=buffers.get(tempBufferIndex);
      messageBuffers.add(mpiBuffer);
      tempLength+=mpiBuffer.getByteBuffer().remaining();
      tempBufferIndex++;
    }
    Object object=buildMessage(currentMessage,messageBuffers,length);
    readLength+=length + 4;
    if (keyed && (currentMessage.getKeyType() == MessageType.BUFFER || currentMessage.getKeyType() == MessageType.STRING || currentMessage.getKeyType() == MessageType.BYTE || currentMessage.getKeyType() == MessageType.OBJECT)) {
      readLength+=4;
    }
    byteBuffer=mpiBuffer.getByteBuffer();
    if (byteBuffer.remaining() > 0) {
      bufferIndex=tempBufferIndex - 1;
    }
 else {
      bufferIndex=tempBufferIndex;
    }
    returnList.add(object);
  }
  return returnList;
}",0.9223443223443224
173047,"public DataFlowOperation direct(Map<String,Object> properties,MessageType type,int edge,Set<Integer> sourceTasks,int destTask,MessageReceiver receiver){
  LOG.info(""String_Node_Str"");
  LOG.info(""String_Node_Str"" + type.toString());
  LOG.info(""String_Node_Str"" + edge);
  LOG.info(""String_Node_Str"" + sourceTasks.size());
  LOG.info(""String_Node_Str"" + sourceTasks.iterator().next());
  LOG.info(""String_Node_Str"" + destTask);
  LOG.info(""String_Node_Str"" + receiver.toString());
  LOG.info(""String_Node_Str"");
  Config mergedCfg=Config.newBuilder().putAll(config).putAll(properties).build();
  MPIDirectDataFlowCommunication dataFlowOperation=new MPIDirectDataFlowCommunication(channel,sourceTasks,destTask,receiver);
  dataFlowOperation.init(mergedCfg,type,instancePlan,edge);
  return dataFlowOperation;
}","public DataFlowOperation direct(Map<String,Object> properties,MessageType type,int edge,Set<Integer> sourceTasks,int destTask,MessageReceiver receiver){
  Config mergedCfg=Config.newBuilder().putAll(config).putAll(properties).build();
  MPIDirectDataFlowCommunication dataFlowOperation=new MPIDirectDataFlowCommunication(channel,sourceTasks,destTask,receiver);
  dataFlowOperation.init(mergedCfg,type,instancePlan,edge);
  return dataFlowOperation;
}",0.7148530579825259
173048,"private void initProgressTrackers(){
  Set<Integer> items=pendingSendMessagesPerSource.keySet();
  LOG.info(String.format(""String_Node_Str"",executor,items));
  sendProgressTracker=new ProgressionTracker(items);
  Set<Integer> items1=pendingReceiveMessagesPerSource.keySet();
  LOG.info(String.format(""String_Node_Str"",executor,items1));
  receiveProgressTracker=new ProgressionTracker(items1);
  Set<Integer> items2=pendingReceiveDeSerializations.keySet();
  LOG.info(String.format(""String_Node_Str"",executor,items1));
  deserializeProgressTracker=new ProgressionTracker(items2);
}","private void initProgressTrackers(){
  Set<Integer> items=pendingSendMessagesPerSource.keySet();
  sendProgressTracker=new ProgressionTracker(items);
  Set<Integer> items1=pendingReceiveMessagesPerSource.keySet();
  receiveProgressTracker=new ProgressionTracker(items1);
  Set<Integer> items2=pendingReceiveDeSerializations.keySet();
  LOG.info(""String_Node_Str"");
  LOG.info(String.format(""String_Node_Str"",executor,items1));
  LOG.info(""String_Node_Str"" + pendingReceiveDeSerializations.size());
  LOG.info(""String_Node_Str"" + pendingReceiveDeSerializations.get(0).poll());
  LOG.info(""String_Node_Str"");
  deserializeProgressTracker=new ProgressionTracker(items2);
}",0.4448
173049,"private void receiveDeserializeProgress(MPIMessage currentMessage,int receiveId){
  if (currentMessage == null) {
    return;
  }
  int id=currentMessage.getOriginatingId();
  if (isStoreBased && isLastReceiver) {
    LOG.info(""String_Node_Str"");
    writeToMemoryManager(currentMessage,receiveId);
    currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
    if (!receiver.receiveMessage(currentMessage,operationMemoryManager)) {
      return;
    }
  }
 else {
    Object object=messageDeSerializer.get(receiveId).build(currentMessage,currentMessage.getHeader().getEdge());
    Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=pendingReceiveMessagesPerSource.get(id);
    currentMessage.setReceivedState(MPIMessage.ReceivedState.INIT);
    if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
      throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
    }
  }
}","private void receiveDeserializeProgress(MPIMessage currentMessage,int receiveId){
  if (currentMessage == null) {
    return;
  }
  int id=currentMessage.getOriginatingId();
  LOG.info(""String_Node_Str"");
  LOG.info(""String_Node_Str"" + receiveId);
  LOG.info(""String_Node_Str"");
  if (isStoreBased && isLastReceiver) {
    LOG.info(""String_Node_Str"");
    writeToMemoryManager(currentMessage,receiveId);
    currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
    if (!receiver.receiveMessage(currentMessage,operationMemoryManager)) {
      return;
    }
  }
 else {
    LOG.info(""String_Node_Str"");
    LOG.info(""String_Node_Str"" + receiveId);
    LOG.info(""String_Node_Str"");
    Object object=messageDeSerializer.get(receiveId).build(currentMessage,currentMessage.getHeader().getEdge());
    Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=pendingReceiveMessagesPerSource.get(id);
    currentMessage.setReceivedState(MPIMessage.ReceivedState.INIT);
    if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
      throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
    }
  }
}",0.8978240302743614
173050,"public boolean sendMessage(int source,Object message,int path,int flags,RoutingParameters routingParameters){
  try {
    LOG.info(""String_Node_Str"" + source);
    LOG.info(""String_Node_Str"" + message.toString());
    LOG.info(""String_Node_Str"" + routingParameters.toString());
    LOG.info(""String_Node_Str"" + routingParameters.getDestinationId());
    LOG.info(""String_Node_Str"" + path);
    ArrayBlockingQueue<Pair<Object,MPISendMessage>> pendingSendMessages=pendingSendMessagesPerSource.get(source);
    MPIMessage mpiMessage=new MPIMessage(source,type,MPIMessageDirection.OUT,this);
    int di=-1;
    if (routingParameters.getExternalRoutes().size() > 0) {
      di=routingParameters.getDestinationId();
    }
    MPISendMessage sendMessage=new MPISendMessage(source,mpiMessage,edge,di,path,flags,routingParameters.getInternalRoutes(),routingParameters.getExternalRoutes());
    boolean ret=pendingSendMessages.offer(new ImmutablePair<Object,MPISendMessage>(message,sendMessage));
    LOG.info(""String_Node_Str"" + ret);
    return ret;
  }
  finally {
    int a;
  }
}","public boolean sendMessage(int source,Object message,int path,int flags,RoutingParameters routingParameters){
  try {
    ArrayBlockingQueue<Pair<Object,MPISendMessage>> pendingSendMessages=pendingSendMessagesPerSource.get(source);
    MPIMessage mpiMessage=new MPIMessage(source,type,MPIMessageDirection.OUT,this);
    int di=-1;
    if (routingParameters.getExternalRoutes().size() > 0) {
      di=routingParameters.getDestinationId();
    }
    MPISendMessage sendMessage=new MPISendMessage(source,mpiMessage,edge,di,path,flags,routingParameters.getInternalRoutes(),routingParameters.getExternalRoutes());
    boolean ret=pendingSendMessages.offer(new ImmutablePair<Object,MPISendMessage>(message,sendMessage));
    return ret;
  }
  finally {
    int a;
  }
}",0.7915078933043005
173051,"private void receiveProgress(Queue<Pair<Object,MPIMessage>> pendingReceiveMessages){
  while (pendingReceiveMessages.size() > 0) {
    Pair<Object,MPIMessage> pair=pendingReceiveMessages.peek();
    MPIMessage.ReceivedState state=pair.getRight().getReceivedState();
    MPIMessage currentMessage=pair.getRight();
    Object object=pair.getLeft();
    if (state == MPIMessage.ReceivedState.INIT) {
      currentMessage.incrementRefCount();
    }
    if (state == MPIMessage.ReceivedState.DOWN || state == MPIMessage.ReceivedState.INIT) {
      currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
      if (!receiver.passMessageDownstream(object,currentMessage)) {
        break;
      }
      currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
      if (!receiver.receiveMessage(currentMessage,object)) {
        break;
      }
      currentMessage.release();
      pendingReceiveMessages.poll();
    }
 else     if (state == MPIMessage.ReceivedState.RECEIVE) {
      currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
      if (!receiver.receiveMessage(currentMessage,object)) {
        break;
      }
      currentMessage.release();
      pendingReceiveMessages.poll();
    }
  }
}","private void receiveProgress(Queue<Pair<Object,MPIMessage>> pendingReceiveMessages){
  while (pendingReceiveMessages.size() > 0) {
    Pair<Object,MPIMessage> pair=pendingReceiveMessages.peek();
    MPIMessage.ReceivedState state=pair.getRight().getReceivedState();
    MPIMessage currentMessage=pair.getRight();
    Object object=pair.getLeft();
    LOG.info(""String_Node_Str"");
    LOG.info(""String_Node_Str"" + state);
    LOG.info(""String_Node_Str"");
    if (state == MPIMessage.ReceivedState.INIT) {
      currentMessage.incrementRefCount();
    }
    if (state == MPIMessage.ReceivedState.DOWN || state == MPIMessage.ReceivedState.INIT) {
      currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
      if (!receiver.passMessageDownstream(object,currentMessage)) {
        break;
      }
      currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
      if (!receiver.receiveMessage(currentMessage,object)) {
        break;
      }
      currentMessage.release();
      pendingReceiveMessages.poll();
    }
 else     if (state == MPIMessage.ReceivedState.RECEIVE) {
      LOG.info(""String_Node_Str"");
      LOG.info(""String_Node_Str"" + state);
      LOG.info(""String_Node_Str"");
      currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
      if (!receiver.receiveMessage(currentMessage,object)) {
        break;
      }
      currentMessage.release();
      pendingReceiveMessages.poll();
    }
  }
}",0.9176646706586826
173052,"/** 
 * Initialize
 * @param cfg
 * @param t
 * @param taskPlan
 * @param edge
 */
public void init(Config cfg,MessageType t,TaskPlan taskPlan,int edge){
  this.router=new DirectRouter(taskPlan,sources,destination);
  if (this.finalReceiver != null && isLastReceiver()) {
    this.finalReceiver.init(cfg,this,receiveExpectedTaskIds());
  }
  Map<Integer,ArrayBlockingQueue<Pair<Object,MPISendMessage>>> pendingSendMessagesPerSource=new HashMap<>();
  Map<Integer,Queue<Pair<Object,MPIMessage>>> pendingReceiveMessagesPerSource=new HashMap<>();
  Map<Integer,Queue<MPIMessage>> pendingReceiveDeSerializations=new HashMap<>();
  Map<Integer,MessageSerializer> serializerMap=new HashMap<>();
  Map<Integer,MessageDeSerializer> deSerializerMap=new HashMap<>();
  Set<Integer> srcs=TaskPlanUtils.getTasksOfThisExecutor(taskPlan,sources);
  for (  int s : srcs) {
    ArrayBlockingQueue<Pair<Object,MPISendMessage>> pendingSendMessages=new ArrayBlockingQueue<Pair<Object,MPISendMessage>>(MPIContext.sendPendingMax(cfg));
    pendingSendMessagesPerSource.put(s,pendingSendMessages);
    pendingReceiveDeSerializations.put(s,new ArrayBlockingQueue<MPIMessage>(MPIContext.sendPendingMax(cfg)));
    serializerMap.put(s,new MPIMessageSerializer(new KryoSerializer()));
  }
  MessageDeSerializer messageDeSerializer=new MPIMessageDeSerializer(new KryoSerializer());
  deSerializerMap.put(destination,messageDeSerializer);
  delegete.init(cfg,t,taskPlan,edge,router.receivingExecutors(),isLastReceiver(),this,pendingSendMessagesPerSource,pendingReceiveMessagesPerSource,pendingReceiveDeSerializations,serializerMap,deSerializerMap,false);
}","/** 
 * Initialize
 * @param cfg
 * @param t
 * @param taskPlan
 * @param edge
 */
public void init(Config cfg,MessageType t,TaskPlan taskPlan,int edge){
  this.config=cfg;
  this.instancePlan=taskPlan;
  this.type=t;
  this.router=new DirectRouter(taskPlan,sources,destination);
  if (this.finalReceiver != null) {
    LG.info(""String_Node_Str"");
    LG.info(""String_Node_Str"");
    LG.info(""String_Node_Str"");
    this.finalReceiver.init(cfg,this,receiveExpectedTaskIds());
  }
 else {
    LG.info(""String_Node_Str"");
  }
  Map<Integer,ArrayBlockingQueue<Pair<Object,MPISendMessage>>> pendingSendMessagesPerSource=new HashMap<>();
  Map<Integer,Queue<Pair<Object,MPIMessage>>> pendingReceiveMessagesPerSource=new HashMap<>();
  Map<Integer,Queue<MPIMessage>> pendingReceiveDeSerializations=new HashMap<>();
  Map<Integer,MessageSerializer> serializerMap=new HashMap<>();
  Map<Integer,MessageDeSerializer> deSerializerMap=new HashMap<>();
  Set<Integer> srcs=TaskPlanUtils.getTasksOfThisExecutor(taskPlan,sources);
  Set<Integer> myexecutors=router.receivingExecutors();
  Set<Integer> mysources=router.allSendTasks();
  LG.info(""String_Node_Str"");
  LG.info(""String_Node_Str"" + mysources.size());
  LG.info(""String_Node_Str"" + myexecutors.size());
  if (mysources.iterator().hasNext()) {
    LG.info(""String_Node_Str"" + mysources.iterator().next());
  }
  if (myexecutors.iterator().hasNext()) {
    LG.info(""String_Node_Str"" + myexecutors.iterator().next());
  }
  for (  int s : mysources) {
    ArrayBlockingQueue<Pair<Object,MPISendMessage>> pendingSendMessages=new ArrayBlockingQueue<Pair<Object,MPISendMessage>>(MPIContext.sendPendingMax(cfg));
    pendingSendMessagesPerSource.put(s,pendingSendMessages);
    serializerMap.put(s,new MPIMessageSerializer(new KryoSerializer()));
  }
  int maxReceiveBuffers=MPIContext.receiveBufferCount(cfg);
  int receiveExecutorsSize=myexecutors.size();
  if (receiveExecutorsSize == 0) {
    receiveExecutorsSize=1;
  }
  Set<Integer> execs=router.receivingExecutors();
  for (  int e : execs) {
    int capacity=maxReceiveBuffers * 2 * receiveExecutorsSize;
    LG.info(""String_Node_Str"" + capacity);
    Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=new ArrayBlockingQueue<Pair<Object,MPIMessage>>(capacity);
    pendingReceiveMessagesPerSource.put(e,pendingReceiveMessages);
    pendingReceiveDeSerializations.put(e,new ArrayBlockingQueue<MPIMessage>(capacity));
    deSerializerMap.put(e,new MPIMessageDeSerializer(new KryoSerializer()));
  }
  MPIMessage mpimsg=pendingReceiveDeSerializations.get(0).poll();
  LG.info(""String_Node_Str"" + mpimsg);
  KryoSerializer kryoSerializer=new KryoSerializer();
  kryoSerializer.init(new HashMap<String,Object>());
  MessageDeSerializer messageDeSerializer=new MPIMessageDeSerializer(kryoSerializer);
  MessageSerializer messageSerializer=new MPIMessageSerializer(kryoSerializer);
  delegete.init(cfg,t,taskPlan,edge,router.receivingExecutors(),router.isLastReceiver(),this,pendingSendMessagesPerSource,pendingReceiveMessagesPerSource,pendingReceiveDeSerializations,serializerMap,deSerializerMap,false);
  LG.info(""String_Node_Str"");
}",0.6099558916194077
173053,"@Override public boolean receiveMessage(MPIMessage currentMessage,Object object){
  MessageHeader header=currentMessage.getHeader();
  LG.info(""String_Node_Str"");
  LG.info(""String_Node_Str"" + header.toString());
  LG.info(""String_Node_Str"" + currentMessage.toString());
  LG.info(""String_Node_Str"" + object.toString());
  LG.info(""String_Node_Str"" + header.getSourceId());
  LG.info(""String_Node_Str"" + header.getSourceId());
  LG.info(""String_Node_Str"");
  return finalReceiver.onMessage(header.getSourceId(),0,destination,header.getFlags(),object);
}","@Override public boolean receiveMessage(MPIMessage currentMessage,Object object){
  MessageHeader header=currentMessage.getHeader();
  LG.info(""String_Node_Str"");
  LG.info(""String_Node_Str"" + header.toString());
  LG.info(""String_Node_Str"" + currentMessage.toString());
  LG.info(""String_Node_Str"" + object.toString());
  LG.info(""String_Node_Str"" + header.getSourceId());
  LG.info(""String_Node_Str"" + header.getSourceId());
  LG.info(""String_Node_Str"");
  return finalReceiver.onMessage(header.getSourceId(),MPIContext.DEFAULT_PATH,destination,header.getFlags(),object);
}",0.9787234042553192
173054,"public MPIDirectDataFlowCommunication(TWSChannel channel,Set<Integer> srcs,int dest,MessageReceiver finalRcvr){
  this.sources=srcs;
  this.destination=dest;
  this.finalReceiver=finalRcvr;
  this.delegete=new MPIDataFlowOperation(channel);
}","public MPIDirectDataFlowCommunication(TWSChannel channel,Set<Integer> srcs,int dest,MessageReceiver finalRcvr){
  this.sources=srcs;
  this.destination=dest;
  this.finalReceiver=finalRcvr;
  this.delegete=new MPIDataFlowOperation(channel);
  this.finalReceiverProgress=new AtomicBoolean(false);
}",0.8979591836734694
173055,"public ProgressionTracker(Set<Integer> items){
  if (items.size() == 0) {
    canProgress=false;
  }
 else {
    canProgress=true;
    this.progressItems=new ArrayBlockingQueue<>(items.size());
    for (    int i : items) {
      progressItems.offer(i);
    }
  }
}","public ProgressionTracker(Set<Integer> items){
  if (items.size() == 0) {
    LOG.info(""String_Node_Str"" + items.size());
    canProgress=false;
  }
 else {
    LOG.info(""String_Node_Str"" + items.size());
    canProgress=true;
    this.progressItems=new ArrayBlockingQueue<>(items.size());
    for (    int i : items) {
      progressItems.offer(i);
    }
  }
}",0.8466453674121406
173056,"/** 
 * Initialize
 * @param cfg
 * @param t
 * @param taskPlan
 * @param edge
 */
public void init(Config cfg,MessageType t,TaskPlan taskPlan,int edge){
  this.thisSources=TaskPlanUtils.getTasksOfThisExecutor(taskPlan,sources);
  LOG.info(String.format(""String_Node_Str"",taskPlan.getThisExecutor(),thisSources));
  this.thisTasks=taskPlan.getTasksOfThisExecutor();
  this.router=new PartitionRouter(taskPlan,sources,destinations);
  Map<Integer,Set<Integer>> internal=router.getInternalSendTasks(0);
  Map<Integer,Set<Integer>> external=router.getExternalSendTasks(0);
  this.instancePlan=taskPlan;
  this.type=t;
  LOG.info(String.format(""String_Node_Str"",taskPlan.getThisExecutor()));
  for (  int s : thisSources) {
    Set<Integer> integerSetMap=internal.get(s);
    if (integerSetMap != null) {
      this.dests.internal.addAll(integerSetMap);
    }
    Set<Integer> integerSetMap1=external.get(s);
    if (integerSetMap1 != null) {
      this.dests.external.addAll(integerSetMap1);
    }
    LOG.info(String.format(""String_Node_Str"",taskPlan.getThisExecutor(),s));
    break;
  }
  LOG.info(String.format(""String_Node_Str"",taskPlan.getThisExecutor()));
  if (this.finalReceiver != null && isLastReceiver()) {
    this.finalReceiver.init(cfg,this,receiveExpectedTaskIds());
  }
  Map<Integer,ArrayBlockingQueue<Pair<Object,MPISendMessage>>> pendingSendMessagesPerSource=new HashMap<>();
  Map<Integer,Queue<Pair<Object,MPIMessage>>> pendingReceiveMessagesPerSource=new HashMap<>();
  Map<Integer,Queue<MPIMessage>> pendingReceiveDeSerializations=new HashMap<>();
  Map<Integer,MessageSerializer> serializerMap=new HashMap<>();
  Map<Integer,MessageDeSerializer> deSerializerMap=new HashMap<>();
  Set<Integer> srcs=TaskPlanUtils.getTasksOfThisExecutor(taskPlan,sources);
  for (  int s : srcs) {
    ArrayBlockingQueue<Pair<Object,MPISendMessage>> pendingSendMessages=new ArrayBlockingQueue<Pair<Object,MPISendMessage>>(MPIContext.sendPendingMax(cfg));
    pendingSendMessagesPerSource.put(s,pendingSendMessages);
    serializerMap.put(s,new MPIMessageSerializer(new KryoSerializer()));
  }
  int maxReceiveBuffers=MPIContext.receiveBufferCount(cfg);
  int receiveExecutorsSize=receivingExecutors().size();
  if (receiveExecutorsSize == 0) {
    receiveExecutorsSize=1;
  }
  Set<Integer> execs=router.receivingExecutors();
  for (  int e : execs) {
    int capacity=maxReceiveBuffers * 2 * receiveExecutorsSize;
    Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=new ArrayBlockingQueue<Pair<Object,MPIMessage>>(capacity);
    pendingReceiveMessagesPerSource.put(e,pendingReceiveMessages);
    pendingReceiveDeSerializations.put(e,new ArrayBlockingQueue<MPIMessage>(capacity));
    deSerializerMap.put(e,new MPIMessageDeSerializer(new KryoSerializer()));
  }
  KryoSerializer kryoSerializer=new KryoSerializer();
  kryoSerializer.init(new HashMap<String,Object>());
  MessageDeSerializer messageDeSerializer=new MPIMessageDeSerializer(kryoSerializer);
  MessageSerializer messageSerializer=new MPIMessageSerializer(kryoSerializer);
  delegete.init(cfg,t,taskPlan,edge,router.receivingExecutors(),router.isLastReceiver(),this,pendingSendMessagesPerSource,pendingReceiveMessagesPerSource,pendingReceiveDeSerializations,serializerMap,deSerializerMap,false);
}","/** 
 * Initialize
 */
public void init(Config cfg,MessageType t,TaskPlan taskPlan,int edge){
  this.thisSources=TaskPlanUtils.getTasksOfThisExecutor(taskPlan,sources);
  LOG.info(String.format(""String_Node_Str"",taskPlan.getThisExecutor(),thisSources));
  this.thisTasks=taskPlan.getTasksOfThisExecutor();
  this.router=new PartitionRouter(taskPlan,sources,destinations);
  Map<Integer,Set<Integer>> internal=router.getInternalSendTasks(0);
  Map<Integer,Set<Integer>> external=router.getExternalSendTasks(0);
  this.instancePlan=taskPlan;
  this.type=t;
  LOG.info(String.format(""String_Node_Str"",taskPlan.getThisExecutor()));
  for (  int s : thisSources) {
    Set<Integer> integerSetMap=internal.get(s);
    if (integerSetMap != null) {
      this.dests.internal.addAll(integerSetMap);
    }
    Set<Integer> integerSetMap1=external.get(s);
    if (integerSetMap1 != null) {
      this.dests.external.addAll(integerSetMap1);
    }
    LOG.info(String.format(""String_Node_Str"",taskPlan.getThisExecutor(),s));
    break;
  }
  LOG.info(String.format(""String_Node_Str"",taskPlan.getThisExecutor()));
  if (this.finalReceiver != null && isLastReceiver()) {
    this.finalReceiver.init(cfg,this,receiveExpectedTaskIds());
  }
  Map<Integer,ArrayBlockingQueue<Pair<Object,MPISendMessage>>> pendingSendMessagesPerSource=new HashMap<>();
  Map<Integer,Queue<Pair<Object,MPIMessage>>> pendingReceiveMessagesPerSource=new HashMap<>();
  Map<Integer,Queue<MPIMessage>> pendingReceiveDeSerializations=new HashMap<>();
  Map<Integer,MessageSerializer> serializerMap=new HashMap<>();
  Map<Integer,MessageDeSerializer> deSerializerMap=new HashMap<>();
  Set<Integer> srcs=TaskPlanUtils.getTasksOfThisExecutor(taskPlan,sources);
  for (  int s : srcs) {
    ArrayBlockingQueue<Pair<Object,MPISendMessage>> pendingSendMessages=new ArrayBlockingQueue<Pair<Object,MPISendMessage>>(MPIContext.sendPendingMax(cfg));
    pendingSendMessagesPerSource.put(s,pendingSendMessages);
    serializerMap.put(s,new MPIMessageSerializer(new KryoSerializer()));
  }
  int maxReceiveBuffers=MPIContext.receiveBufferCount(cfg);
  int receiveExecutorsSize=receivingExecutors().size();
  if (receiveExecutorsSize == 0) {
    receiveExecutorsSize=1;
  }
  Set<Integer> execs=router.receivingExecutors();
  for (  int e : execs) {
    int capacity=maxReceiveBuffers * 2 * receiveExecutorsSize;
    Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=new ArrayBlockingQueue<Pair<Object,MPIMessage>>(capacity);
    pendingReceiveMessagesPerSource.put(e,pendingReceiveMessages);
    pendingReceiveDeSerializations.put(e,new ArrayBlockingQueue<MPIMessage>(capacity));
    deSerializerMap.put(e,new MPIMessageDeSerializer(new KryoSerializer()));
  }
  KryoSerializer kryoSerializer=new KryoSerializer();
  kryoSerializer.init(new HashMap<String,Object>());
  MessageDeSerializer messageDeSerializer=new MPIMessageDeSerializer(kryoSerializer);
  MessageSerializer messageSerializer=new MPIMessageSerializer(kryoSerializer);
  delegete.init(cfg,t,taskPlan,edge,router.receivingExecutors(),router.isLastReceiver(),this,pendingSendMessagesPerSource,pendingReceiveMessagesPerSource,pendingReceiveDeSerializations,serializerMap,deSerializerMap,false);
}",0.9907378820623648
173057,"public boolean receiveMessage(MPIMessage currentMessage,Object object){
  MessageHeader header=currentMessage.getHeader();
  return finalReceiver.onMessage(header.getSourceId(),MPIContext.DEFAULT_PATH,router.mainTaskOfExecutor(instancePlan.getThisExecutor(),MPIContext.DEFAULT_PATH),header.getFlags(),object);
}","public boolean receiveMessage(MPIMessage currentMessage,Object object){
  MessageHeader header=currentMessage.getHeader();
  return finalReceiver.onMessage(header.getSourceId(),MPIContext.DEFAULT_PATH,header.getDestinationIdentifier(),header.getFlags(),object);
}",0.8083623693379791
173058,"/** 
 * Progress the serializations
 */
public void progress(){
  if (partialSendAttempts > 1000000 || sendAttempts > 1000000 || sendCount > 5900) {
    String s=""String_Node_Str"";
    for (    Map.Entry<Integer,Queue<MPIBuffer>> e : receiveBuffers.entrySet()) {
      s+=e.getKey() + ""String_Node_Str"" + e.getValue().size()+ ""String_Node_Str"";
    }
    LOG.info(String.format(""String_Node_Str"",executor,sendCount,receiveCount,sendBufferReleaseCount,receiveBufferReleaseCount,s,sendsOfferred,sendsPartialOfferred));
    ((TWSMPIChannel)channel).setDebug(true);
  }
  if (sendProgressTracker.canProgress()) {
    int sendId=sendProgressTracker.next();
    if (sendId != Integer.MIN_VALUE) {
      sendProgress(pendingSendMessagesPerSource.get(sendId),sendId);
      sendProgressTracker.finish(sendId);
    }
  }
  if (deserializeProgressTracker.canProgress()) {
    int deserializeId=deserializeProgressTracker.next();
    if (deserializeId != Integer.MIN_VALUE) {
      receiveDeserializeProgress(pendingReceiveDeSerializations.get(deserializeId).poll(),deserializeId);
      deserializeProgressTracker.finish(deserializeId);
    }
  }
  if (receiveProgressTracker.canProgress()) {
    int receiveId=receiveProgressTracker.next();
    if (receiveId != Integer.MIN_VALUE) {
      receiveProgress(pendingReceiveMessagesPerSource.get(receiveId));
      receiveProgressTracker.finish(receiveId);
    }
  }
}","/** 
 * Progress the serializations
 */
public void progress(){
  if (partialSendAttempts > 1000000 || sendAttempts > 1000000) {
    String s=""String_Node_Str"";
    for (    Map.Entry<Integer,Queue<MPIBuffer>> e : receiveBuffers.entrySet()) {
      s+=e.getKey() + ""String_Node_Str"" + e.getValue().size()+ ""String_Node_Str"";
    }
    LOG.info(String.format(""String_Node_Str"",executor,sendCount,receiveCount,sendBufferReleaseCount,receiveBufferReleaseCount,s,sendsOfferred,sendsPartialOfferred));
    ((TWSMPIChannel)channel).setDebug(true);
  }
  if (sendProgressTracker.canProgress()) {
    int sendId=sendProgressTracker.next();
    if (sendId != Integer.MIN_VALUE) {
      sendProgress(pendingSendMessagesPerSource.get(sendId),sendId);
      sendProgressTracker.finish(sendId);
    }
  }
  if (deserializeProgressTracker.canProgress()) {
    int deserializeId=deserializeProgressTracker.next();
    if (deserializeId != Integer.MIN_VALUE) {
      receiveDeserializeProgress(pendingReceiveDeSerializations.get(deserializeId).poll(),deserializeId);
      deserializeProgressTracker.finish(deserializeId);
    }
  }
  if (receiveProgressTracker.canProgress()) {
    int receiveId=receiveProgressTracker.next();
    if (receiveId != Integer.MIN_VALUE) {
      receiveProgress(pendingReceiveMessagesPerSource.get(receiveId));
      receiveProgressTracker.finish(receiveId);
    }
  }
}",0.9928263988522238
173059,"@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  this.executor=op.getTaskPlan().getThisExecutor();
  this.operation=op;
  this.sendPendingMax=MPIContext.sendPendingMax(cfg);
  this.reducedValues=new ArrayBlockingQueue<>(sendPendingMax);
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,List<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    Map<Integer,Integer> totalCountsPerTask=new HashMap<>();
    for (    int i : e.getValue()) {
      messagesPerTask.put(i,new ArrayList<Object>());
      countsPerTask.put(i,0);
      totalCountsPerTask.put(i,0);
    }
    LOG.fine(String.format(""String_Node_Str"",executor,e.getKey(),e.getValue().toString()));
    messages.put(e.getKey(),messagesPerTask);
    counts.put(e.getKey(),countsPerTask);
    totalCounts.put(e.getKey(),totalCountsPerTask);
  }
}","@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  this.executor=op.getTaskPlan().getThisExecutor();
  this.operation=op;
  this.sendPendingMax=MPIContext.sendPendingMax(cfg);
  this.reducedValues=new ArrayBlockingQueue<>(sendPendingMax);
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,Queue<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    Map<Integer,Integer> totalCountsPerTask=new HashMap<>();
    for (    int i : e.getValue()) {
      messagesPerTask.put(i,new ArrayBlockingQueue<>(sendPendingMax * 4));
      countsPerTask.put(i,0);
      totalCountsPerTask.put(i,0);
    }
    LOG.fine(String.format(""String_Node_Str"",executor,e.getKey(),e.getValue().toString()));
    messages.put(e.getKey(),messagesPerTask);
    counts.put(e.getKey(),countsPerTask);
    totalCounts.put(e.getKey(),totalCountsPerTask);
  }
}",0.9705882352941176
173060,"@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  List<Object> m=messages.get(target).get(source);
  Integer c=counts.get(target).get(source);
  if (m.size() > sendPendingMax * 4) {
    canAdd=false;
    onMessageAttempts++;
  }
 else {
    onMessageAttempts=0;
    m.add(object);
    counts.get(target).put(source,c + 1);
    Integer tc=totalCounts.get(target).get(source);
    totalCounts.get(target).put(source,tc + 1);
  }
  return canAdd;
}","@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  Queue<Object> m=messages.get(target).get(source);
  Integer c=counts.get(target).get(source);
  if (m.size() >= sendPendingMax * 4) {
    canAdd=false;
    onMessageAttempts++;
  }
 else {
    onMessageAttempts=0;
    m.offer(object);
    counts.get(target).put(source,c + 1);
    Integer tc=totalCounts.get(target).get(source);
    totalCounts.get(target).put(source,tc + 1);
  }
  return canAdd;
}",0.9824902723735408
173061,"@Override public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    Map<Integer,List<Object>> messagePerTarget=messages.get(t);
    Map<Integer,Integer> countsPerTarget=counts.get(t);
    Map<Integer,Integer> totalCountMap=totalCounts.get(t);
    while (canProgress) {
      boolean found=true;
      for (      Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
      }
      if (found && reducedValues.size() < sendPendingMax) {
        Object previous=null;
        for (        Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
          if (previous == null) {
            previous=e.getValue().remove(0);
          }
 else {
            Object current=e.getValue().remove(0);
            previous=reduceFunction.reduce(previous,current);
          }
        }
        if (previous != null) {
          reducedValues.offer(previous);
        }
      }
 else {
        progressAttempts++;
      }
      if (reducedValues.size() > 0) {
        Object previous=reducedValues.peek();
        boolean handle=handleMessage(t,previous,0,destination);
        if (handle) {
          reducedValues.poll();
          for (          Map.Entry<Integer,Integer> e : countsPerTarget.entrySet()) {
            Integer i=e.getValue();
            countsPerTarget.put(e.getKey(),i - 1);
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}","@Override public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    Map<Integer,Queue<Object>> messagePerTarget=messages.get(t);
    Map<Integer,Integer> countsPerTarget=counts.get(t);
    Map<Integer,Integer> totalCountMap=totalCounts.get(t);
    while (canProgress) {
      boolean found=true;
      for (      Map.Entry<Integer,Queue<Object>> e : messagePerTarget.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
      }
      if (found && reducedValues.size() < sendPendingMax) {
        Object previous=null;
        for (        Map.Entry<Integer,Queue<Object>> e : messagePerTarget.entrySet()) {
          if (previous == null) {
            previous=e.getValue().poll();
          }
 else {
            Object current=e.getValue().poll();
            previous=reduceFunction.reduce(previous,current);
          }
        }
        if (previous != null) {
          reducedValues.offer(previous);
        }
        progressAttempts=0;
      }
 else {
        progressAttempts++;
      }
      if (reducedValues.size() > 0) {
        Object previous=reducedValues.peek();
        boolean handle=handleMessage(t,previous,0,destination);
        if (handle) {
          reducedValues.poll();
          for (          Map.Entry<Integer,Integer> e : countsPerTarget.entrySet()) {
            Integer i=e.getValue();
            countsPerTarget.put(e.getKey(),i - 1);
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}",0.8667312036140691
173062,"@Override public void run(){
  try {
    LOG.log(Level.INFO,""String_Node_Str"" + id);
    IntData data=generateData();
    for (int i=0; i < 6000; i++) {
      while (!reduce.send(task,data,0)) {
        reduce.progress();
        Thread.yield();
      }
      if (i % 100 == 0) {
        LOG.info(String.format(""String_Node_Str"",id,i));
      }
    }
    LOG.info(String.format(""String_Node_Str"",id));
    status=Status.MAP_FINISHED;
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}","@Override public void run(){
  try {
    LOG.log(Level.INFO,""String_Node_Str"" + id);
    IntData data=generateData();
    for (int i=0; i < 6000; i++) {
      while (!reduce.send(task,data,0)) {
        reduce.progress();
        Thread.yield();
      }
      if (i % 100 == 0 || i > 5990) {
        LOG.info(String.format(""String_Node_Str"",id,i));
      }
    }
    LOG.info(String.format(""String_Node_Str"",id));
    status=Status.MAP_FINISHED;
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}",0.9879759519038076
173063,"/** 
 * Setup the receives and send sendBuffers
 */
protected void setupCommunication(){
  int maxReceiveBuffers=MPIContext.receiveBufferCount(config);
  int receiveBufferSize=MPIContext.bufferSize(config);
  for (  Integer recv : receivingExecutors) {
    Queue<MPIBuffer> recvList=new LinkedList<>();
    for (int i=0; i < maxReceiveBuffers; i++) {
      recvList.add(new MPIBuffer(receiveBufferSize));
    }
    LOG.fine(instancePlan.getThisExecutor() + ""String_Node_Str"" + recv);
    channel.receiveMessage(recv,edge,this,recvList);
    receiveBuffers.put(recv,recvList);
  }
  int sendBufferSize=MPIContext.bufferSize(config);
  int sendBufferCount=MPIContext.sendBuffersCount(config);
  for (int i=0; i < sendBufferCount; i++) {
    MPIBuffer buffer=new MPIBuffer(sendBufferSize);
    sendBuffers.offer(buffer);
  }
}","/** 
 * Setup the receives and send sendBuffers
 */
protected void setupCommunication(){
  int maxReceiveBuffers=MPIContext.receiveBufferCount(config);
  int receiveBufferSize=MPIContext.bufferSize(config);
  for (  Integer recv : receivingExecutors) {
    Queue<MPIBuffer> recvList=new LinkedBlockingQueue<>();
    for (int i=0; i < maxReceiveBuffers; i++) {
      recvList.add(new MPIBuffer(receiveBufferSize));
    }
    LOG.fine(instancePlan.getThisExecutor() + ""String_Node_Str"" + recv);
    channel.receiveMessage(recv,edge,this,recvList);
    receiveBuffers.put(recv,recvList);
  }
  int sendBufferSize=MPIContext.bufferSize(config);
  int sendBufferCount=MPIContext.sendBuffersCount(config);
  for (int i=0; i < sendBufferCount; i++) {
    MPIBuffer buffer=new MPIBuffer(sendBufferSize);
    sendBuffers.offer(buffer);
  }
}",0.9897280966767372
173064,"protected void releaseTheBuffers(int id,MPIMessage message){
  if (MPIMessageDirection.IN == message.getMessageDirection()) {
    Queue<MPIBuffer> list=receiveBuffers.get(id);
    for (    MPIBuffer buffer : message.getBuffers()) {
      buffer.getByteBuffer().clear();
      list.offer(buffer);
      receiveBufferReleaseCount++;
    }
  }
 else   if (MPIMessageDirection.OUT == message.getMessageDirection()) {
    Queue<MPIBuffer> queue=sendBuffers;
    for (    MPIBuffer buffer : message.getBuffers()) {
      buffer.getByteBuffer().clear();
      queue.offer(buffer);
      sendBufferReleaseCount++;
    }
  }
}","protected void releaseTheBuffers(int id,MPIMessage message){
  if (MPIMessageDirection.IN == message.getMessageDirection()) {
    Queue<MPIBuffer> list=receiveBuffers.get(id);
    for (    MPIBuffer buffer : message.getBuffers()) {
      buffer.getByteBuffer().clear();
      if (!list.offer(buffer)) {
        throw new RuntimeException(""String_Node_Str"");
      }
      receiveBufferReleaseCount++;
    }
  }
 else   if (MPIMessageDirection.OUT == message.getMessageDirection()) {
    Queue<MPIBuffer> queue=sendBuffers;
    for (    MPIBuffer buffer : message.getBuffers()) {
      buffer.getByteBuffer().clear();
      if (!queue.offer(buffer)) {
        throw new RuntimeException(""String_Node_Str"");
      }
      sendBufferReleaseCount++;
    }
  }
}",0.8981077147016011
173065,"public boolean sendMessage(int source,Object message,int path,int flags,RoutingParameters routingParameters){
  ArrayBlockingQueue<Pair<Object,MPISendMessage>> pendingSendMessages=pendingSendMessagesPerSource.get(source);
  MPIMessage mpiMessage=new MPIMessage(source,type,MPIMessageDirection.OUT,this);
  int di=-1;
  if (routingParameters.getExternalRoutes().size() > 0) {
    di=routingParameters.getDestinationId();
  }
  MPISendMessage sendMessage=new MPISendMessage(source,mpiMessage,edge,di,path,flags,routingParameters.getInternalRoutes(),routingParameters.getExternalRoutes());
  return pendingSendMessages.offer(new ImmutablePair<Object,MPISendMessage>(message,sendMessage));
}","public boolean sendMessage(int source,Object message,int path,int flags,RoutingParameters routingParameters){
  ArrayBlockingQueue<Pair<Object,MPISendMessage>> pendingSendMessages=pendingSendMessagesPerSource.get(source);
  MPIMessage mpiMessage=new MPIMessage(source,type,MPIMessageDirection.OUT,this);
  int di=-1;
  if (routingParameters.getExternalRoutes().size() > 0) {
    di=routingParameters.getDestinationId();
  }
  MPISendMessage sendMessage=new MPISendMessage(source,mpiMessage,edge,di,path,flags,routingParameters.getInternalRoutes(),routingParameters.getExternalRoutes());
  boolean offer=pendingSendMessages.offer(new ImmutablePair<Object,MPISendMessage>(message,sendMessage));
  if (!offer) {
    sendAttempts++;
  }
 else {
    ((TWSMPIChannel)channel).setDebug(false);
    sendAttempts=0;
    sendsOfferred++;
  }
  return offer;
}",0.8854166666666666
173066,"public boolean sendMessagePartial(int source,Object object,int path,int flags,RoutingParameters routingParameters){
  ArrayBlockingQueue<Pair<Object,MPISendMessage>> pendingSendMessages=pendingSendMessagesPerSource.get(source * -1 - 1);
  MPIMessage mpiMessage=new MPIMessage(source,type,MPIMessageDirection.OUT,this);
  int di=-1;
  if (routingParameters.getExternalRoutes().size() > 0) {
    di=routingParameters.getDestinationId();
  }
  MPISendMessage sendMessage=new MPISendMessage(source,mpiMessage,edge,di,path,flags,routingParameters.getInternalRoutes(),routingParameters.getExternalRoutes());
  boolean ret=pendingSendMessages.offer(new ImmutablePair<Object,MPISendMessage>(object,sendMessage));
  return ret;
}","public boolean sendMessagePartial(int source,Object object,int path,int flags,RoutingParameters routingParameters){
  ArrayBlockingQueue<Pair<Object,MPISendMessage>> pendingSendMessages=pendingSendMessagesPerSource.get(source * -1 - 1);
  MPIMessage mpiMessage=new MPIMessage(source,type,MPIMessageDirection.OUT,this);
  int di=-1;
  if (routingParameters.getExternalRoutes().size() > 0) {
    di=routingParameters.getDestinationId();
  }
  MPISendMessage sendMessage=new MPISendMessage(source,mpiMessage,edge,di,path,flags,routingParameters.getInternalRoutes(),routingParameters.getExternalRoutes());
  boolean ret=pendingSendMessages.offer(new ImmutablePair<Object,MPISendMessage>(object,sendMessage));
  if (!ret) {
    partialSendAttempts++;
  }
 else {
    ((TWSMPIChannel)channel).setDebug(false);
    partialSendAttempts=0;
    sendsPartialOfferred++;
  }
  return ret;
}",0.886107634543179
173067,"/** 
 * Progress the serializations
 */
public void progress(){
  LOG.info(String.format(""String_Node_Str"",executor,sendCount,receiveCount,sendBufferReleaseCount,receiveBufferReleaseCount));
  if (sendProgressTracker.canProgress()) {
    int sendId=sendProgressTracker.next();
    if (sendId != Integer.MIN_VALUE) {
      sendProgress(pendingSendMessagesPerSource.get(sendId),sendId);
      sendProgressTracker.finish(sendId);
    }
  }
  if (deserializeProgressTracker.canProgress()) {
    int deserializeId=deserializeProgressTracker.next();
    if (deserializeId != Integer.MIN_VALUE) {
      receiveDeserializeProgress(pendingReceiveDeSerializations.get(deserializeId).poll(),deserializeId);
      deserializeProgressTracker.finish(deserializeId);
    }
  }
  if (receiveProgressTracker.canProgress()) {
    int receiveId=receiveProgressTracker.next();
    if (receiveId != Integer.MIN_VALUE) {
      receiveProgress(pendingReceiveMessagesPerSource.get(receiveId));
      receiveProgressTracker.finish(receiveId);
    }
  }
}","/** 
 * Progress the serializations
 */
public void progress(){
  if (partialSendAttempts > 1000000 || sendAttempts > 1000000 || sendCount > 5900) {
    String s=""String_Node_Str"";
    for (    Map.Entry<Integer,Queue<MPIBuffer>> e : receiveBuffers.entrySet()) {
      s+=e.getKey() + ""String_Node_Str"" + e.getValue().size()+ ""String_Node_Str"";
    }
    LOG.info(String.format(""String_Node_Str"",executor,sendCount,receiveCount,sendBufferReleaseCount,receiveBufferReleaseCount,s,sendsOfferred,sendsPartialOfferred));
    ((TWSMPIChannel)channel).setDebug(true);
  }
  if (sendProgressTracker.canProgress()) {
    int sendId=sendProgressTracker.next();
    if (sendId != Integer.MIN_VALUE) {
      sendProgress(pendingSendMessagesPerSource.get(sendId),sendId);
      sendProgressTracker.finish(sendId);
    }
  }
  if (deserializeProgressTracker.canProgress()) {
    int deserializeId=deserializeProgressTracker.next();
    if (deserializeId != Integer.MIN_VALUE) {
      receiveDeserializeProgress(pendingReceiveDeSerializations.get(deserializeId).poll(),deserializeId);
      deserializeProgressTracker.finish(deserializeId);
    }
  }
  if (receiveProgressTracker.canProgress()) {
    int receiveId=receiveProgressTracker.next();
    if (receiveId != Integer.MIN_VALUE) {
      receiveProgress(pendingReceiveMessagesPerSource.get(receiveId));
      receiveProgressTracker.finish(receiveId);
    }
  }
}",0.8458692971639951
173068,"@Override public void progress(){
  delegete.progress();
  if (finalReceiverProgress.compareAndSet(false,true)) {
    finalReceiver.progress();
    finalReceiverProgress.compareAndSet(true,false);
  }
  if (partialRecevierProgress.compareAndSet(false,true)) {
    partialReceiver.progress();
    partialRecevierProgress.compareAndSet(true,false);
  }
}","@Override public void progress(){
  delegete.progress();
  if (lock.tryLock()) {
    try {
      finalReceiver.progress();
    }
  finally {
      lock.unlock();
    }
  }
  if (partialLock.tryLock()) {
    try {
      partialReceiver.progress();
    }
  finally {
      partialLock.unlock();
    }
  }
}",0.3201219512195122
173069,"public void finish(int item){
  progressItems.offer(item);
}","public void finish(int item){
  boolean offer=progressItems.offer(item);
  if (!offer) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.5853658536585366
173070,"/** 
 * Progress the communications that are pending
 */
public void progress(){
  while (pendingSends.size() > 0) {
    MPISendRequests sendRequests=pendingSends.poll();
    if (sendRequests != null) {
      postMessage(sendRequests);
      waitForCompletionSends.add(sendRequests);
    }
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    if (receiveRequests.availableBuffers.size() > 0) {
      postReceive(receiveRequests);
    }
  }
  Iterator<MPISendRequests> sendRequestsIterator=waitForCompletionSends.iterator();
  while (sendRequestsIterator.hasNext()) {
    MPISendRequests sendRequests=sendRequestsIterator.next();
    Iterator<MPIRequest> requestIterator=sendRequests.pendingSends.iterator();
    while (requestIterator.hasNext()) {
      MPIRequest r=requestIterator.next();
      try {
        Status status=r.request.testStatus();
        if (status != null) {
          completedSendCount++;
          requestIterator.remove();
        }
      }
 catch (      MPIException e) {
        throw new RuntimeException(""String_Node_Str"" + sendRequests.rank,e);
      }
    }
    if (sendRequests.pendingSends.size() == 0) {
      sendRequests.callback.onSendComplete(sendRequests.rank,sendRequests.edge,sendRequests.message);
      sendRequestsIterator.remove();
    }
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    try {
      Iterator<MPIRequest> requestIterator=receiveRequests.pendingRequests.iterator();
      while (requestIterator.hasNext()) {
        MPIRequest r=requestIterator.next();
        Status status=r.request.testStatus();
        if (status != null) {
          if (!status.isCancelled()) {
            ++receiveCount;
            r.buffer.setSize(status.getCount(MPI.BYTE));
            receiveRequests.callback.onReceiveComplete(receiveRequests.rank,receiveRequests.edge,r.buffer);
            requestIterator.remove();
          }
 else {
            throw new RuntimeException(""String_Node_Str"");
          }
        }
      }
    }
 catch (    MPIException e) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
}","/** 
 * Progress the communications that are pending
 */
public void progress(){
  while (pendingSends.size() > 0) {
    MPISendRequests sendRequests=pendingSends.poll();
    if (sendRequests != null) {
      postMessage(sendRequests);
      waitForCompletionSends.add(sendRequests);
    }
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    if (debug) {
      LOG.info(String.format(""String_Node_Str"",executor,receiveRequests.rank,receiveRequests.availableBuffers.size(),receiveRequests.availableBuffers.peek()));
    }
    if (receiveRequests.availableBuffers.size() > 0) {
      postReceive(receiveRequests);
    }
  }
  Iterator<MPISendRequests> sendRequestsIterator=waitForCompletionSends.iterator();
  while (sendRequestsIterator.hasNext()) {
    MPISendRequests sendRequests=sendRequestsIterator.next();
    Iterator<MPIRequest> requestIterator=sendRequests.pendingSends.iterator();
    while (requestIterator.hasNext()) {
      MPIRequest r=requestIterator.next();
      try {
        Status status=r.request.testStatus();
        if (status != null) {
          completedSendCount++;
          requestIterator.remove();
        }
      }
 catch (      MPIException e) {
        throw new RuntimeException(""String_Node_Str"" + sendRequests.rank,e);
      }
    }
    if (sendRequests.pendingSends.size() == 0) {
      sendRequests.callback.onSendComplete(sendRequests.rank,sendRequests.edge,sendRequests.message);
      sendRequestsIterator.remove();
    }
  }
  if (debug) {
    LOG.info(String.format(""String_Node_Str"",executor,sendCount,completedSendCount,receiveCount,pendingReceiveCount,pendingSends.size(),waitForCompletionSends.size()));
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    try {
      Iterator<MPIRequest> requestIterator=receiveRequests.pendingRequests.iterator();
      while (requestIterator.hasNext()) {
        MPIRequest r=requestIterator.next();
        Status status=r.request.testStatus();
        if (status != null) {
          if (!status.isCancelled()) {
            ++receiveCount;
            r.buffer.setSize(status.getCount(MPI.BYTE));
            receiveRequests.callback.onReceiveComplete(receiveRequests.rank,receiveRequests.edge,r.buffer);
            requestIterator.remove();
          }
 else {
            throw new RuntimeException(""String_Node_Str"");
          }
        }
      }
    }
 catch (    MPIException e) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
}",0.924486057398738
173071,"@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  this.executor=op.getTaskPlan().getThisExecutor();
  this.operation=op;
  this.sendPendingMax=MPIContext.sendPendingMax(cfg);
  this.reducedValues=new ArrayBlockingQueue<>(sendPendingMax);
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,List<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    for (    int i : e.getValue()) {
      messagesPerTask.put(i,new ArrayList<Object>());
      countsPerTask.put(i,0);
    }
    LOG.fine(String.format(""String_Node_Str"",executor,e.getKey(),e.getValue().toString()));
    messages.put(e.getKey(),messagesPerTask);
    counts.put(e.getKey(),countsPerTask);
  }
}","@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  this.executor=op.getTaskPlan().getThisExecutor();
  this.operation=op;
  this.sendPendingMax=MPIContext.sendPendingMax(cfg);
  this.reducedValues=new ArrayBlockingQueue<>(sendPendingMax);
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,List<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    Map<Integer,Integer> totalCountsPerTask=new HashMap<>();
    for (    int i : e.getValue()) {
      messagesPerTask.put(i,new ArrayList<Object>());
      countsPerTask.put(i,0);
      totalCountsPerTask.put(i,0);
    }
    LOG.fine(String.format(""String_Node_Str"",executor,e.getKey(),e.getValue().toString()));
    messages.put(e.getKey(),messagesPerTask);
    counts.put(e.getKey(),countsPerTask);
    totalCounts.put(e.getKey(),totalCountsPerTask);
  }
}",0.9146482122260668
173072,"@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  List<Object> m=messages.get(target).get(source);
  Integer c=counts.get(target).get(source);
  if (m.size() > sendPendingMax) {
    canAdd=false;
  }
 else {
    m.add(object);
    counts.get(target).put(source,c + 1);
  }
  return canAdd;
}","@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  List<Object> m=messages.get(target).get(source);
  Integer c=counts.get(target).get(source);
  if (m.size() > sendPendingMax * 4) {
    canAdd=false;
    onMessageAttempts++;
  }
 else {
    onMessageAttempts=0;
    m.add(object);
    counts.get(target).put(source,c + 1);
    Integer tc=totalCounts.get(target).get(source);
    totalCounts.get(target).put(source,tc + 1);
  }
  return canAdd;
}",0.8229885057471265
173073,"@Override public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    Map<Integer,List<Object>> messagePerTarget=messages.get(t);
    Map<Integer,Integer> countsPerTarget=counts.get(t);
    while (canProgress) {
      boolean found=true;
      for (      Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
      }
      if (found && reducedValues.size() < sendPendingMax) {
        Object previous=null;
        for (        Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
          if (previous == null) {
            previous=e.getValue().remove(0);
          }
 else {
            Object current=e.getValue().remove(0);
            previous=reduceFunction.reduce(previous,current);
          }
        }
        if (previous != null) {
          reducedValues.offer(previous);
        }
      }
      if (reducedValues.size() > 0) {
        Object previous=reducedValues.peek();
        boolean handle=handleMessage(t,previous,0,destination);
        if (handle) {
          reducedValues.poll();
          for (          Map.Entry<Integer,Integer> e : countsPerTarget.entrySet()) {
            Integer i=e.getValue();
            countsPerTarget.put(e.getKey(),i - 1);
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}","@Override public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    Map<Integer,List<Object>> messagePerTarget=messages.get(t);
    Map<Integer,Integer> countsPerTarget=counts.get(t);
    Map<Integer,Integer> totalCountMap=totalCounts.get(t);
    while (canProgress) {
      boolean found=true;
      for (      Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
      }
      if (found && reducedValues.size() < sendPendingMax) {
        Object previous=null;
        for (        Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
          if (previous == null) {
            previous=e.getValue().remove(0);
          }
 else {
            Object current=e.getValue().remove(0);
            previous=reduceFunction.reduce(previous,current);
          }
        }
        if (previous != null) {
          reducedValues.offer(previous);
        }
      }
 else {
        progressAttempts++;
      }
      if (reducedValues.size() > 0) {
        Object previous=reducedValues.peek();
        boolean handle=handleMessage(t,previous,0,destination);
        if (handle) {
          reducedValues.poll();
          for (          Map.Entry<Integer,Integer> e : countsPerTarget.entrySet()) {
            Integer i=e.getValue();
            countsPerTarget.put(e.getKey(),i - 1);
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}",0.9653315382026254
173074,"@Override public void run(){
  try {
    LOG.log(Level.INFO,""String_Node_Str"" + id);
    IntData data=generateData();
    for (int i=0; i < 1000; i++) {
      int flag=0;
      if (i == 1000 - 1) {
        flag=MessageFlags.FLAGS_LAST;
      }
      while (!reduce.send(task,data,flag)) {
        reduce.progress();
      }
      if (i % 100 == 0) {
        LOG.info(String.format(""String_Node_Str"",id,i));
      }
      Thread.yield();
    }
    LOG.info(String.format(""String_Node_Str"",id));
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}","@Override public void run(){
  try {
    LOG.log(Level.INFO,""String_Node_Str"" + id);
    IntData data=generateData();
    for (int i=0; i < 1000; i++) {
      int flag=0;
      if (i == 1000 - 1) {
        flag=MessageFlags.FLAGS_LAST;
      }
      while (!reduce.send(task,data,flag)) {
        reduce.progress();
        Thread.yield();
      }
      if (i % 100 == 0) {
        LOG.info(String.format(""String_Node_Str"",id,i));
      }
      Thread.yield();
    }
    LOG.info(String.format(""String_Node_Str"",id));
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}",0.9787610619469026
173075,"@Override public void run(){
  try {
    LOG.log(Level.INFO,""String_Node_Str"" + id);
    IntData data=generateData();
    for (int i=0; i < 6000; i++) {
      while (!reduce.send(task,data,0)) {
        reduce.progress();
      }
      if (i % 100 == 0) {
        LOG.info(String.format(""String_Node_Str"",id,i));
      }
    }
    LOG.info(String.format(""String_Node_Str"",id));
    status=Status.MAP_FINISHED;
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}","@Override public void run(){
  try {
    LOG.log(Level.INFO,""String_Node_Str"" + id);
    IntData data=generateData();
    for (int i=0; i < 6000; i++) {
      while (!reduce.send(task,data,0)) {
        reduce.progress();
        Thread.yield();
      }
      if (i % 100 == 0) {
        LOG.info(String.format(""String_Node_Str"",id,i));
      }
    }
    LOG.info(String.format(""String_Node_Str"",id));
    status=Status.MAP_FINISHED;
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}",0.975051975051975
173076,"/** 
 * The destination id is the destination itself
 * @return
 */
public int destinationIdentifier(int source,int path){
  return 0;
}","/** 
 * The destination id is the destination itself
 */
public int destinationIdentifier(int source,int path){
  return 0;
}",0.9578544061302682
173077,"/** 
 * Create a direct router
 * @param plan
 * @param srscs
 * @param dests
 */
public PartitionRouter(TaskPlan plan,Set<Integer> srscs,Set<Integer> dests){
  this.taskPlan=plan;
  this.externalSendTasks=new HashMap<>();
  this.internalSendTasks=new HashMap<>();
  Set<Integer> myTasks=taskPlan.getChannelsOfExecutor(taskPlan.getThisExecutor());
  for (  int src : srscs) {
    if (myTasks.contains(src)) {
      for (      int dest : dests) {
        if (myTasks.contains(dest)) {
          Set<Integer> set=new HashSet<>();
          set.add(dest);
          internalSendTasks.put(src,set);
        }
 else {
          Set<Integer> set=new HashSet<>();
          set.add(dest);
          externalSendTasks.put(src,set);
        }
      }
    }
  }
  this.upstream=new HashMap<>();
  List<Integer> sources=new ArrayList<>();
  sources.addAll(srscs);
  for (  int dest : dests) {
    if (myTasks.contains(dest)) {
      this.upstream.put(dest,sources);
    }
  }
  receiveExecutors=PartitionRouter.getExecutorsHostingTasks(plan,srscs);
  receiveExecutors.remove(taskPlan.getThisExecutor());
  this.thisExecutorTasks=taskPlan.getChannelsOfExecutor(taskPlan.getThisExecutor());
}","/** 
 * Create a direct router
 */
public PartitionRouter(TaskPlan plan,Set<Integer> srscs,Set<Integer> dests){
  this.taskPlan=plan;
  this.externalSendTasks=new HashMap<>();
  this.internalSendTasks=new HashMap<>();
  Set<Integer> myTasks=taskPlan.getChannelsOfExecutor(taskPlan.getThisExecutor());
  for (  int src : srscs) {
    if (myTasks.contains(src)) {
      for (      int dest : dests) {
        if (myTasks.contains(dest)) {
          if (!internalSendTasks.containsKey(src)) {
            Set<Integer> set=new HashSet<>();
            set.add(dest);
            internalSendTasks.put(src,set);
          }
 else {
            internalSendTasks.get(src).add(dest);
          }
        }
 else {
          if (!externalSendTasks.containsKey(src)) {
            Set<Integer> set=new HashSet<>();
            set.add(dest);
            externalSendTasks.put(src,set);
          }
 else {
            externalSendTasks.get(src).add(dest);
          }
        }
      }
    }
  }
  this.upstream=new HashMap<>();
  List<Integer> sources=new ArrayList<>();
  sources.addAll(srscs);
  for (  int dest : dests) {
    if (myTasks.contains(dest)) {
      this.upstream.put(dest,sources);
    }
  }
  receiveExecutors=PartitionRouter.getExecutorsHostingTasks(plan,srscs);
  receiveExecutors.remove(taskPlan.getThisExecutor());
  this.thisExecutorTasks=taskPlan.getChannelsOfExecutor(taskPlan.getThisExecutor());
}",0.8499807173158503
173078,"public static Object deserializeData(List<MPIBuffer> buffers,int length,KryoSerializer serializer,MessageType type){
switch (type) {
case INTEGER:
    return deserializeInteger(buffers,length);
case DOUBLE:
  return deserializeDouble(buffers,length);
case SHORT:
return deserializeShort(buffers,length);
case OBJECT:
return deserializeObject(buffers,length,serializer);
default :
break;
}
return null;
}","public static Object deserializeData(List<MPIBuffer> buffers,int length,KryoSerializer serializer,MessageType type){
switch (type) {
case INTEGER:
    return deserializeInteger(buffers,length);
case DOUBLE:
  return deserializeDouble(buffers,length);
case SHORT:
return deserializeShort(buffers,length);
case BYTE:
return deserializeBytes(buffers,length);
case OBJECT:
return deserializeObject(buffers,length,serializer);
default :
break;
}
return null;
}",0.9393939393939394
173079,"public static Object deserializeValue(ByteBuffer value,DataMessageType valueType,KryoMemorySerializer serializer){
switch (valueType) {
case INTEGER:
    return deserializeInteger(value);
case DOUBLE:
  return deserializeDouble(value);
case SHORT:
return deserializeShort(value);
case BYTE:
byte[] bytes=new byte[value.remaining()];
value.get(bytes);
return bytes;
case OBJECT:
return deserializeObject(value,serializer);
default :
break;
}
return null;
}","public static Object deserializeValue(ByteBuffer value,DataMessageType valueType,KryoMemorySerializer serializer){
switch (valueType) {
case INTEGER:
    return deserializeInteger(value);
case DOUBLE:
  return deserializeDouble(value);
case SHORT:
return deserializeShort(value);
case BYTE:
return deserializeBytes(value,serializer);
case OBJECT:
return deserializeObject(value,serializer);
default :
break;
}
return null;
}",0.8714448236632537
173080,"public static Object deserializeObject(ByteBuffer data,KryoMemorySerializer serializer){
  int length=data.getInt();
  if (length != data.remaining()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  byte[] temp=new byte[data.remaining()];
  data.get(temp);
  return serializer.deserialize(temp);
}","public static Object deserializeObject(ByteBuffer data,KryoMemorySerializer serializer){
  int length=data.getInt();
  List<Object> dataList=new ArrayList<>();
  while (data.remaining() > 4) {
    if (length > data.remaining()) {
      throw new RuntimeException(""String_Node_Str"");
    }
    byte[] temp=new byte[length];
    data.get(temp);
    dataList.add(serializer.deserialize(temp));
  }
  return dataList;
}",0.7247579529737206
173081,"@Override @SuppressWarnings(""String_Node_Str"") public void receive(int target,Iterator<Object> it){
  int itercount=0;
  Object temp;
  while (it.hasNext()) {
    itercount++;
    temp=it.next();
    if (temp instanceof ImmutablePair) {
      ImmutablePair<Object,Object> data=(ImmutablePair<Object,Object>)temp;
      LOG.info(""String_Node_Str"" + ByteBuffer.wrap((byte[])data.getKey()).getInt() + ""String_Node_Str""+ Arrays.toString((int[])data.getValue()));
    }
  }
}","@Override @SuppressWarnings(""String_Node_Str"") public void receive(int target,Iterator<Object> it){
  int itercount=0;
  Object temp;
  while (it.hasNext()) {
    itercount++;
    temp=it.next();
    if (temp instanceof ImmutablePair) {
      ImmutablePair<Object,Object> data=(ImmutablePair<Object,Object>)temp;
      if (data.getValue() instanceof List) {
        byte[] tempData=(byte[])((List)data.getValue()).get(0);
        LOG.info(""String_Node_Str"" + ByteBuffer.wrap((byte[])data.getKey()).getInt() + ""String_Node_Str""+ Arrays.toString(tempData));
      }
 else {
        LOG.info(""String_Node_Str"" + ByteBuffer.wrap((byte[])data.getKey()).getInt() + ""String_Node_Str""+ Arrays.toString((byte[])data.getValue()));
      }
    }
  }
}",0.5933884297520661
173082,"@Override public void run(){
  try {
    LOG.log(Level.INFO,""String_Node_Str"" + id);
    startTime=System.nanoTime();
    for (int i=0; i < 1; i++) {
      int[] data={task,task * 100};
      int keyint=task * 111;
      byte[] key=ByteBuffer.allocate(4).putInt(keyint).array();
      int flags=MessageFlags.FLAGS_LAST;
      KeyedContent mesage=new KeyedContent(key,data,MessageType.BYTE,MessageType.INTEGER);
      while (!aggregate.send(task,mesage,flags)) {
        try {
          Thread.sleep(1);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      Thread.yield();
    }
    LOG.info(String.format(""String_Node_Str"",id));
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}","@Override public void run(){
  try {
    LOG.log(Level.INFO,""String_Node_Str"" + id);
    startTime=System.nanoTime();
    for (int i=0; i < 1; i++) {
      byte[] data=new byte[12];
      data[0]='a';
      data[1]='b';
      data[2]='c';
      data[3]='d';
      data[4]='d';
      data[5]='d';
      data[6]='d';
      data[7]='d';
      int keyint=task * 111;
      byte[] key=ByteBuffer.allocate(4).putInt(keyint).array();
      int flags=MessageFlags.FLAGS_LAST;
      KeyedContent mesage=new KeyedContent(key,data,MessageType.BYTE,MessageType.BYTE);
      while (!aggregate.send(task,mesage,flags)) {
        try {
          Thread.sleep(1);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      Thread.yield();
    }
    LOG.info(String.format(""String_Node_Str"",id));
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}",0.8729281767955801
173083,"/** 
 * Serialize the message object and send it to store
 * @param mpiSendMessage mpi send message that has information
 * @param messageObject object to be sent
 */
private boolean serializeAndWriteToMemoryManager(MPISendMessage mpiSendMessage,Object messageObject){
  if (isKeyed) {
    KeyedContent kc=(KeyedContent)messageObject;
    ByteBuffer keyBuffer=KeySerializer.getserializedKey(kc.getSource(),mpiSendMessage.getSerializationState(),keyType,kryoSerializer);
    ByteBuffer dataBuffer=DataSerializer.getserializedData(kc.getObject(),type,kryoSerializer);
    return operationMemoryManager.put(keyBuffer,dataBuffer);
  }
 else {
    int key=mpiSendMessage.getSource();
    ByteBuffer keyBuffer=ByteBuffer.allocateDirect(Integer.BYTES);
    keyBuffer.putInt(key);
    ByteBuffer dataBuffer=DataSerializer.getserializedData(messageObject,type,kryoSerializer);
    return operationMemoryManager.put(keyBuffer,dataBuffer);
  }
}","/** 
 * Serialize the message object and send it to store
 * @param mpiSendMessage mpi send message that has information
 * @param messageObject object to be sent
 */
private boolean serializeAndWriteToMemoryManager(MPISendMessage mpiSendMessage,Object messageObject){
  if (mpiSendMessage.getSerializationState() == null) {
    mpiSendMessage.setSerializationState(new SerializeState());
  }
  if (isKeyed) {
    KeyedContent kc=(KeyedContent)messageObject;
    ByteBuffer keyBuffer=KeySerializer.getserializedKey(kc.getSource(),mpiSendMessage.getSerializationState(),keyType,kryoSerializer);
    ByteBuffer dataBuffer=DataSerializer.getserializedData(kc.getObject(),type,kryoSerializer);
    return operationMemoryManager.put(keyBuffer,dataBuffer);
  }
 else {
    int key=mpiSendMessage.getSource();
    ByteBuffer keyBuffer=ByteBuffer.allocateDirect(Integer.BYTES);
    keyBuffer.putInt(key);
    ByteBuffer dataBuffer=DataSerializer.getserializedData(messageObject,type,kryoSerializer);
    return operationMemoryManager.put(keyBuffer,dataBuffer);
  }
}",0.9377510040160644
173084,"@Override public Object getDataBuffers(Object partialObject,int edge){
  MPIMessage currentMessage=(MPIMessage)partialObject;
  int readLength=0;
  int bufferIndex=0;
  List<MPIBuffer> buffers=currentMessage.getBuffers();
  List<Object> returnList=new ArrayList<>();
  MessageHeader header=currentMessage.getHeader();
  if (header == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  while (readLength < header.getLength()) {
    List<MPIBuffer> messageBuffers=new ArrayList<>();
    MPIBuffer mpiBuffer=buffers.get(bufferIndex);
    ByteBuffer byteBuffer=mpiBuffer.getByteBuffer();
    int length=byteBuffer.getInt();
    int tempLength=0;
    int tempBufferIndex=bufferIndex;
    while (tempLength < length) {
      mpiBuffer=buffers.get(tempBufferIndex);
      messageBuffers.add(mpiBuffer);
      tempLength+=mpiBuffer.getByteBuffer().remaining();
      tempBufferIndex++;
    }
    Object object=getSingleDataBuffers(currentMessage,messageBuffers,length);
    readLength+=length + 4;
    byteBuffer=mpiBuffer.getByteBuffer();
    if (byteBuffer.remaining() > 0) {
      bufferIndex=tempBufferIndex - 1;
    }
 else {
      bufferIndex=tempBufferIndex;
    }
    returnList.add(object);
  }
  return returnList;
}","@Override public Object getDataBuffers(Object partialObject,int edge){
  MPIMessage currentMessage=(MPIMessage)partialObject;
  int readLength=0;
  int bufferIndex=0;
  List<MPIBuffer> buffers=currentMessage.getBuffers();
  List<Object> returnList=new ArrayList<>();
  MessageHeader header=currentMessage.getHeader();
  if (header == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  while (readLength < header.getLength()) {
    List<MPIBuffer> messageBuffers=new ArrayList<>();
    MPIBuffer mpiBuffer=buffers.get(bufferIndex);
    ByteBuffer byteBuffer=mpiBuffer.getByteBuffer();
    int length=byteBuffer.getInt();
    int tempLength=0;
    int tempBufferIndex=bufferIndex;
    while (tempLength < length) {
      mpiBuffer=buffers.get(tempBufferIndex);
      messageBuffers.add(mpiBuffer);
      tempLength+=mpiBuffer.getByteBuffer().remaining();
      tempBufferIndex++;
    }
    Object object=getSingleDataBuffers(currentMessage,messageBuffers,length);
    readLength+=length + 4;
    if (keyed) {
      readLength+=4;
    }
    byteBuffer=mpiBuffer.getByteBuffer();
    if (byteBuffer.remaining() > 0) {
      bufferIndex=tempBufferIndex - 1;
    }
 else {
      bufferIndex=tempBufferIndex;
    }
    returnList.add(object);
  }
  return returnList;
}",0.981658692185008
173085,"@Override public Object build(Object partialObject,int edge){
  MPIMessage currentMessage=(MPIMessage)partialObject;
  int readLength=0;
  int bufferIndex=0;
  List<MPIBuffer> buffers=currentMessage.getBuffers();
  List<Object> returnList=new ArrayList<>();
  MessageHeader header=currentMessage.getHeader();
  if (header == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  while (readLength < header.getLength()) {
    List<MPIBuffer> messageBuffers=new ArrayList<>();
    MPIBuffer mpiBuffer=buffers.get(bufferIndex);
    ByteBuffer byteBuffer=mpiBuffer.getByteBuffer();
    int length=byteBuffer.getInt();
    int tempLength=0;
    int tempBufferIndex=bufferIndex;
    while (tempLength < length) {
      mpiBuffer=buffers.get(tempBufferIndex);
      messageBuffers.add(mpiBuffer);
      tempLength+=mpiBuffer.getByteBuffer().remaining();
      tempBufferIndex++;
    }
    Object object=buildMessage(currentMessage,messageBuffers,length);
    readLength+=length + 4;
    byteBuffer=mpiBuffer.getByteBuffer();
    if (byteBuffer.remaining() > 0) {
      bufferIndex=tempBufferIndex - 1;
    }
 else {
      bufferIndex=tempBufferIndex;
    }
    returnList.add(object);
  }
  return returnList;
}","@Override public Object build(Object partialObject,int edge){
  MPIMessage currentMessage=(MPIMessage)partialObject;
  int readLength=0;
  int bufferIndex=0;
  List<MPIBuffer> buffers=currentMessage.getBuffers();
  List<Object> returnList=new ArrayList<>();
  MessageHeader header=currentMessage.getHeader();
  if (header == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  while (readLength < header.getLength()) {
    List<MPIBuffer> messageBuffers=new ArrayList<>();
    MPIBuffer mpiBuffer=buffers.get(bufferIndex);
    ByteBuffer byteBuffer=mpiBuffer.getByteBuffer();
    int length=byteBuffer.getInt();
    int tempLength=0;
    int tempBufferIndex=bufferIndex;
    while (tempLength < length) {
      mpiBuffer=buffers.get(tempBufferIndex);
      messageBuffers.add(mpiBuffer);
      tempLength+=mpiBuffer.getByteBuffer().remaining();
      tempBufferIndex++;
    }
    Object object=buildMessage(currentMessage,messageBuffers,length);
    readLength+=length + 4;
    if (keyed) {
      readLength+=4;
    }
    byteBuffer=mpiBuffer.getByteBuffer();
    if (byteBuffer.remaining() > 0) {
      bufferIndex=tempBufferIndex - 1;
    }
 else {
      bufferIndex=tempBufferIndex;
    }
    returnList.add(object);
  }
  return returnList;
}",0.9814066289409864
173086,"private static byte[] readBytes(List<MPIBuffer> buffers,int length){
  byte[] bytes=new byte[length];
  int currentRead=0;
  int index=0;
  while (currentRead < length) {
    ByteBuffer byteBuffer=buffers.get(index).getByteBuffer();
    int remaining=byteBuffer.remaining();
    int needRead=length - currentRead;
    int canRead=remaining > needRead ? needRead : remaining;
    byteBuffer.get(bytes,currentRead,canRead);
    currentRead+=canRead;
    index++;
    if (index >= buffers.size()) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return bytes;
}","private static byte[] readBytes(List<MPIBuffer> buffers,int length){
  byte[] bytes=new byte[length];
  int currentRead=0;
  int index=0;
  while (currentRead < length) {
    ByteBuffer byteBuffer=buffers.get(index).getByteBuffer();
    int remaining=byteBuffer.remaining();
    int needRead=length - currentRead;
    int canRead=remaining > needRead ? needRead : remaining;
    byteBuffer.get(bytes,currentRead,canRead);
    currentRead+=canRead;
    index++;
    if (currentRead < length && index >= buffers.size()) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return bytes;
}",0.979591836734694
173087,"public static Object deserializeValue(ByteBuffer value,DataMessageType valueType,KryoMemorySerializer serializer){
switch (valueType) {
case INTEGER:
    return deserializeInteger(value);
case DOUBLE:
  return deserializeDouble(value);
case SHORT:
return deserializeShort(value);
case OBJECT:
return deserializeObject(value,serializer);
default :
break;
}
return null;
}","public static Object deserializeValue(ByteBuffer value,DataMessageType valueType,KryoMemorySerializer serializer){
switch (valueType) {
case INTEGER:
    return deserializeInteger(value);
case DOUBLE:
  return deserializeDouble(value);
case SHORT:
return deserializeShort(value);
case BYTE:
byte[] bytes=new byte[value.remaining()];
value.get(bytes);
return bytes;
case OBJECT:
return deserializeObject(value,serializer);
default :
break;
}
return null;
}",0.896969696969697
173088,"public static Object deserializeKey(ByteBuffer key,DataMessageType keyType,KryoMemorySerializer serializer){
switch (keyType) {
case INTEGER:
    return key.getInt();
case DOUBLE:
  return key.getDouble();
case SHORT:
return key.getShort();
case OBJECT:
byte[] temp=new byte[key.remaining()];
key.get(temp);
return serializer.deserialize(temp);
default :
break;
}
return null;
}","public static Object deserializeKey(ByteBuffer key,DataMessageType keyType,KryoMemorySerializer serializer){
switch (keyType) {
case INTEGER:
    return key.getInt();
case DOUBLE:
  return key.getDouble();
case SHORT:
return key.getShort();
case BYTE:
byte[] bytes=new byte[key.remaining()];
key.get(bytes);
return bytes;
case OBJECT:
byte[] temp=new byte[key.remaining()];
key.get(temp);
return serializer.deserialize(temp);
default :
break;
}
return null;
}",0.9032258064516128
173089,"private static Thread createAsyncStreamThread(final InputStream input,final StringBuilder processOutputStringBuilder,final boolean isVerbose){
  Thread thread=new Thread(){
    @Override public void run(){
      LOG.log(Level.FINE,""String_Node_Str"");
      BufferedReader reader=new BufferedReader(new InputStreamReader(input),1);
      while (true) {
        String line=null;
        try {
          line=reader.readLine();
        }
 catch (        IOException e) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
        if (line == null) {
          break;
        }
 else {
          System.err.println(line);
          if (processOutputStringBuilder != null) {
            processOutputStringBuilder.append(line);
          }
        }
      }
      try {
        input.close();
      }
 catch (      IOException e) {
        LOG.log(Level.WARNING,""String_Node_Str"",e);
      }
    }
  }
;
  thread.setDaemon(true);
  return thread;
}","private static Thread createAsyncStreamThread(final InputStream input,final StringBuilder processOutputStringBuilder,final boolean isVerbose){
  Thread thread=new Thread(){
    @Override public void run(){
      LOG.log(Level.FINE,""String_Node_Str"");
      BufferedReader reader=new BufferedReader(new InputStreamReader(input),1);
      while (true) {
        String line=null;
        try {
          line=reader.readLine();
        }
 catch (        IOException e) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
        if (line == null) {
          break;
        }
 else {
          System.err.println(line);
        }
      }
      try {
        input.close();
      }
 catch (      IOException e) {
        LOG.log(Level.WARNING,""String_Node_Str"",e);
      }
    }
  }
;
  thread.setDaemon(true);
  return thread;
}",0.9348189415041784
173090,"@Override public void run(){
  LOG.log(Level.FINE,""String_Node_Str"");
  BufferedReader reader=new BufferedReader(new InputStreamReader(input),1);
  while (true) {
    String line=null;
    try {
      line=reader.readLine();
    }
 catch (    IOException e) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
    if (line == null) {
      break;
    }
 else {
      System.err.println(line);
      if (processOutputStringBuilder != null) {
        processOutputStringBuilder.append(line);
      }
    }
  }
  try {
    input.close();
  }
 catch (  IOException e) {
    LOG.log(Level.WARNING,""String_Node_Str"",e);
  }
}","@Override public void run(){
  LOG.log(Level.FINE,""String_Node_Str"");
  BufferedReader reader=new BufferedReader(new InputStreamReader(input),1);
  while (true) {
    String line=null;
    try {
      line=reader.readLine();
    }
 catch (    IOException e) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
    if (line == null) {
      break;
    }
 else {
      System.err.println(line);
    }
  }
  try {
    input.close();
  }
 catch (  IOException e) {
    LOG.log(Level.WARNING,""String_Node_Str"",e);
  }
}",0.9081364829396326
173091,"public boolean passMessageDownstream(Object object,MPIMessage currentMessage){
  int src=router.mainTaskOfExecutor(instancePlan.getThisExecutor(),MPIContext.DEFAULT_PATH);
  RoutingParameters routingParameters=sendRoutingParameters(src,MPIContext.DEFAULT_PATH);
  ArrayBlockingQueue<Pair<Object,MPISendMessage>> pendingSendMessages=pendingSendMessagesPerSource.get(src);
  MPIMessage mpiMessage=new MPIMessage(src,type,MPIMessageDirection.OUT,delegete);
  int di=-1;
  if (routingParameters.getExternalRoutes().size() > 0) {
    di=routingParameters.getDestinationId();
  }
  MPISendMessage sendMessage=new MPISendMessage(src,mpiMessage,edge,di,MPIContext.DEFAULT_PATH,currentMessage.getHeader().getFlags(),routingParameters.getInternalRoutes(),routingParameters.getExternalRoutes());
  return pendingSendMessages.offer(new ImmutablePair<Object,MPISendMessage>(object,sendMessage));
}","public boolean passMessageDownstream(Object object,MPIMessage currentMessage){
  int src=router.mainTaskOfExecutor(instancePlan.getThisExecutor(),MPIContext.DEFAULT_PATH);
  RoutingParameters routingParameters=sendRoutingParameters(src,MPIContext.DEFAULT_PATH);
  ArrayBlockingQueue<Pair<Object,MPISendMessage>> pendingSendMessages=pendingSendMessagesPerSource.get(src);
  MPIMessage mpiMessage=new MPIMessage(src,type,MPIMessageDirection.OUT,delegete);
  int di=-1;
  if (routingParameters.getExternalRoutes().size() > 0) {
    di=routingParameters.getDestinationId();
  }
  MPISendMessage sendMessage=new MPISendMessage(src,mpiMessage,currentMessage.getHeader().getEdge(),di,MPIContext.DEFAULT_PATH,currentMessage.getHeader().getFlags(),routingParameters.getInternalRoutes(),routingParameters.getExternalRoutes());
  return pendingSendMessages.offer(new ImmutablePair<Object,MPISendMessage>(object,sendMessage));
}",0.9777777777777776
173092,"public void setStoreBased(boolean storeBased){
  isStoreBased=storeBased;
  if (isStoreBased) {
    opertionID=(int)System.currentTimeMillis();
    Path dataPath=new Path(""String_Node_Str"");
    this.memoryManager=new LMDBMemoryManager(dataPath);
    if (!isKeyed) {
      this.operationMemoryManager=memoryManager.addOperation(opertionID,MessageTypeConverter.toDataMessageType(type));
    }
 else {
      this.operationMemoryManager=memoryManager.addOperation(opertionID,MessageTypeConverter.toDataMessageType(type),MessageTypeConverter.toDataMessageType(keyType));
    }
  }
}","public void setStoreBased(boolean storeBased){
  isStoreBased=storeBased;
  if (isStoreBased) {
    opertionID=(int)System.currentTimeMillis();
    this.kryoSerializer=new KryoSerializer();
    Path dataPath=new Path(""String_Node_Str"");
    this.memoryManager=new LMDBMemoryManager(dataPath);
    if (!isKeyed) {
      this.operationMemoryManager=memoryManager.addOperation(opertionID,MessageTypeConverter.toDataMessageType(type));
    }
 else {
      this.operationMemoryManager=memoryManager.addOperation(opertionID,MessageTypeConverter.toDataMessageType(type),MessageTypeConverter.toDataMessageType(keyType));
    }
  }
}",0.961730449251248
173093,"@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  List<Object> m=messages.get(target).get(source);
  Map<Integer,Boolean> finishedMessages=finished.get(target);
  if (m.size() > sendPendingMax) {
    canAdd=false;
    LOG.info(String.format(""String_Node_Str"",executor,target,source,counts.get(target)));
  }
 else {
    LOG.info(String.format(""String_Node_Str"",executor,target,source));
    if (object instanceof MPIMessage) {
      ((MPIMessage)object).incrementRefCount();
    }
    Integer c=counts.get(target).get(source);
    counts.get(target).put(source,c + 1);
    m.add(object);
    if ((flags & MessageFlags.FLAGS_LAST) == MessageFlags.FLAGS_LAST) {
      LOG.info(String.format(""String_Node_Str"",executor,target,source));
      finishedMessages.put(source,true);
    }
  }
  return canAdd;
}","@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  List<Object> m=messages.get(target).get(source);
  Map<Integer,Boolean> finishedMessages=finished.get(target);
  if (m.size() > sendPendingMax) {
    canAdd=false;
    LOG.info(String.format(""String_Node_Str"",executor,target,source,counts.get(target),finalMessages.size()));
  }
 else {
    LOG.info(String.format(""String_Node_Str"",executor,target,source,finishedMessages.size()));
    if (object instanceof MPIMessage) {
      ((MPIMessage)object).incrementRefCount();
    }
    Integer c=counts.get(target).get(source);
    counts.get(target).put(source,c + 1);
    m.add(object);
    if ((flags & MessageFlags.FLAGS_LAST) == MessageFlags.FLAGS_LAST) {
      LOG.info(String.format(""String_Node_Str"",executor,target,source));
      finishedMessages.put(source,true);
    }
  }
  return canAdd;
}",0.9747616376892876
173094,"/** 
 * Method used to progress work
 */
public void progress(){
  for (  int t : messages.keySet()) {
    if (batchDone.get(t)) {
      continue;
    }
    boolean allFinished=true;
    Map<Integer,List<Object>> map=messages.get(t);
    Map<Integer,Boolean> finishedForTarget=finished.get(t);
    Map<Integer,Integer> countMap=counts.get(t);
    LOG.info(String.format(""String_Node_Str"",executor,t,countMap,finishedForTarget));
    boolean found=true;
    for (    Map.Entry<Integer,List<Object>> e : map.entrySet()) {
      if (e.getValue().size() == 0 && !finishedForTarget.get(e.getKey())) {
        found=false;
      }
      if (!finishedForTarget.get(e.getKey())) {
        allFinished=false;
      }
    }
    if (found) {
      List<Object> out=new ArrayList<>();
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        List<Object> valueList=e.getValue();
        if (valueList.size() > 0) {
          Object value=valueList.get(0);
          out.add(value);
          allFinished=false;
          valueList.remove(0);
        }
      }
      finalMessages.get(t).addAll(out);
    }
 else {
      allFinished=false;
    }
    if (allFinished) {
      LOG.info(String.format(""String_Node_Str"",executor,t));
      batchDone.put(t,true);
      Object previous=null;
      List<Object> finalMessagePerTask=finalMessages.get(t);
      for (int i=0; i < finalMessagePerTask.size(); i++) {
        if (previous == null) {
          previous=finalMessagePerTask.get(i);
        }
 else {
          Object current=finalMessagePerTask.get(i);
          previous=reduceFunction.reduce(previous,current);
        }
      }
      reduceReceiver.receive(t,previous);
    }
  }
}","/** 
 * Method used to progress work
 */
public void progress(){
  for (  int t : messages.keySet()) {
    if (batchDone.get(t)) {
      continue;
    }
    boolean allFinished=true;
    Map<Integer,List<Object>> map=messages.get(t);
    Map<Integer,Boolean> finishedForTarget=finished.get(t);
    Map<Integer,Integer> countMap=counts.get(t);
    LOG.info(String.format(""String_Node_Str"",executor,t,countMap,finishedForTarget));
    boolean found=true;
    for (    Map.Entry<Integer,List<Object>> e : map.entrySet()) {
      if (e.getValue().size() == 0 && !finishedForTarget.get(e.getKey())) {
        found=false;
      }
      if (!finishedForTarget.get(e.getKey())) {
        allFinished=false;
      }
    }
    if (found) {
      List<Object> out=new ArrayList<>();
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        List<Object> valueList=e.getValue();
        if (valueList.size() > 0) {
          Object value=valueList.get(0);
          out.add(value);
          allFinished=false;
          valueList.remove(0);
        }
      }
      for (      Map.Entry<Integer,Integer> e : countMap.entrySet()) {
        Integer i=e.getValue();
        e.setValue(i - 1);
      }
      finalMessages.get(t).addAll(out);
    }
 else {
      allFinished=false;
    }
    if (allFinished) {
      LOG.info(String.format(""String_Node_Str"",executor,t));
      batchDone.put(t,true);
      Object previous=null;
      List<Object> finalMessagePerTask=finalMessages.get(t);
      for (int i=0; i < finalMessagePerTask.size(); i++) {
        if (previous == null) {
          previous=finalMessagePerTask.get(i);
        }
 else {
          Object current=finalMessagePerTask.get(i);
          previous=reduceFunction.reduce(previous,current);
        }
      }
      reduceReceiver.receive(t,previous);
    }
  }
}",0.9609286523216308
173095,"@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  executor=op.getTaskPlan().getThisExecutor();
  sendPendingMax=MPIContext.sendPendingMax(cfg);
  LOG.fine(String.format(""String_Node_Str"",executor,expectedIds));
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,List<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Boolean> finishedPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    for (    int i : e.getValue()) {
      messagesPerTask.put(i,new ArrayList<Object>());
      finishedPerTask.put(i,false);
      countsPerTask.put(i,0);
    }
    messages.put(e.getKey(),messagesPerTask);
    finished.put(e.getKey(),finishedPerTask);
    counts.put(e.getKey(),countsPerTask);
    batchDone.put(e.getKey(),false);
  }
  this.dataFlowOperation=op;
  this.executor=dataFlowOperation.getTaskPlan().getThisExecutor();
}","@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  executor=op.getTaskPlan().getThisExecutor();
  sendPendingMax=MPIContext.sendPendingMax(cfg);
  this.dataFlowOperation=op;
  this.executor=dataFlowOperation.getTaskPlan().getThisExecutor();
  LOG.fine(String.format(""String_Node_Str"",executor,expectedIds));
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,List<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Boolean> finishedPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    for (    int task : e.getValue()) {
      messagesPerTask.put(task,new ArrayList<Object>());
      finishedPerTask.put(task,false);
      countsPerTask.put(task,0);
    }
    messages.put(e.getKey(),messagesPerTask);
    finished.put(e.getKey(),finishedPerTask);
    counts.put(e.getKey(),countsPerTask);
    batchDone.put(e.getKey(),false);
  }
}",0.8887722980062959
173096,"@Override public void progress(){
  for (  int t : messages.keySet()) {
    if (batchDone.get(t)) {
      continue;
    }
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,List<Object>> messagePerTarget=messages.get(t);
      Map<Integer,Boolean> finishedForTarget=finished.get(t);
      Map<Integer,Integer> countMap=counts.get(t);
      LOG.info(String.format(""String_Node_Str"",executor,t,countMap,finishedForTarget));
      boolean found=true;
      boolean allFinished=true;
      for (      Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
        if (e.getValue().size() == 0 && !finishedForTarget.get(e.getKey())) {
          found=false;
          canProgress=false;
        }
        if (!finishedForTarget.get(e.getKey())) {
          allFinished=false;
        }
      }
      if (found) {
        Object previous=null;
        for (        Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
          List<Object> valueList=e.getValue();
          if (valueList.size() > 0) {
            if (previous == null) {
              previous=e.getValue().get(0);
            }
 else {
              Object current=e.getValue().get(0);
              previous=reduceFunction.reduce(previous,current);
            }
          }
        }
        int flags=0;
        boolean last;
        if (allFinished) {
          last=true;
          for (          Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
            List<Object> valueList=e.getValue();
            if (valueList.size() > 1) {
              last=false;
            }
          }
          if (last) {
            flags=MessageFlags.FLAGS_LAST;
          }
        }
        if (dataFlowOperation.sendPartial(t,previous,flags,destination)) {
          boolean allZero=true;
          for (          Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
            List<Object> value=e.getValue();
            if (value.size() > 0) {
              value.remove(0);
            }
            if (value.size() != 0) {
              allZero=false;
            }
          }
          if (allFinished && allZero) {
            batchDone.put(t,true);
            break;
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}","@Override public void progress(){
  for (  int t : messages.keySet()) {
    if (batchDone.get(t)) {
      continue;
    }
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,List<Object>> messagePerTarget=messages.get(t);
      Map<Integer,Boolean> finishedForTarget=finished.get(t);
      Map<Integer,Integer> countMap=counts.get(t);
      LOG.info(String.format(""String_Node_Str"",executor,t,countMap,finishedForTarget));
      boolean found=true;
      boolean allFinished=true;
      for (      Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
        if (e.getValue().size() == 0 && !finishedForTarget.get(e.getKey())) {
          found=false;
          canProgress=false;
        }
        if (!finishedForTarget.get(e.getKey())) {
          allFinished=false;
        }
      }
      if (found) {
        Object previous=null;
        for (        Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
          List<Object> valueList=e.getValue();
          if (valueList.size() > 0) {
            if (previous == null) {
              previous=e.getValue().get(0);
            }
 else {
              Object current=e.getValue().get(0);
              previous=reduceFunction.reduce(previous,current);
            }
          }
        }
        int flags=0;
        boolean last;
        if (allFinished) {
          last=true;
          for (          Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
            List<Object> valueList=e.getValue();
            if (valueList.size() > 1) {
              last=false;
            }
          }
          if (last) {
            flags=MessageFlags.FLAGS_LAST;
          }
        }
        if (dataFlowOperation.sendPartial(t,previous,flags,destination)) {
          boolean allZero=true;
          for (          Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
            List<Object> value=e.getValue();
            if (value.size() > 0) {
              value.remove(0);
            }
            if (value.size() != 0) {
              allZero=false;
            }
          }
          for (          Map.Entry<Integer,Integer> e : countMap.entrySet()) {
            Integer i=e.getValue();
            e.setValue(i - 1);
          }
          if (allFinished && allZero) {
            batchDone.put(t,true);
            break;
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}",0.9669040636782572
173097,"@Override public boolean receive(int target,Object object){
  count++;
  if (count % 1 == 0) {
    LOG.info(String.format(""String_Node_Str"",target,count));
  }
  return true;
}","@Override public boolean receive(int target,Object object){
  count++;
  LOG.info(String.format(""String_Node_Str"",target,count));
  return true;
}",0.906832298136646
173098,"public static int receiveBufferCount(Config cfg){
  return cfg.getIntegerValue(RECEIVE_BUFFERS_COUNT,32);
}","public static int receiveBufferCount(Config cfg){
  return cfg.getIntegerValue(RECEIVE_BUFFERS_COUNT,16);
}",0.9813084112149532
173099,"private boolean sendMessageToTarget(MPIMessage msgObj1,int i){
  msgObj1.incrementRefCount(1);
  int e=instancePlan.getExecutorForChannel(i);
  return channel.sendMessage(e,msgObj1,this);
}","private boolean sendMessageToTarget(MPIMessage msgObj1,int i){
  msgObj1.incrementRefCount();
  int e=instancePlan.getExecutorForChannel(i);
  return channel.sendMessage(e,msgObj1,this);
}",0.9973474801061007
173100,"protected void releaseTheBuffers(int id,MPIMessage message){
  lock.lock();
  try {
    if (MPIMessageDirection.IN == message.getMessageDirection()) {
      Queue<MPIBuffer> list=receiveBuffers.get(id);
      for (      MPIBuffer buffer : message.getBuffers()) {
        buffer.getByteBuffer().clear();
        list.offer(buffer);
      }
    }
 else     if (MPIMessageDirection.OUT == message.getMessageDirection()) {
      Queue<MPIBuffer> queue=sendBuffers;
      for (      MPIBuffer buffer : message.getBuffers()) {
        buffer.getByteBuffer().clear();
        queue.offer(buffer);
      }
    }
  }
  finally {
    lock.unlock();
  }
}","protected void releaseTheBuffers(int id,MPIMessage message){
  lock.lock();
  try {
    if (MPIMessageDirection.IN == message.getMessageDirection()) {
      Queue<MPIBuffer> list=receiveBuffers.get(id);
      for (      MPIBuffer buffer : message.getBuffers()) {
        buffer.getByteBuffer().clear();
        list.offer(buffer);
        releasedReceivedBuffers++;
      }
    }
 else     if (MPIMessageDirection.OUT == message.getMessageDirection()) {
      Queue<MPIBuffer> queue=sendBuffers;
      for (      MPIBuffer buffer : message.getBuffers()) {
        buffer.getByteBuffer().clear();
        queue.offer(buffer);
        releasedSendBuffers++;
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.9512555391432792
173101,"/** 
 * Progress the serializations
 */
public void progress(){
  lock.lock();
  try {
    for (    Map.Entry<Integer,ArrayBlockingQueue<Pair<Object,MPISendMessage>>> e : pendingSendMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPISendMessage>> pendingSendMessages=e.getValue();
      boolean canProgress=true;
      while (pendingSendMessages.size() > 0 && canProgress) {
        Pair<Object,MPISendMessage> pair=pendingSendMessages.peek();
        MPISendMessage mpiSendMessage=pair.getValue();
        Object messageObject=pair.getKey();
        if (mpiSendMessage.serializedState() == MPISendMessage.SendState.INIT) {
          for (          Integer i : mpiSendMessage.getInternalSends()) {
            boolean receiveAccepted;
            if (isStoreBased && isLastReceiver) {
              serializeAndWriteToMemoryManager(mpiSendMessage,messageObject);
              receiveAccepted=receiver.receiveSendInternally(mpiSendMessage.getSource(),i,mpiSendMessage.getPath(),mpiSendMessage.getFlags(),operationMemoryManager);
            }
 else {
              receiveAccepted=receiver.receiveSendInternally(mpiSendMessage.getSource(),i,mpiSendMessage.getPath(),mpiSendMessage.getFlags(),messageObject);
            }
            if (!receiveAccepted) {
              canProgress=false;
              int attempt=updateAttemptMap(sendMessageInternalAttempts,i,1);
              if (debug && attempt > MAX_ATTEMPTS) {
                LOG.info(String.format(""String_Node_Str"",executor,attempt));
              }
              break;
            }
 else {
              updateAttemptMap(sendMessageInternalAttempts,i,-1);
            }
          }
          if (canProgress) {
            mpiSendMessage.setSendState(MPISendMessage.SendState.SENT_INTERNALLY);
          }
        }
        if (canProgress) {
          if (mpiSendMessage.getExternalSends().size() == 0) {
            pendingSendMessages.poll();
            continue;
          }
          MPISendMessage message=(MPISendMessage)messageSerializer.build(pair.getKey(),mpiSendMessage);
          if (message.serializedState() == MPISendMessage.SendState.SERIALIZED) {
            List<Integer> exRoutes=new ArrayList<>(mpiSendMessage.getExternalSends());
            int startOfExternalRouts=mpiSendMessage.getAcceptedExternalSends();
            int noOfExternalSends=startOfExternalRouts;
            for (int i=startOfExternalRouts; i < exRoutes.size(); i++) {
              boolean sendAccepted=sendMessageToTarget(message.getMPIMessage(),exRoutes.get(i));
              if (!sendAccepted) {
                canProgress=false;
                sendMessageToTargetAttempts++;
                if (sendMessageToTargetAttempts > MAX_ATTEMPTS) {
                  LOG.info(String.format(""String_Node_Str"",executor,sendMessageToTargetAttempts));
                }
                break;
              }
 else {
                if (sendMessageToTargetAttempts > 0) {
                  sendMessageToTargetAttempts--;
                }
                mpiSendMessage.incrementAcceptedExternalSends();
                noOfExternalSends++;
              }
            }
            if (noOfExternalSends == exRoutes.size()) {
              mpiSendMessage.setSendState(MPISendMessage.SendState.FINISHED);
              pendingSendMessages.poll();
            }
          }
 else {
            break;
          }
        }
      }
    }
    for (    Map.Entry<Integer,Queue<MPIMessage>> it : pendingReceiveDeSerializations.entrySet()) {
      MPIMessage currentMessage=it.getValue().poll();
      if (currentMessage == null) {
        continue;
      }
      int id=currentMessage.getOriginatingId();
      if (isStoreBased && isLastReceiver) {
        writeToMemoryManager(currentMessage);
        currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
        if (!receiver.receiveMessage(currentMessage,operationMemoryManager)) {
          int attempt=updateAttemptMap(receiveMessageAttempts,id,1);
          if (debug && attempt > MAX_ATTEMPTS) {
            LOG.info(String.format(""String_Node_Str"",executor,attempt));
          }
          continue;
        }
 else {
          updateAttemptMap(receiveMessageAttempts,id,-1);
        }
      }
 else {
        Object object=messageDeSerializer.build(currentMessage,currentMessage.getHeader().getEdge());
        Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=pendingReceiveMessagesPerSource.get(id);
        currentMessage.setReceivedState(MPIMessage.ReceivedState.INIT);
        if (pendingReceiveMessages.size() > 0) {
          if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
            throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
          }
        }
 else {
          currentMessage.incrementRefCount();
          currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
          if (!receiver.passMessageDownstream(object,currentMessage)) {
            if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
              throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
            }
            continue;
          }
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiver.receiveMessage(currentMessage,object)) {
            if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
              throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
            }
            int attempt=updateAttemptMap(receiveMessageAttempts,id,1);
            if (debug && attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            continue;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,id,-1);
          }
        }
        currentMessage.release();
      }
    }
    for (    Map.Entry<Integer,Queue<Pair<Object,MPIMessage>>> e : pendingReceiveMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=e.getValue();
      while (pendingReceiveMessages.size() > 0) {
        Pair<Object,MPIMessage> pair=pendingReceiveMessages.peek();
        MPIMessage.ReceivedState state=pair.getRight().getReceivedState();
        MPIMessage currentMessage=pair.getRight();
        Object object=pair.getLeft();
        if (state == MPIMessage.ReceivedState.INIT) {
          currentMessage.incrementRefCount();
        }
        if (state == MPIMessage.ReceivedState.DOWN || state == MPIMessage.ReceivedState.INIT) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
          if (!receiver.passMessageDownstream(object,currentMessage)) {
            break;
          }
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiver.receiveMessage(currentMessage,object)) {
            int attempt=updateAttemptMap(receiveMessageAttempts,0,1);
            if (debug && attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            break;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,0,-1);
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
 else         if (state == MPIMessage.ReceivedState.RECEIVE) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiver.receiveMessage(currentMessage,object)) {
            int attempt=updateAttemptMap(receiveMessageAttempts,0,1);
            if (debug && attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            break;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,0,-1);
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
      }
    }
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Progress the serializations
 */
public void progress(){
  lock.lock();
  try {
    for (    Map.Entry<Integer,ArrayBlockingQueue<Pair<Object,MPISendMessage>>> e : pendingSendMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPISendMessage>> pendingSendMessages=e.getValue();
      boolean canProgress=true;
      while (pendingSendMessages.size() > 0 && canProgress) {
        Pair<Object,MPISendMessage> pair=pendingSendMessages.peek();
        MPISendMessage mpiSendMessage=pair.getValue();
        Object messageObject=pair.getKey();
        if (mpiSendMessage.serializedState() == MPISendMessage.SendState.INIT) {
          for (          Integer i : mpiSendMessage.getInternalSends()) {
            boolean receiveAccepted;
            if (isStoreBased && isLastReceiver) {
              serializeAndWriteToMemoryManager(mpiSendMessage,messageObject);
              receiveAccepted=receiver.receiveSendInternally(mpiSendMessage.getSource(),i,mpiSendMessage.getPath(),mpiSendMessage.getFlags(),operationMemoryManager);
            }
 else {
              receiveAccepted=receiver.receiveSendInternally(mpiSendMessage.getSource(),i,mpiSendMessage.getPath(),mpiSendMessage.getFlags(),messageObject);
            }
            if (!receiveAccepted) {
              canProgress=false;
              int attempt=updateAttemptMap(sendMessageInternalAttempts,i,1);
              if (debug && attempt > MAX_ATTEMPTS) {
                LOG.info(String.format(""String_Node_Str"",executor,attempt));
              }
              break;
            }
 else {
              updateAttemptMap(sendMessageInternalAttempts,i,-1);
            }
          }
          if (canProgress) {
            mpiSendMessage.setSendState(MPISendMessage.SendState.SENT_INTERNALLY);
          }
        }
        if (canProgress) {
          if (mpiSendMessage.getExternalSends().size() == 0) {
            pendingSendMessages.poll();
            continue;
          }
          MPISendMessage message=(MPISendMessage)messageSerializer.build(pair.getKey(),mpiSendMessage);
          if (message.serializedState() == MPISendMessage.SendState.SERIALIZED) {
            List<Integer> exRoutes=new ArrayList<>(mpiSendMessage.getExternalSends());
            int startOfExternalRouts=mpiSendMessage.getAcceptedExternalSends();
            int noOfExternalSends=startOfExternalRouts;
            for (int i=startOfExternalRouts; i < exRoutes.size(); i++) {
              boolean sendAccepted=sendMessageToTarget(message.getMPIMessage(),exRoutes.get(i));
              if (!sendAccepted) {
                canProgress=false;
                sendMessageToTargetAttempts++;
                if (sendMessageToTargetAttempts > MAX_ATTEMPTS) {
                  LOG.info(String.format(""String_Node_Str"",executor,sendMessageToTargetAttempts));
                }
                break;
              }
 else {
                if (sendMessageToTargetAttempts > 0) {
                  sendMessageToTargetAttempts--;
                }
                mpiSendMessage.incrementAcceptedExternalSends();
                noOfExternalSends++;
              }
            }
            if (noOfExternalSends == exRoutes.size()) {
              mpiSendMessage.setSendState(MPISendMessage.SendState.FINISHED);
              pendingSendMessages.poll();
            }
          }
 else {
            break;
          }
        }
      }
    }
    for (    Map.Entry<Integer,Queue<MPIMessage>> it : pendingReceiveDeSerializations.entrySet()) {
      MPIMessage currentMessage=it.getValue().poll();
      if (currentMessage == null) {
        continue;
      }
      int id=currentMessage.getOriginatingId();
      if (isStoreBased && isLastReceiver) {
        LOG.info(""String_Node_Str"");
        writeToMemoryManager(currentMessage);
        currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
        if (!receiver.receiveMessage(currentMessage,operationMemoryManager)) {
          int attempt=updateAttemptMap(receiveMessageAttempts,id,1);
          if (debug && attempt > MAX_ATTEMPTS) {
            LOG.info(String.format(""String_Node_Str"",executor,attempt));
          }
          continue;
        }
 else {
          updateAttemptMap(receiveMessageAttempts,id,-1);
        }
      }
 else {
        Object object=messageDeSerializer.build(currentMessage,currentMessage.getHeader().getEdge());
        Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=pendingReceiveMessagesPerSource.get(id);
        currentMessage.setReceivedState(MPIMessage.ReceivedState.INIT);
        if (pendingReceiveMessages.size() > 0) {
          if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
            throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
          }
        }
 else {
          currentMessage.incrementRefCount();
          currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
          if (!receiver.passMessageDownstream(object,currentMessage)) {
            if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
              throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
            }
            continue;
          }
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiver.receiveMessage(currentMessage,object)) {
            if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
              throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
            }
            int attempt=updateAttemptMap(receiveMessageAttempts,id,1);
            if (debug && attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            continue;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,id,-1);
          }
          currentMessage.release();
        }
      }
    }
    for (    Map.Entry<Integer,Queue<Pair<Object,MPIMessage>>> e : pendingReceiveMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=e.getValue();
      while (pendingReceiveMessages.size() > 0) {
        Pair<Object,MPIMessage> pair=pendingReceiveMessages.peek();
        MPIMessage.ReceivedState state=pair.getRight().getReceivedState();
        MPIMessage currentMessage=pair.getRight();
        Object object=pair.getLeft();
        if (state == MPIMessage.ReceivedState.INIT) {
          currentMessage.incrementRefCount();
        }
        if (state == MPIMessage.ReceivedState.DOWN || state == MPIMessage.ReceivedState.INIT) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
          if (!receiver.passMessageDownstream(object,currentMessage)) {
            break;
          }
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiver.receiveMessage(currentMessage,object)) {
            int attempt=updateAttemptMap(receiveMessageAttempts,0,1);
            if (debug && attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            break;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,0,-1);
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
 else         if (state == MPIMessage.ReceivedState.RECEIVE) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiver.receiveMessage(currentMessage,object)) {
            int attempt=updateAttemptMap(receiveMessageAttempts,0,1);
            if (debug && attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            break;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,0,-1);
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.9933470123733136
173102,"private boolean sendMessageToTarget(MPIMessage msgObj1,int i){
  msgObj1.incrementRefCount(1);
  int e=instancePlan.getExecutorForChannel(i);
  return channel.sendMessage(e,msgObj1,this);
}","private boolean sendMessageToTarget(MPIMessage msgObj1,int i){
  msgObj1.incrementRefCount(0);
  int e=instancePlan.getExecutorForChannel(i);
  return channel.sendMessage(e,msgObj1,this);
}",0.9947089947089948
173103,"/** 
 * Send messages to the particular id
 * @param id id to be used for sending messages
 * @param message the message
 * @return true if the message is accepted to be sent
 */
public boolean sendMessage(int id,MPIMessage message,MPIMessageListener callback){
  boolean offer=pendingSends.offer(new MPISendRequests(id,message.getHeader().getEdge(),message,callback));
  if (offer) {
    pendingSendCount++;
  }
  return offer;
}","/** 
 * Send messages to the particular id
 * @param id id to be used for sending messages
 * @param message the message
 * @return true if the message is accepted to be sent
 */
public boolean sendMessage(int id,MPIMessage message,MPIMessageListener callback){
  boolean offer=pendingSends.offer(new MPISendRequests(id,message.getHeader().getEdge(),message,callback));
  return offer;
}",0.9179926560587516
173104,"/** 
 * Progress the communications that are pending
 */
public void progress(){
  while (pendingSends.size() > 0) {
    MPISendRequests sendRequests=pendingSends.poll();
    postMessage(sendRequests);
    waitForCompletionSends.add(sendRequests);
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    if (receiveRequests.availableBuffers.size() > 0) {
      postReceive(receiveRequests);
    }
  }
  Iterator<MPISendRequests> sendRequestsIterator=waitForCompletionSends.iterator();
  while (sendRequestsIterator.hasNext()) {
    MPISendRequests sendRequests=sendRequestsIterator.next();
    Iterator<MPIRequest> requestIterator=sendRequests.pendingSends.iterator();
    while (requestIterator.hasNext()) {
      MPIRequest r=requestIterator.next();
      try {
        Status status=r.request.testStatus();
        if (status != null) {
          requestIterator.remove();
        }
      }
 catch (      MPIException e) {
        throw new RuntimeException(""String_Node_Str"" + sendRequests.rank,e);
      }
    }
    if (sendRequests.pendingSends.size() == 0) {
      sendRequests.callback.onSendComplete(sendRequests.rank,sendRequests.edge,sendRequests.message);
      sendRequestsIterator.remove();
    }
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    try {
      Iterator<MPIRequest> requestIterator=receiveRequests.pendingRequests.iterator();
      while (requestIterator.hasNext()) {
        MPIRequest r=requestIterator.next();
        Status status=r.request.testStatus();
        if (status != null) {
          if (!status.isCancelled()) {
            r.buffer.setSize(status.getCount(MPI.BYTE));
            receiveRequests.callback.onReceiveComplete(receiveRequests.rank,receiveRequests.edge,r.buffer);
            requestIterator.remove();
          }
 else {
            throw new RuntimeException(""String_Node_Str"");
          }
        }
      }
    }
 catch (    MPIException e) {
      LOG.severe(""String_Node_Str"");
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
}","/** 
 * Progress the communications that are pending
 */
public void progress(){
  while (pendingSends.size() > 0) {
    MPISendRequests sendRequests=pendingSends.poll();
    postMessage(sendRequests);
    waitForCompletionSends.add(sendRequests);
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    if (receiveRequests.availableBuffers.size() > 0) {
      postReceive(receiveRequests);
    }
  }
  Iterator<MPISendRequests> sendRequestsIterator=waitForCompletionSends.iterator();
  while (sendRequestsIterator.hasNext()) {
    MPISendRequests sendRequests=sendRequestsIterator.next();
    Iterator<MPIRequest> requestIterator=sendRequests.pendingSends.iterator();
    while (requestIterator.hasNext()) {
      MPIRequest r=requestIterator.next();
      try {
        Status status=r.request.testStatus();
        if (status != null) {
          completedSendCount++;
          requestIterator.remove();
        }
      }
 catch (      MPIException e) {
        throw new RuntimeException(""String_Node_Str"" + sendRequests.rank,e);
      }
    }
    if (sendRequests.pendingSends.size() == 0) {
      sendRequests.callback.onSendComplete(sendRequests.rank,sendRequests.edge,sendRequests.message);
      sendRequestsIterator.remove();
    }
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    try {
      Iterator<MPIRequest> requestIterator=receiveRequests.pendingRequests.iterator();
      while (requestIterator.hasNext()) {
        MPIRequest r=requestIterator.next();
        Status status=r.request.testStatus();
        if (status != null) {
          if (!status.isCancelled()) {
            ++receiveCount;
            r.buffer.setSize(status.getCount(MPI.BYTE));
            receiveRequests.callback.onReceiveComplete(receiveRequests.rank,receiveRequests.edge,r.buffer);
            requestIterator.remove();
          }
 else {
            throw new RuntimeException(""String_Node_Str"");
          }
        }
      }
    }
 catch (    MPIException e) {
      LOG.severe(""String_Node_Str"");
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
}",0.9862825788751716
173105,"@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  executor=op.getTaskPlan().getThisExecutor();
  sendPendingMax=MPIContext.sendPendingMax(cfg);
  LOG.fine(String.format(""String_Node_Str"",executor,expectedIds));
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,List<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Boolean> finishedPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    for (    int i : e.getValue()) {
      messagesPerTask.put(i,new ArrayList<Object>());
      finishedPerTask.put(i,false);
      countsPerTask.put(i,0);
    }
    messages.put(e.getKey(),messagesPerTask);
    finished.put(e.getKey(),finishedPerTask);
    finalMessages.put(e.getKey(),new ArrayList<>());
    counts.put(e.getKey(),countsPerTask);
    batchDone.put(e.getKey(),false);
  }
  this.dataFlowOperation=op;
  this.executor=dataFlowOperation.getTaskPlan().getThisExecutor();
}","@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  executor=op.getTaskPlan().getThisExecutor();
  sendPendingMax=MPIContext.sendPendingMax(cfg);
  LOG.fine(String.format(""String_Node_Str"",executor,expectedIds));
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,List<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Boolean> finishedPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    Map<Integer,Integer> totalCountsPerTask=new HashMap<>();
    for (    int i : e.getValue()) {
      messagesPerTask.put(i,new ArrayList<Object>());
      finishedPerTask.put(i,false);
      countsPerTask.put(i,0);
      totalCountsPerTask.put(i,0);
    }
    messages.put(e.getKey(),messagesPerTask);
    finished.put(e.getKey(),finishedPerTask);
    finalMessages.put(e.getKey(),new ArrayList<>());
    counts.put(e.getKey(),countsPerTask);
    batchDone.put(e.getKey(),false);
    totalCounts.put(e.getKey(),totalCountsPerTask);
  }
  this.dataFlowOperation=op;
  this.executor=dataFlowOperation.getTaskPlan().getThisExecutor();
}",0.931098696461825
173106,"@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  List<Object> m=messages.get(target).get(source);
  Map<Integer,Boolean> finishedMessages=finished.get(target);
  if (m.size() > sendPendingMax) {
    canAdd=false;
    LOG.info(String.format(""String_Node_Str"",executor,target,source,counts.get(target),finalMessages.size()));
  }
 else {
    LOG.info(String.format(""String_Node_Str"",executor,target,source,finishedMessages.size()));
    if (object instanceof MPIMessage) {
      ((MPIMessage)object).incrementRefCount();
    }
    Integer c=counts.get(target).get(source);
    counts.get(target).put(source,c + 1);
    m.add(object);
    if ((flags & MessageFlags.FLAGS_LAST) == MessageFlags.FLAGS_LAST) {
      LOG.info(String.format(""String_Node_Str"",executor,target,source));
      finishedMessages.put(source,true);
    }
  }
  return canAdd;
}","@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  List<Object> m=messages.get(target).get(source);
  Map<Integer,Boolean> finishedMessages=finished.get(target);
  if (m.size() > sendPendingMax) {
    canAdd=false;
  }
 else {
    if (object instanceof MPIMessage) {
      ((MPIMessage)object).incrementRefCount();
    }
    Integer c=counts.get(target).get(source);
    counts.get(target).put(source,c + 1);
    Integer tc=totalCounts.get(target).get(source);
    totalCounts.get(target).put(source,tc + 1);
    m.add(object);
    if ((flags & MessageFlags.FLAGS_LAST) == MessageFlags.FLAGS_LAST) {
      LOG.info(String.format(""String_Node_Str"",executor,target,source));
      finishedMessages.put(source,true);
    }
  }
  return canAdd;
}",0.8222996515679443
173107,"/** 
 * Method used to progress work
 */
public void progress(){
  for (  int t : messages.keySet()) {
    if (batchDone.get(t)) {
      continue;
    }
    boolean allFinished=true;
    Map<Integer,List<Object>> map=messages.get(t);
    Map<Integer,Boolean> finishedForTarget=finished.get(t);
    Map<Integer,Integer> countMap=counts.get(t);
    LOG.info(String.format(""String_Node_Str"",executor,t,countMap,finishedForTarget));
    boolean found=true;
    for (    Map.Entry<Integer,List<Object>> e : map.entrySet()) {
      if (e.getValue().size() == 0 && !finishedForTarget.get(e.getKey())) {
        found=false;
      }
      if (!finishedForTarget.get(e.getKey())) {
        allFinished=false;
      }
    }
    if (found) {
      List<Object> out=new ArrayList<>();
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        List<Object> valueList=e.getValue();
        if (valueList.size() > 0) {
          Object value=valueList.get(0);
          out.add(value);
          allFinished=false;
          valueList.remove(0);
        }
      }
      for (      Map.Entry<Integer,Integer> e : countMap.entrySet()) {
        Integer i=e.getValue();
        e.setValue(i - 1);
      }
      finalMessages.get(t).addAll(out);
    }
 else {
      allFinished=false;
    }
    if (allFinished) {
      LOG.info(String.format(""String_Node_Str"",executor,t));
      batchDone.put(t,true);
      Object previous=null;
      List<Object> finalMessagePerTask=finalMessages.get(t);
      for (int i=0; i < finalMessagePerTask.size(); i++) {
        if (previous == null) {
          previous=finalMessagePerTask.get(i);
        }
 else {
          Object current=finalMessagePerTask.get(i);
          previous=reduceFunction.reduce(previous,current);
        }
      }
      reduceReceiver.receive(t,previous);
    }
  }
}","/** 
 * Method used to progress work
 */
public void progress(){
  for (  int t : messages.keySet()) {
    if (batchDone.get(t)) {
      continue;
    }
    boolean allFinished=true;
    Map<Integer,List<Object>> map=messages.get(t);
    Map<Integer,Boolean> finishedForTarget=finished.get(t);
    Map<Integer,Integer> countMap=counts.get(t);
    Map<Integer,Integer> totalCountMap=totalCounts.get(t);
    boolean found=true;
    for (    Map.Entry<Integer,List<Object>> e : map.entrySet()) {
      if (e.getValue().size() == 0 && !finishedForTarget.get(e.getKey())) {
        found=false;
      }
      if (!finishedForTarget.get(e.getKey())) {
        allFinished=false;
      }
    }
    if (found) {
      List<Object> out=new ArrayList<>();
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        List<Object> valueList=e.getValue();
        if (valueList.size() > 0) {
          Object value=valueList.get(0);
          out.add(value);
          allFinished=false;
          valueList.remove(0);
        }
      }
      for (      Map.Entry<Integer,Integer> e : countMap.entrySet()) {
        Integer i=e.getValue();
        e.setValue(i - 1);
      }
      finalMessages.get(t).addAll(out);
    }
 else {
      allFinished=false;
    }
    if (allFinished) {
      LOG.info(String.format(""String_Node_Str"",executor,t));
      batchDone.put(t,true);
      Object previous=null;
      List<Object> finalMessagePerTask=finalMessages.get(t);
      for (int i=0; i < finalMessagePerTask.size(); i++) {
        if (previous == null) {
          previous=finalMessagePerTask.get(i);
        }
 else {
          Object current=finalMessagePerTask.get(i);
          previous=reduceFunction.reduce(previous,current);
        }
      }
      reduceReceiver.receive(t,previous);
    }
  }
}",0.9684326104858632
173108,"@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  executor=op.getTaskPlan().getThisExecutor();
  sendPendingMax=MPIContext.sendPendingMax(cfg);
  this.dataFlowOperation=op;
  this.executor=dataFlowOperation.getTaskPlan().getThisExecutor();
  LOG.fine(String.format(""String_Node_Str"",executor,expectedIds));
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,List<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Boolean> finishedPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    for (    int task : e.getValue()) {
      messagesPerTask.put(task,new ArrayList<Object>());
      finishedPerTask.put(task,false);
      countsPerTask.put(task,0);
    }
    messages.put(e.getKey(),messagesPerTask);
    finished.put(e.getKey(),finishedPerTask);
    counts.put(e.getKey(),countsPerTask);
    batchDone.put(e.getKey(),false);
  }
}","@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  executor=op.getTaskPlan().getThisExecutor();
  sendPendingMax=MPIContext.sendPendingMax(cfg);
  this.dataFlowOperation=op;
  this.executor=dataFlowOperation.getTaskPlan().getThisExecutor();
  LOG.fine(String.format(""String_Node_Str"",executor,expectedIds));
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,List<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Boolean> finishedPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    Map<Integer,Integer> totalCountsPerTask=new HashMap<>();
    for (    int task : e.getValue()) {
      messagesPerTask.put(task,new ArrayList<Object>());
      finishedPerTask.put(task,false);
      countsPerTask.put(task,0);
      totalCountsPerTask.put(task,0);
    }
    messages.put(e.getKey(),messagesPerTask);
    finished.put(e.getKey(),finishedPerTask);
    counts.put(e.getKey(),countsPerTask);
    batchDone.put(e.getKey(),false);
    totalCounts.put(e.getKey(),totalCountsPerTask);
  }
}",0.9270178830352828
173109,"@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  if (messages.get(target) == null) {
    throw new RuntimeException(String.format(""String_Node_Str"",executor,target));
  }
  List<Object> m=messages.get(target).get(source);
  Map<Integer,Boolean> finishedMessages=finished.get(target);
  if (m.size() > sendPendingMax) {
    canAdd=false;
  }
 else {
    if (object instanceof MPIMessage) {
      ((MPIMessage)object).incrementRefCount();
    }
    Integer c=counts.get(target).get(source);
    counts.get(target).put(source,c + 1);
    m.add(object);
    if ((flags & MessageFlags.FLAGS_LAST) == MessageFlags.FLAGS_LAST) {
      finishedMessages.put(source,true);
    }
  }
  return canAdd;
}","@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  if (messages.get(target) == null) {
    throw new RuntimeException(String.format(""String_Node_Str"",executor,target));
  }
  List<Object> m=messages.get(target).get(source);
  Map<Integer,Boolean> finishedMessages=finished.get(target);
  if (m.size() > sendPendingMax) {
    canAdd=false;
  }
 else {
    if (object instanceof MPIMessage) {
      ((MPIMessage)object).incrementRefCount();
    }
    Integer c=counts.get(target).get(source);
    counts.get(target).put(source,c + 1);
    Integer tc=totalCounts.get(target).get(source);
    totalCounts.get(target).put(source,tc + 1);
    m.add(object);
    if ((flags & MessageFlags.FLAGS_LAST) == MessageFlags.FLAGS_LAST) {
      finishedMessages.put(source,true);
    }
  }
  return canAdd;
}",0.938195302843016
173110,"@Override public void progress(){
  for (  int t : messages.keySet()) {
    if (batchDone.get(t)) {
      continue;
    }
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,List<Object>> messagePerTarget=messages.get(t);
      Map<Integer,Boolean> finishedForTarget=finished.get(t);
      Map<Integer,Integer> countMap=counts.get(t);
      LOG.info(String.format(""String_Node_Str"",executor,t,countMap,finishedForTarget));
      boolean found=true;
      boolean allFinished=true;
      for (      Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
        if (e.getValue().size() == 0 && !finishedForTarget.get(e.getKey())) {
          found=false;
          canProgress=false;
        }
        if (!finishedForTarget.get(e.getKey())) {
          allFinished=false;
        }
      }
      if (found) {
        Object previous=null;
        for (        Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
          List<Object> valueList=e.getValue();
          if (valueList.size() > 0) {
            if (previous == null) {
              previous=e.getValue().get(0);
            }
 else {
              Object current=e.getValue().get(0);
              previous=reduceFunction.reduce(previous,current);
            }
          }
        }
        int flags=0;
        boolean last;
        if (allFinished) {
          last=true;
          for (          Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
            List<Object> valueList=e.getValue();
            if (valueList.size() > 1) {
              last=false;
            }
          }
          if (last) {
            flags=MessageFlags.FLAGS_LAST;
          }
        }
        if (dataFlowOperation.sendPartial(t,previous,flags,destination)) {
          boolean allZero=true;
          for (          Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
            List<Object> value=e.getValue();
            if (value.size() > 0) {
              value.remove(0);
            }
            if (value.size() != 0) {
              allZero=false;
            }
          }
          for (          Map.Entry<Integer,Integer> e : countMap.entrySet()) {
            Integer i=e.getValue();
            e.setValue(i - 1);
          }
          if (allFinished && allZero) {
            batchDone.put(t,true);
            break;
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}","@Override public void progress(){
  for (  int t : messages.keySet()) {
    if (batchDone.get(t)) {
      continue;
    }
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,List<Object>> messagePerTarget=messages.get(t);
      Map<Integer,Boolean> finishedForTarget=finished.get(t);
      Map<Integer,Integer> countMap=counts.get(t);
      Map<Integer,Integer> totalCountMap=totalCounts.get(t);
      boolean found=true;
      boolean allFinished=true;
      for (      Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
        if (e.getValue().size() == 0 && !finishedForTarget.get(e.getKey())) {
          found=false;
          canProgress=false;
        }
        if (!finishedForTarget.get(e.getKey())) {
          allFinished=false;
        }
      }
      if (found) {
        Object previous=null;
        for (        Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
          List<Object> valueList=e.getValue();
          if (valueList.size() > 0) {
            if (previous == null) {
              previous=e.getValue().get(0);
            }
 else {
              Object current=e.getValue().get(0);
              previous=reduceFunction.reduce(previous,current);
            }
          }
        }
        int flags=0;
        boolean last;
        if (allFinished) {
          last=true;
          for (          Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
            List<Object> valueList=e.getValue();
            if (valueList.size() > 1) {
              last=false;
            }
          }
          if (last) {
            flags=MessageFlags.FLAGS_LAST;
          }
        }
        if (dataFlowOperation.sendPartial(t,previous,flags,destination)) {
          boolean allZero=true;
          for (          Map.Entry<Integer,List<Object>> e : messagePerTarget.entrySet()) {
            List<Object> value=e.getValue();
            if (value.size() > 0) {
              value.remove(0);
            }
            if (value.size() != 0) {
              allZero=false;
            }
          }
          for (          Map.Entry<Integer,Integer> e : countMap.entrySet()) {
            Integer i=e.getValue();
            e.setValue(i - 1);
          }
          if (allFinished && allZero) {
            batchDone.put(t,true);
            break;
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}",0.9765545361875636
173111,"public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,List<Object>> map=messages.get(t);
      boolean found=true;
      Object o=null;
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
 else {
          o=e.getValue().get(0);
        }
      }
      if (found) {
        for (        Map.Entry<Integer,List<Object>> e : map.entrySet()) {
          o=e.getValue().remove(0);
        }
        if (o != null) {
          count++;
          if (count % 1000 == 0) {
            LOG.info(String.format(""String_Node_Str"",id,t,count,counts));
          }
          if (count >= 11000) {
            LOG.info(""String_Node_Str"" + (System.nanoTime() - start) / 1000000 + ""String_Node_Str"" + count);
          }
        }
 else {
          LOG.severe(""String_Node_Str"");
        }
      }
    }
  }
}","public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,List<Object>> map=messages.get(t);
      boolean found=true;
      Object o=null;
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
 else {
          o=e.getValue().get(0);
        }
      }
      if (found) {
        for (        Map.Entry<Integer,List<Object>> e : map.entrySet()) {
          o=e.getValue().remove(0);
        }
        if (o != null) {
          count++;
          if (count % 10 == 0) {
            LOG.info(String.format(""String_Node_Str"",id,t,count,counts));
          }
          if (count >= 11000) {
            LOG.info(""String_Node_Str"" + (System.nanoTime() - start) / 1000000 + ""String_Node_Str"" + count);
          }
        }
 else {
          LOG.severe(""String_Node_Str"");
        }
      }
    }
  }
}",0.9989949748743718
173112,"public MPIDirectDataFlowCommunication(TWSMPIChannel channel,Set<Integer> srcs,int dest,MessageReceiver finalRcvr){
  this.sources=srcs;
  this.destination=dest;
  this.finalReceiver=finalRcvr;
}","public MPIDirectDataFlowCommunication(TWSMPIChannel channel,Set<Integer> srcs,int dest,MessageReceiver finalRcvr){
  this.sources=srcs;
  this.destination=dest;
  this.finalReceiver=finalRcvr;
  this.delegete=new MPIDataFlowOperation(channel);
}",0.8838268792710706
173113,"public MPIDataFlowAllGather(TWSMPIChannel chnl,Set<Integer> sources,Set<Integer> destination,int middleTask,MessageReceiver finalRecv,MessageReceiver partialRecv,int redEdge,int broadEdge){
  this.channel=chnl;
  this.sources=sources;
  this.destinations=destination;
  this.partialReceiver=partialRecv;
  this.finalReceiver=finalRecv;
  this.reduceEdge=redEdge;
  this.broadCastEdge=broadEdge;
  this.middleTask=middleTask;
}","public MPIDataFlowAllGather(TWSChannel chnl,Set<Integer> sources,Set<Integer> destination,int middleTask,MessageReceiver finalRecv,MessageReceiver partialRecv,int redEdge,int broadEdge){
  this.channel=chnl;
  this.sources=sources;
  this.destinations=destination;
  this.partialReceiver=partialRecv;
  this.finalReceiver=finalRecv;
  this.reduceEdge=redEdge;
  this.broadCastEdge=broadEdge;
  this.middleTask=middleTask;
}",0.9964664310954064
173114,"public MPIDataFlowAllReduce(TWSMPIChannel chnl,Set<Integer> sources,Set<Integer> destination,int middleTask,MessageReceiver finalRecv,MessageReceiver partialRecv,int redEdge,int broadEdge){
  this.channel=chnl;
  this.sources=sources;
  this.destinations=destination;
  this.partialReceiver=partialRecv;
  this.finalReceiver=finalRecv;
  this.reduceEdge=redEdge;
  this.broadCastEdge=broadEdge;
  this.middleTask=middleTask;
}","public MPIDataFlowAllReduce(TWSChannel chnl,Set<Integer> sources,Set<Integer> destination,int middleTask,MessageReceiver finalRecv,MessageReceiver partialRecv,int redEdge,int broadEdge){
  this.channel=chnl;
  this.sources=sources;
  this.destinations=destination;
  this.partialReceiver=partialRecv;
  this.finalReceiver=finalRecv;
  this.reduceEdge=redEdge;
  this.broadCastEdge=broadEdge;
  this.middleTask=middleTask;
}",0.9964664310954064
173115,"public MPIDataFlowBroadcast(TWSMPIChannel channel,int src,Set<Integer> dests,MessageReceiver finalRcvr){
  this.source=src;
  this.destinations=dests;
  this.finalReceiver=finalRcvr;
  this.delegete=new MPIDataFlowOperation(channel);
}","public MPIDataFlowBroadcast(TWSChannel channel,int src,Set<Integer> dests,MessageReceiver finalRcvr){
  this.source=src;
  this.destinations=dests;
  this.finalReceiver=finalRcvr;
  this.delegete=new MPIDataFlowOperation(channel);
}",0.9935760171306208
173116,"public MPIDataFlowGather(TWSMPIChannel channel,Set<Integer> sources,int destination,MessageReceiver finalRcvr,MessageReceiver partialRcvr,int indx,int p,Config cfg,MessageType t,MessageType kt,TaskPlan taskPlan,int edge){
  this.index=indx;
  this.sources=sources;
  this.destination=destination;
  this.finalReceiver=finalRcvr;
  this.partialReceiver=partialRcvr;
  this.pathToUse=p;
  this.keyType=kt;
  this.instancePlan=taskPlan;
  this.isKeyed=true;
  this.delegete=new MPIDataFlowOperation(channel);
}","public MPIDataFlowGather(TWSChannel channel,Set<Integer> sources,int destination,MessageReceiver finalRcvr,MessageReceiver partialRcvr,int indx,int p,Config cfg,MessageType t,MessageType kt,TaskPlan taskPlan,int edge){
  this.index=indx;
  this.sources=sources;
  this.destination=destination;
  this.finalReceiver=finalRcvr;
  this.partialReceiver=partialRcvr;
  this.pathToUse=p;
  this.keyType=kt;
  this.instancePlan=taskPlan;
  this.isKeyed=true;
  this.delegete=new MPIDataFlowOperation(channel);
}",0.9970326409495548
173117,"public MPIDataFlowLoadBalance(TWSMPIChannel channel,Set<Integer> srcs,Set<Integer> dests,MessageReceiver finalRcvr){
  this.sources=srcs;
  this.destinations=dests;
  this.destinationIndex=new HashMap<>();
  this.destinationsList=new ArrayList<>(destinations);
  this.delegete=new MPIDataFlowOperation(channel);
  for (  int s : sources) {
    destinationIndex.put(s,0);
  }
  this.finalReceiver=finalRcvr;
}","public MPIDataFlowLoadBalance(TWSChannel channel,Set<Integer> srcs,Set<Integer> dests,MessageReceiver finalRcvr){
  this.sources=srcs;
  this.destinations=dests;
  this.destinationIndex=new HashMap<>();
  this.destinationsList=new ArrayList<>(destinations);
  this.delegete=new MPIDataFlowOperation(channel);
  for (  int s : sources) {
    destinationIndex.put(s,0);
  }
  this.finalReceiver=finalRcvr;
}",0.996309963099631
173118,"public MPIDataFlowMultiGather(TWSMPIChannel chnl,Set<Integer> sources,Set<Integer> destination,MultiMessageReceiver finalRecv,MultiMessageReceiver partialRecv,Set<Integer> es){
  this.channel=chnl;
  this.sources=sources;
  this.destinations=destination;
  this.finalReceiver=finalRecv;
  this.edges=es;
  this.gatherMap=new HashMap<>();
  this.partialReceiver=partialRecv;
}","public MPIDataFlowMultiGather(TWSChannel chnl,Set<Integer> sources,Set<Integer> destination,MultiMessageReceiver finalRecv,MultiMessageReceiver partialRecv,Set<Integer> es){
  this.channel=chnl;
  this.sources=sources;
  this.destinations=destination;
  this.finalReceiver=finalRecv;
  this.edges=es;
  this.gatherMap=new HashMap<>();
  this.partialReceiver=partialRecv;
}",0.9959839357429718
173119,"public MPIDataFlowMultiReduce(TWSMPIChannel chnl,Set<Integer> sources,Set<Integer> destination,MultiMessageReceiver finalRecv,MultiMessageReceiver partialRecv,Set<Integer> es){
  this.channel=chnl;
  this.sources=sources;
  this.destinations=destination;
  this.partialReceiver=partialRecv;
  this.finalReceiver=finalRecv;
  this.edges=es;
  this.reduceMap=new HashMap<>();
}","public MPIDataFlowMultiReduce(TWSChannel chnl,Set<Integer> sources,Set<Integer> destination,MultiMessageReceiver finalRecv,MultiMessageReceiver partialRecv,Set<Integer> es){
  this.channel=chnl;
  this.sources=sources;
  this.destinations=destination;
  this.partialReceiver=partialRecv;
  this.finalReceiver=finalRecv;
  this.edges=es;
  this.reduceMap=new HashMap<>();
}",0.9959839357429718
173120,"public MPIDataFlowOperation(TWSMPIChannel channel){
  this.channel=channel;
}","public MPIDataFlowOperation(TWSChannel channel){
  this.channel=channel;
}",0.9801324503311258
173121,"public MPIDataFlowPartition(TWSMPIChannel channel,Set<Integer> srcs,Set<Integer> dests,MessageReceiver finalRcvr,PartitionStratergy stratergy){
  this.sources=srcs;
  this.destinations=dests;
  this.destinationIndex=new HashMap<>();
  this.destinationsList=new ArrayList<>(destinations);
  this.delegete=new MPIDataFlowOperation(channel);
  this.partitionStratergy=stratergy;
  for (  int s : sources) {
    destinationIndex.put(s,0);
  }
  this.finalReceiver=finalRcvr;
}","public MPIDataFlowPartition(TWSChannel channel,Set<Integer> srcs,Set<Integer> dests,MessageReceiver finalRcvr,PartitionStratergy stratergy){
  this.sources=srcs;
  this.destinations=dests;
  this.destinationIndex=new HashMap<>();
  this.destinationsList=new ArrayList<>(destinations);
  this.delegete=new MPIDataFlowOperation(channel);
  this.partitionStratergy=stratergy;
  for (  int s : sources) {
    destinationIndex.put(s,0);
  }
  this.finalReceiver=finalRcvr;
}",0.9968119022316684
173122,"public MPIDataFlowReduce(TWSMPIChannel channel,Set<Integer> sources,int destination,MessageReceiver finalRcvr,MessageReceiver partialRcvr){
  this(channel,sources,destination,finalRcvr,partialRcvr,0,0);
}","public MPIDataFlowReduce(TWSChannel channel,Set<Integer> sources,int destination,MessageReceiver finalRcvr,MessageReceiver partialRcvr){
  this(channel,sources,destination,finalRcvr,partialRcvr,0,0);
}",0.9925925925925926
173123,"public MPIDirectDataFlowCommunication(TWSMPIChannel channel,Set<Integer> srcs,int dest,MessageReceiver finalRcvr){
  this.sources=srcs;
  this.destination=dest;
  this.finalReceiver=finalRcvr;
  this.delegete=new MPIDataFlowOperation(channel);
}","public MPIDirectDataFlowCommunication(TWSChannel channel,Set<Integer> srcs,int dest,MessageReceiver finalRcvr){
  this.sources=srcs;
  this.destination=dest;
  this.finalReceiver=finalRcvr;
  this.delegete=new MPIDataFlowOperation(channel);
}",0.9938398357289528
173124,"public void clear(){
}","public void clear(){
  pendingReceives.clear();
  pendingSends.clear();
}",0.4631578947368421
173125,"public void disconnect(){
  if (!isConnected) {
    return;
  }
  try {
    socketChannel.close();
  }
 catch (  IOException e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}","public void disconnect(){
  if (!isConnected) {
    return;
  }
  channel.forceFlush();
  try {
    socketChannel.close();
  }
 catch (  IOException e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}",0.9381443298969072
173126,"public void stop(){
  if (serverSocketChannel == null || !serverSocketChannel.isOpen()) {
    LOG.info(""String_Node_Str"");
    return;
  }
  for (  Map.Entry<SocketChannel,Channel> connections : connectedChannels.entrySet()) {
    SocketChannel channel=connections.getKey();
    connections.getValue().clear();
  }
  try {
    serverSocketChannel.close();
  }
 catch (  IOException e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}","public void stop(){
  if (serverSocketChannel == null || !serverSocketChannel.isOpen()) {
    LOG.info(""String_Node_Str"");
    return;
  }
  for (  Map.Entry<SocketChannel,Channel> connections : connectedChannels.entrySet()) {
    SocketChannel channel=connections.getKey();
    progress.removeAllInterest(channel);
    connections.getValue().clear();
  }
  try {
    serverSocketChannel.close();
  }
 catch (  IOException e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}",0.955386289445049
173127,"public static void main(String[] args){
  int noOfProcs=Integer.parseInt(args[1]);
  int procId=Integer.parseInt(args[0]);
  NetworkInfo networkInfo=new NetworkInfo(procId);
  networkInfo.addProperty(TCPContext.NETWORK_HOSTNAME,""String_Node_Str"");
  networkInfo.addProperty(TCPContext.NETWORK_PORT,8764);
  List<NetworkInfo> list=new ArrayList<>();
  for (int i=0; i < noOfProcs; i++) {
    NetworkInfo info=new NetworkInfo(i);
    info.addProperty(TCPContext.NETWORK_HOSTNAME,""String_Node_Str"");
    info.addProperty(TCPContext.NETWORK_PORT,8765 + i);
    list.add(info);
  }
  TCPChannel master=new TCPChannel(Config.newBuilder().build(),list,list.get(procId),networkInfo);
  master.start();
  int destProcId=0;
  if (procId == 0) {
    destProcId=1;
  }
  List<TCPRequest> readRequests=new ArrayList<>();
  List<TCPRequest> writeRequests=new ArrayList<>();
  for (int i=0; i < 5; i++) {
    ByteBuffer byteBuffer=ByteBuffer.allocate(128);
    TCPRequest write=master.iSend(byteBuffer,128,destProcId,1);
    writeRequests.add(write);
    ByteBuffer receiveBuffer=ByteBuffer.allocate(128);
    TCPRequest read=master.iRecv(receiveBuffer,128,destProcId,1);
    readRequests.add(read);
  }
  for (int i=0; i < 5; i++) {
    TCPRequest w=writeRequests.get(i);
    if (w.isComplete()) {
      LOG.info(""String_Node_Str"");
    }
    TCPRequest r=readRequests.get(i);
    if (r.isComplete()) {
      LOG.info(""String_Node_Str"");
    }
  }
}","public static void main(String[] args){
  int noOfProcs=Integer.parseInt(args[1]);
  int procId=Integer.parseInt(args[0]);
  NetworkInfo networkInfo=new NetworkInfo(procId);
  networkInfo.addProperty(TCPContext.NETWORK_HOSTNAME,""String_Node_Str"");
  networkInfo.addProperty(TCPContext.NETWORK_PORT,8764);
  List<NetworkInfo> list=new ArrayList<>();
  for (int i=0; i < noOfProcs; i++) {
    NetworkInfo info=new NetworkInfo(i);
    info.addProperty(TCPContext.NETWORK_HOSTNAME,""String_Node_Str"");
    info.addProperty(TCPContext.NETWORK_PORT,8765 + i);
    list.add(info);
  }
  TCPChannel master=new TCPChannel(Config.newBuilder().build(),list,list.get(procId),networkInfo);
  master.start();
  int destProcId=0;
  if (procId == 0) {
    destProcId=1;
  }
  List<TCPRequest> readRequests=new ArrayList<>();
  List<TCPRequest> writeRequests=new ArrayList<>();
  for (int i=0; i < 5; i++) {
    ByteBuffer byteBuffer=ByteBuffer.allocate(128);
    TCPRequest write=master.iSend(byteBuffer,128,destProcId,1);
    writeRequests.add(write);
    ByteBuffer receiveBuffer=ByteBuffer.allocate(128);
    TCPRequest read=master.iRecv(receiveBuffer,128,destProcId,1);
    readRequests.add(read);
  }
  int completed=0;
  int writeCOmpeted=0;
  do {
    completed=0;
    writeCOmpeted=0;
    master.progress();
    for (int i=0; i < 5; i++) {
      TCPRequest w=writeRequests.get(i);
      if (w.isComplete()) {
        LOG.info(""String_Node_Str"" + writeCOmpeted);
        writeCOmpeted++;
      }
      TCPRequest r=readRequests.get(i);
      if (r.isComplete()) {
        LOG.info(""String_Node_Str"" + completed);
        completed++;
      }
    }
  }
 while (completed != 5 || writeCOmpeted != 5);
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  master.close();
}",0.8810110974106042
173128,"@Override public void onSendComplete(SocketChannel channel,TCPWriteRequest writeRequest){
  LOG.log(Level.INFO,""String_Node_Str"");
  writeRequest.setComplete(true);
  if (writeRequest.getEdge() == -1) {
    ByteBuffer buffer=writeRequest.getByteBuffer();
    buffer.clear();
    helloSendByteBuffers.add(buffer);
    clientsConnected++;
  }
}","@Override public void onSendComplete(SocketChannel channel,TCPWriteRequest writeRequest){
  LOG.log(Level.INFO,""String_Node_Str"");
  writeRequest.setComplete(true);
  if (writeRequest.getEdge() == -1) {
    ByteBuffer buffer=writeRequest.getByteBuffer();
    buffer.clear();
    helloSendByteBuffers.add(buffer);
    clientsCompleted++;
  }
}",0.9883040935672516
173129,"public void setKeyType(MessageType keyType){
  this.keyType=keyType;
  operationMemoryManager.setKeyType(MessageTypeConverter.toDataMessageType(keyType));
}","public void setKeyType(MessageType keyType){
  this.keyType=keyType;
  if (isStoreBased) {
    operationMemoryManager.setKeyType(MessageTypeConverter.toDataMessageType(keyType));
  }
}",0.9176470588235294
173130,"@Override public void onSendComplete(SocketChannel channel,TCPWriteRequest writeRequest){
}","@Override public void onSendComplete(SocketChannel channel,TCPRequest writeRequest){
}",0.9717514124293786
173131,"@Override public void onReceiveComplete(SocketChannel channel,TCPReadRequest readRequest){
  ByteBuffer buffer=readRequest.getByteBuffer();
  int processNo=buffer.getInt();
  LOG.log(Level.INFO,""String_Node_Str"" + processNo);
  if (channelIntegerMap.containsKey(processNo)) {
    LOG.log(Level.WARNING,String.format(""String_Node_Str"",processNo));
  }
  channelIntegerMap.put(processNo,channel);
  if (channelIntegerMap.keySet().size() == workerInfoList.size()) {
    LOG.log(Level.INFO,""String_Node_Str"");
    sendHelloResponse();
  }
}","@Override public void onReceiveComplete(SocketChannel channel,TCPRequest readRequest){
  ByteBuffer buffer=readRequest.getByteBuffer();
  int processNo=buffer.getInt();
  LOG.log(Level.INFO,""String_Node_Str"" + processNo);
  if (channelIntegerMap.containsKey(processNo)) {
    LOG.log(Level.WARNING,String.format(""String_Node_Str"",processNo));
  }
  channelIntegerMap.put(processNo,channel);
  if (channelIntegerMap.keySet().size() == workerInfoList.size()) {
    LOG.log(Level.INFO,""String_Node_Str"");
    sendHelloResponse();
  }
}",0.99625468164794
173132,"public TCPRequest iRecv(ByteBuffer buffer,int size,int procId,int edge){
  SocketChannel ch=serverChannel.get(procId);
  if (ch == null) {
    LOG.log(Level.INFO,""String_Node_Str"");
    return null;
  }
  return server.receive(ch,buffer,size,edge);
}","public TCPRequest iRecv(ByteBuffer buffer,int size,int procId,int edge){
  SocketChannel ch=serverChannel.get(procId);
  if (ch == null) {
    LOG.log(Level.INFO,""String_Node_Str"" + procId);
    return null;
  }
  return server.receive(ch,buffer,size,edge);
}",0.9823182711198428
173133,"public void start(){
  String hostName=TCPContext.getHostName(thisInfo);
  int port=TCPContext.getPort(thisInfo);
  looper=new Progress();
  server=new Server(config,hostName,port,looper,new ChannelServerMessageHandler());
  server.start();
  worker=new TCPWorker(config,masterInfo);
  worker.start();
  worker.waitForSync();
  LOG.log(Level.INFO,""String_Node_Str"");
  for (  NetworkInfo info : networkInfos) {
    if (info.getProcId() == thisInfo.getProcId()) {
      continue;
    }
    String remoteHost=TCPContext.getHostName(info);
    int remotePort=TCPContext.getPort(info);
    Client client=new Client(remoteHost,remotePort,config,looper,new ClientChannelMessageHandler());
    client.connect();
    clients.put(info.getProcId(),client);
    invertedClientChannels.put(client.getSocketChannel(),info.getProcId());
  }
  while (clientsConnected != (networkInfos.size() - 1) && (clientsCompleted != networkInfos.size() - 1)) {
    looper.loop();
  }
  LOG.log(Level.INFO,""String_Node_Str"" + clientsConnected + ""String_Node_Str""+ clientsCompleted);
}","public void start(){
  String hostName=TCPContext.getHostName(thisInfo);
  int port=TCPContext.getPort(thisInfo);
  looper=new Progress();
  server=new Server(config,hostName,port,looper,new ChannelServerMessageHandler());
  server.start();
  worker=new TCPWorker(config,masterInfo);
  worker.start();
  worker.waitForSync();
  LOG.log(Level.INFO,""String_Node_Str"");
  for (  NetworkInfo info : networkInfos) {
    if (info.getProcId() == thisInfo.getProcId()) {
      continue;
    }
    String remoteHost=TCPContext.getHostName(info);
    int remotePort=TCPContext.getPort(info);
    Client client=new Client(remoteHost,remotePort,config,looper,new ClientChannelMessageHandler());
    client.connect();
    clients.put(info.getProcId(),client);
    invertedClientChannels.put(client.getSocketChannel(),info.getProcId());
  }
  while (clientsConnected != (networkInfos.size() - 1) || (clientsCompleted != networkInfos.size() - 1)) {
    looper.loop();
  }
  LOG.log(Level.INFO,""String_Node_Str"" + clientsConnected + ""String_Node_Str""+ clientsCompleted);
}",0.9981060606060606
173134,"public TCPRequest iSend(ByteBuffer buffer,int size,int procId,int edge){
  SocketChannel ch=clientChannel.get(procId);
  if (ch == null) {
    LOG.log(Level.INFO,""String_Node_Str"");
    return null;
  }
  Client client=clients.get(procId);
  return client.send(ch,buffer,size,edge);
}","public TCPRequest iSend(ByteBuffer buffer,int size,int procId,int edge){
  SocketChannel ch=clientChannel.get(procId);
  if (ch == null) {
    LOG.log(Level.INFO,""String_Node_Str"" + procId);
    return null;
  }
  Client client=clients.get(procId);
  return client.send(ch,buffer,size,edge);
}",0.9844020797227035
173135,"@Override public void onConnect(SocketChannel channel,StatusCode status){
  LOG.log(Level.INFO,""String_Node_Str"" + channel);
}","@Override public void onConnect(SocketChannel channel,StatusCode status){
  LOG.log(Level.INFO,""String_Node_Str"" + channel);
  connectedChannels.add(channel);
  if (connectedChannels.size() == workerInfoList.size()) {
    postReceives();
  }
}",0.6829268292682927
173136,"public void start(){
  String hostName=TCPContext.getHostName(thisNetworkInfo);
  int port=TCPContext.getPort(thisNetworkInfo);
  progress=new Progress();
  server=new Server(config,hostName,port,progress,new ServerEventHandler());
  server.start();
  postReceives();
  while (true) {
    progress.loop();
  }
}","public void start(){
  String hostName=TCPContext.getHostName(thisNetworkInfo);
  int port=TCPContext.getPort(thisNetworkInfo);
  progress=new Progress();
  server=new Server(config,hostName,port,progress,new ServerEventHandler());
  server.start();
  while (true) {
    progress.loop();
  }
}",0.9701986754966888
173137,"public void postReceives(){
  for (  NetworkInfo info : workerInfoList) {
    SocketChannel channel=channelIntegerMap.get(info.getProcId());
    ByteBuffer receiveBuffer=ByteBuffer.allocate(4);
    server.send(channel,receiveBuffer,4,0);
  }
}","public void postReceives(){
  for (  SocketChannel ch : connectedChannels) {
    ByteBuffer receiveBuffer=ByteBuffer.allocate(4);
    server.receive(ch,receiveBuffer,4,0);
  }
}",0.7571428571428571
173138,"@Override public void onReceiveComplete(SocketChannel channel,TCPReadRequest readRequest){
  ByteBuffer buffer=readRequest.getByteBuffer();
  int processNo=buffer.getInt();
  if (channelIntegerMap.containsKey(processNo)) {
    LOG.log(Level.WARNING,String.format(""String_Node_Str"",processNo));
  }
  channelIntegerMap.put(processNo,channel);
  if (channelIntegerMap.keySet().size() == workerInfoList.size()) {
    sendHelloResponse();
  }
}","@Override public void onReceiveComplete(SocketChannel channel,TCPReadRequest readRequest){
  ByteBuffer buffer=readRequest.getByteBuffer();
  int processNo=buffer.getInt();
  LOG.log(Level.INFO,""String_Node_Str"" + processNo);
  if (channelIntegerMap.containsKey(processNo)) {
    LOG.log(Level.WARNING,String.format(""String_Node_Str"",processNo));
  }
  channelIntegerMap.put(processNo,channel);
  if (channelIntegerMap.keySet().size() == workerInfoList.size()) {
    sendHelloResponse();
  }
}",0.8317256162915327
173139,"public void read(){
  while (pendingReceives.size() > 0) {
    TCPReadRequest readRequest=readRequest(socketChannel);
    if (readRequest != null) {
      readRequest.setComplete(true);
      messageHandler.onReceiveComplete(socketChannel,readRequest);
    }
 else {
      break;
    }
  }
}","public void read(){
  LOG.info(""String_Node_Str"" + socketChannel);
  while (pendingReceives.size() > 0) {
    TCPReadRequest readRequest=readRequest(socketChannel);
    if (readRequest != null) {
      readRequest.setComplete(true);
      messageHandler.onReceiveComplete(socketChannel,readRequest);
    }
 else {
      break;
    }
  }
}",0.9252782193958664
173140,"private TCPReadRequest readRequest(SocketChannel channel){
  if (readStatus == DataStatus.INIT) {
    readHeader.clear();
    readStatus=DataStatus.HEADER;
  }
  if (readStatus == DataStatus.HEADER) {
    int retval=readFromChannel(channel,readHeader);
    if (retval != 0) {
      return null;
    }
    readHeader.flip();
    readSize=readHeader.getInt();
    readEdge=readHeader.getInt();
    readStatus=DataStatus.BODY;
  }
  if (readStatus == DataStatus.BODY) {
    ByteBuffer buffer;
    if (readingRequest == null) {
      Queue<TCPReadRequest> readRequests=getReadRequest(readEdge);
      if (readRequests.size() == 0) {
        return null;
      }
      readingRequest=readRequests.poll();
      buffer=readingRequest.getByteBuffer();
      buffer.clear();
      buffer.limit(readSize);
    }
 else {
      buffer=readingRequest.getByteBuffer();
    }
    int retVal=readFromChannel(channel,buffer);
    if (retVal < 0) {
      readSize=0;
      readEdge=0;
      TCPReadRequest ret=readingRequest;
      readingRequest=null;
      writeStatus=DataStatus.INIT;
      return null;
    }
 else     if (retVal == 0) {
      readSize=0;
      readEdge=0;
      TCPReadRequest ret=readingRequest;
      readingRequest=null;
      writeStatus=DataStatus.INIT;
      return ret;
    }
 else {
      return null;
    }
  }
  return null;
}","private TCPReadRequest readRequest(SocketChannel channel){
  LOG.log(Level.INFO,""String_Node_Str"");
  if (readStatus == DataStatus.INIT) {
    readHeader.clear();
    readStatus=DataStatus.HEADER;
  }
  if (readStatus == DataStatus.HEADER) {
    int retval=readFromChannel(channel,readHeader);
    if (retval != 0) {
      return null;
    }
    readHeader.flip();
    readSize=readHeader.getInt();
    readEdge=readHeader.getInt();
    readStatus=DataStatus.BODY;
  }
  if (readStatus == DataStatus.BODY) {
    ByteBuffer buffer;
    if (readingRequest == null) {
      Queue<TCPReadRequest> readRequests=getReadRequest(readEdge);
      if (readRequests.size() == 0) {
        return null;
      }
      readingRequest=readRequests.poll();
      buffer=readingRequest.getByteBuffer();
      buffer.clear();
      buffer.limit(readSize);
    }
 else {
      buffer=readingRequest.getByteBuffer();
    }
    int retVal=readFromChannel(channel,buffer);
    if (retVal < 0) {
      readSize=0;
      readEdge=0;
      TCPReadRequest ret=readingRequest;
      readingRequest=null;
      writeStatus=DataStatus.INIT;
      return null;
    }
 else     if (retVal == 0) {
      readSize=0;
      readEdge=0;
      buffer.flip();
      TCPReadRequest ret=readingRequest;
      readingRequest=null;
      writeStatus=DataStatus.INIT;
      return ret;
    }
 else {
      return null;
    }
  }
  return null;
}",0.9774052478134112
173141,"private int writeRequest(SocketChannel channel,TCPWriteRequest request){
  ByteBuffer buffer=request.getByteBuffer();
  int written=0;
  if (writeStatus == DataStatus.INIT) {
    buffer.flip();
    writeHeader.clear();
    writeStatus=DataStatus.HEADER;
    writeHeader.putInt(request.getLength());
    writeHeader.putInt(request.getEdge());
  }
  if (writeStatus == DataStatus.HEADER) {
    written=writeToChannel(channel,writeHeader);
    if (written < 0) {
      return written;
    }
 else     if (written == 0) {
      writeStatus=DataStatus.BODY;
    }
  }
  if (writeStatus == DataStatus.BODY) {
    written=writeToChannel(channel,request.getByteBuffer());
    if (written < 0) {
      return written;
    }
 else     if (written == 0) {
      writeStatus=DataStatus.INIT;
      return written;
    }
  }
  return written;
}","private int writeRequest(SocketChannel channel,TCPWriteRequest request){
  ByteBuffer buffer=request.getByteBuffer();
  int written=0;
  if (writeStatus == DataStatus.INIT) {
    writeHeader.clear();
    writeStatus=DataStatus.HEADER;
    writeHeader.putInt(request.getLength());
    writeHeader.putInt(request.getEdge());
    writeHeader.flip();
  }
  if (writeStatus == DataStatus.HEADER) {
    written=writeToChannel(channel,writeHeader);
    if (written < 0) {
      return written;
    }
 else     if (written == 0) {
      writeStatus=DataStatus.BODY;
    }
  }
  if (writeStatus == DataStatus.BODY) {
    buffer.flip();
    written=writeToChannel(channel,buffer);
    if (written < 0) {
      return written;
    }
 else     if (written == 0) {
      writeStatus=DataStatus.INIT;
      return written;
    }
  }
  return written;
}",0.9454763331336128
173142,"public void write(){
  while (pendingSends.size() > 0) {
    TCPWriteRequest writeRequest=pendingSends.peek();
    if (writeRequest == null) {
      break;
    }
    int writeState=writeRequest(socketChannel,writeRequest);
    if (writeState > 0) {
      break;
    }
 else     if (writeState < 0) {
      LOG.severe(""String_Node_Str"");
      selectHandler.handleError(socketChannel);
      return;
    }
 else {
      pendingSends.poll();
      writeRequest.setComplete(true);
      messageHandler.onSendComplete(socketChannel,writeRequest);
    }
  }
  if (pendingSends.size() == 0) {
    disableWriting();
  }
}","public void write(){
  while (pendingSends.size() > 0) {
    TCPWriteRequest writeRequest=pendingSends.peek();
    if (writeRequest == null) {
      break;
    }
    int writeState=writeRequest(socketChannel,writeRequest);
    if (writeState > 0) {
      break;
    }
 else     if (writeState < 0) {
      LOG.severe(""String_Node_Str"");
      selectHandler.handleError(socketChannel);
      return;
    }
 else {
      LOG.log(Level.INFO,""String_Node_Str"");
      pendingSends.poll();
      writeRequest.setComplete(true);
      messageHandler.onSendComplete(socketChannel,writeRequest);
    }
  }
}",0.9134377576257212
173143,"@Override public void handleConnect(SelectableChannel selectableChannel){
  try {
    if (socketChannel.finishConnect()) {
      progress.unregisterConnect(selectableChannel);
    }
  }
 catch (  IOException e) {
    LOG.log(Level.SEVERE,""String_Node_Str"" + address,e);
    messageHandler.onConnect(socketChannel,StatusCode.ERROR_CONN);
    return;
  }
  channel=new Channel(config,progress,this,socketChannel,messageHandler);
  isConnected=true;
  messageHandler.onConnect(socketChannel,StatusCode.SUCCESS);
}","@Override public void handleConnect(SelectableChannel selectableChannel){
  try {
    if (socketChannel.finishConnect()) {
      progress.unregisterConnect(selectableChannel);
    }
  }
 catch (  IOException e) {
    LOG.log(Level.SEVERE,""String_Node_Str"" + address,e);
    messageHandler.onConnect(socketChannel,StatusCode.ERROR_CONN);
    return;
  }
  channel=new Channel(config,progress,this,socketChannel,messageHandler);
  channel.enableReading();
  channel.enableWriting();
  isConnected=true;
  messageHandler.onConnect(socketChannel,StatusCode.SUCCESS);
}",0.9497206703910616
173144,"@Override public void handleAccept(SelectableChannel ch){
  try {
    SocketChannel socketChannel=serverSocketChannel.accept();
    if (socketChannel != null) {
      socketChannel.configureBlocking(false);
      socketChannel.socket().setSendBufferSize(TCPContext.getSocketSendBufferSize(config,1024));
      socketChannel.socket().setReceiveBufferSize(TCPContext.getSocketReceivedBufferSize(config,1024));
      socketChannel.socket().setTcpNoDelay(true);
      Channel channel=new Channel(config,progress,this,socketChannel,messageHandler);
      connectedChannels.put(socketChannel,channel);
    }
  }
 catch (  IOException e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}","@Override public void handleAccept(SelectableChannel ch){
  try {
    SocketChannel socketChannel=serverSocketChannel.accept();
    if (socketChannel != null) {
      socketChannel.configureBlocking(false);
      socketChannel.socket().setSendBufferSize(TCPContext.getSocketSendBufferSize(config,1024));
      socketChannel.socket().setReceiveBufferSize(TCPContext.getSocketReceivedBufferSize(config,1024));
      socketChannel.socket().setTcpNoDelay(true);
      Channel channel=new Channel(config,progress,this,socketChannel,messageHandler);
      channel.enableReading();
      channel.enableWriting();
      connectedChannels.put(socketChannel,channel);
      messageHandler.onConnect(socketChannel,StatusCode.SUCCESS);
    }
  }
 catch (  IOException e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}",0.9145527369826436
173145,"@Override public void onConnect(SocketChannel channel,StatusCode status){
  LOG.log(Level.INFO,""String_Node_Str"" + channel);
  clientSocketChannel=channel;
  send();
}","@Override public void onConnect(SocketChannel channel,StatusCode status){
  LOG.log(Level.INFO,""String_Node_Str"" + channel);
  clientSocketChannel=channel;
  sendAndPost();
}",0.9794721407624634
173146,"@Override public Iterator<Object> getIterator(int opID,DataMessageType valueType,KryoMemorySerializer deSerializer){
  return memoryManager.getIterator(opID,valueType,deSerializer);
}","@Override public Iterator<Object> getIterator(int opID,DataMessageType valueType,KryoMemorySerializer deSerializer){
  flushAll(opID);
  return memoryManager.getIterator(opID,valueType,deSerializer);
}",0.953125
173147,"/** 
 * Progress the serializations
 */
public void progress(){
  lock.lock();
  try {
    for (    Map.Entry<Integer,ArrayBlockingQueue<Pair<Object,MPISendMessage>>> e : pendingSendMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPISendMessage>> pendingSendMessages=e.getValue();
      boolean canProgress=true;
      while (pendingSendMessages.size() > 0 && canProgress) {
        Pair<Object,MPISendMessage> pair=pendingSendMessages.peek();
        MPISendMessage mpiSendMessage=pair.getValue();
        Object messageObject=pair.getKey();
        if (mpiSendMessage.serializedState() == MPISendMessage.SendState.INIT) {
          for (          Integer i : mpiSendMessage.getInternalSends()) {
            boolean receiveAccepted;
            if (isLastReceiver) {
              serializeAndWriteToMemoryManager(mpiSendMessage,messageObject);
              receiveAccepted=receiver.receiveSendInternally(mpiSendMessage.getSource(),i,mpiSendMessage.getPath(),mpiSendMessage.getFlags(),operationMemoryManager);
            }
 else {
              receiveAccepted=receiver.receiveSendInternally(mpiSendMessage.getSource(),i,mpiSendMessage.getPath(),mpiSendMessage.getFlags(),messageObject);
            }
            if (!receiveAccepted) {
              canProgress=false;
              int attempt=updateAttemptMap(sendMessageInternalAttempts,i,1);
              if (debug && attempt > MAX_ATTEMPTS) {
                LOG.info(String.format(""String_Node_Str"",executor,attempt));
              }
              break;
            }
 else {
              updateAttemptMap(sendMessageInternalAttempts,i,-1);
            }
          }
          if (canProgress) {
            mpiSendMessage.setSendState(MPISendMessage.SendState.SENT_INTERNALLY);
          }
        }
        if (canProgress) {
          if (mpiSendMessage.getExternalSends().size() == 0) {
            pendingSendMessages.poll();
            continue;
          }
          MPISendMessage message=(MPISendMessage)messageSerializer.build(pair.getKey(),mpiSendMessage);
          if (message.serializedState() == MPISendMessage.SendState.SERIALIZED) {
            List<Integer> exRoutes=new ArrayList<>(mpiSendMessage.getExternalSends());
            int startOfExternalRouts=mpiSendMessage.getAcceptedExternalSends();
            int noOfExternalSends=startOfExternalRouts;
            for (int i=startOfExternalRouts; i < exRoutes.size(); i++) {
              boolean sendAccepted=sendMessageToTarget(message.getMPIMessage(),exRoutes.get(i));
              if (!sendAccepted) {
                canProgress=false;
                sendMessageToTargetAttempts++;
                if (sendMessageToTargetAttempts > MAX_ATTEMPTS) {
                  LOG.info(String.format(""String_Node_Str"",executor,sendMessageToTargetAttempts));
                }
                break;
              }
 else {
                if (sendMessageToTargetAttempts > 0) {
                  sendMessageToTargetAttempts--;
                }
                mpiSendMessage.incrementAcceptedExternalSends();
                noOfExternalSends++;
              }
            }
            if (noOfExternalSends == exRoutes.size()) {
              mpiSendMessage.setSendState(MPISendMessage.SendState.FINISHED);
              pendingSendMessages.poll();
            }
          }
 else {
            break;
          }
        }
      }
    }
    for (    Map.Entry<Integer,Queue<MPIMessage>> it : pendingReceiveDeSerializations.entrySet()) {
      MPIMessage currentMessage=it.getValue().poll();
      int id=currentMessage.getOriginatingId();
      if (currentMessage == null) {
        continue;
      }
      if (isLastReceiver) {
        writeToMemoryManager(currentMessage);
        currentMessage.release();
        currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
        if (!receiver.receiveMessage(currentMessage,operationMemoryManager)) {
          int attempt=updateAttemptMap(receiveMessageAttempts,id,1);
          if (debug && attempt > MAX_ATTEMPTS) {
            LOG.info(String.format(""String_Node_Str"",executor,attempt));
          }
          continue;
        }
 else {
          updateAttemptMap(receiveMessageAttempts,id,-1);
        }
      }
 else {
        Object object=messageDeSerializer.build(currentMessage,currentMessage.getHeader().getEdge());
        Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=pendingReceiveMessagesPerSource.get(id);
        currentMessage.setReceivedState(MPIMessage.ReceivedState.INIT);
        if (pendingReceiveMessages.size() > 0) {
          if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
            throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
          }
        }
 else {
          currentMessage.incrementRefCount();
          currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
          if (!receiver.passMessageDownstream(object,currentMessage)) {
            if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
              throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
            }
            continue;
          }
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiver.receiveMessage(currentMessage,object)) {
            if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
              throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
            }
            int attempt=updateAttemptMap(receiveMessageAttempts,id,1);
            if (debug && attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            continue;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,id,-1);
          }
        }
        currentMessage.release();
      }
    }
    for (    Map.Entry<Integer,Queue<Pair<Object,MPIMessage>>> e : pendingReceiveMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=e.getValue();
      while (pendingReceiveMessages.size() > 0) {
        Pair<Object,MPIMessage> pair=pendingReceiveMessages.peek();
        MPIMessage.ReceivedState state=pair.getRight().getReceivedState();
        MPIMessage currentMessage=pair.getRight();
        Object object=pair.getLeft();
        if (state == MPIMessage.ReceivedState.INIT) {
          currentMessage.incrementRefCount();
        }
        if (state == MPIMessage.ReceivedState.DOWN || state == MPIMessage.ReceivedState.INIT) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
          if (!receiver.passMessageDownstream(object,currentMessage)) {
            break;
          }
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiver.receiveMessage(currentMessage,object)) {
            int attempt=updateAttemptMap(receiveMessageAttempts,0,1);
            if (debug && attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            break;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,0,-1);
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
 else         if (state == MPIMessage.ReceivedState.RECEIVE) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiver.receiveMessage(currentMessage,object)) {
            int attempt=updateAttemptMap(receiveMessageAttempts,0,1);
            if (debug && attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            break;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,0,-1);
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
      }
    }
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Progress the serializations
 */
public void progress(){
  lock.lock();
  try {
    for (    Map.Entry<Integer,ArrayBlockingQueue<Pair<Object,MPISendMessage>>> e : pendingSendMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPISendMessage>> pendingSendMessages=e.getValue();
      boolean canProgress=true;
      while (pendingSendMessages.size() > 0 && canProgress) {
        Pair<Object,MPISendMessage> pair=pendingSendMessages.peek();
        MPISendMessage mpiSendMessage=pair.getValue();
        Object messageObject=pair.getKey();
        if (mpiSendMessage.serializedState() == MPISendMessage.SendState.INIT) {
          for (          Integer i : mpiSendMessage.getInternalSends()) {
            boolean receiveAccepted;
            if (isLastReceiver) {
              serializeAndWriteToMemoryManager(mpiSendMessage,messageObject);
              receiveAccepted=receiver.receiveSendInternally(mpiSendMessage.getSource(),i,mpiSendMessage.getPath(),mpiSendMessage.getFlags(),operationMemoryManager);
            }
 else {
              receiveAccepted=receiver.receiveSendInternally(mpiSendMessage.getSource(),i,mpiSendMessage.getPath(),mpiSendMessage.getFlags(),messageObject);
            }
            if (!receiveAccepted) {
              canProgress=false;
              int attempt=updateAttemptMap(sendMessageInternalAttempts,i,1);
              if (debug && attempt > MAX_ATTEMPTS) {
                LOG.info(String.format(""String_Node_Str"",executor,attempt));
              }
              break;
            }
 else {
              updateAttemptMap(sendMessageInternalAttempts,i,-1);
            }
          }
          if (canProgress) {
            mpiSendMessage.setSendState(MPISendMessage.SendState.SENT_INTERNALLY);
          }
        }
        if (canProgress) {
          if (mpiSendMessage.getExternalSends().size() == 0) {
            pendingSendMessages.poll();
            continue;
          }
          MPISendMessage message=(MPISendMessage)messageSerializer.build(pair.getKey(),mpiSendMessage);
          if (message.serializedState() == MPISendMessage.SendState.SERIALIZED) {
            List<Integer> exRoutes=new ArrayList<>(mpiSendMessage.getExternalSends());
            int startOfExternalRouts=mpiSendMessage.getAcceptedExternalSends();
            int noOfExternalSends=startOfExternalRouts;
            for (int i=startOfExternalRouts; i < exRoutes.size(); i++) {
              boolean sendAccepted=sendMessageToTarget(message.getMPIMessage(),exRoutes.get(i));
              if (!sendAccepted) {
                canProgress=false;
                sendMessageToTargetAttempts++;
                if (sendMessageToTargetAttempts > MAX_ATTEMPTS) {
                  LOG.info(String.format(""String_Node_Str"",executor,sendMessageToTargetAttempts));
                }
                break;
              }
 else {
                if (sendMessageToTargetAttempts > 0) {
                  sendMessageToTargetAttempts--;
                }
                mpiSendMessage.incrementAcceptedExternalSends();
                noOfExternalSends++;
              }
            }
            if (noOfExternalSends == exRoutes.size()) {
              mpiSendMessage.setSendState(MPISendMessage.SendState.FINISHED);
              pendingSendMessages.poll();
            }
          }
 else {
            break;
          }
        }
      }
    }
    for (    Map.Entry<Integer,Queue<MPIMessage>> it : pendingReceiveDeSerializations.entrySet()) {
      MPIMessage currentMessage=it.getValue().poll();
      int id=currentMessage.getOriginatingId();
      if (currentMessage == null) {
        continue;
      }
      if (isLastReceiver) {
        writeToMemoryManager(currentMessage);
        currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
        if (!receiver.receiveMessage(currentMessage,operationMemoryManager)) {
          int attempt=updateAttemptMap(receiveMessageAttempts,id,1);
          if (debug && attempt > MAX_ATTEMPTS) {
            LOG.info(String.format(""String_Node_Str"",executor,attempt));
          }
          continue;
        }
 else {
          updateAttemptMap(receiveMessageAttempts,id,-1);
        }
      }
 else {
        Object object=messageDeSerializer.build(currentMessage,currentMessage.getHeader().getEdge());
        Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=pendingReceiveMessagesPerSource.get(id);
        currentMessage.setReceivedState(MPIMessage.ReceivedState.INIT);
        if (pendingReceiveMessages.size() > 0) {
          if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
            throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
          }
        }
 else {
          currentMessage.incrementRefCount();
          currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
          if (!receiver.passMessageDownstream(object,currentMessage)) {
            if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
              throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
            }
            continue;
          }
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiver.receiveMessage(currentMessage,object)) {
            if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
              throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
            }
            int attempt=updateAttemptMap(receiveMessageAttempts,id,1);
            if (debug && attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            continue;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,id,-1);
          }
        }
        currentMessage.release();
      }
    }
    for (    Map.Entry<Integer,Queue<Pair<Object,MPIMessage>>> e : pendingReceiveMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=e.getValue();
      while (pendingReceiveMessages.size() > 0) {
        Pair<Object,MPIMessage> pair=pendingReceiveMessages.peek();
        MPIMessage.ReceivedState state=pair.getRight().getReceivedState();
        MPIMessage currentMessage=pair.getRight();
        Object object=pair.getLeft();
        if (state == MPIMessage.ReceivedState.INIT) {
          currentMessage.incrementRefCount();
        }
        if (state == MPIMessage.ReceivedState.DOWN || state == MPIMessage.ReceivedState.INIT) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
          if (!receiver.passMessageDownstream(object,currentMessage)) {
            break;
          }
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiver.receiveMessage(currentMessage,object)) {
            int attempt=updateAttemptMap(receiveMessageAttempts,0,1);
            if (debug && attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            break;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,0,-1);
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
 else         if (state == MPIMessage.ReceivedState.RECEIVE) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiver.receiveMessage(currentMessage,object)) {
            int attempt=updateAttemptMap(receiveMessageAttempts,0,1);
            if (debug && attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            break;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,0,-1);
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.9978768577494692
173148,"public static double[] deserializeDouble(List<MPIBuffer> buffers,int byteLength){
  int noOfDoubles=byteLength / 8;
  double[] returnDoubles=new double[noOfDoubles];
  int bufferIndex=0;
  for (int i=0; i < noOfDoubles; i++) {
    ByteBuffer byteBuffer=buffers.get(bufferIndex).getByteBuffer();
    int remaining=byteBuffer.remaining();
    if (remaining > 8) {
      returnDoubles[i]=byteBuffer.getDouble();
    }
 else {
      bufferIndex=getReadBuffer(buffers,8,bufferIndex);
      if (bufferIndex < 0) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  return returnDoubles;
}","public static double[] deserializeDouble(List<MPIBuffer> buffers,int byteLength){
  int noOfDoubles=byteLength / 8;
  double[] returnDoubles=new double[noOfDoubles];
  int bufferIndex=0;
  for (int i=0; i < noOfDoubles; i++) {
    ByteBuffer byteBuffer=buffers.get(bufferIndex).getByteBuffer();
    int remaining=byteBuffer.remaining();
    if (remaining >= 8) {
      returnDoubles[i]=byteBuffer.getDouble();
    }
 else {
      bufferIndex=getReadBuffer(buffers,8,bufferIndex);
      if (bufferIndex < 0) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  return returnDoubles;
}",0.9991755976916736
173149,"public static long[] deserializeLong(List<MPIBuffer> buffers,int byteLength){
  int noOfDoubles=byteLength / 8;
  long[] returnDoubles=new long[noOfDoubles];
  int bufferIndex=0;
  for (int i=0; i < noOfDoubles; i++) {
    ByteBuffer byteBuffer=buffers.get(bufferIndex).getByteBuffer();
    int remaining=byteBuffer.remaining();
    if (remaining > 8) {
      returnDoubles[i]=byteBuffer.getLong();
    }
 else {
      bufferIndex=getReadBuffer(buffers,8,bufferIndex);
      if (bufferIndex < 0) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  return returnDoubles;
}","public static long[] deserializeLong(List<MPIBuffer> buffers,int byteLength){
  int noOfDoubles=byteLength / 8;
  long[] returnDoubles=new long[noOfDoubles];
  int bufferIndex=0;
  for (int i=0; i < noOfDoubles; i++) {
    ByteBuffer byteBuffer=buffers.get(bufferIndex).getByteBuffer();
    int remaining=byteBuffer.remaining();
    if (remaining >= 8) {
      returnDoubles[i]=byteBuffer.getLong();
    }
 else {
      bufferIndex=getReadBuffer(buffers,8,bufferIndex);
      if (bufferIndex < 0) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  return returnDoubles;
}",0.9991617770326908
173150,"public static short[] deserializeShort(List<MPIBuffer> buffers,int byteLength){
  int noOfDoubles=byteLength / 2;
  short[] returnDoubles=new short[noOfDoubles];
  int bufferIndex=0;
  for (int i=0; i < noOfDoubles; i++) {
    ByteBuffer byteBuffer=buffers.get(bufferIndex).getByteBuffer();
    int remaining=byteBuffer.remaining();
    if (remaining > 2) {
      returnDoubles[i]=byteBuffer.getShort();
    }
 else {
      bufferIndex=getReadBuffer(buffers,4,bufferIndex);
      if (bufferIndex < 0) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  return returnDoubles;
}","public static short[] deserializeShort(List<MPIBuffer> buffers,int byteLength){
  int noOfDoubles=byteLength / 2;
  short[] returnDoubles=new short[noOfDoubles];
  int bufferIndex=0;
  for (int i=0; i < noOfDoubles; i++) {
    ByteBuffer byteBuffer=buffers.get(bufferIndex).getByteBuffer();
    int remaining=byteBuffer.remaining();
    if (remaining >= 2) {
      returnDoubles[i]=byteBuffer.getShort();
    }
 else {
      bufferIndex=getReadBuffer(buffers,4,bufferIndex);
      if (bufferIndex < 0) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  return returnDoubles;
}",0.999168744804655
173151,"public static int[] deserializeInteger(List<MPIBuffer> buffers,int byteLength){
  int noOfDoubles=byteLength / 4;
  int[] returnDoubles=new int[noOfDoubles];
  int bufferIndex=0;
  for (int i=0; i < noOfDoubles; i++) {
    ByteBuffer byteBuffer=buffers.get(bufferIndex).getByteBuffer();
    int remaining=byteBuffer.remaining();
    if (remaining > 4) {
      returnDoubles[i]=byteBuffer.getInt();
    }
 else {
      bufferIndex=getReadBuffer(buffers,4,bufferIndex);
      if (bufferIndex < 0) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  return returnDoubles;
}","public static int[] deserializeInteger(List<MPIBuffer> buffers,int byteLength){
  int noOfDoubles=byteLength / 4;
  int[] returnDoubles=new int[noOfDoubles];
  int bufferIndex=0;
  for (int i=0; i < noOfDoubles; i++) {
    ByteBuffer byteBuffer=buffers.get(bufferIndex).getByteBuffer();
    int remaining=byteBuffer.remaining();
    if (remaining >= 4) {
      returnDoubles[i]=byteBuffer.getInt();
    }
 else {
      bufferIndex=getReadBuffer(buffers,4,bufferIndex);
      if (bufferIndex < 0) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  return returnDoubles;
}",0.9991603694374476
173152,"private static int getReadBuffer(List<MPIBuffer> bufs,int size,int currentBufferIndex){
  for (int i=currentBufferIndex; i < bufs.size(); i++) {
    ByteBuffer byteBuffer=bufs.get(i).getByteBuffer();
    if (byteBuffer.remaining() < size) {
      byteBuffer.rewind();
      return i;
    }
  }
  return -1;
}","private static int getReadBuffer(List<MPIBuffer> bufs,int size,int currentBufferIndex){
  for (int i=currentBufferIndex; i < bufs.size(); i++) {
    ByteBuffer byteBuffer=bufs.get(i).getByteBuffer();
    if (byteBuffer.remaining() > size) {
      byteBuffer.rewind();
      return i;
    }
  }
  return -1;
}",0.9967532467532468
173153,"private static boolean copyIntegers(int[] data,ByteBuffer targetBuffer,SerializeState state){
  int totalBytes=state.getTotalBytes();
  int remainingCapacity=targetBuffer.remaining();
  int bytesCopied=state.getBytesCopied();
  int remainingToCopy=data.length - bytesCopied / 4;
  int canCopy=(remainingCapacity > remainingToCopy ? remainingToCopy : remainingCapacity) / 4;
  int offSet=bytesCopied / 4;
  for (int i=0; i < canCopy; i++) {
    targetBuffer.putInt(data[i + offSet]);
  }
  totalBytes+=canCopy * 4;
  state.setTotalBytes(totalBytes);
  if (canCopy == remainingToCopy) {
    state.setData(null);
    state.setBytesCopied(0);
    return true;
  }
 else {
    state.setBytesCopied(canCopy * 4 + bytesCopied);
    return false;
  }
}","private static boolean copyIntegers(int[] data,ByteBuffer targetBuffer,SerializeState state){
  int totalBytes=state.getTotalBytes();
  int remainingCapacity=targetBuffer.remaining();
  int bytesCopied=state.getBytesCopied();
  int remainingToCopy=data.length * 4 - bytesCopied;
  int canCopy=(remainingCapacity > remainingToCopy ? remainingToCopy : remainingCapacity) / 4;
  int offSet=bytesCopied / 4;
  for (int i=0; i < canCopy; i++) {
    targetBuffer.putInt(data[i + offSet]);
  }
  totalBytes+=canCopy * 4;
  state.setTotalBytes(totalBytes);
  if ((canCopy * 4) == remainingToCopy) {
    state.setData(null);
    state.setBytesCopied(0);
    return true;
  }
 else {
    state.setBytesCopied(canCopy * 4 + bytesCopied);
    return false;
  }
}",0.9812583668005356
173154,"private static boolean copyDoubles(double[] data,ByteBuffer targetBuffer,SerializeState state){
  int totalBytes=state.getTotalBytes();
  int remainingCapacity=targetBuffer.remaining();
  int bytesCopied=state.getBytesCopied();
  int remainingToCopy=data.length - bytesCopied / 8;
  int canCopy=(remainingCapacity > remainingToCopy ? remainingToCopy : remainingCapacity) / 8;
  int offSet=bytesCopied / 8;
  for (int i=0; i < canCopy; i++) {
    targetBuffer.putDouble(data[i + offSet]);
  }
  totalBytes+=canCopy * 8;
  state.setTotalBytes(totalBytes);
  if (canCopy == remainingToCopy) {
    state.setData(null);
    state.setBytesCopied(0);
    return true;
  }
 else {
    state.setBytesCopied(canCopy * 8 + bytesCopied);
    return false;
  }
}","private static boolean copyDoubles(double[] data,ByteBuffer targetBuffer,SerializeState state){
  int totalBytes=state.getTotalBytes();
  int remainingCapacity=targetBuffer.remaining();
  int bytesCopied=state.getBytesCopied();
  int remainingToCopy=data.length * 8 - bytesCopied;
  int canCopy=(remainingCapacity > remainingToCopy ? remainingToCopy : remainingCapacity) / 8;
  int offSet=bytesCopied / 8;
  for (int i=0; i < canCopy; i++) {
    targetBuffer.putDouble(data[i + offSet]);
  }
  totalBytes+=canCopy * 8;
  state.setTotalBytes(totalBytes);
  if ((canCopy * 8) == remainingToCopy) {
    state.setData(null);
    state.setBytesCopied(0);
    return true;
  }
 else {
    state.setBytesCopied(canCopy * 8 + bytesCopied);
    return false;
  }
}",0.9813829787234044
173155,"private static boolean copyLong(long[] data,ByteBuffer targetBuffer,SerializeState state){
  int totalBytes=state.getTotalBytes();
  int remainingCapacity=targetBuffer.remaining();
  int bytesCopied=state.getBytesCopied();
  int remainingToCopy=data.length - bytesCopied / 8;
  int canCopy=(remainingCapacity > remainingToCopy ? remainingToCopy : remainingCapacity) / 8;
  int offSet=bytesCopied / 8;
  for (int i=0; i < canCopy; i++) {
    targetBuffer.putLong(data[i + offSet]);
  }
  totalBytes+=canCopy * 8;
  state.setTotalBytes(totalBytes);
  if (canCopy == remainingToCopy) {
    state.setData(null);
    state.setBytesCopied(0);
    return true;
  }
 else {
    state.setBytesCopied(canCopy * 8 + bytesCopied);
    return false;
  }
}","private static boolean copyLong(long[] data,ByteBuffer targetBuffer,SerializeState state){
  int totalBytes=state.getTotalBytes();
  int remainingCapacity=targetBuffer.remaining();
  int bytesCopied=state.getBytesCopied();
  int remainingToCopy=data.length * 8 - bytesCopied;
  int canCopy=(remainingCapacity > remainingToCopy ? remainingToCopy : remainingCapacity) / 8;
  int offSet=bytesCopied / 8;
  for (int i=0; i < canCopy; i++) {
    targetBuffer.putLong(data[i + offSet]);
  }
  totalBytes+=canCopy * 8;
  state.setTotalBytes(totalBytes);
  if ((canCopy * 8) == remainingToCopy) {
    state.setData(null);
    state.setBytesCopied(0);
    return true;
  }
 else {
    state.setBytesCopied(canCopy * 8 + bytesCopied);
    return false;
  }
}",0.9812080536912752
173156,"private static boolean copyShort(short[] data,ByteBuffer targetBuffer,SerializeState state){
  int totalBytes=state.getTotalBytes();
  int remainingCapacity=targetBuffer.remaining();
  int bytesCopied=state.getBytesCopied();
  int remainingToCopy=data.length - bytesCopied / 2;
  int canCopy=(remainingCapacity > remainingToCopy ? remainingToCopy : remainingCapacity) / 2;
  int offSet=bytesCopied / 2;
  for (int i=0; i < canCopy; i++) {
    targetBuffer.putShort(data[i + offSet]);
  }
  totalBytes+=canCopy * 2;
  state.setTotalBytes(totalBytes);
  if (canCopy == remainingToCopy) {
    state.setData(null);
    state.setBytesCopied(0);
    return true;
  }
 else {
    state.setBytesCopied(canCopy * 2 + bytesCopied);
    return false;
  }
}","private static boolean copyShort(short[] data,ByteBuffer targetBuffer,SerializeState state){
  int totalBytes=state.getTotalBytes();
  int remainingCapacity=targetBuffer.remaining();
  int bytesCopied=state.getBytesCopied();
  int remainingToCopy=data.length * 2 - bytesCopied;
  int canCopy=(remainingCapacity > remainingToCopy ? remainingToCopy : remainingCapacity) / 2;
  int offSet=bytesCopied / 2;
  for (int i=0; i < canCopy; i++) {
    targetBuffer.putShort(data[i + offSet]);
  }
  totalBytes+=canCopy * 2;
  state.setTotalBytes(totalBytes);
  if ((canCopy * 2) == remainingToCopy) {
    state.setData(null);
    state.setBytesCopied(0);
    return true;
  }
 else {
    state.setBytesCopied(canCopy * 2 + bytesCopied);
    return false;
  }
}",0.9812834224598932
173157,"/** 
 * Buffers the inputs before submitting it to the store. If the value is already present it will be replaced
 */
public boolean putBulk(int opID,String key,ByteBuffer value){
  if (!keyMap.containsKey(opID) && !memoryManager.containsKey(opID,key)) {
    registerKey(opID,key,MemoryManagerContext.BULK_MM_STEP_SIZE);
  }
 else {
    delete(opID,key);
    registerKey(opID,key,MemoryManagerContext.BULK_MM_STEP_SIZE);
  }
  keyMapCurrent.get(opID).put(key,1);
  keyMapBuffers.get(opID).get(key).add(value);
  keyBufferSizes.get(opID).put(key,keyBufferSizes.get(opID).get(key) + value.limit());
  return true;
}","/** 
 * Buffers the inputs before submitting it to the store. If the value is already present it will be replaced
 */
public boolean putBulk(int opID,String key,ByteBuffer value){
  if (value.position() != 0) {
    value.flip();
  }
  if (!keyMap.get(opID).containsKey(key) && !memoryManager.containsKey(opID,key)) {
    registerKey(opID,key,MemoryManagerContext.BULK_MM_STEP_SIZE);
  }
 else {
    delete(opID,key);
    registerKey(opID,key,MemoryManagerContext.BULK_MM_STEP_SIZE);
  }
  keyMapCurrent.get(opID).put(key,1);
  keyMapBuffers.get(opID).get(key).add(value);
  keyBufferSizes.get(opID).put(key,keyBufferSizes.get(opID).get(key) + value.limit());
  return true;
}",0.936335403726708
173158,"/** 
 * Buffers the inputs before submitting to the store. The new values will be appended to the end
 */
public boolean appendBulk(int opID,String key,ByteBuffer value){
  if (!keyMap.containsKey(opID)) {
    registerKey(opID,key,MemoryManagerContext.BULK_MM_STEP_SIZE);
  }
  int step=keyMap.get(opID).get(key);
  int currentCount=keyMapCurrent.get(opID).get(key);
  if ((currentCount + 1) % step == 0) {
    flush(opID,key,value);
    keyMapCurrent.get(opID).put(key,currentCount + 1);
  }
 else {
    keyMapCurrent.get(opID).put(key,currentCount + 1);
    keyMapBuffers.get(opID).get(key).add(value);
    keyBufferSizes.get(opID).put(key,keyBufferSizes.get(opID).get(key) + value.limit());
  }
  return true;
}","/** 
 * Buffers the inputs before submitting to the store. The new values will be appended to the end
 */
public boolean appendBulk(int opID,String key,ByteBuffer value){
  if (value.position() != 0) {
    value.flip();
  }
  if (!keyMap.get(opID).containsKey(key)) {
    registerKey(opID,key,MemoryManagerContext.BULK_MM_STEP_SIZE);
  }
  int step=keyMap.get(opID).get(key);
  int currentCount=keyMapCurrent.get(opID).get(key);
  if ((currentCount + 1) % step == 0) {
    flush(opID,key,value);
    keyMapCurrent.get(opID).put(key,currentCount + 1);
  }
 else {
    keyMapCurrent.get(opID).put(key,currentCount + 1);
    keyMapBuffers.get(opID).get(key).add(value);
    keyBufferSizes.get(opID).put(key,keyBufferSizes.get(opID).get(key) + value.limit());
  }
  return true;
}",0.94496644295302
173159,"/** 
 * Buffers the inputs before submitting to the store. The new values will be appended to the end
 */
public boolean appendBulk(int opID,String key,ByteBuffer value){
  if (!keyMap.containsKey(key)) {
    registerKey(opID,key,MemoryManagerContext.BULK_MM_STEP_SIZE);
  }
  int step=keyMap.get(opID).get(key);
  int currentCount=keyMapCurrent.get(opID).get(key);
  if ((currentCount + 1) % step == 0) {
    flush(opID,key,value);
    keyMapCurrent.get(opID).put(key,currentCount + 1);
  }
 else {
    keyMapCurrent.get(opID).put(key,currentCount + 1);
    keyMapBuffers.get(opID).get(key).add(value);
    keyBufferSizes.get(opID).put(key,keyBufferSizes.get(opID).get(key) + value.limit());
  }
  return true;
}","/** 
 * Buffers the inputs before submitting to the store. The new values will be appended to the end
 */
public boolean appendBulk(int opID,String key,ByteBuffer value){
  if (!keyMap.containsKey(opID)) {
    registerKey(opID,key,MemoryManagerContext.BULK_MM_STEP_SIZE);
  }
  int step=keyMap.get(opID).get(key);
  int currentCount=keyMapCurrent.get(opID).get(key);
  if ((currentCount + 1) % step == 0) {
    flush(opID,key,value);
    keyMapCurrent.get(opID).put(key,currentCount + 1);
  }
 else {
    keyMapCurrent.get(opID).put(key,currentCount + 1);
    keyMapBuffers.get(opID).get(key).add(value);
    keyBufferSizes.get(opID).put(key,keyBufferSizes.get(opID).get(key) + value.limit());
  }
  return true;
}",0.9950946040644708
173160,"public void progress(){
  for (  int t : messages.keySet()) {
    if (batchDone.get(t)) {
      continue;
    }
    boolean allFinished=true;
    Map<Integer,List<Object>> map=messages.get(t);
    Map<Integer,Boolean> finishedForTarget=finished.get(t);
    Map<Integer,Integer> countMap=counts.get(t);
    boolean found=true;
    for (    Map.Entry<Integer,List<Object>> e : map.entrySet()) {
      if (e.getValue().size() == 0 && !finishedForTarget.get(e.getKey())) {
        found=false;
      }
      if (!finishedForTarget.get(e.getKey())) {
        allFinished=false;
      }
    }
    if (found) {
      List<Object> out=new ArrayList<>();
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        List<Object> valueList=e.getValue();
        if (valueList.size() > 0) {
          Object value=valueList.get(0);
          out.add(value);
          allFinished=false;
          valueList.remove(0);
        }
      }
      finalMessages.get(t).addAll(out);
    }
 else {
      allFinished=false;
    }
    if (allFinished) {
      LOG.info(String.format(""String_Node_Str"",executor,t));
      batchDone.put(t,true);
      gatherBatchReceiver.receive(t,finalMessages.get(t).iterator());
    }
  }
}","/** 
 * Method used to progress work
 */
public void progress(){
  for (  int t : messages.keySet()) {
    if (batchDone.get(t)) {
      continue;
    }
    boolean allFinished=true;
    Map<Integer,List<Object>> map=messages.get(t);
    Map<Integer,Boolean> finishedForTarget=finished.get(t);
    Map<Integer,Integer> countMap=counts.get(t);
    boolean found=true;
    for (    Map.Entry<Integer,List<Object>> e : map.entrySet()) {
      if (e.getValue().size() == 0 && !finishedForTarget.get(e.getKey())) {
        found=false;
      }
      if (!finishedForTarget.get(e.getKey())) {
        allFinished=false;
      }
    }
    if (found) {
      List<Object> out=new ArrayList<>();
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        List<Object> valueList=e.getValue();
        if (valueList.size() > 0) {
          Object value=valueList.get(0);
          out.add(value);
          allFinished=false;
          valueList.remove(0);
        }
      }
      finalMessages.get(t).addAll(out);
    }
 else {
      allFinished=false;
    }
    if (allFinished) {
      LOG.info(String.format(""String_Node_Str"",executor,t));
      batchDone.put(t,true);
      gatherBatchReceiver.receive(t,finalMessages.get(t).iterator());
    }
  }
}",0.9835010060362172
173161,"@Override public void receive(int target,Iterator<Object> it){
  Map<String,Integer> wordCounts=new HashMap<>();
  while (it.hasNext()) {
    Object next=it.next();
    if (next instanceof List) {
      for (      Object o : (List)next) {
        int count=0;
        String value=o.toString();
        if (wordCounts.containsKey(value)) {
          count=wordCounts.get(value);
        }
        count++;
        totalCount++;
        wordCounts.put(value,count);
      }
    }
  }
  LOG.info(String.format(""String_Node_Str"",executor,wordCounts));
}","@Override public void receive(int target,Iterator<Object> it){
  Map<String,Integer> localwordCounts=new HashMap<>();
  while (it.hasNext()) {
    Object next=it.next();
    if (next instanceof List) {
      for (      Object o : (List)next) {
        int count=0;
        String value=o.toString();
        if (localwordCounts.containsKey(value)) {
          count=localwordCounts.get(value);
        }
        count++;
        totalCount++;
        localwordCounts.put(value,count);
      }
    }
  }
  LOG.info(String.format(""String_Node_Str"",executor,localwordCounts));
}",0.9777777777777776
173162,"@Override public URI uploadPackage(String sourceLocation) throws UploaderException {
  File file=new File(sourceLocation);
  String fileName=file.getName();
  boolean dirExist=file.isDirectory();
  if (!dirExist) {
    throw new UploaderException(String.format(""String_Node_Str"",sourceLocation));
  }
  if (!this.controller.mkdirsIfNotExists(destinationDirectory)) {
    throw new UploaderException(String.format(""String_Node_Str"",destinationDirectory));
  }
  LOG.log(Level.INFO,String.format(""String_Node_Str"",sourceLocation,destinationDirectory));
  try {
    if (!this.controller.copyFromLocalDirectory(sourceLocation,destinationDirectory)) {
      throw new UploaderException(String.format(""String_Node_Str"",sourceLocation,destinationDirectory));
    }
    LOG.log(Level.INFO,String.format(""String_Node_Str"",sourceLocation,destinationDirectory));
    return new URI(destinationDirectory + ""String_Node_Str"" + fileName);
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(""String_Node_Str"" + destinationDirectory,e);
  }
}","@Override public URI uploadPackage(String sourceLocation) throws UploaderException {
  File file=new File(sourceLocation);
  String fileName=file.getName();
  boolean dirExist=file.isDirectory();
  if (!dirExist) {
    throw new UploaderException(String.format(""String_Node_Str"",sourceLocation));
  }
  if (!this.controller.mkdirsIfNotExists(destinationDirectory)) {
    throw new UploaderException(String.format(""String_Node_Str"",destinationDirectory));
  }
  LOG.log(Level.INFO,String.format(""String_Node_Str"" + ""String_Node_Str"",sourceLocation,destinationDirectory));
  try {
    if (!this.controller.copyFromLocalDirectory(sourceLocation,destinationDirectory)) {
      throw new UploaderException(String.format(""String_Node_Str"",sourceLocation,destinationDirectory));
    }
    LOG.log(Level.INFO,String.format(""String_Node_Str"",sourceLocation,destinationDirectory));
    return new URI(destinationDirectory + ""String_Node_Str"" + fileName);
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(""String_Node_Str"" + destinationDirectory,e);
  }
}",0.9905123339658444
173163,"@Override public void initialize(Config config){
  this.config=config;
  this.controller=getScpController();
  this.destinationDirectory=ScpContext.uploaderJobDirectory(config);
}","@Override public void initialize(Config conf){
  this.config=conf;
  this.controller=getScpController();
  this.destinationDirectory=ScpContext.uploaderJobDirectory(conf);
}",0.9829545454545454
173164,"@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,List<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    for (    int i : e.getValue()) {
      messagesPerTask.put(i,new ArrayList<Object>());
      countsPerTask.put(i,0);
    }
    messages.put(e.getKey(),messagesPerTask);
    counts.put(e.getKey(),countsPerTask);
  }
  this.dataFlowOperation=op;
  this.executor=dataFlowOperation.getTaskPlan().getThisExecutor();
}","@Override public void init(Config cfg,DataFlowOperation op,Map<Integer,List<Integer>> expectedIds){
  executor=op.getTaskPlan().getThisExecutor();
  LOG.info(String.format(""String_Node_Str"",executor,expectedIds));
  for (  Map.Entry<Integer,List<Integer>> e : expectedIds.entrySet()) {
    Map<Integer,List<Object>> messagesPerTask=new HashMap<>();
    Map<Integer,Integer> countsPerTask=new HashMap<>();
    for (    int i : e.getValue()) {
      messagesPerTask.put(i,new ArrayList<Object>());
      countsPerTask.put(i,0);
    }
    messages.put(e.getKey(),messagesPerTask);
    counts.put(e.getKey(),countsPerTask);
  }
  this.dataFlowOperation=op;
  this.executor=dataFlowOperation.getTaskPlan().getThisExecutor();
}",0.914156626506024
173165,"public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,List<Object>> map=messages.get(t);
      Map<Integer,Integer> cMap=counts.get(t);
      boolean found=true;
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
      }
      if (found) {
        List<Object> out=new ArrayList<>();
        for (        Map.Entry<Integer,List<Object>> e : map.entrySet()) {
          Object e1=e.getValue().get(0);
          out.add(e1);
        }
        if (dataFlowOperation.sendPartial(t,out,0,MessageFlags.FLAGS_MULTI_MSG)) {
          for (          Map.Entry<Integer,List<Object>> e : map.entrySet()) {
            e.getValue().remove(0);
          }
          for (          Map.Entry<Integer,Integer> e : cMap.entrySet()) {
            Integer i=e.getValue();
            e.setValue(i - 1);
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}","public void progress(){
  if (this.threadName == null) {
    this.threadName=Thread.currentThread().getName();
  }
  String tn=Thread.currentThread().getName();
  if (!tn.equals(threadName)) {
    throw new RuntimeException(String.format(""String_Node_Str"",executor,threadName,tn));
  }
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,List<Object>> map=messages.get(t);
      Map<Integer,Integer> cMap=counts.get(t);
      boolean found=true;
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
      }
      if (map.entrySet().size() == 0) {
        LOG.info(String.format(""String_Node_Str"",executor,t,counts));
      }
      if (found) {
        List<Object> out=new ArrayList<>();
        for (        Map.Entry<Integer,List<Object>> e : map.entrySet()) {
          Object e1=e.getValue().get(0);
          out.add(e1);
        }
        if (dataFlowOperation.sendPartial(t,out,0,MessageFlags.FLAGS_MULTI_MSG)) {
          for (          Map.Entry<Integer,List<Object>> e : map.entrySet()) {
            List<Object> value=e.getValue();
            if (value.size() == 0) {
              LOG.info(String.format(""String_Node_Str"",executor,t,e.getKey()));
            }
            value.remove(0);
          }
          for (          Map.Entry<Integer,Integer> e : cMap.entrySet()) {
            Integer i=e.getValue();
            e.setValue(i - 1);
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}",0.7968923418423973
173166,"@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  if (messages.get(target) == null) {
    throw new RuntimeException(String.format(""String_Node_Str"",executor,target));
  }
  List<Object> m=messages.get(target).get(source);
  Integer c=counts.get(target).get(source);
  if (m.size() > 16) {
    canAdd=false;
    LOG.info(String.format(""String_Node_Str"",executor,target,source));
  }
 else {
    LOG.info(String.format(""String_Node_Str"",executor,target,source,counts.get(target)));
    if (object instanceof MPIMessage) {
      ((MPIMessage)object).incrementRefCount();
    }
    m.add(object);
    counts.get(target).put(source,c + 1);
  }
  return canAdd;
}","@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  if (this.threadName == null) {
    this.threadName=Thread.currentThread().getName();
  }
  String tn=Thread.currentThread().getName();
  if (!tn.equals(threadName)) {
    throw new RuntimeException(String.format(""String_Node_Str"",executor,threadName,tn));
  }
  if (messages.get(target) == null) {
    throw new RuntimeException(String.format(""String_Node_Str"",executor,target));
  }
  List<Object> m=messages.get(target).get(source);
  Integer c=counts.get(target).get(source);
  if (m.size() > 16) {
    canAdd=false;
  }
 else {
    if (object instanceof MPIMessage) {
      ((MPIMessage)object).incrementRefCount();
    }
    m.add(object);
    counts.get(target).put(source,c + 1);
  }
  return canAdd;
}",0.7272727272727273
173167,"@Override public boolean send(int source,Object message,int flags,int dest){
  return false;
}","@Override public boolean send(int source,Object message,int flags,int dest){
  return delegete.sendMessage(source,message,dest,flags,sendRoutingParameters(source,dest));
}",0.6943396226415094
173168,"@Override public TaskPlan getTaskPlan(){
  return null;
}","@Override public TaskPlan getTaskPlan(){
  return plan;
}",0.9473684210526316
173169,"@Override public MessageType getType(){
  return null;
}","@Override public MessageType getType(){
  return type;
}",0.9285714285714286
173170,"public boolean build(){
  if (header == null && buffers.size() > 0) {
    return false;
  }
  if (header != null) {
    int currentSize=0;
    for (    MPIBuffer buffer : buffers) {
      currentSize+=buffer.getByteBuffer().remaining();
    }
    if (currentSize == header.getLength()) {
      complete=true;
      return true;
    }
  }
  return false;
}","public boolean build(){
  if (header == null && buffers.size() > 0) {
    return false;
  }
  if (header != null) {
    int currentSize=0;
    for (    MPIBuffer buffer : buffers) {
      currentSize+=buffer.getByteBuffer().remaining();
    }
    LOG.info(String.format(""String_Node_Str"",currentSize,header.getLength()));
    if (currentSize == header.getLength()) {
      complete=true;
      return true;
    }
  }
  return false;
}",0.899873257287706
173171,"/** 
 * Progress the communications that are pending
 */
public void progress(){
  while (pendingSends.size() > 0) {
    MPISendRequests sendRequests=pendingSends.poll();
    postMessage(sendRequests);
    waitForCompletionSends.add(sendRequests);
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    if (receiveRequests.availableBuffers.size() > 0) {
      postReceive(receiveRequests);
    }
  }
  Iterator<MPISendRequests> sendRequestsIterator=waitForCompletionSends.iterator();
  while (sendRequestsIterator.hasNext()) {
    MPISendRequests sendRequests=sendRequestsIterator.next();
    Iterator<MPIRequest> requestIterator=sendRequests.pendingSends.iterator();
    while (requestIterator.hasNext()) {
      MPIRequest r=requestIterator.next();
      try {
        Status status=r.request.testStatus();
        if (status != null) {
          requestIterator.remove();
        }
      }
 catch (      MPIException e) {
        throw new RuntimeException(""String_Node_Str"" + sendRequests.rank,e);
      }
    }
    if (sendRequests.pendingSends.size() == 0) {
      sendRequests.callback.onSendComplete(sendRequests.rank,sendRequests.edge,sendRequests.message);
      sendRequestsIterator.remove();
    }
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    try {
      Iterator<MPIRequest> requestIterator=receiveRequests.pendingRequests.iterator();
      while (requestIterator.hasNext()) {
        MPIRequest r=requestIterator.next();
        Status status=r.request.testStatus();
        if (status != null) {
          if (!status.isCancelled()) {
            r.buffer.setSize(status.getCount(MPI.BYTE));
            receiveRequests.callback.onReceiveComplete(receiveRequests.rank,receiveRequests.edge,r.buffer);
            requestIterator.remove();
          }
 else {
            throw new RuntimeException(""String_Node_Str"");
          }
        }
      }
    }
 catch (    MPIException e) {
      LOG.severe(""String_Node_Str"");
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
}","/** 
 * Progress the communications that are pending
 */
public void progress(){
  while (pendingSends.size() > 0) {
    MPISendRequests sendRequests=pendingSends.poll();
    postMessage(sendRequests);
    waitForCompletionSends.add(sendRequests);
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    if (receiveRequests.availableBuffers.size() > 0) {
      postReceive(receiveRequests);
    }
  }
  Iterator<MPISendRequests> sendRequestsIterator=waitForCompletionSends.iterator();
  while (sendRequestsIterator.hasNext()) {
    MPISendRequests sendRequests=sendRequestsIterator.next();
    Iterator<MPIRequest> requestIterator=sendRequests.pendingSends.iterator();
    while (requestIterator.hasNext()) {
      MPIRequest r=requestIterator.next();
      try {
        Status status=r.request.testStatus();
        if (status != null) {
          requestIterator.remove();
        }
      }
 catch (      MPIException e) {
        throw new RuntimeException(""String_Node_Str"" + sendRequests.rank,e);
      }
    }
    if (sendRequests.pendingSends.size() == 0) {
      sendRequests.callback.onSendComplete(sendRequests.rank,sendRequests.edge,sendRequests.message);
      sendRequestsIterator.remove();
    }
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    try {
      Iterator<MPIRequest> requestIterator=receiveRequests.pendingRequests.iterator();
      while (requestIterator.hasNext()) {
        MPIRequest r=requestIterator.next();
        Status status=r.request.testStatus();
        if (status != null) {
          if (!status.isCancelled()) {
            LOG.info(String.format(""String_Node_Str"",executor,receiveRequests.rank,status.getCount(MPI.BYTE)));
            r.buffer.setSize(status.getCount(MPI.BYTE));
            receiveRequests.callback.onReceiveComplete(receiveRequests.rank,receiveRequests.edge,r.buffer);
            requestIterator.remove();
          }
 else {
            throw new RuntimeException(""String_Node_Str"");
          }
        }
      }
    }
 catch (    MPIException e) {
      LOG.severe(""String_Node_Str"");
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
}",0.9679168549480344
173172,"/** 
 * Initialize the data structure
 * @param cfg
 * @param plan
 * @param root
 * @param dests
 */
public BinaryTreeRouter(Config cfg,TaskPlan plan,int root,Set<Integer> dests){
  int interNodeDegree=MPIContext.interNodeDegree(cfg,2);
  int intraNodeDegree=MPIContext.intraNodeDegree(cfg,2);
  mainTaskLast=false;
  BinaryTree tree=new BinaryTree(interNodeDegree,intraNodeDegree,plan,root,dests);
  Node treeRoot=tree.buildInterGroupTree(0);
  Set<Integer> thisExecutorTasks=plan.getChannelsOfExecutor(plan.getThisExecutor());
  Set<Integer> thisExecutorTasksOfOperation=new HashSet<>();
  for (  int t : thisExecutorTasks) {
    if (dests.contains(t) || root == t) {
      thisExecutorTasksOfOperation.add(t);
    }
  }
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),thisExecutorTasksOfOperation.toString()));
  this.destinationIdentifiers=new HashMap<>();
  this.receiveTasks=new HashMap<>();
  sendExternalTasksPartial=new HashMap<>();
  sendInternalTasks=new HashMap<>();
  sendExternalTasks=new HashMap<>();
  receiveExecutors=new HashSet<>();
  for (  int t : thisExecutorTasksOfOperation) {
    List<Integer> recv=new ArrayList<>();
    Node search=BinaryTree.search(treeRoot,t);
    if (search != null) {
      mainTask=search.getTaskId();
      LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),mainTask));
      if (search.getParent() != null) {
        receiveExecutors.add(plan.getExecutorForChannel(search.getParent().getTaskId()));
        recv.add(search.getParent().getTaskId());
      }
      receiveTasks.put(t,new ArrayList<>(recv));
      List<Integer> directChildren=search.getDirectChildren();
      for (      int child : directChildren) {
        destinationIdentifiers.put(t,child);
        List<Integer> childReceiveTasks=new ArrayList<>();
        childReceiveTasks.add(t);
        receiveTasks.put(child,childReceiveTasks);
      }
      Set<Integer> mainInternalSendTasks=new HashSet<>(directChildren);
      sendInternalTasks.put(t,mainInternalSendTasks);
      Set<Integer> mainExternalSendTasks=new HashSet<>();
      mainExternalSendTasks.addAll(search.getRemoteChildrenIds());
      sendExternalTasks.put(t,mainExternalSendTasks);
      destinationIdentifiers.put(t,0);
    }
 else {
      LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),t));
    }
  }
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),sendInternalTasks));
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),sendExternalTasks));
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),sendExternalTasksPartial));
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),receiveExecutors));
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),receiveTasks));
}","/** 
 * Initialize the data structure
 * @param cfg
 * @param plan
 * @param root
 * @param dests
 */
public BinaryTreeRouter(Config cfg,TaskPlan plan,int root,Set<Integer> dests){
  int interNodeDegree=MPIContext.interNodeDegree(cfg,2);
  int intraNodeDegree=MPIContext.intraNodeDegree(cfg,2);
  mainTaskLast=false;
  BinaryTree tree=new BinaryTree(interNodeDegree,intraNodeDegree,plan,root,dests);
  Node treeRoot=tree.buildInterGroupTree(0);
  Set<Integer> thisExecutorTasks=plan.getChannelsOfExecutor(plan.getThisExecutor());
  Set<Integer> thisExecutorTasksOfOperation=new HashSet<>();
  for (  int t : thisExecutorTasks) {
    if (dests.contains(t) || root == t) {
      thisExecutorTasksOfOperation.add(t);
    }
  }
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),thisExecutorTasksOfOperation.toString()));
  this.destinationIdentifiers=new HashMap<>();
  this.receiveTasks=new HashMap<>();
  sendExternalTasksPartial=new HashMap<>();
  sendInternalTasks=new HashMap<>();
  sendExternalTasks=new HashMap<>();
  receiveExecutors=new HashSet<>();
  for (  int t : thisExecutorTasksOfOperation) {
    List<Integer> recv=new ArrayList<>();
    Node search=BinaryTree.search(treeRoot,t);
    if (search != null) {
      mainTask=search.getTaskId();
      LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),mainTask));
      if (search.getParent() != null) {
        receiveExecutors.add(plan.getExecutorForChannel(search.getParent().getTaskId()));
        recv.add(search.getParent().getTaskId());
      }
      receiveTasks.put(t,new ArrayList<>(recv));
      List<Integer> directChildren=search.getDirectChildren();
      for (      int child : directChildren) {
        destinationIdentifiers.put(t,child);
        List<Integer> childReceiveTasks=new ArrayList<>();
        childReceiveTasks.add(t);
        receiveTasks.put(child,childReceiveTasks);
      }
      Set<Integer> mainInternalSendTasks=new HashSet<>(directChildren);
      sendInternalTasks.put(t,mainInternalSendTasks);
      Set<Integer> mainExternalSendTasks=new HashSet<>();
      mainExternalSendTasks.addAll(search.getRemoteChildrenIds());
      sendExternalTasks.put(t,mainExternalSendTasks);
      destinationIdentifiers.put(t,0);
    }
 else {
      LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),t));
    }
  }
}",0.9147771696637998
173173,"/** 
 * Initialize the data structure
 * @param cfg
 * @param plan
 * @param root
 * @param dests
 */
public InvertedBinaryTreeRouter(Config cfg,TaskPlan plan,int root,Set<Integer> dests,int index){
  int interNodeDegree=MPIContext.interNodeDegree(cfg,2);
  int intraNodeDegree=MPIContext.intraNodeDegree(cfg,2);
  this.executor=plan.getThisExecutor();
  this.mainTaskLast=false;
  BinaryTree tree=new BinaryTree(interNodeDegree,intraNodeDegree,plan,root,dests);
  Node treeRoot=tree.buildInterGroupTree(index);
  Set<Integer> thisExecutorTasks=plan.getChannelsOfExecutor(plan.getThisExecutor());
  Set<Integer> thisExecutorTasksOfOperation=new HashSet<>();
  for (  int t : thisExecutorTasks) {
    if (dests.contains(t) || root == t) {
      thisExecutorTasksOfOperation.add(t);
    }
  }
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),thisExecutorTasksOfOperation.toString()));
  this.destinationIdentifiers=new HashMap<>();
  this.receiveTasks=new HashMap<Integer,List<Integer>>();
  sendExternalTasksPartial=new HashMap<>();
  sendInternalTasks=new HashMap<>();
  sendExternalTasks=new HashMap<>();
  receiveExecutors=new HashSet<>();
  for (  int t : thisExecutorTasksOfOperation) {
    List<Integer> recv=new ArrayList<>();
    Node search=BinaryTree.search(treeRoot,t);
    if (search != null) {
      mainTask=search.getTaskId();
      LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),mainTask));
      for (      int k : search.getRemoteChildrenIds()) {
        receiveExecutors.add(plan.getExecutorForChannel(k));
      }
      recv.addAll(search.getAllChildrenIds());
      receiveTasks.put(t,new ArrayList<>(recv));
      List<Integer> directChildren=search.getDirectChildren();
      for (      int child : directChildren) {
        Set<Integer> sendTasks=new HashSet<>();
        sendTasks.add(t);
        sendInternalTasks.put(child,sendTasks);
        destinationIdentifiers.put(child,t);
      }
      Node parent=search.getParent();
      if (parent != null) {
        Set<Integer> sendTasks=new HashSet<>();
        sendTasks.add(parent.getTaskId());
        sendExternalTasksPartial.put(t,sendTasks);
        destinationIdentifiers.put(t,parent.getTaskId());
      }
 else {
        mainTaskLast=true;
      }
    }
 else {
      LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),t));
    }
  }
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),sendInternalTasks));
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),sendExternalTasks));
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),sendExternalTasksPartial));
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),receiveExecutors));
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),receiveTasks));
}","/** 
 * Initialize the data structure
 * @param cfg
 * @param plan
 * @param root
 * @param dests
 */
public InvertedBinaryTreeRouter(Config cfg,TaskPlan plan,int root,Set<Integer> dests,int index){
  int interNodeDegree=MPIContext.interNodeDegree(cfg,2);
  int intraNodeDegree=MPIContext.intraNodeDegree(cfg,2);
  this.executor=plan.getThisExecutor();
  this.mainTaskLast=false;
  BinaryTree tree=new BinaryTree(interNodeDegree,intraNodeDegree,plan,root,dests);
  Node treeRoot=tree.buildInterGroupTree(index);
  Set<Integer> thisExecutorTasks=plan.getChannelsOfExecutor(plan.getThisExecutor());
  Set<Integer> thisExecutorTasksOfOperation=new HashSet<>();
  for (  int t : thisExecutorTasks) {
    if (dests.contains(t) || root == t) {
      thisExecutorTasksOfOperation.add(t);
    }
  }
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),thisExecutorTasksOfOperation.toString()));
  this.destinationIdentifiers=new HashMap<>();
  this.receiveTasks=new HashMap<Integer,List<Integer>>();
  sendExternalTasksPartial=new HashMap<>();
  sendInternalTasks=new HashMap<>();
  sendExternalTasks=new HashMap<>();
  receiveExecutors=new HashSet<>();
  for (  int t : thisExecutorTasksOfOperation) {
    List<Integer> recv=new ArrayList<>();
    Node search=BinaryTree.search(treeRoot,t);
    if (search != null) {
      mainTask=search.getTaskId();
      LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),mainTask));
      for (      int k : search.getRemoteChildrenIds()) {
        receiveExecutors.add(plan.getExecutorForChannel(k));
      }
      recv.addAll(search.getAllChildrenIds());
      receiveTasks.put(t,new ArrayList<>(recv));
      List<Integer> directChildren=search.getDirectChildren();
      for (      int child : directChildren) {
        Set<Integer> sendTasks=new HashSet<>();
        sendTasks.add(t);
        sendInternalTasks.put(child,sendTasks);
        destinationIdentifiers.put(child,t);
      }
      Node parent=search.getParent();
      if (parent != null) {
        Set<Integer> sendTasks=new HashSet<>();
        sendTasks.add(parent.getTaskId());
        sendExternalTasksPartial.put(t,sendTasks);
        destinationIdentifiers.put(t,parent.getTaskId());
      }
 else {
        mainTaskLast=true;
      }
    }
 else {
      LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),t));
    }
  }
}",0.9156020131629888
173174,"/** 
 * Initialize the data structure
 * @param cfg
 * @param plan
 * @param roots
 * @param dests
 */
public KeyedInvertedBinaryTreeRouter(Config cfg,TaskPlan plan,Set<Integer> roots,Set<Integer> dests){
  int interNodeDegree=MPIContext.interNodeDegree(cfg,2);
  int intraNodeDegree=MPIContext.intraNodeDegree(cfg,2);
  mainTaskLast=false;
  this.taskPlan=plan;
  this.destinationIdentifiers=new HashMap<>();
  this.pathToTask=new HashMap<>();
  this.receiveTasks=new HashMap<Integer,Map<Integer,List<Integer>>>();
  sendExternalTasksPartial=new HashMap<>();
  sendInternalTasks=new HashMap<>();
  sendExternalTasks=new HashMap<>();
  receiveExecutors=new HashSet<>();
  List<Integer> rootsSorted=new ArrayList<Integer>(roots);
  Collections.sort(rootsSorted);
  mainTask=new HashMap<>();
  Set<Integer> destinationsInThisExecutor=TaskPlanUtils.getTasksOfThisExecutor(plan,dests);
  for (  int t : destinationsInThisExecutor) {
    int path=rootsSorted.indexOf(t);
    pathToTask.put(path,t);
  }
  for (int path=0; path < roots.size(); path++) {
    int root=rootsSorted.get(path);
    BinaryTree tree=new BinaryTree(interNodeDegree,intraNodeDegree,plan,root,dests);
    Node treeRoot=tree.buildInterGroupTree(path);
    Set<Integer> thisExecutorTasks=plan.getChannelsOfExecutor(plan.getThisExecutor());
    Set<Integer> thisExecutorTasksOfOperation=new HashSet<>();
    for (    int t : thisExecutorTasks) {
      if (dests.contains(t) || root == t) {
        thisExecutorTasksOfOperation.add(t);
      }
    }
    LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),thisExecutorTasksOfOperation.toString()));
    for (    int t : thisExecutorTasksOfOperation) {
      List<Integer> recv=new ArrayList<>();
      Node search=BinaryTree.search(treeRoot,t);
      if (search != null) {
        mainTask.put(path,search.getTaskId());
        LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),mainTask));
        for (        int k : search.getRemoteChildrenIds()) {
          receiveExecutors.add(plan.getExecutorForChannel(k));
        }
        recv.addAll(search.getAllChildrenIds());
        Map<Integer,List<Integer>> receivePathMap;
        if (receiveTasks.containsKey(t)) {
          receivePathMap=receiveTasks.get(t);
        }
 else {
          receivePathMap=new HashMap<>();
        }
        receivePathMap.put(path,new ArrayList<>(recv));
        receiveTasks.put(t,receivePathMap);
        List<Integer> directChildren=search.getDirectChildren();
        if (t == path) {
          LOG.log(Level.INFO,String.format(""String_Node_Str"",plan.getThisExecutor(),directChildren));
        }
        for (        int child : directChildren) {
          Map<Integer,Set<Integer>> sendMap;
          if (sendInternalTasks.containsKey(child)) {
            sendMap=sendInternalTasks.get(child);
          }
 else {
            sendMap=new HashMap<>();
          }
          Set<Integer> sendTasks=new HashSet<>();
          sendTasks.add(t);
          sendMap.put(path,sendTasks);
          sendInternalTasks.put(child,sendMap);
          Map<Integer,Integer> destinationMap=new HashMap<>();
          if (destinationIdentifiers.containsKey(path)) {
            destinationMap=destinationIdentifiers.get(path);
          }
          destinationMap.put(child,t);
          destinationIdentifiers.put(path,destinationMap);
        }
        Node parent=search.getParent();
        if (parent != null) {
          Map<Integer,Set<Integer>> mainSendMap;
          if (sendExternalTasksPartial.containsKey(t)) {
            mainSendMap=sendExternalTasksPartial.get(t);
          }
 else {
            mainSendMap=new HashMap<>();
          }
          Set<Integer> sendTasks=new HashSet<>();
          sendTasks.add(parent.getTaskId());
          mainSendMap.put(path,sendTasks);
          sendExternalTasksPartial.put(t,mainSendMap);
          Map<Integer,Integer> destinationMap=new HashMap<>();
          if (destinationIdentifiers.containsKey(path)) {
            destinationMap=destinationIdentifiers.get(path);
          }
          destinationMap.put(t,parent.getTaskId());
          destinationIdentifiers.put(path,destinationMap);
        }
 else {
          mainTaskLast=true;
        }
      }
 else {
        LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),t));
      }
    }
  }
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),sendInternalTasks));
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),sendExternalTasks));
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),sendExternalTasksPartial));
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),receiveExecutors));
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),receiveTasks));
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),mainTask));
}","/** 
 * Initialize the data structure
 * @param cfg
 * @param plan
 * @param roots
 * @param dests
 */
public KeyedInvertedBinaryTreeRouter(Config cfg,TaskPlan plan,Set<Integer> roots,Set<Integer> dests){
  int interNodeDegree=MPIContext.interNodeDegree(cfg,2);
  int intraNodeDegree=MPIContext.intraNodeDegree(cfg,2);
  mainTaskLast=false;
  this.taskPlan=plan;
  this.destinationIdentifiers=new HashMap<>();
  this.pathToTask=new HashMap<>();
  this.receiveTasks=new HashMap<Integer,Map<Integer,List<Integer>>>();
  sendExternalTasksPartial=new HashMap<>();
  sendInternalTasks=new HashMap<>();
  sendExternalTasks=new HashMap<>();
  receiveExecutors=new HashSet<>();
  List<Integer> rootsSorted=new ArrayList<Integer>(roots);
  Collections.sort(rootsSorted);
  mainTask=new HashMap<>();
  Set<Integer> destinationsInThisExecutor=TaskPlanUtils.getTasksOfThisExecutor(plan,dests);
  for (  int t : destinationsInThisExecutor) {
    int path=rootsSorted.indexOf(t);
    pathToTask.put(path,t);
  }
  for (int path=0; path < roots.size(); path++) {
    int root=rootsSorted.get(path);
    BinaryTree tree=new BinaryTree(interNodeDegree,intraNodeDegree,plan,root,dests);
    Node treeRoot=tree.buildInterGroupTree(path);
    Set<Integer> thisExecutorTasks=plan.getChannelsOfExecutor(plan.getThisExecutor());
    Set<Integer> thisExecutorTasksOfOperation=new HashSet<>();
    for (    int t : thisExecutorTasks) {
      if (dests.contains(t) || root == t) {
        thisExecutorTasksOfOperation.add(t);
      }
    }
    LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),thisExecutorTasksOfOperation.toString()));
    for (    int t : thisExecutorTasksOfOperation) {
      List<Integer> recv=new ArrayList<>();
      Node search=BinaryTree.search(treeRoot,t);
      if (search != null) {
        mainTask.put(path,search.getTaskId());
        LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),mainTask));
        for (        int k : search.getRemoteChildrenIds()) {
          receiveExecutors.add(plan.getExecutorForChannel(k));
        }
        recv.addAll(search.getAllChildrenIds());
        Map<Integer,List<Integer>> receivePathMap;
        if (receiveTasks.containsKey(t)) {
          receivePathMap=receiveTasks.get(t);
        }
 else {
          receivePathMap=new HashMap<>();
        }
        receivePathMap.put(path,new ArrayList<>(recv));
        receiveTasks.put(t,receivePathMap);
        List<Integer> directChildren=search.getDirectChildren();
        if (t == path) {
          LOG.log(Level.INFO,String.format(""String_Node_Str"",plan.getThisExecutor(),directChildren));
        }
        for (        int child : directChildren) {
          Map<Integer,Set<Integer>> sendMap;
          if (sendInternalTasks.containsKey(child)) {
            sendMap=sendInternalTasks.get(child);
          }
 else {
            sendMap=new HashMap<>();
          }
          Set<Integer> sendTasks=new HashSet<>();
          sendTasks.add(t);
          sendMap.put(path,sendTasks);
          sendInternalTasks.put(child,sendMap);
          Map<Integer,Integer> destinationMap=new HashMap<>();
          if (destinationIdentifiers.containsKey(path)) {
            destinationMap=destinationIdentifiers.get(path);
          }
          destinationMap.put(child,t);
          destinationIdentifiers.put(path,destinationMap);
        }
        Node parent=search.getParent();
        if (parent != null) {
          Map<Integer,Set<Integer>> mainSendMap;
          if (sendExternalTasksPartial.containsKey(t)) {
            mainSendMap=sendExternalTasksPartial.get(t);
          }
 else {
            mainSendMap=new HashMap<>();
          }
          Set<Integer> sendTasks=new HashSet<>();
          sendTasks.add(parent.getTaskId());
          mainSendMap.put(path,sendTasks);
          sendExternalTasksPartial.put(t,mainSendMap);
          Map<Integer,Integer> destinationMap=new HashMap<>();
          if (destinationIdentifiers.containsKey(path)) {
            destinationMap=destinationIdentifiers.get(path);
          }
          destinationMap.put(t,parent.getTaskId());
          destinationIdentifiers.put(path,destinationMap);
        }
 else {
          mainTaskLast=true;
        }
      }
 else {
        LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),t));
      }
    }
  }
}",0.944033101045296
173175,"/** 
 * add one file to tar.gz file
 * @param file file to be added to the tar.gz
 * @dirPrefixForTar directory structure of this file in tar.gz
 */
public void addFileToArchive(File file,String dirPrefixForTar){
  try {
    String filePathInTar=dirPrefixForTar + file.getName();
    TarArchiveEntry entry=new TarArchiveEntry(file,filePathInTar);
    entry.setSize(file.length());
    tarOutputStream.putArchiveEntry(entry);
    IOUtils.copy(new FileInputStream(file),tarOutputStream);
    tarOutputStream.closeArchiveEntry();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * add one file to tar.gz file
 * @param file file to be added to the tar.gz
 */
public void addFileToArchive(File file,String dirPrefixForTar){
  try {
    String filePathInTar=dirPrefixForTar + file.getName();
    TarArchiveEntry entry=new TarArchiveEntry(file,filePathInTar);
    entry.setSize(file.length());
    tarOutputStream.putArchiveEntry(entry);
    IOUtils.copy(new FileInputStream(file),tarOutputStream);
    tarOutputStream.closeArchiveEntry();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9433962264150944
173176,"/** 
 * add all files in the given directory to the tar.gz file add the given prefix to all files in tar names do not copy files recursively. Only one level copying.
 * @param path of the firectory to be added
 */
public void addDirectoryToArchive(String path){
  File dir=new File(path);
  String prefix=dirPrefixForArchive + dir.getName() + ""String_Node_Str"";
  for (  File file : dir.listFiles()) {
    addFileToArchive(file,prefix);
  }
}","/** 
 * add all files in the given directory to the tar.gz file add the given prefix to all files in tar names do not copy files recursively. Only one level copying.
 * @param path of the firectory to be added
 */
public void addDirectoryToArchive(String path){
  File dir=new File(path);
  String prefix=DIR_PREFIX_FOR_ARCHIVE + dir.getName() + ""String_Node_Str"";
  for (  File file : dir.listFiles()) {
    addFileToArchive(file,prefix);
  }
}",0.9582863585118376
173177,"/** 
 * @param targetDir
 * @return
 */
public static TarGzipPacker createTarGzipPacker(String targetDir,Config config){
  String archiveFilename=SchedulerContext.jobPackageName(config);
  Path archiveFile=Paths.get(targetDir + ""String_Node_Str"" + archiveFilename);
  try {
    OutputStream outStream=Files.newOutputStream(archiveFile);
    GzipCompressorOutputStream gzipOutputStream=new GzipCompressorOutputStream(outStream);
    TarArchiveOutputStream tarOutputStream=new TarArchiveOutputStream(gzipOutputStream);
    return new TarGzipPacker(archiveFile,tarOutputStream);
  }
 catch (  IOException ioe) {
    System.out.println(""String_Node_Str"");
    ioe.printStackTrace();
    return null;
  }
}","/** 
 * Create
 * @param targetDir
 * @return
 */
public static TarGzipPacker createTarGzipPacker(String targetDir,Config config){
  String archiveFilename=SchedulerContext.jobPackageName(config);
  Path archiveFile=Paths.get(targetDir + ""String_Node_Str"" + archiveFilename);
  try {
    OutputStream outStream=Files.newOutputStream(archiveFile);
    GzipCompressorOutputStream gzipOutputStream=new GzipCompressorOutputStream(outStream);
    TarArchiveOutputStream tarOutputStream=new TarArchiveOutputStream(gzipOutputStream);
    return new TarGzipPacker(archiveFile,tarOutputStream);
  }
 catch (  IOException ioe) {
    System.out.println(""String_Node_Str"");
    ioe.printStackTrace();
    return null;
  }
}",0.9929178470254958
173178,"/** 
 * @param archiveFile
 * @param tarOutputStream
 */
private TarGzipPacker(Path archiveFile,TarArchiveOutputStream tarOutputStream){
  this.archiveFile=archiveFile;
  this.tarOutputStream=tarOutputStream;
}","/** 
 * Pack
 * @param archiveFile
 * @param tarOutputStream
 */
private TarGzipPacker(Path archiveFile,TarArchiveOutputStream tarOutputStream){
  this.archiveFile=archiveFile;
  this.tarOutputStream=tarOutputStream;
}",0.9813084112149532
173179,"/** 
 * At this level the method does not return an OperationMemoryManager since the implementaion does not handle OperationMemoryManager's
 * @param opID
 * @return
 */
@Override public OperationMemoryManager addOperation(int opID){
  dbMap.put(opID,env.openDbi(String.valueOf(opID),MDB_CREATE));
  return null;
}","/** 
 * At this level the method does not return an OperationMemoryManager since the implementaion does not handle OperationMemoryManager's
 */
@Override public OperationMemoryManager addOperation(int opID){
  dbMap.put(opID,env.openDbi(String.valueOf(opID),MDB_CREATE));
  return null;
}",0.956810631229236
173180,"@Override public void init(Config cfg,MessageType messageType,TaskPlan plan,int graphEdge){
  this.config=cfg;
  this.instancePlan=plan;
  this.edge=graphEdge;
  this.type=messageType;
  this.bounded=false;
  this.executor=instancePlan.getThisExecutor();
  int noOfSendBuffers=MPIContext.broadcastBufferCount(config);
  int sendBufferSize=MPIContext.bufferSize(config);
  this.sendBuffers=new ArrayBlockingQueue<MPIBuffer>(noOfSendBuffers);
  for (int i=0; i < noOfSendBuffers; i++) {
    sendBuffers.offer(new MPIBuffer(sendBufferSize));
  }
  this.receiveBuffers=new HashMap<>();
  this.pendingSendMessagesPerSource=new HashMap<>();
  this.pendingReceiveMessagesPerSource=new HashMap<>();
  this.pendingReceiveDeSerializations=new HashMap<>();
  LOG.info(String.format(""String_Node_Str"",instancePlan.getThisExecutor()));
  setupRouting();
  LOG.info(String.format(""String_Node_Str"",instancePlan.getThisExecutor()));
  setupCommunication();
  LOG.info(String.format(""String_Node_Str"",instancePlan.getThisExecutor()));
  initSerializers();
}","@Override public void init(Config cfg,MessageType messageType,TaskPlan plan,int graphEdge){
  this.config=cfg;
  this.instancePlan=plan;
  this.edge=graphEdge;
  this.type=messageType;
  this.debug=false;
  this.executor=instancePlan.getThisExecutor();
  int noOfSendBuffers=MPIContext.broadcastBufferCount(config);
  int sendBufferSize=MPIContext.bufferSize(config);
  this.sendBuffers=new ArrayBlockingQueue<MPIBuffer>(noOfSendBuffers);
  for (int i=0; i < noOfSendBuffers; i++) {
    sendBuffers.offer(new MPIBuffer(sendBufferSize));
  }
  this.receiveBuffers=new HashMap<>();
  this.pendingSendMessagesPerSource=new HashMap<>();
  this.pendingReceiveMessagesPerSource=new HashMap<>();
  this.pendingReceiveDeSerializations=new HashMap<>();
  LOG.info(String.format(""String_Node_Str"",instancePlan.getThisExecutor()));
  setupRouting();
  LOG.info(String.format(""String_Node_Str"",instancePlan.getThisExecutor()));
  setupCommunication();
  LOG.info(String.format(""String_Node_Str"",instancePlan.getThisExecutor()));
  initSerializers();
}",0.9951923076923076
173181,"@Override public void progress(){
  lock.lock();
  try {
    for (    Map.Entry<Integer,ArrayBlockingQueue<Pair<Object,MPISendMessage>>> e : pendingSendMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPISendMessage>> pendingSendMessages=e.getValue();
      boolean canProgress=true;
      while (pendingSendMessages.size() > 0 && canProgress) {
        Pair<Object,MPISendMessage> pair=pendingSendMessages.peek();
        MPISendMessage mpiSendMessage=pair.getValue();
        Object messageObject=pair.getKey();
        if (mpiSendMessage.serializedState() == MPISendMessage.SendState.INIT) {
          for (          Integer i : mpiSendMessage.getInternalSends()) {
            boolean receiveAccepted=receiveSendInternally(mpiSendMessage.getSource(),i,mpiSendMessage.getPath(),mpiSendMessage.getFlags(),messageObject);
            if (!receiveAccepted) {
              canProgress=false;
              int attempt=updateAttemptMap(sendMessageInternalAttempts,i,1);
              if (attempt > MAX_ATTEMPTS) {
                LOG.info(String.format(""String_Node_Str"",executor,attempt));
              }
              break;
            }
 else {
              updateAttemptMap(sendMessageInternalAttempts,i,-1);
            }
          }
          if (canProgress) {
            mpiSendMessage.setSendState(MPISendMessage.SendState.SENT_INTERNALLY);
          }
        }
        if (canProgress) {
          if (mpiSendMessage.getExternalSends().size() == 0) {
            pendingSendMessages.poll();
            continue;
          }
          MPISendMessage message=(MPISendMessage)messageSerializer.build(pair.getKey(),mpiSendMessage);
          if (message.serializedState() == MPISendMessage.SendState.SERIALIZED) {
            List<Integer> exRoutes=new ArrayList<>(mpiSendMessage.getExternalSends());
            int startOfExternalRouts=mpiSendMessage.getAcceptedExternalSends();
            int noOfExternalSends=startOfExternalRouts;
            for (int i=startOfExternalRouts; i < exRoutes.size(); i++) {
              boolean sendAccepted=sendMessageToTarget(message.getMPIMessage(),exRoutes.get(i));
              if (!sendAccepted) {
                canProgress=false;
                sendMessageToTargetAttempts++;
                if (sendMessageToTargetAttempts > MAX_ATTEMPTS) {
                  LOG.info(String.format(""String_Node_Str"",executor,sendMessageToTargetAttempts));
                }
                break;
              }
 else {
                if (sendMessageToTargetAttempts > 0) {
                  sendMessageToTargetAttempts--;
                }
                mpiSendMessage.incrementAcceptedExternalSends();
                noOfExternalSends++;
              }
            }
            if (noOfExternalSends == exRoutes.size()) {
              mpiSendMessage.setSendState(MPISendMessage.SendState.FINISHED);
              pendingSendMessages.poll();
            }
          }
 else {
            break;
          }
        }
      }
    }
    for (    Map.Entry<Integer,Queue<MPIMessage>> it : pendingReceiveDeSerializations.entrySet()) {
      MPIMessage currentMessage=it.getValue().poll();
      if (currentMessage == null) {
        continue;
      }
      Object object=messageDeSerializer.build(currentMessage,currentMessage.getHeader().getEdge());
      int id=currentMessage.getOriginatingId();
      Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=pendingReceiveMessagesPerSource.get(id);
      currentMessage.setReceivedState(MPIMessage.ReceivedState.INIT);
      if (pendingReceiveMessages.size() > 0) {
        if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
          throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
        }
      }
 else {
        currentMessage.incrementRefCount();
        currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
        if (!passMessageDownstream(object,currentMessage)) {
          if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
            throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
          }
          continue;
        }
        currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
        if (!receiveMessage(currentMessage,object)) {
          if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
            throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
          }
          int attempt=updateAttemptMap(receiveMessageAttempts,id,1);
          if (attempt > MAX_ATTEMPTS) {
            LOG.info(String.format(""String_Node_Str"",executor,attempt));
          }
          continue;
        }
 else {
          updateAttemptMap(receiveMessageAttempts,id,-1);
        }
        currentMessage.release();
      }
    }
    for (    Map.Entry<Integer,Queue<Pair<Object,MPIMessage>>> e : pendingReceiveMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=e.getValue();
      while (pendingReceiveMessages.size() > 0) {
        Pair<Object,MPIMessage> pair=pendingReceiveMessages.peek();
        MPIMessage.ReceivedState state=pair.getRight().getReceivedState();
        MPIMessage currentMessage=pair.getRight();
        Object object=pair.getLeft();
        if (state == MPIMessage.ReceivedState.INIT) {
          currentMessage.incrementRefCount();
        }
        if (state == MPIMessage.ReceivedState.DOWN || state == MPIMessage.ReceivedState.INIT) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
          if (!passMessageDownstream(object,currentMessage)) {
            break;
          }
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiveMessage(currentMessage,object)) {
            int attempt=updateAttemptMap(receiveMessageAttempts,0,1);
            if (attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            break;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,0,-1);
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
 else         if (state == MPIMessage.ReceivedState.RECEIVE) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiveMessage(currentMessage,object)) {
            int attempt=updateAttemptMap(receiveMessageAttempts,0,1);
            if (attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            break;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,0,-1);
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
      }
    }
  }
  finally {
    lock.unlock();
  }
}","@Override public void progress(){
  lock.lock();
  try {
    for (    Map.Entry<Integer,ArrayBlockingQueue<Pair<Object,MPISendMessage>>> e : pendingSendMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPISendMessage>> pendingSendMessages=e.getValue();
      boolean canProgress=true;
      while (pendingSendMessages.size() > 0 && canProgress) {
        Pair<Object,MPISendMessage> pair=pendingSendMessages.peek();
        MPISendMessage mpiSendMessage=pair.getValue();
        Object messageObject=pair.getKey();
        if (mpiSendMessage.serializedState() == MPISendMessage.SendState.INIT) {
          for (          Integer i : mpiSendMessage.getInternalSends()) {
            boolean receiveAccepted=receiveSendInternally(mpiSendMessage.getSource(),i,mpiSendMessage.getPath(),mpiSendMessage.getFlags(),messageObject);
            if (!receiveAccepted) {
              canProgress=false;
              int attempt=updateAttemptMap(sendMessageInternalAttempts,i,1);
              if (debug && attempt > MAX_ATTEMPTS) {
                LOG.info(String.format(""String_Node_Str"",executor,attempt));
              }
              break;
            }
 else {
              updateAttemptMap(sendMessageInternalAttempts,i,-1);
            }
          }
          if (canProgress) {
            mpiSendMessage.setSendState(MPISendMessage.SendState.SENT_INTERNALLY);
          }
        }
        if (canProgress) {
          if (mpiSendMessage.getExternalSends().size() == 0) {
            pendingSendMessages.poll();
            continue;
          }
          MPISendMessage message=(MPISendMessage)messageSerializer.build(pair.getKey(),mpiSendMessage);
          if (message.serializedState() == MPISendMessage.SendState.SERIALIZED) {
            List<Integer> exRoutes=new ArrayList<>(mpiSendMessage.getExternalSends());
            int startOfExternalRouts=mpiSendMessage.getAcceptedExternalSends();
            int noOfExternalSends=startOfExternalRouts;
            for (int i=startOfExternalRouts; i < exRoutes.size(); i++) {
              boolean sendAccepted=sendMessageToTarget(message.getMPIMessage(),exRoutes.get(i));
              if (!sendAccepted) {
                canProgress=false;
                sendMessageToTargetAttempts++;
                if (sendMessageToTargetAttempts > MAX_ATTEMPTS) {
                  LOG.info(String.format(""String_Node_Str"",executor,sendMessageToTargetAttempts));
                }
                break;
              }
 else {
                if (sendMessageToTargetAttempts > 0) {
                  sendMessageToTargetAttempts--;
                }
                mpiSendMessage.incrementAcceptedExternalSends();
                noOfExternalSends++;
              }
            }
            if (noOfExternalSends == exRoutes.size()) {
              mpiSendMessage.setSendState(MPISendMessage.SendState.FINISHED);
              pendingSendMessages.poll();
            }
          }
 else {
            break;
          }
        }
      }
    }
    for (    Map.Entry<Integer,Queue<MPIMessage>> it : pendingReceiveDeSerializations.entrySet()) {
      MPIMessage currentMessage=it.getValue().poll();
      if (currentMessage == null) {
        continue;
      }
      Object object=messageDeSerializer.build(currentMessage,currentMessage.getHeader().getEdge());
      int id=currentMessage.getOriginatingId();
      Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=pendingReceiveMessagesPerSource.get(id);
      currentMessage.setReceivedState(MPIMessage.ReceivedState.INIT);
      if (pendingReceiveMessages.size() > 0) {
        if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
          throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
        }
      }
 else {
        currentMessage.incrementRefCount();
        currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
        if (!passMessageDownstream(object,currentMessage)) {
          if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
            throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
          }
          continue;
        }
        currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
        if (!receiveMessage(currentMessage,object)) {
          if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
            throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
          }
          int attempt=updateAttemptMap(receiveMessageAttempts,id,1);
          if (debug && attempt > MAX_ATTEMPTS) {
            LOG.info(String.format(""String_Node_Str"",executor,attempt));
          }
          continue;
        }
 else {
          updateAttemptMap(receiveMessageAttempts,id,-1);
        }
        currentMessage.release();
      }
    }
    for (    Map.Entry<Integer,Queue<Pair<Object,MPIMessage>>> e : pendingReceiveMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=e.getValue();
      while (pendingReceiveMessages.size() > 0) {
        Pair<Object,MPIMessage> pair=pendingReceiveMessages.peek();
        MPIMessage.ReceivedState state=pair.getRight().getReceivedState();
        MPIMessage currentMessage=pair.getRight();
        Object object=pair.getLeft();
        if (state == MPIMessage.ReceivedState.INIT) {
          currentMessage.incrementRefCount();
        }
        if (state == MPIMessage.ReceivedState.DOWN || state == MPIMessage.ReceivedState.INIT) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
          if (!passMessageDownstream(object,currentMessage)) {
            break;
          }
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiveMessage(currentMessage,object)) {
            int attempt=updateAttemptMap(receiveMessageAttempts,0,1);
            if (debug && attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            break;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,0,-1);
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
 else         if (state == MPIMessage.ReceivedState.RECEIVE) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiveMessage(currentMessage,object)) {
            int attempt=updateAttemptMap(receiveMessageAttempts,0,1);
            if (debug && attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            break;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,0,-1);
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.9973995954926322
173182,"public static int receiveBufferCount(Config cfg){
  return cfg.getIntegerValue(RECEIVE_BUFFERS_COUNT,128);
}","public static int receiveBufferCount(Config cfg){
  return cfg.getIntegerValue(RECEIVE_BUFFERS_COUNT,32);
}",0.986046511627907
173183,"public static int sendPendingMax(Config cfg){
  return cfg.getIntegerValue(SEND_PENDING_MAX,128);
}","public static int sendPendingMax(Config cfg){
  return cfg.getIntegerValue(SEND_PENDING_MAX,16);
}",0.9847715736040608
173184,"public static int bufferSize(Config cfg){
  return cfg.getIntegerValue(BUFFER_SIZE,256000);
}","public static int bufferSize(Config cfg){
  return cfg.getIntegerValue(BUFFER_SIZE,2048000);
}",0.9732620320855616
173185,"public static int sendBuffersCount(Config cfg){
  return cfg.getIntegerValue(SEND_BUFFERS_COUNT,128);
}","public static int sendBuffersCount(Config cfg){
  return cfg.getIntegerValue(SEND_BUFFERS_COUNT,16);
}",0.9853658536585366
173186,"public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,List<Object>> map=messages.get(t);
      Map<Integer,Integer> cMap=counts.get(t);
      boolean found=true;
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
      }
      if (found) {
        List<Object> out=new ArrayList<>();
        for (        Map.Entry<Integer,List<Object>> e : map.entrySet()) {
          Object e1=e.getValue().get(0);
          if (!(e1 instanceof MPIMessage)) {
            out.add(new MultiObject(e.getKey(),e1));
          }
 else {
            out.add(e1);
          }
          e.getValue().remove(0);
        }
        if (sendMessagePartial(t,out,0,MPIContext.FLAGS_MULTI_MSG,type)) {
          for (          Map.Entry<Integer,Integer> e : cMap.entrySet()) {
            Integer i=e.getValue();
            cMap.put(e.getKey(),i - 1);
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}","public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,List<Object>> map=messages.get(t);
      Map<Integer,Integer> cMap=counts.get(t);
      boolean found=true;
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
      }
      if (found) {
        List<Object> out=new ArrayList<>();
        for (        Map.Entry<Integer,List<Object>> e : map.entrySet()) {
          Object e1=e.getValue().get(0);
          if (!(e1 instanceof MPIMessage)) {
            out.add(new MultiObject(e.getKey(),e1));
          }
 else {
            out.add(e1);
          }
        }
        if (sendMessagePartial(t,out,0,MPIContext.FLAGS_MULTI_MSG,type)) {
          for (          Map.Entry<Integer,List<Object>> e : map.entrySet()) {
            e.getValue().remove(0);
          }
          for (          Map.Entry<Integer,Integer> e : cMap.entrySet()) {
            Integer i=e.getValue();
            e.setValue(i - 1);
          }
        }
 else {
          canProgress=false;
        }
      }
    }
  }
}",0.909404659188956
173187,"@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  if (messages.get(target) == null) {
    throw new RuntimeException(String.format(""String_Node_Str"",executor,target));
  }
  List<Object> m=messages.get(target).get(source);
  Integer c=counts.get(target).get(source);
  if (m.size() > 128) {
    canAdd=false;
  }
 else {
    if (object instanceof MPIMessage) {
      ((MPIMessage)object).incrementRefCount();
    }
    m.add(object);
    counts.get(target).put(source,c + 1);
  }
  return canAdd;
}","@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  if (messages.get(target) == null) {
    throw new RuntimeException(String.format(""String_Node_Str"",executor,target));
  }
  List<Object> m=messages.get(target).get(source);
  Integer c=counts.get(target).get(source);
  if (m.size() > 16) {
    canAdd=false;
  }
 else {
    if (object instanceof MPIMessage) {
      ((MPIMessage)object).incrementRefCount();
    }
    m.add(object);
    counts.get(target).put(source,c + 1);
  }
  return canAdd;
}",0.9973427812223208
173188,"@Override public void progress(){
  lock.lock();
  try {
    for (    Map.Entry<Integer,ArrayBlockingQueue<Pair<Object,MPISendMessage>>> e : pendingSendMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPISendMessage>> pendingSendMessages=e.getValue();
      boolean canProgress=true;
      while (pendingSendMessages.size() > 0 && canProgress) {
        Pair<Object,MPISendMessage> pair=pendingSendMessages.peek();
        MPISendMessage mpiSendMessage=pair.getValue();
        Object messageObject=pair.getKey();
        if (mpiSendMessage.serializedState() == MPISendMessage.SendState.INIT) {
          for (          Integer i : mpiSendMessage.getInternalSends()) {
            boolean receiveAccepted=receiveSendInternally(mpiSendMessage.getSource(),i,mpiSendMessage.getPath(),mpiSendMessage.getFlags(),messageObject);
            if (!receiveAccepted) {
              canProgress=false;
              break;
            }
          }
          if (canProgress) {
            mpiSendMessage.setSendState(MPISendMessage.SendState.SENT_INTERNALLY);
          }
        }
        if (canProgress) {
          if (mpiSendMessage.getExternalSends().size() == 0) {
            pendingSendMessages.poll();
            continue;
          }
          MPISendMessage message=(MPISendMessage)messageSerializer.build(pair.getKey(),mpiSendMessage);
          if (message.serializedState() == MPISendMessage.SendState.SERIALIZED) {
            List<Integer> exRoutes=new ArrayList<>(mpiSendMessage.getExternalSends());
            int startOfExternalRouts=mpiSendMessage.getAcceptedExternalSends();
            int noOfExternalSends=startOfExternalRouts;
            for (int i=startOfExternalRouts; i < exRoutes.size(); i++) {
              boolean sendAccepted=sendMessageToTarget(message.getMPIMessage(),exRoutes.get(i));
              if (!sendAccepted) {
                canProgress=false;
                break;
              }
 else {
                mpiSendMessage.incrementAcceptedExternalSends();
                noOfExternalSends++;
              }
            }
            if (noOfExternalSends == exRoutes.size()) {
              mpiSendMessage.setSendState(MPISendMessage.SendState.FINISHED);
              pendingSendMessages.poll();
            }
          }
 else {
            break;
          }
        }
      }
    }
    for (    Map.Entry<Integer,Queue<MPIMessage>> it : pendingReceiveDeSerializations.entrySet()) {
      MPIMessage currentMessage=it.getValue().poll();
      if (currentMessage == null) {
        continue;
      }
      Object object=messageDeSerializer.build(currentMessage,currentMessage.getHeader().getEdge());
      int id=currentMessage.getOriginatingId();
      Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=pendingReceiveMessagesPerSource.get(id);
      currentMessage.setReceivedState(MPIMessage.ReceivedState.INIT);
      if (pendingReceiveMessages.size() > 0) {
        if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
          throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
        }
      }
 else {
        currentMessage.incrementRefCount();
        currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
        if (!passMessageDownstream(object,currentMessage)) {
          if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
            throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
          }
          continue;
        }
        currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
        if (!receiveMessage(currentMessage,object)) {
          if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
            throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
          }
          continue;
        }
        currentMessage.release();
      }
    }
    for (    Map.Entry<Integer,Queue<Pair<Object,MPIMessage>>> e : pendingReceiveMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=e.getValue();
      while (pendingReceiveMessages.size() > 0) {
        Pair<Object,MPIMessage> pair=pendingReceiveMessages.peek();
        MPIMessage.ReceivedState state=pair.getRight().getReceivedState();
        MPIMessage currentMessage=pair.getRight();
        Object object=pair.getLeft();
        if (state == MPIMessage.ReceivedState.INIT) {
          currentMessage.incrementRefCount();
        }
        if (state == MPIMessage.ReceivedState.DOWN || state == MPIMessage.ReceivedState.INIT) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
          if (!passMessageDownstream(object,currentMessage)) {
            break;
          }
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiveMessage(currentMessage,object)) {
            break;
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
 else         if (state == MPIMessage.ReceivedState.RECEIVE) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiveMessage(currentMessage,object)) {
            break;
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
      }
    }
  }
  finally {
    lock.unlock();
  }
}","@Override public void progress(){
  lock.lock();
  try {
    for (    Map.Entry<Integer,ArrayBlockingQueue<Pair<Object,MPISendMessage>>> e : pendingSendMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPISendMessage>> pendingSendMessages=e.getValue();
      boolean canProgress=true;
      while (pendingSendMessages.size() > 0 && canProgress) {
        Pair<Object,MPISendMessage> pair=pendingSendMessages.peek();
        MPISendMessage mpiSendMessage=pair.getValue();
        Object messageObject=pair.getKey();
        if (mpiSendMessage.serializedState() == MPISendMessage.SendState.INIT) {
          for (          Integer i : mpiSendMessage.getInternalSends()) {
            boolean receiveAccepted=receiveSendInternally(mpiSendMessage.getSource(),i,mpiSendMessage.getPath(),mpiSendMessage.getFlags(),messageObject);
            if (!receiveAccepted) {
              canProgress=false;
              int attempt=updateAttemptMap(sendMessageInternalAttempts,i,1);
              if (attempt > MAX_ATTEMPTS) {
                LOG.info(String.format(""String_Node_Str"",executor,attempt));
              }
              break;
            }
 else {
              updateAttemptMap(sendMessageInternalAttempts,i,-1);
            }
          }
          if (canProgress) {
            mpiSendMessage.setSendState(MPISendMessage.SendState.SENT_INTERNALLY);
          }
        }
        if (canProgress) {
          if (mpiSendMessage.getExternalSends().size() == 0) {
            pendingSendMessages.poll();
            continue;
          }
          MPISendMessage message=(MPISendMessage)messageSerializer.build(pair.getKey(),mpiSendMessage);
          if (message.serializedState() == MPISendMessage.SendState.SERIALIZED) {
            List<Integer> exRoutes=new ArrayList<>(mpiSendMessage.getExternalSends());
            int startOfExternalRouts=mpiSendMessage.getAcceptedExternalSends();
            int noOfExternalSends=startOfExternalRouts;
            for (int i=startOfExternalRouts; i < exRoutes.size(); i++) {
              boolean sendAccepted=sendMessageToTarget(message.getMPIMessage(),exRoutes.get(i));
              if (!sendAccepted) {
                canProgress=false;
                sendMessageToTargetAttempts++;
                if (sendMessageToTargetAttempts > MAX_ATTEMPTS) {
                  LOG.info(String.format(""String_Node_Str"",executor,sendMessageToTargetAttempts));
                }
                break;
              }
 else {
                if (sendMessageToTargetAttempts > 0) {
                  sendMessageToTargetAttempts--;
                }
                mpiSendMessage.incrementAcceptedExternalSends();
                noOfExternalSends++;
              }
            }
            if (noOfExternalSends == exRoutes.size()) {
              mpiSendMessage.setSendState(MPISendMessage.SendState.FINISHED);
              pendingSendMessages.poll();
            }
          }
 else {
            break;
          }
        }
      }
    }
    for (    Map.Entry<Integer,Queue<MPIMessage>> it : pendingReceiveDeSerializations.entrySet()) {
      MPIMessage currentMessage=it.getValue().poll();
      if (currentMessage == null) {
        continue;
      }
      Object object=messageDeSerializer.build(currentMessage,currentMessage.getHeader().getEdge());
      int id=currentMessage.getOriginatingId();
      Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=pendingReceiveMessagesPerSource.get(id);
      currentMessage.setReceivedState(MPIMessage.ReceivedState.INIT);
      if (pendingReceiveMessages.size() > 0) {
        if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
          throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
        }
      }
 else {
        currentMessage.incrementRefCount();
        currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
        if (!passMessageDownstream(object,currentMessage)) {
          if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
            throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
          }
          continue;
        }
        currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
        if (!receiveMessage(currentMessage,object)) {
          if (!pendingReceiveMessages.offer(new ImmutablePair<>(object,currentMessage))) {
            throw new RuntimeException(executor + ""String_Node_Str"" + pendingReceiveMessages.size());
          }
          int attempt=updateAttemptMap(receiveMessageAttempts,id,1);
          if (attempt > MAX_ATTEMPTS) {
            LOG.info(String.format(""String_Node_Str"",executor,attempt));
          }
          continue;
        }
 else {
          updateAttemptMap(receiveMessageAttempts,id,-1);
        }
        currentMessage.release();
      }
    }
    for (    Map.Entry<Integer,Queue<Pair<Object,MPIMessage>>> e : pendingReceiveMessagesPerSource.entrySet()) {
      Queue<Pair<Object,MPIMessage>> pendingReceiveMessages=e.getValue();
      while (pendingReceiveMessages.size() > 0) {
        Pair<Object,MPIMessage> pair=pendingReceiveMessages.peek();
        MPIMessage.ReceivedState state=pair.getRight().getReceivedState();
        MPIMessage currentMessage=pair.getRight();
        Object object=pair.getLeft();
        if (state == MPIMessage.ReceivedState.INIT) {
          currentMessage.incrementRefCount();
        }
        if (state == MPIMessage.ReceivedState.DOWN || state == MPIMessage.ReceivedState.INIT) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.DOWN);
          if (!passMessageDownstream(object,currentMessage)) {
            break;
          }
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiveMessage(currentMessage,object)) {
            int attempt=updateAttemptMap(receiveMessageAttempts,0,1);
            if (attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            break;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,0,-1);
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
 else         if (state == MPIMessage.ReceivedState.RECEIVE) {
          currentMessage.setReceivedState(MPIMessage.ReceivedState.RECEIVE);
          if (!receiveMessage(currentMessage,object)) {
            int attempt=updateAttemptMap(receiveMessageAttempts,0,1);
            if (attempt > MAX_ATTEMPTS) {
              LOG.info(String.format(""String_Node_Str"",executor,attempt));
            }
            break;
          }
 else {
            updateAttemptMap(receiveMessageAttempts,0,-1);
          }
          currentMessage.release();
          pendingReceiveMessages.poll();
        }
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.878286270691334
173189,"/** 
 * Serialize a message in buffers.
 * @param message
 * @param state
 * @param targetBuffer
 * @return the number of complete messages written
 */
private boolean serializeBufferedMessage(MPIMessage message,SerializeState state,MPIBuffer targetBuffer){
  ByteBuffer targetByteBuffer=targetBuffer.getByteBuffer();
  byte[] tempBytes=new byte[targetBuffer.getCapacity()];
  int targetRemainingSpace=targetByteBuffer.remaining();
  int currentSourceBuffer=state.getBufferNo();
  int bytesCopiedFromSource=state.getBytesCopied();
  int canCopy=0;
  int needsCopy=0;
  List<MPIBuffer> buffers=message.getBuffers();
  MPIBuffer currentMPIBuffer=null;
  int totalBytes=state.getTotalBytes();
  while (targetRemainingSpace > 0 && currentSourceBuffer < buffers.size()) {
    currentMPIBuffer=buffers.get(currentSourceBuffer);
    ByteBuffer currentSourceByteBuffer=currentMPIBuffer.getByteBuffer();
    if (currentSourceBuffer == 0 && bytesCopiedFromSource == 0) {
      bytesCopiedFromSource+=16;
    }
    needsCopy=currentMPIBuffer.getSize() - bytesCopiedFromSource;
    currentSourceByteBuffer.position(bytesCopiedFromSource);
    canCopy=needsCopy > targetRemainingSpace ? targetRemainingSpace : needsCopy;
    currentSourceByteBuffer.get(tempBytes,0,canCopy);
    targetByteBuffer.put(tempBytes,0,canCopy);
    totalBytes+=canCopy;
    targetRemainingSpace-=canCopy;
    bytesCopiedFromSource+=canCopy;
    if (targetRemainingSpace < 6) {
      if (canCopy == needsCopy) {
        currentSourceBuffer++;
        bytesCopiedFromSource=0;
      }
      break;
    }
    currentSourceBuffer++;
    bytesCopiedFromSource=0;
  }
  targetBuffer.setSize(targetByteBuffer.position());
  state.setTotalBytes(totalBytes);
  if (currentSourceBuffer == buffers.size() && currentMPIBuffer != null) {
    state.setBufferNo(0);
    state.setBytesCopied(0);
    return true;
  }
 else {
    state.setBufferNo(currentSourceBuffer);
    state.setBytesCopied(bytesCopiedFromSource);
    return false;
  }
}","/** 
 * Serialize a message in buffers.
 * @param message
 * @param state
 * @param targetBuffer
 * @return the number of complete messages written
 */
private boolean serializeBufferedMessage(MPIMessage message,SerializeState state,MPIBuffer targetBuffer){
  ByteBuffer targetByteBuffer=targetBuffer.getByteBuffer();
  byte[] tempBytes=new byte[targetBuffer.getCapacity()];
  int targetRemainingSpace=targetByteBuffer.remaining();
  int currentSourceBuffer=state.getBufferNo();
  int bytesCopiedFromSource=state.getBytesCopied();
  int canCopy=0;
  int needsCopy=0;
  List<MPIBuffer> buffers=message.getBuffers();
  MPIBuffer currentMPIBuffer=null;
  int totalBytes=state.getTotalBytes();
  while (targetRemainingSpace > 0 && currentSourceBuffer < buffers.size()) {
    currentMPIBuffer=buffers.get(currentSourceBuffer);
    ByteBuffer currentSourceByteBuffer=currentMPIBuffer.getByteBuffer();
    if (currentSourceBuffer == 0 && bytesCopiedFromSource == 0) {
      bytesCopiedFromSource+=16;
    }
    needsCopy=currentMPIBuffer.getSize() - bytesCopiedFromSource;
    currentSourceByteBuffer.position(bytesCopiedFromSource);
    canCopy=needsCopy > targetRemainingSpace ? targetRemainingSpace : needsCopy;
    currentSourceByteBuffer.get(tempBytes,0,canCopy);
    targetByteBuffer.put(tempBytes,0,canCopy);
    totalBytes+=canCopy;
    targetRemainingSpace-=canCopy;
    bytesCopiedFromSource+=canCopy;
    if (targetRemainingSpace < 6) {
      if (canCopy == needsCopy) {
        currentSourceBuffer++;
        bytesCopiedFromSource=0;
      }
      break;
    }
    currentSourceBuffer++;
    bytesCopiedFromSource=0;
  }
  targetBuffer.setSize(targetByteBuffer.position());
  state.setTotalBytes(totalBytes);
  if (currentSourceBuffer == buffers.size() && currentMPIBuffer != null) {
    state.setBufferNo(0);
    state.setBytesCopied(0);
    message.release();
    return true;
  }
 else {
    state.setBufferNo(currentSourceBuffer);
    state.setBytesCopied(bytesCopiedFromSource);
    return false;
  }
}",0.9942514371407148
173190,"@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  if (count == 0) {
    start=System.nanoTime();
  }
  try {
    List<Object> m=messages.get(target).get(source);
    if (messages.get(target) == null) {
      throw new RuntimeException(String.format(""String_Node_Str"",id,target));
    }
    Integer c=counts.get(target).get(source);
    if (m.size() > 128) {
      canAdd=false;
    }
 else {
      m.add(object);
      counts.get(target).put(source,c + 1);
    }
    return canAdd;
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
  return true;
}","@Override public boolean onMessage(int source,int path,int target,int flags,Object object){
  boolean canAdd=true;
  if (count == 0) {
    start=System.nanoTime();
  }
  try {
    List<Object> m=messages.get(target).get(source);
    if (messages.get(target) == null) {
      throw new RuntimeException(String.format(""String_Node_Str"",id,target));
    }
    Integer c=counts.get(target).get(source);
    if (m.size() > 16) {
      canAdd=false;
    }
 else {
      m.add(object);
      counts.get(target).put(source,c + 1);
    }
    return canAdd;
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
  return true;
}",0.9975903614457832
173191,"/** 
 * Generate data with an integer array
 * @return IntData
 */
private IntData generateData(){
  int s=12800;
  int[] d=new int[s];
  for (int i=0; i < s; i++) {
    d[i]=i;
  }
  return new IntData(d);
}","/** 
 * Generate data with an integer array
 * @return IntData
 */
private IntData generateData(){
  int s=128000;
  int[] d=new int[s];
  for (int i=0; i < s; i++) {
    d[i]=i;
  }
  return new IntData(d);
}",0.9976019184652278
173192,"@Override public void run(){
  try {
    LOG.log(Level.INFO,""String_Node_Str"" + id);
    IntData data=generateData();
    for (int i=0; i < 100; i++) {
      while (!aggregate.send(task,data,0)) {
        try {
          Thread.sleep(1);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      if (i % 1000 == 0) {
        LOG.info(String.format(""String_Node_Str"",id,i));
      }
      Thread.yield();
    }
    LOG.info(String.format(""String_Node_Str"",id));
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}","@Override public void run(){
  try {
    LOG.log(Level.INFO,""String_Node_Str"" + id);
    IntData data=generateData();
    for (int i=0; i < 100; i++) {
      while (!aggregate.send(task,data,0)) {
        try {
          Thread.sleep(1);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      if (i % 10 == 0) {
        LOG.info(String.format(""String_Node_Str"",id,i));
      }
      Thread.yield();
    }
    LOG.info(String.format(""String_Node_Str"",id));
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}",0.9982394366197184
173193,"public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,List<Object>> map=messages.get(t);
      Map<Integer,Integer> cMap=counts.get(t);
      boolean found=true;
      Object o=null;
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
 else {
          o=e.getValue().get(0);
        }
      }
      if (found) {
        for (        Map.Entry<Integer,List<Object>> e : map.entrySet()) {
          o=e.getValue().remove(0);
        }
        for (        Map.Entry<Integer,Integer> e : cMap.entrySet()) {
          Integer i=e.getValue();
          cMap.put(e.getKey(),i - 1);
        }
        if (o != null) {
          count++;
          if (count % 1 == 0) {
            LOG.info(String.format(""String_Node_Str"",id,t,count,counts));
          }
          if (count >= 10000) {
            LOG.info(""String_Node_Str"" + (System.nanoTime() - start) / 1000000 + ""String_Node_Str"" + count);
          }
        }
 else {
          LOG.severe(""String_Node_Str"");
        }
      }
    }
  }
}","public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,List<Object>> map=messages.get(t);
      Map<Integer,Integer> cMap=counts.get(t);
      boolean found=true;
      Object o=null;
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
 else {
          o=e.getValue().get(0);
        }
      }
      if (found) {
        for (        Map.Entry<Integer,List<Object>> e : map.entrySet()) {
          o=e.getValue().remove(0);
        }
        for (        Map.Entry<Integer,Integer> e : cMap.entrySet()) {
          Integer i=e.getValue();
          cMap.put(e.getKey(),i - 1);
        }
        if (o != null) {
          count++;
          if (count % 1 == 0) {
            LOG.info(String.format(""String_Node_Str"",id,t,count,counts));
          }
          if (count >= 100) {
            LOG.info(""String_Node_Str"" + (System.nanoTime() - start) / 1000000 + ""String_Node_Str"" + count);
          }
        }
 else {
          LOG.severe(""String_Node_Str"");
        }
      }
    }
  }
}",0.9991610738255032
173194,"public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,List<Object>> map=messages.get(t);
      Map<Integer,Integer> cMap=counts.get(t);
      boolean found=true;
      Object o=null;
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
 else {
          o=e.getValue().get(0);
        }
      }
      if (found) {
        for (        Map.Entry<Integer,List<Object>> e : map.entrySet()) {
          o=e.getValue().remove(0);
        }
        for (        Map.Entry<Integer,Integer> e : cMap.entrySet()) {
          Integer i=e.getValue();
          cMap.put(e.getKey(),i - 1);
        }
        if (o != null) {
          count++;
          if (count % 1 == 0) {
            LOG.info(String.format(""String_Node_Str"",id,t,count,counts));
          }
          if (count >= 100) {
            LOG.info(""String_Node_Str"" + (System.nanoTime() - start) / 1000000 + ""String_Node_Str"" + count);
          }
        }
 else {
          LOG.severe(""String_Node_Str"");
        }
      }
    }
  }
}","public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    while (canProgress) {
      Map<Integer,List<Object>> map=messages.get(t);
      Map<Integer,Integer> cMap=counts.get(t);
      boolean found=true;
      Object o=null;
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        if (e.getValue().size() == 0) {
          found=false;
          canProgress=false;
        }
 else {
          o=e.getValue().get(0);
        }
      }
      if (found) {
        for (        Map.Entry<Integer,List<Object>> e : map.entrySet()) {
          o=e.getValue().remove(0);
        }
        for (        Map.Entry<Integer,Integer> e : cMap.entrySet()) {
          Integer i=e.getValue();
          cMap.put(e.getKey(),i - 1);
        }
        if (o != null) {
          count++;
          if (count % 100 == 0) {
            LOG.info(String.format(""String_Node_Str"",id,t,count,counts));
          }
          if (count >= 100) {
            LOG.info(""String_Node_Str"" + (System.nanoTime() - start) / 1000000 + ""String_Node_Str"" + count);
          }
        }
 else {
          LOG.severe(""String_Node_Str"");
        }
      }
    }
  }
}",0.9991610738255032
173195,"/** 
 * test method for BasicJob write to a file
 * @param basicJob
 */
public static void jobWriteTest(BasicJob basicJob){
  String file=""String_Node_Str"";
  JobUtils.writeJobFile(basicJob.serialize(),file);
}","/** 
 * test method for BasicJob write to a file
 */
public static void jobWriteTest(BasicJob basicJob){
  String file=""String_Node_Str"";
  JobUtils.writeJobFile(basicJob.serialize(),file);
}",0.9526184538653366
173196,"public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    if (done.get(t)) {
      continue;
    }
    while (canProgress) {
      Map<Integer,List<Object>> map=messages.get(t);
      Map<Integer,Boolean> finishedMap=finished.get(t);
      boolean found=true;
      int finishedInputs=0;
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        Boolean f=finishedMap.get(e.getKey());
        if (e.getValue().size() == 0) {
          if (!f) {
            found=false;
            canProgress=false;
          }
        }
        if (f) {
          finishedInputs++;
        }
      }
      if (finishedInputs == map.keySet().size()) {
        done.put(t,true);
      }
      if (found) {
        List<Object> out=new ArrayList<>();
        for (        Map.Entry<Integer,List<Object>> e : map.entrySet()) {
          List<Object> objectList=e.getValue();
          if (objectList.size() > 0) {
            Object object=objectList.get(0);
            if (!(object instanceof MPIMessage)) {
              out.add(new MultiObject(e.getKey(),object));
            }
 else {
              out.add(object);
            }
          }
        }
        if (!operation.sendMessagePartial(t,out,0,MPIContext.FLAGS_MULTI_MSG,operation.getType())) {
          canProgress=false;
        }
      }
    }
  }
}","/** 
 * progress
 */
public void progress(){
  for (  int t : messages.keySet()) {
    boolean canProgress=true;
    if (done.get(t)) {
      continue;
    }
    while (canProgress) {
      Map<Integer,List<Object>> map=messages.get(t);
      Map<Integer,Boolean> finishedMap=finished.get(t);
      boolean found=true;
      int finishedInputs=0;
      for (      Map.Entry<Integer,List<Object>> e : map.entrySet()) {
        Boolean f=finishedMap.get(e.getKey());
        if (e.getValue().size() == 0) {
          if (!f) {
            found=false;
            canProgress=false;
          }
        }
        if (f) {
          finishedInputs++;
        }
      }
      if (finishedInputs == map.keySet().size()) {
        done.put(t,true);
      }
      if (found) {
        List<Object> out=new ArrayList<>();
        for (        Map.Entry<Integer,List<Object>> e : map.entrySet()) {
          List<Object> objectList=e.getValue();
          if (objectList.size() > 0) {
            Object object=objectList.get(0);
            if (!(object instanceof MPIMessage)) {
              out.add(new MultiObject(e.getKey(),object));
            }
 else {
              out.add(object);
            }
          }
        }
        if (!operation.sendMessagePartial(t,out,0,MPIContext.FLAGS_MULTI_MSG,operation.getType())) {
          canProgress=false;
        }
      }
    }
  }
}",0.9923273657289002
173197,"public static Config loadConfig(Map<String,Object> cfg){
  try {
    Class.forName(AuroraClientContext.class.getName());
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
  String twister2Home=System.getProperty(SchedulerContext.TWISTER_2_HOME);
  String configDir=System.getProperty(SchedulerContext.CONFIG_DIR);
  String clusterName=System.getProperty(SchedulerContext.CLUSTER_NAME);
  String jobJar=System.getProperty(SchedulerContext.JOB_FILE);
  Map<String,Object> environmentProperties=JobUtils.readCommandLineOpts();
  if (environmentProperties.containsKey(SchedulerContext.TWISTER_2_HOME)) {
    twister2Home=(String)environmentProperties.get(SchedulerContext.CONFIG_DIR);
  }
  if (environmentProperties.containsKey(SchedulerContext.CONFIG_DIR)) {
    configDir=(String)environmentProperties.get(SchedulerContext.CONFIG_DIR);
  }
  if (environmentProperties.containsKey(SchedulerContext.CLUSTER_NAME)) {
    clusterName=(String)environmentProperties.get(SchedulerContext.CLUSTER_NAME);
  }
  if (environmentProperties.containsKey(SchedulerContext.JOB_FILE)) {
    jobJar=(String)environmentProperties.get(SchedulerContext.JOB_FILE);
  }
  if (configDir == null) {
    configDir=twister2Home + ""String_Node_Str"";
  }
  LOG.log(Level.INFO,String.format(""String_Node_Str"" + ""String_Node_Str"",twister2Home,configDir,clusterName));
  Config config=ConfigLoader.loadConfig(twister2Home,configDir + ""String_Node_Str"" + clusterName);
  return Config.newBuilder().putAll(config).put(MPIContext.TWISTER2_HOME.getKey(),twister2Home).put(MPIContext.TWISTER2_CLUSTER_NAME,clusterName).put(MPIContext.JOB_FILE,jobJar).putAll(environmentProperties).putAll(cfg).build();
}","/** 
 * loadConfig
 * @param cfg
 * @return
 */
public static Config loadConfig(Map<String,Object> cfg){
  try {
    Class.forName(AuroraClientContext.class.getName());
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
  String twister2Home=System.getProperty(SchedulerContext.TWISTER_2_HOME);
  String configDir=System.getProperty(SchedulerContext.CONFIG_DIR);
  String clusterName=System.getProperty(SchedulerContext.CLUSTER_NAME);
  String jobJar=System.getProperty(SchedulerContext.JOB_FILE);
  Map<String,Object> environmentProperties=JobUtils.readCommandLineOpts();
  if (environmentProperties.containsKey(SchedulerContext.TWISTER_2_HOME)) {
    twister2Home=(String)environmentProperties.get(SchedulerContext.CONFIG_DIR);
  }
  if (environmentProperties.containsKey(SchedulerContext.CONFIG_DIR)) {
    configDir=(String)environmentProperties.get(SchedulerContext.CONFIG_DIR);
  }
  if (environmentProperties.containsKey(SchedulerContext.CLUSTER_NAME)) {
    clusterName=(String)environmentProperties.get(SchedulerContext.CLUSTER_NAME);
  }
  if (environmentProperties.containsKey(SchedulerContext.JOB_FILE)) {
    jobJar=(String)environmentProperties.get(SchedulerContext.JOB_FILE);
  }
  if (configDir == null) {
    configDir=twister2Home + ""String_Node_Str"";
  }
  LOG.log(Level.INFO,String.format(""String_Node_Str"" + ""String_Node_Str"",twister2Home,configDir,clusterName));
  Config config=ConfigLoader.loadConfig(twister2Home,configDir + ""String_Node_Str"" + clusterName);
  return Config.newBuilder().putAll(config).put(MPIContext.TWISTER2_HOME.getKey(),twister2Home).put(MPIContext.TWISTER2_CLUSTER_NAME,clusterName).put(MPIContext.JOB_FILE,jobJar).putAll(environmentProperties).putAll(cfg).build();
}",0.9859649122807016
173198,"public AuroraClientController(String cluster,String role,String env,String jobName,boolean isVerbose){
  this.jobSpec=String.format(""String_Node_Str"",cluster,role,env,jobName);
  this.isVerbose=isVerbose;
}","AuroraClientController(String cluster,String role,String env,String jobName,boolean isVerbose){
  this.jobSpec=String.format(""String_Node_Str"",cluster,role,env,jobName);
  this.isVerbose=isVerbose;
}",0.982716049382716
173199,"/** 
 * add new containers to this job
 * @param count
 */
public void addContainers(Integer count){
  List<String> auroraCmd=new ArrayList<>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",jobSpec + ""String_Node_Str"",count.toString()));
  if (isVerbose) {
    auroraCmd.add(""String_Node_Str"");
  }
  LOG.info(String.format(""String_Node_Str"",count,auroraCmd));
  if (!runProcess(auroraCmd)) {
    throw new RuntimeException(""String_Node_Str"" + count + ""String_Node_Str"");
  }
}","/** 
 * add new containers to this job
 */
public void addContainers(Integer count){
  List<String> auroraCmd=new ArrayList<>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",jobSpec + ""String_Node_Str"",count.toString()));
  if (isVerbose) {
    auroraCmd.add(""String_Node_Str"");
  }
  LOG.info(String.format(""String_Node_Str"",count,auroraCmd));
  if (!runProcess(auroraCmd)) {
    throw new RuntimeException(""String_Node_Str"" + count + ""String_Node_Str"");
  }
}",0.9847619047619048
173200,"/** 
 * put relevant config parameters to a HashMap to be used as environment variables when submitting jobs
 * @param config
 * @return
 */
public static Map<AuroraField,String> constructEnvVariables(Config config){
  HashMap<AuroraField,String> envs=new HashMap<AuroraField,String>();
  envs.put(AuroraField.TWISTER2_PACKAGE_PATH,AuroraClientContext.packagePath(config));
  envs.put(AuroraField.TWISTER2_PACKAGE_FILE,AuroraClientContext.packageFile(config));
  envs.put(AuroraField.CLUSTER,AuroraClientContext.cluster(config));
  envs.put(AuroraField.ENVIRONMENT,AuroraClientContext.environment(config));
  envs.put(AuroraField.ROLE,AuroraClientContext.role(config));
  envs.put(AuroraField.AURORA_JOB_NAME,AuroraClientContext.auroraJobName(config));
  envs.put(AuroraField.CPUS_PER_CONTAINER,AuroraClientContext.cpusPerContainer(config));
  envs.put(AuroraField.RAM_PER_CONTAINER,AuroraClientContext.ramPerContainer(config) + ""String_Node_Str"");
  envs.put(AuroraField.DISK_PER_CONTAINER,AuroraClientContext.diskPerContainer(config) + ""String_Node_Str"");
  envs.put(AuroraField.NUMBER_OF_CONTAINERS,AuroraClientContext.numberOfContainers(config));
  return envs;
}","/** 
 * put relevant config parameters to a HashMap to be used as environment variables when submitting jobs
 */
public static Map<AuroraField,String> constructEnvVariables(Config config){
  HashMap<AuroraField,String> envs=new HashMap<AuroraField,String>();
  envs.put(AuroraField.TWISTER2_PACKAGE_PATH,AuroraClientContext.packagePath(config));
  envs.put(AuroraField.TWISTER2_PACKAGE_FILE,AuroraClientContext.packageFile(config));
  envs.put(AuroraField.CLUSTER,AuroraClientContext.cluster(config));
  envs.put(AuroraField.ENVIRONMENT,AuroraClientContext.environment(config));
  envs.put(AuroraField.ROLE,AuroraClientContext.role(config));
  envs.put(AuroraField.AURORA_JOB_NAME,AuroraClientContext.auroraJobName(config));
  envs.put(AuroraField.CPUS_PER_CONTAINER,AuroraClientContext.cpusPerContainer(config));
  envs.put(AuroraField.RAM_PER_CONTAINER,AuroraClientContext.ramPerContainer(config) + ""String_Node_Str"");
  envs.put(AuroraField.DISK_PER_CONTAINER,AuroraClientContext.diskPerContainer(config) + ""String_Node_Str"");
  envs.put(AuroraField.NUMBER_OF_CONTAINERS,AuroraClientContext.numberOfContainers(config));
  return envs;
}",0.9878577623590632
173201,"public static void main(String[] args){
  Options cmdOptions=null;
  try {
    cmdOptions=setupOptions();
    CommandLineParser parser=new DefaultParser();
    CommandLine cmd=parser.parse(cmdOptions,args);
    Config config=loadConfigurations(cmd);
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + config.size());
    System.out.println(config);
    String cluster=AuroraClientContext.cluster(config);
    String role=AuroraClientContext.role(config);
    String env=AuroraClientContext.environment(config);
    String jobName=AuroraClientContext.auroraJobName(config);
    AuroraClientController controller=new AuroraClientController(cluster,role,env,jobName,true);
    String auroraFilename=AuroraClientContext.auroraScript(config);
    Map<AuroraField,String> bindings=constructEnvVariables(config);
    printEnvs(bindings);
    boolean jobSubmitted=controller.createJob(bindings,auroraFilename);
    if (jobSubmitted)     LOG.log(Level.INFO,""String_Node_Str"");
 else     LOG.log(Level.SEVERE,""String_Node_Str"");
  }
 catch (  ParseException e) {
    HelpFormatter formatter=new HelpFormatter();
    formatter.printHelp(""String_Node_Str"",cmdOptions);
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","public static void main(String[] args){
  Options cmdOptions=null;
  try {
    cmdOptions=setupOptions();
    CommandLineParser parser=new DefaultParser();
    CommandLine cmd=parser.parse(cmdOptions,args);
    Config config=loadConfigurations(cmd);
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + config.size());
    System.out.println(config);
    String cluster=AuroraClientContext.cluster(config);
    String role=AuroraClientContext.role(config);
    String env=AuroraClientContext.environment(config);
    String jobName=AuroraClientContext.auroraJobName(config);
    AuroraClientController controller=new AuroraClientController(cluster,role,env,jobName,true);
    String auroraFilename=AuroraClientContext.auroraScript(config);
    Map<AuroraField,String> bindings=constructEnvVariables(config);
    printEnvs(bindings);
    boolean jobSubmitted=controller.createJob(bindings,auroraFilename);
    if (jobSubmitted) {
      LOG.log(Level.INFO,""String_Node_Str"");
    }
 else {
      LOG.log(Level.SEVERE,""String_Node_Str"");
    }
  }
 catch (  ParseException e) {
    HelpFormatter formatter=new HelpFormatter();
    formatter.printHelp(""String_Node_Str"",cmdOptions);
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.9888888888888888
173202,"/** 
 * read config parameters from configuration files all config files are in a single directory
 * @param cmd
 * @return Config object that has values from config files and from command line
 */
private static Config loadConfigurations(CommandLine cmd){
  String twister2Home=cmd.getOptionValue(""String_Node_Str"");
  String configDir=cmd.getOptionValue(""String_Node_Str"");
  String clusterName=cmd.getOptionValue(""String_Node_Str"");
  LOG.log(Level.INFO,String.format(""String_Node_Str"" + ""String_Node_Str"",twister2Home,configDir,clusterName));
  try {
    Class.forName(AuroraClientContext.class.getName());
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
  Config config=ConfigLoader.loadConfig(twister2Home,configDir + ""String_Node_Str"" + clusterName);
  return Config.newBuilder().putAll(config).put(SchedulerContext.TWISTER2_HOME.getKey(),twister2Home).put(SchedulerContext.TWISTER2_CLUSTER_NAME,clusterName).build();
}","/** 
 * read config parameters from configuration files all config files are in a single directory
 * @return Config object that has values from config files and from command line
 */
private static Config loadConfigurations(CommandLine cmd){
  String twister2Home=cmd.getOptionValue(""String_Node_Str"");
  String configDir=cmd.getOptionValue(""String_Node_Str"");
  String clusterName=cmd.getOptionValue(""String_Node_Str"");
  LOG.log(Level.INFO,String.format(""String_Node_Str"" + ""String_Node_Str"",twister2Home,configDir,clusterName));
  try {
    Class.forName(AuroraClientContext.class.getName());
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
  Config config=ConfigLoader.loadConfig(twister2Home,configDir + ""String_Node_Str"" + clusterName);
  return Config.newBuilder().putAll(config).put(SchedulerContext.TWISTER2_HOME.getKey(),twister2Home).put(SchedulerContext.TWISTER2_CLUSTER_NAME,clusterName).build();
}",0.9925690021231424
173203,"/** 
 * print all environment variables for debuging purposes
 * @param envs
 */
public static void printEnvs(Map<AuroraField,String> envs){
  LOG.log(Level.INFO,""String_Node_Str"");
  Set<AuroraField> keys=envs.keySet();
  for (  AuroraField key : keys) {
    System.out.println(key + ""String_Node_Str"" + envs.get(key));
  }
}","/** 
 * print all environment variables for debuging purposes
 */
public static void printEnvs(Map<AuroraField,String> envs){
  LOG.log(Level.INFO,""String_Node_Str"");
  Set<AuroraField> keys=envs.keySet();
  for (  AuroraField key : keys) {
    System.out.println(key + ""String_Node_Str"" + envs.get(key));
  }
}",0.976452119309262
173204,"@Override public void initialize(Config config){
  this.config=config;
  String cluster=AuroraClientContext.cluster(config);
  String role=AuroraClientContext.role(config);
  String env=AuroraClientContext.environment(config);
  String jobName=AuroraClientContext.auroraJobName(config);
  controller=new AuroraClientController(cluster,role,env,jobName,true);
}","@Override public void initialize(Config conf){
  this.config=conf;
  String cluster=AuroraClientContext.cluster(conf);
  String role=AuroraClientContext.role(conf);
  String env=AuroraClientContext.environment(conf);
  String jobName=AuroraClientContext.auroraJobName(conf);
  controller=new AuroraClientController(cluster,role,env,jobName,true);
}",0.9830508474576272
173205,"public IntData(){
}","public IntData(int size){
  int[] d=new int[size];
  for (int i=0; i < size; i++) {
    d[i]=i;
  }
  this.data=d;
}",0.2814814814814815
173206,"public synchronized int read(byte[] b,int off,int len){
  ByteBuffer byteBuffer=getReadBuffer();
  if (byteBuffer == null) {
    return -1;
  }
  if (byteBuffer.remaining() >= 1) {
    int copiedLength=byteBuffer.remaining() > len ? len : byteBuffer.remaining();
    byteBuffer.get(b,off,copiedLength);
    return copiedLength;
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public synchronized int read(byte[] b,int off,int len){
  ByteBuffer byteBuffer=getReadBuffer();
  if (byteBuffer == null) {
    return -1;
  }
  int canCopy=length - copiedBytes;
  if (byteBuffer.remaining() >= 1) {
    int copiedLength=0;
    if (byteBuffer.remaining() > len) {
      copiedLength=len > canCopy ? canCopy : len;
    }
 else {
      copiedLength=byteBuffer.remaining() > canCopy ? canCopy : byteBuffer.remaining();
    }
    byteBuffer.get(b,off,copiedLength);
    copiedBytes+=copiedLength;
    return copiedLength;
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.7767767767767768
173207,"public synchronized void reset(){
}","public synchronized void reset(){
  copiedBytes=0;
  currentBufferIndex=0;
}",0.6306306306306306
173208,"private ByteBuffer getReadBuffer(){
  ByteBuffer byteBuffer=bufs.get(currentBufferIndex).getByteBuffer();
  int pos=byteBuffer.position();
  if (pos >= byteBuffer.limit() - 1) {
    currentBufferIndex++;
    byteBuffer=bufs.get(currentBufferIndex).getByteBuffer();
    byteBuffer.rewind();
    if (currentBufferIndex >= bufs.size()) {
      return null;
    }
  }
  return byteBuffer;
}","private ByteBuffer getReadBuffer(){
  if (copiedBytes >= length) {
    return null;
  }
  ByteBuffer byteBuffer=bufs.get(currentBufferIndex).getByteBuffer();
  int pos=byteBuffer.position();
  if (pos >= byteBuffer.limit() - 1) {
    currentBufferIndex++;
    byteBuffer=bufs.get(currentBufferIndex).getByteBuffer();
    byteBuffer.rewind();
    if (currentBufferIndex >= bufs.size()) {
      return null;
    }
  }
  return byteBuffer;
}",0.9368932038834952
173209,"public synchronized long skip(long n){
  if (n < 0) {
    return 0;
  }
  int skipped=0;
  for (int i=currentBufferIndex; i < bufs.size(); i++) {
    ByteBuffer b=bufs.get(i).getByteBuffer();
    int avail;
    long needSkip=n - skipped;
    int bufPos=b.position();
    avail=b.remaining() - bufPos;
    if (needSkip >= avail) {
      b.position(bufPos + avail);
      currentBufferIndex++;
      skipped+=avail;
    }
 else {
      b.position((int)(bufPos + needSkip));
      skipped+=needSkip;
    }
    if (skipped >= n) {
      break;
    }
  }
  return skipped;
}","public synchronized long skip(long n){
  if (n < 0) {
    return 0;
  }
  int skipped=0;
  for (int i=currentBufferIndex; i < bufs.size(); i++) {
    ByteBuffer b=bufs.get(i).getByteBuffer();
    int avail;
    long needSkip=n - skipped;
    int bufPos=b.position();
    avail=b.remaining() - bufPos;
    int canCopy=length - (copiedBytes + skipped);
    if (needSkip >= avail) {
      avail=canCopy > avail ? avail : canCopy;
      b.position(bufPos + avail);
      currentBufferIndex++;
      skipped+=avail;
      copiedBytes+=skipped;
    }
 else {
      needSkip=canCopy > needSkip ? needSkip : canCopy;
      b.position((int)(bufPos + needSkip));
      skipped+=needSkip;
      copiedBytes+=skipped;
    }
    if (skipped >= n) {
      break;
    }
  }
  return skipped;
}",0.8448403860430587
173210,"@SuppressWarnings(""String_Node_Str"") private void serializeBody(Object object,MPISendMessage sendMessage,MPIBuffer buffer){
  List objectList=(List)object;
  SerializeState state=(SerializeState)sendMessage.getSerializationState();
  int startIndex=state.getCurrentObject();
  int remaining=buffer.getCapacity();
  if (remaining < 6) {
    return;
  }
  ByteBuffer byteBuffer=buffer.getByteBuffer();
  for (int i=startIndex; i < objectList.size(); i++) {
    Object o=objectList.get(i);
    if (o instanceof MPIMessage) {
      MPIMessage mpiMessage=(MPIMessage)o;
      boolean complete=serializeBufferedMessage(mpiMessage,state,buffer);
      if (complete) {
        state.setCurrentObject(startIndex + 1);
      }
    }
 else {
      boolean complete=serializeMessage((MultiObject)o,sendMessage,buffer);
      if (complete) {
        state.setCurrentObject(startIndex + 1);
      }
    }
    remaining=buffer.getByteBuffer().remaining();
    if (!(remaining > 6 && state.getCurrentObject() < objectList.size() - 1)) {
      break;
    }
  }
  if (state.getCurrentObject() == objectList.size()) {
    sendMessage.setSendState(MPISendMessage.SendState.SERIALIZED);
  }
}","@SuppressWarnings(""String_Node_Str"") private void serializeBody(Object object,MPISendMessage sendMessage,MPIBuffer buffer){
  List objectList=(List)object;
  SerializeState state=(SerializeState)sendMessage.getSerializationState();
  int startIndex=state.getCurrentObject();
  int remaining=buffer.getCapacity();
  if (remaining < 6) {
    return;
  }
  for (int i=startIndex; i < objectList.size(); i++) {
    Object o=objectList.get(i);
    if (o instanceof MPIMessage) {
      MPIMessage mpiMessage=(MPIMessage)o;
      boolean complete=serializeBufferedMessage(mpiMessage,state,buffer);
      if (complete) {
        state.setCurrentObject(i + 1);
      }
    }
 else {
      boolean complete=serializeMessage((MultiObject)o,sendMessage,buffer);
      if (complete) {
        state.setCurrentObject(i + 1);
      }
    }
    remaining=buffer.getByteBuffer().remaining();
    if (!(remaining > 6 && state.getCurrentObject() < objectList.size())) {
      break;
    }
  }
  if (state.getCurrentObject() == objectList.size()) {
    sendMessage.setSendState(MPISendMessage.SendState.SERIALIZED);
  }
}",0.5334507042253521
173211,"private MPIMessage serializeObject(Object object,int source){
  MultiObject multiObject=new MultiObject(source,object);
  MultiObject multiObject2=new MultiObject(source,object);
  List<Object> list=new ArrayList<>();
  list.add(multiObject);
  list.add(multiObject2);
  MPIMessage mpiMessage=new MPIMessage(source,MessageType.OBJECT,MPIMessageDirection.OUT,new MessageListener());
  int di=-1;
  MPISendMessage sendMessage=new MPISendMessage(source,mpiMessage,0,di,0,MPIContext.FLAGS_MULTI_MSG,null,null);
  multiMessageSerializer.build(list,sendMessage);
  return mpiMessage;
}","private MPIMessage serializeObject(Object object,int source){
  IntData data1=new IntData(10);
  MultiObject multiObject=new MultiObject(source,data1);
  IntData data2=new IntData(100);
  MultiObject multiObject2=new MultiObject(source,data2);
  List<Object> list=new ArrayList<>();
  list.add(multiObject);
  list.add(multiObject2);
  MPIMessage mpiMessage=new MPIMessage(source,MessageType.OBJECT,MPIMessageDirection.OUT,new MessageListener());
  int di=-1;
  MPISendMessage sendMessage=new MPISendMessage(source,mpiMessage,0,di,0,MPIContext.FLAGS_MULTI_MSG,null,null);
  multiMessageSerializer.build(list,sendMessage);
  return mpiMessage;
}",0.7735077677841373
173212,"@Override public void init(Config config,int id,ResourcePlan resourcePlan){
  Config.Builder builder=new Config.Builder();
  builder.put(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  Config txtFileConf=builder.build();
  Path path=new Path(""String_Node_Str"" + ""String_Node_Str"");
  InputFormat txtInput=new TextInputFormatter(path);
  txtInput.configure(txtFileConf);
  int minSplits=8;
  try {
    InputSplit[] inputSplits=txtInput.createInputSplits(minSplits);
    InputSplitAssigner inputSplitAssigner=txtInput.getInputSplitAssigner(inputSplits);
    Mapper wordCountMapper=new Mapper();
    wordCountMapper.setInputSource(inputSplitAssigner.getNextInputSplit(null,id));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","@Override public void init(Config config,int id,ResourcePlan resourcePlan){
  Config.Builder builder=new Config.Builder();
  builder.put(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  Config txtFileConf=builder.build();
  Path path=new Path(""String_Node_Str"" + ""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") InputFormat txtInput=new TextInputFormatter(path);
  txtInput.configure(txtFileConf);
  int minSplits=8;
  try {
    InputSplit[] inputSplits=txtInput.createInputSplits(minSplits);
    InputSplitAssigner inputSplitAssigner=txtInput.getInputSplitAssigner(inputSplits);
    MapperSource mapperSource=new MapperSource(txtInput,inputSplitAssigner.getNextInputSplit(null,id));
    Mapper wordCountMapper=new Mapper();
    wordCountMapper.setInputSource(mapperSource);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.8751560549313359
173213,"@Override public TV getTaskEdgeSource(TE taskEdge){
  return TypeUtil.uncheckedCast(getIntrusiveTaskEdge(taskEdge).source,vertexTypeDecl);
}","@Override public TV getTaskEdgeSource(TE taskEdge){
  return vertexTypeDecl.uncheckedCast(getIntrusiveTaskEdge(taskEdge).source,vertexTypeDecl);
}",0.958041958041958
173214,"@Override public TV getTaskEdgeTarget(TE taskEdge){
  return TypeUtil.uncheckedCast(getIntrusiveTaskEdge(taskEdge).target,vertexTypeDecl);
}","@Override public TV getTaskEdgeTarget(TE taskEdge){
  return vertexTypeDecl.uncheckedCast(getIntrusiveTaskEdge(taskEdge).target,vertexTypeDecl);
}",0.958041958041958
173215,"public DataflowTaskGraph(TaskEdgeFactory<TV,TE> taskEdgeFactory){
  super(taskEdgeFactory);
}","public DataflowTaskGraph(IDataflowTaskEdgeFactory<TV,TE> taskEdgeFactory){
  super(taskEdgeFactory);
}",0.953846153846154
173216,"public IDataflowTaskGraph<Mapper,DefaultTaskEdge> getTaskGraph(){
  return taskGraph;
}","public IDataflowTaskGraph<Mapper,DefaultDataflowTaskEdge> getTaskGraph(){
  return taskGraph;
}",0.956043956043956
173217,"public void setTaskGraph(IDataflowTaskGraph<Mapper,DefaultTaskEdge> taskGraph){
  this.taskGraph=taskGraph;
}","public void setTaskGraph(IDataflowTaskGraph<Mapper,DefaultDataflowTaskEdge> taskGraph){
  this.taskGraph=taskGraph;
}",0.9646017699115044
173218,"private IntrusiveTaskEdge createIntrusiveTaskEdge(TE taskEdge,TV taskVertex1,TV taskVertex2){
  IntrusiveTaskEdge intrusiveTaskEdge;
  if (taskEdge instanceof IntrusiveTaskEdge) {
    intrusiveTaskEdge=(IntrusiveTaskEdge)taskEdge;
    System.out.println(""String_Node_Str"" + intrusiveTaskEdge);
  }
 else {
    intrusiveTaskEdge=new IntrusiveTaskEdge();
    System.out.println(""String_Node_Str"" + intrusiveTaskEdge);
  }
  return intrusiveTaskEdge;
}","private IntrusiveTaskEdge createIntrusiveTaskEdge(TE taskEdge,TV taskVertex1,TV taskVertex2){
  IntrusiveTaskEdge intrusiveTaskEdge;
  if (taskEdge instanceof IntrusiveTaskEdge) {
    intrusiveTaskEdge=(IntrusiveTaskEdge)taskEdge;
    System.out.println(""String_Node_Str"" + intrusiveTaskEdge);
  }
 else {
    intrusiveTaskEdge=new IntrusiveTaskEdge();
    System.out.println(""String_Node_Str"" + intrusiveTaskEdge);
  }
  intrusiveTaskEdge.source=taskVertex1;
  intrusiveTaskEdge.target=taskVertex2;
  return intrusiveTaskEdge;
}",0.918200408997955
173219,"public CManager(String message){
  this.message=message;
}","protected CManager(String message){
  this.message=message;
}",0.907563025210084
173220,"/** 
 * This method returns the set of incoming task edges for the task vertex 'TV'
 * @param taskVertex
 * @return
 */
Set<TE> incomingTaskEdgesOf(TV taskVertex);","/** 
 * This method returns the set of incoming task edges for the task vertex 'TV'
 */
Set<TE> incomingTaskEdgesOf(TV taskVertex);",0.891156462585034
173221,"/** 
 * This method returns the set of outgoing task edges for the task vertex 'TV'
 * @param taskVertex
 * @return
 */
Set<TE> outgoingTaskEdgesOf(TV taskVertex);","/** 
 * This method returns the set of outgoing task edges for the task vertex 'TV'
 */
Set<TE> outgoingTaskEdgesOf(TV taskVertex);",0.891156462585034
173222,"/** 
 * This method returns the set of outward task edges for the task vertex 'TV'
 * @param taskVertex
 * @return
 */
int outDegreeOf(TV taskVertex);","/** 
 * This method returns the set of outward task edges for the task vertex 'TV'
 */
int outDegreeOf(TV taskVertex);",0.8805970149253731
173223,"/** 
 * This method is responsible for returning the number of inward directed edges for the task vertex 'TV'
 * @param taskVertex
 * @return
 */
int inDegreeOf(TV taskVertex);","/** 
 * This method is responsible for returning the number of inward directed edges for the task vertex 'TV'
 */
int inDegreeOf(TV taskVertex);",0.9
173224,"/** 
 * Create path from given path String
 */
public Path(String pathString){
  pathString=checkAndTrimPathArg(pathString);
  if (hasWindowsDrive(pathString,false)) {
    pathString=""String_Node_Str"" + pathString;
  }
  String scheme=null;
  String authority=null;
  int start=0;
  final int colon=pathString.indexOf(':');
  final int slash=pathString.indexOf('/');
  if ((colon != -1) && ((slash == -1) || (colon < slash))) {
    scheme=pathString.substring(0,colon);
    start=colon + 1;
  }
  if (pathString.startsWith(""String_Node_Str"",start) && (pathString.length() - start > 2)) {
    final int nextSlash=pathString.indexOf('/',start + 2);
    final int authEnd=nextSlash > 0 ? nextSlash : pathString.length();
    authority=pathString.substring(start + 2,authEnd);
    start=authEnd;
  }
  final String path=pathString.substring(start,pathString.length());
  initialize(scheme,authority,path);
}","/** 
 * Create path from given path String
 */
public Path(String pathString){
  String curpathString=checkAndTrimPathArg(pathString);
  if (hasWindowsDrive(curpathString,false)) {
    curpathString=""String_Node_Str"" + curpathString;
  }
  String scheme=null;
  String authority=null;
  int start=0;
  final int colon=curpathString.indexOf(':');
  final int slash=curpathString.indexOf('/');
  if ((colon != -1) && ((slash == -1) || (colon < slash))) {
    scheme=curpathString.substring(0,colon);
    start=colon + 1;
  }
  if (curpathString.startsWith(""String_Node_Str"",start) && (curpathString.length() - start > 2)) {
    final int nextSlash=curpathString.indexOf('/',start + 2);
    final int authEnd=nextSlash > 0 ? nextSlash : curpathString.length();
    authority=curpathString.substring(start + 2,authEnd);
    start=authEnd;
  }
  final String path=curpathString.substring(start,curpathString.length());
  initialize(scheme,authority,path);
}",0.9735849056603774
173225,"private String checkAndTrimPathArg(String path){
  if (path == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  path=path.trim();
  if (path.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return path;
}","private String checkAndTrimPathArg(String path){
  if (path == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String curpath=path.trim();
  if (curpath.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return curpath;
}",0.9702602230483272
173226,"private String normalizePath(String path){
  path=path.trim();
  path=path.replace(""String_Node_Str"",""String_Node_Str"");
  path=path.replaceAll(""String_Node_Str"",""String_Node_Str"");
  if (!path.equals(SEPARATOR) && !path.matches(""String_Node_Str"") && path.endsWith(SEPARATOR)) {
    path=path.substring(0,path.length() - SEPARATOR.length());
  }
  return path;
}","private String normalizePath(String path){
  String curPath=path.trim();
  curPath=curPath.replace(""String_Node_Str"",""String_Node_Str"");
  curPath=curPath.replaceAll(""String_Node_Str"",""String_Node_Str"");
  if (!curPath.equals(SEPARATOR) && !curPath.matches(""String_Node_Str"") && curPath.endsWith(SEPARATOR)) {
    curPath=curPath.substring(0,curPath.length() - SEPARATOR.length());
  }
  return curPath;
}",0.7353324641460235
173227,"public LocatableInputSplit getSplit(){
  return this.split;
}","LocatableInputSplit getSplit(){
  return this.split;
}",0.9391304347826088
173228,"@Override public LocatableInputSplit getNextInputSplit(String host,int taskId){
  if (host == null) {
synchronized (this.remoteSplitChooser) {
synchronized (this.unassigned) {
        LocatableInputSplitWithCount split=this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);
        if (split != null) {
          if (this.unassigned.remove(split)) {
            LOG.info(""String_Node_Str"");
            remoteAssignments++;
            return split.getSplit();
          }
 else {
            throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
          }
        }
 else {
          return null;
        }
      }
    }
  }
  host=host.toLowerCase(Locale.US);
  LocatableInputSplitChooser localSplits=this.localPerHost.get(host);
  if (localSplits == null) {
    localSplits=new LocatableInputSplitChooser();
synchronized (localSplits) {
      LocatableInputSplitChooser prior=this.localPerHost.putIfAbsent(host,localSplits);
      if (prior == null) {
        LocatableInputSplitWithCount[] remaining;
synchronized (this.unassigned) {
          remaining=this.unassigned.toArray(new LocatableInputSplitWithCount[this.unassigned.size()]);
        }
        for (        LocatableInputSplitWithCount isw : remaining) {
          if (isLocal(host,isw.getSplit().getHostnames())) {
            isw.incrementLocalCount();
            localSplits.addInputSplit(isw);
          }
        }
      }
 else {
        localSplits=prior;
      }
    }
  }
synchronized (localSplits) {
synchronized (this.unassigned) {
      LocatableInputSplitWithCount split=localSplits.getNextUnassignedMinLocalCountSplit(this.unassigned);
      if (split != null) {
        if (this.unassigned.remove(split)) {
          LOG.info(""String_Node_Str"" + host);
          localAssignments++;
          return split.getSplit();
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
synchronized (this.remoteSplitChooser) {
synchronized (this.unassigned) {
      LocatableInputSplitWithCount split=this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);
      if (split != null) {
        if (this.unassigned.remove(split)) {
          LOG.info(""String_Node_Str"" + host);
          remoteAssignments++;
          return split.getSplit();
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
 else {
        return null;
      }
    }
  }
}","@Override public LocatableInputSplit getNextInputSplit(String host,int taskId){
  if (host == null) {
synchronized (this.remoteSplitChooser) {
synchronized (this.unassigned) {
        LocatableInputSplitWithCount split=this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);
        if (split != null) {
          if (this.unassigned.remove(split)) {
            LOG.info(""String_Node_Str"");
            remoteAssignments++;
            return split.getSplit();
          }
 else {
            throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
          }
        }
 else {
          return null;
        }
      }
    }
  }
  String curhost=host.toLowerCase(Locale.US);
  LocatableInputSplitChooser localSplits=this.localPerHost.get(curhost);
  if (localSplits == null) {
    localSplits=new LocatableInputSplitChooser();
synchronized (localSplits) {
      LocatableInputSplitChooser prior=this.localPerHost.putIfAbsent(curhost,localSplits);
      if (prior == null) {
        LocatableInputSplitWithCount[] remaining;
synchronized (this.unassigned) {
          remaining=this.unassigned.toArray(new LocatableInputSplitWithCount[this.unassigned.size()]);
        }
        for (        LocatableInputSplitWithCount isw : remaining) {
          if (isLocal(curhost,isw.getSplit().getHostnames())) {
            isw.incrementLocalCount();
            localSplits.addInputSplit(isw);
          }
        }
      }
 else {
        localSplits=prior;
      }
    }
  }
synchronized (localSplits) {
synchronized (this.unassigned) {
      LocatableInputSplitWithCount split=localSplits.getNextUnassignedMinLocalCountSplit(this.unassigned);
      if (split != null) {
        if (this.unassigned.remove(split)) {
          LOG.info(""String_Node_Str"" + host);
          localAssignments++;
          return split.getSplit();
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
synchronized (this.remoteSplitChooser) {
synchronized (this.unassigned) {
      LocatableInputSplitWithCount split=this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);
      if (split != null) {
        if (this.unassigned.remove(split)) {
          LOG.info(""String_Node_Str"" + host);
          remoteAssignments++;
          return split.getSplit();
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
 else {
        return null;
      }
    }
  }
}",0.9962338949454906
173229,"public int getLocalCount(){
  return this.localCount;
}","int getLocalCount(){
  return this.localCount;
}",0.9320388349514565
173230,"public LocatableInputSplitWithCount(LocatableInputSplit split){
  this.split=split;
  this.localCount=0;
}","LocatableInputSplitWithCount(LocatableInputSplit split){
  this.split=split;
  this.localCount=0;
}",0.9658536585365852
173231,"public LocatableInputSplitChooser(Collection<LocatableInputSplitWithCount> splits){
  this.splits=new LinkedList<LocatableInputSplitWithCount>();
  for (  LocatableInputSplitWithCount isw : splits) {
    this.addInputSplit(isw);
  }
}","LocatableInputSplitChooser(Collection<LocatableInputSplitWithCount> splits){
  this.splits=new LinkedList<LocatableInputSplitWithCount>();
  for (  LocatableInputSplitWithCount isw : splits) {
    this.addInputSplit(isw);
  }
}",0.9848156182212582
173232,"public void incrementLocalCount(){
  this.localCount++;
}","void incrementLocalCount(){
  this.localCount++;
}",0.9345794392523364
173233,"private static final boolean isLocal(String flinkHost,String[] hosts){
  if (flinkHost == null || hosts == null) {
    return false;
  }
  for (  String h : hosts) {
    if (h != null && NetUtils.getHostnameFromFQDN(h.toLowerCase()).equals(flinkHost)) {
      return true;
    }
  }
  return false;
}","private static boolean isLocal(String flinkHost,String[] hosts){
  if (flinkHost == null || hosts == null) {
    return false;
  }
  for (  String h : hosts) {
    if (h != null && NetUtils.getHostnameFromFQDN(h.toLowerCase()).equals(flinkHost)) {
      return true;
    }
  }
  return false;
}",0.98989898989899
173234,"private File pathToFile(Path path){
  if (!path.isAbsolute()) {
    path=new Path(getWorkingDirectory(),path);
  }
  return new File(path.toUri().getPath());
}","private File pathToFile(Path path){
  Path curPath=path;
  if (!path.isAbsolute()) {
    curPath=new Path(getWorkingDirectory(),path);
  }
  return new File(curPath.toUri().getPath());
}",0.910144927536232
173235,"@Override public void run(){
}","@Override public void run(){
  if (executableTask == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  LOG.info(String.format(""String_Node_Str"",executableTask.getTaskId(),messageProcessLimit));
  if (isMessageBased) {
    while (!queueRef.isEmpty()) {
      if (messageProcessCount < messageProcessLimit) {
        executableTask.execute(queueRef.poll());
        messageProcessCount++;
      }
 else {
        LOG.info(""String_Node_Str"");
        TaskExecutorFixedThread.executorPool.submit(new RunnableFixedTask(executableTask,queueRef,messageProcessLimit));
        return;
      }
    }
synchronized (ExecutorContext.FIXED_EXECUTOR_LOCK) {
      if (!queueRef.isEmpty()) {
        LOG.info(""String_Node_Str"");
        TaskExecutorFixedThread.executorPool.submit(new RunnableFixedTask(executableTask,queueRef,messageProcessLimit));
      }
 else {
        TaskExecutorFixedThread.removeRunningTask(executableTask.getTaskId());
      }
    }
  }
 else {
    executableTask.execute();
    TaskExecutorFixedThread.removeRunningTask(executableTask.getTaskId());
  }
}",0.054005400540054
173236,"public void setEndianess(ByteOrder endianess){
  if (endianess == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.endianess=endianess;
}","public void setEndianess(ByteOrder order){
  if (endianess == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.endianess=order;
}",0.925925925925926
173237,"public void setBufferSize(int bufferSize){
  if (bufferSize < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.bufferSize=bufferSize;
}","public void setBufferSize(int buffSize){
  if (bufferSize < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.bufferSize=buffSize;
}",0.9874213836477987
173238,"/** 
 * Computes the input splits for the file. By default, one file block is one split. If more splits are requested than blocks are available, then a split may be a fraction of a block and splits may cross block boundaries.
 * @param minNumSplits The minimum desired number of file splits.
 * @return The computed file splits.
 */
@Override public FileInputSplit[] createInputSplits(int minNumSplits) throws IOException {
  if (minNumSplits < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  minNumSplits=Math.max(minNumSplits,this.numSplits);
  final Path path=this.filePath;
  final List<FileInputSplit> inputSplits=new ArrayList<FileInputSplit>(minNumSplits);
  List<FileStatus> files=new ArrayList<FileStatus>();
  long totalLength=0;
  final FileSystem fs=path.getFileSystem();
  final FileStatus pathFile=fs.getFileStatus(path);
  if (pathFile.isDir()) {
    totalLength+=sumFilesInDir(path,files,true);
  }
 else {
    files.add(pathFile);
    totalLength+=pathFile.getLen();
  }
  if (totalLength % this.recordLength != 0)   throw new IllegalStateException(""String_Node_Str"");
  long numberOfRecords=totalLength / this.recordLength;
  long minRecordsForSplit=Math.floorDiv(numberOfRecords,minNumSplits);
  long oddRecords=numberOfRecords % minNumSplits;
  int splitNum=0;
  for (  final FileStatus file : files) {
    final long len=file.getLen();
    final long blockSize=file.getBlockSize();
    final long minSplitSize=minRecordsForSplit * this.recordLength;
    long currentSplitSize=minSplitSize;
    long halfSplit=currentSplitSize >>> 1;
    if (oddRecords > 0) {
      currentSplitSize=currentSplitSize + this.recordLength;
      oddRecords--;
    }
    if (len > 0) {
      final BlockLocation[] blocks=fs.getFileBlockLocations(file,0,len);
      Arrays.sort(blocks);
      long bytesUnassigned=len;
      long position=0;
      int blockIndex=0;
      while (bytesUnassigned >= currentSplitSize) {
        blockIndex=getBlockIndexForPosition(blocks,position,halfSplit,blockIndex);
        FileInputSplit fis=new FileInputSplit(splitNum++,file.getPath(),position,currentSplitSize,blocks[blockIndex].getHosts());
        inputSplits.add(fis);
        position+=currentSplitSize;
        bytesUnassigned-=currentSplitSize;
      }
    }
 else {
      throw new IllegalStateException(""String_Node_Str"" + file.getPath() + ""String_Node_Str"");
    }
  }
  return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);
}","/** 
 * Computes the input splits for the file. By default, one file block is one split. If more splits are requested than blocks are available, then a split may be a fraction of a block and splits may cross block boundaries.
 * @param minNumSplits The minimum desired number of file splits.
 * @return The computed file splits.
 */
@Override public FileInputSplit[] createInputSplits(int minNumSplits) throws IOException {
  if (minNumSplits < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int curminNumSplits=Math.max(minNumSplits,this.numSplits);
  final Path path=this.filePath;
  final List<FileInputSplit> inputSplits=new ArrayList<FileInputSplit>(curminNumSplits);
  List<FileStatus> files=new ArrayList<FileStatus>();
  long totalLength=0;
  final FileSystem fs=path.getFileSystem();
  final FileStatus pathFile=fs.getFileStatus(path);
  if (pathFile.isDir()) {
    totalLength+=sumFilesInDir(path,files,true);
  }
 else {
    files.add(pathFile);
    totalLength+=pathFile.getLen();
  }
  if (totalLength % this.recordLength != 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  long numberOfRecords=totalLength / this.recordLength;
  long minRecordsForSplit=Math.floorDiv(numberOfRecords,minNumSplits);
  long oddRecords=numberOfRecords % minNumSplits;
  int splitNum=0;
  for (  final FileStatus file : files) {
    final long len=file.getLen();
    final long blockSize=file.getBlockSize();
    final long minSplitSize=minRecordsForSplit * this.recordLength;
    long currentSplitSize=minSplitSize;
    long halfSplit=currentSplitSize >>> 1;
    if (oddRecords > 0) {
      currentSplitSize=currentSplitSize + this.recordLength;
      oddRecords--;
    }
    if (len > 0) {
      final BlockLocation[] blocks=fs.getFileBlockLocations(file,0,len);
      Arrays.sort(blocks);
      long bytesUnassigned=len;
      long position=0;
      int blockIndex=0;
      while (bytesUnassigned >= currentSplitSize) {
        blockIndex=getBlockIndexForPosition(blocks,position,halfSplit,blockIndex);
        FileInputSplit fis=new FileInputSplit(splitNum++,file.getPath(),position,currentSplitSize,blocks[blockIndex].getHosts());
        inputSplits.add(fis);
        position+=currentSplitSize;
        bytesUnassigned-=currentSplitSize;
      }
    }
 else {
      throw new IllegalStateException(""String_Node_Str"" + file.getPath() + ""String_Node_Str"");
    }
  }
  return inputSplits.toArray(new FileInputSplit[inputSplits.size()]);
}",0.9963533225283632
173239,"/** 
 * Reads a single record from the binary file
 */
public byte[] readRecord(byte[] reusable,byte[] bytes,int offset,int numBytes) throws IOException {
  if (reusable != null && reusable.length == this.recordLength) {
    System.arraycopy(bytes,offset,reusable,0,numBytes);
    return reusable;
  }
 else {
    byte[] tmp=new byte[this.recordLength];
    System.arraycopy(bytes,offset,tmp,0,numBytes);
    return tmp;
  }
}","/** 
 * Reads a single record from the binary file
 */
public byte[] readRecord(byte[] reusable,byte[] bytes,int readOffset,int numBytes) throws IOException {
  if (reusable != null && reusable.length == this.recordLength) {
    System.arraycopy(bytes,readOffset,reusable,0,numBytes);
    return reusable;
  }
 else {
    byte[] tmp=new byte[this.recordLength];
    System.arraycopy(bytes,readOffset,tmp,0,numBytes);
    return tmp;
  }
}",0.9791666666666666
173240,"/** 
 * Configures this input format by reading the path to the file from the configuration and setting the record length
 * @param parameters The configuration object to read the parameters from.
 */
@Override public void configure(Config parameters){
  super.configure(parameters);
  int recordLength=parameters.getIntegerValue(RECORD_LENGTH,-1);
  if (recordLength > 0) {
    setRecordLength(recordLength);
  }
}","/** 
 * Configures this input format by reading the path to the file from the configuration and setting the record length
 * @param parameters The configuration object to read the parameters from.
 */
@Override public void configure(Config parameters){
  super.configure(parameters);
  int recordLen=parameters.getIntegerValue(RECORD_LENGTH,-1);
  if (recordLen > 0) {
    setRecordLength(recordLen);
  }
}",0.9890377588306942
173241,"public BinaryInputFormatter(Path filePath,int recordLength){
  super(filePath);
  setRecordLength(recordLength);
}","public BinaryInputFormatter(Path filePath,int recordLen){
  super(filePath);
  setRecordLength(recordLen);
}",0.972972972972973
173242,"public void setRecordLength(int recordLength){
  if (recordLength <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.recordLength=recordLength;
  if (this.bufferSize % recordLength != 0) {
    int bufferFactor=1;
    if (this.bufferSize > 0) {
      bufferFactor=bufferSize / recordLength;
    }
 else {
      bufferFactor=DEFAULT_READ_BUFFER_SIZE / recordLength;
    }
    if (bufferFactor >= 1) {
      setBufferSize(recordLength * bufferFactor);
    }
 else {
      setBufferSize(recordLength * 8);
    }
  }
}","public void setRecordLength(int recordLen){
  if (recordLen <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.recordLength=recordLen;
  if (this.bufferSize % recordLen != 0) {
    int bufferFactor=1;
    if (this.bufferSize > 0) {
      bufferFactor=bufferSize / recordLen;
    }
 else {
      bufferFactor=DEFAULT_READ_BUFFER_SIZE / recordLen;
    }
    if (bufferFactor >= 1) {
      setBufferSize(recordLen * bufferFactor);
    }
 else {
      setBufferSize(recordLen * 8);
    }
  }
}",0.8106060606060606
173243,"/** 
 * Fills the read buffer with bytes read from the file starting from an offset.
 */
private boolean fillBuffer(int offset) throws IOException {
  int maxReadLength=this.readBuffer.length - offset;
  if (this.splitLength == FileInputFormat.READ_WHOLE_SPLIT_FLAG) {
    int read=this.stream.read(this.readBuffer,offset,maxReadLength);
    if (read == -1) {
      this.stream.close();
      this.stream=null;
      return false;
    }
 else {
      this.readPos=offset;
      this.limit=read;
      return true;
    }
  }
  int toRead;
  if (this.splitLength > 0) {
    toRead=this.splitLength > maxReadLength ? maxReadLength : (int)this.splitLength;
  }
 else {
    toRead=maxReadLength;
    this.overLimit=true;
    return false;
  }
  int read=this.stream.read(this.readBuffer,offset,toRead);
  if (read == -1) {
    this.stream.close();
    this.stream=null;
    return false;
  }
 else {
    this.splitLength-=read;
    this.readPos=offset;
    this.limit=read + offset;
    return true;
  }
}","/** 
 * Fills the read buffer with bytes read from the file starting from an offset.
 */
private boolean fillBuffer(int fillOffset) throws IOException {
  int maxReadLength=this.readBuffer.length - fillOffset;
  if (this.splitLength == FileInputFormat.READ_WHOLE_SPLIT_FLAG) {
    int read=this.stream.read(this.readBuffer,fillOffset,maxReadLength);
    if (read == -1) {
      this.stream.close();
      this.stream=null;
      return false;
    }
 else {
      this.readPos=fillOffset;
      this.limit=read;
      return true;
    }
  }
  int toRead;
  if (this.splitLength > 0) {
    toRead=this.splitLength > maxReadLength ? maxReadLength : (int)this.splitLength;
  }
 else {
    toRead=maxReadLength;
    this.overLimit=true;
    return false;
  }
  int read=this.stream.read(this.readBuffer,fillOffset,toRead);
  if (read == -1) {
    this.stream.close();
    this.stream=null;
    return false;
  }
 else {
    this.splitLength-=read;
    this.readPos=fillOffset;
    this.limit=read + fillOffset;
    return true;
  }
}",0.9792899408284024
173244,"private void setResult(byte[] buffer,int offset,int len){
  this.currBuffer=buffer;
  this.currOffset=offset;
  this.currLen=len;
}","private void setResult(byte[] buffer,int resultOffset,int len){
  this.currBuffer=buffer;
  this.currOffset=resultOffset;
  this.currLen=len;
}",0.9416058394160584
173245,"/** 
 * This function parses the given byte array which represents a serialized record. The function returns a valid record or throws an IOException.
 * @param reuse An optionally reusable object.
 * @param bytes Binary data of serialized records.
 * @param offset The offset where to start to read the record data.
 * @param numBytes The number of bytes that can be read starting at the offset position.
 * @return Returns the read record if it was successfully deserialized.
 * @throws IOException if the record could not be read.
 */
public abstract OT readRecord(OT reuse,byte[] bytes,int offset,int numBytes) throws IOException ;","/** 
 * This function parses the given byte array which represents a serialized record. The function returns a valid record or throws an IOException.
 * @param reuse An optionally reusable object.
 * @param bytes Binary data of serialized records.
 * @param readOffset The offset where to start to read the record data.
 * @param numBytes The number of bytes that can be read starting at the offset position.
 * @return Returns the read record if it was successfully deserialized.
 * @throws IOException if the record could not be read.
 */
public abstract OT readRecord(OT reuse,byte[] bytes,int readOffset,int numBytes) throws IOException ;",0.9905956112852664
173246,"/** 
 * Fills the read buffer with bytes read from the file starting from an offset.
 */
private boolean fillBuffer(int offset) throws IOException {
  int maxReadLength=this.readBuffer.length - offset;
  if (this.splitLength == FileInputFormat.READ_WHOLE_SPLIT_FLAG) {
    int read=this.stream.read(this.readBuffer,offset,maxReadLength);
    if (read == -1) {
      this.stream.close();
      this.stream=null;
      return false;
    }
 else {
      this.readPos=offset;
      this.limit=read;
      return true;
    }
  }
  int toRead;
  if (this.splitLength > 0) {
    toRead=this.splitLength > maxReadLength ? maxReadLength : (int)this.splitLength;
  }
 else {
    toRead=maxReadLength;
    this.overLimit=true;
  }
  int read=this.stream.read(this.readBuffer,offset,toRead);
  if (read == -1) {
    this.stream.close();
    this.stream=null;
    return false;
  }
 else {
    this.splitLength-=read;
    this.readPos=offset;
    this.limit=read + offset;
    return true;
  }
}","/** 
 * Fills the read buffer with bytes read from the file starting from an offset.
 */
private boolean fillBuffer(int fillOffset) throws IOException {
  int maxReadLength=this.readBuffer.length - fillOffset;
  if (this.splitLength == FileInputFormat.READ_WHOLE_SPLIT_FLAG) {
    int read=this.stream.read(this.readBuffer,fillOffset,maxReadLength);
    if (read == -1) {
      this.stream.close();
      this.stream=null;
      return false;
    }
 else {
      this.readPos=fillOffset;
      this.limit=read;
      return true;
    }
  }
  int toRead;
  if (this.splitLength > 0) {
    toRead=this.splitLength > maxReadLength ? maxReadLength : (int)this.splitLength;
  }
 else {
    toRead=maxReadLength;
    this.overLimit=true;
  }
  int read=this.stream.read(this.readBuffer,fillOffset,toRead);
  if (read == -1) {
    this.stream.close();
    this.stream=null;
    return false;
  }
 else {
    this.splitLength-=read;
    this.readPos=fillOffset;
    this.limit=read + fillOffset;
    return true;
  }
}",0.9789156626506024
173247,"@Override public void execute(){
  LOG.log(Level.INFO,""String_Node_Str"");
  for (int i=0; i < 100000; i++) {
    IntData data=generateData();
    while (getDfop().send(0,data)) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    sendCount++;
    Thread.yield();
  }
  status=Status.MAP_FINISHED;
}","@Override public void execute(){
  LOG.log(Level.INFO,""String_Node_Str"");
  for (int i=0; i < 100000; i++) {
    IntData data=generateData();
    while (!getDfop().send(0,data)) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    sendCount++;
    Thread.yield();
  }
  status=Status.MAP_FINISHED;
}",0.9986824769433466
173248,"/** 
 * Init task executor
 * @param twscom
 * @param dfo
 */
public void init(TWSCommunication twscom,DataFlowOperation dfo){
  this.channel=twscom;
  this.direct=dfo;
  this.progres=true;
}","/** 
 * Init task executor
 */
public void init(TWSCommunication twscom,DataFlowOperation dfo){
  this.channel=twscom;
  this.direct=dfo;
  this.progres=true;
}",0.9116809116809116
173249,"/** 
 * Init's the task thread pool
 * @param corePoolSize
 */
private void initThreadPool(int corePoolSize){
  executorPool=(ThreadPoolExecutor)Executors.newFixedThreadPool(corePoolSize);
}","/** 
 * Init's the task thread pool
 */
private void initThreadPool(int corePoolSize){
  executorPool=(ThreadPoolExecutor)Executors.newFixedThreadPool(corePoolSize);
}",0.9355742296918768
173250,"public boolean registerQueue(int qid,Queue queue){
  queues.put(qid,queue);
  return true;
}","public boolean registerQueue(int qid,Queue<?> queue){
  queues.put(qid,queue);
  return true;
}",0.983957219251337
173251,"private Node buildIntraGroupTree(int groupId,int index){
  Set<Integer> executorsHostingTask=getExecutorsHostingTask(groupId);
  LOG.log(Level.INFO,taskPlan.getThisExecutor() + ""String_Node_Str"" + executorsHostingTask);
  List<Integer> executorIds=rotateList(new ArrayList<>(executorsHostingTask),index);
  LOG.log(Level.INFO,taskPlan.getThisExecutor() + ""String_Node_Str"" + executorIds);
  if (executorIds.size() == 0) {
    return null;
  }
  Collections.sort(executorIds);
  Node rootNode=createTreeeNode(groupId,executorIds.get(0),index);
  Queue<Node> queue=new LinkedList<>();
  Node current=rootNode;
  int i=0;
  while (i < executorIds.size()) {
    if (current.getChildren().size() < intraNodeDegree) {
      Node e=createTreeeNode(groupId,executorIds.get(i),index);
      current.addChild(e);
      e.setParent(current);
      queue.add(e);
      i++;
    }
 else {
      current=queue.poll();
    }
  }
  return rootNode;
}","private Node buildIntraGroupTree(int groupId,int index){
  Set<Integer> executorsHostingTask=getExecutorsHostingTask(groupId);
  List<Integer> executorIds=rotateList(new ArrayList<>(executorsHostingTask),index);
  if (executorIds.size() == 0) {
    return null;
  }
  Collections.sort(executorIds);
  Node rootNode=createTreeeNode(groupId,executorIds.get(0),index);
  Queue<Node> queue=new LinkedList<>();
  Node current=rootNode;
  int i=1;
  while (i < executorIds.size()) {
    if (current.getChildren().size() < intraNodeDegree) {
      Node e=createTreeeNode(groupId,executorIds.get(i),index);
      current.addChild(e);
      e.setParent(current);
      LOG.info(String.format(""String_Node_Str"",taskPlan.getThisExecutor(),e,current));
      queue.add(e);
      i++;
    }
 else {
      current=queue.poll();
    }
  }
  return rootNode;
}",0.3014623172103487
173252,"private Node createTreeeNode(int groupId,int executorId,int rotateIndex){
  Set<Integer> allTasksOfExecutor=taskPlan.getChannelsOfExecutor(executorId);
  if (allTasksOfExecutor == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  Set<Integer> tasksOfExecutor=getTasksInExecutor(executorId);
  if (tasksOfExecutor == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  LOG.info(String.format(""String_Node_Str"",taskPlan.getThisExecutor(),allTasksOfExecutor.toString(),tasksOfExecutor.toString()));
  List<Integer> channelsOfExecutorList=new ArrayList<>(tasksOfExecutor);
  Collections.sort(channelsOfExecutorList);
  channelsOfExecutorList=rotateList(channelsOfExecutorList,rotateIndex);
  int firstTaskId=channelsOfExecutorList.get(0);
  Node node=new Node(firstTaskId,groupId);
  for (int i=1; i < channelsOfExecutorList.size(); i++) {
    node.addDirectChild(channelsOfExecutorList.get(i));
  }
  LOG.info(String.format(""String_Node_Str"",taskPlan.getThisExecutor(),node));
  return node;
}","private Node createTreeeNode(int groupId,int executorId,int rotateIndex){
  Set<Integer> allTasksOfExecutor=taskPlan.getChannelsOfExecutor(executorId);
  if (allTasksOfExecutor == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  Set<Integer> tasksOfExecutor=getTasksInExecutor(executorId);
  if (tasksOfExecutor == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  LOG.info(String.format(""String_Node_Str"",taskPlan.getThisExecutor(),allTasksOfExecutor.toString(),tasksOfExecutor.toString()));
  List<Integer> channelsOfExecutorList=new ArrayList<>(tasksOfExecutor);
  Collections.sort(channelsOfExecutorList);
  channelsOfExecutorList=rotateList(channelsOfExecutorList,rotateIndex);
  int firstTaskId=channelsOfExecutorList.get(0);
  Node node=new Node(firstTaskId,groupId);
  for (int i=1; i < channelsOfExecutorList.size(); i++) {
    node.addDirectChild(channelsOfExecutorList.get(i));
  }
  return node;
}",0.9601634320735444
173253,"/** 
 * Initialize the data structure
 * @param cfg
 * @param plan
 * @param root
 * @param dests
 */
public SingleTargetBinaryTreeRouter(Config cfg,TaskPlan plan,int root,Set<Integer> dests){
  int interNodeDegree=MPIContext.interNodeDegree(cfg,2);
  int intraNodeDegree=MPIContext.intraNodeDegree(cfg,2);
  mainTaskLast=false;
  BinaryTree tree=new BinaryTree(interNodeDegree,intraNodeDegree,plan,root,dests);
  Node treeRoot=tree.buildInterGroupTree(0);
  Set<Integer> thisExecutorTasks=plan.getChannelsOfExecutor(plan.getThisExecutor());
  Set<Integer> thisExecutorTasksOfOperation=new HashSet<>();
  for (  int t : thisExecutorTasks) {
    if (dests.contains(t) || root == t) {
      thisExecutorTasksOfOperation.add(t);
    }
  }
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),thisExecutorTasksOfOperation.toString()));
  this.receiveTasks=new HashMap<Integer,Map<Integer,List<Integer>>>();
  sendExternalTasks=new HashMap<>();
  sendInternalTasks=new HashMap<>();
  receiveExecutors=new HashSet<>();
  for (  int t : thisExecutorTasksOfOperation) {
    List<Integer> recv=new ArrayList<>();
    Node search=BinaryTree.search(treeRoot,t);
    if (search != null) {
      mainTask=search.getTaskId();
      LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),mainTask));
      receiveExecutors.addAll(search.getRemoteChildrenIds());
      recv.addAll(search.getAllChildrenIds());
      Map<Integer,List<Integer>> receivePathMap=new HashMap<>();
      receivePathMap.put(0,new ArrayList<>(recv));
      receiveTasks.put(t,receivePathMap);
      List<Integer> directChildren=search.getDirectChildren();
      for (      int child : directChildren) {
        Map<Integer,Set<Integer>> sendMap=new HashMap<>();
        String log=""String_Node_Str"";
        Set<Integer> sendTasks=new HashSet<>();
        sendTasks.add(t);
        sendMap.put(MPIContext.DEFAULT_PATH,sendTasks);
        log+=String.format(""String_Node_Str"",plan.getThisExecutor(),child,t);
        sendInternalTasks.put(child,sendMap);
        LOG.info(""String_Node_Str"" + log);
      }
      Node parent=search.getParent();
      if (parent != null) {
        Map<Integer,Set<Integer>> mainSendMap=new HashMap<>();
        String log=""String_Node_Str"";
        Set<Integer> sendTasks=new HashSet<>();
        sendTasks.add(parent.getTaskId());
        mainSendMap.put(MPIContext.DEFAULT_PATH,sendTasks);
        log+=String.format(""String_Node_Str"",plan.getThisExecutor(),t,parent.getTaskId());
        sendExternalTasks.put(t,mainSendMap);
        LOG.info(""String_Node_Str"" + log);
      }
 else {
        mainTaskLast=true;
      }
    }
 else {
      LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),t));
    }
  }
}","/** 
 * Initialize the data structure
 * @param cfg
 * @param plan
 * @param root
 * @param dests
 */
public SingleTargetBinaryTreeRouter(Config cfg,TaskPlan plan,int root,Set<Integer> dests){
  int interNodeDegree=MPIContext.interNodeDegree(cfg,2);
  int intraNodeDegree=MPIContext.intraNodeDegree(cfg,2);
  mainTaskLast=false;
  BinaryTree tree=new BinaryTree(interNodeDegree,intraNodeDegree,plan,root,dests);
  Node treeRoot=tree.buildInterGroupTree(0);
  Set<Integer> thisExecutorTasks=plan.getChannelsOfExecutor(plan.getThisExecutor());
  Set<Integer> thisExecutorTasksOfOperation=new HashSet<>();
  for (  int t : thisExecutorTasks) {
    if (dests.contains(t) || root == t) {
      thisExecutorTasksOfOperation.add(t);
    }
  }
  LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),thisExecutorTasksOfOperation.toString()));
  this.receiveTasks=new HashMap<Integer,Map<Integer,List<Integer>>>();
  sendExternalTasks=new HashMap<>();
  sendInternalTasks=new HashMap<>();
  receiveExecutors=new HashSet<>();
  for (  int t : thisExecutorTasksOfOperation) {
    List<Integer> recv=new ArrayList<>();
    Node search=BinaryTree.search(treeRoot,t);
    if (search != null) {
      mainTask=search.getTaskId();
      LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),mainTask));
      for (      int k : search.getRemoteChildrenIds()) {
        receiveExecutors.add(plan.getExecutorForChannel(k));
      }
      recv.addAll(search.getAllChildrenIds());
      Map<Integer,List<Integer>> receivePathMap=new HashMap<>();
      receivePathMap.put(0,new ArrayList<>(recv));
      receiveTasks.put(t,receivePathMap);
      List<Integer> directChildren=search.getDirectChildren();
      for (      int child : directChildren) {
        Map<Integer,Set<Integer>> sendMap=new HashMap<>();
        String log=""String_Node_Str"";
        Set<Integer> sendTasks=new HashSet<>();
        sendTasks.add(t);
        sendMap.put(MPIContext.DEFAULT_PATH,sendTasks);
        log+=String.format(""String_Node_Str"",plan.getThisExecutor(),child,t);
        sendInternalTasks.put(child,sendMap);
        LOG.info(""String_Node_Str"" + log);
      }
      Node parent=search.getParent();
      if (parent != null) {
        Map<Integer,Set<Integer>> mainSendMap=new HashMap<>();
        String log=""String_Node_Str"";
        Set<Integer> sendTasks=new HashSet<>();
        sendTasks.add(parent.getTaskId());
        mainSendMap.put(MPIContext.DEFAULT_PATH,sendTasks);
        log+=String.format(""String_Node_Str"",plan.getThisExecutor(),t,parent.getTaskId());
        sendExternalTasks.put(t,mainSendMap);
        LOG.info(""String_Node_Str"" + log);
      }
 else {
        mainTaskLast=true;
      }
    }
 else {
      LOG.info(String.format(""String_Node_Str"",plan.getThisExecutor(),t));
    }
  }
}",0.9763324299909666
173254,"@Override public void onMessage(int source,int path,int target,Object object){
}","@Override public void onMessage(int source,int path,int target,Object object){
  LOG.info(""String_Node_Str"");
}",0.837696335078534
173255,"public static int receiveBufferCount(Config cfg){
  return cfg.getIntegerValue(RECEIVE_BUFFERS_COUNT,64);
}","public static int receiveBufferCount(Config cfg){
  return cfg.getIntegerValue(RECEIVE_BUFFERS_COUNT,128);
}",0.9767441860465116
173256,"public static int sendBuffersCount(Config cfg){
  return cfg.getIntegerValue(SEND_BUFFERS_COUNT,4);
}","public static int sendBuffersCount(Config cfg){
  return cfg.getIntegerValue(SEND_BUFFERS_COUNT,128);
}",0.9803921568627452
173257,"protected void releaseTheBuffers(int id,MPIMessage message){
  if (MPIMessageDirection.IN == message.getMessageDirection()) {
    List<MPIBuffer> list=receiveBuffers.get(id);
    for (    MPIBuffer buffer : message.getBuffers()) {
      list.add(buffer);
    }
  }
 else   if (MPIMessageDirection.OUT == message.getMessageDirection()) {
    Queue<MPIBuffer> queue=sendBuffers;
    for (    MPIBuffer buffer : message.getBuffers()) {
      queue.offer(buffer);
    }
  }
}","protected void releaseTheBuffers(int id,MPIMessage message){
  if (MPIMessageDirection.IN == message.getMessageDirection()) {
    List<MPIBuffer> list=receiveBuffers.get(id);
    for (    MPIBuffer buffer : message.getBuffers()) {
      buffer.getByteBuffer().reset();
      list.add(buffer);
    }
  }
 else   if (MPIMessageDirection.OUT == message.getMessageDirection()) {
    Queue<MPIBuffer> queue=sendBuffers;
    for (    MPIBuffer buffer : message.getBuffers()) {
      LOG.info(""String_Node_Str"");
      buffer.getByteBuffer().clear();
      queue.offer(buffer);
    }
  }
}",0.8945868945868946
173258,"/** 
 * Send a message to the given rank.
 * @param requests the message
 */
private void postMessage(MPISendRequests requests){
  MPIMessage message=requests.message;
  for (int i=0; i < message.getBuffers().size(); i++) {
    try {
      MPIBuffer buffer=message.getBuffers().get(i);
      LOG.info(String.format(""String_Node_Str"",executor,requests.rank,buffer.getSize()));
      Request request=comm.iSend(buffer.getByteBuffer(),buffer.getSize(),MPI.BYTE,requests.rank,message.getHeader().getEdge());
      requests.pendingSends.add(new MPIRequest(request,buffer));
    }
 catch (    MPIException e) {
      throw new RuntimeException(""String_Node_Str"" + requests.rank);
    }
  }
}","/** 
 * Send a message to the given rank.
 * @param requests the message
 */
private void postMessage(MPISendRequests requests){
  MPIMessage message=requests.message;
  for (int i=0; i < message.getBuffers().size(); i++) {
    try {
      sendCount++;
      MPIBuffer buffer=message.getBuffers().get(i);
      LOG.info(String.format(""String_Node_Str"",executor,requests.rank,buffer.getSize(),sendCount));
      Request request=comm.iSend(buffer.getByteBuffer(),buffer.getSize(),MPI.BYTE,requests.rank,message.getHeader().getEdge());
      requests.pendingSends.add(new MPIRequest(request,buffer));
    }
 catch (    MPIException e) {
      throw new RuntimeException(""String_Node_Str"" + requests.rank);
    }
  }
}",0.9792709077912796
173259,"/** 
 * Send messages to the particular id
 * @param id id to be used for sending messages
 * @param message the message
 * @return true if the message is accepted to be sent
 */
public boolean sendMessage(int id,MPIMessage message,MPIMessageListener callback){
  lock.lock();
  try {
    return pendingSends.offer(new MPISendRequests(id,message.getHeader().getEdge(),message,callback));
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Send messages to the particular id
 * @param id id to be used for sending messages
 * @param message the message
 * @return true if the message is accepted to be sent
 */
public boolean sendMessage(int id,MPIMessage message,MPIMessageListener callback){
  lock.lock();
  try {
    boolean offer=pendingSends.offer(new MPISendRequests(id,message.getHeader().getEdge(),message,callback));
    LOG.info(String.format(""String_Node_Str"",++pendingSendCount,pendingSends.size()));
    return offer;
  }
  finally {
    lock.unlock();
  }
}",0.8698347107438017
173260,"/** 
 * Progress the communications that are pending
 */
public void progress(){
  while (pendingSends.size() > 0) {
    MPISendRequests sendRequests=pendingSends.poll();
    postMessage(sendRequests);
    waitForCompletionSends.add(sendRequests);
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    if (receiveRequests.availableBuffers.size() > 0) {
      LOG.info(String.format(""String_Node_Str"",executor,receiveRequests.rank));
      postReceive(receiveRequests);
    }
  }
  for (int i=0; i < waitForCompletionSends.size(); i++) {
    MPISendRequests sendRequests=waitForCompletionSends.get(i);
    Iterator<MPIRequest> requestIterator=sendRequests.pendingSends.iterator();
    while (requestIterator.hasNext()) {
      MPIRequest r=requestIterator.next();
      try {
        Status status=r.request.testStatus();
        if (status != null) {
          LOG.log(Level.INFO,executor + ""String_Node_Str"");
          requestIterator.remove();
        }
      }
 catch (      MPIException e) {
        throw new RuntimeException(""String_Node_Str"" + sendRequests.rank,e);
      }
    }
    if (sendRequests.pendingSends.size() == 0) {
      sendRequests.callback.onSendComplete(sendRequests.rank,sendRequests.edge,sendRequests.message);
    }
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    try {
      Iterator<MPIRequest> requestIterator=receiveRequests.pendingRequests.iterator();
      while (requestIterator.hasNext()) {
        MPIRequest r=requestIterator.next();
        Status status=r.request.testStatus();
        if (status != null) {
          if (!status.isCancelled()) {
            LOG.log(Level.INFO,executor + ""String_Node_Str"" + status.getCount(MPI.BYTE));
            r.buffer.setSize(status.getCount(MPI.BYTE));
            receiveRequests.callback.onReceiveComplete(receiveRequests.rank,receiveRequests.edge,r.buffer);
            requestIterator.remove();
          }
 else {
            throw new RuntimeException(""String_Node_Str"");
          }
        }
      }
    }
 catch (    MPIException e) {
      LOG.severe(""String_Node_Str"");
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
}","/** 
 * Progress the communications that are pending
 */
public void progress(){
  while (pendingSends.size() > 0) {
    MPISendRequests sendRequests=pendingSends.poll();
    postMessage(sendRequests);
    waitForCompletionSends.add(sendRequests);
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    if (receiveRequests.availableBuffers.size() > 0) {
      LOG.info(String.format(""String_Node_Str"",executor,receiveRequests.rank));
      postReceive(receiveRequests);
    }
  }
  for (int i=0; i < waitForCompletionSends.size(); i++) {
    MPISendRequests sendRequests=waitForCompletionSends.get(i);
    Iterator<MPIRequest> requestIterator=sendRequests.pendingSends.iterator();
    while (requestIterator.hasNext()) {
      MPIRequest r=requestIterator.next();
      try {
        Status status=r.request.testStatus();
        if (status != null) {
          requestIterator.remove();
        }
      }
 catch (      MPIException e) {
        throw new RuntimeException(""String_Node_Str"" + sendRequests.rank,e);
      }
    }
    if (sendRequests.pendingSends.size() == 0) {
      sendRequests.callback.onSendComplete(sendRequests.rank,sendRequests.edge,sendRequests.message);
    }
  }
  for (int i=0; i < registeredReceives.size(); i++) {
    MPIReceiveRequests receiveRequests=registeredReceives.get(i);
    try {
      Iterator<MPIRequest> requestIterator=receiveRequests.pendingRequests.iterator();
      while (requestIterator.hasNext()) {
        MPIRequest r=requestIterator.next();
        Status status=r.request.testStatus();
        if (status != null) {
          if (!status.isCancelled()) {
            r.buffer.setSize(status.getCount(MPI.BYTE));
            receiveRequests.callback.onReceiveComplete(receiveRequests.rank,receiveRequests.edge,r.buffer);
            requestIterator.remove();
          }
 else {
            throw new RuntimeException(""String_Node_Str"");
          }
        }
      }
    }
 catch (    MPIException e) {
      LOG.severe(""String_Node_Str"");
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
}",0.9660326086956522
173261,"/** 
 * Serialized the message into the buffer
 * @param payload
 * @param sendMessage
 * @param buffer
 * @return true if the message is completely written
 */
private void serializeBody(Object payload,MPISendMessage sendMessage,MPIBuffer buffer){
  MessageType type=sendMessage.getMPIMessage().getType();
  LOG.log(Level.INFO,""String_Node_Str"" + type);
switch (type) {
case INTEGER:
    break;
case LONG:
  break;
case DOUBLE:
break;
case OBJECT:
serializeObject(payload,sendMessage,buffer);
break;
case BYTE:
break;
case STRING:
break;
default :
break;
}
}","/** 
 * Serialized the message into the buffer
 * @param payload
 * @param sendMessage
 * @param buffer
 * @return true if the message is completely written
 */
private void serializeBody(Object payload,MPISendMessage sendMessage,MPIBuffer buffer){
  MessageType type=sendMessage.getMPIMessage().getType();
switch (type) {
case INTEGER:
    break;
case LONG:
  break;
case DOUBLE:
break;
case OBJECT:
serializeObject(payload,sendMessage,buffer);
break;
case BYTE:
break;
case STRING:
break;
default :
break;
}
}",0.955140186915888
173262,"@Override public void onMessage(MessageHeader header,Object object){
  LOG.info(""String_Node_Str"");
  count++;
  if (count == 10) {
    status=Status.LOAD_RECEIVE_FINISHED;
  }
}","@Override public void onMessage(MessageHeader header,Object object){
  count++;
  LOG.info(""String_Node_Str"" + count);
  if (count == 10000) {
    status=Status.LOAD_RECEIVE_FINISHED;
  }
}",0.9427792915531336
173263,"@Override public void run(){
  LOG.log(Level.INFO,""String_Node_Str"");
  for (int i=0; i < 10; i++) {
    IntData data=generateData();
    direct.send(0,data);
  }
  status=Status.MAP_FINISHED;
}","@Override public void run(){
  LOG.log(Level.INFO,""String_Node_Str"");
  for (int i=0; i < 10000; i++) {
    IntData data=generateData();
    direct.send(0,data);
    Thread.yield();
  }
  status=Status.MAP_FINISHED;
}",0.9440389294403893
173264,"@Override public Object build(Object message,Object partialBuildObject){
  MPISendMessage sendMessage=(MPISendMessage)partialBuildObject;
  if (sendMessage.getMPIMessage().isComplete()) {
    sendMessage.setSerializedState(MPISendMessage.SerializedState.FINISHED);
    return sendMessage;
  }
  while (sendBuffers.size() > 0 && sendMessage.serializedState() != MPISendMessage.SerializedState.FINISHED) {
    MPIBuffer buffer=sendBuffers.poll();
    if (sendMessage.serializedState() == MPISendMessage.SerializedState.INIT) {
      buildHeader(buffer,sendMessage);
      sendMessage.setSerializedState(MPISendMessage.SerializedState.HEADER_BUILT);
    }
    if (sendMessage.serializedState() == MPISendMessage.SerializedState.HEADER_BUILT) {
      serializeBody(message,sendMessage,buffer);
      sendMessage.setSerializedState(MPISendMessage.SerializedState.BODY);
    }
 else     if (sendMessage.serializedState() == MPISendMessage.SerializedState.BODY) {
      serializeBody(message,sendMessage,buffer);
    }
    sendMessage.getMPIMessage().addBuffer(buffer);
    if (sendMessage.serializedState() == MPISendMessage.SerializedState.FINISHED) {
      MPIMessage mpiMessage=sendMessage.getMPIMessage();
      mpiMessage.setComplete(true);
    }
  }
  return sendMessage;
}","@Override public Object build(Object message,Object partialBuildObject){
  MPISendMessage sendMessage=(MPISendMessage)partialBuildObject;
  if (sendMessage.getMPIMessage().isComplete()) {
    sendMessage.setSerializedState(MPISendMessage.SerializedState.FINISHED);
    return sendMessage;
  }
  while (sendBuffers.size() > 0 && sendMessage.serializedState() != MPISendMessage.SerializedState.FINISHED) {
    MPIBuffer buffer=sendBuffers.poll();
    if (sendMessage.serializedState() == MPISendMessage.SerializedState.INIT) {
      buildHeader(buffer,sendMessage);
      sendMessage.setSerializedState(MPISendMessage.SerializedState.HEADER_BUILT);
    }
    if (sendMessage.serializedState() == MPISendMessage.SerializedState.HEADER_BUILT) {
      serializeBody(message,sendMessage,buffer);
    }
 else     if (sendMessage.serializedState() == MPISendMessage.SerializedState.BODY) {
      serializeBody(message,sendMessage,buffer);
    }
    sendMessage.getMPIMessage().addBuffer(buffer);
    if (sendMessage.serializedState() == MPISendMessage.SerializedState.FINISHED) {
      MPIMessage mpiMessage=sendMessage.getMPIMessage();
      mpiMessage.setComplete(true);
      LOG.info(""String_Node_Str"");
    }
 else {
      LOG.info(""String_Node_Str"");
    }
  }
  return sendMessage;
}",0.8837573385518591
173265,"/** 
 * Serializes a java object using kryo serialization
 * @param object
 * @param sendMessage
 * @param buffer
 */
private void serializeObject(Object object,MPISendMessage sendMessage,MPIBuffer buffer){
  byte[] data;
  int dataPosition;
  ByteBuffer byteBuffer=buffer.getByteBuffer();
  if (sendMessage.serializedState() == MPISendMessage.SerializedState.HEADER_BUILT) {
    data=serializer.serialize(object);
    byteBuffer.putInt(12,data.length);
    MessageHeader.Builder builder=MessageHeader.newBuilder(sendMessage.getSource(),sendMessage.getEdge(),data.length);
    builder.subEdge(sendMessage.getSubEdge());
    sendMessage.getMPIMessage().setHeader(builder.build());
    dataPosition=0;
    sendMessage.setSendBytes(data);
    LOG.log(Level.INFO,String.format(""String_Node_Str"",sendMessage.getSource(),sendMessage.getEdge(),sendMessage.getPath(),data.length));
  }
 else {
    data=sendMessage.getSendBytes();
    dataPosition=sendMessage.getByteCopied();
  }
  LOG.log(Level.INFO,""String_Node_Str"");
  if (grouped && MPISendMessage.SerializedState.BODY == sendMessage.serializedState()) {
    byteBuffer.putInt(sendMessage.getPath());
  }
  int remainingToCopy=data.length - dataPosition;
  int bufferSpace=byteBuffer.capacity() - byteBuffer.position();
  int copyBytes=remainingToCopy > bufferSpace ? bufferSpace : remainingToCopy;
  byteBuffer.put(data,dataPosition,copyBytes);
  sendMessage.setByteCopied(dataPosition + copyBytes);
  buffer.setSize(byteBuffer.position());
  if (copyBytes == remainingToCopy) {
    sendMessage.setSerializedState(MPISendMessage.SerializedState.FINISHED);
  }
}","/** 
 * Serializes a java object using kryo serialization
 * @param object
 * @param sendMessage
 * @param buffer
 */
private void serializeObject(Object object,MPISendMessage sendMessage,MPIBuffer buffer){
  byte[] data;
  int dataPosition;
  ByteBuffer byteBuffer=buffer.getByteBuffer();
  if (sendMessage.serializedState() == MPISendMessage.SerializedState.HEADER_BUILT) {
    data=serializer.serialize(object);
    byteBuffer.putInt(12,data.length);
    MessageHeader.Builder builder=MessageHeader.newBuilder(sendMessage.getSource(),sendMessage.getEdge(),data.length);
    builder.subEdge(sendMessage.getSubEdge());
    sendMessage.getMPIMessage().setHeader(builder.build());
    dataPosition=0;
    sendMessage.setSendBytes(data);
    LOG.log(Level.INFO,String.format(""String_Node_Str"",sendMessage.getSource(),sendMessage.getEdge(),sendMessage.getPath(),data.length));
  }
 else {
    data=sendMessage.getSendBytes();
    dataPosition=sendMessage.getByteCopied();
  }
  if (grouped && MPISendMessage.SerializedState.BODY == sendMessage.serializedState()) {
    byteBuffer.putInt(sendMessage.getPath());
  }
  int remainingToCopy=data.length - dataPosition;
  int bufferSpace=byteBuffer.capacity() - byteBuffer.position();
  int copyBytes=remainingToCopy > bufferSpace ? bufferSpace : remainingToCopy;
  byteBuffer.put(data,dataPosition,copyBytes);
  sendMessage.setByteCopied(dataPosition + copyBytes);
  LOG.log(Level.INFO,String.format(""String_Node_Str"" + ""String_Node_Str"",byteBuffer.position(),copyBytes,remainingToCopy));
  buffer.setSize(byteBuffer.position());
  if (copyBytes == remainingToCopy) {
    sendMessage.setSerializedState(MPISendMessage.SerializedState.FINISHED);
  }
 else {
    sendMessage.setSerializedState(MPISendMessage.SerializedState.BODY);
  }
}",0.7018890200708382
173266,"private void buildHeader(MPIBuffer buffer,MPISendMessage sendMessage){
  if (buffer.getCapacity() < 16) {
    throw new RuntimeException(""String_Node_Str"");
  }
  ByteBuffer byteBuffer=buffer.getByteBuffer();
  byteBuffer.putInt(sendMessage.getSource());
  byteBuffer.putInt(sendMessage.getPath());
  byteBuffer.putInt(sendMessage.getSubEdge());
  byteBuffer.putInt(0);
  sendMessage.setWrittenHeaderSize(16);
  buffer.setSize(16);
}","private void buildHeader(MPIBuffer buffer,MPISendMessage sendMessage){
  if (buffer.getCapacity() < 16) {
    throw new RuntimeException(""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"");
  ByteBuffer byteBuffer=buffer.getByteBuffer();
  byteBuffer.putInt(sendMessage.getSource());
  byteBuffer.putInt(sendMessage.getPath());
  byteBuffer.putInt(sendMessage.getSubEdge());
  byteBuffer.putInt(0);
  sendMessage.setWrittenHeaderSize(16);
  buffer.setSize(16);
}",0.9654403567447044
173267,"@Override protected void routeSendMessage(int src,MPISendMessage message,List<Integer> routes){
  Set<Integer> routing=router.getDownstreamTasks(src);
  if (routing == null) {
    throw new RuntimeException(""String_Node_Str"" + src);
  }
  routes.addAll(routing);
}","@Override protected void routeSendMessage(int src,List<Integer> routes){
  Set<Integer> routing=router.getDownstreamTasks(src);
  if (routing == null) {
    throw new RuntimeException(""String_Node_Str"" + src);
  }
  routes.addAll(routing);
}",0.9544554455445544
173268,"@Override protected void routeSendMessage(int source,MPISendMessage message,List<Integer> routes){
}","@Override protected void routeSendMessage(int source,List<Integer> routes){
}",0.8700564971751412
173269,"@Override public void progress(){
  lock.lock();
  try {
    while (pendingSendMessages.size() > 0) {
      Pair<Object,MPISendMessage> pair=pendingSendMessages.peek();
      MPISendMessage message=(MPISendMessage)messageSerializer.build(pair.getKey(),pair.getValue());
      if (message.serializedState() == MPISendMessage.SerializedState.FINISHED) {
        List<Integer> routes=new ArrayList<>();
        routeSendMessage(message.getSource(),message,routes);
        sendMessage(message.getMPIMessage(),routes);
        pendingSendMessages.remove();
      }
 else {
        break;
      }
    }
  }
  finally {
    lock.unlock();
  }
}","@Override public void progress(){
  lock.lock();
  try {
    while (pendingSendMessages.size() > 0) {
      Pair<Object,MPISendMessage> pair=pendingSendMessages.peek();
      MPISendMessage message=(MPISendMessage)messageSerializer.build(pair.getKey(),pair.getValue());
      if (message.serializedState() == MPISendMessage.SerializedState.FINISHED) {
        List<Integer> routes=new ArrayList<>();
        routeSendMessage(message.getSource(),routes);
        sendMessage(message.getMPIMessage(),routes);
        pendingSendMessages.remove();
      }
 else {
        break;
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.9936908517350158
173270,"protected abstract void routeSendMessage(int source,MPISendMessage message,List<Integer> routes);","protected abstract void routeSendMessage(int source,List<Integer> routes);",0.8654970760233918
173271,"@Override protected void routeSendMessage(int source,MPISendMessage message,List<Integer> routes){
  Set<Integer> routing=router.getDownstreamTasks(source);
  if (routing == null) {
    throw new RuntimeException(""String_Node_Str"" + source);
  }
  routes.addAll(routing);
}","@Override protected void routeSendMessage(int source,List<Integer> routes){
  Set<Integer> routing=router.getDownstreamTasks(source);
  if (routing == null) {
    throw new RuntimeException(""String_Node_Str"" + source);
  }
  routes.addAll(routing);
}",0.9560229445506692
173272,"@Override protected void routeSendMessage(int source,MPISendMessage message,List<Integer> routes){
  Set<Integer> downstreamTasks=router.getDownstreamTasks(source);
  routes.addAll(downstreamTasks);
}","@Override protected void routeSendMessage(int source,List<Integer> routes){
  Set<Integer> downstreamTasks=router.getDownstreamTasks(source);
  routes.addAll(downstreamTasks);
}",0.9389920424403184
173273,"@Override protected void routeSendMessage(int source,MPISendMessage message,List<Integer> routes){
  Set<Integer> routing=router.getDownstreamTasks(source);
}","@Override protected void routeSendMessage(int source,List<Integer> routes){
  Set<Integer> routing=router.getDownstreamTasks(source);
}",0.9215017064846416
173274,"public DirectRouter(TaskPlan plan,Set<Integer> srscs,int dest){
  this.destination=dest;
  this.taskPlan=plan;
  this.downStream=new HashSet<>();
  this.downStream.add(dest);
  this.upstream=new HashMap<>();
  List<Integer> sources=new ArrayList<>();
  sources.addAll(srscs);
  this.upstream.put(0,sources);
  int destinationExecutor=executor(destination);
  receiveExecutors=new HashSet<>();
  if (destinationExecutor == taskPlan.getThisExecutor()) {
    for (    int s : srscs) {
      int e=executor(s);
      if (destinationExecutor != e) {
        receiveExecutors.add(e);
      }
    }
  }
  this.thisExecutorTasks=taskPlan.getChannelsOfExecutor(taskPlan.getThisExecutor());
}","public DirectRouter(TaskPlan plan,Set<Integer> srscs,int dest){
  this.destination=dest;
  this.taskPlan=plan;
  this.downStream=new HashSet<>();
  this.downStream.add(dest);
  this.upstream=new HashMap<>();
  List<Integer> sources=new ArrayList<>();
  sources.addAll(srscs);
  this.upstream.put(0,sources);
  int destinationExecutor=taskPlan.getExecutorForChannel(destination);
  receiveExecutors=new HashSet<>();
  if (destinationExecutor == taskPlan.getThisExecutor()) {
    for (    int s : srscs) {
      int e=taskPlan.getExecutorForChannel(s);
      if (destinationExecutor != e) {
        receiveExecutors.add(e);
      }
    }
  }
  this.thisExecutorTasks=taskPlan.getChannelsOfExecutor(taskPlan.getThisExecutor());
}",0.7769886363636364
173275,"@Override public Set<Integer> getDownstreamTasks(int source){
  return null;
}","@Override public Set<Integer> getDownstreamTasks(int source){
  return downStream;
}",0.925925925925926
173276,"/** 
 * Initialize the data structure
 * @param cfg
 * @param plan
 * @param root
 * @param dests
 * @param strm
 */
public SingleTargetBinaryTreeRouter(Config cfg,TaskPlan plan,int root,Set<Integer> dests,int strm,int distinctRts){
  this.config=cfg;
  this.taskPlan=plan;
  this.sources=root;
  this.destinations=dests;
  this.stream=strm;
  this.distinctRoutes=distinctRts;
  this.interNodeDegree=MPIContext.interNodeDegree(cfg,2);
  this.intraNodeDegree=MPIContext.intraNodeDegree(cfg,2);
  tree=new BinaryTree(interNodeDegree,intraNodeDegree,taskPlan,root,dests);
  treeRoot=tree.buildInterGroupTree(0);
  Set<Integer> thisExecutorTasks=taskPlan.getChannelsOfExecutor(taskPlan.getThisExecutor());
  thisExecutorTasksOfOperation=new HashSet<>();
  for (  int t : thisExecutorTasks) {
    if (dests.contains(t) || root == t) {
      thisExecutorTasksOfOperation.add(t);
    }
  }
  receiveExecutors=new HashSet<>();
  for (  int t : thisExecutorTasksOfOperation) {
    Node search=BinaryTree.search(treeRoot,t);
    if (search == null) {
      continue;
    }
    receiveExecutors.addAll(search.getRemoteChildrenIds());
  }
  this.upstream=new HashMap<>();
  Set<Integer> recv=new HashSet<>();
  for (  int t : thisExecutorTasksOfOperation) {
    Node search=BinaryTree.search(treeRoot,t);
    if (search == null) {
      continue;
    }
    recv.addAll(search.getAllChildrenIds());
  }
  upstream.put(0,new ArrayList<>(recv));
  downStream=new HashSet<>();
}","/** 
 * Initialize the data structure
 * @param cfg
 * @param plan
 * @param root
 * @param dests
 * @param strm
 */
public SingleTargetBinaryTreeRouter(Config cfg,TaskPlan plan,int root,Set<Integer> dests,int strm,int distinctRts){
  this.config=cfg;
  this.taskPlan=plan;
  this.sources=root;
  this.destinations=dests;
  this.stream=strm;
  this.distinctRoutes=distinctRts;
  this.interNodeDegree=MPIContext.interNodeDegree(cfg,2);
  this.intraNodeDegree=MPIContext.intraNodeDegree(cfg,2);
  tree=new BinaryTree(interNodeDegree,intraNodeDegree,taskPlan,root,dests);
  treeRoot=tree.buildInterGroupTree(0);
  Set<Integer> thisExecutorTasks=taskPlan.getChannelsOfExecutor(taskPlan.getThisExecutor());
  thisExecutorTasksOfOperation=new HashSet<>();
  for (  int t : thisExecutorTasks) {
    if (dests.contains(t) || root == t) {
      thisExecutorTasksOfOperation.add(t);
    }
  }
  this.upstream=new HashMap<>();
  Set<Integer> recv=new HashSet<>();
  receiveExecutors=new HashSet<>();
  for (  int t : thisExecutorTasksOfOperation) {
    Node search=BinaryTree.search(treeRoot,t);
    if (search == null) {
      continue;
    }
    receiveExecutors.addAll(search.getRemoteChildrenIds());
    recv.addAll(search.getAllChildrenIds());
  }
  upstream.put(0,new ArrayList<>(recv));
  downStream=new HashSet<>();
}",0.8386167146974063
173277,"@Override public void run(){
  LOG.log(Level.INFO,""String_Node_Str"");
  for (int i=0; i < 100000; i++) {
    IntData data=generateData();
    while (!reduce.send(0,data)) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    sendCount++;
    Thread.yield();
  }
  status=Status.MAP_FINISHED;
}","@Override public void run(){
  LOG.log(Level.INFO,""String_Node_Str"");
  for (int i=0; i < 100000; i++) {
    IntData data=generateData();
    for (int j=0; j < NO_OF_TASKS - 1; j++) {
      while (!reduce.send(j,data)) {
        try {
          Thread.sleep(1);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
    sendCount++;
    Thread.yield();
  }
  status=Status.MAP_FINISHED;
}",0.914004914004914
173278,"public Builder subEdge(int edge){
  header.subEdge=edge;
  return this;
}","public Builder subEdge(int edge){
  header.destinationIdentifier=edge;
  return this;
}",0.8625
173279,"/** 
 * Setup the receives and send sendBuffers
 */
protected void setupCommunication(){
  int maxReceiveBuffers=MPIContext.receiveBufferCount(config);
  int receiveBufferSize=MPIContext.bufferSize(config);
  for (  Integer recv : router.receivingExecutors()) {
    Queue<MPIBuffer> recvList=new LinkedList<>();
    for (int i=0; i < maxReceiveBuffers; i++) {
      recvList.add(new MPIBuffer(receiveBufferSize));
    }
    LOG.info(instancePlan.getThisExecutor() + ""String_Node_Str"" + recv);
    channel.receiveMessage(recv,edge,this,recvList);
    receiveBuffers.put(recv,recvList);
  }
  if (!router.isLast() && this.partialReceiver != null) {
    partialReceiver.init(router.receiveExpectedTaskIds());
  }
 else {
    this.finalReceiver.init(router.receiveExpectedTaskIds());
  }
  int sendBufferSize=MPIContext.bufferSize(config);
  int sendBufferCount=MPIContext.sendBuffersCount(config);
  for (int i=0; i < sendBufferCount; i++) {
    MPIBuffer buffer=new MPIBuffer(sendBufferSize);
    sendBuffers.offer(buffer);
  }
}","/** 
 * Setup the receives and send sendBuffers
 */
protected void setupCommunication(){
  int maxReceiveBuffers=MPIContext.receiveBufferCount(config);
  int receiveBufferSize=MPIContext.bufferSize(config);
  for (  Integer recv : router.receivingExecutors()) {
    Queue<MPIBuffer> recvList=new LinkedList<>();
    for (int i=0; i < maxReceiveBuffers; i++) {
      recvList.add(new MPIBuffer(receiveBufferSize));
    }
    LOG.info(instancePlan.getThisExecutor() + ""String_Node_Str"" + recv);
    channel.receiveMessage(recv,edge,this,recvList);
    receiveBuffers.put(recv,recvList);
  }
  if (this.partialReceiver != null) {
    partialReceiver.init(router.receiveExpectedTaskIds());
  }
 else {
    this.finalReceiver.init(router.receiveExpectedTaskIds());
  }
  int sendBufferSize=MPIContext.bufferSize(config);
  int sendBufferCount=MPIContext.sendBuffersCount(config);
  for (int i=0; i < sendBufferCount; i++) {
    MPIBuffer buffer=new MPIBuffer(sendBufferSize);
    sendBuffers.offer(buffer);
  }
}",0.9901671583087512
173280,"@Override public void onReceiveComplete(int id,int e,MPIBuffer buffer){
  lock.lock();
  try {
    MPIMessage currentMessage=currentMessages.get(id);
    if (currentMessage == null) {
      currentMessage=new MPIMessage(type,MPIMessageDirection.IN,this);
      currentMessages.put(id,currentMessage);
    }
    Object object=messageDeSerializer.buid(buffer,currentMessage,e);
    if (currentMessage.isComplete()) {
      currentMessage.incrementRefCount();
      passMessageDownstream(currentMessage);
      MessageHeader header=currentMessage.getHeader();
      if (!router.isLast() && partialReceiver != null) {
        partialReceiver.onMessage(header,object);
      }
 else {
        finalReceiver.onMessage(header,object);
      }
      currentMessages.remove(id);
      currentMessage.release();
    }
 else {
      LOG.info(""String_Node_Str"");
    }
  }
  finally {
    lock.unlock();
  }
}","@Override public void onReceiveComplete(int id,int e,MPIBuffer buffer){
  lock.lock();
  try {
    MPIMessage currentMessage=currentMessages.get(id);
    if (currentMessage == null) {
      currentMessage=new MPIMessage(type,MPIMessageDirection.IN,this);
      currentMessages.put(id,currentMessage);
    }
    Object object=messageDeSerializer.buid(buffer,currentMessage,e);
    if (currentMessage.isComplete()) {
      currentMessage.incrementRefCount();
      passMessageDownstream(currentMessage);
      receiveMessage(currentMessage,object);
      currentMessages.remove(id);
      currentMessage.release();
    }
 else {
      LOG.info(""String_Node_Str"");
    }
  }
  finally {
    lock.unlock();
  }
}",0.8535825545171339
173281,"@Override public boolean isLast(){
  return false;
}","@Override public boolean isLast(int task){
  return false;
}",0.9285714285714286
173282,"private void calculateRoutingTable(){
  ArrayList<Integer> sourceList=new ArrayList<>(sources);
  Collections.sort(sourceList);
  int routs=Math.min(Math.min(distinctRoutes,sourceList.size()),destinations.size());
  for (int i=0; i < sourceList.size(); i++) {
    int source=sourceList.get(i);
    int index=i % routs;
    Node root=null;
    Node search=tree.search(root,task);
    if (search != null) {
      Routing routing=getRouting(search);
      if (routing != null) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
}","private void calculateRoutingTable(){
  ArrayList<Integer> sourceList=new ArrayList<>(sources);
  Collections.sort(sourceList);
  int routs=Math.min(Math.min(distinctRoutes,sourceList.size()),destinations.size());
  for (int i=0; i < sourceList.size(); i++) {
    int source=sourceList.get(i);
    int index=i % routs;
    Node root=null;
    Node search=BinaryTree.search(root,0);
    if (search != null) {
      Routing routing=getRouting(search);
      if (routing != null) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
}",0.9882139619220308
173283,"@Override public Map<Integer,List<Integer>> receiveExpectedTaskIds(){
  if (isLast()) {
    LOG.info(taskPlan.getThisExecutor() + ""String_Node_Str"" + upstream.get(0));
    return upstream;
  }
  return new HashMap<>();
}","@Override public Map<Integer,List<Integer>> receiveExpectedTaskIds(){
  if (thisExecutorTasks.contains(destination)) {
    LOG.info(taskPlan.getThisExecutor() + ""String_Node_Str"" + upstream.get(0));
    return upstream;
  }
  return new HashMap<>();
}",0.9044585987261148
173284,"@Override public boolean isLast(){
  Set<Integer> tasks=taskPlan.getChannelsOfExecutor(taskPlan.getThisExecutor());
  return tasks.contains(destination);
}","@Override public boolean isLast(int task){
  return thisExecutorTasks.contains(destination);
}",0.6586345381526104
173285,"public DirectRouter(TaskPlan plan,Set<Integer> srscs,int dest){
  this.destination=dest;
  this.taskPlan=plan;
  this.downStream=new HashSet<>();
  this.downStream.add(dest);
  this.upstream=new HashMap<>();
  List<Integer> sources=new ArrayList<>();
  sources.addAll(srscs);
  this.upstream.put(0,sources);
  int destinationExecutor=executor(destination);
  receiveExecutors=new HashSet<>();
  if (destinationExecutor == taskPlan.getThisExecutor()) {
    for (    int s : srscs) {
      int e=executor(s);
      if (destinationExecutor != e) {
        receiveExecutors.add(e);
      }
    }
  }
}","public DirectRouter(TaskPlan plan,Set<Integer> srscs,int dest){
  this.destination=dest;
  this.taskPlan=plan;
  this.downStream=new HashSet<>();
  this.downStream.add(dest);
  this.upstream=new HashMap<>();
  List<Integer> sources=new ArrayList<>();
  sources.addAll(srscs);
  this.upstream.put(0,sources);
  int destinationExecutor=executor(destination);
  receiveExecutors=new HashSet<>();
  if (destinationExecutor == taskPlan.getThisExecutor()) {
    for (    int s : srscs) {
      int e=executor(s);
      if (destinationExecutor != e) {
        receiveExecutors.add(e);
      }
    }
  }
  this.thisExecutorTasks=taskPlan.getChannelsOfExecutor(taskPlan.getThisExecutor());
}",0.9335418295543392
173286,"/** 
 * Is this the final task
 * @return
 */
boolean isLast();","/** 
 * Is this the final task
 * @return
 */
boolean isLast(int task);",0.9402985074626866
173287,"@Override public boolean isLast(){
  return false;
}","@Override public boolean isLast(int task){
  return false;
}",0.9285714285714286
173288,"protected IRouter setupRouting(){
  Set<Integer> sources=new HashSet<>();
  sources.add(source);
  return new BinaryTreeRouter(config,instancePlan,sources,destinations,edge,1);
}","protected void setupRouting(){
  Set<Integer> sources=new HashSet<>();
  sources.add(source);
  router=new BinaryTreeRouter(config,instancePlan,sources,destinations,edge,1);
}",0.9518413597733713
173289,"@Override protected IRouter setupRouting(){
  return null;
}","@Override protected void setupRouting(){
  return;
}",0.875
173290,protected abstract IRouter setupRouting();,protected abstract void setupRouting();,0.8888888888888888
173291,"@Override public void init(Config cfg,MessageType messageType,TaskPlan plan,int graphEdge,MessageReceiver rcvr,MessageReceiver partialRcvr){
  this.config=cfg;
  this.instancePlan=plan;
  this.edge=graphEdge;
  this.finalReceiver=rcvr;
  this.partialReceiver=partialRcvr;
  this.type=messageType;
  this.executor=instancePlan.getThisExecutor();
  int noOfSendBuffers=MPIContext.broadcastBufferCount(config);
  int sendBufferSize=MPIContext.bufferSize(config);
  this.sendBuffers=new ArrayBlockingQueue<MPIBuffer>(noOfSendBuffers);
  for (int i=0; i < noOfSendBuffers; i++) {
    sendBuffers.offer(new MPIBuffer(sendBufferSize));
  }
  this.receiveBuffers=new HashMap<>();
  router=setupRouting();
  pendingSendMessages=new ArrayBlockingQueue<Pair<Object,MPISendMessage>>(MPIContext.sendPendingMax(config,1024));
  setupCommunication();
  initSerializers();
}","@Override public void init(Config cfg,MessageType messageType,TaskPlan plan,int graphEdge,MessageReceiver rcvr,MessageReceiver partialRcvr){
  this.config=cfg;
  this.instancePlan=plan;
  this.edge=graphEdge;
  this.finalReceiver=rcvr;
  this.partialReceiver=partialRcvr;
  this.type=messageType;
  this.executor=instancePlan.getThisExecutor();
  int noOfSendBuffers=MPIContext.broadcastBufferCount(config);
  int sendBufferSize=MPIContext.bufferSize(config);
  this.sendBuffers=new ArrayBlockingQueue<MPIBuffer>(noOfSendBuffers);
  for (int i=0; i < noOfSendBuffers; i++) {
    sendBuffers.offer(new MPIBuffer(sendBufferSize));
  }
  this.receiveBuffers=new HashMap<>();
  setupRouting();
  pendingSendMessages=new ArrayBlockingQueue<Pair<Object,MPISendMessage>>(MPIContext.sendPendingMax(config,1024));
  setupCommunication();
  initSerializers();
}",0.9959040374488004
173292,"protected void receiveMessage(MPIMessage currentMessage,Object object){
  MessageHeader header=currentMessage.getHeader();
  int messageDestId=currentMessage.getHeader().getDestinationIdentifier();
  if (!router.isLast(messageDestId) && partialReceiver != null) {
    partialReceiver.onMessage(header,object);
  }
 else {
    finalReceiver.onMessage(header,object);
  }
}","protected void receiveMessage(MPIMessage currentMessage,Object object){
  MessageHeader header=currentMessage.getHeader();
  int messageDestId=currentMessage.getHeader().getDestinationIdentifier();
  if (!isLast(messageDestId) && partialReceiver != null) {
    partialReceiver.onMessage(header,object);
  }
 else {
    finalReceiver.onMessage(header,object);
  }
}",0.9904761904761904
173293,"/** 
 * Setup the receives and send sendBuffers
 */
protected void setupCommunication(){
  int maxReceiveBuffers=MPIContext.receiveBufferCount(config);
  int receiveBufferSize=MPIContext.bufferSize(config);
  for (  Integer recv : router.receivingExecutors()) {
    Queue<MPIBuffer> recvList=new LinkedList<>();
    for (int i=0; i < maxReceiveBuffers; i++) {
      recvList.add(new MPIBuffer(receiveBufferSize));
    }
    LOG.info(instancePlan.getThisExecutor() + ""String_Node_Str"" + recv);
    channel.receiveMessage(recv,edge,this,recvList);
    receiveBuffers.put(recv,recvList);
  }
  if (this.partialReceiver != null) {
    partialReceiver.init(router.receiveExpectedTaskIds());
  }
 else {
    this.finalReceiver.init(router.receiveExpectedTaskIds());
  }
  int sendBufferSize=MPIContext.bufferSize(config);
  int sendBufferCount=MPIContext.sendBuffersCount(config);
  for (int i=0; i < sendBufferCount; i++) {
    MPIBuffer buffer=new MPIBuffer(sendBufferSize);
    sendBuffers.offer(buffer);
  }
}","/** 
 * Setup the receives and send sendBuffers
 */
protected void setupCommunication(){
  int maxReceiveBuffers=MPIContext.receiveBufferCount(config);
  int receiveBufferSize=MPIContext.bufferSize(config);
  for (  Integer recv : receivingExecutors()) {
    Queue<MPIBuffer> recvList=new LinkedList<>();
    for (int i=0; i < maxReceiveBuffers; i++) {
      recvList.add(new MPIBuffer(receiveBufferSize));
    }
    LOG.info(instancePlan.getThisExecutor() + ""String_Node_Str"" + recv);
    channel.receiveMessage(recv,edge,this,recvList);
    receiveBuffers.put(recv,recvList);
  }
  if (this.partialReceiver != null) {
    partialReceiver.init(receiveExpectedTaskIds());
  }
 else {
    this.finalReceiver.init(receiveExpectedTaskIds());
  }
  int sendBufferSize=MPIContext.bufferSize(config);
  int sendBufferCount=MPIContext.sendBuffersCount(config);
  for (int i=0; i < sendBufferCount; i++) {
    MPIBuffer buffer=new MPIBuffer(sendBufferSize);
    sendBuffers.offer(buffer);
  }
}",0.9894631209232312
173294,"protected void sendMessage(MPIMessage msgObj1,List<Integer> sendIds){
  if (sendIds != null && sendIds.size() > 0) {
    msgObj1.incrementRefCount(sendIds.size());
    for (    int i : sendIds) {
      int e=router.executor(i);
      channel.sendMessage(e,msgObj1,this);
    }
  }
}","protected void sendMessage(MPIMessage msgObj1,List<Integer> sendIds){
  if (sendIds != null && sendIds.size() > 0) {
    msgObj1.incrementRefCount(sendIds.size());
    for (    int i : sendIds) {
      int e=instancePlan.getExecutorForChannel(i);
      channel.sendMessage(e,msgObj1,this);
    }
  }
}",0.9228130360205832
173295,"public IRouter setupRouting(){
  Set<Integer> destinations=new HashSet<>();
  destinations.add(destination);
  return new BinaryTreeRouter(config,instancePlan,destinations,sources,edge,1);
}","public void setupRouting(){
  Set<Integer> destinations=new HashSet<>();
  destinations.add(destination);
  this.router=new BinaryTreeRouter(config,instancePlan,destinations,sources,edge,1);
}",0.9424083769633508
173296,"@Override protected void receiveMessage(MPIMessage currentMessage,Object object){
  super.receiveMessage(currentMessage,object);
}","@Override protected void receiveMessage(MPIMessage currentMessage,Object object){
  MessageHeader header=currentMessage.getHeader();
  int messageDestId=currentMessage.getHeader().getDestinationIdentifier();
  if (!isLast(messageDestId) && partialReceiver != null) {
    partialReceiver.onMessage(header,object);
  }
 else {
    finalReceiver.onMessage(header,object);
  }
}",0.3888888888888889
173297,"@Override protected IRouter setupRouting(){
  return new DirectRouter(instancePlan,sources,destination);
}","@Override protected void setupRouting(){
  this.router=new DirectRouter(instancePlan,sources,destination);
}",0.897196261682243
173298,"protected IRouter setupRouting(){
  return new LoadBalanceRouter(config,instancePlan,sources,destinations,edge,MPIContext.distinctRoutes(config,sources.size()));
}","protected void setupRouting(){
  this.router=new LoadBalanceRouter(config,instancePlan,sources,destinations,edge,MPIContext.distinctRoutes(config,sources.size()));
}",0.9329268292682928
173299,"private static ResourcePlan createResourcePlan(Config config){
  ResourcePlan resourcePlan=new ResourcePlan(SlurmMPIContext.clusterName(config));
  try {
    String processName=MPI.getProcessorName();
    char[] processNameChars=new char[processName.length()];
    int length=processNameChars.length;
    processName.getChars(0,length,processNameChars,0);
    IntBuffer countSend=MPI.newIntBuffer(1);
    int worldSize=MPI.COMM_WORLD.getSize();
    IntBuffer countReceive=MPI.newIntBuffer(worldSize);
    countSend.put(length);
    MPI.COMM_WORLD.allGather(countSend,1,MPI.INT,countReceive,MPI.COMM_WORLD.getSize(),MPI.INT);
    int[] receiveSizes=new int[worldSize];
    int[] displacements=new int[worldSize];
    int sum=0;
    for (int i=0; i < worldSize; i++) {
      receiveSizes[i]=countReceive.get(i);
      displacements[i]=sum;
      sum+=receiveSizes[i];
    }
    MPI.COMM_WORLD.allGather(countSend,1,MPI.INT,countReceive,worldSize,MPI.INT);
    CharBuffer sendBuffer=MPI.newCharBuffer(length);
    CharBuffer receiveBuffer=MPI.newCharBuffer(countReceive.get());
    sendBuffer.append(processName);
    MPI.COMM_WORLD.allGatherv(sendBuffer,length,MPI.CHAR,receiveBuffer,receiveSizes,displacements,MPI.CHAR);
    Map<Integer,String> processNames=new HashMap<>();
    for (int i=0; i < receiveSizes.length; i++) {
      char[] c=new char[receiveSizes[i]];
      receiveBuffer.get(c);
      processNames.put(i,new String(c));
      LOG.info(String.format(""String_Node_Str"",i,processNames.get(i)));
    }
    addContainers(config,resourcePlan,processNames);
  }
 catch (  MPIException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return resourcePlan;
}","private static ResourcePlan createResourcePlan(Config config){
  try {
    ResourcePlan resourcePlan=new ResourcePlan(SlurmMPIContext.clusterName(config),MPI.COMM_WORLD.getRank());
    String processName=MPI.getProcessorName();
    char[] processNameChars=new char[processName.length()];
    int length=processNameChars.length;
    processName.getChars(0,length,processNameChars,0);
    IntBuffer countSend=MPI.newIntBuffer(1);
    int worldSize=MPI.COMM_WORLD.getSize();
    IntBuffer countReceive=MPI.newIntBuffer(worldSize);
    countSend.put(length);
    MPI.COMM_WORLD.allGather(countSend,1,MPI.INT,countReceive,MPI.COMM_WORLD.getSize(),MPI.INT);
    int[] receiveSizes=new int[worldSize];
    int[] displacements=new int[worldSize];
    int sum=0;
    for (int i=0; i < worldSize; i++) {
      receiveSizes[i]=countReceive.get(i);
      displacements[i]=sum;
      sum+=receiveSizes[i];
    }
    MPI.COMM_WORLD.allGather(countSend,1,MPI.INT,countReceive,worldSize,MPI.INT);
    CharBuffer sendBuffer=MPI.newCharBuffer(length);
    CharBuffer receiveBuffer=MPI.newCharBuffer(countReceive.get());
    sendBuffer.append(processName);
    MPI.COMM_WORLD.allGatherv(sendBuffer,length,MPI.CHAR,receiveBuffer,receiveSizes,displacements,MPI.CHAR);
    Map<Integer,String> processNames=new HashMap<>();
    for (int i=0; i < receiveSizes.length; i++) {
      char[] c=new char[receiveSizes[i]];
      receiveBuffer.get(c);
      processNames.put(i,new String(c));
      LOG.info(String.format(""String_Node_Str"",i,processNames.get(i)));
    }
    addContainers(config,resourcePlan,processNames);
    return resourcePlan;
  }
 catch (  MPIException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.4871567759078831
173300,"/** 
 * Initialize the data flow communication
 * @param config the network configuration
 * @param instancePlan instance plan
 */
void init(Config config,int thisTask,TaskPlan instancePlan,Set<Integer> sources,Set<Integer> destinations,int stream,MessageReceiver receiver,MessageDeSerializer messageDeSerializer,MessageSerializer messageSerializer);","/** 
 * Initialize the data flow communication
 * @param config the network configuration
 * @param instancePlan instance plan
 */
void init(Config config,int thisTask,TaskPlan instancePlan,Set<Integer> sources,Set<Integer> destinations,int stream,MessageReceiver receiver,MessageDeSerializer messageDeSerializer,MessageSerializer messageSerializer,MessageReceiver partialReceiver);",0.9562841530054644
173301,"/** 
 * Indicate that a partial broadcast is finished
 */
void finish();","/** 
 * Indicate that a partial operation is finished
 */
void finish();",0.9027777777777778
173302,"private void set(int sourceId,int destId,int edge,int length,int lastNode){
  this.sourceId=sourceId;
  this.destId=destId;
  this.edge=edge;
  this.length=length;
  this.lastNode=lastNode;
}","private void set(int srcId,int dstId,int e,int l,int lNode){
  this.sourceId=srcId;
  this.destId=dstId;
  this.edge=e;
  this.length=l;
  this.lastNode=lNode;
}",0.9147727272727272
173303,"public static Builder newBuilder(int sourceId,int destId,int edge,int length,int lastNode){
  return new Builder(sourceId,destId,edge,length,lastNode);
}","public static Builder newBuilder(int srcId,int dstId,int e,int l,int lNode){
  return new Builder(srcId,dstId,e,l,lNode);
}",0.8913043478260869
173304,"public Builder reInit(int sourceId,int destId,int edge,int length,int lastNode){
  header.set(sourceId,destId,edge,length,lastNode);
  header.properties.clear();
  return this;
}","public Builder reInit(int sourceId,int destId,int edge,int length,int lastNode){
  header.set(sourceId,destId,edge,length,lastNode);
  header.subNodeDestingation=false;
  header.subNodeOrigin=false;
  header.properties.clear();
  return this;
}",0.8436018957345972
173305,"private MessageHeader(int sourceId,int destId,int edge,int length,int lastNode){
  this.sourceId=sourceId;
  this.destId=destId;
  this.edge=edge;
  this.length=length;
  this.lastNode=lastNode;
}","private MessageHeader(int srcId,int dstId,int e,int l,int lNode){
  this.sourceId=srcId;
  this.destId=dstId;
  this.edge=e;
  this.length=l;
  this.lastNode=lNode;
}",0.9171270718232044
173306,"@Override public void init(Config config,TaskPlan taskPlan){
  this.instancePlan=taskPlan;
  this.config=config;
}","@Override public void init(Config cfg,TaskPlan taskPlan){
  this.instancePlan=taskPlan;
  this.config=cfg;
}",0.972972972972973
173307,"public DataFlowOperation setUpDataFlowOperation(Operation operation,int task,Set<Integer> sources,Set<Integer> destinations,Map<String,Object> configuration,int stream,MessageReceiver receiver,MessageDeSerializer formatter,MessageSerializer builder){
  Config mergedCfg=Config.newBuilder().putAll(config).putAll(configuration).build();
  DataFlowOperation dataFlowOperation=create(operation);
  dataFlowOperation.init(mergedCfg,task,instancePlan,sources,destinations,stream,receiver,formatter,builder);
  return dataFlowOperation;
}","public DataFlowOperation setUpDataFlowOperation(Operation operation,int task,Set<Integer> sources,Set<Integer> destinations,Map<String,Object> configuration,int stream,MessageReceiver receiver,MessageDeSerializer formatter,MessageSerializer builder,MessageReceiver partialReceiver){
  Config mergedCfg=Config.newBuilder().putAll(config).putAll(configuration).build();
  DataFlowOperation dataFlowOperation=create(operation);
  dataFlowOperation.init(mergedCfg,task,instancePlan,sources,destinations,stream,receiver,formatter,builder,partialReceiver);
  return dataFlowOperation;
}",0.9568345323741008
173308,"DataFlowOperation setUpDataFlowOperation(Operation operation,int task,Set<Integer> sources,Set<Integer> destinations,Map<String,Object> configuration,int stream,MessageReceiver receiver,MessageDeSerializer formatter,MessageSerializer builder);","DataFlowOperation setUpDataFlowOperation(Operation operation,int task,Set<Integer> sources,Set<Integer> destinations,Map<String,Object> configuration,int stream,MessageReceiver receiver,MessageDeSerializer formatter,MessageSerializer builder,MessageReceiver partialReceiver);",0.9382239382239382
173309,"@Override public void init(Config config,int thisTask,TaskPlan instancePlan,Set<Integer> sources,Set<Integer> destinations,int stream,MessageReceiver receiver,MessageDeSerializer messageDeSerializer,MessageSerializer messageSerializer){
}","@Override public void init(Config config,int thisTask,TaskPlan instancePlan,Set<Integer> sources,Set<Integer> destinations,int stream,MessageReceiver receiver,MessageDeSerializer messageDeSerializer,MessageSerializer messageSerializer,MessageReceiver partialRcvr){
}",0.9444444444444444
173310,"@Override public void init(Config cfg,int task,TaskPlan plan,Set<Integer> srcs,Set<Integer> dests,int messageStream,MessageReceiver rcvr,MessageDeSerializer fmtr,MessageSerializer bldr){
  super.init(cfg,task,plan,srcs,dests,messageStream,rcvr,fmtr,bldr);
  for (  Integer source : expectedRoutes.keySet()) {
    currentMessages.put(source,new HashMap<Integer,MPIMessage>());
  }
}","@Override public void init(Config cfg,int task,TaskPlan plan,Set<Integer> srcs,Set<Integer> dests,int messageStream,MessageReceiver rcvr,MessageDeSerializer fmtr,MessageSerializer bldr,MessageReceiver partialRcvr){
  super.init(cfg,task,plan,srcs,dests,messageStream,rcvr,fmtr,bldr,partialRcvr);
  for (  Integer source : expectedRoutes.keySet()) {
    currentMessages.put(source,new HashMap<Integer,MPIMessage>());
  }
}",0.9501246882793016
173311,"@Override public void init(Config config,TaskPlan taskPlan){
  super.init(config,taskPlan);
  channel=new TWSMPIChannel(config,MPI.COMM_WORLD);
}","@Override public void init(Config cfg,TaskPlan taskPlan){
  super.init(cfg,taskPlan);
  channel=new TWSMPIChannel(cfg,MPI.COMM_WORLD);
}",0.9679715302491104
173312,"@Override public DataFlowOperation create(Operation operation){
  if (operation == Operation.BROADCAST) {
    return new MPIDataFlowBroadcast(channel);
  }
 else   if (operation == Operation.REDUCE) {
    return new MPIDataFlowReduce(channel);
  }
 else   if (operation == Operation.ALLGATHER) {
    return null;
  }
 else   if (operation == Operation.LOADBALANCE) {
    return new MPILoadBalance(channel);
  }
 else   if (operation == Operation.PARTITION) {
    return new MPIPartition();
  }
  return null;
}","@Override public DataFlowOperation create(Operation operation){
  if (operation == Operation.BROADCAST) {
    return new MPIDataFlowBroadcast(channel);
  }
 else   if (operation == Operation.REDUCE) {
    return new MPIDataFlowReduce(channel);
  }
 else   if (operation == Operation.ALLGATHER) {
    return null;
  }
 else   if (operation == Operation.LOADBALANCE) {
    return new MPILoadBalance(channel);
  }
 else   if (operation == Operation.PARTITION) {
    return new MPIPartition(channel);
  }
  return null;
}",0.9931840311587148
173313,"@Override public void init(Config cfg,int task,TaskPlan plan,Set<Integer> srcs,Set<Integer> dests,int messageStream,MessageReceiver rcvr,MessageDeSerializer fmtr,MessageSerializer bldr){
  this.config=cfg;
  this.instancePlan=plan;
  this.sources=srcs;
  this.destinations=dests;
  this.stream=messageStream;
  this.messageDeSerializer=fmtr;
  this.messageSerializer=bldr;
  this.receiver=rcvr;
  this.sendBuffers=new LinkedList<>();
  this.thisTask=task;
  int noOfSendBuffers=MPIContext.broadcastBufferCount(config);
  int sendBufferSize=MPIContext.bufferSize(config);
  for (int i=0; i < noOfSendBuffers; i++) {
    sendBuffers.offer(new MPIBuffer(sendBufferSize));
  }
  router=setupRouting();
  this.expectedRoutes=router.expectedRoutes();
  setupCommunication();
}","@Override public void init(Config cfg,int task,TaskPlan plan,Set<Integer> srcs,Set<Integer> dests,int messageStream,MessageReceiver rcvr,MessageDeSerializer fmtr,MessageSerializer bldr,MessageReceiver partialRcvr){
  this.config=cfg;
  this.instancePlan=plan;
  this.sources=srcs;
  this.destinations=dests;
  this.stream=messageStream;
  this.messageDeSerializer=fmtr;
  this.messageSerializer=bldr;
  this.receiver=rcvr;
  this.sendBuffers=new LinkedList<>();
  this.thisTask=task;
  this.partialReceiver=partialRcvr;
  int noOfSendBuffers=MPIContext.broadcastBufferCount(config);
  int sendBufferSize=MPIContext.bufferSize(config);
  for (int i=0; i < noOfSendBuffers; i++) {
    sendBuffers.offer(new MPIBuffer(sendBufferSize));
  }
  router=setupRouting();
  this.expectedRoutes=router.expectedRoutes();
  setupCommunication();
}",0.9600997506234414
173314,"@Override public int hashCode(){
  int result=containerId;
  result=31 * result + (taskInstancePlan != null ? taskInstancePlan.hashCode() : 0);
  result=31 * result + (requiredresource != null ? requiredresource.hashCode() : 0);
  result=31 * result + (scheduledresource != null ? scheduledresource.hashCode() : 0);
  return result;
}","@Override public int hashCode(){
  int result=containerId;
  result=31 * result + (taskInstancePlan != null ? taskInstancePlan.hashCode() : 0);
  result=31 * result + (requiredResource != null ? requiredResource.hashCode() : 0);
  result=31 * result + (scheduledResource != null ? scheduledResource.hashCode() : 0);
  return result;
}",0.9880239520958084
173315,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (!(o instanceof ContainerPlan))   return false;
  ContainerPlan that=(ContainerPlan)o;
  if (containerId != that.containerId)   return false;
  if (taskInstancePlan != null ? !taskInstancePlan.equals(that.taskInstancePlan) : that.taskInstancePlan != null)   return false;
  return (requiredresource != null ? requiredresource.equals(that.requiredresource) : that.requiredresource == null) && (scheduledresource != null ? scheduledresource.equals(that.scheduledresource) : that.scheduledresource == null);
}","@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (!(o instanceof ContainerPlan))   return false;
  ContainerPlan that=(ContainerPlan)o;
  if (containerId != that.containerId)   return false;
  if (taskInstancePlan != null ? !taskInstancePlan.equals(that.taskInstancePlan) : that.taskInstancePlan != null)   return false;
  if (requiredResource != null ? !requiredResource.equals(that.requiredResource) : that.requiredResource != null)   return false;
  return scheduledResource != null ? scheduledResource.equals(that.scheduledResource) : that.scheduledResource == null;
}",0.7586206896551724
173316,"public Resource getRequiredresource(){
  return requiredresource;
}","public Resource getRequiredresource(){
  return requiredResource;
}",0.9850746268656716
173317,"public void start(RoundFacade parentRound,Player sellingPlayer,int cashToRaise,PublicCompany cashNeedingCompany,boolean dumpOtherCompaniesAllowed){
  log.info(""String_Node_Str"" + sellingPlayer.getId() + ""String_Node_Str""+ cashToRaise);
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",sellingPlayer.getId(),Bank.format(this,cashToRaise)));
  this.parentRound=parentRound;
  currentPlayer=this.sellingPlayer=sellingPlayer;
  this.cashNeedingCompany=cashNeedingCompany;
  this.cashToRaise=IntegerState.create(this,""String_Node_Str"",cashToRaise);
  this.dumpOtherCompaniesAllowed=dumpOtherCompaniesAllowed;
  log.debug(""String_Node_Str"" + dumpOtherCompaniesAllowed);
  getRoot().getPlayerManager().setCurrentPlayer(sellingPlayer);
  getSellableShares();
}","public void start(RoundFacade parentRound,Player sellingPlayer,int cashToRaise,PublicCompany cashNeedingCompany,boolean dumpOtherCompaniesAllowed){
  log.info(""String_Node_Str"" + sellingPlayer.getId() + ""String_Node_Str""+ cashToRaise);
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",sellingPlayer.getId(),Bank.format(this,cashToRaise)));
  this.parentRound=parentRound;
  currentPlayer=this.sellingPlayer=sellingPlayer;
  this.cashNeedingCompany=cashNeedingCompany;
  this.cashToRaise=IntegerState.create(this,""String_Node_Str"",cashToRaise);
  this.dumpOtherCompaniesAllowed=dumpOtherCompaniesAllowed;
  log.debug(""String_Node_Str"" + dumpOtherCompaniesAllowed);
  getRoot().getPlayerManager().setCurrentPlayer(sellingPlayer);
  if (getSellableShares().isEmpty()) {
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",Bank.format(this,this.cashToRaise.value())));
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",Bank.format(this,this.cashToRaise.value())));
    currentPlayer.setBankrupt();
    gameManager.registerBankruptcy();
  }
}",0.8298800436205016
173318,"public ImmutableMap<MapHex,HexSidesSet> getReachableSides(){
  Map<MapHex,HexSidesSet.Builder> hexSides=Maps.newHashMap();
  for (  NetworkVertex vertex : graph.vertexSet()) {
    if (vertex.isSide()) {
      MapHex hex=vertex.getHex();
      if (!hexSides.containsKey(hex)) {
        hexSides.put(hex,HexSidesSet.builder());
      }
      hexSides.get(hex).set(vertex.getSide());
    }
  }
  ImmutableMap.Builder<MapHex,HexSidesSet> hexBuilder=ImmutableMap.builder();
  for (  MapHex hex : hexSides.keySet()) {
    hexBuilder.put(hex,hexSides.get(hex).build());
  }
  return hexBuilder.build();
}","public ImmutableMap<MapHex,HexSidesSet> getReachableSides(){
  Map<MapHex,HexSidesSet.Builder> hexSides=Maps.newHashMap();
  for (  NetworkVertex vertex : graph.vertexSet()) {
    if (vertex.isSide() && iterator.getSeenData().get(vertex) != NetworkIterator.greedyState.greedy) {
      MapHex hex=vertex.getHex();
      if (!hexSides.containsKey(hex)) {
        hexSides.put(hex,HexSidesSet.builder());
      }
      hexSides.get(hex).set(vertex.getSide());
    }
  }
  ImmutableMap.Builder<MapHex,HexSidesSet> hexBuilder=ImmutableMap.builder();
  for (  MapHex hex : hexSides.keySet()) {
    hexBuilder.put(hex,hexSides.get(hex).build());
  }
  return hexBuilder.build();
}",0.9401574803149606
173319,"private void initRouteGraph(NetworkGraph mapGraph,PublicCompany company,boolean addHQ){
  RevenueManager revenueManager=company.getRoot().getRevenueManager();
  if (revenueManager != null) {
    revenueManager.activateRouteGraphModifiers(mapGraph,company);
  }
  NetworkVertex.initAllRailsVertices(mapGraph,company,null);
  NetworkVertex hqVertex=new NetworkVertex(company);
  graph.addVertex(hqVertex);
  List<NetworkVertex> tokenVertexes=mapGraph.getCompanyBaseTokenVertexes(company);
  Set<NetworkVertex> vertexes=new HashSet<NetworkVertex>();
  for (  NetworkVertex vertex : tokenVertexes) {
    boolean storeSink=vertex.isSink();
    vertex.setSink(false);
    vertexes.add(vertex);
    graph.addVertex(vertex);
    graph.addEdge(vertex,hqVertex,new NetworkEdge(vertex,hqVertex,false));
    iterator=new NetworkIterator(mapGraph.getGraph(),vertex,company);
    for (; iterator.hasNext(); ) {
      NetworkVertex seenVertex=iterator.next();
      if (iterator.getSeenData().get(seenVertex) != NetworkIterator.greedyState.greedy) {
        vertexes.add(seenVertex);
      }
    }
    vertex.setSink(storeSink);
  }
  Subgraph<NetworkVertex,NetworkEdge,SimpleGraph<NetworkVertex,NetworkEdge>> subGraph=new Subgraph<NetworkVertex,NetworkEdge,SimpleGraph<NetworkVertex,NetworkEdge>>(mapGraph.getGraph(),vertexes);
  Graphs.addGraph(graph,subGraph);
  if (!addHQ)   graph.removeVertex(hqVertex);
}","private void initRouteGraph(NetworkGraph mapGraph,PublicCompany company,boolean addHQ){
  RevenueManager revenueManager=company.getRoot().getRevenueManager();
  if (revenueManager != null) {
    revenueManager.activateRouteGraphModifiers(mapGraph,company);
  }
  NetworkVertex.initAllRailsVertices(mapGraph,company,null);
  NetworkVertex hqVertex=new NetworkVertex(company);
  graph.addVertex(hqVertex);
  List<NetworkVertex> tokenVertexes=mapGraph.getCompanyBaseTokenVertexes(company);
  Set<NetworkVertex> vertexes=new HashSet<NetworkVertex>();
  for (  NetworkVertex vertex : tokenVertexes) {
    boolean storeSink=vertex.isSink();
    vertex.setSink(false);
    vertexes.add(vertex);
    graph.addVertex(vertex);
    graph.addEdge(vertex,hqVertex,new NetworkEdge(vertex,hqVertex,false));
    iterator=new NetworkIterator(mapGraph.getGraph(),vertex,company);
    for (; iterator.hasNext(); )     vertexes.add(iterator.next());
    vertex.setSink(storeSink);
  }
  Subgraph<NetworkVertex,NetworkEdge,SimpleGraph<NetworkVertex,NetworkEdge>> subGraph=new Subgraph<NetworkVertex,NetworkEdge,SimpleGraph<NetworkVertex,NetworkEdge>>(mapGraph.getGraph(),vertexes);
  Graphs.addGraph(graph,subGraph);
  if (!addHQ)   graph.removeVertex(hqVertex);
}",0.916256157635468
173320,"public ImmutableMap<MapHex,HexSidesSet> getReachableSides(){
  Map<MapHex,HexSidesSet.Builder> hexSides=Maps.newHashMap();
  for (  NetworkVertex vertex : graph.vertexSet()) {
    if (vertex.isSide() && iterator.getSeenData().get(vertex) != NetworkIterator.greedyState.greedy) {
      MapHex hex=vertex.getHex();
      if (!hexSides.containsKey(hex)) {
        hexSides.put(hex,HexSidesSet.builder());
      }
      hexSides.get(hex).set(vertex.getSide());
    }
  }
  ImmutableMap.Builder<MapHex,HexSidesSet> hexBuilder=ImmutableMap.builder();
  for (  MapHex hex : hexSides.keySet()) {
    hexBuilder.put(hex,hexSides.get(hex).build());
  }
  return hexBuilder.build();
}","public ImmutableMap<MapHex,HexSidesSet> getReachableSides(){
  Map<MapHex,HexSidesSet.Builder> hexSides=Maps.newHashMap();
  for (  NetworkVertex vertex : graph.vertexSet()) {
    if (vertex.isSide()) {
      MapHex hex=vertex.getHex();
      if (!hexSides.containsKey(hex)) {
        hexSides.put(hex,HexSidesSet.builder());
      }
      hexSides.get(hex).set(vertex.getSide());
    }
  }
  ImmutableMap.Builder<MapHex,HexSidesSet> hexBuilder=ImmutableMap.builder();
  for (  MapHex hex : hexSides.keySet()) {
    hexBuilder.put(hex,hexSides.get(hex).build());
  }
  return hexBuilder.build();
}",0.9401574803149606
173321,"private void initRouteGraph(NetworkGraph mapGraph,PublicCompany company,boolean addHQ){
  RevenueManager revenueManager=company.getRoot().getRevenueManager();
  if (revenueManager != null) {
    revenueManager.activateRouteGraphModifiers(mapGraph,company);
  }
  NetworkVertex.initAllRailsVertices(mapGraph,company,null);
  NetworkVertex hqVertex=new NetworkVertex(company);
  graph.addVertex(hqVertex);
  List<NetworkVertex> tokenVertexes=mapGraph.getCompanyBaseTokenVertexes(company);
  Set<NetworkVertex> vertexes=new HashSet<NetworkVertex>();
  for (  NetworkVertex vertex : tokenVertexes) {
    boolean storeSink=vertex.isSink();
    vertex.setSink(false);
    vertexes.add(vertex);
    graph.addVertex(vertex);
    graph.addEdge(vertex,hqVertex,new NetworkEdge(vertex,hqVertex,false));
    iterator=new NetworkIterator(mapGraph.getGraph(),vertex,company);
    for (; iterator.hasNext(); )     vertexes.add(iterator.next());
    vertex.setSink(storeSink);
  }
  Subgraph<NetworkVertex,NetworkEdge,SimpleGraph<NetworkVertex,NetworkEdge>> subGraph=new Subgraph<NetworkVertex,NetworkEdge,SimpleGraph<NetworkVertex,NetworkEdge>>(mapGraph.getGraph(),vertexes);
  Graphs.addGraph(graph,subGraph);
  if (!addHQ)   graph.removeVertex(hqVertex);
}","private void initRouteGraph(NetworkGraph mapGraph,PublicCompany company,boolean addHQ){
  RevenueManager revenueManager=company.getRoot().getRevenueManager();
  if (revenueManager != null) {
    revenueManager.activateRouteGraphModifiers(mapGraph,company);
  }
  NetworkVertex.initAllRailsVertices(mapGraph,company,null);
  NetworkVertex hqVertex=new NetworkVertex(company);
  graph.addVertex(hqVertex);
  List<NetworkVertex> tokenVertexes=mapGraph.getCompanyBaseTokenVertexes(company);
  Set<NetworkVertex> vertexes=new HashSet<NetworkVertex>();
  for (  NetworkVertex vertex : tokenVertexes) {
    boolean storeSink=vertex.isSink();
    vertex.setSink(false);
    vertexes.add(vertex);
    graph.addVertex(vertex);
    graph.addEdge(vertex,hqVertex,new NetworkEdge(vertex,hqVertex,false));
    iterator=new NetworkIterator(mapGraph.getGraph(),vertex,company);
    for (; iterator.hasNext(); ) {
      NetworkVertex seenVertex=iterator.next();
      if (iterator.getSeenData().get(seenVertex) != NetworkIterator.greedyState.greedy) {
        vertexes.add(seenVertex);
      }
    }
    vertex.setSink(storeSink);
  }
  Subgraph<NetworkVertex,NetworkEdge,SimpleGraph<NetworkVertex,NetworkEdge>> subGraph=new Subgraph<NetworkVertex,NetworkEdge,SimpleGraph<NetworkVertex,NetworkEdge>>(mapGraph.getGraph(),vertexes);
  Graphs.addGraph(graph,subGraph);
  if (!addHQ)   graph.removeVertex(hqVertex);
}",0.916256157635468
173322,"/** 
 * Buying one or more single or double-share certificates (more is sometimes possible)
 * @param player The player that wants to buy shares.
 * @param action The executed action
 * @return True if the certificates could be bought. False indicates anerror.
 */
@Override public boolean buyShares(String playerName,BuyCertificate action){
  PublicCompany company=action.getCompany();
  PortfolioModel from=action.getFromPortfolio();
  String companyName=company.getId();
  int number=action.getNumberBought();
  int shareUnit=company.getShareUnit();
  int sharePerCert=action.getSharePerCertificate();
  int share=number * sharePerCert;
  int shares=share / shareUnit;
  String errMsg=null;
  int price=0;
  PortfolioModel portfolio=null;
  currentPlayer=playerManager.getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,currentPlayer.getId());
      break;
    }
    company=companyManager.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company != operatingCompany) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,operatingCompany.getId());
    }
    if (!company.hasFloated()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.mustHaveOperatedToTradeShares() && !company.hasOperated()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (hasSold.value()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (share > from.getShare(company)) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,from.getId());
      break;
    }
    portfolio=operatingCompany.getPortfolioModel();
    int treasuryShareLimit=getGameParameterAsInt(GameDef.Parm.TREASURY_SHARE_LIMIT);
    if (portfolio.getShare(company) + share > treasuryShareLimit) {
      errMsg=LocalText.getText(""String_Node_Str"",String.valueOf(treasuryShareLimit));
      break;
    }
    price=company.getMarketPrice();
    if (operatingCompany.getCash() < shares * price) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",companyName,shares,companyName,from.getId(),errMsg));
    return false;
  }
  int cashAmount=shares * price;
  String cashText=Currency.toBank(company,cashAmount);
  if (number == 1) {
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",companyName,shareUnit,companyName,from.getId(),cashText));
  }
 else {
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",companyName,number,shareUnit,number * shareUnit,companyName,from.getId(),cashText));
  }
  PublicCertificate cert2;
  for (int i=0; i < number; i++) {
    cert2=from.findCertificate(company,sharePerCert / shareUnit,false);
    cert2.moveTo(company);
  }
  hasBought.set(true);
  return true;
}","/** 
 * Buying one or more single or double-share certificates (more is sometimes possible)
 * @param player The player that wants to buy shares.
 * @param action The executed action
 * @return True if the certificates could be bought. False indicates anerror.
 */
@Override public boolean buyShares(String playerName,BuyCertificate action){
  PublicCompany company=action.getCompany();
  PortfolioModel from=action.getFromPortfolio();
  String companyName=company.getId();
  int number=action.getNumberBought();
  int shareUnit=company.getShareUnit();
  int sharePerCert=action.getSharePerCertificate();
  int share=number * sharePerCert;
  int shares=share / shareUnit;
  String errMsg=null;
  int price=0;
  PortfolioModel portfolio=null;
  currentPlayer=playerManager.getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,currentPlayer.getId());
      break;
    }
    company=companyManager.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company != operatingCompany) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,operatingCompany.getId());
    }
    if (!company.hasFloated()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.mustHaveOperatedToTradeShares() && !company.hasOperated()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (hasSold.value()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (share > from.getShare(company)) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,from.getId());
      break;
    }
    portfolio=operatingCompany.getPortfolioModel();
    int treasuryShareLimit=getGameParameterAsInt(GameDef.Parm.TREASURY_SHARE_LIMIT);
    if (portfolio.getShare(company) + share > treasuryShareLimit) {
      errMsg=LocalText.getText(""String_Node_Str"",String.valueOf(treasuryShareLimit));
      break;
    }
    price=company.getMarketPrice();
    if (operatingCompany.getCash() < shares * price) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",companyName,shares,companyName,from.getId(),errMsg));
    return false;
  }
  int cashAmount=shares * price;
  String cashText=Currency.toBank(company,cashAmount);
  if (number == 1) {
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",companyName,shareUnit,companyName,from.getName(),cashText));
  }
 else {
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",companyName,number,shareUnit,number * shareUnit,companyName,from.getName(),cashText));
  }
  PublicCertificate cert2;
  for (int i=0; i < number; i++) {
    cert2=from.findCertificate(company,sharePerCert / shareUnit,false);
    cert2.moveTo(company);
  }
  hasBought.set(true);
  return true;
}",0.9980217606330366
173323,"/** 
 * Start a company by buying one or more shares (more applies to e.g. 1841)
 * @param player The player that wants to start a company.
 * @param company The company to start.
 * @param price The start (par) price (ignored if the price is fixed).
 * @param shares The number of shares to buy (can be more than 1 in e.g.1841).
 * @return True if the company could be started. False indicates an error.
 */
@Override public boolean startCompany(String playerName,StartCompany action){
  PublicCompany company=action.getCompany();
  int price=action.getPrice();
  int shares=action.getNumberBought();
  String errMsg=null;
  StockSpace startSpace=null;
  int numberOfCertsToBuy=0;
  PublicCertificate cert=null;
  String companyName=company.getId();
  PublicCompany minor=null;
  StartCompany_18EU startAction=null;
  Stop selectedHomeCity=null;
  currentPlayer=playerManager.getCurrentPlayer();
  while (true) {
    if (!(action instanceof StartCompany_18EU)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    startAction=(StartCompany_18EU)action;
    if (companyBoughtThisTurnWrapper.value() != null) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    company=companyManager.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.hasStarted()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    cert=ipo.findCertificate(company,true);
    if (shares < cert.getShares())     shares=cert.getShares();
    numberOfCertsToBuy=shares - (cert.getShares() - 1);
    if (!mayPlayerBuyCertificate(currentPlayer,company,numberOfCertsToBuy)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if ((startSpace=stockMarket.getStartSpace(price)) == null) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(this,price),company.getId());
      break;
    }
    if (currentPlayer.getCashValue() < shares * price) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!phase5Reached) {
      minor=startAction.getChosenMinor();
      if (minor != null && currentPlayer.getPortfolioModel().getCertificates(minor) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",currentPlayer.getId(),minor.getId());
        break;
      }
    }
 else {
      selectedHomeCity=startAction.getSelectedHomeStation();
      if (selectedHomeCity.getSlots() <= selectedHomeCity.getBaseTokens().size()) {
        errMsg=LocalText.getText(""String_Node_Str"",selectedHomeCity.toString(),company.getId());
        break;
      }
    }
    numberOfCertsToBuy++;
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,companyName,Bank.format(this,price),errMsg));
    return false;
  }
  MapHex homeHex=null;
  int homeCityNumber=1;
  if (minor != null) {
    homeHex=minor.getHomeHexes().get(0);
    homeCityNumber=homeHex.getStopOfBaseToken(minor).getRelatedNumber();
  }
 else   if (selectedHomeCity != null) {
    homeHex=selectedHomeCity.getParent();
    homeCityNumber=selectedHomeCity.getRelatedNumber();
    homeHex.addHome(company,selectedHomeCity);
  }
  company.setHomeHex(homeHex);
  company.setHomeCityNumber(homeCityNumber);
  company.start(startSpace);
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,companyName,Bank.format(this,price),Bank.format(this,shares * price),shares,cert.getShare(),company.getId()));
  cert.moveTo(currentPlayer);
  Currency.wire(currentPlayer,shares * price,company);
  if (minor != null) {
    PublicCertificate cert2=ipo.findCertificate(company,false);
    cert2.moveTo(currentPlayer);
    int minorCash=minor.getCash();
    int minorTrains=minor.getPortfolioModel().getTrainList().size();
    company.transferAssetsFrom(minor);
    minor.setClosed();
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",currentPlayer.getId(),minor.getId(),company.getId(),Bank.format(this,minorCash),minorTrains));
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",currentPlayer.getId(),cert2.getShare(),company.getId(),ipo.getParent().getId(),minor.getId()));
  }
 else {
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",company.getId(),selectedHomeCity.toString()));
  }
  Portfolio.moveAll(ipo.getCertificates(company),company);
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",company.getPortfolioModel().getShare(company),company.getId()));
  int tokensCost=100;
  String costText=Currency.toBank(company,tokensCost);
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",company.getId(),costText,company.getNumberOfBaseTokens()));
  companyBoughtThisTurnWrapper.set(company);
  hasActed.set(true);
  setPriority();
  return true;
}","/** 
 * Start a company by buying one or more shares (more applies to e.g. 1841)
 * @param player The player that wants to start a company.
 * @param company The company to start.
 * @param price The start (par) price (ignored if the price is fixed).
 * @param shares The number of shares to buy (can be more than 1 in e.g.1841).
 * @return True if the company could be started. False indicates an error.
 */
@Override public boolean startCompany(String playerName,StartCompany action){
  PublicCompany company=action.getCompany();
  int price=action.getPrice();
  int shares=action.getNumberBought();
  String errMsg=null;
  StockSpace startSpace=null;
  int numberOfCertsToBuy=0;
  PublicCertificate cert=null;
  String companyName=company.getId();
  PublicCompany minor=null;
  StartCompany_18EU startAction=null;
  Stop selectedHomeCity=null;
  currentPlayer=playerManager.getCurrentPlayer();
  while (true) {
    if (!(action instanceof StartCompany_18EU)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    startAction=(StartCompany_18EU)action;
    if (companyBoughtThisTurnWrapper.value() != null) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    company=companyManager.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.hasStarted()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    cert=ipo.findCertificate(company,true);
    if (shares < cert.getShares())     shares=cert.getShares();
    numberOfCertsToBuy=shares - (cert.getShares() - 1);
    if (!mayPlayerBuyCertificate(currentPlayer,company,numberOfCertsToBuy)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if ((startSpace=stockMarket.getStartSpace(price)) == null) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(this,price),company.getId());
      break;
    }
    if (currentPlayer.getCashValue() < shares * price) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!phase5Reached) {
      minor=startAction.getChosenMinor();
      if (minor != null && currentPlayer.getPortfolioModel().getCertificates(minor) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",currentPlayer.getId(),minor.getId());
        break;
      }
    }
 else {
      selectedHomeCity=startAction.getSelectedHomeStation();
      if (selectedHomeCity.getSlots() <= selectedHomeCity.getBaseTokens().size()) {
        errMsg=LocalText.getText(""String_Node_Str"",selectedHomeCity.toString(),company.getId());
        break;
      }
    }
    numberOfCertsToBuy++;
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,companyName,Bank.format(this,price),errMsg));
    return false;
  }
  MapHex homeHex=null;
  int homeCityNumber=1;
  if (minor != null) {
    homeHex=minor.getHomeHexes().get(0);
    homeCityNumber=homeHex.getStopOfBaseToken(minor).getRelatedNumber();
  }
 else   if (selectedHomeCity != null) {
    homeHex=selectedHomeCity.getParent();
    homeCityNumber=selectedHomeCity.getRelatedNumber();
    homeHex.addHome(company,selectedHomeCity);
  }
  company.setHomeHex(homeHex);
  company.setHomeCityNumber(homeCityNumber);
  company.start(startSpace);
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,companyName,Bank.format(this,price),Bank.format(this,shares * price),shares,cert.getShare(),company.getId()));
  cert.moveTo(currentPlayer);
  Currency.wire(currentPlayer,shares * price,company);
  if (minor != null) {
    PublicCertificate cert2=ipo.findCertificate(company,false);
    cert2.moveTo(currentPlayer);
    int minorCash=minor.getCash();
    int minorTrains=minor.getPortfolioModel().getTrainList().size();
    company.transferAssetsFrom(minor);
    minor.setClosed();
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",currentPlayer.getId(),minor.getId(),company.getId(),Bank.format(this,minorCash),minorTrains));
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",currentPlayer.getId(),cert2.getShare(),company.getId(),ipo.getParent().getId(),minor.getId()));
  }
 else {
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",company.getId(),selectedHomeCity.toText()));
  }
  Portfolio.moveAll(ipo.getCertificates(company),company);
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",company.getPortfolioModel().getShare(company),company.getId()));
  int tokensCost=100;
  String costText=Currency.toBank(company,tokensCost);
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",company.getId(),costText,company.getNumberOfBaseTokens()));
  companyBoughtThisTurnWrapper.set(company);
  hasActed.set(true);
  setPriority();
  return true;
}",0.9989650175947008
173324,"protected void deRegisterObservers(){
  log.debug(""String_Node_Str"");
  for (  Observer o : observers) {
    o.getObservable().removeObserver(o);
  }
}","protected void deRegisterObservers(){
  log.debug(""String_Node_Str"");
  for (  Observer o : observers) {
    Observable observable=o.getObservable();
    if (observable != null) {
      observable.removeObserver(o);
    }
  }
}",0.798941798941799
173325,"public boolean specialBuyTrain(BuyTrain action){
  OrStep currentStep=getStep();
  setStep(GameDef.OrStep.BUY_TRAIN);
  boolean trainResults=super.buyTrain(action);
  setStep(currentStep);
  if (trainResults == false) {
    return false;
  }
  if ((ipo.getTrainsPerType(action.getType()).length == 0) && (trainTypeCanAffectOR(action.getType()) == true)) {
    orControl.orExitToStockRound(operatingCompany.value(),currentStep);
    setActionForPrivateExchange(action.getType());
    if (manditoryNextAction == null) {
      finishOR();
    }
  }
  return true;
}","public boolean specialBuyTrain(BuyTrain action){
  OrStep currentStep=getStep();
  setStep(GameDef.OrStep.BUY_TRAIN);
  boolean trainResults=super.buyTrain(action);
  setStep(currentStep);
  if (!excessTrainCompanies.isEmpty()) {
    for (    Player CompanyOwner : excessTrainCompanies.keySet()) {
      List<PublicCompany> excessTrainCompaniesList=excessTrainCompanies.get(CompanyOwner);
      for (      PublicCompany excessTrainCompany : excessTrainCompaniesList) {
        int numberofTrainsToDiscard=(excessTrainCompany.getNumberOfTrains() - excessTrainCompany.getCurrentTrainLimit());
        Set<Train> trains=excessTrainCompany.getPortfolioModel().getTrainList();
        List<Train> trainsToDiscard=new ArrayList<Train>(4);
        for (        Train train : trains) {
          trainsToDiscard.add(train);
          if (--numberofTrainsToDiscard == 0)           break;
        }
        for (        Train train : trainsToDiscard) {
          train.discard();
          ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",excessTrainCompany.getLongName(),train.getId()));
        }
      }
    }
  }
  if (trainResults == false) {
    return false;
  }
  if ((ipo.getTrainsPerType(action.getType()).length == 0) && (trainTypeCanAffectOR(action.getType()) == true)) {
    orControl.orExitToStockRound(operatingCompany.value(),currentStep);
    setActionForPrivateExchange(action.getType());
    if (manditoryNextAction == null) {
      finishOR();
    }
  }
  return true;
}",0.5480253534861044
173326,"public boolean specialBuyTrain(BuyTrain action){
  OrStep currentStep=getStep();
  setStep(GameDef.OrStep.BUY_TRAIN);
  boolean trainResults=super.buyTrain(action);
  setStep(currentStep);
  if (trainResults == false) {
    return false;
  }
  if ((ipo.getTrainsPerType(action.getType()).length == 0) && (trainTypeCanAffectOR(action.getType()) == true)) {
    orControl.orExitToStockRound(operatingCompany.value(),currentStep);
    setActionForPrivateExchange(action.getType());
    if (manditoryNextAction == null) {
      finishOR();
    }
  }
  return true;
}","public boolean specialBuyTrain(BuyTrain action){
  OrStep currentStep=getStep();
  setStep(GameDef.OrStep.BUY_TRAIN);
  boolean trainResults=super.buyTrain(action);
  setStep(currentStep);
  if (!excessTrainCompanies.isEmpty()) {
    for (    Player CompanyOwner : excessTrainCompanies.keySet()) {
      List<PublicCompany> excessTrainCompaniesList=excessTrainCompanies.get(CompanyOwner);
      for (      PublicCompany excessTrainCompany : excessTrainCompaniesList) {
        int numberofTrainsToDiscard=(excessTrainCompany.getNumberOfTrains() - excessTrainCompany.getCurrentTrainLimit());
        Set<Train> trains=excessTrainCompany.getPortfolioModel().getTrainList();
        List<Train> trainsToDiscard=new ArrayList<Train>(4);
        for (        Train train : trains) {
          trainsToDiscard.add(train);
          if (--numberofTrainsToDiscard == 0)           break;
        }
        for (        Train train : trainsToDiscard) {
          train.discard();
          ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",excessTrainCompany.getLongName(),train.getId()));
        }
      }
    }
  }
  if (trainResults == false) {
    return false;
  }
  if ((ipo.getTrainsPerType(action.getType()).length == 0) && (trainTypeCanAffectOR(action.getType()) == true)) {
    orControl.orExitToStockRound(operatingCompany.value(),currentStep);
    setActionForPrivateExchange(action.getType());
    if (manditoryNextAction == null) {
      finishOR();
    }
  }
  return true;
}",0.5480253534861044
173327,"@Override public void resume(){
  guiHints.setActivePanel(GuiDef.Panel.MAP);
  guiHints.setCurrentRoundType(getClass());
  if (savedAction instanceof BuyTrain) {
    BuyTrain action=(BuyTrain)savedAction;
    Player player=playerManager.getPlayerByName(action.getPlayerName());
    PublicCompany company=action.getCompany();
    int initialPlayerCash=player.getCash();
    int trainCost=action.getFixedCost();
    int amountOwed=(trainCost - company.getCash());
    Currency.wire(player,amountOwed,company);
    BuyTrain newTrainBuy=new BuyTrain(action.getTrain(),action.getFromOwner(),trainCost);
    newTrainBuy.setPricePaid(trainCost);
    buyTrain(newTrainBuy);
    int additionalDebt=-player.getCash();
    if (initialPlayerCash < 0) {
      additionalDebt=additionalDebt - (-initialPlayerCash);
    }
    int penalty=(additionalDebt / 2);
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",player.getId(),Bank.format(this,penalty)));
    Currency.wire(player,penalty,getRoot().getBank());
  }
  wasInterrupted.set(true);
}","@Override public void resume(){
  guiHints.setActivePanel(GuiDef.Panel.MAP);
  guiHints.setCurrentRoundType(getClass());
  if (savedAction instanceof BuyTrain) {
    BuyTrain action=(BuyTrain)savedAction;
    Player player=playerManager.getPlayerByName(action.getPlayerName());
    PublicCompany company=action.getCompany();
    int initialPlayerCash=player.getCash();
    int trainCost=action.getFixedCost();
    int amountOwed=(trainCost - company.getCash());
    Currency.wire(player,amountOwed,company);
    BuyTrain newTrainBuy=new BuyTrain(action.getTrain(),action.getFromOwner(),trainCost);
    newTrainBuy.setPricePaid(trainCost);
    buyTrain(newTrainBuy);
    if (!(initialPlayerCash > amountOwed)) {
      int additionalDebt=-player.getCash();
      if (initialPlayerCash < 0) {
        additionalDebt=additionalDebt - (-initialPlayerCash);
      }
      int penalty=(additionalDebt / 2);
      ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",player.getId(),Bank.format(this,penalty)));
      Currency.wire(player,penalty,getRoot().getBank());
    }
  }
  wasInterrupted.set(true);
}",0.9696686887540832
173328,"@Override public void resume(){
  guiHints.setActivePanel(GuiDef.Panel.MAP);
  guiHints.setCurrentRoundType(getClass());
  if (savedAction instanceof BuyTrain) {
    BuyTrain action=(BuyTrain)savedAction;
    Player player=playerManager.getPlayerByName(action.getPlayerName());
    PublicCompany company=action.getCompany();
    int initialPlayerCash=player.getCash();
    int trainCost=action.getFixedCost();
    int amountOwed=(trainCost - company.getCash());
    Currency.wire(player,amountOwed,company);
    BuyTrain newTrainBuy=new BuyTrain(action.getTrain(),action.getFromOwner(),trainCost);
    newTrainBuy.setPricePaid(trainCost);
    buyTrain(newTrainBuy);
    int additionalDebt=-player.getCash();
    if (initialPlayerCash < 0) {
      additionalDebt=additionalDebt - (-initialPlayerCash);
    }
    int penalty=(additionalDebt / 2);
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",player.getId(),Bank.format(this,penalty)));
    Currency.wire(player,penalty,getRoot().getBank());
  }
  wasInterrupted.set(true);
}","@Override public void resume(){
  guiHints.setActivePanel(GuiDef.Panel.MAP);
  guiHints.setCurrentRoundType(getClass());
  if (savedAction instanceof BuyTrain) {
    BuyTrain action=(BuyTrain)savedAction;
    Player player=playerManager.getPlayerByName(action.getPlayerName());
    PublicCompany company=action.getCompany();
    int initialPlayerCash=player.getCash();
    int trainCost=action.getFixedCost();
    int amountOwed=(trainCost - company.getCash());
    Currency.wire(player,amountOwed,company);
    BuyTrain newTrainBuy=new BuyTrain(action.getTrain(),action.getFromOwner(),trainCost);
    newTrainBuy.setPricePaid(trainCost);
    buyTrain(newTrainBuy);
    if (!(initialPlayerCash > amountOwed)) {
      int additionalDebt=-player.getCash();
      if (initialPlayerCash < 0) {
        additionalDebt=additionalDebt - (-initialPlayerCash);
      }
      int penalty=(additionalDebt / 2);
      ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",player.getId(),Bank.format(this,penalty)));
      Currency.wire(player,penalty,getRoot().getBank());
    }
  }
  wasInterrupted.set(true);
}",0.9696686887540832
173329,"public boolean isTileColourAllowed(String tileColour){
  return tileColours.contains(tileColour);
}","@Deprecated public boolean isTileColourAllowed(String tileColour){
  return tileColours.contains(tileColour);
}",0.9428571428571428
173330,"public List<String> getTileColours(){
  return tileColours;
}","@Deprecated public List<String> getTileColours(){
  return tileColours;
}",0.9104477611940298
173331,"public boolean modifyCalculator(RevenueAdapter revenueAdapter){
  Phase phase=revenueAdapter.getPhase();
  int bonusValue;
  if (phase.isTileColourAllowed(TileColour.GREY.name())) {
    bonusValue=30;
  }
 else   if (phase.isTileColourAllowed(TileColour.BROWN.name())) {
    bonusValue=20;
  }
 else   if (phase.isTileColourAllowed(TileColour.GREEN.name())) {
    bonusValue=10;
  }
 else {
    return false;
  }
  log.info(""String_Node_Str"" + bonusValue);
  Set<NetworkVertex> offBoard=new HashSet<NetworkVertex>();
  for (  NetworkVertex vertex : revenueAdapter.getVertices()) {
    if (vertex.isStation() && vertex.getStation().getType() == Station.Type.OFFMAPCITY) {
      offBoard.add(vertex);
    }
  }
  NetworkVertex hamburgCity=NetworkVertex.getVertexByIdentifier(revenueAdapter.getVertices(),""String_Node_Str"");
  if (hamburgCity != null) {
    NetworkVertex hamburgTerminal=NetworkVertex.duplicateVertex(revenueAdapter.getGraph(),hamburgCity,""String_Node_Str"",true);
    hamburgTerminal.setSink(true);
    offBoard.add(hamburgTerminal);
    offBoard.remove(hamburgCity);
    VertexVisit hamburgSet=revenueAdapter.new VertexVisit();
    hamburgSet.set.add(hamburgCity);
    hamburgSet.set.add(hamburgTerminal);
    revenueAdapter.addVertexVisitSet(hamburgSet);
  }
  log.info(""String_Node_Str"" + offBoard);
  Set<NetworkVertex> bases=revenueAdapter.getStartVertices();
  Set<NetworkVertex> destOffBoard=new HashSet<NetworkVertex>(offBoard);
  for (  NetworkVertex offA : offBoard) {
    destOffBoard.remove(offA);
    for (    NetworkVertex offB : destOffBoard) {
      for (      NetworkVertex base : bases) {
        RevenueBonus bonus=new RevenueBonus(bonusValue,""String_Node_Str"");
        bonus.addVertex(offA);
        bonus.addVertex(offB);
        bonus.addVertex(base);
        revenueAdapter.addRevenueBonus(bonus);
      }
    }
  }
  return false;
}","public boolean modifyCalculator(RevenueAdapter revenueAdapter){
  Phase phase=revenueAdapter.getPhase();
  int bonusValue;
  if (phase.isTileColourAllowed(TileColour.GREY.toText())) {
    bonusValue=30;
  }
 else   if (phase.isTileColourAllowed(TileColour.BROWN.toText())) {
    bonusValue=20;
  }
 else   if (phase.isTileColourAllowed(TileColour.GREEN.toText())) {
    bonusValue=10;
  }
 else {
    return false;
  }
  log.info(""String_Node_Str"" + bonusValue);
  Set<NetworkVertex> offBoard=new HashSet<NetworkVertex>();
  for (  NetworkVertex vertex : revenueAdapter.getVertices()) {
    if (vertex.isStation() && vertex.getStation().getType() == Station.Type.OFFMAPCITY) {
      offBoard.add(vertex);
    }
  }
  NetworkVertex hamburgCity=NetworkVertex.getVertexByIdentifier(revenueAdapter.getVertices(),""String_Node_Str"");
  if (hamburgCity != null) {
    NetworkVertex hamburgTerminal=NetworkVertex.duplicateVertex(revenueAdapter.getGraph(),hamburgCity,""String_Node_Str"",true);
    hamburgTerminal.setSink(true);
    offBoard.add(hamburgTerminal);
    offBoard.remove(hamburgCity);
    VertexVisit hamburgSet=revenueAdapter.new VertexVisit();
    hamburgSet.set.add(hamburgCity);
    hamburgSet.set.add(hamburgTerminal);
    revenueAdapter.addVertexVisitSet(hamburgSet);
  }
  log.info(""String_Node_Str"" + offBoard);
  Set<NetworkVertex> bases=revenueAdapter.getStartVertices();
  Set<NetworkVertex> destOffBoard=new HashSet<NetworkVertex>(offBoard);
  for (  NetworkVertex offA : offBoard) {
    destOffBoard.remove(offA);
    for (    NetworkVertex offB : destOffBoard) {
      for (      NetworkVertex base : bases) {
        RevenueBonus bonus=new RevenueBonus(bonusValue,""String_Node_Str"");
        bonus.addVertex(offA);
        bonus.addVertex(offB);
        bonus.addVertex(base);
        revenueAdapter.addRevenueBonus(bonus);
      }
    }
  }
  return false;
}",0.9919957310565636
173332,"@Override public boolean setPossibleActions(){
  if (manditoryNextAction != null) {
    possibleActions.add(manditoryNextAction);
    return true;
  }
  if (getStep() == GameDef.OrStep.INITIAL) {
    if (operatingCompany.value() instanceof PublicCompany_1880) {
      initTurn();
      if ((noMapMode) || (!((PublicCompany_1880)operatingCompany.value()).hasBuildingRightForPhase(gameManager.getCurrentPhase()))) {
        nextStep(GameDef.OrStep.LAY_TRACK);
      }
 else {
        initNormalTileLays();
        setStep(GameDef.OrStep.LAY_TRACK);
      }
    }
  }
  if ((getStep() == GameDef.OrStep.BUY_TRAIN) && (operatingCompany.value() instanceof Investor_1880)) {
    Investor_1880 investor=(Investor_1880)(operatingCompany.value());
    if (investor.isConnectedToLinkedCompany()) {
      possibleActions.add(new CloseInvestor_1880((Investor_1880)operatingCompany.value()));
      return true;
    }
  }
  return super.setPossibleActions();
}","@Override public boolean setPossibleActions(){
  if (manditoryNextAction != null) {
    possibleActions.add(manditoryNextAction);
    return true;
  }
  if (getStep() == GameDef.OrStep.INITIAL) {
    if (operatingCompany.value() instanceof PublicCompany_1880) {
      initTurn();
      if (operatingCompany.value() instanceof Investor_1880) {
        if (gameManager.getCurrentPhase().getId().equals(""String_Node_Str"")) {
          setStep(GameDef.OrStep.BUY_TRAIN);
        }
      }
      if ((noMapMode) || (!((PublicCompany_1880)operatingCompany.value()).hasBuildingRightForPhase(gameManager.getCurrentPhase()))) {
        nextStep(GameDef.OrStep.LAY_TRACK);
      }
 else {
        initNormalTileLays();
        setStep(GameDef.OrStep.LAY_TRACK);
      }
    }
  }
  if ((getStep() == GameDef.OrStep.BUY_TRAIN) && (operatingCompany.value() instanceof Investor_1880)) {
    Investor_1880 investor=(Investor_1880)(operatingCompany.value());
    if (investor.isConnectedToLinkedCompany()) {
      possibleActions.add(new CloseInvestor_1880((Investor_1880)operatingCompany.value()));
      return true;
    }
  }
  return super.setPossibleActions();
}",0.6469747498808956
173333,"@Override protected boolean equalsAs(PossibleAction pa,boolean asOption){
  if (pa == this)   return true;
  if (!super.equalsAs(pa,asOption))   return false;
  StartCompany_18EU action=(StartCompany_18EU)pa;
  boolean options=Objects.equal(this.minorsToMerge,action.minorsToMerge) && Objects.equal(this.requestStartSpaces,action.requestStartSpaces) && Objects.equal(this.availableHomeStations,action.availableHomeStations);
  if (asOption)   return options;
  return options && Objects.equal(this.chosenMinor,action.chosenMinor) && Objects.equal(this.selectedHomeStation,action.selectedHomeStation);
}","@Override protected boolean equalsAs(PossibleAction pa,boolean asOption){
  if (pa == this)   return true;
  if (!super.equalsAs(pa,asOption))   return false;
  StartCompany_18EU action=(StartCompany_18EU)pa;
  boolean options=Objects.equal(this.requestStartSpaces,action.requestStartSpaces) && RailsObjects.elementEquals(this.minorsToMerge,action.minorsToMerge);
  if (asOption)   return options;
  return options && Objects.equal(this.chosenMinor,action.chosenMinor) && Objects.equal(this.selectedHomeStation,action.selectedHomeStation);
}",0.6649168853893264
173334,"@Override public boolean isSoldOut(){
  if (!isBuyable())   return false;
  for (  PublicCertificate cert : certificates.view()) {
    Owner owner=cert.getOwner();
    if (owner instanceof BankPortfolio && owner != Bank.getUnavailable(this)) {
      return false;
    }
  }
  return true;
}","@Override public boolean isSoldOut(){
  if (!hasStarted())   return false;
  for (  PublicCertificate cert : certificates.view()) {
    Owner owner=cert.getOwner();
    if (owner instanceof BankPortfolio && owner != Bank.getUnavailable(this)) {
      return false;
    }
  }
  return true;
}",0.9672977624784854
173335,"/** 
 * Create a list of certificates that the company may sell, taking all rules taken into account. <br>Note: old code that provides for ownership of presidencies of other companies has been retained, but not tested. This code will be needed for 1841.
 * @return List of sellable certificates.
 */
public void setSellableCerts(){
  String compName;
  int price;
  int number;
  int maxShareToSell;
  PortfolioModel companyPortfolio=operatingCompany.getPortfolioModel();
  for (  PublicCompany company : companyManager.getAllPublicCompanies()) {
    if (!company.hasStarted())     continue;
    maxShareToSell=companyPortfolio.getShare(company);
    if (maxShareToSell == 0)     continue;
    maxShareToSell=Math.min(maxShareToSell,getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT) - pool.getShare(company));
    if (maxShareToSell == 0)     continue;
    int[] shareCountPerUnit=new int[5];
    compName=company.getId();
    for (    PublicCertificate c : companyPortfolio.getCertificates(company)) {
      if (c.isPresidentShare()) {
        shareCountPerUnit[1]+=c.getShares();
      }
 else {
        ++shareCountPerUnit[c.getShares()];
      }
    }
    if (sellPrices.containsKey(compName)) {
      price=(sellPrices.get(compName)).getPrice();
    }
 else {
      price=company.getMarketPrice();
    }
    for (int shareSize=1; shareSize <= 4; shareSize++) {
      number=shareCountPerUnit[shareSize];
      if (number == 0)       continue;
      number=Math.min(number,maxShareToSell / (shareSize * company.getShareUnit()));
      if (number == 0)       continue;
      for (int i=1; i <= number; i++) {
        possibleActions.add(new SellShares(company,shareSize,i,price));
      }
    }
  }
}","/** 
 * Create a list of certificates that the company may sell, taking all rules taken into account. <br>Note: old code that provides for ownership of presidencies of other companies has been retained, but not tested. This code will be needed for 1841.
 * @return List of sellable certificates.
 */
public void setSellableCerts(){
  int price;
  int number;
  int maxShareToSell;
  PortfolioModel companyPortfolio=operatingCompany.getPortfolioModel();
  for (  PublicCompany company : companyManager.getAllPublicCompanies()) {
    if (!company.hasStarted())     continue;
    maxShareToSell=companyPortfolio.getShare(company);
    if (maxShareToSell == 0)     continue;
    maxShareToSell=Math.min(maxShareToSell,getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT) - pool.getShare(company));
    if (maxShareToSell == 0)     continue;
    int[] shareCountPerUnit=new int[5];
    for (    PublicCertificate c : companyPortfolio.getCertificates(company)) {
      if (c.isPresidentShare()) {
        shareCountPerUnit[1]+=c.getShares();
      }
 else {
        ++shareCountPerUnit[c.getShares()];
      }
    }
    if (sellPrices.containsKey(company)) {
      price=(sellPrices.get(company)).getPrice();
    }
 else {
      price=company.getMarketPrice();
    }
    for (int shareSize=1; shareSize <= 4; shareSize++) {
      number=shareCountPerUnit[shareSize];
      if (number == 0)       continue;
      number=Math.min(number,maxShareToSell / (shareSize * company.getShareUnit()));
      if (number == 0)       continue;
      for (int i=1; i <= number; i++) {
        possibleActions.add(new SellShares(company,shareSize,i,price));
      }
    }
  }
}",0.9812555786968165
173336,"@Override public boolean sellShares(SellShares action){
  PortfolioModel portfolio=currentPlayer.getPortfolioModel();
  String playerName=currentPlayer.getId();
  String errMsg=null;
  String companyName=action.getCompanyName();
  PublicCompany company=companyManager.getPublicCompany(action.getCompanyName());
  PublicCertificate cert=null;
  PublicCertificate presCert=null;
  List<PublicCertificate> certsToSell=new ArrayList<PublicCertificate>();
  Player dumpedPlayer=null;
  int presSharesToSell=0;
  int numberToSell=action.getNumber();
  int shareUnits=action.getShareUnits();
  int currentIndex=getCurrentPlayerIndex();
  while (true) {
    if (numberToSell <= 0) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!mayPlayerSellShareOfCompany(company)) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (portfolio.getShare(company) < numberToSell) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (pool.getShare(company) + numberToSell * company.getShareUnit() > getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    Iterator<PublicCertificate> it=portfolio.getCertificates(company).iterator();
    while (numberToSell > 0 && it.hasNext()) {
      cert=it.next();
      if (cert.isPresidentShare()) {
        if (cert.isPresidentShare())         presCert=cert;
        continue;
      }
 else       if (shareUnits != cert.getShares()) {
        continue;
      }
      certsToSell.add(cert);
      numberToSell--;
    }
    if (numberToSell == 0)     presCert=null;
    if (numberToSell > 0 && presCert != null && numberToSell <= presCert.getShares()) {
      if (company == cashNeedingCompany || !dumpOtherCompaniesAllowed) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
      Player otherPlayer;
      Player player=playerManager.getCurrentPlayer();
      for (int i=currentIndex + 1; i < currentIndex + numberOfPlayers; i++) {
        otherPlayer=playerManager.getNextPlayerAfter(player);
        if (otherPlayer.getPortfolioModel().getShare(company) >= presCert.getShare()) {
          if (numberToSell > 1 || otherPlayer.getPortfolioModel().ownsCertificates(company,1,false) >= 1) {
            dumpedPlayer=otherPlayer;
            presSharesToSell=numberToSell;
            numberToSell=0;
            break;
          }
        }
        player=otherPlayer;
      }
    }
    if (numberToSell > 0) {
      if (presCert != null) {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
 else {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
      break;
    }
    break;
  }
  int numberSold=action.getNumber();
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,numberSold,companyName,errMsg));
    return false;
  }
  StockSpace sellPrice;
  int price;
  if (sellPrices.containsKey(company) && GameOption.getAsBoolean(this,""String_Node_Str"")) {
    price=(sellPrices.get(company).getPrice());
  }
 else {
    sellPrice=company.getCurrentSpace();
    price=sellPrice.getPrice();
    sellPrices.put(company,sellPrice);
  }
  int cashAmount=((numberSold * price * shareUnits) - (numberSold * 5));
  String cashText=Currency.fromBank(cashAmount,currentPlayer);
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,numberSold,company.getShareUnit(),numberSold * company.getShareUnit(),companyName,cashText));
  boolean soldBefore=sellPrices.containsKey(companyName);
  adjustSharePrice(company,numberSold,soldBefore);
  if (!company.isClosed()) {
    executeShareTransfer(company,certsToSell,dumpedPlayer,presSharesToSell);
  }
  cashToRaise.add(-numberSold * price);
  if (cashToRaise.value() <= 0) {
    gameManager.finishShareSellingRound();
  }
 else   if (getSellableShares().isEmpty()) {
    gameManager.finishShareSellingRound();
  }
  return true;
}","@Override public boolean sellShares(SellShares action){
  PortfolioModel portfolio=currentPlayer.getPortfolioModel();
  String playerName=currentPlayer.getId();
  String errMsg=null;
  String companyName=action.getCompanyName();
  PublicCompany company=companyManager.getPublicCompany(action.getCompanyName());
  PublicCertificate cert=null;
  PublicCertificate presCert=null;
  List<PublicCertificate> certsToSell=new ArrayList<PublicCertificate>();
  Player dumpedPlayer=null;
  int presSharesToSell=0;
  int numberToSell=action.getNumber();
  int shareUnits=action.getShareUnits();
  int currentIndex=getCurrentPlayerIndex();
  while (true) {
    if (numberToSell <= 0) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!mayPlayerSellShareOfCompany(company)) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (portfolio.getShare(company) < numberToSell) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (pool.getShare(company) + numberToSell * company.getShareUnit() > getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    Iterator<PublicCertificate> it=portfolio.getCertificates(company).iterator();
    while (numberToSell > 0 && it.hasNext()) {
      cert=it.next();
      if (cert.isPresidentShare()) {
        if (cert.isPresidentShare())         presCert=cert;
        continue;
      }
 else       if (shareUnits != cert.getShares()) {
        continue;
      }
      certsToSell.add(cert);
      numberToSell--;
    }
    if (numberToSell == 0)     presCert=null;
    if (numberToSell > 0 && presCert != null && numberToSell <= presCert.getShares()) {
      if (company == cashNeedingCompany || !dumpOtherCompaniesAllowed) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
      Player otherPlayer;
      Player player=playerManager.getCurrentPlayer();
      for (int i=currentIndex + 1; i < currentIndex + numberOfPlayers; i++) {
        otherPlayer=playerManager.getNextPlayerAfter(player);
        if (otherPlayer.getPortfolioModel().getShare(company) >= presCert.getShare()) {
          if (numberToSell > 1 || otherPlayer.getPortfolioModel().ownsCertificates(company,1,false) >= 1) {
            dumpedPlayer=otherPlayer;
            presSharesToSell=numberToSell;
            numberToSell=0;
            break;
          }
        }
        player=otherPlayer;
      }
    }
    if (numberToSell > 0) {
      if (presCert != null) {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
 else {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
      break;
    }
    break;
  }
  int numberSold=action.getNumber();
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,numberSold,companyName,errMsg));
    return false;
  }
  StockSpace sellPrice;
  int price;
  if (sellPrices.containsKey(company) && GameOption.getAsBoolean(this,""String_Node_Str"")) {
    price=(sellPrices.get(company).getPrice());
  }
 else {
    sellPrice=company.getCurrentSpace();
    price=sellPrice.getPrice();
    sellPrices.put(company,sellPrice);
  }
  int cashAmount=((numberSold * price * shareUnits) - (numberSold * 5));
  String cashText=Currency.fromBank(cashAmount,currentPlayer);
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,numberSold,company.getShareUnit(),numberSold * company.getShareUnit(),companyName,cashText));
  boolean soldBefore=sellPrices.containsKey(company);
  adjustSharePrice(company,numberSold,soldBefore);
  if (!company.isClosed()) {
    executeShareTransfer(company,certsToSell,dumpedPlayer,presSharesToSell);
  }
  cashToRaise.add(-numberSold * price);
  if (cashToRaise.value() <= 0) {
    gameManager.finishShareSellingRound();
  }
 else   if (getSellableShares().isEmpty()) {
    gameManager.finishShareSellingRound();
  }
  return true;
}",0.999507146377526
173337,"/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(NullAction action,String playerName){
  String errMsg=null;
  Player player=playerManager.getCurrentPlayer();
  StartItem auctionItem=auctionItemState.value();
  while (true) {
    if (!playerName.equals(player.getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getId());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName));
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.value() >= auctionItem.getBidders() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getId());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
      playerManager.setCurrentToPriorityPlayer();
    }
 else {
      if (GameOption.getAsBoolean(this,""String_Node_Str"")) {
        player.unblockCash(auctionItem.getBid(player));
        auctionItem.setPass(player);
      }
      setNextBiddingPlayer(auctionItem);
    }
  }
 else {
    if (numPasses.value() >= playerManager.getNumberOfPlayers()) {
      gameManager.reportAllPlayersPassed();
      if (startPacket.getFirstItem() == startPacket.getFirstUnsoldItem() || startPacket.getFirstUnsoldItem().getReduceable()) {
        startPacket.getFirstUnsoldItem().reduceBasePriceBy(5);
        ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",startPacket.getFirstUnsoldItem().getId(),Bank.format(this,startPacket.getFirstUnsoldItem().getBasePrice())));
        numPasses.set(0);
        if (startPacket.getFirstUnsoldItem().getBasePrice() == 0) {
          assignItem(playerManager.getCurrentPlayer(),startPacket.getFirstUnsoldItem(),0,0);
          getRoot().getPlayerManager().setPriorityPlayerToNext();
        }
 else {
          playerManager.setCurrentToNextPlayer();
        }
      }
 else {
        numPasses.set(0);
        finishRound();
      }
    }
 else {
      playerManager.setCurrentToNextPlayer();
    }
  }
  return true;
}","/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(NullAction action,String playerName){
  String errMsg=null;
  Player player=playerManager.getCurrentPlayer();
  StartItem auctionItem=auctionItemState.value();
  while (true) {
    if (!playerName.equals(player.getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getId());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName));
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.value() >= auctionItem.getBidders() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getId());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
      playerManager.setCurrentToPriorityPlayer();
    }
 else {
      if (GameOption.getAsBoolean(this,""String_Node_Str"")) {
        player.unblockCash(auctionItem.getBid(player));
        auctionItem.setPass(player);
      }
      setNextBiddingPlayer(auctionItem);
    }
  }
 else {
    if (numPasses.value() >= playerManager.getNumberOfPlayers()) {
      gameManager.reportAllPlayersPassed();
      if (startPacket.getFirstItem() == startPacket.getFirstUnsoldItem() || startPacket.getFirstUnsoldItem().getReduceable()) {
        startPacket.getFirstUnsoldItem().reduceBasePriceBy(5);
        ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",startPacket.getFirstUnsoldItem().getId(),Bank.format(this,startPacket.getFirstUnsoldItem().getBasePrice())));
        numPasses.set(0);
        if (startPacket.getFirstUnsoldItem().getBasePrice() == 0) {
          getRoot().getPlayerManager().setCurrentToNextPlayer();
          assignItem(playerManager.getCurrentPlayer(),startPacket.getFirstUnsoldItem(),0,0);
          getRoot().getPlayerManager().setPriorityPlayerToNext();
          getRoot().getPlayerManager().setCurrentToNextPlayer();
        }
 else {
          playerManager.setCurrentToNextPlayer();
        }
      }
 else {
        numPasses.set(0);
        finishRound();
      }
    }
 else {
      playerManager.setCurrentToNextPlayer();
    }
  }
  return true;
}",0.973800886739218
173338,"public boolean verify(JComponent arg0){
  List<String> players=window.getPlayers();
  window.setPlayers(players);
  int nextPlayerNr=players.size();
  if (nextPlayerNr < window.getSelectedGame().getMaxPlayers()) {
    if (!window.isPlayerEnabled(nextPlayerNr)) {
      window.enablePlayer(nextPlayerNr);
      window.setFocus(nextPlayerNr);
    }
  }
  if (nextPlayerNr + 1 < window.getSelectedGame().getMaxPlayers()) {
    window.disablePlayer(nextPlayerNr + 1);
  }
  return true;
}","public boolean verify(JComponent arg0){
  List<String> players=window.getPlayers();
  window.setPlayers(players);
  int nextPlayerNr=players.size();
  if (nextPlayerNr < window.getSelectedGame().getMaxPlayers()) {
    if (!window.isPlayerEnabled(nextPlayerNr)) {
      window.enablePlayer(nextPlayerNr);
      window.setFocus(nextPlayerNr);
    }
  }
  while (++nextPlayerNr < window.getSelectedGame().getMaxPlayers()) {
    window.disablePlayer(nextPlayerNr);
  }
  return true;
}",0.955440414507772
173339,"void initPlayersPane(GameInfo selectedGame){
  playersPane.setVisible(false);
  List<String> prefilledPlayers=Lists.newArrayList();
  for (  PlayerInfo player : players) {
    if (player.name != null && player.name.getText().length() > 0) {
      prefilledPlayers.add(player.name.getText());
    }
  }
  players.clear();
  if (prefilledPlayers.isEmpty()) {
    prefilledPlayers=Arrays.asList(Config.get(""String_Node_Str"").split(""String_Node_Str""));
  }
  playersPane.removeAll();
  int maxPlayers=selectedGame.getMaxPlayers();
  int minPlayers=selectedGame.getMinPlayers();
  playersPane.setLayout(new GridLayout(maxPlayers + 1,0,0,2));
  playersPane.setBorder(BorderFactory.createLoweredBevelBorder());
  playersPane.add(new JLabel(""String_Node_Str""));
  playersPane.add(randomizeButton);
  for (int i=0; i < maxPlayers; i++) {
    PlayerInfo player=new PlayerInfo();
    player.number.setText(LocalText.getText(""String_Node_Str"",Integer.toString(i + 1)));
    player.name.setInputVerifier(controller.playerNameVerifier);
    if (i < prefilledPlayers.size()) {
      player.name.setText(prefilledPlayers.get(i));
    }
    if (i < minPlayers) {
      player.name.setBorder(BorderFactory.createLineBorder(Color.RED));
    }
    if (i <= minPlayers || i <= prefilledPlayers.size()) {
      player.name.setEnabled(true);
      player.number.setForeground(Color.BLACK);
    }
 else {
      player.name.setEnabled(false);
      player.number.setForeground(Color.GRAY);
    }
    playersPane.add(player.number);
    playersPane.add(player.name);
    players.add(player);
  }
  playersPane.setVisible(true);
}","void initPlayersPane(GameInfo selectedGame){
  playersPane.setVisible(false);
  List<String> prefilledPlayers=Lists.newArrayList();
  for (  PlayerInfo player : players) {
    if (player.name != null && player.name.getText().length() > 0) {
      prefilledPlayers.add(player.name.getText());
    }
  }
  players.clear();
  if (prefilledPlayers.isEmpty()) {
    prefilledPlayers=Arrays.asList(Config.get(""String_Node_Str"").split(""String_Node_Str""));
  }
  playersPane.removeAll();
  int maxPlayers=selectedGame.getMaxPlayers();
  int minPlayers=selectedGame.getMinPlayers();
  playersPane.setLayout(new GridLayout(maxPlayers + 1,0,0,2));
  playersPane.setBorder(BorderFactory.createLoweredBevelBorder());
  playersPane.add(new JLabel(""String_Node_Str""));
  playersPane.add(randomizeButton);
  for (int i=0; i < maxPlayers; i++) {
    PlayerInfo player=new PlayerInfo();
    player.number.setText(LocalText.getText(""String_Node_Str"",Integer.toString(i + 1)));
    player.name.setInputVerifier(controller.playerNameVerifier);
    if (i < prefilledPlayers.size()) {
      player.name.setText(prefilledPlayers.get(i));
    }
    if (i < minPlayers) {
      player.name.setBorder(BorderFactory.createLineBorder(Color.RED));
    }
    if (i < minPlayers || i <= prefilledPlayers.size()) {
      player.name.setEnabled(true);
      player.number.setForeground(Color.BLACK);
    }
 else {
      player.name.setEnabled(false);
      player.number.setForeground(Color.GRAY);
    }
    final int playerNr=i;
    player.name.addMouseListener(new MouseAdapter(){
      @Override public void mouseClicked(      MouseEvent e){
        if (playerNr == getPlayerCount()) {
          enablePlayer(playerNr);
          setFocus(playerNr);
        }
      }
    }
);
    playersPane.add(player.number);
    playersPane.add(player.name);
    players.add(player);
  }
  playersPane.setVisible(true);
}",0.8687158862395863
173340,"private String getStartItemDescription(StartItem item){
  StringBuffer b=new StringBuffer(""String_Node_Str"");
  b.append(item.getPrimary().toString());
  if (item.getPrimary() instanceof PrivateCompany) {
    PrivateCompany priv=(PrivateCompany)item.getPrimary();
    b.append(""String_Node_Str"").append(Bank.format(item,priv.getRevenue()));
    List<MapHex> blockedHexes=priv.getBlockedHexes();
    if (blockedHexes == null) {
    }
 else     if (blockedHexes.size() == 1) {
      b.append(""String_Node_Str"").append(blockedHexes.get(0).getId());
    }
 else     if (blockedHexes.size() > 1) {
      b.append(""String_Node_Str"");
      for (      MapHex hex : blockedHexes) {
        b.append(""String_Node_Str"").append(hex.getId());
      }
    }
    if (priv.hasSpecialProperties()) {
      b.append(""String_Node_Str"");
      for (      SpecialProperty sp : priv.getSpecialProperties()) {
        b.append(""String_Node_Str"").append(sp.toString());
      }
    }
    List<String> preventClosingConditions=priv.getPreventClosingConditions();
    if (!preventClosingConditions.isEmpty()) {
      b.append(""String_Node_Str"");
      for (      String condition : preventClosingConditions) {
        b.append(""String_Node_Str"").append(condition);
      }
    }
  }
  if (item.getSecondary() != null) {
    b.append(""String_Node_Str"");
    b.append(item.getSecondary().toString());
  }
  return b.toString();
}","private String getStartItemDescription(StartItem item){
  StringBuffer b=new StringBuffer(""String_Node_Str"");
  b.append(item.getPrimary().toString());
  if (item.getPrimary() instanceof PrivateCompany) {
    PrivateCompany priv=(PrivateCompany)item.getPrimary();
    b.append(""String_Node_Str"").append(Bank.format(item,priv.getRevenue()));
    List<MapHex> blockedHexes=priv.getBlockedHexes();
    if (blockedHexes == null) {
    }
 else     if (blockedHexes.size() == 1) {
      b.append(""String_Node_Str"").append(blockedHexes.get(0).getId());
    }
 else     if (blockedHexes.size() > 1) {
      b.append(""String_Node_Str"");
      for (      MapHex hex : blockedHexes) {
        b.append(""String_Node_Str"").append(hex.getId());
      }
    }
    if (priv.hasSpecialProperties()) {
      b.append(""String_Node_Str"");
      for (      SpecialProperty sp : priv.getSpecialProperties()) {
        b.append(""String_Node_Str"").append(sp.getInfo());
      }
    }
    List<String> preventClosingConditions=priv.getPreventClosingConditions();
    if (!preventClosingConditions.isEmpty()) {
      b.append(""String_Node_Str"");
      for (      String condition : preventClosingConditions) {
        b.append(""String_Node_Str"").append(condition);
      }
    }
  }
  if (item.getSecondary() != null) {
    b.append(""String_Node_Str"");
    b.append(item.getSecondary().toText());
  }
  return b.toString();
}",0.991074616208497
173341,"/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(NullAction action,String playerName){
  String errMsg=null;
  Player player=playerManager.getCurrentPlayer();
  while (true) {
    if (!playerName.equals(player.getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getId());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName));
  numPasses.add(1);
  if (numPasses.value() >= playerManager.getNumberOfPlayers()) {
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str""));
    for (    StartItem item : startPacket.getItems()) {
      if ((item.getStatus() == 2) && (item.getBasePrice() != 0)) {
        item.reduceBasePriceBy(10);
        ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",item.getId(),Bank.format(this,item.getBasePrice())));
      }
    }
    numPasses.set(0);
    if (startPacket.getFirstUnsoldItem().getBasePrice() == 0) {
      assignItem(playerManager.getCurrentPlayer(),startPacket.getFirstUnsoldItem(),0,0);
      getRoot().getPlayerManager().setPriorityPlayerToNext();
    }
 else {
      playerManager.setCurrentToNextPlayer();
    }
    numRoundsPassed.add(1);
  }
 else {
    playerManager.setCurrentToNextPlayer();
  }
  return true;
}","/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(NullAction action,String playerName){
  String errMsg=null;
  Player player=playerManager.getCurrentPlayer();
  while (true) {
    if (!playerName.equals(player.getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getId());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName));
  numPasses.add(1);
  if (numPasses.value() >= playerManager.getNumberOfPlayers()) {
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str""));
    for (    StartItem item : startPacket.getItems()) {
      if ((item.getStatus() == 2) && (item.getBasePrice() != 0)) {
        if (item.getBasePrice() >= 10) {
          item.reduceBasePriceBy(10);
        }
 else {
          item.reduceBasePriceBy(5);
        }
        ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",item.getId(),Bank.format(this,item.getBasePrice())));
      }
    }
    numPasses.set(0);
    numRoundsPassed.add(1);
    playerManager.setCurrentToNextPlayer();
    for (    StartItem unsoldItem : startPacket.getUnsoldItems()) {
      if (unsoldItem.getBasePrice() == 0) {
        assignItem(playerManager.getCurrentPlayer(),unsoldItem,0,0);
        playerManager.setCurrentToNextPlayer();
        getRoot().getPlayerManager().setPriorityPlayerToNext();
        resetStartPacketPrices(numRoundsPassed.value());
        numRoundsPassed.set(0);
        return true;
      }
    }
  }
 else {
    playerManager.setCurrentToNextPlayer();
  }
  return true;
}",0.8176795580110497
173342,"private void resetStartPacketPrices(int i){
  List<StartItem> startItems=startPacket.getItems();
  for (  StartItem item : startItems) {
    if ((!item.isSold()) && (item.getStatus() == StartItem.BUYABLE)) {
      item.reduceBasePriceBy(-(i * 10));
    }
  }
}","private void resetStartPacketPrices(int i){
  List<StartItem> startItems=startPacket.getItems();
  for (  StartItem item : startItems) {
    if ((!item.isSold()) && (item.getStatus() == StartItem.BUYABLE)) {
      item.reduceBasePriceBy(-(i * 10));
      if (item.getId() == ""String_Node_Str"") {
        item.reduceBasePriceBy(5);
      }
    }
  }
}",0.8524590163934426
173343,"public void closeInvestor(CloseInvestor_1880 action){
  String[] cashOptions=new String[2];
  cashOptions[0]=LocalText.getText(""String_Node_Str"",action.getInvestor().getCash(),action.getInvestor().getLinkedCompany().getId());
  cashOptions[1]=LocalText.getText(""String_Node_Str"",(action.getInvestor().getCash() / 5),action.getInvestor().getPresident());
  String cashChoice=(String)JOptionPane.showInputDialog(orWindow,LocalText.getText(""String_Node_Str"",action.getInvestor().getId()),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,cashOptions,cashOptions[0]);
  if (cashChoice == cashOptions[0]) {
    action.setTreasuryToLinkedCompany(true);
  }
 else {
    action.setTreasuryToLinkedCompany(false);
  }
  if (action.getInvestor().getLinkedCompany().getNumberOfFreeBaseTokens() > 0) {
    String[] tokenOptions=new String[2];
    tokenOptions[0]=LocalText.getText(""String_Node_Str"",action.getInvestor().getId(),action.getInvestor().getLinkedCompany().getId());
    tokenOptions[1]=LocalText.getText(""String_Node_Str"",action.getInvestor().getId(),action.getInvestor().getLinkedCompany().getId());
    String tokenChoice=(String)JOptionPane.showInputDialog(orWindow,LocalText.getText(""String_Node_Str""),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,tokenOptions,tokenOptions[0]);
    if (tokenChoice == tokenOptions[0]) {
      action.setReplaceToken(true);
    }
 else {
      action.setReplaceToken(false);
    }
  }
 else {
    action.setReplaceToken(false);
  }
  orWindow.process(action);
}","public void closeInvestor(CloseInvestor_1880 action){
  String[] cashOptions=new String[2];
  cashOptions[0]=LocalText.getText(""String_Node_Str"",action.getInvestor().getCash(),action.getInvestor().getLinkedCompany().getId());
  cashOptions[1]=LocalText.getText(""String_Node_Str"",(action.getInvestor().getCash() / 5),action.getInvestor().getPresident().getId());
  String cashChoice=(String)JOptionPane.showInputDialog(orWindow,LocalText.getText(""String_Node_Str"",action.getInvestor().getId()),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,cashOptions,cashOptions[0]);
  if (cashChoice == cashOptions[0]) {
    action.setTreasuryToLinkedCompany(true);
  }
 else {
    action.setTreasuryToLinkedCompany(false);
  }
  if (action.getInvestor().getLinkedCompany().getNumberOfFreeBaseTokens() > 0) {
    String[] tokenOptions=new String[2];
    tokenOptions[0]=LocalText.getText(""String_Node_Str"",action.getInvestor().getId(),action.getInvestor().getLinkedCompany().getId());
    tokenOptions[1]=LocalText.getText(""String_Node_Str"",action.getInvestor().getId(),action.getInvestor().getLinkedCompany().getId());
    String tokenChoice=(String)JOptionPane.showInputDialog(orWindow,LocalText.getText(""String_Node_Str""),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,tokenOptions,tokenOptions[0]);
    if (tokenChoice == tokenOptions[0]) {
      action.setReplaceToken(true);
    }
 else {
      action.setReplaceToken(false);
    }
  }
 else {
    action.setReplaceToken(false);
  }
  orWindow.process(action);
}",0.9974160206718348
173344,"private void setNextBiddingPlayer(){
  Player currentPlayer;
  do {
    currentPlayer=playerManager.setCurrentToNextPlayer();
  }
 while (((StartItem)currentAuctionItem.value()).getBid(currentPlayer) != 0);
}","private void setNextBiddingPlayer(){
  Player currentPlayer;
  do {
    currentPlayer=playerManager.setCurrentToNextPlayer();
  }
 while (((StartItem)currentAuctionItem.value()).isActive(currentPlayer) == false);
}",0.8672985781990521
173345,"/** 
 * The current player bids on a given start item.
 * @param playerName The name of the current player (for checking purposes).
 * @param itemName The name of the start item on which the bid is placed.
 * @param amount The bid amount.
 */
@Override protected boolean bid(String playerName,BidStartItem bidItem){
  StartItem item=bidItem.getStartItem();
  StartItem auctionedItem=(StartItem)currentAuctionItem.value();
  String errMsg=null;
  Player player=playerManager.getCurrentPlayer();
  int bidAmount=bidItem.getActualBid();
  while (true) {
    if (bidAmount == -1) {
      if (!bidItem.isSelectForAuction()) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
    }
 else {
      if ((currentStep.value() == OPEN_STEP || currentStep.value() == BID_STEP) && !item.equals(auctionedItem)) {
        errMsg=LocalText.getText(""String_Node_Str"",item.getId(),auctionedItem.getId());
        break;
      }
      if (bidAmount < item.getMinimumBid()) {
        errMsg=LocalText.getText(""String_Node_Str"",Bank.format(this,item.getMinimumBid()));
        break;
      }
      if (bidAmount % startPacket.getModulus() != 0) {
        errMsg=LocalText.getText(""String_Node_Str"",bidAmount,startPacket.getMinimumIncrement());
        break;
      }
      if (bidAmount > player.getCash()) {
        errMsg=LocalText.getText(""String_Node_Str"",Bank.format(this,bidAmount));
        break;
      }
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,item.getId(),errMsg));
    return false;
  }
  if (currentStep.value() == SELECT_STEP) {
    currentAuctionItem.set(item);
    item.setStatus(StartItem.AUCTIONED);
    for (    StartItem item2 : itemsToSell.view()) {
      if (item2 != item && !item2.isSold()) {
        item2.setStatus(StartItem.UNAVAILABLE);
      }
    }
    if (bidAmount == -1) {
      currentStep.set(OPEN_STEP);
    }
    ReportBuffer.add(this,""String_Node_Str"");
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,item.getId()));
  }
  if (bidAmount > 0) {
    item.setBid(bidAmount,player);
    item.setMinimumBid(bidAmount + 5);
    currentStep.set(BID_STEP);
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,Bank.format(this,bidAmount),item.getId()));
  }
switch (currentStep.value()) {
case OPEN_STEP:
case BUY_STEP:
    Player currentPlayer=playerManager.setCurrentToNextPlayer();
  if (currentPlayer == selectingPlayer.value()) {
    currentBuyPrice.add(-10);
    currentStep.set(BUY_STEP);
    if (currentBuyPrice.value() == 0) {
      assignItem(currentPlayer,item,0,0);
    }
  }
break;
case BID_STEP:
setNextBiddingPlayer();
}
return true;
}","/** 
 * The current player bids on a given start item.
 * @param playerName The name of the current player (for checking purposes).
 * @param itemName The name of the start item on which the bid is placed.
 * @param amount The bid amount.
 */
@Override protected boolean bid(String playerName,BidStartItem bidItem){
  StartItem item=bidItem.getStartItem();
  StartItem auctionedItem=(StartItem)currentAuctionItem.value();
  String errMsg=null;
  Player player=playerManager.getCurrentPlayer();
  int bidAmount=bidItem.getActualBid();
  while (true) {
    if (bidAmount == -1) {
      if (!bidItem.isSelectForAuction()) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
    }
 else {
      if ((currentStep.value() == OPEN_STEP || currentStep.value() == BID_STEP) && !item.equals(auctionedItem)) {
        errMsg=LocalText.getText(""String_Node_Str"",item.getId(),auctionedItem.getId());
        break;
      }
      if (bidAmount < item.getMinimumBid()) {
        errMsg=LocalText.getText(""String_Node_Str"",Bank.format(this,item.getMinimumBid()));
        break;
      }
      if (bidAmount % startPacket.getModulus() != 0) {
        errMsg=LocalText.getText(""String_Node_Str"",bidAmount,startPacket.getMinimumIncrement());
        break;
      }
      if (bidAmount > player.getCash()) {
        errMsg=LocalText.getText(""String_Node_Str"",Bank.format(this,bidAmount));
        break;
      }
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,item.getId(),errMsg));
    return false;
  }
  if (currentStep.value() == SELECT_STEP) {
    currentAuctionItem.set(item);
    item.setStatus(StartItem.AUCTIONED);
    item.setAllActive();
    for (    StartItem item2 : itemsToSell.view()) {
      if (item2 != item && !item2.isSold()) {
        item2.setStatus(StartItem.UNAVAILABLE);
      }
    }
    if (bidAmount == -1) {
      currentStep.set(OPEN_STEP);
    }
    ReportBuffer.add(this,""String_Node_Str"");
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,item.getId()));
  }
  if (bidAmount > 0) {
    item.setBid(bidAmount,player);
    item.setMinimumBid(bidAmount + 5);
    currentStep.set(BID_STEP);
    ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,Bank.format(this,bidAmount),item.getId()));
  }
switch (currentStep.value()) {
case OPEN_STEP:
case BUY_STEP:
    Player currentPlayer=playerManager.setCurrentToNextPlayer();
  if (currentPlayer == selectingPlayer.value()) {
    currentBuyPrice.add(-10);
    currentStep.set(BUY_STEP);
    if (currentBuyPrice.value() == 0) {
      assignItem(currentPlayer,item,0,0);
    }
  }
break;
case BID_STEP:
setNextBiddingPlayer();
}
return true;
}",0.9954069446996142
173346,"/** 
 * Get a list of buyable trains for the currently operating company. Omit trains that the company has no money for. If there is no cash to buy any train from the Bank, prepare for emergency train buying.
 */
public void setBuyableTrains(){
  if (operatingCompany.value() == null)   return;
  int cash=operatingCompany.value().getCash();
  int cost=0;
  Set<Train> trains;
  boolean hasTrains=operatingCompany.value().getPortfolioModel().getNumberOfTrains() > 0;
  if (cash == 0 && hasTrains)   return;
  boolean canBuyTrainNow=canBuyTrainNow();
  boolean mustBuyTrain=!hasTrains && operatingCompany.value().mustOwnATrain();
  boolean emergency=false;
  SortedMap<Integer,Train> newEmergencyTrains=new TreeMap<Integer,Train>();
  SortedMap<Integer,Train> usedEmergencyTrains=new TreeMap<Integer,Train>();
  if (getCurrentPhase().canBuyMoreTrainsPerTurn() || trainsBoughtThisTurn.isEmpty()) {
    boolean mayBuyMoreOfEachType=getCurrentPhase().canBuyMoreTrainsPerTypePerTurn();
    trains=trainManager.getAvailableNewTrains();
    for (    Train train : trains) {
      if (!operatingCompany.value().mayBuyTrainType(train))       continue;
      if (!mayBuyMoreOfEachType && trainsBoughtThisTurn.contains(train.getCertType())) {
        continue;
      }
      List<TrainType> types=train.getCertType().getPotentialTrainTypes();
      for (      TrainType type : types) {
        cost=type.getCost();
        if (cost <= cash) {
          if (canBuyTrainNow) {
            BuyTrain action=new BuyTrain(train,type,ipo.getParent(),cost);
            action.setForcedBuyIfNoRoute(mustBuyTrain);
            possibleActions.add(action);
          }
        }
 else         if (mustBuyTrain) {
          newEmergencyTrains.put(cost,train);
        }
      }
      if (train.canBeExchanged() && hasTrains) {
        cost=train.getCertType().getExchangeCost();
        if (cost <= cash) {
          Set<Train> exchangeableTrains=operatingCompany.value().getPortfolioModel().getUniqueTrains();
          BuyTrain action=new BuyTrain(train,ipo.getParent(),cost);
          action.setTrainsForExchange(exchangeableTrains);
          possibleActions.add(action);
          canBuyTrainNow=true;
        }
      }
      if (!canBuyTrainNow)       continue;
      for (      SpecialTrainBuy stb : getSpecialProperties(SpecialTrainBuy.class)) {
        int reducedPrice=stb.getPrice(cost);
        if (reducedPrice > cash)         continue;
        BuyTrain bt=new BuyTrain(train,ipo.getParent(),reducedPrice);
        bt.setSpecialProperty(stb);
        bt.setForcedBuyIfNoRoute(mustBuyTrain);
        possibleActions.add(bt);
      }
    }
    if (!canBuyTrainNow)     return;
    trains=pool.getUniqueTrains();
    for (    Train train : trains) {
      if (!mayBuyMoreOfEachType && trainsBoughtThisTurn.contains(train.getCertType())) {
        continue;
      }
      cost=train.getCost();
      if (cost <= cash) {
        BuyTrain bt=new BuyTrain(train,pool.getParent(),cost);
        bt.setForcedBuyIfNoRoute(mustBuyTrain);
        possibleActions.add(bt);
      }
 else       if (mustBuyTrain) {
        usedEmergencyTrains.put(cost,train);
      }
    }
    emergency=mustBuyTrain && possibleActions.getType(BuyTrain.class).isEmpty();
    if (emergency || getGameParameterAsBoolean(GameDef.Parm.EMERGENCY_MAY_ALWAYS_BUY_NEW_TRAIN) && !newEmergencyTrains.isEmpty()) {
      if (getGameParameterAsBoolean(GameDef.Parm.EMERGENCY_MUST_BUY_CHEAPEST_TRAIN)) {
        int cheapestTrainCost=newEmergencyTrains.firstKey();
        Train cheapestTrain=newEmergencyTrains.get(cheapestTrainCost);
        if (!usedEmergencyTrains.isEmpty() && usedEmergencyTrains.firstKey() < cheapestTrainCost) {
          cheapestTrainCost=usedEmergencyTrains.firstKey();
          cheapestTrain=usedEmergencyTrains.get(cheapestTrainCost);
        }
        BuyTrain bt=new BuyTrain(cheapestTrain,cheapestTrain.getOwner(),cheapestTrainCost);
        bt.setPresidentMustAddCash(cheapestTrainCost - cash);
        bt.setForcedBuyIfNoRoute(mustBuyTrain);
        possibleActions.add(bt);
      }
 else {
        for (        Train train : newEmergencyTrains.values()) {
          BuyTrain bt=new BuyTrain(train,ipo.getParent(),train.getCost());
          bt.setPresidentMustAddCash(train.getCost() - cash);
          bt.setForcedBuyIfNoRoute(mustBuyTrain);
          possibleActions.add(bt);
        }
        for (        Train train : usedEmergencyTrains.values()) {
          BuyTrain bt=new BuyTrain(train,pool.getParent(),train.getCost());
          bt.setPresidentMustAddCash(train.getCost() - cash);
          bt.setForcedBuyIfNoRoute(mustBuyTrain);
          possibleActions.add(bt);
        }
      }
    }
  }
  if (!canBuyTrainNow)   return;
  if (getCurrentPhase().isTrainTradingAllowed()) {
    BuyTrain bt;
    Player p;
    int index;
    int numberOfPlayers=playerManager.getNumberOfPlayers();
    int presidentCash=operatingCompany.value().getPresident().getCashValue();
    List<List<PublicCompany>> companiesPerPlayer=new ArrayList<List<PublicCompany>>(numberOfPlayers);
    for (int i=0; i < numberOfPlayers; i++)     companiesPerPlayer.add(new ArrayList<PublicCompany>(4));
    List<PublicCompany> companies;
    for (    PublicCompany c : getOperatingCompanies()) {
      if (c.isClosed() || c == operatingCompany.value())       continue;
      p=c.getPresident();
      index=p.getIndex();
      companiesPerPlayer.get(index).add(c);
    }
    int currentPlayerIndex=playerManager.getCurrentPlayer().getIndex();
    for (int i=currentPlayerIndex; i < currentPlayerIndex + numberOfPlayers; i++) {
      companies=companiesPerPlayer.get(i % numberOfPlayers);
      for (      PublicCompany company : companies) {
        trains=company.getPortfolioModel().getUniqueTrains();
        for (        Train train : trains) {
          if (train.isObsolete() || !train.isTradeable())           continue;
          bt=null;
          if (i != currentPlayerIndex && getGameParameterAsBoolean(GameDef.Parm.FIXED_PRICE_TRAINS_BETWEEN_PRESIDENTS) || operatingCompany.value().mustTradeTrainsAtFixedPrice() || company.mustTradeTrainsAtFixedPrice()) {
            if ((cash >= train.getCost()) && (operatingCompany.value().mayBuyTrainType(train))) {
              bt=new BuyTrain(train,company,train.getCost());
            }
 else {
              continue;
            }
          }
 else           if (cash > 0 || emergency && getGameParameterAsBoolean(GameDef.Parm.EMERGENCY_MAY_BUY_FROM_COMPANY)) {
            bt=new BuyTrain(train,company,0);
            if (emergency && cash < train.getCost()) {
              bt.setPresidentMayAddCash(Math.min(train.getCost() - cash,presidentCash));
            }
          }
          if (bt != null)           possibleActions.add(bt);
        }
      }
    }
  }
  if (!operatingCompany.value().mustOwnATrain() || operatingCompany.value().getPortfolioModel().getNumberOfTrains() > 0) {
    doneAllowed=true;
  }
}","/** 
 * Get a list of buyable trains for the currently operating company. Omit trains that the company has no money for. If there is no cash to buy any train from the Bank, prepare for emergency train buying.
 */
public void setBuyableTrains(){
  if (operatingCompany.value() == null)   return;
  int cash=operatingCompany.value().getCash();
  int cost=0;
  Set<Train> trains;
  boolean hasTrains=operatingCompany.value().getPortfolioModel().getNumberOfTrains() > 0;
  if (cash == 0 && hasTrains)   return;
  boolean canBuyTrainNow=canBuyTrainNow();
  boolean mustBuyTrain=!hasTrains && operatingCompany.value().mustOwnATrain();
  boolean emergency=false;
  SortedMap<Integer,Train> newEmergencyTrains=new TreeMap<Integer,Train>();
  SortedMap<Integer,Train> usedEmergencyTrains=new TreeMap<Integer,Train>();
  if (getCurrentPhase().canBuyMoreTrainsPerTurn() || trainsBoughtThisTurn.isEmpty()) {
    boolean mayBuyMoreOfEachType=getCurrentPhase().canBuyMoreTrainsPerTypePerTurn();
    trains=trainManager.getAvailableNewTrains();
    for (    Train train : trains) {
      if (!operatingCompany.value().mayBuyTrainType(train))       continue;
      if (!mayBuyMoreOfEachType && trainsBoughtThisTurn.contains(train.getCertType())) {
        continue;
      }
      List<TrainType> types=train.getCertType().getPotentialTrainTypes();
      for (      TrainType type : types) {
        cost=type.getCost();
        if (cost <= cash) {
          if (canBuyTrainNow) {
            BuyTrain action=new BuyTrain(train,type,ipo.getParent(),cost);
            action.setForcedBuyIfNoRoute(mustBuyTrain);
            possibleActions.add(action);
          }
        }
 else         if (mustBuyTrain) {
          newEmergencyTrains.put(cost,train);
        }
      }
      if (train.canBeExchanged() && hasTrains) {
        cost=train.getCertType().getExchangeCost();
        if (cost <= cash) {
          Set<Train> exchangeableTrains=operatingCompany.value().getPortfolioModel().getUniqueTrains();
          BuyTrain action=new BuyTrain(train,ipo.getParent(),cost);
          action.setTrainsForExchange(exchangeableTrains);
          possibleActions.add(action);
          canBuyTrainNow=true;
        }
      }
      if (!canBuyTrainNow)       continue;
      for (      SpecialTrainBuy stb : getSpecialProperties(SpecialTrainBuy.class)) {
        int reducedPrice=stb.getPrice(cost);
        if (reducedPrice > cash)         continue;
        BuyTrain bt=new BuyTrain(train,ipo.getParent(),reducedPrice);
        bt.setSpecialProperty(stb);
        bt.setForcedBuyIfNoRoute(mustBuyTrain);
        possibleActions.add(bt);
      }
    }
    if (!canBuyTrainNow)     return;
    trains=pool.getUniqueTrains();
    for (    Train train : trains) {
      if (!mayBuyMoreOfEachType && trainsBoughtThisTurn.contains(train.getCertType())) {
        continue;
      }
      cost=train.getCost();
      if (cost <= cash) {
        BuyTrain bt=new BuyTrain(train,pool.getParent(),cost);
        bt.setForcedBuyIfNoRoute(mustBuyTrain);
        possibleActions.add(bt);
      }
 else       if (mustBuyTrain) {
        usedEmergencyTrains.put(cost,train);
      }
    }
    emergency=mustBuyTrain && possibleActions.getType(BuyTrain.class).isEmpty();
    if (emergency || getGameParameterAsBoolean(GameDef.Parm.EMERGENCY_MAY_ALWAYS_BUY_NEW_TRAIN) && !newEmergencyTrains.isEmpty()) {
      if (getGameParameterAsBoolean(GameDef.Parm.EMERGENCY_MUST_BUY_CHEAPEST_TRAIN)) {
        int cheapestTrainCost=newEmergencyTrains.firstKey();
        Train cheapestTrain=newEmergencyTrains.get(cheapestTrainCost);
        if (!usedEmergencyTrains.isEmpty() && usedEmergencyTrains.firstKey() < cheapestTrainCost) {
          cheapestTrainCost=usedEmergencyTrains.firstKey();
          cheapestTrain=usedEmergencyTrains.get(cheapestTrainCost);
        }
        BuyTrain bt=new BuyTrain(cheapestTrain,cheapestTrain.getOwner(),cheapestTrainCost);
        bt.setPresidentMustAddCash(cheapestTrainCost - cash);
        bt.setForcedBuyIfNoRoute(mustBuyTrain);
        possibleActions.add(bt);
      }
 else {
        for (        Train train : newEmergencyTrains.values()) {
          BuyTrain bt=new BuyTrain(train,ipo.getParent(),train.getCost());
          bt.setPresidentMustAddCash(train.getCost() - cash);
          bt.setForcedBuyIfNoRoute(mustBuyTrain);
          possibleActions.add(bt);
        }
        for (        Train train : usedEmergencyTrains.values()) {
          BuyTrain bt=new BuyTrain(train,pool.getParent(),train.getCost());
          bt.setPresidentMustAddCash(train.getCost() - cash);
          bt.setForcedBuyIfNoRoute(mustBuyTrain);
          possibleActions.add(bt);
        }
      }
    }
  }
  if (!canBuyTrainNow)   return;
  if (getCurrentPhase().isTrainTradingAllowed()) {
    BuyTrain bt;
    Player p;
    int index;
    int numberOfPlayers=playerManager.getNumberOfPlayers();
    int presidentCash=operatingCompany.value().getPresident().getCashValue();
    List<List<PublicCompany>> companiesPerPlayer=new ArrayList<List<PublicCompany>>(numberOfPlayers);
    for (int i=0; i < numberOfPlayers; i++)     companiesPerPlayer.add(new ArrayList<PublicCompany>(4));
    List<PublicCompany> companies;
    for (    PublicCompany c : companyManager.getAllPublicCompanies()) {
      if (!c.hasFloated())       continue;
      if (c.isClosed() || c == operatingCompany.value())       continue;
      p=c.getPresident();
      index=p.getIndex();
      companiesPerPlayer.get(index).add(c);
    }
    int currentPlayerIndex=playerManager.getCurrentPlayer().getIndex();
    for (int i=currentPlayerIndex; i < currentPlayerIndex + numberOfPlayers; i++) {
      companies=companiesPerPlayer.get(i % numberOfPlayers);
      for (      PublicCompany company : companies) {
        trains=company.getPortfolioModel().getUniqueTrains();
        for (        Train train : trains) {
          if (train.isObsolete() || !train.isTradeable())           continue;
          bt=null;
          if (i != currentPlayerIndex && getGameParameterAsBoolean(GameDef.Parm.FIXED_PRICE_TRAINS_BETWEEN_PRESIDENTS) || operatingCompany.value().mustTradeTrainsAtFixedPrice() || company.mustTradeTrainsAtFixedPrice()) {
            if ((cash >= train.getCost()) && (operatingCompany.value().mayBuyTrainType(train))) {
              bt=new BuyTrain(train,company,train.getCost());
            }
 else {
              continue;
            }
          }
 else           if (cash > 0 || emergency && getGameParameterAsBoolean(GameDef.Parm.EMERGENCY_MAY_BUY_FROM_COMPANY)) {
            bt=new BuyTrain(train,company,0);
            if (emergency && cash < train.getCost()) {
              bt.setPresidentMayAddCash(Math.min(train.getCost() - cash,presidentCash));
            }
          }
          if (bt != null)           possibleActions.add(bt);
        }
      }
    }
  }
  if (!operatingCompany.value().mustOwnATrain() || operatingCompany.value().getPortfolioModel().getNumberOfTrains() > 0) {
    doneAllowed=true;
  }
}",0.9941108876759552
173347,"@Override public String getUpgradeText(){
  String text=null;
  if (action instanceof LayBaseToken) {
    text=""String_Node_Str"";
    if (action.getPotentialCost(hex.getHex()) != 0) {
      String cost=Bank.format(action.getCompany(),action.getPotentialCost(hex.getHex()));
      text+=LocalText.getText(""String_Node_Str"",cost);
    }
    if (action.getSpecialProperty() != null) {
      text+=""String_Node_Str"" + action.getSpecialProperty().getOriginalCompany().getId() + ""String_Node_Str"";
    }
    if (isValid() && !hasSingleSelection()) {
      text+=""String_Node_Str"";
      text+=hex.getHex().getConnectionString(selectedStop.getRelatedStation());
      text+=""String_Node_Str"";
    }
    text+=""String_Node_Str"";
  }
 else   if (action instanceof LayBonusToken) {
    BonusToken token=((LayBonusToken)action).getSpecialProperty().getToken();
    text=token.getId();
  }
  return text;
}","@Override public String getUpgradeText(){
  String text=null;
  if (action instanceof LayBaseToken) {
    text=""String_Node_Str"";
    if (action.getPotentialCost(hex.getHex()) != 0) {
      String cost=Bank.format(action.getCompany(),action.getPotentialCost(hex.getHex()));
      text+=LocalText.getText(""String_Node_Str"",cost);
    }
 else {
      text+=LocalText.getText(""String_Node_Str"");
    }
    if (action.getSpecialProperty() != null) {
      text+=""String_Node_Str"" + action.getSpecialProperty().getOriginalCompany().getId() + ""String_Node_Str"";
    }
    if (isValid() && !hasSingleSelection()) {
      text+=""String_Node_Str"";
      text+=hex.getHex().getConnectionString(selectedStop.getRelatedStation());
      text+=""String_Node_Str"";
    }
    text+=""String_Node_Str"";
  }
 else   if (action instanceof LayBonusToken) {
    BonusToken token=((LayBonusToken)action).getSpecialProperty().getToken();
    text=token.getId();
  }
  return text;
}",0.9654427645788336
173348,"@Override public int getPotentialCost(MapHex hex){
  if (hex == null) {
    return 0;
  }
 else {
    return company.getBaseTokenLayCost(hex);
  }
}","@Override public int getPotentialCost(MapHex hex){
  if (hex == null) {
    return 0;
  }
 else {
    if (specialProperty != null && ((SpecialBaseTokenLay)specialProperty).isFree()) {
      return 0;
    }
 else {
      return company.getBaseTokenLayCost(hex);
    }
  }
}",0.6904761904761905
173349,"@Override public boolean isSoldOut(){
  Owner owner;
  String name;
  if (""String_Node_Str"".equalsIgnoreCase(GameOption.getValue(this,""String_Node_Str""))) {
    for (    PublicCertificate cert : certificates.view()) {
      owner=cert.getOwner();
      name=cert.getName();
      if ((owner instanceof BankPortfolio || owner == cert.getCompany()) && (!name.equalsIgnoreCase(""String_Node_Str""))) {
        return false;
      }
    }
    return true;
  }
  return super.isSoldOut();
}","@Override public boolean isSoldOut(){
  if (!isBuyable())   return false;
  for (  PublicCertificate cert : certificates.view()) {
    Owner owner=cert.getOwner();
    if (owner instanceof BankPortfolio && owner != Bank.getUnavailable(this)) {
      return false;
    }
  }
  return true;
}",0.1940491591203104
173350,"/** 
 * @author Martin
 */
public PublicCompany_1835(RailsItem parent,String Id){
  super(parent,Id);
}","public PublicCompany_1835(RailsItem parent,String Id){
  super(parent,Id);
}",0.8491620111731844
173351,"/** 
 * @see rails.common.parser.ConfigurableComponent#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Tag tag) throws ConfigurationException {
  name=tag.getAttributeAsString(""String_Node_Str"");
  cost=tag.getAttributeAsInteger(""String_Node_Str"");
  majorStops=tag.getAttributeAsInteger(""String_Node_Str"");
  minorStops=tag.getAttributeAsInteger(""String_Node_Str"");
  Tag reachTag=tag.getChild(""String_Node_Str"");
  if (reachTag != null) {
    reachBasis=reachTag.getAttributeAsString(""String_Node_Str"",reachBasis);
    countTowns=reachTag.getAttributeAsString(""String_Node_Str"",countTowns);
  }
  Tag scoreTag=tag.getChild(""String_Node_Str"");
  if (scoreTag != null) {
    scoreTowns=scoreTag.getAttributeAsString(""String_Node_Str"",scoreTowns);
    scoreCities=scoreTag.getAttributeAsString(""String_Node_Str"",scoreCities);
  }
  countHexes=reachBasis.equals(""String_Node_Str"");
  townCountIndicator=countTowns.equals(""String_Node_Str"") ? NO_TOWN_COUNT : minorStops > 0 ? TOWN_COUNT_MINOR : TOWN_COUNT_MAJOR;
  cityScoreFactor=scoreCities.equals(""String_Node_Str"") ? 2 : 1;
  townScoreFactor=scoreTowns.equals(""String_Node_Str"") ? 1 : 0;
}","/** 
 * @see rails.common.parser.ConfigurableComponent#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Tag tag) throws ConfigurationException {
  name=tag.getAttributeAsString(""String_Node_Str"");
  cost=tag.getAttributeAsInteger(""String_Node_Str"");
  majorStops=tag.getAttributeAsInteger(""String_Node_Str"");
  minorStops=tag.getAttributeAsInteger(""String_Node_Str"");
  Tag reachTag=tag.getChild(""String_Node_Str"");
  if (reachTag != null) {
    reachBasis=reachTag.getAttributeAsString(""String_Node_Str"",reachBasis);
    countTowns=reachTag.getAttributeAsString(""String_Node_Str"",countTowns);
  }
  Tag scoreTag=tag.getChild(""String_Node_Str"");
  if (scoreTag != null) {
    scoreTowns=scoreTag.getAttributeAsString(""String_Node_Str"",scoreTowns);
    scoreCities=scoreTag.getAttributeAsString(""String_Node_Str"",scoreCities);
  }
  countHexes=reachBasis.equals(""String_Node_Str"");
  townCountIndicator=countTowns.equals(""String_Node_Str"") ? NO_TOWN_COUNT : minorStops > 0 ? TOWN_COUNT_MINOR : TOWN_COUNT_MAJOR;
  cityScoreFactor=scoreCities.equalsIgnoreCase(""String_Node_Str"") ? 2 : 1;
  townScoreFactor=scoreTowns.equalsIgnoreCase(""String_Node_Str"") ? 1 : 0;
}",0.9914748508098892
173352,"public void nextSelection(){
  if (activeUpgrade.hasSingleSelection()) {
  }
 else {
    activeUpgrade.nextSelection();
    upgradeToLabels.get(activeUpgrade).update();
    activeHex.update();
    SoundManager.notifyOfSelectUpgrade(activeUpgrade);
  }
}","public void nextSelection(){
  if (activeUpgrade == null || activeUpgrade.hasSingleSelection()) {
  }
 else {
    activeUpgrade.nextSelection();
    upgradeToLabels.get(activeUpgrade).update();
    activeHex.update();
    SoundManager.notifyOfSelectUpgrade(activeUpgrade);
  }
}",0.9529190207156308
173353,"/** 
 * Register a bid. <p> This method does <b>not</b> check off the amount of money that a player has available for bidding.
 * @param amount The bid amount.
 * @param bidder The bidding player.special amounts are 0 for 18EU as buy price, -1 as standard pass, -2 and below as pass in 18EU 
 */
public void setBid(int amount,Player bidder){
  if (amount == -1) {
    setPass(bidder);
  }
 else {
    int index=bidder.getIndex();
    bids[index].set(amount);
    bids[index].setSuppressZero(false);
    active[index]=true;
    lastBidderIndex.set(index);
    minimumBid.set(amount + 5);
  }
}","/** 
 * Register a bid. <p> This method does <b>not</b> check off the amount of money that a player has available for bidding.
 * @param amount The bid amount.
 * @param bidder The bidding player.amount of -1 indicates a pass 
 */
public void setBid(int amount,Player bidder){
  if (amount == -1) {
    setPass(bidder);
  }
 else   if (amount > 0) {
    int index=bidder.getIndex();
    bids[index].set(amount);
    bids[index].setSuppressZero(false);
    active[index]=true;
    lastBidderIndex.set(index);
    minimumBid.set(amount + 5);
  }
}",0.8830255057167986
173354,"public NetworkMultigraph getMultigraph(PublicCompany company,Collection<NetworkVertex> protectedVertices){
  return NetworkMultigraph.create(getRevenueGraph(company,protectedVertices),protectedVertices);
}","public NetworkMultigraph getMultigraph(PublicCompany company,Collection<NetworkVertex> protectedVertices){
  if (multiGraph == null) {
    multiGraph=NetworkMultigraph.create(getRevenueGraph(company,protectedVertices),protectedVertices);
    log.info(""String_Node_Str"");
  }
  return multiGraph;
}",0.7888446215139442
173355,"public NetworkGraph getMapGraph(){
  return NetworkGraph.createMapGraph(root);
}","public NetworkGraph getMapGraph(){
  mapGraph=NetworkGraph.createMapGraph(root);
  log.info(""String_Node_Str"");
  return mapGraph;
}",0.6981132075471698
173356,"public NetworkGraph getRevenueGraph(PublicCompany company,Collection<NetworkVertex> protectedVertices){
  return NetworkGraph.createOptimizedGraph(getRouteGraph(company,false),protectedVertices);
}","public NetworkGraph getRevenueGraph(PublicCompany company,Collection<NetworkVertex> protectedVertices){
  if (revenueGraph == null) {
    revenueGraph=NetworkGraph.createOptimizedGraph(getRouteGraphCached(company,false),protectedVertices);
    log.info(""String_Node_Str"");
  }
  return revenueGraph;
}",0.7630522088353414
173357,"public NetworkGraph getRouteGraph(PublicCompany company,boolean addHQ){
  return NetworkGraph.createRouteGraph(getMapGraph(),company,addHQ);
}","public NetworkGraph getRouteGraph(PublicCompany company,boolean addHQ){
  routeGraph=NetworkGraph.createRouteGraph(getMapGraph(),company,addHQ);
  this.company=company;
  this.addHQ=addHQ;
  log.info(""String_Node_Str"");
  return routeGraph;
}",0.7083333333333334
173358,"public void populateFromRails(){
  graph=networkAdapter.getRouteGraph(company,false);
  NetworkVertex.initAllRailsVertices(graph,company,phase);
  addStartVertices(graph.getCompanyBaseTokenVertexes(company));
  defineVertexVisitSets();
  defineRevenueBonuses();
  for (  Train train : company.getPortfolioModel().getTrainList()) {
    addTrain(train);
  }
  if (revenueManager != null) {
    revenueManager.initStaticModifiers(this);
  }
}","public void populateFromRails(){
  graph=networkAdapter.getRouteGraphCached(company,false);
  NetworkVertex.initAllRailsVertices(graph,company,phase);
  addStartVertices(graph.getCompanyBaseTokenVertexes(company));
  defineVertexVisitSets();
  defineRevenueBonuses();
  for (  Train train : company.getPortfolioModel().getTrainList()) {
    addTrain(train);
  }
  if (revenueManager != null) {
    revenueManager.initStaticModifiers(this);
  }
}",0.993212669683258
173359,"@Override public void resume(){
  PublicCompany prussian=companyManager.getPublicCompany(GameManager_1835.PR_ID);
  if (prussian.hasFloated() && !prussian.hasOperated() && operatingCompany.value() == companyManager.getPublicCompany(""String_Node_Str"")) {
    log.debug(""String_Node_Str"");
    int index=0;
    int operatingCompanyndex=getOperatingCompanyndex();
    for (    PublicCompany company : setOperatingCompanies()) {
      if (index > operatingCompanyndex && company.hasStockPrice() && company.hasFloated() && !company.isClosed() && company != operatingCompany.value() && company.getCurrentSpace().getPrice() < prussian.getCurrentSpace().getPrice()) {
        log.debug(""String_Node_Str"" + company.getId());
        break;
      }
      index++;
    }
    operatingCompanies.add(index,prussian);
    log.debug(""String_Node_Str"" + index);
  }
 else {
    log.debug(""String_Node_Str"");
  }
  guiHints.setCurrentRoundType(getClass());
  super.resume();
}","@Override public void resume(){
  PublicCompany prussian=companyManager.getPublicCompany(GameManager_1835.PR_ID);
  if (prussian.hasFloated() && !prussian.hasOperated() && operatingCompany.value() == companyManager.getPublicCompany(""String_Node_Str"")) {
    log.debug(""String_Node_Str"");
    int index=0;
    int operatingCompanyndex=getOperatingCompanyndex();
    for (    PublicCompany company : setOperatingCompanies()) {
      if (index > operatingCompanyndex && company.hasStockPrice() && company.hasFloated() && !company.isClosed() && company != operatingCompany.value() && company.getCurrentSpace().getPrice() < prussian.getCurrentSpace().getPrice()) {
        log.debug(""String_Node_Str"" + company.getId());
        break;
      }
      index++;
    }
    operatingCompanies.add(index,prussian);
    log.debug(""String_Node_Str"" + index);
  }
 else {
    log.debug(""String_Node_Str"");
  }
  if (operatingCompany.value().isClosed())   finishTurn();
  guiHints.setCurrentRoundType(getClass());
  super.resume();
}",0.970156803237228
173360,"/** 
 * Set the start item sold status.
 * @param sold The new sold status (usually true).
 */
public void setSold(Player player,int buyPrice){
  status.set(SOLD);
  lastBidder.set(player);
  for (  Player p : bids.keySet()) {
    CountingMoneyModel bid=bids.get(p);
    if (bid.value() > 0) {
      p.unblockCash(bid.value());
      if (p != player) {
        bid.set(0);
        bid.setSuppressZero(true);
      }
 else {
        bid.set(buyPrice);
      }
      active.get(p).set(false);
      ;
    }
  }
  minimumBid.set(0);
}","/** 
 * Set the start item sold status.
 * @param sold The new sold status (usually true).
 */
public void setSold(Player player,int buyPrice){
  status.set(SOLD);
  lastBidder.set(player);
  for (  Player p : bids.keySet()) {
    CountingMoneyModel bid=bids.get(p);
    if (bid.value() > 0) {
      p.unblockCash(bid.value());
      if (p != player) {
        bid.set(0);
        bid.setSuppressZero(true);
      }
      active.get(p).set(false);
      ;
    }
  }
  bids.get(player).set(buyPrice);
  minimumBid.set(0);
}",0.8641975308641975
173361,"@Override public void nextRound(Round round){
  if (round instanceof StartRound) {
    if (((StartRound)round).getStartPacket().areAllSold()) {
      beginStartRound();
    }
 else {
      startOperatingRound(runIfStartPacketIsNotCompletelySold());
    }
    numOfORs.set(10);
  }
 else   if (round instanceof StockRound) {
    relativeORNumber.set(1);
    orControl.startedFromStockRound();
    startOperatingRound(true);
  }
 else   if (round instanceof OperatingRound_1880) {
    if ((orControl.isFinalOperatingRoundSequence()) && (getRelativeORNumber() == 3)) {
      finishGame();
    }
 else     if (getRoot().getCompanyManager().getNextUnfinishedStartPacket() != null) {
      beginStartRound();
    }
 else     if (orControl.isExitingToStockRound() == true) {
      startStockRound();
    }
 else {
      orControl.startedFromOperatingRound();
      relativeORNumber.add(1);
      startOperatingRound(true);
    }
  }
}","@Override public void nextRound(Round round){
  if (round instanceof StartRound) {
    if (((StartRound)round).getStartPacket().areAllSold()) {
      beginStartRound();
    }
 else {
      startOperatingRound(runIfStartPacketIsNotCompletelySold());
    }
    numOfORs.set(10);
  }
 else   if (round instanceof StockRound) {
    relativeORNumber.set(1);
    orControl.startedFromStockRound();
    startOperatingRound(true);
  }
 else   if (round instanceof OperatingRound_1880) {
    if (orControl.getFinalOperatingRoundSequenceNumber() > 3) {
      finishGame();
    }
 else     if (getRoot().getCompanyManager().getNextUnfinishedStartPacket() != null) {
      beginStartRound();
    }
 else     if (orControl.isExitingToStockRound() == true) {
      startStockRound();
    }
 else {
      orControl.startedFromOperatingRound();
      relativeORNumber.add(1);
      startOperatingRound(true);
    }
  }
}",0.7678864008738394
173362,"public void setColorModel(final ColorModel colorModel){
  Observer colorObserver=new Observer(){
    public void update(    String text){
      if (colorModel.getBackground() != null) {
        Field.this.setBackground(colorModel.getBackground());
      }
      if (colorModel.getForeground() != null) {
        Field.this.setForeground(colorModel.getForeground());
      }
    }
    public Observable getObservable(){
      return colorModel;
    }
  }
;
  colorModel.addObserver(colorObserver);
  colorObserver.update(null);
}","public void setColorModel(ColorModel colorModel){
  final ColorModel storeModel=colorModel;
  colorObserver=new Observer(){
    public void update(    String text){
      if (storeModel.getBackground() != null) {
        setBackground(storeModel.getBackground());
      }
 else {
        setBackground(NORMAL_BG_COLOUR);
      }
      if (storeModel.getForeground() != null) {
        setForeground(storeModel.getForeground());
      }
    }
    public Observable getObservable(){
      return storeModel;
    }
  }
;
  colorModel.addObserver(colorObserver);
  colorObserver.update(null);
}",0.4400715563506261
173363,"public String getTypeId(){
  return certTypeId;
}","public String getTypeId(){
  String certTypeId=company.getId() + ""String_Node_Str"" + getShare()+ ""String_Node_Str"";
  if (president)   certTypeId+=""String_Node_Str"";
  return certTypeId;
}",0.4135021097046413
173364,"/** 
 * @param companyI
 */
public void setCompany(PublicCompany companyI){
  company=companyI;
  certTypeId=company.getId() + ""String_Node_Str"" + getShare()+ ""String_Node_Str"";
  if (president)   certTypeId+=""String_Node_Str"";
}","public void setCompany(PublicCompany companyI){
  company=companyI;
}",0.4630872483221476
173365,"/** 
 * @return
 */
public PublicCompany getCompany(){
  return company;
}","public PublicCompany getCompany(){
  return company;
}",0.84375
173366,"/** 
 * @param b
 */
public boolean isInitiallyAvailable(){
  return initiallyAvailable;
}","public boolean isInitiallyAvailable(){
  return initiallyAvailable;
}",0.8679245283018868
173367,"public PublicCompany getType(){
  return company;
}","@Override public PublicCompany getType(){
  return company;
}",0.9107142857142856
173368,"/** 
 * @param b
 */
public void setPresident(boolean b){
  president=b;
}","public void setPresident(boolean b){
  president=b;
}",0.8346456692913385
173369,"private List<NetworkVertex> extractExpressRun(RevenueTrainRun run,int length){
  if (!run.hasAValidRun())   return new ArrayList<NetworkVertex>();
  NetworkVertex baseVertex=run.getBaseVertex();
  List<NetworkVertex> otherVertices=new ArrayList<NetworkVertex>(run.getUniqueVertices());
  otherVertices.remove(baseVertex);
  Collections.sort(otherVertices);
  List<NetworkVertex> expressVertices=otherVertices.subList(0,Math.min(otherVertices.size(),length - 1));
  expressVertices.add(0,baseVertex);
  return expressVertices;
}","private List<NetworkVertex> extractExpressRun(RevenueTrainRun run,int length){
  if (!run.hasAValidRun())   return new ArrayList<NetworkVertex>();
  NetworkVertex baseVertex=run.getBaseVertex();
  List<NetworkVertex> otherVertices=new ArrayList<NetworkVertex>(run.getUniqueVertices());
  otherVertices.remove(baseVertex);
  Collections.sort(otherVertices,new NetworkVertex.ValueOrder());
  List<NetworkVertex> expressVertices=otherVertices.subList(0,Math.min(otherVertices.size(),length - 1));
  expressVertices.add(0,baseVertex);
  return expressVertices;
}",0.9714285714285714
173370,"public int evaluationValue(List<RevenueTrainRun> runs,boolean optimalRuns){
  int value=0;
  for (  RevenueTrainRun run : runs) {
    if ((run.getTrain().getRailsTrainType() != null) && (run.getTrain().getRailsTrainType().getCertificateType().getId().equals(""String_Node_Str""))) {
      if (optimalRuns)       log.debug(""String_Node_Str"" + run.getRunVertices());
      List<NetworkVertex> expressRun=extractExpressRun(run,6);
      if (optimalRuns)       log.debug(""String_Node_Str"" + expressRun);
      int expressRunValue=NetworkVertex.sum(expressRun);
      value+=expressRunValue - run.getRunValue();
    }
    if ((run.getTrain().getRailsTrainType() != null) && (run.getTrain().getRailsTrainType().getCertificateType().getId().equals(""String_Node_Str""))) {
      int expressRunValue=NetworkVertex.sum(extractExpressRun(run,8));
      value+=expressRunValue - run.getRunValue();
    }
  }
  return value;
}","public int evaluationValue(List<RevenueTrainRun> runs,boolean optimalRuns){
  int value=0;
  for (  RevenueTrainRun run : runs) {
    if ((run.getTrain().getRailsTrainType() != null) && (run.getTrain().getRailsTrainType().getCertificateType().getId().equals(""String_Node_Str""))) {
      if (optimalRuns)       log.debug(""String_Node_Str"" + run.getRunVertices());
      List<NetworkVertex> expressRun=extractExpressRun(run,6);
      if (optimalRuns)       log.debug(""String_Node_Str"" + expressRun);
      int expressRunValue=NetworkVertex.sum(expressRun);
      value+=expressRunValue - run.getRunValue();
    }
    if ((run.getTrain().getRailsTrainType() != null) && (run.getTrain().getRailsTrainType().getCertificateType().getId().equals(""String_Node_Str""))) {
      if (optimalRuns)       log.debug(""String_Node_Str"" + run.getRunVertices());
      List<NetworkVertex> expressRun=extractExpressRun(run,8);
      if (optimalRuns)       log.debug(""String_Node_Str"" + expressRun);
      int expressRunValue=NetworkVertex.sum(expressRun);
      value+=expressRunValue - run.getRunValue();
    }
  }
  return value;
}",0.8779041028175977
173371,"/** 
 * @return True if the map panel expected hex clicks for actions / corrections
 */
public boolean hexClicked(GUIHex clickedHex,GUIHex selectedHex,boolean rightClick){
  if (localStep == null) {
    return false;
  }
  if (selectedHex == clickedHex) {
switch (localStep) {
case SelectUpgrade:
      if (rightClick) {
        upgradePanel.nextUpgrade();
      }
 else {
        upgradePanel.nextSelection();
      }
    return true;
default :
  return false;
}
}
if (clickedHex == null) {
switch (localStep) {
case SelectUpgrade:
if (selectedHex != null) {
  map.selectHex(null);
}
setLocalStep(LocalSteps.SelectHex);
return true;
default :
return false;
}
}
if (hexUpgrades.contains(clickedHex)) {
switch (localStep) {
case SelectHex:
case SelectUpgrade:
map.selectHex(clickedHex);
setLocalStep(LocalSteps.SelectUpgrade);
return true;
default :
return false;
}
}
switch (localStep) {
case SelectHex:
case SelectUpgrade:
map.selectHex(null);
setLocalStep(LocalSteps.SelectHex);
return false;
default :
return false;
}
}","/** 
 * @return True if the map panel expected hex clicks for actions / corrections
 */
public boolean hexClicked(GUIHex clickedHex,GUIHex selectedHex,boolean rightClick){
  if (localStep == null) {
    return false;
  }
  if (selectedHex == clickedHex) {
switch (localStep) {
case SelectUpgrade:
      if (rightClick) {
        upgradePanel.nextUpgrade();
      }
 else {
        upgradePanel.nextSelection();
      }
    return true;
default :
  return false;
}
}
if (clickedHex == null) {
switch (localStep) {
case SelectUpgrade:
if (selectedHex != null) {
  map.selectHex(null);
}
setLocalStep(LocalSteps.SelectHex);
return true;
default :
return false;
}
}
if (hexUpgrades.containsVisible(clickedHex)) {
switch (localStep) {
case SelectHex:
case SelectUpgrade:
map.selectHex(clickedHex);
setLocalStep(LocalSteps.SelectUpgrade);
return true;
default :
return false;
}
}
switch (localStep) {
case SelectHex:
case SelectUpgrade:
map.selectHex(null);
setLocalStep(LocalSteps.SelectHex);
return false;
default :
return false;
}
}",0.9965870307167236
173372,"public NetworkMultigraph getMultigraph(PublicCompany company,Collection<NetworkVertex> protectedVertices){
  if (multiGraph == null) {
    multiGraph=NetworkMultigraph.create(getRevenueGraph(company,protectedVertices),protectedVertices);
    log.info(""String_Node_Str"");
  }
  return multiGraph;
}","public NetworkMultigraph getMultigraph(PublicCompany company,Collection<NetworkVertex> protectedVertices){
  return NetworkMultigraph.create(getRevenueGraph(company,protectedVertices),protectedVertices);
}",0.7888446215139442
173373,"public NetworkGraph getMapGraph(){
  if (mapGraph == null) {
    mapGraph=NetworkGraph.createMapGraph(root);
    log.info(""String_Node_Str"");
  }
  return mapGraph;
}","public NetworkGraph getMapGraph(){
  return NetworkGraph.createMapGraph(root);
}",0.6016260162601627
173374,"public NetworkGraph getRevenueGraph(PublicCompany company,Collection<NetworkVertex> protectedVertices){
  if (revenueGraph == null) {
    revenueGraph=NetworkGraph.createOptimizedGraph(getRouteGraph(company,false),protectedVertices);
    log.info(""String_Node_Str"");
  }
  return revenueGraph;
}","public NetworkGraph getRevenueGraph(PublicCompany company,Collection<NetworkVertex> protectedVertices){
  return NetworkGraph.createOptimizedGraph(getRouteGraph(company,false),protectedVertices);
}",0.7886178861788617
173375,"public NetworkGraph getRouteGraph(PublicCompany company,boolean addHQ){
  if (routeGraph == null || company != this.company || addHQ != this.addHQ) {
    routeGraph=NetworkGraph.createRouteGraph(getMapGraph(),company,addHQ);
    this.company=company;
    this.addHQ=addHQ;
    log.info(""String_Node_Str"");
  }
  return routeGraph;
}","public NetworkGraph getRouteGraph(PublicCompany company,boolean addHQ){
  return NetworkGraph.createRouteGraph(getMapGraph(),company,addHQ);
}",0.5738396624472574
173376,"public void saveGameStatus(){
  List<String> status=statusWindow.getGameStatus().getTextContents();
  JFileChooser jfc=new JFileChooser();
  String filename=saveDirectory + ""String_Node_Str"" + savePrefix+ ""String_Node_Str""+ saveDateTimeFormat.format(new Date())+ ""String_Node_Str"";
  File proposedFile=new File(filename);
  jfc.setSelectedFile(proposedFile);
  if (jfc.showSaveDialog(statusWindow) == JFileChooser.APPROVE_OPTION) {
    File selectedFile=jfc.getSelectedFile();
  }
  try {
    PrintWriter pw=new PrintWriter(filename);
    for (    String line : status)     pw.println(line);
    pw.close();
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"",e);
    getDisplayBuffer().add(LocalText.getText(""String_Node_Str"",e.getMessage()));
  }
}","public void saveGameStatus(){
  List<String> status=statusWindow.getGameStatus().getTextContents();
  JFileChooser jfc=new JFileChooser();
  String filename=saveDirectory + ""String_Node_Str"" + savePrefix+ ""String_Node_Str""+ saveDateTimeFormat.format(new Date())+ ""String_Node_Str"";
  File proposedFile=new File(filename);
  jfc.setSelectedFile(proposedFile);
  if (jfc.showSaveDialog(statusWindow) == JFileChooser.APPROVE_OPTION) {
    File selectedFile=jfc.getSelectedFile();
    try {
      PrintWriter pw=new PrintWriter(selectedFile);
      for (      String line : status)       pw.println(line);
      pw.close();
    }
 catch (    IOException e) {
      log.error(""String_Node_Str"",e);
      getDisplayBuffer().add(LocalText.getText(""String_Node_Str"",e.getMessage()));
    }
  }
}",0.813953488372093
173377,"public void informOnRedo(){
  ReportSet redoSet=futureReports.pollFirst();
  pastReports.addLast(redoSet);
}","@Override public void informOnRedo(){
  ReportSet redoSet=futureReports.pollFirst();
  pastReports.addLast(redoSet);
}",0.9557522123893806
173378,"public void informOnUndo(){
  ReportSet undoSet=pastReports.pollLast();
  futureReports.addFirst(undoSet);
}","@Override public void informOnUndo(){
  ReportSet undoSet=pastReports.pollLast();
  futureReports.addFirst(undoSet);
}",0.9557522123893806
173379,"public void updateOnClose(ChangeSet current){
  ReportSet currentSet=currentReportBuilder.build(current);
  pastReports.addLast(currentSet);
  futureReports.clear();
  currentText=getAsHtml(current);
  if (observer != null) {
    observer.update(currentText);
  }
  currentReportBuilder=ReportSet.builder();
}","@Override public void updateOnClose(){
  ChangeSet current=changeStack.getClosedChangeSet();
  ReportSet currentSet=currentReportBuilder.build(current);
  pastReports.addLast(currentSet);
  futureReports.clear();
  currentReportBuilder=ReportSet.builder();
  updateObserver();
}",0.5178875638841567
173380,"public String getCurrentText(){
  return currentText;
}","public String getCurrentText(){
  return getAsHtml(changeStack.getClosedChangeSet());
}",0.676056338028169
173381,void updateOnClose(ChangeSet current);,public void updateOnClose();,0.6363636363636364
173382,void informOnRedo();,public void informOnRedo();,0.851063829787234
173383,void informOnUndo();,public void informOnUndo();,0.851063829787234
173384,"/** 
 * Add ChangeReporter
 */
public void addChangeReporter(ChangeReporter reporter){
  this.reporter=reporter;
  log.debug(""String_Node_Str"" + reporter);
}","/** 
 * Add ChangeReporter
 */
public void addChangeReporter(ChangeReporter reporter){
  this.reporter=reporter;
  reporter.init(this);
  log.debug(""String_Node_Str"" + reporter);
}",0.9317507418397626
173385,"public void redo(int index){
  checkState(index > undoStack.size() && index <= undoStack.size() + redoStack.size(),""String_Node_Str"");
  ImmutableSet.Builder<State> states=ImmutableSet.builder();
  while (undoStack.size() < index) {
    states.addAll(executeRedo().getStates());
  }
  restart();
  updateObservers(states.build());
}","public void redo(int index){
  checkState(index > undoStack.size() && index <= undoStack.size() + redoStack.size(),""String_Node_Str"");
  ImmutableSet.Builder<State> states=ImmutableSet.builder();
  while (undoStack.size() < index) {
    states.addAll(executeRedo().getStates());
  }
  restart();
  updateObservers(states.build());
  if (reporter != null) {
    reporter.updateAfterUndoRedo();
  }
}",0.9095890410958904
173386,"/** 
 * Example: Undo-Stack has 4 elements (1,2,3,4), size = 4 Undo to index 2, requires removing the latest element, such that size = 3
 */
public void undo(int index){
  checkState(isUndoPossible() && index < undoStack.size(),""String_Node_Str"");
  ImmutableSet.Builder<State> states=ImmutableSet.builder();
  while (undoStack.size() > index) {
    states.addAll(executeUndo().getStates());
  }
  restart();
  updateObservers(states.build());
}","/** 
 * Example: Undo-Stack has 4 elements (1,2,3,4), size = 4 Undo to index 2, requires removing the latest element, such that size = 3
 */
public void undo(int index){
  checkState(isUndoPossible() && index < undoStack.size(),""String_Node_Str"");
  ImmutableSet.Builder<State> states=ImmutableSet.builder();
  while (undoStack.size() > index) {
    states.addAll(executeUndo().getStates());
  }
  restart();
  updateObservers(states.build());
  if (reporter != null) {
    reporter.updateAfterUndoRedo();
  }
}",0.9309623430962344
173387,"public void close(ChangeAction action){
  if (checkRequirementsForClose(action)) {
    int index=undoStack.size() + 1;
    ChangeSet closeSet=new ChangeSet(changeBuilder.build(),action,index);
    log.debug(""String_Node_Str"" + closeSet);
    undoStack.addLast(closeSet);
    redoStack.clear();
    if (reporter != null) {
      reporter.updateOnClose(closeSet);
    }
    restart();
    updateObservers(closeSet.getStates());
  }
}","public void close(ChangeAction action){
  if (checkRequirementsForClose(action)) {
    int index=undoStack.size() + 1;
    ChangeSet closeSet=new ChangeSet(changeBuilder.build(),action,index);
    log.debug(""String_Node_Str"" + closeSet);
    undoStack.addLast(closeSet);
    redoStack.clear();
    if (reporter != null) {
      reporter.updateOnClose();
    }
    restart();
    updateObservers(closeSet.getStates());
  }
}",0.990632318501171
173388,"public void updateOnClose(ChangeSet current){
}","@Override public void updateOnClose(){
}",0.6896551724137931
173389,"public void informOnRedo(){
}","@Override public void informOnRedo(){
}",0.8529411764705882
173390,"public void informOnUndo(){
}","@Override public void informOnUndo(){
}",0.8529411764705882
173391,"private void testUndoAfterClose(){
  assertTrue(state.value());
  changeStack.undo();
  assertEquals(2,changeStack.getCurrentIndex());
  assertSame(set_2,changeStack.getPreviousChangeSet());
  assertFalse(state.value());
  changeStack.undo();
  assertEquals(1,changeStack.getCurrentIndex());
  assertSame(set_1,changeStack.getPreviousChangeSet());
  assertTrue(state.value());
  try {
    changeStack.undo();
    failBecauseExceptionWasNotThrown(IllegalStateException.class);
  }
 catch (  Exception e) {
    assertThat(e).isInstanceOf(IllegalStateException.class);
  }
  assertEquals(1,changeStack.getCurrentIndex());
  assertSame(set_1,changeStack.getPreviousChangeSet());
  assertTrue(state.value());
}","private void testUndoAfterClose(){
  assertTrue(state.value());
  changeStack.undo();
  assertEquals(2,changeStack.getCurrentIndex());
  assertSame(set_2,changeStack.getClosedChangeSet());
  assertFalse(state.value());
  changeStack.undo();
  assertEquals(1,changeStack.getCurrentIndex());
  assertSame(set_1,changeStack.getClosedChangeSet());
  assertTrue(state.value());
  try {
    changeStack.undo();
    failBecauseExceptionWasNotThrown(IllegalStateException.class);
  }
 catch (  Exception e) {
    assertThat(e).isInstanceOf(IllegalStateException.class);
  }
  assertEquals(1,changeStack.getCurrentIndex());
  assertSame(set_1,changeStack.getClosedChangeSet());
  assertTrue(state.value());
}",0.9230769230769232
173392,"@Test public void testRedo(){
  changeStack.close(changeAction);
  changeStack.undo();
  changeStack.undo();
  changeStack.redo();
  assertEquals(2,changeStack.getCurrentIndex());
  assertSame(set_2,changeStack.getPreviousChangeSet());
  assertFalse(state.value());
  changeStack.redo();
  assertEquals(3,changeStack.getCurrentIndex());
  assertSame(set_3,changeStack.getPreviousChangeSet());
  assertTrue(state.value());
  try {
    changeStack.redo();
    failBecauseExceptionWasNotThrown(IllegalStateException.class);
  }
 catch (  Exception e) {
    assertThat(e).isInstanceOf(IllegalStateException.class);
  }
  assertEquals(3,changeStack.getCurrentIndex());
  assertSame(set_3,changeStack.getPreviousChangeSet());
  assertTrue(state.value());
  testUndoAfterClose();
}","@Test public void testRedo(){
  changeStack.close(changeAction);
  changeStack.undo();
  changeStack.undo();
  changeStack.redo();
  assertEquals(2,changeStack.getCurrentIndex());
  assertSame(set_2,changeStack.getClosedChangeSet());
  assertFalse(state.value());
  changeStack.redo();
  assertEquals(3,changeStack.getCurrentIndex());
  assertSame(set_3,changeStack.getClosedChangeSet());
  assertTrue(state.value());
  try {
    changeStack.redo();
    failBecauseExceptionWasNotThrown(IllegalStateException.class);
  }
 catch (  Exception e) {
    assertThat(e).isInstanceOf(IllegalStateException.class);
  }
  assertEquals(3,changeStack.getCurrentIndex());
  assertSame(set_3,changeStack.getClosedChangeSet());
  assertTrue(state.value());
  testUndoAfterClose();
}",0.9727626459143968
173393,"@Before public void setUp(){
  root=Root.create();
  changeStack=root.getStateManager().getChangeStack();
  changeAction=new ChangeActionImpl();
  state=BooleanState.create(root,STATE_ID,true);
  StateTestUtils.close(root);
  set_1=changeStack.getPreviousChangeSet();
  state.set(false);
  StateTestUtils.close(root);
  set_2=changeStack.getPreviousChangeSet();
  state.set(true);
  StateTestUtils.close(root);
  set_3=changeStack.getPreviousChangeSet();
}","@Before public void setUp(){
  root=Root.create();
  changeStack=root.getStateManager().getChangeStack();
  changeAction=new ChangeActionImpl();
  state=BooleanState.create(root,STATE_ID,true);
  StateTestUtils.close(root);
  set_1=changeStack.getClosedChangeSet();
  state.set(false);
  StateTestUtils.close(root);
  set_2=changeStack.getClosedChangeSet();
  state.set(true);
  StateTestUtils.close(root);
  set_3=changeStack.getClosedChangeSet();
}",0.9536423841059604
173394,"@Test public void testcloseAndNew(){
  changeStack.close(changeAction);
  assertSame(set_3,changeStack.getPreviousChangeSet());
  assertEquals(3,changeStack.getCurrentIndex());
}","@Test public void testcloseAndNew(){
  changeStack.close(changeAction);
  assertSame(set_3,changeStack.getClosedChangeSet());
  assertEquals(3,changeStack.getCurrentIndex());
}",0.9661016949152542
173395,"@Test public void testGetCurrentChangeSet(){
  assertSame(set_3,changeStack.getPreviousChangeSet());
  assertEquals(3,changeStack.getCurrentIndex());
}","@Test public void testGetCurrentChangeSet(){
  assertSame(set_3,changeStack.getClosedChangeSet());
  assertEquals(3,changeStack.getCurrentIndex());
}",0.96
173396,"public static ChangeSet getPreviousChangeSet(Root root){
  return root.getStateManager().getChangeStack().getPreviousChangeSet();
}","public static ChangeSet getPreviousChangeSet(Root root){
  return root.getStateManager().getChangeStack().getClosedChangeSet();
}",0.953846153846154
173397,"public boolean processOnReload(PossibleAction action){
  getRoot().getReportManager().getDisplayBuffer().clear();
  if (getRoot().getGameName().equals(""String_Node_Str"") && possibleActions.contains(RepayLoans.class) && (!possibleActions.contains(action.getClass()) || (action.getClass() == NullAction.class && ((NullAction)action).getMode() != NullAction.Mode.DONE))) {
    log.debug(""String_Node_Str"");
    getCurrentRound().process(new NullAction(NullAction.Mode.DONE));
    possibleActions.clear();
    getCurrentRound().setPossibleActions();
    if (!isGameOver())     setCorrectionActions();
  }
  log.debug(""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action);
  String playerName=getCurrentPlayer().getId();
  for (  PossibleAction a : possibleActions.getList()) {
    log.debug(playerName + ""String_Node_Str"" + a.toString());
  }
  if (!possibleActions.validate(action)) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",action.toString()));
    return false;
  }
  boolean doProcess=true;
  if (skipNextDone) {
    if (action instanceof NullAction && ((NullAction)action).getMode() == NullAction.Mode.DONE) {
      if (currentRound.value() instanceof OperatingRound && ((OperatingRound)currentRound.value()).getStep() == skippedStep) {
        doProcess=false;
      }
    }
  }
  skipNextDone=false;
  skippedStep=null;
  ChangeStack changeStack=getRoot().getStateManager().getChangeStack();
  if (doProcess && !processCorrectionActions(action) && !getCurrentRound().process(action)) {
    String msg=""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action.toString()+ ""String_Node_Str""+ getCurrentRound().getRoundName()+ ""String_Node_Str"";
    log.error(msg);
    DisplayBuffer.add(this,msg);
    return false;
  }
  possibleActions.clear();
  getCurrentRound().setPossibleActions();
  changeStack.close(action);
  if (!isGameOver())   setCorrectionActions();
  executedActions.add(action);
  log.debug(""String_Node_Str"" + getCurrentPlayer().getId());
  return true;
}","public boolean processOnReload(PossibleAction action){
  getRoot().getReportManager().getDisplayBuffer().clear();
  if (getRoot().getGameName().equals(""String_Node_Str"") && possibleActions.contains(RepayLoans.class) && (!possibleActions.contains(action.getClass()) || (action.getClass() == NullAction.class && ((NullAction)action).getMode() != NullAction.Mode.DONE))) {
    log.debug(""String_Node_Str"");
    getCurrentRound().process(new NullAction(NullAction.Mode.DONE));
    possibleActions.clear();
    getCurrentRound().setPossibleActions();
    if (!isGameOver())     setCorrectionActions();
  }
  log.debug(""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action);
  String playerName=getCurrentPlayer().getId();
  for (  PossibleAction a : possibleActions.getList()) {
    log.debug(playerName + ""String_Node_Str"" + a.toString());
  }
  if (!possibleActions.validate(action)) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",action.toString()));
    return false;
  }
  boolean doProcess=true;
  if (skipNextDone) {
    if (action instanceof NullAction && ((NullAction)action).getMode() == NullAction.Mode.DONE) {
      if (currentRound.value() instanceof OperatingRound && ((OperatingRound)currentRound.value()).getStep() == skippedStep) {
        doProcess=false;
      }
    }
  }
  skipNextDone=false;
  skippedStep=null;
  ChangeStack changeStack=getRoot().getStateManager().getChangeStack();
  if (doProcess && !processCorrectionActions(action) && !getCurrentRound().process(action)) {
    String msg=""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action.toString()+ ""String_Node_Str""+ getCurrentRound().getRoundName()+ ""String_Node_Str"";
    log.error(msg);
    DisplayBuffer.add(this,msg);
    return false;
  }
  executedActions.add(action);
  possibleActions.clear();
  getCurrentRound().setPossibleActions();
  changeStack.close(action);
  if (!isGameOver())   setCorrectionActions();
  log.debug(""String_Node_Str"" + getCurrentPlayer().getId());
  return true;
}",0.9847140039447732
173398,"public void paintTokensAndText(Graphics2D g){
  GUIGlobals.setRenderingHints(g);
  paintStationTokens(g);
  paintOffStationTokens(g);
  if (!isTilePainted())   return;
  FontMetrics fontMetrics=g.getFontMetrics();
  if (getHex().getTileCost() > 0) {
    g.drawString(Bank.format(getHex(),getHex().getTileCost()),dimensions.rectBound.x + (dimensions.rectBound.width - fontMetrics.stringWidth(Integer.toString(getHex().getTileCost()))) * 3 / 5,dimensions.rectBound.y + ((fontMetrics.getHeight() + dimensions.rectBound.height) * 9 / 15));
  }
  Map<PublicCompany,Stop> homes=getHex().getHomes();
  if (homes != null) {
    for (    PublicCompany company : homes.keySet()) {
      if (company.isClosed())       continue;
      if (hex.hasTokenOfCompany(company))       continue;
      Stop homeCity=homes.get(company);
      if (homeCity.getRelatedStation() == null) {
        Set<Stop> stops=getHex().getStops();
        for (        Stop stop : stops) {
          if (stop.hasTokenSlotsLeft()) {
            homeCity=stop;
            break;
          }
        }
      }
      HexPoint p=getTokenCenter(1,homeCity);
      drawHome(g,company,p);
    }
  }
  if (hex.isBlockedByPrivateCompany()) {
    PrivateCompany p=hex.getBlockingPrivateCompany();
    String text=""String_Node_Str"" + p.getId() + ""String_Node_Str"";
    g.drawString(text,dimensions.rectBound.x + (dimensions.rectBound.width - fontMetrics.stringWidth(text)) * 1 / 2,dimensions.rectBound.y + ((fontMetrics.getHeight() + dimensions.rectBound.height) * 5 / 15));
  }
  if (hex.isReservedForCompany() && hex.isPreprintedTileCurrent()) {
    String text=""String_Node_Str"" + hex.getReservedForCompany().getId() + ""String_Node_Str"";
    g.drawString(text,dimensions.rectBound.x + (dimensions.rectBound.width - fontMetrics.stringWidth(text)) * 1 / 2,dimensions.rectBound.y + ((fontMetrics.getHeight() + dimensions.rectBound.height) * 5 / 25));
  }
}","public void paintTokensAndText(Graphics2D g){
  GUIGlobals.setRenderingHints(g);
  paintStationTokens(g);
  paintOffStationTokens(g);
  if (!isTilePainted())   return;
  FontMetrics fontMetrics=g.getFontMetrics();
  if (getHex().getTileCost() > 0) {
    g.drawString(Bank.format(getHex(),getHex().getTileCost()),dimensions.rectBound.x + (dimensions.rectBound.width - fontMetrics.stringWidth(Integer.toString(getHex().getTileCost()))) * 3 / 5,dimensions.rectBound.y + ((fontMetrics.getHeight() + dimensions.rectBound.height) * 9 / 15));
  }
  Map<PublicCompany,Stop> homes=getHex().getHomes();
  if (homes != null) {
    for (    PublicCompany company : homes.keySet()) {
      if (company.isClosed())       continue;
      if (hex.hasTokenOfCompany(company))       continue;
      if (hex.getBlockedForTokenLays() == MapHex.BlockedToken.NEVER)       continue;
      Stop homeCity=homes.get(company);
      if (homeCity.getRelatedStation() == null) {
        Set<Stop> stops=getHex().getStops();
        for (        Stop stop : stops) {
          if (stop.hasTokenSlotsLeft()) {
            homeCity=stop;
            break;
          }
        }
      }
      HexPoint p=getTokenCenter(1,homeCity);
      drawHome(g,company,p);
    }
  }
  if (hex.isBlockedByPrivateCompany()) {
    PrivateCompany p=hex.getBlockingPrivateCompany();
    String text=""String_Node_Str"" + p.getId() + ""String_Node_Str"";
    g.drawString(text,dimensions.rectBound.x + (dimensions.rectBound.width - fontMetrics.stringWidth(text)) * 1 / 2,dimensions.rectBound.y + ((fontMetrics.getHeight() + dimensions.rectBound.height) * 5 / 15));
  }
  if (hex.isReservedForCompany() && hex.isPreprintedTileCurrent()) {
    String text=""String_Node_Str"" + hex.getReservedForCompany().getId() + ""String_Node_Str"";
    g.drawString(text,dimensions.rectBound.x + (dimensions.rectBound.width - fontMetrics.stringWidth(text)) * 1 / 2,dimensions.rectBound.y + ((fontMetrics.getHeight() + dimensions.rectBound.height) * 5 / 25));
  }
}",0.94229289561426
173399,"private PrivatesModel(RailsOwner parent,String id){
  super(parent,id);
  privates=PortfolioSet.create(parent,""String_Node_Str"",PrivateCompany.class);
}","private PrivatesModel(RailsOwner parent,String id){
  super(parent,id);
  privates=PortfolioSet.create(parent,""String_Node_Str"",PrivateCompany.class);
  privates.addModel(this);
}",0.918429003021148
173400,"private void defineTileUpgrades(List<LayTile> actions){
  for (  LayTile layTile : actions) {
switch (layTile.getType()) {
case (LayTile.GENERIC):
      addGenericTileLays(layTile);
    break;
case (LayTile.SPECIAL_PROPERTY):
  SpecialProperty sp=layTile.getSpecialProperty();
if (sp == null || !(sp instanceof SpecialTileLay) || ((SpecialTileLay)sp).requiresConnection()) {
  break;
}
case (LayTile.LOCATION_SPECIFIC):
if (layTile.getLocations() != null) {
addLocatedTileLays(layTile);
}
 else {
addGenericTileLays(layTile);
}
default :
}
}
}","private void defineTileUpgrades(List<LayTile> actions){
  for (  LayTile layTile : actions) {
switch (layTile.getType()) {
case (LayTile.GENERIC):
      addConnectedTileLays(layTile);
    break;
case (LayTile.SPECIAL_PROPERTY):
  SpecialTileLay sp=(SpecialTileLay)layTile.getSpecialProperty();
if (sp.requiresConnection()) {
  addConnectedTileLays(layTile);
}
 else {
  addLocatedTileLays(layTile);
}
break;
case (LayTile.LOCATION_SPECIFIC):
addLocatedTileLays(layTile);
break;
default :
}
}
}",0.6235521235521235
173401,"private void defineRevenueBonuses(){
  Set<MapHex> hexes=new HashSet<MapHex>();
  for (  NetworkVertex vertex : getVertices()) {
    MapHex hex=vertex.getHex();
    if (hex != null)     hexes.add(hex);
  }
  for (  MapHex hex : hexes) {
    List<RevenueBonusTemplate> bonuses=new ArrayList<RevenueBonusTemplate>();
    List<RevenueBonusTemplate> hexBonuses=hex.getRevenueBonuses();
    if (hexBonuses != null)     bonuses.addAll(hexBonuses);
    List<RevenueBonusTemplate> tileBonuses=hex.getCurrentTile().getRevenueBonuses();
    if (tileBonuses != null)     bonuses.addAll(tileBonuses);
    for (    RevenueBonusTemplate bonus : bonuses) {
      addRevenueBonus(bonus.toRevenueBonus(hex,root,graph));
    }
  }
  log.info(""String_Node_Str"" + revenueBonuses);
}","private void defineRevenueBonuses(){
  Set<MapHex> hexes=new HashSet<MapHex>();
  for (  NetworkVertex vertex : getVertices()) {
    MapHex hex=vertex.getHex();
    if (hex != null)     hexes.add(hex);
  }
  for (  MapHex hex : hexes) {
    List<RevenueBonusTemplate> bonuses=new ArrayList<RevenueBonusTemplate>();
    List<RevenueBonusTemplate> hexBonuses=hex.getRevenueBonuses();
    if (hexBonuses != null)     bonuses.addAll(hexBonuses);
    List<RevenueBonusTemplate> tileBonuses=hex.getCurrentTile().getRevenueBonuses();
    if (tileBonuses != null)     bonuses.addAll(tileBonuses);
    for (    RevenueBonusTemplate bonus : bonuses) {
      RevenueBonus bonusConverted=bonus.toRevenueBonus(hex,root,graph);
      if (bonusConverted != null) {
        addRevenueBonus(bonusConverted);
      }
    }
  }
  log.info(""String_Node_Str"" + revenueBonuses);
}",0.9185185185185184
173402,"public RevenueBonus toRevenueBonus(MapHex hex,RailsRoot root,NetworkGraph graph){
  log.info(""String_Node_Str"" + this);
  RevenueBonus bonus=new RevenueBonus(value,name);
  if (!convertVertices(bonus,graph,hex)) {
    log.info(""String_Node_Str"");
    return null;
  }
  convertTrainTypes(bonus,root.getTrainManager());
  convertPhases(bonus,root.getPhaseManager());
  log.info(""String_Node_Str"" + bonus);
  return bonus;
}","public RevenueBonus toRevenueBonus(MapHex hex,RailsRoot root,NetworkGraph graph){
  log.info(""String_Node_Str"" + this);
  RevenueBonus bonus=new RevenueBonus(value,name);
  if (!convertVertices(bonus,graph,hex)) {
    log.warn(""String_Node_Str"" + this.toString());
    return null;
  }
  convertTrainTypes(bonus,root.getTrainManager());
  convertPhases(bonus,root.getPhaseManager());
  log.info(""String_Node_Str"" + bonus);
  return bonus;
}",0.9698375870069604
173403,"/** 
 * Returns one train of any type held 
 */
public Set<Train> getUniqueTrains(){
  Set<Train> trainsFound=new HashSet<Train>();
  Map<TrainType,Object> trainTypesFound=new HashMap<TrainType,Object>();
  for (  Train train : trains.getPortfolio()) {
    if (!trainTypesFound.containsKey(train.getType())) {
      trainsFound.add(train);
      trainTypesFound.put(train.getType(),null);
    }
  }
  return trainsFound;
}","/** 
 * Returns one train of any type held 
 */
public Set<Train> getUniqueTrains(){
  ImmutableSortedSet.Builder<Train> trainsFound=ImmutableSortedSet.naturalOrder();
  Set<TrainType> trainTypesFound=Sets.newHashSet();
  for (  Train train : trains.getPortfolio()) {
    if (!trainTypesFound.contains(train.getType())) {
      trainsFound.add(train);
      trainTypesFound.add(train.getType());
    }
  }
  return trainsFound.build();
}",0.3003492433061699
173404,"@Override protected boolean equalsAs(PossibleAction pa,boolean asOption){
  if (pa == this)   return true;
  if (!super.equalsAs(pa,asOption))   return false;
  DiscardTrain action=(DiscardTrain)pa;
  boolean options=Objects.equal(this.ownedTrains,action.ownedTrains) && Objects.equal(this.forced,action.forced);
  if (asOption)   return options;
  return options && Objects.equal(this.discardedTrain,action.discardedTrain);
}","@Override protected boolean equalsAs(PossibleAction pa,boolean asOption){
  if (pa == this)   return true;
  if (!super.equalsAs(pa,asOption))   return false;
  DiscardTrain action=(DiscardTrain)pa;
  boolean options=Objects.equal(this.getOwnedTrainTypes(),action.getOwnedTrainTypes()) && Objects.equal(this.forced,action.forced);
  if (asOption)   return options;
  return options && Objects.equal(this.discardedTrain.getType(),action.discardedTrain.getType());
}",0.9483146067415732
173405,"private static String prepareTestGame(File gameFile,boolean overrideReport){
  if (!gameFile.exists() || !gameFile.isFile())   return null;
  String fileName=gameFile.getName();
  int dot=fileName.lastIndexOf(extensionSeparator);
  String gameName=null;
  if (dot != -1 && fileName.substring(dot + 1).equals(Config.get(""String_Node_Str""))) {
    gameName=fileName.substring(0,dot);
    String gamePath=gameFile.getParent();
    String reportFilename=gamePath + File.separator + gameName+ ""String_Node_Str""+ Config.get(""String_Node_Str"");
    File reportFile=new File(reportFilename);
    if (!reportFile.exists() || overrideReport)     prepareGameReport(gameFile,reportFilename);
  }
  return gameName;
}","private static String prepareTestGame(File gameFile,boolean overrideReport){
  if (!gameFile.exists() || !gameFile.isFile())   return null;
  String fileName=gameFile.getName();
  int dot=fileName.lastIndexOf(extensionSeparator);
  String gameName=null;
  if (dot != -1 && fileName.substring(dot + 1).equals(Config.get(""String_Node_Str""))) {
    gameName=fileName.substring(0,dot);
    String gamePath=gameFile.getParent();
    String reportFilename=gamePath + File.separator + gameName+ ""String_Node_Str""+ Config.get(""String_Node_Str"");
    File reportFile=new File(reportFilename);
    if (!reportFile.exists() || overrideReport) {
      prepareGameReport(gameFile,reportFilename);
      RailsRoot.clearInstance();
    }
  }
  return gameName;
}",0.9703652653342524
173406,"public void hyperlinkUpdate(HyperlinkEvent e){
  if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
    activateTimeWarp();
    URL url=e.getURL();
    int index=url.getPort();
    gotoIndex(index + 1);
    toFront();
  }
}","public void hyperlinkUpdate(HyperlinkEvent e){
  if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
    activateTimeWarp();
    URL url=e.getURL();
    int index=url.getPort();
    gotoIndex(index);
    toFront();
  }
}",0.9913793103448276
173407,"private boolean validate(){
  invalids.clear();
  allowed.addAll(stops);
  if (!(action instanceof LayBonusToken || hex.getHex().isHomeFor(action.getCompany()))) {
    if (hexBlocked()) {
      invalids.add(Invalids.HEX_BLOCKED);
    }
    if (hexReserved()) {
      invalids.add(Invalids.HEX_RESERVED);
    }
  }
  selectedStop=allowed.first();
  return invalids.isEmpty();
}","private boolean validate(){
  invalids.clear();
  allowed.addAll(stops);
  if (!(action instanceof LayBonusToken || hex.getHex().isHomeFor(action.getCompany()))) {
    if (hexBlocked()) {
      invalids.add(Invalids.HEX_BLOCKED);
    }
    if (hexReserved()) {
      invalids.add(Invalids.HEX_RESERVED);
    }
  }
  if (allowed.isEmpty() || !invalids.isEmpty()) {
    selectedStop=null;
    return false;
  }
 else {
    selectedStop=allowed.first();
    return true;
  }
}",0.8362779740871613
173408,"public void finishConfiguration(RailsRoot root,int sortingDigits) throws ConfigurationException {
  try {
    int externalNb=Integer.parseInt(externalId);
    NumberFormat nf=NumberFormat.getInstance();
    nf.setMinimumIntegerDigits(sortingDigits);
    sortingId=nf.format(externalNb);
  }
 catch (  NumberFormatException e) {
    sortingId=externalId;
  }
  for (  TileUpgrade upgrade : upgrades) {
    upgrade.finishConfiguration(root);
  }
}","public void finishConfiguration(RailsRoot root,int sortingDigits) throws ConfigurationException {
  prepainted=true;
  try {
    int externalNb=Integer.parseInt(externalId);
    NumberFormat nf=NumberFormat.getInstance();
    nf.setMinimumIntegerDigits(sortingDigits);
    sortingId=nf.format(externalNb);
    if (externalNb > 0) {
      prepainted=false;
    }
  }
 catch (  NumberFormatException e) {
    sortingId=externalId;
  }
  for (  TileUpgrade upgrade : upgrades) {
    upgrade.finishConfiguration(root);
  }
}",0.922279792746114
173409,"public boolean isTilePainted(Tile tile){
  return !displayMapImage || (tile.getColour().getNumber() >= TileColour.YELLOW.getNumber());
}","public boolean isTilePainted(Tile tile){
  return !(displayMapImage && tile.isPrepainted());
}",0.7130434782608696
173410,"@Override public int compare(MapUpgrade u1,MapUpgrade u2){
  if (u1 instanceof TileHexUpgrade && u2 instanceof TileHexUpgrade) {
    Tile t1=((TileHexUpgrade)u1).getUpgrade().getTargetTile();
    Tile t2=((TileHexUpgrade)u2).getUpgrade().getTargetTile();
    return t1.compareTo(t2);
  }
  return 0;
}","@Override public int compare(MapUpgrade u1,MapUpgrade u2){
  if (u1 instanceof TileHexUpgrade && u2 instanceof TileHexUpgrade) {
    TileHexUpgrade tu1=(TileHexUpgrade)u1;
    TileHexUpgrade tu2=(TileHexUpgrade)u2;
    return ComparisonChain.start().compare(tu1.getAction(),tu2.getAction()).compare(tu1.getUpgrade().getTargetTile(),tu2.getUpgrade().getTargetTile()).compare(tu1.getLocation().getId(),tu2.getLocation().getId()).result();
  }
  return 0;
}",0.5059602649006623
173411,"@Override public Comparator<MapUpgrade> getComparator(){
  return new Comparator<MapUpgrade>(){
    @Override public int compare(    MapUpgrade u1,    MapUpgrade u2){
      if (u1 instanceof TileHexUpgrade && u2 instanceof TileHexUpgrade) {
        Tile t1=((TileHexUpgrade)u1).getUpgrade().getTargetTile();
        Tile t2=((TileHexUpgrade)u2).getUpgrade().getTargetTile();
        return t1.compareTo(t2);
      }
      return 0;
    }
  }
;
}","@Override public Comparator<MapUpgrade> getComparator(){
  return new Comparator<MapUpgrade>(){
    @Override public int compare(    MapUpgrade u1,    MapUpgrade u2){
      if (u1 instanceof TileHexUpgrade && u2 instanceof TileHexUpgrade) {
        TileHexUpgrade tu1=(TileHexUpgrade)u1;
        TileHexUpgrade tu2=(TileHexUpgrade)u2;
        return ComparisonChain.start().compare(tu1.getAction(),tu2.getAction()).compare(tu1.getUpgrade().getTargetTile(),tu2.getUpgrade().getTargetTile()).compare(tu1.getLocation().getId(),tu2.getLocation().getId()).result();
      }
      return 0;
    }
  }
;
}",0.697986577181208
173412,"private String labelText(Tile tile,boolean vertical){
  StringBuffer text=new StringBuffer();
  text.append(""String_Node_Str"" + tile.toText());
  if (!tile.isUnlimited()) {
    if (vertical) {
      text.append(""String_Node_Str"");
    }
 else {
      text.append(""String_Node_Str"");
    }
    text.append(""String_Node_Str"" + tile.getFreeCount() + ""String_Node_Str"");
  }
  text.append(""String_Node_Str"");
  return text.toString();
}","private String labelText(TileHexUpgrade upgrade,boolean vertical){
  Tile tile=upgrade.getUpgrade().getTargetTile();
  StringBuilder text=new StringBuilder();
  text.append(""String_Node_Str"" + tile.toText());
  if (!tile.isUnlimited()) {
    if (vertical) {
      text.append(""String_Node_Str"");
    }
 else {
      text.append(""String_Node_Str"");
    }
    text.append(""String_Node_Str"" + tile.getFreeCount() + ""String_Node_Str"");
  }
  LayTile action=upgrade.getAction();
  if (action.getSpecialProperty() != null) {
    text.append(""String_Node_Str"" + action.getSpecialProperty().getOriginalCompany().getId() + ""String_Node_Str"");
  }
  text.append(""String_Node_Str"");
  return text.toString();
}",0.6472148541114059
173413,"private UpgradeLabel(ImageIcon hexIcon,TileHexUpgrade upgrade,String toolTipHeaderLine,String toolTipBody){
  super(hexIcon);
  this.upgrade=upgrade;
  Tile tile=upgrade.getUpgrade().getTargetTile();
  this.setText(labelText(tile,true));
  this.setToolTipText(toolTipText(tile,toolTipHeaderLine,toolTipBody));
  this.setOpaque(true);
  this.setVisible(true);
  this.setBorder(BORDER);
}","private UpgradeLabel(ImageIcon hexIcon,TileHexUpgrade upgrade,String toolTipHeaderLine,String toolTipBody){
  super(hexIcon);
  this.upgrade=upgrade;
  Tile tile=upgrade.getUpgrade().getTargetTile();
  this.setText(labelText(upgrade,true));
  this.setToolTipText(toolTipText(tile,toolTipHeaderLine,toolTipBody));
  this.setOpaque(true);
  this.setVisible(true);
  this.setBorder(BORDER);
}",0.9883870967741936
173414,"public void selectHex(GUIHex clickedHex){
  log.debug(""String_Node_Str"" + (clickedHex != null ? clickedHex.toText() : ""String_Node_Str"") + ""String_Node_Str""+ (selectedHex != null ? selectedHex.toText() : ""String_Node_Str""));
  if (selectedHex == clickedHex)   return;
  if (selectedHex != null) {
    selectedHex.setState(GUIHex.State.SELECTED);
  }
  if (clickedHex != null) {
    clickedHex.setState(GUIHex.State.SELECTED);
  }
  selectedHex=clickedHex;
}","public void selectHex(GUIHex clickedHex){
  log.debug(""String_Node_Str"" + (clickedHex != null ? clickedHex.toText() : ""String_Node_Str"") + ""String_Node_Str""+ (selectedHex != null ? selectedHex.toText() : ""String_Node_Str""));
  if (selectedHex == clickedHex)   return;
  if (selectedHex != null) {
    selectedHex.setState(GUIHex.State.SELECTABLE);
  }
  if (clickedHex != null) {
    clickedHex.setState(GUIHex.State.SELECTED);
  }
  selectedHex=clickedHex;
}",0.9934497816593888
173415,"public void startPrussianFormationRound(OperatingRound_1835 or){
  interruptedRound=or;
  String roundName;
  if (interruptedRound == null) {
    roundName=""String_Node_Str"" + previousRound.getId();
  }
 else {
    roundName=""String_Node_Str"" + or.getId();
  }
  createRound(PrussianFormationRound.class,roundName).start();
}","public void startPrussianFormationRound(OperatingRound_1835 or){
  interruptedRound=or;
  String roundName;
  if (interruptedRound == null) {
    roundName=""String_Node_Str"" + previousRound.getId();
  }
 else {
    roundName=""String_Node_Str"" + or.getId() + ""String_Node_Str""+ getCurrentPhase().getId();
  }
  createRound(PrussianFormationRound.class,roundName).start();
}",0.932568149210904
173416,"protected void disableButtons(){
  bidButton.setEnabled(false);
  buyButton.setEnabled(false);
  passButton.setEnabled(false);
}","protected void disableButtons(){
  if (includeBidding) {
    bidButton.setEnabled(false);
  }
  buyButton.setEnabled(false);
  passButton.setEnabled(false);
}",0.8951048951048951
173417,"private boolean trainTypeCanAffectOR(TrainType type){
  if ((type.getName().equals(""String_Node_Str"") == false) && (type.getName().equals(""String_Node_Str"") == false) && (type.getName().equals(""String_Node_Str""))) {
    return true;
  }
  return false;
}","private boolean trainTypeCanAffectOR(TrainType type){
  if ((type.getName().equals(""String_Node_Str"") == false) && (type.getName().equals(""String_Node_Str"") == false) && (type.getName().equals(""String_Node_Str"") == false)) {
    return true;
  }
  return false;
}",0.9825918762088974
173418,"private boolean trainTypeCanAffectOR(TrainType type){
  if ((type.getName().equals(""String_Node_Str"") == false) && (type.getName().equals(""String_Node_Str"") == false) && (type.getName().equals(""String_Node_Str""))) {
    return true;
  }
  return false;
}","private boolean trainTypeCanAffectOR(TrainType type){
  if ((type.getName().equals(""String_Node_Str"") == false) && (type.getName().equals(""String_Node_Str"") == false) && (type.getName().equals(""String_Node_Str"") == false)) {
    return true;
  }
  return false;
}",0.9825918762088974
173419,"public void actionPerformed(ActionEvent actor){
  JComponent source=(JComponent)actor.getSource();
  List<PossibleAction> actions;
  PossibleAction chosenAction=null;
  if (source instanceof ClickField) {
    gbc=gb.getConstraints(source);
    actions=((ClickField)source).getPossibleActions();
    SoundManager.notifyOfClickFieldSelection(actions.get(0));
    SoundManager.notifyOfClickFieldSelection(actions.get(0));
    log.debug(""String_Node_Str"" + actions.get(0).toString());
    if (actions == null || actions.size() == 0) {
      log.warn(""String_Node_Str"");
    }
 else     if (actions.get(0) instanceof SellShares) {
      List<String> options=new ArrayList<String>();
      List<SellShares> sellActions=new ArrayList<SellShares>();
      List<Integer> sellAmounts=new ArrayList<Integer>();
      SellShares sale;
      for (      PossibleAction action : actions) {
        sale=(SellShares)action;
        int i=sale.getNumber();
        if (sale.getPresidentExchange() == 0) {
          options.add(LocalText.getText(""String_Node_Str"",i,sale.getShare(),i * sale.getShare(),sale.getCompanyName(),gameUIManager.format(i * sale.getShareUnits() * sale.getPrice())));
        }
 else {
          options.add(LocalText.getText(""String_Node_Str"",i,sale.getShare(),i * sale.getShare(),sale.getCompanyName(),gameUIManager.format(i * sale.getShareUnits() * sale.getPrice()),3 - sale.getPresidentExchange(),sale.getPresidentExchange() * sale.getShareUnit()));
        }
        sellActions.add(sale);
        sellAmounts.add(i);
      }
      int index=0;
      if (options.size() > 1) {
        String message=LocalText.getText(""String_Node_Str"");
        String sp=(String)JOptionPane.showInputDialog(this,message,message,JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
        index=options.indexOf(sp);
      }
 else       if (options.size() == 1) {
        String message=LocalText.getText(""String_Node_Str"");
        int result=JOptionPane.showConfirmDialog(this,options.get(0),message,JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
        index=(result == JOptionPane.OK_OPTION ? 0 : -1);
      }
      if (index < 0) {
      }
 else {
        chosenAction=sellActions.get(index);
      }
    }
 else     if (actions.get(0) instanceof BuyCertificate) {
      boolean startCompany=false;
      List<String> options=new ArrayList<String>();
      List<BuyCertificate> buyActions=new ArrayList<BuyCertificate>();
      List<Integer> buyAmounts=new ArrayList<Integer>();
      BuyCertificate buy;
      String companyName=""String_Node_Str"";
      String playerName=""String_Node_Str"";
      int sharePerCert;
      int sharesPerCert;
      int shareUnit;
      for (      PossibleAction action : actions) {
        buy=(BuyCertificate)action;
        playerName=buy.getPlayerName();
        PublicCompany company=buy.getCompany();
        companyName=company.getId();
        sharePerCert=buy.getSharePerCertificate();
        shareUnit=company.getShareUnit();
        sharesPerCert=sharePerCert / shareUnit;
        if (buy instanceof StartCompany) {
          startCompany=true;
          int[] startPrices;
          if (((StartCompany)buy).mustSelectAPrice()) {
            startPrices=((StartCompany)buy).getStartPrices();
            Arrays.sort(startPrices);
            if (startPrices.length > 1) {
              for (int i=0; i < startPrices.length; i++) {
                options.add(LocalText.getText(""String_Node_Str"",gameUIManager.format(startPrices[i]),sharePerCert,gameUIManager.format(sharesPerCert * startPrices[i])));
                buyActions.add(buy);
                buyAmounts.add(startPrices[i]);
              }
            }
 else {
              options.add(LocalText.getText(""String_Node_Str"",companyName,company.getPresidentsShare().getShare(),gameUIManager.format(company.getPresidentsShare().getShares() * startPrices[0])));
              buyActions.add(buy);
              buyAmounts.add(startPrices[0]);
            }
          }
 else {
            startPrices=new int[]{((StartCompany)buy).getPrice()};
            options.add(LocalText.getText(""String_Node_Str"",companyName,sharePerCert,gameUIManager.format(startPrices[0])));
            buyActions.add(buy);
            buyAmounts.add(startPrices[0]);
          }
        }
 else {
          options.add(LocalText.getText(""String_Node_Str"",sharePerCert,companyName,buy.getFromPortfolio().getId(),gameUIManager.format(sharesPerCert * buy.getPrice())));
          buyActions.add(buy);
          buyAmounts.add(1);
          for (int i=2; i <= buy.getMaximumNumber(); i++) {
            options.add(LocalText.getText(""String_Node_Str"",i,sharePerCert,companyName,buy.getFromPortfolio().getId(),gameUIManager.format(i * sharesPerCert * buy.getPrice())));
            buyActions.add(buy);
            buyAmounts.add(i);
          }
        }
      }
      int index=0;
      if (options.size() > 1 || actions.get(0) instanceof StartCompany_18EU) {
        if (startCompany) {
          RadioButtonDialog dialog=new RadioButtonDialog(GameUIManager.COMPANY_START_PRICE_DIALOG,gameUIManager,parent,LocalText.getText(""String_Node_Str""),LocalText.getText(""String_Node_Str"",playerName,companyName),options.toArray(new String[0]),-1);
          gameUIManager.setCurrentDialog(dialog,actions.get(0));
          parent.disableButtons();
          return;
        }
 else {
          String sp=(String)JOptionPane.showInputDialog(this,LocalText.getText(startCompany ? ""String_Node_Str"" : ""String_Node_Str""),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
          index=options.indexOf(sp);
        }
      }
 else       if (options.size() == 1) {
        int result=JOptionPane.showConfirmDialog(this,options.get(0),LocalText.getText(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
        index=(result == JOptionPane.OK_OPTION ? 0 : -1);
      }
      if (index < 0) {
      }
 else       if (startCompany) {
        chosenAction=buyActions.get(index);
        ((StartCompany)chosenAction).setStartPrice(buyAmounts.get(index));
        ((StartCompany)chosenAction).setNumberBought(((StartCompany)chosenAction).getSharesPerCertificate());
      }
 else {
        chosenAction=buyActions.get(index);
        ((BuyCertificate)chosenAction).setNumberBought(buyAmounts.get(index));
      }
    }
 else     if (actions.get(0) instanceof CashCorrectionAction) {
      CashCorrectionAction cca=(CashCorrectionAction)actions.get(0);
      String amountString=(String)JOptionPane.showInputDialog(this,LocalText.getText(""String_Node_Str"",cca.getCashHolderName()),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,null,0);
      if (amountString.substring(0,1).equals(""String_Node_Str""))       amountString=amountString.substring(1);
      int amount;
      try {
        amount=Integer.parseInt(amountString);
      }
 catch (      NumberFormatException e) {
        amount=0;
      }
      cca.setAmount(amount);
      chosenAction=cca;
    }
 else {
      chosenAction=processGameSpecificActions(actor,actions.get(0));
    }
  }
 else {
    log.warn(""String_Node_Str"" + source.toString());
  }
  chosenAction=processGameSpecificFollowUpActions(actor,chosenAction);
  if (chosenAction != null)   (parent).process(chosenAction);
  repaint();
}","public void actionPerformed(ActionEvent actor){
  JComponent source=(JComponent)actor.getSource();
  List<PossibleAction> actions;
  PossibleAction chosenAction=null;
  if (source instanceof ClickField) {
    gbc=gb.getConstraints(source);
    actions=((ClickField)source).getPossibleActions();
    SoundManager.notifyOfClickFieldSelection(actions.get(0));
    SoundManager.notifyOfClickFieldSelection(actions.get(0));
    log.debug(""String_Node_Str"" + actions.get(0).toString());
    if (actions == null || actions.size() == 0) {
      log.warn(""String_Node_Str"");
    }
 else     if (actions.get(0) instanceof SellShares) {
      List<String> options=new ArrayList<String>();
      List<SellShares> sellActions=new ArrayList<SellShares>();
      List<Integer> sellAmounts=new ArrayList<Integer>();
      SellShares sale;
      for (      PossibleAction action : actions) {
        sale=(SellShares)action;
        int i=sale.getNumber();
        if (sale.getPresidentExchange() == 0) {
          options.add(LocalText.getText(""String_Node_Str"",i,sale.getShare(),i * sale.getShare(),sale.getCompanyName(),gameUIManager.format(i * sale.getShareUnits() * sale.getPrice())));
        }
 else {
          options.add(LocalText.getText(""String_Node_Str"",i,sale.getShare(),i * sale.getShare(),sale.getCompanyName(),gameUIManager.format(i * sale.getShareUnits() * sale.getPrice()),3 - sale.getPresidentExchange(),sale.getPresidentExchange() * sale.getShareUnit()));
        }
        sellActions.add(sale);
        sellAmounts.add(i);
      }
      int index=0;
      if (options.size() > 1) {
        String message=LocalText.getText(""String_Node_Str"");
        String sp=(String)JOptionPane.showInputDialog(this,message,message,JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
        index=options.indexOf(sp);
      }
 else       if (options.size() == 1) {
        String message=LocalText.getText(""String_Node_Str"");
        int result=JOptionPane.showConfirmDialog(this,options.get(0),message,JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
        index=(result == JOptionPane.OK_OPTION ? 0 : -1);
      }
      if (index < 0) {
      }
 else {
        chosenAction=sellActions.get(index);
      }
    }
 else     if (actions.get(0) instanceof BuyCertificate) {
      boolean startCompany=false;
      List<String> options=new ArrayList<String>();
      List<BuyCertificate> buyActions=new ArrayList<BuyCertificate>();
      List<Integer> buyAmounts=new ArrayList<Integer>();
      BuyCertificate buy;
      String companyName=""String_Node_Str"";
      String playerName=""String_Node_Str"";
      int sharePerCert;
      int sharesPerCert;
      int shareUnit;
      for (      PossibleAction action : actions) {
        buy=(BuyCertificate)action;
        playerName=buy.getPlayerName();
        PublicCompany company=buy.getCompany();
        companyName=company.getId();
        sharePerCert=buy.getSharePerCertificate();
        shareUnit=company.getShareUnit();
        sharesPerCert=sharePerCert / shareUnit;
        if (buy instanceof StartCompany) {
          startCompany=true;
          int[] startPrices;
          if (((StartCompany)buy).mustSelectAPrice()) {
            startPrices=((StartCompany)buy).getStartPrices();
            Arrays.sort(startPrices);
            if (startPrices.length > 1) {
              for (int i=0; i < startPrices.length; i++) {
                options.add(LocalText.getText(""String_Node_Str"",gameUIManager.format(startPrices[i]),sharePerCert,gameUIManager.format(sharesPerCert * startPrices[i])));
                buyActions.add(buy);
                buyAmounts.add(startPrices[i]);
              }
            }
 else {
              options.add(LocalText.getText(""String_Node_Str"",companyName,company.getPresidentsShare().getShare(),gameUIManager.format(company.getPresidentsShare().getShares() * startPrices[0])));
              buyActions.add(buy);
              buyAmounts.add(startPrices[0]);
            }
          }
 else {
            startPrices=new int[]{((StartCompany)buy).getPrice()};
            options.add(LocalText.getText(""String_Node_Str"",companyName,sharePerCert,gameUIManager.format(startPrices[0])));
            buyActions.add(buy);
            buyAmounts.add(startPrices[0]);
          }
        }
 else {
          options.add(LocalText.getText(""String_Node_Str"",sharePerCert,companyName,buy.getFromPortfolio().getName(),gameUIManager.format(sharesPerCert * buy.getPrice())));
          buyActions.add(buy);
          buyAmounts.add(1);
          for (int i=2; i <= buy.getMaximumNumber(); i++) {
            options.add(LocalText.getText(""String_Node_Str"",i,sharePerCert,companyName,buy.getFromPortfolio().getName(),gameUIManager.format(i * sharesPerCert * buy.getPrice())));
            buyActions.add(buy);
            buyAmounts.add(i);
          }
        }
      }
      int index=0;
      if (options.size() > 1 || actions.get(0) instanceof StartCompany_18EU) {
        if (startCompany) {
          RadioButtonDialog dialog=new RadioButtonDialog(GameUIManager.COMPANY_START_PRICE_DIALOG,gameUIManager,parent,LocalText.getText(""String_Node_Str""),LocalText.getText(""String_Node_Str"",playerName,companyName),options.toArray(new String[0]),-1);
          gameUIManager.setCurrentDialog(dialog,actions.get(0));
          parent.disableButtons();
          return;
        }
 else {
          String sp=(String)JOptionPane.showInputDialog(this,LocalText.getText(startCompany ? ""String_Node_Str"" : ""String_Node_Str""),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
          index=options.indexOf(sp);
        }
      }
 else       if (options.size() == 1) {
        int result=JOptionPane.showConfirmDialog(this,options.get(0),LocalText.getText(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
        index=(result == JOptionPane.OK_OPTION ? 0 : -1);
      }
      if (index < 0) {
      }
 else       if (startCompany) {
        chosenAction=buyActions.get(index);
        ((StartCompany)chosenAction).setStartPrice(buyAmounts.get(index));
        ((StartCompany)chosenAction).setNumberBought(((StartCompany)chosenAction).getSharesPerCertificate());
      }
 else {
        chosenAction=buyActions.get(index);
        ((BuyCertificate)chosenAction).setNumberBought(buyAmounts.get(index));
      }
    }
 else     if (actions.get(0) instanceof CashCorrectionAction) {
      CashCorrectionAction cca=(CashCorrectionAction)actions.get(0);
      String amountString=(String)JOptionPane.showInputDialog(this,LocalText.getText(""String_Node_Str"",cca.getCashHolderName()),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,null,0);
      if (amountString.substring(0,1).equals(""String_Node_Str""))       amountString=amountString.substring(1);
      int amount;
      try {
        amount=Integer.parseInt(amountString);
      }
 catch (      NumberFormatException e) {
        amount=0;
      }
      cca.setAmount(amount);
      chosenAction=cca;
    }
 else {
      chosenAction=processGameSpecificActions(actor,actions.get(0));
    }
  }
 else {
    log.warn(""String_Node_Str"" + source.toString());
  }
  chosenAction=processGameSpecificFollowUpActions(actor,chosenAction);
  if (chosenAction != null)   (parent).process(chosenAction);
  repaint();
}",0.9991874322860238
173420,"@Override public void actionPerformed(ActionEvent actor){
  JComponent source=(JComponent)actor.getSource();
  List<PossibleAction> actions;
  PossibleAction chosenAction=null;
  if (source instanceof ClickField) {
    gbc=gb.getConstraints(source);
    actions=((ClickField)source).getPossibleActions();
    SoundManager.notifyOfClickFieldSelection(actions.get(0));
    log.debug(""String_Node_Str"" + actions.get(0).toString());
    if (actions == null || actions.size() == 0) {
      log.warn(""String_Node_Str"");
    }
 else     if (actions.get(0) instanceof SellShares) {
      List<String> options=new ArrayList<String>();
      List<SellShares> sellActions=new ArrayList<SellShares>();
      List<Integer> sellAmounts=new ArrayList<Integer>();
      SellShares sale;
      for (      PossibleAction action : actions) {
        sale=(SellShares)action;
        int i=sale.getNumber();
        if (sale.getPresidentExchange() == 0) {
          options.add(LocalText.getText(""String_Node_Str"",i,sale.getShare(),i * sale.getShare(),sale.getCompanyName(),gameUIManager.format(i * sale.getShareUnits() * sale.getPrice())));
        }
 else {
          options.add(LocalText.getText(""String_Node_Str"",i,sale.getShare(),i * sale.getShare(),sale.getCompanyName(),gameUIManager.format(i * sale.getShareUnits() * sale.getPrice()),3 - sale.getPresidentExchange(),sale.getPresidentExchange() * sale.getShareUnit()));
        }
        sellActions.add(sale);
        sellAmounts.add(i);
      }
      int index=0;
      if (options.size() > 1) {
        String message=LocalText.getText(""String_Node_Str"");
        String sp=(String)JOptionPane.showInputDialog(this,message,message,JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
        index=options.indexOf(sp);
      }
 else       if (options.size() == 1) {
        String message=LocalText.getText(""String_Node_Str"");
        int result=JOptionPane.showConfirmDialog(this,options.get(0),message,JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
        index=(result == JOptionPane.OK_OPTION ? 0 : -1);
      }
      if (index < 0) {
      }
 else {
        chosenAction=sellActions.get(index);
      }
    }
 else     if (actions.get(0) instanceof BuyCertificate) {
      boolean startCompany=false;
      List<String> options=new ArrayList<String>();
      List<BuyCertificate> buyActions=new ArrayList<BuyCertificate>();
      List<Integer> buyAmounts=new ArrayList<Integer>();
      BuyCertificate buy;
      String companyName=""String_Node_Str"";
      String playerName=""String_Node_Str"";
      int sharePerCert;
      int sharesPerCert;
      int shareUnit;
      for (      PossibleAction action : actions) {
        buy=(BuyCertificate)action;
        playerName=buy.getPlayerName();
        PublicCompany company=buy.getCompany();
        companyName=company.getId();
        sharePerCert=buy.getSharePerCertificate();
        shareUnit=company.getShareUnit();
        sharesPerCert=sharePerCert / shareUnit;
        if (buy instanceof StartCompany) {
          startCompany=true;
          int[] startPrices;
          if (((StartCompany_1880)buy).mustSelectAPrice()) {
            startPrices=((StartCompany_1880)buy).getStartPrices();
            Arrays.sort(startPrices);
            for (int i=0; i < startPrices.length; i++) {
              options.add(""String_Node_Str"" + startPrices[i]);
            }
          }
        }
 else {
          options.add(LocalText.getText(""String_Node_Str"",sharePerCert,companyName,buy.getFromPortfolio().getId(),gameUIManager.format(sharesPerCert * buy.getPrice())));
          buyActions.add(buy);
          buyAmounts.add(1);
          for (int i=2; i <= buy.getMaximumNumber(); i++) {
            options.add(LocalText.getText(""String_Node_Str"",i,sharePerCert,companyName,buy.getFromPortfolio().getId(),gameUIManager.format(i * sharesPerCert * buy.getPrice())));
            buyActions.add(buy);
            buyAmounts.add(i);
          }
        }
      }
      int index=0;
      if (options.size() > 1) {
        if (startCompany) {
          RadioButtonDialog dialog=new RadioButtonDialog(GameUIManager.COMPANY_START_PRICE_DIALOG,gameUIManager,parent,LocalText.getText(""String_Node_Str""),LocalText.getText(""String_Node_Str"",playerName,companyName),options.toArray(new String[0]),0);
          gameUIManager.setCurrentDialog(dialog,actions.get(0));
          parent.disableButtons();
          return;
        }
 else {
          String sp=(String)JOptionPane.showInputDialog(this,LocalText.getText(startCompany ? ""String_Node_Str"" : ""String_Node_Str""),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
          index=options.indexOf(sp);
        }
      }
 else       if (options.size() == 1) {
        if (startCompany) {
          RadioButtonDialog dialog=new RadioButtonDialog(GameUIManager.COMPANY_START_PRICE_DIALOG,gameUIManager,parent,LocalText.getText(""String_Node_Str""),LocalText.getText(""String_Node_Str"",playerName,companyName),options.toArray(new String[0]),0);
          gameUIManager.setCurrentDialog(dialog,actions.get(0));
          parent.disableButtons();
          return;
        }
 else {
          int result=JOptionPane.showConfirmDialog(this,options.get(0),LocalText.getText(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
          index=(result == JOptionPane.OK_OPTION ? 0 : -1);
        }
      }
      if (index < 0) {
      }
 else       if (startCompany) {
        chosenAction=buyActions.get(index);
        ((StartCompany)chosenAction).setStartPrice(buyAmounts.get(index));
        ((StartCompany)chosenAction).setNumberBought(((StartCompany)chosenAction).getSharesPerCertificate());
      }
 else {
        chosenAction=buyActions.get(index);
        ((BuyCertificate)chosenAction).setNumberBought(buyAmounts.get(index));
      }
    }
 else     if (actions.get(0) instanceof CashCorrectionAction) {
      CashCorrectionAction cca=(CashCorrectionAction)actions.get(0);
      String amountString=(String)JOptionPane.showInputDialog(this,LocalText.getText(""String_Node_Str"",cca.getCashHolderName()),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,null,0);
      if (amountString.substring(0,1).equals(""String_Node_Str""))       amountString=amountString.substring(1);
      int amount;
      try {
        amount=Integer.parseInt(amountString);
      }
 catch (      NumberFormatException e) {
        amount=0;
      }
      cca.setAmount(amount);
      chosenAction=cca;
    }
 else {
      chosenAction=processGameSpecificActions(actor,actions.get(0));
    }
  }
 else {
    log.warn(""String_Node_Str"" + source.toString());
  }
  chosenAction=processGameSpecificFollowUpActions(actor,chosenAction);
  if (chosenAction != null)   (parent).process(chosenAction);
  repaint();
}","@Override public void actionPerformed(ActionEvent actor){
  JComponent source=(JComponent)actor.getSource();
  List<PossibleAction> actions;
  PossibleAction chosenAction=null;
  if (source instanceof ClickField) {
    gbc=gb.getConstraints(source);
    actions=((ClickField)source).getPossibleActions();
    SoundManager.notifyOfClickFieldSelection(actions.get(0));
    log.debug(""String_Node_Str"" + actions.get(0).toString());
    if (actions == null || actions.size() == 0) {
      log.warn(""String_Node_Str"");
    }
 else     if (actions.get(0) instanceof SellShares) {
      List<String> options=new ArrayList<String>();
      List<SellShares> sellActions=new ArrayList<SellShares>();
      List<Integer> sellAmounts=new ArrayList<Integer>();
      SellShares sale;
      for (      PossibleAction action : actions) {
        sale=(SellShares)action;
        int i=sale.getNumber();
        if (sale.getPresidentExchange() == 0) {
          options.add(LocalText.getText(""String_Node_Str"",i,sale.getShare(),i * sale.getShare(),sale.getCompanyName(),gameUIManager.format(i * sale.getShareUnits() * sale.getPrice())));
        }
 else {
          options.add(LocalText.getText(""String_Node_Str"",i,sale.getShare(),i * sale.getShare(),sale.getCompanyName(),gameUIManager.format(i * sale.getShareUnits() * sale.getPrice()),3 - sale.getPresidentExchange(),sale.getPresidentExchange() * sale.getShareUnit()));
        }
        sellActions.add(sale);
        sellAmounts.add(i);
      }
      int index=0;
      if (options.size() > 1) {
        String message=LocalText.getText(""String_Node_Str"");
        String sp=(String)JOptionPane.showInputDialog(this,message,message,JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
        index=options.indexOf(sp);
      }
 else       if (options.size() == 1) {
        String message=LocalText.getText(""String_Node_Str"");
        int result=JOptionPane.showConfirmDialog(this,options.get(0),message,JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
        index=(result == JOptionPane.OK_OPTION ? 0 : -1);
      }
      if (index < 0) {
      }
 else {
        chosenAction=sellActions.get(index);
      }
    }
 else     if (actions.get(0) instanceof BuyCertificate) {
      boolean startCompany=false;
      List<String> options=new ArrayList<String>();
      List<BuyCertificate> buyActions=new ArrayList<BuyCertificate>();
      List<Integer> buyAmounts=new ArrayList<Integer>();
      BuyCertificate buy;
      String companyName=""String_Node_Str"";
      String playerName=""String_Node_Str"";
      int sharePerCert;
      int sharesPerCert;
      int shareUnit;
      for (      PossibleAction action : actions) {
        buy=(BuyCertificate)action;
        playerName=buy.getPlayerName();
        PublicCompany company=buy.getCompany();
        companyName=company.getId();
        sharePerCert=buy.getSharePerCertificate();
        shareUnit=company.getShareUnit();
        sharesPerCert=sharePerCert / shareUnit;
        if (buy instanceof StartCompany) {
          startCompany=true;
          int[] startPrices;
          if (((StartCompany_1880)buy).mustSelectAPrice()) {
            startPrices=((StartCompany_1880)buy).getStartPrices();
            Arrays.sort(startPrices);
            for (int i=0; i < startPrices.length; i++) {
              options.add(""String_Node_Str"" + startPrices[i]);
            }
          }
        }
 else {
          options.add(LocalText.getText(""String_Node_Str"",sharePerCert,companyName,buy.getFromPortfolio().getName(),gameUIManager.format(sharesPerCert * buy.getPrice())));
          buyActions.add(buy);
          buyAmounts.add(1);
          for (int i=2; i <= buy.getMaximumNumber(); i++) {
            options.add(LocalText.getText(""String_Node_Str"",i,sharePerCert,companyName,buy.getFromPortfolio().getName(),gameUIManager.format(i * sharesPerCert * buy.getPrice())));
            buyActions.add(buy);
            buyAmounts.add(i);
          }
        }
      }
      int index=0;
      if (options.size() > 1) {
        if (startCompany) {
          RadioButtonDialog dialog=new RadioButtonDialog(GameUIManager.COMPANY_START_PRICE_DIALOG,gameUIManager,parent,LocalText.getText(""String_Node_Str""),LocalText.getText(""String_Node_Str"",playerName,companyName),options.toArray(new String[0]),0);
          gameUIManager.setCurrentDialog(dialog,actions.get(0));
          parent.disableButtons();
          return;
        }
 else {
          String sp=(String)JOptionPane.showInputDialog(this,LocalText.getText(startCompany ? ""String_Node_Str"" : ""String_Node_Str""),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
          index=options.indexOf(sp);
        }
      }
 else       if (options.size() == 1) {
        if (startCompany) {
          RadioButtonDialog dialog=new RadioButtonDialog(GameUIManager.COMPANY_START_PRICE_DIALOG,gameUIManager,parent,LocalText.getText(""String_Node_Str""),LocalText.getText(""String_Node_Str"",playerName,companyName),options.toArray(new String[0]),0);
          gameUIManager.setCurrentDialog(dialog,actions.get(0));
          parent.disableButtons();
          return;
        }
 else {
          int result=JOptionPane.showConfirmDialog(this,options.get(0),LocalText.getText(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
          index=(result == JOptionPane.OK_OPTION ? 0 : -1);
        }
      }
      if (index < 0) {
      }
 else       if (startCompany) {
        chosenAction=buyActions.get(index);
        ((StartCompany)chosenAction).setStartPrice(buyAmounts.get(index));
        ((StartCompany)chosenAction).setNumberBought(((StartCompany)chosenAction).getSharesPerCertificate());
      }
 else {
        chosenAction=buyActions.get(index);
        ((BuyCertificate)chosenAction).setNumberBought(buyAmounts.get(index));
      }
    }
 else     if (actions.get(0) instanceof CashCorrectionAction) {
      CashCorrectionAction cca=(CashCorrectionAction)actions.get(0);
      String amountString=(String)JOptionPane.showInputDialog(this,LocalText.getText(""String_Node_Str"",cca.getCashHolderName()),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,null,0);
      if (amountString.substring(0,1).equals(""String_Node_Str""))       amountString=amountString.substring(1);
      int amount;
      try {
        amount=Integer.parseInt(amountString);
      }
 catch (      NumberFormatException e) {
        amount=0;
      }
      cca.setAmount(amount);
      chosenAction=cca;
    }
 else {
      chosenAction=processGameSpecificActions(actor,actions.get(0));
    }
  }
 else {
    log.warn(""String_Node_Str"" + source.toString());
  }
  chosenAction=processGameSpecificFollowUpActions(actor,chosenAction);
  if (chosenAction != null)   (parent).process(chosenAction);
  repaint();
}",0.999128160418483
173421,"/** 
 * Split a dividend. TODO Optional rounding down the payout
 * @param amount
 */
public void splitRevenue(int amount){
  if (amount > 0) {
    int numberOfShares=operatingCompany.value().getNumberOfShares();
    int withheld=(amount / (2 * numberOfShares)) * numberOfShares;
    String withheldText=Currency.fromBank(withheld,operatingCompany.value());
    ReportBuffer.add(this,operatingCompany.value().getId() + LocalText.getText(""String_Node_Str"") + withheldText);
    int payed=amount - withheld;
    payout(payed);
  }
}","/** 
 * Split a dividend. TODO Optional rounding down the payout
 * @param amount
 */
public void splitRevenue(int amount){
  if (amount > 0) {
    int numberOfShares=operatingCompany.value().getNumberOfShares();
    int withheld=(amount / (2 * numberOfShares)) * numberOfShares;
    String withheldText=Currency.fromBank(withheld,operatingCompany.value());
    ReportBuffer.add(this,operatingCompany.value().getId() + ""String_Node_Str"" + LocalText.getText(""String_Node_Str"")+ ""String_Node_Str""+ withheldText);
    int payed=amount - withheld;
    payout(payed);
  }
}",0.930783242258652
173422,"private void addLocatedTileLays(LayTile layTile){
  for (  MapHex hex : layTile.getLocations()) {
    GUIHex guiHex=map.getHex(hex);
    Set<TileHexUpgrade> upgrades=TileHexUpgrade.createLocated(hex,layTile);
    tileUpgrades.putAll(guiHex,upgrades);
  }
}","private void addLocatedTileLays(LayTile layTile){
  for (  MapHex hex : layTile.getLocations()) {
    GUIHex guiHex=map.getHex(hex);
    Set<TileHexUpgrade> upgrades=TileHexUpgrade.createLocated(hex,layTile);
    TileHexUpgrade.validateAndEnable(upgrades,gameUIManager.getCurrentPhase());
    tileUpgrades.putAll(guiHex,upgrades);
  }
}",0.7533783783783784
173423,"@Override public boolean sellShares(SellShares action){
  PortfolioModel portfolio=currentPlayer.getPortfolioModel();
  String playerName=currentPlayer.getId();
  String errMsg=null;
  String companyName=action.getCompanyName();
  PublicCompany company=companyManager.getPublicCompany(action.getCompanyName());
  PublicCertificate cert=null;
  PublicCertificate presCert=null;
  List<PublicCertificate> certsToSell=new ArrayList<PublicCertificate>();
  Player dumpedPlayer=null;
  int presSharesToSell=0;
  int numberToSell=action.getNumber();
  int shareUnits=action.getShareUnits();
  while (true) {
    if (numberToSell <= 0) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!mayPlayerSellShareOfCompany(company)) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (portfolio.getShare(company) < numberToSell) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (pool.getShare(company) + numberToSell * company.getShareUnit() > getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    Iterator<PublicCertificate> it=portfolio.getCertificates(company).iterator();
    while (numberToSell > 0 && it.hasNext()) {
      cert=it.next();
      if (cert.isPresidentShare()) {
        if (cert.isPresidentShare())         presCert=cert;
        continue;
      }
 else       if (shareUnits != cert.getShares()) {
        continue;
      }
      certsToSell.add(cert);
      numberToSell--;
    }
    if (numberToSell == 0)     presCert=null;
    if (numberToSell > 0 && presCert != null && numberToSell <= presCert.getShares()) {
      if (company == cashNeedingCompany || !dumpOtherCompaniesAllowed) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
      Player otherPlayer, previousPlayer;
      previousPlayer=getRoot().getPlayerManager().getCurrentPlayer();
      for (int i=1; i <= numberOfPlayers; i++) {
        otherPlayer=getRoot().getPlayerManager().getNextPlayerAfter(previousPlayer);
        if (otherPlayer.getPortfolioModel().getShare(company) >= presCert.getShare()) {
          if (numberToSell > 1 || otherPlayer.getPortfolioModel().ownsCertificates(company,1,false) >= 1) {
            dumpedPlayer=otherPlayer;
            presSharesToSell=numberToSell;
            numberToSell=0;
            break;
          }
        }
        previousPlayer=otherPlayer;
      }
    }
    if (numberToSell > 0) {
      if (presCert != null) {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
 else {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
      break;
    }
    break;
  }
  int numberSold=action.getNumber();
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,numberSold,companyName,errMsg));
    return false;
  }
  StockSpace sellPrice;
  int price;
  if (sellPrices.containsKey(company) && GameOption.getAsBoolean(this,""String_Node_Str"")) {
    price=(sellPrices.get(company).getPrice());
  }
 else {
    sellPrice=company.getCurrentSpace();
    price=sellPrice.getPrice();
    sellPrices.put(company,sellPrice);
  }
  int cashAmount=numberSold * price * shareUnits;
  String cashText=Currency.fromBank(cashAmount,currentPlayer);
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,numberSold,company.getShareUnit(),numberSold * company.getShareUnit(),companyName,cashText));
  boolean soldBefore=sellPrices.containsKey(company);
  adjustSharePrice(company,numberSold,soldBefore);
  if (!company.isClosed()) {
    executeShareTransfer(company,certsToSell,dumpedPlayer,presSharesToSell,action.getPresidentExchange());
  }
  cashToRaise.add(-numberSold * price);
  if (cashToRaise.value() <= 0) {
    gameManager.finishShareSellingRound();
  }
 else   if (getSellableShares().isEmpty()) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",Bank.format(this,cashToRaise.value())));
    currentPlayer.setBankrupt();
    gameManager.registerBankruptcy();
  }
  return true;
}","@Override public boolean sellShares(SellShares action){
  PortfolioModel portfolio=currentPlayer.getPortfolioModel();
  String playerName=currentPlayer.getId();
  String errMsg=null;
  String companyName=action.getCompanyName();
  PublicCompany company=companyManager.getPublicCompany(action.getCompanyName());
  PublicCertificate cert=null;
  PublicCertificate presCert=null;
  List<PublicCertificate> certsToSell=new ArrayList<PublicCertificate>();
  Player dumpedPlayer=null;
  int presSharesToSell=0;
  int numberToSell=action.getNumber();
  int shareUnits=action.getShareUnits();
  while (true) {
    if (numberToSell <= 0) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!mayPlayerSellShareOfCompany(company)) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (portfolio.getShare(company) < numberToSell) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (pool.getShare(company) + numberToSell * company.getShareUnit() > getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    Iterator<PublicCertificate> it=portfolio.getCertificates(company).iterator();
    while (numberToSell > 0 && it.hasNext()) {
      cert=it.next();
      if (cert.isPresidentShare()) {
        if (cert.isPresidentShare())         presCert=cert;
        continue;
      }
 else       if (shareUnits != cert.getShares()) {
        continue;
      }
      certsToSell.add(cert);
      numberToSell--;
    }
    if (numberToSell == 0)     presCert=null;
    if (numberToSell > 0 && presCert != null && numberToSell <= presCert.getShares()) {
      if (company == cashNeedingCompany || !dumpOtherCompaniesAllowed) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
      Player otherPlayer, previousPlayer;
      previousPlayer=getRoot().getPlayerManager().getCurrentPlayer();
      for (int i=0; i <= numberOfPlayers; i++) {
        otherPlayer=getRoot().getPlayerManager().getNextPlayerAfter(previousPlayer);
        if (otherPlayer.getPortfolioModel().getShare(company) >= presCert.getShare()) {
          if (numberToSell > 1 || otherPlayer.getPortfolioModel().ownsCertificates(company,1,false) >= 1) {
            dumpedPlayer=otherPlayer;
            presSharesToSell=numberToSell;
            numberToSell=0;
            break;
          }
        }
        previousPlayer=otherPlayer;
      }
    }
    if (numberToSell > 0) {
      if (presCert != null) {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
 else {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
      break;
    }
    break;
  }
  int numberSold=action.getNumber();
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,numberSold,companyName,errMsg));
    return false;
  }
  StockSpace sellPrice;
  int price;
  if (sellPrices.containsKey(company) && GameOption.getAsBoolean(this,""String_Node_Str"")) {
    price=(sellPrices.get(company).getPrice());
  }
 else {
    sellPrice=company.getCurrentSpace();
    price=sellPrice.getPrice();
    sellPrices.put(company,sellPrice);
  }
  int cashAmount=numberSold * price * shareUnits;
  String cashText=Currency.fromBank(cashAmount,currentPlayer);
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,numberSold,company.getShareUnit(),numberSold * company.getShareUnit(),companyName,cashText));
  boolean soldBefore=sellPrices.containsKey(company);
  adjustSharePrice(company,numberSold,soldBefore);
  if (!company.isClosed()) {
    executeShareTransfer(company,certsToSell,dumpedPlayer,presSharesToSell,action.getPresidentExchange());
  }
  cashToRaise.add(-numberSold * price);
  if (cashToRaise.value() <= 0) {
    gameManager.finishShareSellingRound();
  }
 else   if (getSellableShares().isEmpty()) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",Bank.format(this,cashToRaise.value())));
    currentPlayer.setBankrupt();
    gameManager.registerBankruptcy();
  }
  return true;
}",0.9997610513739544
173424,"@Override public boolean process(PossibleAction action){
  if (!super.process(action))   return false;
  StartItem item;
  while ((item=startPacket.getFirstUnsoldItem()) != null && item.getBidders() == 1 && item.needsPriceSetting() == null) {
    assignItem(item.getBidder(),item,item.getBid(),0);
    if (startPacket.areAllSold()) {
      finishRound();
      break;
    }
  }
  return true;
}","@Override public boolean process(PossibleAction action){
  if (!super.process(action))   return false;
  return true;
}",0.4639376218323586
173425,"/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(NullAction action,String playerName){
  System.out.println(""String_Node_Str"");
  String errMsg=null;
  Player player=playerManager.getCurrentPlayer();
  StartItem_1862 auctionItem=(StartItem_1862)auctionItemState.value();
  while (true) {
    if (!playerName.equals(player.getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getId());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName));
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.value() >= auctionItem.getNumActivePlayers() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getId());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
      playerManager.setCurrentToPriorityPlayer();
    }
 else {
      if (GameOption.getAsBoolean(this,""String_Node_Str"")) {
        player.unblockCash(auctionItem.getBid(player));
        auctionItem.setPass(player);
      }
      setNextBiddingPlayer(auctionItem);
    }
  }
 else {
    if (numPasses.value() >= playerManager.getNumberOfPlayers()) {
      ReportBuffer.add(this,LocalText.getText(""String_Node_Str""));
      numPasses.set(0);
      finishRound();
    }
 else {
      playerManager.setCurrentToNextPlayer();
    }
  }
  return true;
}","/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(NullAction action,String playerName){
  String errMsg=null;
  Player player=playerManager.getCurrentPlayer();
  StartItem_1862 auctionItem=(StartItem_1862)auctionItemState.value();
  while (true) {
    if (!playerName.equals(player.getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getId());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName));
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.value() >= auctionItem.getNumActivePlayers() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getId());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
      playerManager.setCurrentToPriorityPlayer();
    }
 else {
      if (GameOption.getAsBoolean(this,""String_Node_Str"")) {
        player.unblockCash(auctionItem.getBid(player));
        auctionItem.setPass(player);
      }
      setNextBiddingPlayer(auctionItem);
    }
  }
 else {
    if (numPasses.value() >= playerManager.getNumberOfPlayers()) {
      ReportBuffer.add(this,LocalText.getText(""String_Node_Str""));
      numPasses.set(0);
      finishRound();
    }
 else {
      playerManager.setCurrentToNextPlayer();
    }
  }
  return true;
}",0.9883753898497306
173426,"@Override protected boolean buy(String playerName,BuyStartItem boughtItem){
  boolean result=super.buy(playerName,boughtItem);
  auctionItemState.set(null);
  return result;
}","@Override protected boolean buy(String playerName,BuyStartItem boughtItem){
  StartItem item=boughtItem.getStartItem();
  int lastBid=item.getBid();
  String errMsg=null;
  Player player=playerManager.getCurrentPlayer();
  int price=0;
  int sharePrice=0;
  String shareCompName=""String_Node_Str"";
  while (true) {
    if (!boughtItem.setSharePriceOnly()) {
      if (item.getStatus() != StartItem.BUYABLE) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
      price=item.getBasePrice();
      if (item.getBid() > price)       price=item.getBid();
      if (player.getFreeCash() < price) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
    }
 else {
      price=item.getBid();
    }
    if (boughtItem.hasSharePriceToSet()) {
      shareCompName=boughtItem.getCompanyToSetPriceFor();
      sharePrice=boughtItem.getAssociatedSharePrice();
      if (sharePrice == 0) {
        errMsg=LocalText.getText(""String_Node_Str"",shareCompName);
        break;
      }
    }
    break;
  }
  if (errMsg != null) {
    System.out.println(errMsg);
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,item.getName(),errMsg));
    return false;
  }
  assignItem(player,item,price,sharePrice);
  if (lastBid == 0) {
    playerManager.setPriorityPlayerToNext();
  }
  playerManager.setCurrentToNextPlayer();
  numPasses.set(0);
  auctionItemState.set(null);
  return true;
}",0.1648079306071871
173427,"@Override public boolean equalsAsOption(PossibleAction pa){
  if (pa == this)   return true;
  if (!super.equalsAsOption(pa))   return false;
  BuyCertificate action=(BuyCertificate)pa;
  return Objects.equal(this.certificate,action.certificate) && Objects.equal(this.company,action.company) && Objects.equal(this.from,action.from)&& Objects.equal(this.maximumNumber,action.maximumNumber);
}","@Override public boolean equalsAsOption(PossibleAction pa){
  if (pa == this)   return true;
  if (!super.equalsAsOption(pa))   return false;
  BuyCertificate action=(BuyCertificate)pa;
  return Objects.equal(this.company,action.company) && Objects.equal(this.from,action.from) && Objects.equal(this.maximumNumber,action.maximumNumber);
}",0.8367626886145405
173428,"/** 
 * Compare is based on  A) Presidency (presidency comes first in natural ordering) B) Number of Shares (more shares means come first) C) Id of CertificateType D) Id of Certificate
 */
@Override public int compareTo(Ownable other){
  if (other instanceof PublicCertificate) {
    PublicCertificate otherCert=(PublicCertificate)other;
    return ComparisonChain.start().compare(this.getId(),otherCert.getId()).result();
  }
 else {
    return super.compareTo(other);
  }
}","/** 
 * Compare is based on  A) Presidency (presidency comes first in natural ordering) B) Number of Shares (more shares means come first) C) Id of CertificateType D) Id of Certificate
 */
@Override public int compareTo(Ownable other){
  if (other instanceof PublicCertificate) {
    PublicCertificate otherCert=(PublicCertificate)other;
    return ComparisonChain.start().compare(this.getCompany(),otherCert.getCompany()).compare(this.getId(),otherCert.getId()).result();
  }
 else {
    return super.compareTo(other);
  }
}",0.95
173429,"private void checkPlayerOrder(){
  if (gameManager.getStartRoundNumber() == 1) {
    turn.add(1);
    int cycleNumber=(turn.value() + 1) / playerManager.getNumberOfPlayers() + 1;
    if (variant.equalsIgnoreCase(CLEMENS_VARIANT)) {
      if (cycleNumber == 1) {
        playerManager.reversePlayerOrder(false);
      }
    }
 else     if (variant.equalsIgnoreCase(SNAKE_VARIANT)) {
      if (cycleNumber == 2) {
        playerManager.reversePlayerOrder(true);
      }
 else       if (cycleNumber == 3) {
        playerManager.reversePlayerOrder(false);
      }
    }
  }
}","private void checkPlayerOrder(){
  if (gameManager.getStartRoundNumber() == 1) {
    turn.add(1);
    int cycleNumber=(turn.value()) / playerManager.getNumberOfPlayers();
    int playerNumber=(turn.value()) % playerManager.getNumberOfPlayers();
    log.debug(""String_Node_Str"" + turn.value() + ""String_Node_Str""+ cycleNumber+ ""String_Node_Str""+ playerNumber);
    if (variant.equalsIgnoreCase(CLEMENS_VARIANT)) {
      if (cycleNumber == 1 && playerNumber == 0) {
        playerManager.reversePlayerOrder(false);
        playerManager.setCurrentToNextPlayer();
      }
    }
 else     if (variant.equalsIgnoreCase(SNAKE_VARIANT)) {
      if (cycleNumber == 2) {
        playerManager.reversePlayerOrder(true);
      }
 else       if (cycleNumber == 3) {
        playerManager.reversePlayerOrder(false);
      }
    }
  }
}",0.7661406025824964
173430,"@Override public void start(){
  super.start();
  if (variant.equalsIgnoreCase(CLEMENS_VARIANT)) {
    playerManager.reversePlayerOrder(true);
  }
  if (!setPossibleActions()) {
    finishRound();
  }
}","@Override public void start(){
  if (variant.equalsIgnoreCase(CLEMENS_VARIANT)) {
    playerManager.reversePlayerOrder(true);
    Player lastPlayer=playerManager.getNextPlayerAfter(playerManager.getPriorityPlayer());
    playerManager.setPriorityPlayer(lastPlayer);
  }
  super.start();
  if (!setPossibleActions()) {
    finishRound();
  }
}",0.6801470588235294
173431,"/** 
 * @param key that defines the specific for which the portfolio members get returned
 * @return all items for the key contained in the portfolio
 */
public ImmutableSortedSet<T> items(K key){
  return portfolio.values();
}","/** 
 * @param key that defines the specific for which the portfolio members get returned
 * @return all items for the key contained in the portfolio
 */
public ImmutableSortedSet<T> items(K key){
  return portfolio.get(key);
}",0.973568281938326
173432,"@Override public String toString(){
  return super.toString() + RailsObjects.stringHelper(this).addToString(""String_Node_Str"",certificate).addToString(""String_Node_Str"",company).addToString(""String_Node_Str"",sharePerCert).addToString(""String_Node_Str"",from).addToString(""String_Node_Str"",price).addToString(""String_Node_Str"",maximumNumber).addToStringOnlyActed(""String_Node_Str"",numberBought).toString();
}","@Override public String toString(){
  return super.toString() + RailsObjects.stringHelper(this).addToString(""String_Node_Str"",certificate).addToString(""String_Node_Str"",company).addToString(""String_Node_Str"",sharePerCert).addToString(""String_Node_Str"",fromName).addToString(""String_Node_Str"",from).addToString(""String_Node_Str"",price).addToString(""String_Node_Str"",maximumNumber).addToStringOnlyActed(""String_Node_Str"",numberBought).toString();
}",0.9530516431924884
173433,"/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(NullAction action,String playerName){
  String errMsg=null;
  Player player=playerManager.getCurrentPlayer();
  StartItem auctionItem=auctionItemState.value();
  while (true) {
    if (!playerName.equals(player.getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getId());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName));
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.value() >= auctionItem.getBidders() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getId());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
      playerManager.setPriorityPlayerToNext();
    }
 else {
      if (GameOption.getAsBoolean(this,""String_Node_Str"")) {
        player.unblockCash(auctionItem.getBid(player));
        auctionItem.setBid(-1,player);
      }
      setNextBiddingPlayer(auctionItem);
    }
  }
 else {
    if (numPasses.value() >= playerManager.getNumberOfPlayers()) {
      ReportBuffer.add(this,LocalText.getText(""String_Node_Str""));
      if (startPacket.getFirstUnsoldItem() == startPacket.getFirstItem()) {
        startPacket.getFirstItem().reduceBasePriceBy(5);
        ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",startPacket.getFirstItem().getName(),Currency.format(this,startPacket.getFirstItem().getBasePrice())));
        numPasses.set(0);
        if (startPacket.getFirstItem().getBasePrice() == 0) {
          assignItem(playerManager.getCurrentPlayer(),startPacket.getFirstItem(),0,0);
          getRoot().getPlayerManager().setPriorityPlayerToNext();
        }
 else {
          playerManager.setCurrentToNextPlayer();
        }
      }
 else {
        numPasses.set(0);
        finishRound();
      }
    }
 else {
      playerManager.setCurrentToNextPlayer();
    }
  }
  return true;
}","/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(NullAction action,String playerName){
  String errMsg=null;
  Player player=playerManager.getCurrentPlayer();
  StartItem auctionItem=auctionItemState.value();
  while (true) {
    if (!playerName.equals(player.getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getId());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName));
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.value() >= auctionItem.getBidders() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getId());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
      playerManager.setCurrentToPriorityPlayer();
    }
 else {
      if (GameOption.getAsBoolean(this,""String_Node_Str"")) {
        player.unblockCash(auctionItem.getBid(player));
        auctionItem.setBid(-1,player);
      }
      setNextBiddingPlayer(auctionItem);
    }
  }
 else {
    if (numPasses.value() >= playerManager.getNumberOfPlayers()) {
      ReportBuffer.add(this,LocalText.getText(""String_Node_Str""));
      if (startPacket.getFirstUnsoldItem() == startPacket.getFirstItem()) {
        startPacket.getFirstItem().reduceBasePriceBy(5);
        ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",startPacket.getFirstItem().getName(),Currency.format(this,startPacket.getFirstItem().getBasePrice())));
        numPasses.set(0);
        if (startPacket.getFirstItem().getBasePrice() == 0) {
          assignItem(playerManager.getCurrentPlayer(),startPacket.getFirstItem(),0,0);
          getRoot().getPlayerManager().setPriorityPlayerToNext();
        }
 else {
          playerManager.setCurrentToNextPlayer();
        }
      }
 else {
        numPasses.set(0);
        finishRound();
      }
    }
 else {
      playerManager.setCurrentToNextPlayer();
    }
  }
  return true;
}",0.9917495240110006
173434,"/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(NullAction action,String playerName){
  String errMsg=null;
  Player player=playerManager.getCurrentPlayer();
  StartItem auctionItem=auctionItemState.value();
  while (true) {
    if (!playerName.equals(player.getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getId());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName));
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.value() >= auctionItem.getBidders() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getId());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
      playerManager.setPriorityPlayerToNext();
    }
 else {
      if (GameOption.getAsBoolean(this,""String_Node_Str"")) {
        player.unblockCash(auctionItem.getBid(player));
        auctionItem.setBid(-1,player);
      }
      setNextBiddingPlayer(auctionItem);
    }
  }
 else {
    if (numPasses.value() >= playerManager.getNumberOfPlayers()) {
      ReportBuffer.add(this,LocalText.getText(""String_Node_Str""));
      if (startPacket.getFirstUnsoldItem() == startPacket.getFirstItem()) {
        startPacket.getFirstItem().reduceBasePriceBy(5);
        ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",startPacket.getFirstItem().getName(),Currency.format(this,startPacket.getFirstItem().getBasePrice())));
        numPasses.set(0);
        if (startPacket.getFirstItem().getBasePrice() == 0) {
          assignItem(playerManager.getCurrentPlayer(),startPacket.getFirstItem(),0,0);
          getRoot().getPlayerManager().setPriorityPlayerToNext();
        }
 else {
          playerManager.setCurrentToNextPlayer();
        }
      }
 else {
        numPasses.set(0);
        finishRound();
      }
    }
 else {
      playerManager.setCurrentToNextPlayer();
    }
  }
  return true;
}","/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(NullAction action,String playerName){
  String errMsg=null;
  Player player=playerManager.getCurrentPlayer();
  StartItem auctionItem=auctionItemState.value();
  while (true) {
    if (!playerName.equals(player.getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getId());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",playerName));
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.value() >= auctionItem.getBidders() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getId());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
      playerManager.setCurrentToPriorityPlayer();
    }
 else {
      if (GameOption.getAsBoolean(this,""String_Node_Str"")) {
        player.unblockCash(auctionItem.getBid(player));
        auctionItem.setBid(-1,player);
      }
      setNextBiddingPlayer(auctionItem);
    }
  }
 else {
    if (numPasses.value() >= playerManager.getNumberOfPlayers()) {
      ReportBuffer.add(this,LocalText.getText(""String_Node_Str""));
      if (startPacket.getFirstUnsoldItem() == startPacket.getFirstItem()) {
        startPacket.getFirstItem().reduceBasePriceBy(5);
        ReportBuffer.add(this,LocalText.getText(""String_Node_Str"",startPacket.getFirstItem().getName(),Currency.format(this,startPacket.getFirstItem().getBasePrice())));
        numPasses.set(0);
        if (startPacket.getFirstItem().getBasePrice() == 0) {
          assignItem(playerManager.getCurrentPlayer(),startPacket.getFirstItem(),0,0);
          getRoot().getPlayerManager().setPriorityPlayerToNext();
        }
 else {
          playerManager.setCurrentToNextPlayer();
        }
      }
 else {
        numPasses.set(0);
        finishRound();
      }
    }
 else {
      playerManager.setCurrentToNextPlayer();
    }
  }
  return true;
}",0.9917495240110006
173435,"public void addImpassableSide(HexSide side){
  impassableBuilder.set(side);
}","public void addImpassableSide(HexSide side){
  impassableBuilder.set(side);
  log.debug(""String_Node_Str"" + side + ""String_Node_Str""+ this);
}",0.7031963470319634
173436,"public void finishConfiguration(RailsRoot root) throws ConfigurationException {
  for (  MapHex hex : hexes.values()) {
    hex.finishConfiguration(root);
  }
  for (  MapHex hex : hexes.values()) {
    for (    HexSide side : HexSide.all()) {
      MapHex neighbour=hexes.get(mapOrientation.getAdjacentCoordinates(hex.getCoordinates(),side));
      if (neighbour != null) {
        if (hex.isValidNeighbour(neighbour,side)) {
          hexTable.put(hex,side,neighbour);
        }
 else {
          hex.addInvalidSide(side);
          if (hex.isImpassableNeighbour(neighbour)) {
            hex.addImpassableSide(side);
            neighbour.addImpassableSide(side);
          }
        }
      }
 else {
        hex.addInvalidSide(side);
      }
    }
  }
  for (  PublicCompany company : root.getCompanyManager().getAllPublicCompanies()) {
    List<MapHex> homeHexes=company.getHomeHexes();
    if (homeHexes != null) {
      for (      MapHex homeHex : homeHexes) {
        int homeNumber=company.getHomeCityNumber();
        Stop home=homeHex.getRelatedStop(homeNumber);
        if (home == null && homeNumber != 0) {
          throw new ConfigurationException(""String_Node_Str"" + homeNumber + ""String_Node_Str""+ homeHex+ ""String_Node_Str""+ homeHex.getStops().size()+ ""String_Node_Str"");
        }
 else {
          homeHex.addHome(company,home);
        }
      }
    }
    MapHex hex=company.getDestinationHex();
    if (hex != null) {
      hex.addDestination(company);
    }
  }
  mapImageUsed=net.sf.rails.util.Util.hasValue(mapImageFilename) && ""String_Node_Str"".equalsIgnoreCase(Config.get(""String_Node_Str""));
  if (mapImageUsed) {
    String rootDirectory=Config.get(""String_Node_Str"");
    if (!net.sf.rails.util.Util.hasValue(rootDirectory)) {
      rootDirectory=""String_Node_Str"";
    }
    mapImageFilepath=""String_Node_Str"" + rootDirectory + ""String_Node_Str""+ mapImageFilename;
  }
}","public void finishConfiguration(RailsRoot root) throws ConfigurationException {
  for (  MapHex hex : hexes.values()) {
    hex.finishConfiguration(root);
  }
  for (  MapHex hex : hexes.values()) {
    for (    HexSide side : HexSide.all()) {
      MapHex neighbour=hexes.get(mapOrientation.getAdjacentCoordinates(hex.getCoordinates(),side));
      if (neighbour != null) {
        if (hex.isValidNeighbour(neighbour,side)) {
          hexTable.put(hex,side,neighbour);
        }
 else {
          hex.addInvalidSide(side);
          if (hex.isImpassableNeighbour(neighbour)) {
            hex.addImpassableSide(side);
            neighbour.addImpassableSide(side.opposite());
          }
        }
      }
 else {
        hex.addInvalidSide(side);
      }
    }
  }
  for (  PublicCompany company : root.getCompanyManager().getAllPublicCompanies()) {
    List<MapHex> homeHexes=company.getHomeHexes();
    if (homeHexes != null) {
      for (      MapHex homeHex : homeHexes) {
        int homeNumber=company.getHomeCityNumber();
        Stop home=homeHex.getRelatedStop(homeNumber);
        if (home == null && homeNumber != 0) {
          throw new ConfigurationException(""String_Node_Str"" + homeNumber + ""String_Node_Str""+ homeHex+ ""String_Node_Str""+ homeHex.getStops().size()+ ""String_Node_Str"");
        }
 else {
          homeHex.addHome(company,home);
        }
      }
    }
    MapHex hex=company.getDestinationHex();
    if (hex != null) {
      hex.addDestination(company);
    }
  }
  mapImageUsed=net.sf.rails.util.Util.hasValue(mapImageFilename) && ""String_Node_Str"".equalsIgnoreCase(Config.get(""String_Node_Str""));
  if (mapImageUsed) {
    String rootDirectory=Config.get(""String_Node_Str"");
    if (!net.sf.rails.util.Util.hasValue(rootDirectory)) {
      rootDirectory=""String_Node_Str"";
    }
    mapImageFilepath=""String_Node_Str"" + rootDirectory + ""String_Node_Str""+ mapImageFilename;
  }
}",0.9971181556195964
173437,"/** 
 * Compare is based on  A) Presidency (presidency comes first in natural ordering) B) Number of Shares (more shares means come first) C) Id of CertificateType D) Id of Certificate
 */
@Override public int compareTo(Ownable other){
  if (other instanceof PublicCertificate) {
    PublicCertificate otherCert=(PublicCertificate)other;
    return ComparisonChain.start().compare(this.getId(),otherCert.getId()).result();
  }
 else {
    return super.compareTo(other);
  }
}","/** 
 * Compare is based on  A) Presidency (presidency comes first in natural ordering) B) Number of Shares (more shares means come first) C) Id of CertificateType D) Id of Certificate
 */
@Override public int compareTo(Ownable other){
  if (other instanceof PublicCertificate) {
    PublicCertificate otherCert=(PublicCertificate)other;
    return ComparisonChain.start().compare(this.getCompany(),otherCert.getCompany()).compare(this.getId(),otherCert.getId()).result();
  }
 else {
    return super.compareTo(other);
  }
}",0.95
173438,"private void checkPlayerOrder(){
  if (gameManager.getStartRoundNumber() == 1) {
    turn.add(1);
    int cycleNumber=(turn.value() + 1) / playerManager.getNumberOfPlayers() + 1;
    if (variant.equalsIgnoreCase(CLEMENS_VARIANT)) {
      if (cycleNumber == 1) {
        playerManager.reversePlayerOrder(false);
      }
    }
 else     if (variant.equalsIgnoreCase(SNAKE_VARIANT)) {
      if (cycleNumber == 2) {
        playerManager.reversePlayerOrder(true);
      }
 else       if (cycleNumber == 3) {
        playerManager.reversePlayerOrder(false);
      }
    }
  }
}","private void checkPlayerOrder(){
  if (gameManager.getStartRoundNumber() == 1) {
    turn.add(1);
    int cycleNumber=(turn.value()) / playerManager.getNumberOfPlayers();
    int playerNumber=(turn.value()) % playerManager.getNumberOfPlayers();
    log.debug(""String_Node_Str"" + turn.value() + ""String_Node_Str""+ cycleNumber+ ""String_Node_Str""+ playerNumber);
    if (variant.equalsIgnoreCase(CLEMENS_VARIANT)) {
      if (cycleNumber == 1 && playerNumber == 0) {
        playerManager.reversePlayerOrder(false);
        playerManager.setCurrentToNextPlayer();
      }
    }
 else     if (variant.equalsIgnoreCase(SNAKE_VARIANT)) {
      if (cycleNumber == 2) {
        playerManager.reversePlayerOrder(true);
      }
 else       if (cycleNumber == 3) {
        playerManager.reversePlayerOrder(false);
      }
    }
  }
}",0.7661406025824964
173439,"@Override public void start(){
  super.start();
  if (variant.equalsIgnoreCase(CLEMENS_VARIANT)) {
    playerManager.reversePlayerOrder(true);
  }
  if (!setPossibleActions()) {
    finishRound();
  }
}","@Override public void start(){
  if (variant.equalsIgnoreCase(CLEMENS_VARIANT)) {
    playerManager.reversePlayerOrder(true);
    Player lastPlayer=playerManager.getNextPlayerAfter(playerManager.getPriorityPlayer());
    playerManager.setPriorityPlayer(lastPlayer);
  }
  super.start();
  if (!setPossibleActions()) {
    finishRound();
  }
}",0.6801470588235294
173440,"/** 
 * @param key that defines the specific for which the portfolio members get returned
 * @return all items for the key contained in the portfolio
 */
public ImmutableSortedSet<T> items(K key){
  return portfolio.values();
}","/** 
 * @param key that defines the specific for which the portfolio members get returned
 * @return all items for the key contained in the portfolio
 */
public ImmutableSortedSet<T> items(K key){
  return portfolio.get(key);
}",0.973568281938326
173441,"@Override public boolean equalsAsOption(PossibleAction pa){
  if (pa == this)   return true;
  if (!super.equalsAsOption(pa))   return false;
  BuyCertificate action=(BuyCertificate)pa;
  return Objects.equal(this.certificate,action.certificate) && Objects.equal(this.company,action.company) && Objects.equal(this.from,action.from)&& Objects.equal(this.maximumNumber,action.maximumNumber);
}","@Override public boolean equalsAsOption(PossibleAction pa){
  if (pa == this)   return true;
  if (!super.equalsAsOption(pa))   return false;
  BuyCertificate action=(BuyCertificate)pa;
  return Objects.equal(this.company,action.company) && Objects.equal(this.from,action.from) && Objects.equal(this.maximumNumber,action.maximumNumber);
}",0.8367626886145405
173442,"private Configurable configureComponent(RailsRoot root,Tag componentTag) throws ConfigurationException {
  String name=componentTag.getAttributeAsString(XMLTags.NAME_ATTR);
  if (name == null) {
    throw new ConfigurationException(LocalText.getText(""String_Node_Str""));
  }
  String clazz=componentTag.getAttributeAsString(XMLTags.CLASS_ATTR);
  if (clazz == null) {
    throw new ConfigurationException(LocalText.getText(""String_Node_Str"",name));
  }
  String file=componentTag.getAttributeAsString(XMLTags.FILE_ATTR);
  if (mComponentMap.get(name) != null) {
    throw new ConfigurationException(LocalText.getText(""String_Node_Str"",name));
  }
  Configurable component=Configure.create(Configurable.class,clazz,RailsRoot.class,root,name);
  Tag configElement=componentTag;
  if (file != null) {
    String directory=GameInfoParser.DIRECTORY + File.separator + root.getGameName();
    configElement=Tag.findTopTagInFile(file,directory,name,root.getGameOptions());
  }
  try {
    component.configureFromXML(configElement);
  }
 catch (  ConfigurationException e) {
    throw e;
  }
  mComponentMap.put(name,component);
  log.debug(LocalText.getText(""String_Node_Str"",name,clazz));
  return component;
}","private Configurable configureComponent(RailsRoot root,Tag componentTag) throws ConfigurationException {
  String name=componentTag.getAttributeAsString(XMLTags.NAME_ATTR);
  if (name == null) {
    throw new ConfigurationException(LocalText.getText(""String_Node_Str""));
  }
  String clazz=componentTag.getAttributeAsString(XMLTags.CLASS_ATTR);
  if (clazz == null) {
    throw new ConfigurationException(LocalText.getText(""String_Node_Str"",name));
  }
  String file=componentTag.getAttributeAsString(XMLTags.FILE_ATTR);
  if (mComponentMap.get(name) != null) {
    throw new ConfigurationException(LocalText.getText(""String_Node_Str"",name));
  }
  Configurable component=Configure.create(Configurable.class,clazz,RailsRoot.class,root,name);
  Tag configElement=componentTag;
  if (file != null) {
    String directory=GameInfoParser.DIRECTORY + ResourceLoader.SEPARATOR + root.getGameName();
    configElement=Tag.findTopTagInFile(file,directory,name,root.getGameOptions());
  }
  try {
    component.configureFromXML(configElement);
  }
 catch (  ConfigurationException e) {
    throw e;
  }
  mComponentMap.put(name,component);
  log.debug(LocalText.getText(""String_Node_Str"",name,clazz));
  return component;
}",0.9842845326716294
173443,"public void initGameFromXML() throws ConfigurationException {
  String directory=""String_Node_Str"" + gameData.getGameName();
  Tag componentManagerTag=Tag.findTopTagInFile(GAME_XML_FILE,directory,XMLTags.COMPONENT_MANAGER_ELEMENT_ID,gameData.getGameOptions());
  ComponentManager componentManager=new ComponentManager();
  componentManager.start(this,componentManagerTag);
  reportManager=ReportManager.create(this,""String_Node_Str"");
}","public void initGameFromXML() throws ConfigurationException {
  String directory=""String_Node_Str"" + ResourceLoader.SEPARATOR + gameData.getGameName();
  Tag componentManagerTag=Tag.findTopTagInFile(GAME_XML_FILE,directory,XMLTags.COMPONENT_MANAGER_ELEMENT_ID,gameData.getGameOptions());
  ComponentManager componentManager=new ComponentManager();
  componentManager.start(this,componentManagerTag);
  reportManager=ReportManager.create(this,""String_Node_Str"");
}",0.9699666295884316
173444,"/** 
 * @see net.sf.rails.common.parser.Configurable#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Tag tileSetTop) throws ConfigurationException {
  String tileDefFileName=tileSetTop.getAttributeAsString(""String_Node_Str"");
  if (tileDefFileName == null)   throw new ConfigurationException(LocalText.getText(""String_Node_Str""));
  String directory=""String_Node_Str"" + getRoot().getGameName();
  Tag tileDefTop=Tag.findTopTagInFile(tileDefFileName,directory,""String_Node_Str"",getRoot().getGameOptions());
  if (tileDefTop == null)   throw new ConfigurationException(LocalText.getText(""String_Node_Str""));
  List<Tag> tileSetList=tileSetTop.getChildren(""String_Node_Str"");
  List<Tag> tileDefList=tileDefTop.getChildren(""String_Node_Str"");
  Map<String,Tag> tileSetMap=Maps.newHashMapWithExpectedSize(tileSetList.size());
  for (  Tag tileSetTag : tileSetList) {
    String tileId=tileSetTag.getAttributeAsString(""String_Node_Str"");
    if (tileSetMap.containsKey(tileId)) {
      throw new ConfigurationException(LocalText.getText(""String_Node_Str"",String.valueOf(tileId)));
    }
    tileSetMap.put(tileId,tileSetTag);
  }
  Map<String,Tag> tileDefMap=Maps.newHashMapWithExpectedSize(tileDefList.size());
  for (  Tag tileDefTag : tileDefList) {
    String tileId=tileDefTag.getAttributeAsString(""String_Node_Str"");
    if (tileDefMap.containsKey(tileId)) {
      throw new ConfigurationException(LocalText.getText(""String_Node_Str"",String.valueOf(tileId)));
    }
 else     if (!tileSetMap.containsKey(tileId)) {
      log.warn(""String_Node_Str"" + tileId + ""String_Node_Str"");
    }
    tileDefMap.put(tileId,tileDefTag);
  }
  ImmutableMap.Builder<String,Tile> tileMapBuilder=ImmutableMap.builder();
  for (  String id : tileSetMap.keySet()) {
    Tile tile=Tile.create(this,id);
    tileMapBuilder.put(id,tile);
  }
  tileMap=tileMapBuilder.build();
  for (  String id : tileMap.keySet()) {
    Tile tile=tileMap.get(id);
    tile.configureFromXML(tileSetMap.get(id),tileDefMap.get(id));
    sortingDigits=Math.max(sortingDigits,tile.toText().length());
  }
  Tag defaultsTag=tileSetTop.getChild(""String_Node_Str"");
  if (defaultsTag != null) {
    List<Tag> accessTags=defaultsTag.getChildren(""String_Node_Str"");
    defaultStopTypes=StopType.parseDefaults(this,accessTags);
  }
 else {
    defaultStopTypes=ImmutableMap.of();
  }
}","/** 
 * @see net.sf.rails.common.parser.Configurable#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Tag tileSetTop) throws ConfigurationException {
  String tileDefFileName=tileSetTop.getAttributeAsString(""String_Node_Str"");
  if (tileDefFileName == null)   throw new ConfigurationException(LocalText.getText(""String_Node_Str""));
  String directory=""String_Node_Str"" + ResourceLoader.SEPARATOR + getRoot().getGameName();
  Tag tileDefTop=Tag.findTopTagInFile(tileDefFileName,directory,""String_Node_Str"",getRoot().getGameOptions());
  if (tileDefTop == null)   throw new ConfigurationException(LocalText.getText(""String_Node_Str""));
  List<Tag> tileSetList=tileSetTop.getChildren(""String_Node_Str"");
  List<Tag> tileDefList=tileDefTop.getChildren(""String_Node_Str"");
  Map<String,Tag> tileSetMap=Maps.newHashMapWithExpectedSize(tileSetList.size());
  for (  Tag tileSetTag : tileSetList) {
    String tileId=tileSetTag.getAttributeAsString(""String_Node_Str"");
    if (tileSetMap.containsKey(tileId)) {
      throw new ConfigurationException(LocalText.getText(""String_Node_Str"",String.valueOf(tileId)));
    }
    tileSetMap.put(tileId,tileSetTag);
  }
  Map<String,Tag> tileDefMap=Maps.newHashMapWithExpectedSize(tileDefList.size());
  for (  Tag tileDefTag : tileDefList) {
    String tileId=tileDefTag.getAttributeAsString(""String_Node_Str"");
    if (tileDefMap.containsKey(tileId)) {
      throw new ConfigurationException(LocalText.getText(""String_Node_Str"",String.valueOf(tileId)));
    }
 else     if (!tileSetMap.containsKey(tileId)) {
      log.warn(""String_Node_Str"" + tileId + ""String_Node_Str"");
    }
    tileDefMap.put(tileId,tileDefTag);
  }
  ImmutableMap.Builder<String,Tile> tileMapBuilder=ImmutableMap.builder();
  for (  String id : tileSetMap.keySet()) {
    Tile tile=Tile.create(this,id);
    tileMapBuilder.put(id,tile);
  }
  tileMap=tileMapBuilder.build();
  for (  String id : tileMap.keySet()) {
    Tile tile=tileMap.get(id);
    tile.configureFromXML(tileSetMap.get(id),tileDefMap.get(id));
    sortingDigits=Math.max(sortingDigits,tile.toText().length());
  }
  Tag defaultsTag=tileSetTop.getChild(""String_Node_Str"");
  if (defaultsTag != null) {
    List<Tag> accessTags=defaultsTag.getChildren(""String_Node_Str"");
    defaultStopTypes=StopType.parseDefaults(this,accessTags);
  }
 else {
    defaultStopTypes=ImmutableMap.of();
  }
}",0.9943145925457992
173445,"@Before public void setUp(){
  root=Root.create(new ChangeReporterImpl());
  manager=new ManagerImpl(root,MANAGER_ID);
  item=new AbstractItemImpl(manager,ITEM_ID);
  anotherItem=new AbstractItemImpl(item,ANOTHER_ID);
}","@Before public void setUp(){
  root=Root.create();
  manager=new ManagerImpl(root,MANAGER_ID);
  item=new AbstractItemImpl(manager,ITEM_ID);
  anotherItem=new AbstractItemImpl(item,ANOTHER_ID);
}",0.9420289855072465
173446,"public void update(){
}","public void update(ChangeSet changeSet){
}",0.7076923076923077
173447,"private void testUndoAfterClose(){
  assertTrue(state.value());
  changeStack.undo();
  assertEquals(1,changeStack.getCurrentIndex());
  assertSame(set_2,changeStack.getPreviousChangeSet());
  assertFalse(state.value());
  changeStack.undo();
  assertEquals(0,changeStack.getCurrentIndex());
  assertSame(set_1,changeStack.getPreviousChangeSet());
  assertTrue(state.value());
  try {
    changeStack.undo();
    failBecauseExceptionWasNotThrown(IllegalStateException.class);
  }
 catch (  Exception e) {
    assertThat(e).isInstanceOf(IllegalStateException.class);
  }
  assertEquals(0,changeStack.getCurrentIndex());
  assertSame(set_1,changeStack.getPreviousChangeSet());
  assertTrue(state.value());
}","private void testUndoAfterClose(){
  assertTrue(state.value());
  changeStack.undo();
  assertEquals(2,changeStack.getCurrentIndex());
  assertSame(set_2,changeStack.getPreviousChangeSet());
  assertFalse(state.value());
  changeStack.undo();
  assertEquals(1,changeStack.getCurrentIndex());
  assertSame(set_1,changeStack.getPreviousChangeSet());
  assertTrue(state.value());
  try {
    changeStack.undo();
    failBecauseExceptionWasNotThrown(IllegalStateException.class);
  }
 catch (  Exception e) {
    assertThat(e).isInstanceOf(IllegalStateException.class);
  }
  assertEquals(1,changeStack.getCurrentIndex());
  assertSame(set_1,changeStack.getPreviousChangeSet());
  assertTrue(state.value());
}",0.9957446808510638
173448,"@Test public void testRedo(){
  changeStack.close(changeAction);
  changeStack.undo();
  changeStack.undo();
  changeStack.redo();
  assertEquals(1,changeStack.getCurrentIndex());
  assertSame(set_2,changeStack.getPreviousChangeSet());
  assertFalse(state.value());
  changeStack.redo();
  assertEquals(2,changeStack.getCurrentIndex());
  assertSame(set_3,changeStack.getPreviousChangeSet());
  assertTrue(state.value());
  try {
    changeStack.redo();
    failBecauseExceptionWasNotThrown(IllegalStateException.class);
  }
 catch (  Exception e) {
    assertThat(e).isInstanceOf(IllegalStateException.class);
  }
  assertEquals(2,changeStack.getCurrentIndex());
  assertSame(set_3,changeStack.getPreviousChangeSet());
  assertTrue(state.value());
  testUndoAfterClose();
}","@Test public void testRedo(){
  changeStack.close(changeAction);
  changeStack.undo();
  changeStack.undo();
  changeStack.redo();
  assertEquals(2,changeStack.getCurrentIndex());
  assertSame(set_2,changeStack.getPreviousChangeSet());
  assertFalse(state.value());
  changeStack.redo();
  assertEquals(3,changeStack.getCurrentIndex());
  assertSame(set_3,changeStack.getPreviousChangeSet());
  assertTrue(state.value());
  try {
    changeStack.redo();
    failBecauseExceptionWasNotThrown(IllegalStateException.class);
  }
 catch (  Exception e) {
    assertThat(e).isInstanceOf(IllegalStateException.class);
  }
  assertEquals(3,changeStack.getCurrentIndex());
  assertSame(set_3,changeStack.getPreviousChangeSet());
  assertTrue(state.value());
  testUndoAfterClose();
}",0.996124031007752
173449,"@Before public void setUp(){
  root=Root.create(new ChangeReporterImpl());
  changeStack=root.getStateManager().getChangeStack();
  changeAction=new ChangeActionImpl();
  state=BooleanState.create(root,STATE_ID,true);
  StateTestUtils.close(root);
  set_1=changeStack.getPreviousChangeSet();
  state.set(false);
  StateTestUtils.close(root);
  set_2=changeStack.getPreviousChangeSet();
  state.set(true);
  StateTestUtils.close(root);
  set_3=changeStack.getPreviousChangeSet();
}","@Before public void setUp(){
  root=Root.create();
  changeStack=root.getStateManager().getChangeStack();
  changeAction=new ChangeActionImpl();
  state=BooleanState.create(root,STATE_ID,true);
  StateTestUtils.close(root);
  set_1=changeStack.getPreviousChangeSet();
  state.set(false);
  StateTestUtils.close(root);
  set_2=changeStack.getPreviousChangeSet();
  state.set(true);
  StateTestUtils.close(root);
  set_3=changeStack.getPreviousChangeSet();
}",0.9743589743589745
173450,"@Test public void testcloseAndNew(){
  changeStack.close(changeAction);
  assertSame(set_3,changeStack.getPreviousChangeSet());
  assertEquals(2,changeStack.getCurrentIndex());
}","@Test public void testcloseAndNew(){
  changeStack.close(changeAction);
  assertSame(set_3,changeStack.getPreviousChangeSet());
  assertEquals(3,changeStack.getCurrentIndex());
}",0.99438202247191
173451,"@Test public void testGetCurrentChangeSet(){
  assertSame(set_3,changeStack.getPreviousChangeSet());
  assertEquals(2,changeStack.getCurrentIndex());
}","@Test public void testGetCurrentChangeSet(){
  assertSame(set_3,changeStack.getPreviousChangeSet());
  assertEquals(3,changeStack.getCurrentIndex());
}",0.9933774834437086
173452,"@Before public void setUp(){
  root=Root.create(new ChangeReporterImpl());
  item=new AbstractItemImpl(root,ITEM_ID);
  manager=new ManagerImpl(item,MANAGER_ID);
  anotherItem=new AbstractItemImpl(manager,ANOTHER_ITEM_ID);
  anotherManager=new ManagerImpl(manager,ANOTHER_MANAGER_ID);
}","@Before public void setUp(){
  root=Root.create();
  item=new AbstractItemImpl(root,ITEM_ID);
  manager=new ManagerImpl(item,MANAGER_ID);
  anotherItem=new AbstractItemImpl(manager,ANOTHER_ITEM_ID);
  anotherManager=new ManagerImpl(manager,ANOTHER_MANAGER_ID);
}",0.9562043795620438
173453,"@Before public void setUp(){
  root=Root.create(new ChangeReporterImpl());
  manager=new ManagerImpl(root,MANAGER_ID);
  item=new AbstractItemImpl(manager,ITEM_ID);
  observable=new ObservableImpl(item,OBS_ID);
}","@Before public void setUp(){
  root=Root.create();
  manager=new ManagerImpl(root,MANAGER_ID);
  item=new AbstractItemImpl(manager,ITEM_ID);
  observable=new ObservableImpl(item,OBS_ID);
}",0.94
173454,"@Before public void setUp(){
  root=Root.create(new ChangeReporterImpl());
  manager=new ManagerImpl(root,MANAGER_ID);
  item=new AbstractItemImpl(root,ITEM_ID);
  anotherItem=new AbstractItemImpl(manager,ANOTHER_ID);
}","@Before public void setUp(){
  root=Root.create();
  manager=new ManagerImpl(root,MANAGER_ID);
  item=new AbstractItemImpl(root,ITEM_ID);
  anotherItem=new AbstractItemImpl(manager,ANOTHER_ID);
}",0.9420289855072465
173455,"@Before public void setUp(){
  root=Root.create(new ChangeReporterImpl());
  state=StateImpl.create(root,STATE_ID,null);
  model=ModelImpl.create(root,MODEL_ID,null);
  state_model=StateImpl.create(model,STATE_ID,null);
}","@Before public void setUp(){
  root=Root.create();
  state=StateImpl.create(root,STATE_ID,null);
  model=ModelImpl.create(root,MODEL_ID,null);
  state_model=StateImpl.create(model,STATE_ID,null);
}",0.9425837320574164
173456,"public static Root setUpRoot(){
  Root root=Root.create(new ChangeReporterImpl());
  close(root);
  return root;
}","public static Root setUpRoot(){
  Root root=Root.create();
  close(root);
  return root;
}",0.8823529411764706
173457,"private NetworkAdapter(GameManager gameManager){
  this.gameManager=gameManager;
}","private NetworkAdapter(RailsRoot root){
  this.root=root;
}",0.5815602836879432
173458,"public static NetworkAdapter create(GameManager gameManager){
  return new NetworkAdapter(gameManager);
}","public static NetworkAdapter create(RailsRoot root){
  return new NetworkAdapter(root);
}",0.7628865979381443
173459,"public NetworkGraph getMapGraph(){
  if (mapGraph == null) {
    mapGraph=NetworkGraph.createMapGraph(gameManager);
    log.info(""String_Node_Str"");
  }
  return mapGraph;
}","public NetworkGraph getMapGraph(){
  if (mapGraph == null) {
    mapGraph=NetworkGraph.createMapGraph(root);
    log.info(""String_Node_Str"");
  }
  return mapGraph;
}",0.9616519174041298
173460,"public static NetworkGraph createMapGraph(GameManager gameManager){
  NetworkGraph graph=new NetworkGraph();
  graph.generateMapGraph(gameManager);
  return graph;
}","public static NetworkGraph createMapGraph(RailsRoot root){
  NetworkGraph graph=new NetworkGraph();
  graph.generateMapGraph(root);
  return graph;
}",0.8535031847133758
173461,"private void generateMapGraph(GameManager gameManager){
  MapManager mapManager=gameManager.getMapManager();
  RevenueManager revenueManager=gameManager.getRevenueManager();
  for (  MapHex hex : mapManager.getHexes()) {
    Tile tile=hex.getCurrentTile();
    Collection<Station> stations=tile.getStations();
    for (    Station station : stations) {
      NetworkVertex stationVertex=new NetworkVertex(hex,station);
      graph.addVertex(stationVertex);
      vertices.put(stationVertex.getIdentifier(),stationVertex);
      log.info(""String_Node_Str"" + stationVertex);
    }
    for (    HexSide side : HexSide.all())     if (tile.hasTracks(side)) {
      HexSide rotated=side.rotate(hex.getCurrentTileRotation());
      NetworkVertex sideVertex=new NetworkVertex(hex,rotated);
      graph.addVertex(sideVertex);
      vertices.put(sideVertex.getIdentifier(),sideVertex);
      log.info(""String_Node_Str"" + sideVertex);
    }
  }
  for (  MapHex hex : mapManager.getHexes()) {
    Tile tile=hex.getCurrentTile();
    Set<Track> tracks=tile.getTracks();
    for (    Track track : tracks) {
      NetworkVertex startVertex=getVertexRotated(hex,track.getStart());
      NetworkVertex endVertex=getVertexRotated(hex,track.getEnd());
      log.info(""String_Node_Str"" + track);
      NetworkEdge edge=new NetworkEdge(startVertex,endVertex,false);
      if (startVertex == endVertex) {
        log.error(""String_Node_Str"" + track + ""String_Node_Str""+ hex+ ""String_Node_Str"");
      }
 else {
        graph.addEdge(startVertex,endVertex,edge);
        log.info(""String_Node_Str"" + edge.getConnection());
      }
    }
    for (    HexSide side : HexSide.head()) {
      MapHex neighborHex=mapManager.getNeighbour(hex,side);
      if (neighborHex == null) {
        log.info(""String_Node_Str"" + hex.getId() + ""String_Node_Str""+ hex.getOrientationName(side)+ ""String_Node_Str"");
        continue;
      }
      NetworkVertex vertex=getVertex(hex,side);
      HexSide rotated=side.opposite();
      NetworkVertex otherVertex=getVertex(neighborHex,rotated);
      if (vertex == null && otherVertex == null) {
        log.info(""String_Node_Str"" + hex.getId() + ""String_Node_Str""+ hex.getOrientationName(side));
        log.info(""String_Node_Str"" + neighborHex.getId() + ""String_Node_Str""+ neighborHex.getOrientationName(rotated));
        continue;
      }
 else       if (vertex == null && otherVertex != null) {
        log.info(""String_Node_Str"" + neighborHex.getId() + ""String_Node_Str""+ neighborHex.getOrientationName(rotated)+ ""String_Node_Str""+ hex.getId()+ ""String_Node_Str""+ hex.getOrientationName(side));
        vertex=new NetworkVertex(hex,side);
        graph.addVertex(vertex);
        vertices.put(vertex.getIdentifier(),vertex);
        log.info(""String_Node_Str"" + vertex);
      }
 else       if (otherVertex == null) {
        log.info(""String_Node_Str"" + hex.getId() + ""String_Node_Str""+ hex.getOrientationName(side)+ ""String_Node_Str""+ neighborHex.getId()+ ""String_Node_Str""+ neighborHex.getOrientationName(rotated));
        otherVertex=new NetworkVertex(neighborHex,rotated);
        graph.addVertex(otherVertex);
        vertices.put(otherVertex.getIdentifier(),otherVertex);
        log.info(""String_Node_Str"" + otherVertex);
      }
      NetworkEdge edge=new NetworkEdge(vertex,otherVertex,true);
      graph.addEdge(vertex,otherVertex,edge);
      log.info(""String_Node_Str"" + edge.getConnection());
    }
  }
  if (revenueManager != null) {
    revenueManager.initGraphModifiers(this);
  }
}","private void generateMapGraph(RailsRoot root){
  MapManager mapManager=root.getMapManager();
  RevenueManager revenueManager=root.getRevenueManager();
  for (  MapHex hex : mapManager.getHexes()) {
    Tile tile=hex.getCurrentTile();
    Collection<Station> stations=tile.getStations();
    for (    Station station : stations) {
      NetworkVertex stationVertex=new NetworkVertex(hex,station);
      graph.addVertex(stationVertex);
      vertices.put(stationVertex.getIdentifier(),stationVertex);
      log.info(""String_Node_Str"" + stationVertex);
    }
    for (    HexSide side : HexSide.all())     if (tile.hasTracks(side)) {
      HexSide rotated=side.rotate(hex.getCurrentTileRotation());
      NetworkVertex sideVertex=new NetworkVertex(hex,rotated);
      graph.addVertex(sideVertex);
      vertices.put(sideVertex.getIdentifier(),sideVertex);
      log.info(""String_Node_Str"" + sideVertex);
    }
  }
  for (  MapHex hex : mapManager.getHexes()) {
    Tile tile=hex.getCurrentTile();
    Set<Track> tracks=tile.getTracks();
    for (    Track track : tracks) {
      NetworkVertex startVertex=getVertexRotated(hex,track.getStart());
      NetworkVertex endVertex=getVertexRotated(hex,track.getEnd());
      log.info(""String_Node_Str"" + track);
      NetworkEdge edge=new NetworkEdge(startVertex,endVertex,false);
      if (startVertex == endVertex) {
        log.error(""String_Node_Str"" + track + ""String_Node_Str""+ hex+ ""String_Node_Str"");
      }
 else {
        graph.addEdge(startVertex,endVertex,edge);
        log.info(""String_Node_Str"" + edge.getConnection());
      }
    }
    for (    HexSide side : HexSide.head()) {
      MapHex neighborHex=mapManager.getNeighbour(hex,side);
      if (neighborHex == null) {
        log.info(""String_Node_Str"" + hex.getId() + ""String_Node_Str""+ hex.getOrientationName(side)+ ""String_Node_Str"");
        continue;
      }
      NetworkVertex vertex=getVertex(hex,side);
      HexSide rotated=side.opposite();
      NetworkVertex otherVertex=getVertex(neighborHex,rotated);
      if (vertex == null && otherVertex == null) {
        log.info(""String_Node_Str"" + hex.getId() + ""String_Node_Str""+ hex.getOrientationName(side));
        log.info(""String_Node_Str"" + neighborHex.getId() + ""String_Node_Str""+ neighborHex.getOrientationName(rotated));
        continue;
      }
 else       if (vertex == null && otherVertex != null) {
        log.info(""String_Node_Str"" + neighborHex.getId() + ""String_Node_Str""+ neighborHex.getOrientationName(rotated)+ ""String_Node_Str""+ hex.getId()+ ""String_Node_Str""+ hex.getOrientationName(side));
        vertex=new NetworkVertex(hex,side);
        graph.addVertex(vertex);
        vertices.put(vertex.getIdentifier(),vertex);
        log.info(""String_Node_Str"" + vertex);
      }
 else       if (otherVertex == null) {
        log.info(""String_Node_Str"" + hex.getId() + ""String_Node_Str""+ hex.getOrientationName(side)+ ""String_Node_Str""+ neighborHex.getId()+ ""String_Node_Str""+ neighborHex.getOrientationName(rotated));
        otherVertex=new NetworkVertex(neighborHex,rotated);
        graph.addVertex(otherVertex);
        vertices.put(otherVertex.getIdentifier(),otherVertex);
        log.info(""String_Node_Str"" + otherVertex);
      }
      NetworkEdge edge=new NetworkEdge(vertex,otherVertex,true);
      graph.addEdge(vertex,otherVertex,edge);
      log.info(""String_Node_Str"" + edge.getConnection());
    }
  }
  if (revenueManager != null) {
    revenueManager.initGraphModifiers(this);
  }
}",0.9904299385802028
173462,"public Map<String,String> getGameOptions(){
  return gameOptions;
}","public GameOptionsSet getGameOptions(){
  return gameOptions;
}",0.8153846153846154
173463,"private GameData(GameInfo game,Map<String,String> gameOptions,List<String> players){
  this.game=game;
  this.gameOptions=ImmutableMap.copyOf(gameOptions);
  this.players=players;
}","private GameData(GameInfo game,GameOptionsSet gameOptions,List<String> players){
  this.game=game;
  this.gameOptions=gameOptions;
  this.players=players;
}",0.8664688427299704
173464,"public static GameData create(GameInfo game,Map<GameOption,String> gameOptions,List<String> players){
  ImmutableMap.Builder<String,String> legacyOptions=ImmutableMap.builder();
  for (  GameOption option : gameOptions.keySet()) {
    legacyOptions.put(option.getName(),gameOptions.get(option));
  }
  legacyOptions.put(GameOption.NUMBER_OF_PLAYERS,String.valueOf(players.size()));
  return createLegacy(game,legacyOptions.build(),players);
}","public static GameData create(GameInfo game,GameOptionsSet.Builder gameOptions,List<String> players){
  return new GameData(game,gameOptions.build(players.size()),players);
}",0.487012987012987
173465,"private String getLocalisedName(){
  ImmutableList.Builder<String> localTextPars=ImmutableList.builder();
  for (  String par : parameters) {
    localTextPars.add(LocalText.getText(par));
  }
  return LocalText.getText(name,(Object[])localTextPars.build().toArray());
}","private String getLocalisedName(){
  if (parameters == null || parameters.isEmpty()) {
    return LocalText.getText(name);
  }
  ImmutableList.Builder<String> localTextPars=ImmutableList.builder();
  for (  String par : parameters) {
    localTextPars.add(LocalText.getText(par));
  }
  return LocalText.getText(name,(Object[])localTextPars.build().toArray());
}",0.8544303797468354
173466,"public GameOption build(){
  Boolean isBoolean=false;
  List<String> finalAllowedValues=ImmutableList.of();
  if (type.equalsIgnoreCase(OPTION_TYPE_TOGGLE)) {
    isBoolean=true;
    finalAllowedValues=ImmutableList.of(OPTION_VALUE_YES,OPTION_VALUE_NO);
  }
 else   if (type.equalsIgnoreCase(OPTION_TYPE_SELECTION)) {
    if (allowedValues == null) {
      finalAllowedValues=ImmutableList.of();
    }
 else {
      finalAllowedValues=allowedValues;
    }
  }
  String parameterisedName=getParameterisedName();
  String localisedName=getLocalisedName();
  String finalDefaultValue=getFinalDefaultValue(isBoolean,finalAllowedValues);
  return new GameOption(parameterisedName,localisedName,isBoolean,finalDefaultValue,finalAllowedValues,ordering);
}","public GameOption build(){
  Boolean isBoolean=false;
  List<String> finalAllowedValues=ImmutableList.of();
  if (type.equalsIgnoreCase(OPTION_TYPE_TOGGLE)) {
    isBoolean=true;
    finalAllowedValues=ImmutableList.of(OPTION_VALUE_YES,OPTION_VALUE_NO);
  }
 else   if (type.equalsIgnoreCase(OPTION_TYPE_SELECTION)) {
    if (allowedValues == null) {
      finalAllowedValues=ImmutableList.of();
    }
 else {
      finalAllowedValues=allowedValues;
    }
  }
  String parameterisedName=constructParameterisedName(name,parameters);
  String localisedName=getLocalisedName();
  String finalDefaultValue=getFinalDefaultValue(isBoolean,finalAllowedValues);
  return new GameOption(parameterisedName,localisedName,isBoolean,finalDefaultValue,finalAllowedValues,ordering);
}",0.983520105471325
173467,"public void actionPerformed(ActionEvent actor){
  JComponent source=(JComponent)actor.getSource();
  List<PossibleAction> actions;
  PossibleAction chosenAction=null;
  if (source instanceof ClickField) {
    gbc=gb.getConstraints(source);
    actions=((ClickField)source).getPossibleActions();
    SoundManager.notifyOfClickFieldSelection(actions.get(0));
    SoundManager.notifyOfClickFieldSelection(actions.get(0));
    log.debug(""String_Node_Str"" + actions.get(0).toString());
    if (actions == null || actions.size() == 0) {
      log.warn(""String_Node_Str"");
    }
 else     if (actions.get(0) instanceof SellShares) {
      List<String> options=new ArrayList<String>();
      List<SellShares> sellActions=new ArrayList<SellShares>();
      List<Integer> sellAmounts=new ArrayList<Integer>();
      SellShares sale;
      for (      PossibleAction action : actions) {
        sale=(SellShares)action;
        int i=sale.getNumber();
        if (sale.getPresidentExchange() == 0) {
          options.add(LocalText.getText(""String_Node_Str"",i,sale.getShare(),i * sale.getShare(),sale.getCompanyName(),gameUIManager.format(i * sale.getShareUnits() * sale.getPrice())));
        }
 else {
          options.add(LocalText.getText(""String_Node_Str"",i,sale.getShare(),i * sale.getShare(),sale.getCompanyName(),gameUIManager.format(i * sale.getShareUnits() * sale.getPrice()),3 - sale.getPresidentExchange(),sale.getPresidentExchange() * sale.getShareUnit()));
        }
        sellActions.add(sale);
        sellAmounts.add(i);
      }
      int index=0;
      if (options.size() > 1) {
        String message=LocalText.getText(""String_Node_Str"");
        String sp=(String)JOptionPane.showInputDialog(this,message,message,JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
        index=options.indexOf(sp);
      }
 else       if (options.size() == 1) {
        String message=LocalText.getText(""String_Node_Str"");
        int result=JOptionPane.showConfirmDialog(this,options.get(0),message,JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
        index=(result == JOptionPane.OK_OPTION ? 0 : -1);
      }
      if (index < 0) {
      }
 else {
        chosenAction=sellActions.get(index);
      }
    }
 else     if (actions.get(0) instanceof BuyCertificate) {
      boolean startCompany=false;
      List<String> options=new ArrayList<String>();
      List<BuyCertificate> buyActions=new ArrayList<BuyCertificate>();
      List<Integer> buyAmounts=new ArrayList<Integer>();
      BuyCertificate buy;
      String companyName=""String_Node_Str"";
      String playerName=""String_Node_Str"";
      int sharePerCert;
      int sharesPerCert;
      int shareUnit;
      for (      PossibleAction action : actions) {
        buy=(BuyCertificate)action;
        playerName=buy.getPlayerName();
        PublicCompany company=buy.getCompany();
        companyName=company.getId();
        sharePerCert=buy.getSharePerCertificate();
        shareUnit=company.getShareUnit();
        sharesPerCert=sharePerCert / shareUnit;
        if (buy instanceof StartCompany) {
          startCompany=true;
          int[] startPrices;
          if (((StartCompany)buy).mustSelectAPrice()) {
            startPrices=((StartCompany)buy).getStartPrices();
            Arrays.sort(startPrices);
            if (startPrices.length > 1) {
              for (int i=0; i < startPrices.length; i++) {
                options.add(LocalText.getText(""String_Node_Str"",gameUIManager.format(startPrices[i]),sharePerCert,gameUIManager.format(sharesPerCert * startPrices[i])));
                buyActions.add(buy);
                buyAmounts.add(startPrices[i]);
              }
            }
 else {
              options.add(LocalText.getText(""String_Node_Str"",companyName,company.getPresidentsShare().getShare(),gameUIManager.format(company.getPresidentsShare().getShares() * startPrices[0])));
              buyActions.add(buy);
              buyAmounts.add(startPrices[0]);
            }
          }
 else {
            startPrices=new int[]{((StartCompany)buy).getPrice()};
            options.add(LocalText.getText(""String_Node_Str"",companyName,sharePerCert,gameUIManager.format(startPrices[0])));
            buyActions.add(buy);
            buyAmounts.add(startPrices[0]);
          }
        }
 else {
          options.add(LocalText.getText(""String_Node_Str"",sharePerCert,companyName,buy.getFromPortfolio().getId(),gameUIManager.format(sharesPerCert * buy.getPrice())));
          buyActions.add(buy);
          buyAmounts.add(1);
          for (int i=2; i <= buy.getMaximumNumber(); i++) {
            options.add(LocalText.getText(""String_Node_Str"",i,sharePerCert,companyName,buy.getFromPortfolio().getId(),gameUIManager.format(i * sharesPerCert * buy.getPrice())));
            buyActions.add(buy);
            buyAmounts.add(i);
          }
        }
      }
      int index=0;
      if (options.size() > 1) {
        if (startCompany) {
          RadioButtonDialog dialog=new RadioButtonDialog(GameUIManager.COMPANY_START_PRICE_DIALOG,gameUIManager,parent,LocalText.getText(""String_Node_Str""),LocalText.getText(""String_Node_Str"",playerName,companyName),options.toArray(new String[0]),-1);
          gameUIManager.setCurrentDialog(dialog,actions.get(0));
          parent.disableButtons();
          return;
        }
 else {
          String sp=(String)JOptionPane.showInputDialog(this,LocalText.getText(startCompany ? ""String_Node_Str"" : ""String_Node_Str""),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
          index=options.indexOf(sp);
        }
      }
 else       if (options.size() == 1) {
        int result=JOptionPane.showConfirmDialog(this,options.get(0),LocalText.getText(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
        index=(result == JOptionPane.OK_OPTION ? 0 : -1);
      }
      if (index < 0) {
      }
 else       if (startCompany) {
        chosenAction=buyActions.get(index);
        ((StartCompany)chosenAction).setStartPrice(buyAmounts.get(index));
        ((StartCompany)chosenAction).setNumberBought(((StartCompany)chosenAction).getSharesPerCertificate());
      }
 else {
        chosenAction=buyActions.get(index);
        ((BuyCertificate)chosenAction).setNumberBought(buyAmounts.get(index));
      }
    }
 else     if (actions.get(0) instanceof CashCorrectionAction) {
      CashCorrectionAction cca=(CashCorrectionAction)actions.get(0);
      String amountString=(String)JOptionPane.showInputDialog(this,LocalText.getText(""String_Node_Str"",cca.getCashHolderName()),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,null,0);
      if (amountString.substring(0,1).equals(""String_Node_Str""))       amountString=amountString.substring(1);
      int amount;
      try {
        amount=Integer.parseInt(amountString);
      }
 catch (      NumberFormatException e) {
        amount=0;
      }
      cca.setAmount(amount);
      chosenAction=cca;
    }
 else {
      chosenAction=processGameSpecificActions(actor,actions.get(0));
    }
  }
 else {
    log.warn(""String_Node_Str"" + source.toString());
  }
  chosenAction=processGameSpecificFollowUpActions(actor,chosenAction);
  if (chosenAction != null)   (parent).process(chosenAction);
  repaint();
}","public void actionPerformed(ActionEvent actor){
  JComponent source=(JComponent)actor.getSource();
  List<PossibleAction> actions;
  PossibleAction chosenAction=null;
  if (source instanceof ClickField) {
    gbc=gb.getConstraints(source);
    actions=((ClickField)source).getPossibleActions();
    SoundManager.notifyOfClickFieldSelection(actions.get(0));
    SoundManager.notifyOfClickFieldSelection(actions.get(0));
    log.debug(""String_Node_Str"" + actions.get(0).toString());
    if (actions == null || actions.size() == 0) {
      log.warn(""String_Node_Str"");
    }
 else     if (actions.get(0) instanceof SellShares) {
      List<String> options=new ArrayList<String>();
      List<SellShares> sellActions=new ArrayList<SellShares>();
      List<Integer> sellAmounts=new ArrayList<Integer>();
      SellShares sale;
      for (      PossibleAction action : actions) {
        sale=(SellShares)action;
        int i=sale.getNumber();
        if (sale.getPresidentExchange() == 0) {
          options.add(LocalText.getText(""String_Node_Str"",i,sale.getShare(),i * sale.getShare(),sale.getCompanyName(),gameUIManager.format(i * sale.getShareUnits() * sale.getPrice())));
        }
 else {
          options.add(LocalText.getText(""String_Node_Str"",i,sale.getShare(),i * sale.getShare(),sale.getCompanyName(),gameUIManager.format(i * sale.getShareUnits() * sale.getPrice()),3 - sale.getPresidentExchange(),sale.getPresidentExchange() * sale.getShareUnit()));
        }
        sellActions.add(sale);
        sellAmounts.add(i);
      }
      int index=0;
      if (options.size() > 1) {
        String message=LocalText.getText(""String_Node_Str"");
        String sp=(String)JOptionPane.showInputDialog(this,message,message,JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
        index=options.indexOf(sp);
      }
 else       if (options.size() == 1) {
        String message=LocalText.getText(""String_Node_Str"");
        int result=JOptionPane.showConfirmDialog(this,options.get(0),message,JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
        index=(result == JOptionPane.OK_OPTION ? 0 : -1);
      }
      if (index < 0) {
      }
 else {
        chosenAction=sellActions.get(index);
      }
    }
 else     if (actions.get(0) instanceof BuyCertificate) {
      boolean startCompany=false;
      List<String> options=new ArrayList<String>();
      List<BuyCertificate> buyActions=new ArrayList<BuyCertificate>();
      List<Integer> buyAmounts=new ArrayList<Integer>();
      BuyCertificate buy;
      String companyName=""String_Node_Str"";
      String playerName=""String_Node_Str"";
      int sharePerCert;
      int sharesPerCert;
      int shareUnit;
      for (      PossibleAction action : actions) {
        buy=(BuyCertificate)action;
        playerName=buy.getPlayerName();
        PublicCompany company=buy.getCompany();
        companyName=company.getId();
        sharePerCert=buy.getSharePerCertificate();
        shareUnit=company.getShareUnit();
        sharesPerCert=sharePerCert / shareUnit;
        if (buy instanceof StartCompany) {
          startCompany=true;
          int[] startPrices;
          if (((StartCompany)buy).mustSelectAPrice()) {
            startPrices=((StartCompany)buy).getStartPrices();
            Arrays.sort(startPrices);
            if (startPrices.length > 1) {
              for (int i=0; i < startPrices.length; i++) {
                options.add(LocalText.getText(""String_Node_Str"",gameUIManager.format(startPrices[i]),sharePerCert,gameUIManager.format(sharesPerCert * startPrices[i])));
                buyActions.add(buy);
                buyAmounts.add(startPrices[i]);
              }
            }
 else {
              options.add(LocalText.getText(""String_Node_Str"",companyName,company.getPresidentsShare().getShare(),gameUIManager.format(company.getPresidentsShare().getShares() * startPrices[0])));
              buyActions.add(buy);
              buyAmounts.add(startPrices[0]);
            }
          }
 else {
            startPrices=new int[]{((StartCompany)buy).getPrice()};
            options.add(LocalText.getText(""String_Node_Str"",companyName,sharePerCert,gameUIManager.format(startPrices[0])));
            buyActions.add(buy);
            buyAmounts.add(startPrices[0]);
          }
        }
 else {
          options.add(LocalText.getText(""String_Node_Str"",sharePerCert,companyName,buy.getFromPortfolio().getId(),gameUIManager.format(sharesPerCert * buy.getPrice())));
          buyActions.add(buy);
          buyAmounts.add(1);
          for (int i=2; i <= buy.getMaximumNumber(); i++) {
            options.add(LocalText.getText(""String_Node_Str"",i,sharePerCert,companyName,buy.getFromPortfolio().getId(),gameUIManager.format(i * sharesPerCert * buy.getPrice())));
            buyActions.add(buy);
            buyAmounts.add(i);
          }
        }
      }
      int index=0;
      if (options.size() > 1 || actions.get(0) instanceof StartCompany_18EU) {
        if (startCompany) {
          RadioButtonDialog dialog=new RadioButtonDialog(GameUIManager.COMPANY_START_PRICE_DIALOG,gameUIManager,parent,LocalText.getText(""String_Node_Str""),LocalText.getText(""String_Node_Str"",playerName,companyName),options.toArray(new String[0]),-1);
          gameUIManager.setCurrentDialog(dialog,actions.get(0));
          parent.disableButtons();
          return;
        }
 else {
          String sp=(String)JOptionPane.showInputDialog(this,LocalText.getText(startCompany ? ""String_Node_Str"" : ""String_Node_Str""),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
          index=options.indexOf(sp);
        }
      }
 else       if (options.size() == 1) {
        int result=JOptionPane.showConfirmDialog(this,options.get(0),LocalText.getText(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
        index=(result == JOptionPane.OK_OPTION ? 0 : -1);
      }
      if (index < 0) {
      }
 else       if (startCompany) {
        chosenAction=buyActions.get(index);
        ((StartCompany)chosenAction).setStartPrice(buyAmounts.get(index));
        ((StartCompany)chosenAction).setNumberBought(((StartCompany)chosenAction).getSharesPerCertificate());
      }
 else {
        chosenAction=buyActions.get(index);
        ((BuyCertificate)chosenAction).setNumberBought(buyAmounts.get(index));
      }
    }
 else     if (actions.get(0) instanceof CashCorrectionAction) {
      CashCorrectionAction cca=(CashCorrectionAction)actions.get(0);
      String amountString=(String)JOptionPane.showInputDialog(this,LocalText.getText(""String_Node_Str"",cca.getCashHolderName()),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,null,0);
      if (amountString.substring(0,1).equals(""String_Node_Str""))       amountString=amountString.substring(1);
      int amount;
      try {
        amount=Integer.parseInt(amountString);
      }
 catch (      NumberFormatException e) {
        amount=0;
      }
      cca.setAmount(amount);
      chosenAction=cca;
    }
 else {
      chosenAction=processGameSpecificActions(actor,actions.get(0));
    }
  }
 else {
    log.warn(""String_Node_Str"" + source.toString());
  }
  chosenAction=processGameSpecificFollowUpActions(actor,chosenAction);
  if (chosenAction != null)   (parent).process(chosenAction);
  repaint();
}",0.9968064143507508
173468,"private boolean isTrainObsolete(Train train,Owner lastBuyingCompany){
  if (!train.getCertType().isObsoleting())   return false;
  if (obsoleteTrainFor == ObsoleteTrainForType.ALL) {
    return true;
  }
 else {
    Owner owner=train.getOwner();
    return (owner instanceof PublicCompany && owner != lastBuyingCompany);
  }
}","private boolean isTrainObsolete(Train train,Owner lastBuyingCompany){
  if (!train.getCertType().isObsoleting())   return false;
  if (train.getOwner() == pool.getParent())   return false;
  if (obsoleteTrainFor == ObsoleteTrainForType.ALL) {
    return true;
  }
 else {
    Owner owner=train.getOwner();
    return (owner instanceof PublicCompany && owner != lastBuyingCompany);
  }
}",0.9157303370786516
173469,"@Override public void scrollDown(){
  if (!this.isVisible())   return;
  int caretPosition;
  try {
    String docText=editorPane.getDocument().getText(0,editorPane.getDocument().getLength());
    caretPosition=docText.indexOf(ReportBuffer.ACTIVE_MESSAGE_INDICATOR);
  }
 catch (  BadLocationException e) {
    caretPosition=-1;
  }
  ;
  final int caretPositionStore=caretPosition;
  if (caretPosition != -1) {
    editorPane.setCaretPosition(caretPositionStore);
  }
}","@Override public void scrollDown(){
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      int caretPosition;
      try {
        String docText=editorPane.getDocument().getText(0,editorPane.getDocument().getLength());
        caretPosition=docText.indexOf(ReportBuffer.ACTIVE_MESSAGE_INDICATOR);
      }
 catch (      BadLocationException e) {
        caretPosition=-1;
      }
      ;
      final int caretPositionStore=caretPosition;
      if (caretPosition != -1) {
        editorPane.setCaretPosition(caretPositionStore);
      }
    }
  }
);
}",0.8073217726396917
173470,"protected final void initialize(){
  gc=new GridBagConstraints();
  optionsPane=new JPanel();
  buttonPane=new JPanel();
  okButton=new RailsIconButton(RailsIcon.getByConfigKey(okTextKey));
  okButton.setMnemonic(okTextKey.startsWith(""String_Node_Str"") ? KeyEvent.VK_Y : KeyEvent.VK_O);
  okButton.addActionListener(this);
  buttonPane.add(okButton);
  if (hasCancelButton) {
    cancelButton=new RailsIconButton(RailsIcon.getByConfigKey(cancelTextKey));
    cancelButton.setMnemonic(cancelTextKey.startsWith(""String_Node_Str"") ? KeyEvent.VK_N : KeyEvent.VK_C);
    cancelButton.addActionListener(this);
    buttonPane.add(cancelButton);
  }
  getContentPane().setLayout(new GridBagLayout());
  setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  optionsPane.setLayout(new GridBagLayout());
  optionsPane.add(new JLabel(message),constraints(0,0,10,10,10,10));
  initializeInput();
  getContentPane().add(optionsPane,constraints(0,0,0,0,0,0));
  getContentPane().add(buttonPane,constraints(0,1,0,0,0,0));
  pack();
  int x=(int)window.getLocationOnScreen().getX() + (window.getWidth() - getWidth()) / 2;
  int y=(int)window.getLocationOnScreen().getY() + (window.getHeight() - getHeight()) / 2;
  setLocation(x,y);
  setVisible(true);
  setAlwaysOnTop(true);
}","protected final void initialize(){
  gc=new GridBagConstraints();
  optionsPane=new JPanel();
  buttonPane=new JPanel();
  okButton=new RailsIconButton(RailsIcon.getByConfigKey(okTextKey));
  okButton.setMnemonic(okTextKey.startsWith(""String_Node_Str"") ? KeyEvent.VK_Y : KeyEvent.VK_O);
  okButton.addActionListener(this);
  buttonPane.add(okButton);
  if (hasCancelButton) {
    cancelButton=new RailsIconButton(RailsIcon.getByConfigKey(cancelTextKey));
    cancelButton.setMnemonic(cancelTextKey.startsWith(""String_Node_Str"") ? KeyEvent.VK_N : KeyEvent.VK_C);
    cancelButton.addActionListener(this);
    buttonPane.add(cancelButton);
  }
  getContentPane().setLayout(new GridBagLayout());
  setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  optionsPane.setLayout(new GridBagLayout());
  optionsPane.add(new JLabel(message),constraints(0,0,10,10,10,10));
  initializeInput();
  getContentPane().add(optionsPane,constraints(0,0,0,0,0,0));
  getContentPane().add(buttonPane,constraints(0,1,0,0,0,0));
  pack();
  window.setVisible(true);
  int x=(int)window.getLocationOnScreen().getX() + (window.getWidth() - getWidth()) / 2;
  int y=(int)window.getLocationOnScreen().getY() + (window.getHeight() - getHeight()) / 2;
  setLocation(x,y);
  setVisible(true);
  setAlwaysOnTop(true);
}",0.9893992932862192
173471,"public static String getReportItems(){
  int activeIndex=GameManager.getInstance().getRoot().getStateManager().getChangeStack().getCurrentIndex();
  ReportBuffer instance=getInstance();
  StringBuffer s=new StringBuffer();
  s.append(""String_Node_Str"");
  for (  Integer index : instance.reportItems.keySet()) {
    ReportItem item=instance.reportItems.get(index);
    String text=item.toHtml(index == activeIndex);
    String comment=instance.commentItems.get(index);
    if (text == null && comment == null)     continue;
    s.append(""String_Node_Str"");
    if (comment != null) {
      s.append(""String_Node_Str"");
      s.append(item.player.getId() + ""String_Node_Str"");
      s.append(comment + ""String_Node_Str"" + NEWLINE_STRING);
      s.append(""String_Node_Str"");
    }
    if (text != null)     s.append(text);
    s.append(""String_Node_Str"");
  }
  s.append(""String_Node_Str"");
  return s.toString();
}","public static String getReportItems(){
  int activeIndex=GameManager.getInstance().getRoot().getStateManager().getChangeStack().getCurrentIndex();
  ReportBuffer instance=getInstance();
  StringBuffer s=new StringBuffer();
  s.append(""String_Node_Str"");
  for (  Integer index : instance.reportItems.keySet()) {
    ReportItem item=instance.reportItems.get(index);
    String text=item.toHtml(index == activeIndex);
    String comment=instance.commentItems.get(index);
    if (text == null && comment == null)     continue;
    s.append(""String_Node_Str"");
    if (comment != null) {
      s.append(""String_Node_Str"");
      if (item.player == null) {
        s.append(""String_Node_Str"");
      }
 else {
        s.append(item.player.getId() + ""String_Node_Str"");
      }
      s.append(comment + ""String_Node_Str"" + NEWLINE_STRING);
      s.append(""String_Node_Str"");
    }
    if (text != null)     s.append(text);
    s.append(""String_Node_Str"");
  }
  s.append(""String_Node_Str"");
  return s.toString();
}",0.9417273673257024
173472,"private void calculateHexDistances(MapHex hex1,MapHex hex2,int depth){
  if (distances.get(hex1).get(hex2) == null) {
    distances.get(hex1).put(hex2,depth);
  }
 else {
    if (distances.get(hex1).get(hex2) <= depth)     return;
    distances.get(hex1).put(hex2,depth);
  }
  for (  MapHex hex3 : hex2.getNeighbors()) {
    if (hex3 == null)     continue;
    if (distances.get(hex1).get(hex3) == null) {
      calculateHexDistances(hex1,hex3,depth + 1);
    }
 else     if (distances.get(hex1).get(hex3) > depth + 1) {
      calculateHexDistances(hex1,hex3,depth + 1);
    }
  }
}","private void calculateHexDistances(MapHex hex1,MapHex hex2,int depth){
  if (distances.get(hex1).get(hex2) == null) {
    distances.get(hex1).put(hex2,depth);
  }
 else {
    if (distances.get(hex1).get(hex2) <= depth)     return;
    distances.get(hex1).put(hex2,depth);
  }
  for (  MapHex hex3 : getAdjacentHexes(hex2)) {
    if (hex3 == null)     continue;
    if (distances.get(hex1).get(hex3) == null) {
      calculateHexDistances(hex1,hex3,depth + 1);
    }
 else     if (distances.get(hex1).get(hex3) > depth + 1) {
      calculateHexDistances(hex1,hex3,depth + 1);
    }
  }
}",0.5697177074422584
173473,"public boolean modifyCalculator(RevenueAdapter revenueAdapter){
  Phase phase=revenueAdapter.getPhase();
  int bonusValue;
  if (phase.isTileColourAllowed(Tile.GREY_COLOUR_NAME)) {
    bonusValue=30;
  }
 else   if (phase.isTileColourAllowed(Tile.BROWN_COLOUR_NAME)) {
    bonusValue=20;
  }
 else   if (phase.isTileColourAllowed(Tile.GREEN_COLOUR_NAME)) {
    bonusValue=10;
  }
 else {
    return false;
  }
  log.info(""String_Node_Str"" + bonusValue);
  Set<NetworkVertex> offBoard=new HashSet<NetworkVertex>();
  for (  NetworkVertex vertex : revenueAdapter.getVertices()) {
    if (vertex.isStation() && vertex.getStation().getType().equals(Station.OFF_MAP_AREA)) {
      offBoard.add(vertex);
    }
  }
  NetworkVertex hamburgCity=NetworkVertex.getVertexByIdentifier(revenueAdapter.getVertices(),""String_Node_Str"");
  if (hamburgCity != null) {
    NetworkVertex hamburgTerminal=NetworkVertex.duplicateVertex(revenueAdapter.getGraph(),hamburgCity,""String_Node_Str"",true);
    hamburgTerminal.setSink(true);
    offBoard.add(hamburgTerminal);
    VertexVisit hamburgSet=revenueAdapter.new VertexVisit();
    hamburgSet.set.add(hamburgCity);
    hamburgSet.set.add(hamburgTerminal);
    revenueAdapter.addVertexVisitSet(hamburgSet);
  }
  log.info(""String_Node_Str"" + offBoard);
  Set<NetworkVertex> bases=revenueAdapter.getStartVertices();
  Set<NetworkVertex> destOffBoard=new HashSet<NetworkVertex>(offBoard);
  for (  NetworkVertex offA : offBoard) {
    destOffBoard.remove(offA);
    for (    NetworkVertex offB : destOffBoard) {
      for (      NetworkVertex base : bases) {
        RevenueBonus bonus=new RevenueBonus(bonusValue,""String_Node_Str"");
        bonus.addVertex(offA);
        bonus.addVertex(offB);
        bonus.addVertex(base);
        revenueAdapter.addRevenueBonus(bonus);
      }
    }
  }
  return false;
}","public boolean modifyCalculator(RevenueAdapter revenueAdapter){
  Phase phase=revenueAdapter.getPhase();
  int bonusValue;
  if (phase.isTileColourAllowed(Tile.GREY_COLOUR_NAME)) {
    bonusValue=30;
  }
 else   if (phase.isTileColourAllowed(Tile.BROWN_COLOUR_NAME)) {
    bonusValue=20;
  }
 else   if (phase.isTileColourAllowed(Tile.GREEN_COLOUR_NAME)) {
    bonusValue=10;
  }
 else {
    return false;
  }
  log.info(""String_Node_Str"" + bonusValue);
  Set<NetworkVertex> offBoard=new HashSet<NetworkVertex>();
  for (  NetworkVertex vertex : revenueAdapter.getVertices()) {
    if (vertex.isStation() && vertex.getStation().getType().equals(Station.OFF_MAP_AREA)) {
      offBoard.add(vertex);
    }
  }
  NetworkVertex hamburgCity=NetworkVertex.getVertexByIdentifier(revenueAdapter.getVertices(),""String_Node_Str"");
  if (hamburgCity != null) {
    NetworkVertex hamburgTerminal=NetworkVertex.duplicateVertex(revenueAdapter.getGraph(),hamburgCity,""String_Node_Str"",true);
    hamburgTerminal.setSink(true);
    offBoard.add(hamburgTerminal);
    offBoard.remove(hamburgCity);
    VertexVisit hamburgSet=revenueAdapter.new VertexVisit();
    hamburgSet.set.add(hamburgCity);
    hamburgSet.set.add(hamburgTerminal);
    revenueAdapter.addVertexVisitSet(hamburgSet);
  }
  log.info(""String_Node_Str"" + offBoard);
  Set<NetworkVertex> bases=revenueAdapter.getStartVertices();
  Set<NetworkVertex> destOffBoard=new HashSet<NetworkVertex>(offBoard);
  for (  NetworkVertex offA : offBoard) {
    destOffBoard.remove(offA);
    for (    NetworkVertex offB : destOffBoard) {
      for (      NetworkVertex base : bases) {
        RevenueBonus bonus=new RevenueBonus(bonusValue,""String_Node_Str"");
        bonus.addVertex(offA);
        bonus.addVertex(offB);
        bonus.addVertex(base);
        revenueAdapter.addRevenueBonus(bonus);
      }
    }
  }
  return false;
}",0.9908256880733946
173474,"ConfigProfile deriveUserProfile(String name){
  ensureLoad();
  ConfigProfile newProfile=new ConfigProfile(Type.USER,name);
  ConfigProfile reference;
  if (isFinal()) {
    reference=parent;
  }
 else {
    reference=this;
  }
  newProfile.setParent(reference);
  for (  String key : properties.stringPropertyNames()) {
    if (!key.equals(PARENT_KEY) && !key.equals(FINAL_KEY)) {
      newProfile.setProperty(key,properties.getProperty(key));
    }
  }
  return newProfile;
}","ConfigProfile deriveUserProfile(String name){
  ensureLoad();
  ConfigProfile newProfile=new ConfigProfile(Type.USER,name);
  newProfile.loaded=true;
  ConfigProfile reference;
  if (isFinal()) {
    reference=parent;
  }
 else {
    reference=this;
  }
  newProfile.setParent(reference);
  for (  String key : properties.stringPropertyNames()) {
    if (!key.equals(PARENT_KEY) && !key.equals(FINAL_KEY)) {
      newProfile.setProperty(key,properties.getProperty(key));
    }
  }
  return newProfile;
}",0.973469387755102
173475,"public void notifyOfPhase(Phase newPhase){
  if (!newPhase.equals(currentPhase)) {
    currentPhase=newPhase;
    playBackgroundMusic();
  }
}","synchronized public void notifyOfPhase(Phase newPhase){
  if (newPhase != null && !newPhase.equals(currentPhase)) {
    currentPhase=newPhase;
    playBackgroundMusic();
  }
}",0.8958990536277602
173476,"public void notifyOfRound(Round newRound){
  if (!newRound.equals(currentRound)) {
    if (SoundConfig.isSFXEnabled() && !(currentRound instanceof StockRound) && newRound instanceof StockRound) {
      player.playSFXByConfigKey(SoundConfig.KEY_SFX_SR_OpeningBell);
    }
    currentRound=newRound;
    playBackgroundMusic();
  }
}","synchronized public void notifyOfRound(Round newRound){
  if (newRound != null && !newRound.equals(currentRound)) {
    if (SoundConfig.isSFXEnabled() && !(currentRound instanceof StockRound) && newRound instanceof StockRound) {
      player.playSFXByConfigKey(SoundConfig.KEY_SFX_SR_OpeningBell);
    }
    currentRound=newRound;
    playBackgroundMusic();
  }
}",0.9523809523809524
173477,"private void playBackgroundMusic(){
  if (!SoundConfig.isBGMEnabled())   return;
  String currentRoundConfigKey=null;
  if (currentRound instanceof StartRound) {
    currentRoundConfigKey=SoundConfig.KEY_BGM_StartRound;
  }
 else   if (currentRound instanceof StockRound) {
    currentRoundConfigKey=SoundConfig.KEY_BGM_StockRound;
  }
 else   if (currentRound instanceof OperatingRound) {
    currentRoundConfigKey=SoundConfig.KEY_BGM_OperatingRound;
  }
 else   if (currentRound instanceof EndOfGameRound) {
    currentRoundConfigKey=SoundConfig.KEY_BGM_EndOfGameRound;
  }
  if (currentRoundConfigKey != null) {
    String currentPhaseName=""String_Node_Str"";
    if (currentPhase != null)     currentPhaseName=currentPhase.getName();
    String newBackgroundMusicFileName=SoundConfig.get(currentRoundConfigKey,currentPhaseName);
    if (!newBackgroundMusicFileName.equals(currentBackgroundMusicFileName)) {
      currentBackgroundMusicFileName=newBackgroundMusicFileName;
      player.playBGM(newBackgroundMusicFileName);
    }
  }
}","private void playBackgroundMusic(){
  if (!SoundConfig.isBGMEnabled() || currentPhase == null)   return;
  String currentRoundConfigKey=null;
  if (currentRound instanceof StartRound) {
    currentRoundConfigKey=SoundConfig.KEY_BGM_StartRound;
  }
 else   if (currentRound instanceof StockRound) {
    currentRoundConfigKey=SoundConfig.KEY_BGM_StockRound;
  }
 else   if (currentRound instanceof OperatingRound) {
    currentRoundConfigKey=SoundConfig.KEY_BGM_OperatingRound;
  }
 else   if (currentRound instanceof EndOfGameRound) {
    currentRoundConfigKey=SoundConfig.KEY_BGM_EndOfGameRound;
  }
  if (currentRoundConfigKey != null) {
    String currentPhaseName=""String_Node_Str"";
    if (currentPhase != null)     currentPhaseName=currentPhase.getName();
    String newBackgroundMusicFileName=SoundConfig.get(currentRoundConfigKey,currentPhaseName);
    if (!newBackgroundMusicFileName.equals(currentBackgroundMusicFileName)) {
      currentBackgroundMusicFileName=newBackgroundMusicFileName;
      player.playBGM(newBackgroundMusicFileName);
    }
  }
}",0.9885496183206108
173478,"/** 
 * Start a company by buying one or more shares (more applies to e.g. 1841)
 * @param player The player that wants to start a company.
 * @param company The company to start.
 * @param price The start (par) price (ignored if the price is fixed).
 * @param shares The number of shares to buy (can be more than 1 in e.g.1841).
 * @return True if the company could be started. False indicates an error.
 */
@Override public boolean startCompany(String playerName,StartCompany action){
  PublicCompany company=action.getCompany();
  int price=action.getPrice();
  int shares=action.getNumberBought();
  String errMsg=null;
  StockSpace startSpace=null;
  int numberOfCertsToBuy=0;
  PublicCertificate cert=null;
  String companyName=company.getId();
  PublicCompany minor=null;
  StartCompany_18EU startAction=null;
  Stop selectedHomeCity=null;
  currentPlayer=getCurrentPlayer();
  while (true) {
    if (!(action instanceof StartCompany_18EU)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    startAction=(StartCompany_18EU)action;
    if (companyBoughtThisTurnWrapper.value() != null) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    company=companyManager.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.hasStarted()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    cert=ipo.findCertificate(company,true);
    if (shares < cert.getShares())     shares=cert.getShares();
    numberOfCertsToBuy=shares - (cert.getShares() - 1);
    if (!mayPlayerBuyCertificate(currentPlayer,company,numberOfCertsToBuy)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if ((startSpace=stockMarket.getStartSpace(price)) == null) {
      errMsg=LocalText.getText(""String_Node_Str"",Currency.format(this,price),company.getId());
      break;
    }
    if (currentPlayer.getCashValue() < shares * price) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!phase5Reached) {
      minor=startAction.getChosenMinor();
      if (minor != null && currentPlayer.getPortfolioModel().getCertificates(minor) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",currentPlayer.getId(),minor.getId());
        break;
      }
    }
 else {
      selectedHomeCity=startAction.getSelectedHomeStation();
      if (selectedHomeCity.getSlots() <= selectedHomeCity.getBaseTokens().size()) {
        errMsg=LocalText.getText(""String_Node_Str"",selectedHomeCity.toString(),company.getId());
        break;
      }
    }
    numberOfCertsToBuy++;
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,companyName,Currency.format(this,price),errMsg));
    return false;
  }
  ChangeStack.start(this,action);
  MapHex homeHex=null;
  int homeCityNumber=1;
  if (minor != null) {
    homeHex=minor.getHomeHexes().get(0);
    homeCityNumber=homeHex.getCityOfBaseToken(minor);
  }
 else   if (selectedHomeCity != null) {
    homeHex=selectedHomeCity.getParent();
    homeCityNumber=selectedHomeCity.getNumber();
  }
  company.setHomeHex(homeHex);
  company.setHomeCityNumber(homeCityNumber);
  company.start(startSpace);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,companyName,Currency.format(this,price),Currency.format(this,shares * price),shares,cert.getShare(),company.getId()));
  cert.moveTo(currentPlayer);
  Currency.wire(currentPlayer,shares * price,company);
  if (minor != null) {
    PublicCertificate cert2=ipo.findCertificate(company,false);
    cert2.moveTo(currentPlayer);
    int minorCash=minor.getCash();
    int minorTrains=minor.getPortfolioModel().getTrainList().size();
    company.transferAssetsFrom(minor);
    minor.setClosed();
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",currentPlayer.getId(),minor.getId(),company.getId(),Currency.format(this,minorCash),minorTrains));
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",currentPlayer.getId(),cert2.getShare(),company.getId(),ipo.getParent().getId(),minor.getId()));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),selectedHomeCity.toString()));
  }
  Portfolio.moveAll(ipo.getCertificates(company),company);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getPortfolioModel().getShare(company),company.getId()));
  int tokensCost=100;
  String costText=Currency.toBank(company,tokensCost);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),costText,company.getNumberOfBaseTokens()));
  companyBoughtThisTurnWrapper.set(company);
  hasActed.set(true);
  setPriority();
  return true;
}","/** 
 * Start a company by buying one or more shares (more applies to e.g. 1841)
 * @param player The player that wants to start a company.
 * @param company The company to start.
 * @param price The start (par) price (ignored if the price is fixed).
 * @param shares The number of shares to buy (can be more than 1 in e.g.1841).
 * @return True if the company could be started. False indicates an error.
 */
@Override public boolean startCompany(String playerName,StartCompany action){
  PublicCompany company=action.getCompany();
  int price=action.getPrice();
  int shares=action.getNumberBought();
  String errMsg=null;
  StockSpace startSpace=null;
  int numberOfCertsToBuy=0;
  PublicCertificate cert=null;
  String companyName=company.getId();
  PublicCompany minor=null;
  StartCompany_18EU startAction=null;
  Stop selectedHomeCity=null;
  currentPlayer=getCurrentPlayer();
  while (true) {
    if (!(action instanceof StartCompany_18EU)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    startAction=(StartCompany_18EU)action;
    if (companyBoughtThisTurnWrapper.value() != null) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    company=companyManager.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.hasStarted()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    cert=ipo.findCertificate(company,true);
    if (shares < cert.getShares())     shares=cert.getShares();
    numberOfCertsToBuy=shares - (cert.getShares() - 1);
    if (!mayPlayerBuyCertificate(currentPlayer,company,numberOfCertsToBuy)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if ((startSpace=stockMarket.getStartSpace(price)) == null) {
      errMsg=LocalText.getText(""String_Node_Str"",Currency.format(this,price),company.getId());
      break;
    }
    if (currentPlayer.getCashValue() < shares * price) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!phase5Reached) {
      minor=startAction.getChosenMinor();
      if (minor != null && currentPlayer.getPortfolioModel().getCertificates(minor) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",currentPlayer.getId(),minor.getId());
        break;
      }
    }
 else {
      selectedHomeCity=startAction.getSelectedHomeStation();
      if (selectedHomeCity.getSlots() <= selectedHomeCity.getBaseTokens().size()) {
        errMsg=LocalText.getText(""String_Node_Str"",selectedHomeCity.toString(),company.getId());
        break;
      }
    }
    numberOfCertsToBuy++;
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,companyName,Currency.format(this,price),errMsg));
    return false;
  }
  ChangeStack.start(this,action);
  MapHex homeHex=null;
  int homeCityNumber=1;
  if (minor != null) {
    homeHex=minor.getHomeHexes().get(0);
    homeCityNumber=homeHex.getCityOfBaseToken(minor);
  }
 else   if (selectedHomeCity != null) {
    homeHex=selectedHomeCity.getParent();
    homeCityNumber=selectedHomeCity.getNumber();
    try {
      homeHex.addHome(company,homeCityNumber);
    }
 catch (    ConfigurationException e) {
      log.error(e.getStackTrace().toString());
    }
  }
  company.setHomeHex(homeHex);
  company.setHomeCityNumber(homeCityNumber);
  company.start(startSpace);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,companyName,Currency.format(this,price),Currency.format(this,shares * price),shares,cert.getShare(),company.getId()));
  cert.moveTo(currentPlayer);
  Currency.wire(currentPlayer,shares * price,company);
  if (minor != null) {
    PublicCertificate cert2=ipo.findCertificate(company,false);
    cert2.moveTo(currentPlayer);
    int minorCash=minor.getCash();
    int minorTrains=minor.getPortfolioModel().getTrainList().size();
    company.transferAssetsFrom(minor);
    minor.setClosed();
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",currentPlayer.getId(),minor.getId(),company.getId(),Currency.format(this,minorCash),minorTrains));
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",currentPlayer.getId(),cert2.getShare(),company.getId(),ipo.getParent().getId(),minor.getId()));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),selectedHomeCity.toString()));
  }
  Portfolio.moveAll(ipo.getCertificates(company),company);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getPortfolioModel().getShare(company),company.getId()));
  int tokensCost=100;
  String costText=Currency.toBank(company,tokensCost);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),costText,company.getNumberOfBaseTokens()));
  companyBoughtThisTurnWrapper.set(company);
  hasActed.set(true);
  setPriority();
  return true;
}",0.9838909541511772
173479,"protected void checksOnBuying(Certificate cert,int sharePrice){
  if (cert instanceof PublicCertificate) {
    PublicCertificate pubCert=(PublicCertificate)cert;
    PublicCompany comp=pubCert.getCompany();
    if (!comp.hasStarted()) {
      if (!comp.hasStockPrice()) {
        comp.start();
      }
 else       if (pubCert.isPresidentShare()) {
        if (sharePrice > 0) {
          comp.start(sharePrice);
        }
 else         if (comp.getIPOPrice() != 0) {
          comp.start();
        }
 else {
          log.error(""String_Node_Str"" + comp.getId());
        }
      }
    }
    if (comp.hasStarted() && !comp.hasFloated()) {
      checkFlotation(comp);
    }
  }
}","protected void checksOnBuying(Certificate cert,int sharePrice){
  if (cert instanceof PublicCertificate) {
    PublicCertificate pubCert=(PublicCertificate)cert;
    PublicCompany comp=pubCert.getCompany();
    if (!comp.hasStarted()) {
      if (!comp.hasStockPrice()) {
        comp.start();
      }
 else       if (pubCert.isPresidentShare()) {
        if (sharePrice > 0) {
          comp.start(sharePrice);
        }
 else         if (comp.getIPOPrice() != 0) {
          comp.start();
        }
 else {
          log.error(""String_Node_Str"" + comp.getId());
        }
      }
    }
    if (comp.hasStarted() && !comp.hasFloated()) {
      checkFlotation(comp);
    }
    if (comp.hasStarted())     comp.checkPresidency();
  }
}",0.956768249468462
173480,"public Rectangle getRoutesBounds(List<GeneralPath> p1,List<GeneralPath> p2){
  int margin=(int)Math.ceil(strokeWidth * zoomFactor);
  List<Rectangle> pathRects=new ArrayList<Rectangle>();
  if (p1 != null) {
    for (    GeneralPath p : p1)     pathRects.add(p.getBounds());
  }
  if (p2 != null) {
    for (    GeneralPath p : p2)     pathRects.add(p.getBounds());
  }
  Rectangle r=null;
  for (  Rectangle pathRect : pathRects) {
    Rectangle pathMarginRect=new Rectangle(pathRect.x - margin,pathRect.y - margin,pathRect.width + margin * 2,pathRect.y + margin * 2);
    if (r == null) {
      r=pathMarginRect;
    }
 else {
      r.add(pathMarginRect);
    }
  }
  return r;
}","public Rectangle getRoutesBounds(List<GeneralPath> p1,List<GeneralPath> p2){
  int margin=(int)Math.ceil(strokeWidth * zoomFactor);
  List<Rectangle> pathRects=new ArrayList<Rectangle>();
  if (p1 != null) {
    for (    GeneralPath p : p1)     pathRects.add(p.getBounds());
  }
  if (p2 != null) {
    for (    GeneralPath p : p2)     pathRects.add(p.getBounds());
  }
  Rectangle r=null;
  for (  Rectangle pathRect : pathRects) {
    Rectangle pathMarginRect=new Rectangle(pathRect.x - margin,pathRect.y - margin,pathRect.width + margin * 2,pathRect.height + margin * 2);
    if (r == null) {
      r=pathMarginRect;
    }
 else {
      r.add(pathMarginRect);
    }
  }
  return r;
}",0.9948792977322604
173481,"/** 
 * @param zoomAdjustmentFactor Additional factor applied to zoom factor. Usedfor precisely adjusting zoom-step based zoom factors for perfect fit requirements.  
 */
public void setZoomAdjustmentFactor(double zoomAdjustmentFactor){
  ImageLoader.zoomAdjustmentFactor=zoomAdjustmentFactor;
  for (int i=0; i < zoomFactors.length; i++) {
    zoomFactors[i]=0;
  }
}","/** 
 * @param zoomAdjustmentFactor Additional factor applied to zoom factor. Usedfor precisely adjusting zoom-step based zoom factors for perfect fit requirements.  
 */
public void setZoomAdjustmentFactor(double zoomAdjustmentFactor){
  ImageLoader.zoomAdjustmentFactor=zoomAdjustmentFactor;
  for (int i=0; i < zoomFactors.length; i++) {
    zoomFactors[i]=0;
  }
  if (tileMap != null)   tileMap.clear();
}",0.9460154241645244
173482,"private void adjustToNewMapZoom(){
  currentMapSize=map.getCurrentSize();
  log.debug(""String_Node_Str"" + currentMapSize);
  layeredPane.setPreferredSize(currentMapSize);
  map.setBounds(0,0,currentMapSize.width,currentMapSize.height);
  if (mapImage != null) {
    mapImage.setBoundsAndResize(currentMapSize,map.getZoomStep());
  }
  layeredPane.revalidate();
}","private void adjustToNewMapZoom(){
  currentMapSize=map.getCurrentSize();
  log.debug(""String_Node_Str"" + currentMapSize);
  layeredPane.setPreferredSize(currentMapSize);
  map.setBounds(0,0,currentMapSize.width,currentMapSize.height);
  if (mapImage != null) {
    mapImage.setBoundsAndResize(currentMapSize,map.getZoomStep());
  }
  if (gameUIManager.getORUIManager() != null && gameUIManager.getORUIManager().getORPanel() != null)   gameUIManager.getORUIManager().getORPanel().redrawRoutes();
  layeredPane.revalidate();
}",0.8162344983089064
173483,"private void redrawRoutes(){
  if (revenueAdapter != null && isDisplayRoutes()) {
    revenueAdapter.drawOptimalRunAsPath(orUIManager.getMap());
  }
}","public void redrawRoutes(){
  if (revenueAdapter != null && isDisplayRoutes()) {
    revenueAdapter.drawOptimalRunAsPath(orUIManager.getMap());
  }
}",0.9698996655518396
173484,"public void actionPerformed(ActionEvent actor){
  JComponent source=(JComponent)actor.getSource();
  String command=actor.getActionCommand();
  List<PossibleAction> executedActions=null;
  PossibleAction executedAction=null;
  if (source instanceof ActionTaker) {
    executedActions=((ActionTaker)source).getPossibleActions();
    if (!executedActions.isEmpty()) {
      executedAction=executedActions.get(0);
      log.debug(""String_Node_Str"" + executedAction.toString());
    }
    if (executedAction instanceof SetDividend) {
      setSelect(revenue[orCompIndex],revenueSelect[orCompIndex],false);
    }
    orUIManager.processAction(command,executedActions);
  }
 else   if (source == zoomIn) {
    fitToWindow.setSelected(false);
    fitToWidth.setSelected(false);
    fitToHeight.setSelected(false);
    orWindow.getMapPanel().zoom(true);
    redrawRoutes();
  }
 else   if (source == zoomOut) {
    fitToWindow.setSelected(false);
    fitToWidth.setSelected(false);
    fitToHeight.setSelected(false);
    orWindow.getMapPanel().zoom(false);
    redrawRoutes();
  }
 else   if (source == fitToWindow) {
    if (fitToWindow.isSelected()) {
      fitToWidth.setSelected(false);
      fitToHeight.setSelected(false);
      orWindow.getMapPanel().fitToWindow();
      redrawRoutes();
    }
 else {
      orWindow.getMapPanel().removeFitToOption();
    }
  }
 else   if (source == fitToWidth) {
    if (fitToWidth.isSelected()) {
      fitToWindow.setSelected(false);
      fitToHeight.setSelected(false);
      orWindow.getMapPanel().fitToWidth();
      redrawRoutes();
    }
 else {
      orWindow.getMapPanel().removeFitToOption();
    }
  }
 else   if (source == fitToHeight) {
    if (fitToHeight.isSelected()) {
      fitToWindow.setSelected(false);
      fitToWidth.setSelected(false);
      orWindow.getMapPanel().fitToHeight();
      redrawRoutes();
    }
 else {
      orWindow.getMapPanel().removeFitToOption();
    }
  }
 else   if (source == calibrateMap) {
    MapManager mapManager=orUIManager.getMap().getMapManager();
    String offsetX=JOptionPane.showInputDialog(this,""String_Node_Str"",mapManager.getMapXOffset());
    try {
      mapManager.setMapXOffset(Integer.parseInt(offsetX));
    }
 catch (    NumberFormatException e) {
    }
    String offsetY=JOptionPane.showInputDialog(this,""String_Node_Str"",mapManager.getMapYOffset());
    try {
      mapManager.setMapYOffset(Integer.parseInt(offsetY));
    }
 catch (    NumberFormatException e) {
    }
    String scale=JOptionPane.showInputDialog(this,""String_Node_Str"",mapManager.getMapScale());
    try {
      mapManager.setMapScale(Float.parseFloat(scale));
    }
 catch (    NumberFormatException e) {
    }
    orWindow.getMapPanel().zoom(true);
    orWindow.getMapPanel().zoom(false);
  }
 else   if (command == NETWORK_INFO_CMD) {
    JMenuItem item=(JMenuItem)actor.getSource();
    executeNetworkInfo(item.getText());
  }
 else {
    orUIManager.processAction(command,null);
  }
}","public void actionPerformed(ActionEvent actor){
  JComponent source=(JComponent)actor.getSource();
  String command=actor.getActionCommand();
  List<PossibleAction> executedActions=null;
  PossibleAction executedAction=null;
  if (source instanceof ActionTaker) {
    executedActions=((ActionTaker)source).getPossibleActions();
    if (!executedActions.isEmpty()) {
      executedAction=executedActions.get(0);
      log.debug(""String_Node_Str"" + executedAction.toString());
    }
    if (executedAction instanceof SetDividend) {
      setSelect(revenue[orCompIndex],revenueSelect[orCompIndex],false);
    }
    orUIManager.processAction(command,executedActions);
  }
 else   if (source == zoomIn) {
    fitToWindow.setSelected(false);
    fitToWidth.setSelected(false);
    fitToHeight.setSelected(false);
    orWindow.getMapPanel().zoom(true);
  }
 else   if (source == zoomOut) {
    fitToWindow.setSelected(false);
    fitToWidth.setSelected(false);
    fitToHeight.setSelected(false);
    orWindow.getMapPanel().zoom(false);
  }
 else   if (source == fitToWindow) {
    if (fitToWindow.isSelected()) {
      fitToWidth.setSelected(false);
      fitToHeight.setSelected(false);
      orWindow.getMapPanel().fitToWindow();
    }
 else {
      orWindow.getMapPanel().removeFitToOption();
    }
  }
 else   if (source == fitToWidth) {
    if (fitToWidth.isSelected()) {
      fitToWindow.setSelected(false);
      fitToHeight.setSelected(false);
      orWindow.getMapPanel().fitToWidth();
    }
 else {
      orWindow.getMapPanel().removeFitToOption();
    }
  }
 else   if (source == fitToHeight) {
    if (fitToHeight.isSelected()) {
      fitToWindow.setSelected(false);
      fitToWidth.setSelected(false);
      orWindow.getMapPanel().fitToHeight();
    }
 else {
      orWindow.getMapPanel().removeFitToOption();
    }
  }
 else   if (source == calibrateMap) {
    MapManager mapManager=orUIManager.getMap().getMapManager();
    String offsetX=JOptionPane.showInputDialog(this,""String_Node_Str"",mapManager.getMapXOffset());
    try {
      mapManager.setMapXOffset(Integer.parseInt(offsetX));
    }
 catch (    NumberFormatException e) {
    }
    String offsetY=JOptionPane.showInputDialog(this,""String_Node_Str"",mapManager.getMapYOffset());
    try {
      mapManager.setMapYOffset(Integer.parseInt(offsetY));
    }
 catch (    NumberFormatException e) {
    }
    String scale=JOptionPane.showInputDialog(this,""String_Node_Str"",mapManager.getMapScale());
    try {
      mapManager.setMapScale(Float.parseFloat(scale));
    }
 catch (    NumberFormatException e) {
    }
    orWindow.getMapPanel().zoom(true);
    orWindow.getMapPanel().zoom(false);
  }
 else   if (command == NETWORK_INFO_CMD) {
    JMenuItem item=(JMenuItem)actor.getSource();
    executeNetworkInfo(item.getText());
  }
 else {
    orUIManager.processAction(command,null);
  }
}",0.9817931982136724
173485,"private static void initialLoad(){
  if (legacyConfigFile) {
    if (!propertiesLoaded) {
      loadPropertyFile(defaultProperties,selectedProfile,false);
      propertiesLoaded=true;
      setSaveDirDefaults();
    }
    return;
  }
  if (!profilesLoaded) {
    loadPropertyFile(defaultProfiles,defaultProfilesFile,true);
    loadPropertyFile(userProfiles,userProfilesFile,false);
    profilesLoaded=true;
  }
  log.info(""String_Node_Str"" + selectedProfile);
  if (!propertiesLoaded) {
    loadProfile(selectedProfile);
    propertiesLoaded=true;
  }
  Properties versionNumber=new Properties();
  loadPropertyFile(versionNumber,""String_Node_Str"",true);
  String version=versionNumber.getProperty(""String_Node_Str"");
  String develop=versionNumber.getProperty(""String_Node_Str"");
  if (Util.hasValue(""String_Node_Str"")) {
    if (Util.hasValue(develop)) {
      RailsRoot.version=version + ""String_Node_Str"";
    }
 else {
      RailsRoot.version=version;
    }
  }
}","private static void initialLoad(){
  if (legacyConfigFile) {
    if (!propertiesLoaded) {
      loadPropertyFile(defaultProperties,selectedProfile,false);
      propertiesLoaded=true;
      setSaveDirDefaults();
    }
    return;
  }
  if (!profilesLoaded) {
    loadPropertyFile(defaultProfiles,defaultProfilesFile,true);
    loadPropertyFile(userProfiles,userProfilesFile,false);
    profilesLoaded=true;
  }
  log.info(""String_Node_Str"" + selectedProfile);
  if (!propertiesLoaded) {
    loadProfile(selectedProfile);
    propertiesLoaded=true;
  }
  Properties versionNumber=new Properties();
  loadPropertyFile(versionNumber,""String_Node_Str"",true);
  String version=versionNumber.getProperty(""String_Node_Str"");
  if (Util.hasValue(""String_Node_Str"")) {
    RailsRoot.setVersion(version);
  }
  String develop=versionNumber.getProperty(""String_Node_Str"");
  if (Util.hasValue(develop)) {
    RailsRoot.setDevelop(develop != ""String_Node_Str"");
  }
}",0.8569942797711908
173486,"protected void addNetworkInfo(){
  if (networkInfoMenu != null)   infoMenu.remove(networkInfoMenu);
  networkInfoMenu=createNetworkInfo();
  if (networkInfoMenu == null)   return;
  networkInfoMenu.setEnabled(true);
  infoMenu.add(networkInfoMenu);
}","protected void addNetworkInfo(){
  if (networkInfoMenu != null)   infoMenu.remove(networkInfoMenu);
  networkInfoMenu=createNetworkInfo();
  if (networkInfoMenu == null)   return;
  networkInfoMenu.setEnabled(RailsRoot.getDevelop());
  infoMenu.add(networkInfoMenu);
}",0.9498069498069498
173487,"public ORPanel(ORWindow parent,ORUIManager orUIManager){
  super();
  orWindow=parent;
  this.orUIManager=orUIManager;
  GameUIManager gameUIManager=parent.gameUIManager;
  statusPanel=new JPanel();
  gb=new GridBagLayout();
  statusPanel.setLayout(gb);
  statusPanel.setBorder(BorderFactory.createEtchedBorder());
  statusPanel.setOpaque(true);
  gridPanel=statusPanel;
  parentFrame=parent;
  round=gameUIManager.getCurrentRound();
  privatesCanBeBought=gameUIManager.getGameParameterAsBoolean(GuiDef.Parm.CAN_ANY_COMPANY_BUY_PRIVATES);
  bonusTokensExist=gameUIManager.getGameParameterAsBoolean(GuiDef.Parm.DO_BONUS_TOKENS_EXIST);
  hasCompanyLoans=gameUIManager.getGameParameterAsBoolean(GuiDef.Parm.HAS_ANY_COMPANY_LOANS);
  hasRights=gameUIManager.getGameParameterAsBoolean(GuiDef.Parm.HAS_ANY_RIGHTS);
  initButtonPanel();
  gbc=new GridBagConstraints();
  players=gameUIManager.getPlayers().toArray(new Player[0]);
  if (round instanceof OperatingRound) {
    companies=((OperatingRound)round).getOperatingCompanies().toArray(new PublicCompany[0]);
    nc=companies.length;
  }
  initFields();
  setLayout(new BorderLayout());
  add(statusPanel,BorderLayout.CENTER);
  add(buttonPanel,BorderLayout.SOUTH);
  menuBar=new JMenuBar();
  infoMenu=new JMenu(LocalText.getText(""String_Node_Str""));
  infoMenu.setEnabled(true);
  remainingTilesMenuItem=new JMenuItem(LocalText.getText(""String_Node_Str""));
  remainingTilesMenuItem.addActionListener(this);
  remainingTilesMenuItem.setActionCommand(REM_TILES_CMD);
  infoMenu.add(remainingTilesMenuItem);
  menuBar.add(infoMenu);
  addCompanyInfo();
  addTrainsInfo();
  addPhasesInfo();
  addNetworkInfo();
  specialMenu=new JMenu(LocalText.getText(""String_Node_Str""));
  specialMenu.setBackground(Color.YELLOW);
  specialMenu.setEnabled(false);
  menuBar.add(specialMenu);
  if (hasCompanyLoans) {
    loansMenu=new JMenu(LocalText.getText(""String_Node_Str""));
    loansMenu.setEnabled(true);
    takeLoans=new ActionMenuItem(LocalText.getText(""String_Node_Str""));
    takeLoans.addActionListener(this);
    takeLoans.setEnabled(false);
    loansMenu.add(takeLoans);
    menuItemsToReset.add(takeLoans);
    repayLoans=new ActionMenuItem(LocalText.getText(""String_Node_Str""));
    repayLoans.addActionListener(this);
    repayLoans.setEnabled(false);
    loansMenu.add(repayLoans);
    menuItemsToReset.add(repayLoans);
    menuBar.add(loansMenu);
  }
  zoomMenu=new JMenu(""String_Node_Str"");
  zoomMenu.setEnabled(true);
  zoomIn=new JMenuItem(""String_Node_Str"");
  zoomIn.addActionListener(this);
  zoomIn.setEnabled(true);
  zoomMenu.add(zoomIn);
  zoomOut=new JMenuItem(""String_Node_Str"");
  zoomOut.addActionListener(this);
  zoomOut.setEnabled(true);
  zoomMenu.add(zoomOut);
  calibrateMap=new JMenuItem(""String_Node_Str"");
  calibrateMap.addActionListener(this);
  calibrateMap.setEnabled(true);
  zoomMenu.add(calibrateMap);
  menuBar.add(zoomMenu);
  add(menuBar,BorderLayout.NORTH);
  setVisible(true);
  addKeyListener(this);
}","public ORPanel(ORWindow parent,ORUIManager orUIManager){
  super();
  orWindow=parent;
  this.orUIManager=orUIManager;
  GameUIManager gameUIManager=parent.gameUIManager;
  statusPanel=new JPanel();
  gb=new GridBagLayout();
  statusPanel.setLayout(gb);
  statusPanel.setBorder(BorderFactory.createEtchedBorder());
  statusPanel.setOpaque(true);
  gridPanel=statusPanel;
  parentFrame=parent;
  round=gameUIManager.getCurrentRound();
  privatesCanBeBought=gameUIManager.getGameParameterAsBoolean(GuiDef.Parm.CAN_ANY_COMPANY_BUY_PRIVATES);
  bonusTokensExist=gameUIManager.getGameParameterAsBoolean(GuiDef.Parm.DO_BONUS_TOKENS_EXIST);
  hasCompanyLoans=gameUIManager.getGameParameterAsBoolean(GuiDef.Parm.HAS_ANY_COMPANY_LOANS);
  hasRights=gameUIManager.getGameParameterAsBoolean(GuiDef.Parm.HAS_ANY_RIGHTS);
  initButtonPanel();
  gbc=new GridBagConstraints();
  players=gameUIManager.getPlayers().toArray(new Player[0]);
  if (round instanceof OperatingRound) {
    companies=((OperatingRound)round).getOperatingCompanies().toArray(new PublicCompany[0]);
    nc=companies.length;
  }
  initFields();
  setLayout(new BorderLayout());
  add(statusPanel,BorderLayout.CENTER);
  add(buttonPanel,BorderLayout.SOUTH);
  menuBar=new JMenuBar();
  infoMenu=new JMenu(LocalText.getText(""String_Node_Str""));
  infoMenu.setEnabled(true);
  remainingTilesMenuItem=new JMenuItem(LocalText.getText(""String_Node_Str""));
  remainingTilesMenuItem.addActionListener(this);
  remainingTilesMenuItem.setActionCommand(REM_TILES_CMD);
  infoMenu.add(remainingTilesMenuItem);
  menuBar.add(infoMenu);
  addCompanyInfo();
  addTrainsInfo();
  addPhasesInfo();
  addNetworkInfo();
  specialMenu=new JMenu(LocalText.getText(""String_Node_Str""));
  specialMenu.setBackground(Color.YELLOW);
  specialMenu.setEnabled(false);
  menuBar.add(specialMenu);
  if (hasCompanyLoans) {
    loansMenu=new JMenu(LocalText.getText(""String_Node_Str""));
    loansMenu.setEnabled(true);
    takeLoans=new ActionMenuItem(LocalText.getText(""String_Node_Str""));
    takeLoans.addActionListener(this);
    takeLoans.setEnabled(false);
    loansMenu.add(takeLoans);
    menuItemsToReset.add(takeLoans);
    repayLoans=new ActionMenuItem(LocalText.getText(""String_Node_Str""));
    repayLoans.addActionListener(this);
    repayLoans.setEnabled(false);
    loansMenu.add(repayLoans);
    menuItemsToReset.add(repayLoans);
    menuBar.add(loansMenu);
  }
  zoomMenu=new JMenu(""String_Node_Str"");
  zoomMenu.setEnabled(true);
  zoomIn=new JMenuItem(""String_Node_Str"");
  zoomIn.addActionListener(this);
  zoomIn.setEnabled(true);
  zoomMenu.add(zoomIn);
  zoomOut=new JMenuItem(""String_Node_Str"");
  zoomOut.addActionListener(this);
  zoomOut.setEnabled(true);
  zoomMenu.add(zoomOut);
  calibrateMap=new JMenuItem(""String_Node_Str"");
  calibrateMap.addActionListener(this);
  calibrateMap.setEnabled(RailsRoot.getDevelop());
  zoomMenu.add(calibrateMap);
  menuBar.add(zoomMenu);
  add(menuBar,BorderLayout.NORTH);
  setVisible(true);
  addKeyListener(this);
}",0.9956666666666668
173488,"/** 
 * sets the meta data required for a game save
 */
public void initSave(Long saveFileVersionID,String gameName,Map<String,String> gameOptions,List<String> playerNames){
  gameData.meta.version=RailsRoot.version + ""String_Node_Str"" + BuildInfo.buildDate;
  gameData.meta.date=new SimpleDateFormat(""String_Node_Str"").format(new Date());
  gameData.meta.fileVersionID=saveFileVersionID;
  gameData.meta.gameName=gameName;
  gameData.gameOptions=gameOptions;
  gameData.playerNames=playerNames;
  initSave=true;
}","/** 
 * sets the meta data required for a game save
 */
public void initSave(Long saveFileVersionID,String gameName,Map<String,String> gameOptions,List<String> playerNames){
  gameData.meta.version=RailsRoot.getFullVersion() + ""String_Node_Str"" + BuildInfo.buildDate;
  gameData.meta.date=new SimpleDateFormat(""String_Node_Str"").format(new Date());
  gameData.meta.fileVersionID=saveFileVersionID;
  gameData.meta.gameName=gameName;
  gameData.gameOptions=gameOptions;
  gameData.playerNames=playerNames;
  initSave=true;
}",0.9778206364513018
173489,"@Override protected void finishRound(){
  ReportBuffer.add(""String_Node_Str"");
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",String.valueOf(getStockRoundNumber())));
  for (  PublicCompany company : gameManager.getCompaniesInRunningOrder()) {
    if (company.hasStockPrice() && company.isSoldOut()) {
      StockSpace oldSpace=company.getCurrentSpace();
      stockMarket.soldOut(company);
      StockSpace newSpace=company.getCurrentSpace();
      if (newSpace != oldSpace) {
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),Currency.format(this,oldSpace.getPrice()),oldSpace.getId(),Currency.format(this,newSpace.getPrice()),newSpace.getId()));
      }
 else {
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),Currency.format(this,newSpace.getPrice()),newSpace.getId()));
      }
    }
  }
  super.finishRound();
}","@Override protected void finishRound(){
  ReportBuffer.add(""String_Node_Str"");
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",String.valueOf(getStockRoundNumber())));
  if (raiseIfSoldOut) {
    for (    PublicCompany company : gameManager.getCompaniesInRunningOrder()) {
      if (company.hasStockPrice() && company.isSoldOut()) {
        StockSpace oldSpace=company.getCurrentSpace();
        stockMarket.soldOut(company);
        StockSpace newSpace=company.getCurrentSpace();
        if (newSpace != oldSpace) {
          ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),Currency.format(this,oldSpace.getPrice()),oldSpace.getId(),Currency.format(this,newSpace.getPrice()),newSpace.getId()));
        }
 else {
          ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),Currency.format(this,newSpace.getPrice()),newSpace.getId()));
        }
      }
    }
  }
  super.finishRound();
}",0.9647577092511012
173490,"/** 
 * Constructed via Configure
 */
public StockRound(GameManager parent,String id){
  super(parent,id);
  if (numberOfPlayers == 0)   numberOfPlayers=gameManager.getPlayers().size();
  sequenceRule=getGameParameterAsInt(GameDef.Parm.STOCK_ROUND_SEQUENCE);
  guiHints.setVisibilityHint(GuiDef.Panel.MAP,true);
  guiHints.setVisibilityHint(GuiDef.Panel.STOCK_MARKET,true);
  guiHints.setActivePanel(GuiDef.Panel.STATUS);
}","/** 
 * Constructed via Configure
 */
public StockRound(GameManager parent,String id){
  super(parent,id);
  if (numberOfPlayers == 0)   numberOfPlayers=gameManager.getPlayers().size();
  sequenceRule=getGameParameterAsInt(GameDef.Parm.STOCK_ROUND_SEQUENCE);
  raiseIfSoldOut=true;
  guiHints.setVisibilityHint(GuiDef.Panel.MAP,true);
  guiHints.setVisibilityHint(GuiDef.Panel.STOCK_MARKET,true);
  guiHints.setActivePanel(GuiDef.Panel.STATUS);
}",0.9735327963176064
173491,"public FinalMinorExchangeRound(GameManager parent,String id){
  super(parent,id);
  guiHints.setVisibilityHint(GuiDef.Panel.MAP,true);
  guiHints.setActivePanel(GuiDef.Panel.STATUS);
}","public FinalMinorExchangeRound(GameManager parent,String id){
  super(parent,id);
  guiHints.setVisibilityHint(GuiDef.Panel.MAP,true);
  guiHints.setActivePanel(GuiDef.Panel.STATUS);
  raiseIfSoldOut=false;
}",0.9387755102040816
173492,"@Override public void start(){
  prussian=companyManager.getPublicCompany(PR_ID);
  phase=getCurrentPhase();
  startPr=!prussian.hasStarted();
  forcedMerge=phase.getName().equals(""String_Node_Str"");
  forcedStart=phase.getName().equals(""String_Node_Str"") || forcedMerge;
  mergePr=!prussianIsComplete(gameManager);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",PR_ID));
  log.debug(""String_Node_Str"" + startPr + ""String_Node_Str""+ forcedStart+ ""String_Node_Str""+ mergePr+ ""String_Node_Str""+ forcedMerge);
  step=startPr ? Step.START : Step.MERGE;
  if (step == Step.START) {
    m2=companyManager.getPublicCompany(M2_ID);
    setCurrentPlayer(m2.getPresident());
    ((GameManager_1835)gameManager).setPrussianFormationStartingPlayer(currentPlayer);
    if (forcedStart) {
      executeStartPrussian(true);
      step=Step.MERGE;
    }
  }
  if (step == Step.MERGE) {
    startingPlayer=((GameManager_1835)gameManager).getPrussianFormationStartingPlayer();
    log.debug(""String_Node_Str"" + startingPlayer.getId());
    setCurrentPlayer(startingPlayer);
    if (forcedMerge) {
      Set<SpecialProperty> sps;
      setFoldablePrePrussians();
      List<Company> foldables=new ArrayList<Company>();
      for (      PrivateCompany company : gameManager.getAllPrivateCompanies()) {
        if (company.isClosed())         continue;
        sps=company.getSpecialProperties();
        if (sps != null && !sps.isEmpty() && Iterables.get(sps,0) instanceof ExchangeForShare) {
          foldables.add(company);
        }
      }
      for (      PublicCompany company : gameManager.getAllPublicCompanies()) {
        if (company.isClosed())         continue;
        sps=company.getSpecialProperties();
        if (sps != null && !sps.isEmpty() && Iterables.get(sps,0) instanceof ExchangeForShare) {
          foldables.add(company);
        }
      }
      executeExchange(foldables,false,true);
      finishRound();
    }
 else {
      findNextMergingPlayer(false);
    }
  }
}","@Override public void start(){
  prussian=companyManager.getPublicCompany(PR_ID);
  phase=getCurrentPhase();
  startPr=!prussian.hasStarted();
  forcedMerge=phase.getName().equals(""String_Node_Str"");
  forcedStart=phase.getName().equals(""String_Node_Str"") || forcedMerge;
  mergePr=!prussianIsComplete(gameManager);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",PR_ID));
  log.debug(""String_Node_Str"" + startPr + ""String_Node_Str""+ forcedStart+ ""String_Node_Str""+ mergePr+ ""String_Node_Str""+ forcedMerge);
  step=startPr ? Step.START : Step.MERGE;
  if (step == Step.START) {
    m2=companyManager.getPublicCompany(M2_ID);
    setCurrentPlayer(m2.getPresident());
    ((GameManager_1835)gameManager).setPrussianFormationStartingPlayer(currentPlayer);
    if (forcedStart) {
      executeStartPrussian(true);
      step=Step.MERGE;
    }
  }
  if (step == Step.MERGE) {
    startingPlayer=((GameManager_1835)gameManager).getPrussianFormationStartingPlayer();
    log.debug(""String_Node_Str"" + startingPlayer.getId());
    setCurrentPlayer(startingPlayer);
    if (forcedMerge) {
      Set<SpecialProperty> sps;
      setFoldablePrePrussians();
      List<Company> foldables=new ArrayList<Company>();
      for (      PrivateCompany company : gameManager.getAllPrivateCompanies()) {
        if (company.isClosed())         continue;
        sps=company.getSpecialProperties();
        if (sps != null && !sps.isEmpty() && Iterables.get(sps,0) instanceof ExchangeForShare) {
          foldables.add(company);
        }
      }
      for (      PublicCompany company : gameManager.getAllPublicCompanies()) {
        if (company.isClosed())         continue;
        sps=company.getSpecialProperties();
        if (sps != null && !sps.isEmpty() && Iterables.get(sps,0) instanceof ExchangeForShare) {
          foldables.add(company);
        }
      }
      executeExchange(foldables,false,true);
      if (prussian.getNumberOfTrains() > prussian.getCurrentTrainLimit()) {
        step=Step.DISCARD_TRAINS;
      }
 else {
        finishRound();
      }
    }
 else {
      findNextMergingPlayer(false);
    }
  }
}",0.9668454412481716
173493,"@Override public boolean setPossibleActions(){
  if (step == Step.START) {
    Player m2Owner=m2.getPresident();
    startingPlayer=m2Owner;
    setCurrentPlayer(m2Owner);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",getCurrentPlayer().getId()));
    possibleActions.add(new FoldIntoPrussian(m2));
  }
 else   if (step == Step.MERGE) {
    possibleActions.add(new FoldIntoPrussian(foldablePrePrussians));
  }
 else   if (step == Step.DISCARD_TRAINS) {
    if (prussian.getNumberOfTrains() > prussian.getCurrentTrainLimit()) {
      possibleActions.add(new DiscardTrain(prussian,prussian.getPortfolioModel().getUniqueTrains(),true));
    }
  }
  return true;
}","@Override public boolean setPossibleActions(){
  if (step == Step.START) {
    Player m2Owner=m2.getPresident();
    startingPlayer=m2Owner;
    setCurrentPlayer(m2Owner);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",getCurrentPlayer().getId()));
    possibleActions.add(new FoldIntoPrussian(m2));
  }
 else   if (step == Step.MERGE) {
    possibleActions.add(new FoldIntoPrussian(foldablePrePrussians));
  }
 else   if (step == Step.DISCARD_TRAINS) {
    if (prussian.getNumberOfTrains() > prussian.getCurrentTrainLimit()) {
      log.debug(""String_Node_Str"" + prussian.getNumberOfTrains() + ""String_Node_Str""+ prussian.getCurrentTrainLimit());
      possibleActions.add(new DiscardTrain(prussian,prussian.getPortfolioModel().getUniqueTrains(),true));
    }
  }
  return true;
}",0.9179206566347468
173494,"public boolean discardTrain(DiscardTrain action){
  Train train=action.getDiscardedTrain();
  PublicCompany company=action.getCompany();
  String errMsg=null;
  while (true) {
    if (company != prussian) {
      errMsg=LocalText.getText(""String_Node_Str"",company.getId(),prussian.getId());
      break;
    }
    if (train == null && action.isForced()) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!company.getPortfolioModel().getTrainList().contains(train)) {
      errMsg=LocalText.getText(""String_Node_Str"",company.getId(),train.toText());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),(train != null ? train.toText() : ""String_Node_Str""),errMsg));
    return false;
  }
  ChangeStack.start(this,action);
  pool.addTrain(train);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),train.toText()));
  finishRound();
  return true;
}","public boolean discardTrain(DiscardTrain action){
  Train train=action.getDiscardedTrain();
  PublicCompany company=action.getCompany();
  String errMsg=null;
  while (true) {
    if (company != prussian) {
      errMsg=LocalText.getText(""String_Node_Str"",company.getId(),prussian.getId());
      break;
    }
    if (train == null && action.isForced()) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!company.getPortfolioModel().getTrainList().contains(train)) {
      errMsg=LocalText.getText(""String_Node_Str"",company.getId(),train.toText());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),(train != null ? train.toText() : ""String_Node_Str""),errMsg));
    return false;
  }
  ChangeStack.start(this,action);
  pool.addTrain(train);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),train.toText()));
  if (prussian.getNumberOfTrains() > prussian.getCurrentTrainLimit()) {
    step=Step.DISCARD_TRAINS;
  }
 else {
    finishRound();
  }
  return true;
}",0.9295366795366796
173495,"public void finishConfiguration(GameManager gameManager) throws ConfigurationException {
  MapHex hex;
  int i, j, k;
  MapHex nb;
  mapImageUsed=rails.util.Util.hasValue(mapImageFilename) && ""String_Node_Str"".equalsIgnoreCase(Config.get(""String_Node_Str""));
  if (mapImageUsed) {
    String rootDirectory=Config.get(""String_Node_Str"");
    if (!rails.util.Util.hasValue(rootDirectory)) {
      rootDirectory=""String_Node_Str"";
    }
    mapImageFilepath=rootDirectory + ""String_Node_Str"" + mapImageFilename;
  }
  for (  String hexName : mHexes.keySet()) {
    hex=mHexes.get(hexName);
    hex.finishConfiguration(gameManager);
  }
  int ii, jj;
  for (i=minX; i <= maxX; i++) {
    for (j=minY; j <= maxY; j++) {
      if ((hex=hexes[i][j]) == null)       continue;
      for (k=0; k < 6; k++) {
        ii=getAdjacentX(i,j,k);
        jj=getAdjacentY(i,j,k);
        if (ii >= minX && ii <= maxX && jj >= minY && jj <= maxY && (nb=hexes[ii][jj]) != null) {
          if (hex.isNeighbour(nb,k) && nb.isNeighbour(hex,k + 3)) {
            hex.setNeighbor(k,nb);
            nb.setNeighbor(k + 3,hex);
          }
          if (hex.isImpassable(nb) || nb.isImpassable(hex)) {
            hex.addImpassableSide(k);
          }
        }
      }
    }
  }
  List<MapHex> homeHexes;
  for (  PublicCompany company : gameManager.getCompanyManager().getAllPublicCompanies()) {
    if ((homeHexes=company.getHomeHexes()) != null) {
      for (      MapHex homeHex : homeHexes) {
        homeHex.addHome(company,company.getHomeCityNumber());
      }
    }
    if ((hex=company.getDestinationHex()) != null) {
      hex.addDestination(company);
    }
  }
}","public void finishConfiguration(GameManager gameManager) throws ConfigurationException {
  MapHex hex;
  int i, j, k;
  MapHex nb;
  mapImageUsed=rails.util.Util.hasValue(mapImageFilename) && ""String_Node_Str"".equalsIgnoreCase(Config.get(""String_Node_Str""));
  if (mapImageUsed) {
    String rootDirectory=Config.get(""String_Node_Str"");
    if (!rails.util.Util.hasValue(rootDirectory)) {
      rootDirectory=""String_Node_Str"";
    }
    mapImageFilepath=""String_Node_Str"" + rootDirectory + ""String_Node_Str""+ mapImageFilename;
  }
  for (  String hexName : mHexes.keySet()) {
    hex=mHexes.get(hexName);
    hex.finishConfiguration(gameManager);
  }
  int ii, jj;
  for (i=minX; i <= maxX; i++) {
    for (j=minY; j <= maxY; j++) {
      if ((hex=hexes[i][j]) == null)       continue;
      for (k=0; k < 6; k++) {
        ii=getAdjacentX(i,j,k);
        jj=getAdjacentY(i,j,k);
        if (ii >= minX && ii <= maxX && jj >= minY && jj <= maxY && (nb=hexes[ii][jj]) != null) {
          if (hex.isNeighbour(nb,k) && nb.isNeighbour(hex,k + 3)) {
            hex.setNeighbor(k,nb);
            nb.setNeighbor(k + 3,hex);
          }
          if (hex.isImpassable(nb) || nb.isImpassable(hex)) {
            hex.addImpassableSide(k);
          }
        }
      }
    }
  }
  List<MapHex> homeHexes;
  for (  PublicCompany company : gameManager.getCompanyManager().getAllPublicCompanies()) {
    if ((homeHexes=company.getHomeHexes()) != null) {
      for (      MapHex homeHex : homeHexes) {
        homeHex.addHome(company,company.getHomeCityNumber());
      }
    }
    if ((hex=company.getDestinationHex()) != null) {
      hex.addDestination(company);
    }
  }
}",0.9846153846153848
173496,"private void loadMap(){
  try {
    File imageFile=new File(mapManager.getMapImageFilepath());
    setURI(imageFile.toURI().toString());
    log.debug(""String_Node_Str"" + imageFile.getName());
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + mapManager.getMapImageFilepath(),e);
  }
  addGVTTreeRendererListener(new GVTTreeRendererAdapter(){
    public void gvtRenderingCompleted(    GVTTreeRendererEvent e){
      if (!initialized) {
        initialTransform=getRenderingTransform();
        scaleMap();
        initialized=true;
      }
      addGVTTreeRendererListener(null);
    }
  }
);
}","private void loadMap(){
  try {
    setURI(getClass().getResource(mapManager.getMapImageFilepath()).toString());
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + mapManager.getMapImageFilepath(),e);
  }
  addGVTTreeRendererListener(new GVTTreeRendererAdapter(){
    public void gvtRenderingCompleted(    GVTTreeRendererEvent e){
      if (!initialized) {
        initialTransform=getRenderingTransform();
        scaleMap();
        initialized=true;
      }
      addGVTTreeRendererListener(null);
    }
  }
);
}",0.8253968253968254
173497,"/** 
 * Create a list of certificates that a player may sell in a Stock Round, taking all rules taken into account.
 * @return List of sellable certificates.
 */
public void setSellableShares(){
  if (!mayCurrentPlayerSellAnything())   return;
  int price;
  int number;
  int share, maxShareToSell;
  boolean dumpAllowed;
  PortfolioModel playerPortfolio=currentPlayer.getPortfolioModel();
  for (  PublicCompany company : companyManager.getAllPublicCompanies()) {
    if (!mayPlayerSellShareOfCompany(company))     continue;
    share=maxShareToSell=playerPortfolio.getShare(company);
    if (maxShareToSell == 0)     continue;
    maxShareToSell=Math.min(maxShareToSell,getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT) - pool.getShare(company));
    if (maxShareToSell == 0)     continue;
    if (company.getPresident() == currentPlayer) {
      int presidentShare=company.getCertificates().get(0).getShare();
      if (maxShareToSell > share - presidentShare) {
        dumpAllowed=false;
        int playerShare;
        for (        Player player : gameManager.getPlayers()) {
          if (player == currentPlayer)           continue;
          playerShare=player.getPortfolioModel().getShare(company);
          if (playerShare >= presidentShare) {
            dumpAllowed=true;
            break;
          }
        }
        if (!dumpAllowed)         maxShareToSell=share - presidentShare;
      }
    }
    int[] shareCountPerUnit=new int[5];
    for (    PublicCertificate c : playerPortfolio.getCertificates(company)) {
      if (c.isPresidentShare()) {
        shareCountPerUnit[1]+=c.getShares();
      }
 else {
        ++shareCountPerUnit[c.getShares()];
      }
    }
    price=getCurrentSellPrice(company);
    for (int i=1; i <= 4; i++) {
      number=shareCountPerUnit[i];
      if (number == 0)       continue;
      if ((Boolean)gameManager.getGameParameter(GameDef.Parm.NO_SALE_OF_JUST_BOUGHT_CERT) && company.equals(companyBoughtThisTurnWrapper.value())) {
        number--;
      }
      if (number <= 0)       continue;
      number=Math.min(number,maxShareToSell / (i * company.getShareUnit()));
      if (number <= 0)       continue;
    }
  }
}","/** 
 * Create a list of certificates that a player may sell in a Stock Round, taking all rules taken into account.
 * @return List of sellable certificates.
 */
public void setSellableShares(){
  if (!mayCurrentPlayerSellAnything())   return;
  int price;
  int number;
  int share, maxShareToSell;
  boolean dumpAllowed;
  PortfolioModel playerPortfolio=currentPlayer.getPortfolioModel();
  for (  PublicCompany company : companyManager.getAllPublicCompanies()) {
    if (!mayPlayerSellShareOfCompany(company))     continue;
    share=maxShareToSell=playerPortfolio.getShare(company);
    if (maxShareToSell == 0)     continue;
    maxShareToSell=Math.min(maxShareToSell,getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT) - pool.getShare(company));
    if (maxShareToSell == 0)     continue;
    if (company.getPresident() == currentPlayer) {
      int presidentShare=company.getCertificates().get(0).getShare();
      if (maxShareToSell > share - presidentShare) {
        dumpAllowed=false;
        int playerShare;
        for (        Player player : gameManager.getPlayers()) {
          if (player == currentPlayer)           continue;
          playerShare=player.getPortfolioModel().getShare(company);
          if (playerShare >= presidentShare) {
            dumpAllowed=true;
            break;
          }
        }
        if (!dumpAllowed)         maxShareToSell=share - presidentShare;
      }
    }
    int[] shareCountPerUnit=new int[5];
    for (    PublicCertificate c : playerPortfolio.getCertificates(company)) {
      if (c.isPresidentShare()) {
        shareCountPerUnit[1]+=c.getShares();
      }
 else {
        ++shareCountPerUnit[c.getShares()];
      }
    }
    price=getCurrentSellPrice(company);
    for (int i=1; i <= 4; i++) {
      number=shareCountPerUnit[i];
      if (number == 0)       continue;
      if ((Boolean)gameManager.getGameParameter(GameDef.Parm.NO_SALE_OF_JUST_BOUGHT_CERT) && company.equals(companyBoughtThisTurnWrapper.value())) {
        number--;
      }
      if (number <= 0)       continue;
      number=Math.min(number,maxShareToSell / (i * company.getShareUnit()));
      if (number <= 0)       continue;
      possibleActions.add(new SellShares(company.getId(),i,number,price));
    }
  }
}",0.983081434694338
173498,"/** 
 * Final initialisation, after all XML has been processed.
 */
public void finishConfiguration(GameManager gameManager) throws ConfigurationException {
  this.gameManager=gameManager;
  bank=gameManager.getBank();
  stockMarket=gameManager.getStockMarket();
  mapManager=gameManager.getMapManager();
  if (turnsWithExtraTileLaysInit != null) {
    turnsWithExtraTileLays=new HashMap<String,IntegerState>();
    for (    String colour : turnsWithExtraTileLaysInit.keySet()) {
      IntegerState tileLays=IntegerState.create(this,""String_Node_Str"" + colour + ""String_Node_Str"",turnsWithExtraTileLaysInit.get(colour));
      turnsWithExtraTileLays.put(colour,tileLays);
    }
  }
  if (maxNumberOfLoans != 0) {
    currentNumberOfLoans=IntegerState.create(this,""String_Node_Str"");
    currentLoanValue=CountingMoneyModel.create(this,""String_Node_Str"",false);
    currentLoanValue.setSuppressZero(true);
  }
  if (hasStockPrice && Util.hasValue(startSpace)) {
    parPrice.setPrice(stockMarket.getStockSpace(startSpace));
    if (parPrice.getPrice() == null)     throw new ConfigurationException(""String_Node_Str"" + startSpace + ""String_Node_Str""+ getId());
    currentPrice.setPrice(parPrice.getPrice());
  }
  if (shareUnit == null) {
    shareUnit=IntegerState.create(this,""String_Node_Str"",DEFAULT_SHARE_UNIT);
  }
  int certIndex=0;
  if (certificateTags != null) {
    int shareTotal=0;
    boolean gotPresident=false;
    PublicCertificate certificate;
    for (    Tag certificateTag : certificateTags) {
      int shares=certificateTag.getAttributeAsInteger(""String_Node_Str"",1);
      boolean president=""String_Node_Str"".equals(certificateTag.getAttributeAsString(""String_Node_Str"",""String_Node_Str""));
      int number=certificateTag.getAttributeAsInteger(""String_Node_Str"",1);
      boolean certIsInitiallyAvailable=certificateTag.getAttributeAsBoolean(""String_Node_Str"",certsAreInitiallyAvailable);
      float certificateCount=certificateTag.getAttributeAsFloat(""String_Node_Str"",1.0f);
      if (president) {
        if (number > 1 || gotPresident)         throw new ConfigurationException(""String_Node_Str"" + getId() + ""String_Node_Str"");
        gotPresident=true;
      }
      for (int k=0; k < number; k++) {
        certificate=new PublicCertificate(this,""String_Node_Str"" + certIndex,shares,president,certIsInitiallyAvailable,certificateCount,certIndex++);
        certificates.add(certificate);
        shareTotal+=shares * shareUnit.value();
      }
    }
    if (shareTotal != 100)     throw new ConfigurationException(""String_Node_Str"" + getId() + ""String_Node_Str"");
  }
  nameCertificates();
  PublicCertificate cert;
  for (int i=0; i < certificates.size(); i++) {
    cert=certificates.get(i);
    cert.setUniqueId(getId(),i);
    cert.setInitiallyAvailable(cert.isInitiallyAvailable() && this.certsAreInitiallyAvailable);
  }
  Set<BaseToken> newTokens=Sets.newHashSet();
  for (int i=0; i < numberOfBaseTokens; i++) {
    BaseToken token=BaseToken.create(this);
    newTokens.add(token);
  }
  baseTokens.initTokens(newTokens);
  if (homeHexNames != null) {
    homeHexes=new ArrayList<MapHex>(2);
    MapHex homeHex;
    for (    String homeHexName : homeHexNames.split(""String_Node_Str"")) {
      homeHex=mapManager.getHex(homeHexName);
      if (homeHex == null) {
        throw new ConfigurationException(""String_Node_Str"" + homeHexName + ""String_Node_Str""+ getId());
      }
      homeHexes.add(homeHex);
      infoText+=""String_Node_Str"" + homeHex.getInfo();
    }
  }
  if (destinationHexName != null) {
    destinationHex=mapManager.getHex(destinationHexName);
    if (destinationHex == null) {
      throw new ConfigurationException(""String_Node_Str"" + destinationHexName + ""String_Node_Str""+ getId());
    }
    infoText+=""String_Node_Str"" + destinationHex.getInfo();
  }
  if (Util.hasValue(privateToCloseOnFirstTrainName)) {
    privateToCloseOnFirstTrain=gameManager.getCompanyManager().getPrivateCompany(privateToCloseOnFirstTrainName);
  }
  infoText+=parentInfoText;
  parentInfoText=""String_Node_Str"";
  if (portfolio.hasSpecialProperties()) {
    for (    SpecialProperty sp : portfolio.getPersistentSpecialProperties()) {
      if (sp instanceof SpecialRight) {
        gameManager.setGuiParameter(GuiDef.Parm.HAS_ANY_RIGHTS,true);
        if (rights == null) {
          rights=HashMapState.create(this,""String_Node_Str"");
        }
        sp.finishConfiguration(gameManager);
      }
    }
  }
  portfolio.finishConfiguration();
}","/** 
 * Final initialisation, after all XML has been processed.
 */
public void finishConfiguration(GameManager gameManager) throws ConfigurationException {
  this.gameManager=gameManager;
  bank=gameManager.getBank();
  stockMarket=gameManager.getStockMarket();
  mapManager=gameManager.getMapManager();
  if (turnsWithExtraTileLaysInit != null) {
    turnsWithExtraTileLays=new HashMap<String,IntegerState>();
    for (    String colour : turnsWithExtraTileLaysInit.keySet()) {
      IntegerState tileLays=IntegerState.create(this,""String_Node_Str"" + colour + ""String_Node_Str"",turnsWithExtraTileLaysInit.get(colour));
      turnsWithExtraTileLays.put(colour,tileLays);
    }
  }
  if (maxNumberOfLoans != 0) {
    currentNumberOfLoans=IntegerState.create(this,""String_Node_Str"");
    currentLoanValue=CountingMoneyModel.create(this,""String_Node_Str"",false);
    currentLoanValue.setSuppressZero(true);
  }
  if (hasStockPrice && Util.hasValue(startSpace)) {
    parPrice.setPrice(stockMarket.getStockSpace(startSpace));
    if (parPrice.getPrice() == null)     throw new ConfigurationException(""String_Node_Str"" + startSpace + ""String_Node_Str""+ getId());
    currentPrice.setPrice(parPrice.getPrice());
  }
  int certIndex=0;
  if (certificateTags != null) {
    int shareTotal=0;
    boolean gotPresident=false;
    PublicCertificate certificate;
    for (    Tag certificateTag : certificateTags) {
      int shares=certificateTag.getAttributeAsInteger(""String_Node_Str"",1);
      boolean president=""String_Node_Str"".equals(certificateTag.getAttributeAsString(""String_Node_Str"",""String_Node_Str""));
      int number=certificateTag.getAttributeAsInteger(""String_Node_Str"",1);
      boolean certIsInitiallyAvailable=certificateTag.getAttributeAsBoolean(""String_Node_Str"",certsAreInitiallyAvailable);
      float certificateCount=certificateTag.getAttributeAsFloat(""String_Node_Str"",1.0f);
      if (president) {
        if (number > 1 || gotPresident)         throw new ConfigurationException(""String_Node_Str"" + getId() + ""String_Node_Str"");
        gotPresident=true;
      }
      for (int k=0; k < number; k++) {
        certificate=new PublicCertificate(this,""String_Node_Str"" + certIndex,shares,president,certIsInitiallyAvailable,certificateCount,certIndex++);
        certificates.add(certificate);
        shareTotal+=shares * shareUnit.value();
      }
    }
    if (shareTotal != 100)     throw new ConfigurationException(""String_Node_Str"" + getId() + ""String_Node_Str"");
  }
  nameCertificates();
  PublicCertificate cert;
  for (int i=0; i < certificates.size(); i++) {
    cert=certificates.get(i);
    cert.setUniqueId(getId(),i);
    cert.setInitiallyAvailable(cert.isInitiallyAvailable() && this.certsAreInitiallyAvailable);
  }
  Set<BaseToken> newTokens=Sets.newHashSet();
  for (int i=0; i < numberOfBaseTokens; i++) {
    BaseToken token=BaseToken.create(this);
    newTokens.add(token);
  }
  baseTokens.initTokens(newTokens);
  if (homeHexNames != null) {
    homeHexes=new ArrayList<MapHex>(2);
    MapHex homeHex;
    for (    String homeHexName : homeHexNames.split(""String_Node_Str"")) {
      homeHex=mapManager.getHex(homeHexName);
      if (homeHex == null) {
        throw new ConfigurationException(""String_Node_Str"" + homeHexName + ""String_Node_Str""+ getId());
      }
      homeHexes.add(homeHex);
      infoText+=""String_Node_Str"" + homeHex.getInfo();
    }
  }
  if (destinationHexName != null) {
    destinationHex=mapManager.getHex(destinationHexName);
    if (destinationHex == null) {
      throw new ConfigurationException(""String_Node_Str"" + destinationHexName + ""String_Node_Str""+ getId());
    }
    infoText+=""String_Node_Str"" + destinationHex.getInfo();
  }
  if (Util.hasValue(privateToCloseOnFirstTrainName)) {
    privateToCloseOnFirstTrain=gameManager.getCompanyManager().getPrivateCompany(privateToCloseOnFirstTrainName);
  }
  infoText+=parentInfoText;
  parentInfoText=""String_Node_Str"";
  if (portfolio.hasSpecialProperties()) {
    for (    SpecialProperty sp : portfolio.getPersistentSpecialProperties()) {
      if (sp instanceof SpecialRight) {
        gameManager.setGuiParameter(GuiDef.Parm.HAS_ANY_RIGHTS,true);
        if (rights == null) {
          rights=HashMapState.create(this,""String_Node_Str"");
        }
        sp.finishConfiguration(gameManager);
      }
    }
  }
  portfolio.finishConfiguration();
}",0.9876989053154271
173499,"/** 
 * To configure all public companies from the &lt;PublicCompany&gt; XML element
 */
public void configureFromXML(Tag tag) throws ConfigurationException {
  longName=tag.getAttributeAsString(""String_Node_Str"",getId());
  infoText=""String_Node_Str"" + longName;
  alias=tag.getAttributeAsString(""String_Node_Str"",alias);
  fgHexColour=tag.getAttributeAsString(""String_Node_Str"",fgHexColour);
  fgColour=Util.parseColour(fgHexColour);
  bgHexColour=tag.getAttributeAsString(""String_Node_Str"",bgHexColour);
  bgColour=Util.parseColour(bgHexColour);
  floatPerc=tag.getAttributeAsInteger(""String_Node_Str"",floatPerc);
  startSpace=tag.getAttributeAsString(""String_Node_Str"");
  fixedPrice=tag.getAttributeAsInteger(""String_Node_Str"",0);
  numberOfBaseTokens=tag.getAttributeAsInteger(""String_Node_Str"",1);
  certsAreInitiallyAvailable=tag.getAttributeAsBoolean(""String_Node_Str"",certsAreInitiallyAvailable);
  canBeRestarted=tag.getAttributeAsBoolean(""String_Node_Str"",canBeRestarted);
  Tag shareUnitTag=tag.getChild(""String_Node_Str"");
  if (shareUnitTag != null) {
    shareUnit=IntegerState.create(this,""String_Node_Str"",shareUnitTag.getAttributeAsInteger(""String_Node_Str"",DEFAULT_SHARE_UNIT));
    shareUnitsForSharePrice=shareUnitTag.getAttributeAsInteger(""String_Node_Str"",shareUnitsForSharePrice);
  }
  Tag homeBaseTag=tag.getChild(""String_Node_Str"");
  if (homeBaseTag != null) {
    homeHexNames=homeBaseTag.getAttributeAsString(""String_Node_Str"");
    homeCityNumber=homeBaseTag.getAttributeAsInteger(""String_Node_Str"",1);
    homeAllCitiesBlocked=homeBaseTag.getAttributeAsBoolean(""String_Node_Str"",false);
  }
  Tag destinationTag=tag.getChild(""String_Node_Str"");
  if (destinationTag != null) {
    destinationHexName=destinationTag.getAttributeAsString(""String_Node_Str"");
  }
  Tag privateBuyTag=tag.getChild(""String_Node_Str"");
  if (privateBuyTag != null) {
    canBuyPrivates=true;
  }
  Tag canUseSpecTag=tag.getChild(""String_Node_Str"");
  if (canUseSpecTag != null)   canUseSpecialProperties=true;
  Tag infoTag=tag.getChild(""String_Node_Str"");
  if (infoTag != null) {
    String infoKey=infoTag.getAttributeAsString(""String_Node_Str"");
    String[] infoParms=infoTag.getAttributeAsString(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"");
    infoText+=""String_Node_Str"" + LocalText.getText(infoKey,(Object[])infoParms);
  }
  parentInfoText+=SpecialProperty.configure(this,tag);
  poolPaysOut=poolPaysOut || tag.getChild(""String_Node_Str"") != null;
  ipoPaysOut=ipoPaysOut || tag.getChild(""String_Node_Str"") != null;
  Tag floatTag=tag.getChild(""String_Node_Str"");
  if (floatTag != null) {
    floatPerc=floatTag.getAttributeAsInteger(""String_Node_Str"",floatPerc);
    String sharePriceAttr=floatTag.getAttributeAsString(""String_Node_Str"");
    if (Util.hasValue(sharePriceAttr)) {
      sharePriceUpOnFloating=sharePriceAttr.equalsIgnoreCase(""String_Node_Str"");
    }
  }
  Tag priceTag=tag.getChild(""String_Node_Str"");
  if (priceTag != null) {
    hasStockPrice=priceTag.getAttributeAsBoolean(""String_Node_Str"",true);
    hasParPrice=priceTag.getAttributeAsBoolean(""String_Node_Str"",hasStockPrice);
  }
  Tag payoutTag=tag.getChild(""String_Node_Str"");
  if (payoutTag != null) {
    String split=payoutTag.getAttributeAsString(""String_Node_Str"",""String_Node_Str"");
    splitAlways=split.equalsIgnoreCase(""String_Node_Str"");
    splitAllowed=split.equalsIgnoreCase(""String_Node_Str"");
    payoutMustExceedPriceToMove=payoutTag.getAttributeAsBoolean(""String_Node_Str"",false);
  }
  Tag ownSharesTag=tag.getChild(""String_Node_Str"");
  if (ownSharesTag != null) {
    canHoldOwnShares=true;
    treasuryPaysOut=true;
    maxPercOfOwnShares=ownSharesTag.getAttributeAsInteger(""String_Node_Str"",maxPercOfOwnShares);
  }
  Tag trainsTag=tag.getChild(""String_Node_Str"");
  if (trainsTag != null) {
    trainLimit=trainsTag.getAttributeAsIntegerArray(""String_Node_Str"",trainLimit);
    mustOwnATrain=trainsTag.getAttributeAsBoolean(""String_Node_Str"",mustOwnATrain);
  }
  Tag initialTrainTag=tag.getChild(""String_Node_Str"");
  if (initialTrainTag != null) {
    initialTrainType=initialTrainTag.getAttributeAsString(""String_Node_Str"");
    initialTrainCost=initialTrainTag.getAttributeAsInteger(""String_Node_Str"",initialTrainCost);
    initialTrainTradeable=initialTrainTag.getAttributeAsBoolean(""String_Node_Str"",initialTrainTradeable);
  }
  Tag firstTrainTag=tag.getChild(""String_Node_Str"");
  if (firstTrainTag != null) {
    String typeName=firstTrainTag.getAttributeAsString(""String_Node_Str"",""String_Node_Str"");
    if (typeName.equalsIgnoreCase(""String_Node_Str"")) {
      privateToCloseOnFirstTrainName=firstTrainTag.getAttributeAsString(""String_Node_Str"");
    }
 else {
      throw new ConfigurationException(""String_Node_Str"");
    }
  }
  Tag capitalisationTag=tag.getChild(""String_Node_Str"");
  if (capitalisationTag != null) {
    String capType=capitalisationTag.getAttributeAsString(""String_Node_Str"",""String_Node_Str"");
    if (capType.equalsIgnoreCase(""String_Node_Str"")) {
      setCapitalisation(CAPITALISE_FULL);
    }
 else     if (capType.equalsIgnoreCase(""String_Node_Str"")) {
      setCapitalisation(CAPITALISE_INCREMENTAL);
    }
 else     if (capType.equalsIgnoreCase(""String_Node_Str"")) {
      setCapitalisation(CAPITALISE_WHEN_BOUGHT);
    }
 else {
      throw new ConfigurationException(""String_Node_Str"" + capType);
    }
  }
  Tag tileLaysTag=tag.getChild(""String_Node_Str"");
  if (tileLaysTag != null) {
    for (    Tag numberTag : tileLaysTag.getChildren(""String_Node_Str"")) {
      String colourString=numberTag.getAttributeAsString(""String_Node_Str"");
      if (colourString == null)       throw new ConfigurationException(""String_Node_Str"");
      String phaseString=numberTag.getAttributeAsString(""String_Node_Str"");
      if (phaseString == null)       throw new ConfigurationException(""String_Node_Str"");
      int number=numberTag.getAttributeAsInteger(""String_Node_Str"");
      Integer lays=new Integer(number);
      int validForTurns=numberTag.getAttributeAsInteger(""String_Node_Str"",0);
      String[] colours=colourString.split(""String_Node_Str"");
      HashMap<String,Integer> phaseMap;
      String[] phases=phaseString.split(""String_Node_Str"");
      for (int i=0; i < colours.length; i++) {
        if (extraTileLays == null)         extraTileLays=new HashMap<String,HashMap<String,Integer>>();
        extraTileLays.put(colours[i],(phaseMap=new HashMap<String,Integer>()));
        for (int k=0; k < phases.length; k++) {
          phaseMap.put(phases[k],lays);
        }
        if (validForTurns > 0) {
          if (turnsWithExtraTileLaysInit == null) {
            turnsWithExtraTileLaysInit=new HashMap<String,Integer>();
          }
          turnsWithExtraTileLaysInit.put(colours[i],validForTurns);
        }
      }
    }
  }
  List<Tag> certTags=tag.getChildren(""String_Node_Str"");
  if (certTags != null)   certificateTags=certTags;
  Tag baseTokenTag=tag.getChild(""String_Node_Str"");
  if (baseTokenTag != null) {
    Tag layCostTag=baseTokenTag.getChild(""String_Node_Str"");
    if (layCostTag != null) {
      baseTokenLayCostMethod=layCostTag.getAttributeAsString(""String_Node_Str"",baseTokenLayCostMethod);
      if (baseTokenLayCostMethod.equalsIgnoreCase(BASE_COST_SEQUENCE)) {
        baseTokenLayCostMethod=BASE_COST_SEQUENCE;
      }
 else       if (baseTokenLayCostMethod.equalsIgnoreCase(BASE_COST_DISTANCE)) {
        baseTokenLayCostMethod=BASE_COST_DISTANCE;
      }
 else {
        throw new ConfigurationException(""String_Node_Str"" + baseTokenLayCostMethod);
      }
      baseTokenLayCost=layCostTag.getAttributeAsIntegerArray(""String_Node_Str"");
    }
    Tag buyCostTag=baseTokenTag.getChild(""String_Node_Str"");
    if (buyCostTag != null) {
      baseTokensBuyCost=buyCostTag.getAttributeAsInteger(""String_Node_Str"",0);
    }
    Tag tokenLayTimeTag=baseTokenTag.getChild(""String_Node_Str"");
    if (tokenLayTimeTag != null) {
      String layTimeString=tokenLayTimeTag.getAttributeAsString(""String_Node_Str"");
      if (Util.hasValue(layTimeString)) {
        for (int i=0; i < tokenLayTimeNames.length; i++) {
          if (tokenLayTimeNames[i].equalsIgnoreCase(layTimeString)) {
            homeBaseTokensLayTime=i;
            break;
          }
        }
      }
    }
  }
  Tag sellSharesTag=tag.getChild(""String_Node_Str"");
  if (sellSharesTag != null) {
    mayTradeShares=true;
    mustHaveOperatedToTradeShares=sellSharesTag.getAttributeAsBoolean(""String_Node_Str"",mustHaveOperatedToTradeShares);
  }
  Tag loansTag=tag.getChild(""String_Node_Str"");
  if (loansTag != null) {
    maxNumberOfLoans=loansTag.getAttributeAsInteger(""String_Node_Str"",-1);
    valuePerLoan=loansTag.getAttributeAsInteger(""String_Node_Str"",0);
    loanInterestPct=loansTag.getAttributeAsInteger(""String_Node_Str"",0);
    maxLoansPerRound=loansTag.getAttributeAsInteger(""String_Node_Str"",-1);
  }
  Tag optionsTag=tag.getChild(""String_Node_Str"");
  if (optionsTag != null) {
    mustTradeTrainsAtFixedPrice=optionsTag.getAttributeAsBoolean(""String_Node_Str"",mustTradeTrainsAtFixedPrice);
    canClose=optionsTag.getAttributeAsBoolean(""String_Node_Str"",canClose);
  }
}","/** 
 * To configure all public companies from the &lt;PublicCompany&gt; XML element
 */
public void configureFromXML(Tag tag) throws ConfigurationException {
  longName=tag.getAttributeAsString(""String_Node_Str"",getId());
  infoText=""String_Node_Str"" + longName;
  alias=tag.getAttributeAsString(""String_Node_Str"",alias);
  fgHexColour=tag.getAttributeAsString(""String_Node_Str"",fgHexColour);
  fgColour=Util.parseColour(fgHexColour);
  bgHexColour=tag.getAttributeAsString(""String_Node_Str"",bgHexColour);
  bgColour=Util.parseColour(bgHexColour);
  floatPerc=tag.getAttributeAsInteger(""String_Node_Str"",floatPerc);
  startSpace=tag.getAttributeAsString(""String_Node_Str"");
  fixedPrice=tag.getAttributeAsInteger(""String_Node_Str"",0);
  numberOfBaseTokens=tag.getAttributeAsInteger(""String_Node_Str"",1);
  certsAreInitiallyAvailable=tag.getAttributeAsBoolean(""String_Node_Str"",certsAreInitiallyAvailable);
  canBeRestarted=tag.getAttributeAsBoolean(""String_Node_Str"",canBeRestarted);
  Tag shareUnitTag=tag.getChild(""String_Node_Str"");
  if (shareUnitTag != null) {
    shareUnit.set(shareUnitTag.getAttributeAsInteger(""String_Node_Str"",DEFAULT_SHARE_UNIT));
    shareUnitsForSharePrice=shareUnitTag.getAttributeAsInteger(""String_Node_Str"",shareUnitsForSharePrice);
  }
  Tag homeBaseTag=tag.getChild(""String_Node_Str"");
  if (homeBaseTag != null) {
    homeHexNames=homeBaseTag.getAttributeAsString(""String_Node_Str"");
    homeCityNumber=homeBaseTag.getAttributeAsInteger(""String_Node_Str"",1);
    homeAllCitiesBlocked=homeBaseTag.getAttributeAsBoolean(""String_Node_Str"",false);
  }
  Tag destinationTag=tag.getChild(""String_Node_Str"");
  if (destinationTag != null) {
    destinationHexName=destinationTag.getAttributeAsString(""String_Node_Str"");
  }
  Tag privateBuyTag=tag.getChild(""String_Node_Str"");
  if (privateBuyTag != null) {
    canBuyPrivates=true;
  }
  Tag canUseSpecTag=tag.getChild(""String_Node_Str"");
  if (canUseSpecTag != null)   canUseSpecialProperties=true;
  Tag infoTag=tag.getChild(""String_Node_Str"");
  if (infoTag != null) {
    String infoKey=infoTag.getAttributeAsString(""String_Node_Str"");
    String[] infoParms=infoTag.getAttributeAsString(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"");
    infoText+=""String_Node_Str"" + LocalText.getText(infoKey,(Object[])infoParms);
  }
  parentInfoText+=SpecialProperty.configure(this,tag);
  poolPaysOut=poolPaysOut || tag.getChild(""String_Node_Str"") != null;
  ipoPaysOut=ipoPaysOut || tag.getChild(""String_Node_Str"") != null;
  Tag floatTag=tag.getChild(""String_Node_Str"");
  if (floatTag != null) {
    floatPerc=floatTag.getAttributeAsInteger(""String_Node_Str"",floatPerc);
    String sharePriceAttr=floatTag.getAttributeAsString(""String_Node_Str"");
    if (Util.hasValue(sharePriceAttr)) {
      sharePriceUpOnFloating=sharePriceAttr.equalsIgnoreCase(""String_Node_Str"");
    }
  }
  Tag priceTag=tag.getChild(""String_Node_Str"");
  if (priceTag != null) {
    hasStockPrice=priceTag.getAttributeAsBoolean(""String_Node_Str"",true);
    hasParPrice=priceTag.getAttributeAsBoolean(""String_Node_Str"",hasStockPrice);
  }
  Tag payoutTag=tag.getChild(""String_Node_Str"");
  if (payoutTag != null) {
    String split=payoutTag.getAttributeAsString(""String_Node_Str"",""String_Node_Str"");
    splitAlways=split.equalsIgnoreCase(""String_Node_Str"");
    splitAllowed=split.equalsIgnoreCase(""String_Node_Str"");
    payoutMustExceedPriceToMove=payoutTag.getAttributeAsBoolean(""String_Node_Str"",false);
  }
  Tag ownSharesTag=tag.getChild(""String_Node_Str"");
  if (ownSharesTag != null) {
    canHoldOwnShares=true;
    treasuryPaysOut=true;
    maxPercOfOwnShares=ownSharesTag.getAttributeAsInteger(""String_Node_Str"",maxPercOfOwnShares);
  }
  Tag trainsTag=tag.getChild(""String_Node_Str"");
  if (trainsTag != null) {
    trainLimit=trainsTag.getAttributeAsIntegerArray(""String_Node_Str"",trainLimit);
    mustOwnATrain=trainsTag.getAttributeAsBoolean(""String_Node_Str"",mustOwnATrain);
  }
  Tag initialTrainTag=tag.getChild(""String_Node_Str"");
  if (initialTrainTag != null) {
    initialTrainType=initialTrainTag.getAttributeAsString(""String_Node_Str"");
    initialTrainCost=initialTrainTag.getAttributeAsInteger(""String_Node_Str"",initialTrainCost);
    initialTrainTradeable=initialTrainTag.getAttributeAsBoolean(""String_Node_Str"",initialTrainTradeable);
  }
  Tag firstTrainTag=tag.getChild(""String_Node_Str"");
  if (firstTrainTag != null) {
    String typeName=firstTrainTag.getAttributeAsString(""String_Node_Str"",""String_Node_Str"");
    if (typeName.equalsIgnoreCase(""String_Node_Str"")) {
      privateToCloseOnFirstTrainName=firstTrainTag.getAttributeAsString(""String_Node_Str"");
    }
 else {
      throw new ConfigurationException(""String_Node_Str"");
    }
  }
  Tag capitalisationTag=tag.getChild(""String_Node_Str"");
  if (capitalisationTag != null) {
    String capType=capitalisationTag.getAttributeAsString(""String_Node_Str"",""String_Node_Str"");
    if (capType.equalsIgnoreCase(""String_Node_Str"")) {
      setCapitalisation(CAPITALISE_FULL);
    }
 else     if (capType.equalsIgnoreCase(""String_Node_Str"")) {
      setCapitalisation(CAPITALISE_INCREMENTAL);
    }
 else     if (capType.equalsIgnoreCase(""String_Node_Str"")) {
      setCapitalisation(CAPITALISE_WHEN_BOUGHT);
    }
 else {
      throw new ConfigurationException(""String_Node_Str"" + capType);
    }
  }
  Tag tileLaysTag=tag.getChild(""String_Node_Str"");
  if (tileLaysTag != null) {
    for (    Tag numberTag : tileLaysTag.getChildren(""String_Node_Str"")) {
      String colourString=numberTag.getAttributeAsString(""String_Node_Str"");
      if (colourString == null)       throw new ConfigurationException(""String_Node_Str"");
      String phaseString=numberTag.getAttributeAsString(""String_Node_Str"");
      if (phaseString == null)       throw new ConfigurationException(""String_Node_Str"");
      int number=numberTag.getAttributeAsInteger(""String_Node_Str"");
      Integer lays=new Integer(number);
      int validForTurns=numberTag.getAttributeAsInteger(""String_Node_Str"",0);
      String[] colours=colourString.split(""String_Node_Str"");
      HashMap<String,Integer> phaseMap;
      String[] phases=phaseString.split(""String_Node_Str"");
      for (int i=0; i < colours.length; i++) {
        if (extraTileLays == null)         extraTileLays=new HashMap<String,HashMap<String,Integer>>();
        extraTileLays.put(colours[i],(phaseMap=new HashMap<String,Integer>()));
        for (int k=0; k < phases.length; k++) {
          phaseMap.put(phases[k],lays);
        }
        if (validForTurns > 0) {
          if (turnsWithExtraTileLaysInit == null) {
            turnsWithExtraTileLaysInit=new HashMap<String,Integer>();
          }
          turnsWithExtraTileLaysInit.put(colours[i],validForTurns);
        }
      }
    }
  }
  List<Tag> certTags=tag.getChildren(""String_Node_Str"");
  if (certTags != null)   certificateTags=certTags;
  Tag baseTokenTag=tag.getChild(""String_Node_Str"");
  if (baseTokenTag != null) {
    Tag layCostTag=baseTokenTag.getChild(""String_Node_Str"");
    if (layCostTag != null) {
      baseTokenLayCostMethod=layCostTag.getAttributeAsString(""String_Node_Str"",baseTokenLayCostMethod);
      if (baseTokenLayCostMethod.equalsIgnoreCase(BASE_COST_SEQUENCE)) {
        baseTokenLayCostMethod=BASE_COST_SEQUENCE;
      }
 else       if (baseTokenLayCostMethod.equalsIgnoreCase(BASE_COST_DISTANCE)) {
        baseTokenLayCostMethod=BASE_COST_DISTANCE;
      }
 else {
        throw new ConfigurationException(""String_Node_Str"" + baseTokenLayCostMethod);
      }
      baseTokenLayCost=layCostTag.getAttributeAsIntegerArray(""String_Node_Str"");
    }
    Tag buyCostTag=baseTokenTag.getChild(""String_Node_Str"");
    if (buyCostTag != null) {
      baseTokensBuyCost=buyCostTag.getAttributeAsInteger(""String_Node_Str"",0);
    }
    Tag tokenLayTimeTag=baseTokenTag.getChild(""String_Node_Str"");
    if (tokenLayTimeTag != null) {
      String layTimeString=tokenLayTimeTag.getAttributeAsString(""String_Node_Str"");
      if (Util.hasValue(layTimeString)) {
        for (int i=0; i < tokenLayTimeNames.length; i++) {
          if (tokenLayTimeNames[i].equalsIgnoreCase(layTimeString)) {
            homeBaseTokensLayTime=i;
            break;
          }
        }
      }
    }
  }
  Tag sellSharesTag=tag.getChild(""String_Node_Str"");
  if (sellSharesTag != null) {
    mayTradeShares=true;
    mustHaveOperatedToTradeShares=sellSharesTag.getAttributeAsBoolean(""String_Node_Str"",mustHaveOperatedToTradeShares);
  }
  Tag loansTag=tag.getChild(""String_Node_Str"");
  if (loansTag != null) {
    maxNumberOfLoans=loansTag.getAttributeAsInteger(""String_Node_Str"",-1);
    valuePerLoan=loansTag.getAttributeAsInteger(""String_Node_Str"",0);
    loanInterestPct=loansTag.getAttributeAsInteger(""String_Node_Str"",0);
    maxLoansPerRound=loansTag.getAttributeAsInteger(""String_Node_Str"",-1);
  }
  Tag optionsTag=tag.getChild(""String_Node_Str"");
  if (optionsTag != null) {
    mustTradeTrainsAtFixedPrice=optionsTag.getAttributeAsBoolean(""String_Node_Str"",mustTradeTrainsAtFixedPrice);
    canClose=optionsTag.getAttributeAsBoolean(""String_Node_Str"",canClose);
  }
}",0.9973225506802909
173500,"@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action.getClass() == StartCompany.class))   return false;
  StartCompany a=(StartCompany)action;
  return a.company == company && a.from == from && Ints.asList(startPrices).contains(a.price);
}","@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action.getClass() == StartCompany.class))   return false;
  StartCompany a=(StartCompany)action;
  return a.company == company && a.from == from && (startPrices == null && a.startPrices == null || Ints.asList(startPrices).contains(a.price));
}",0.913793103448276
173501,"@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action instanceof FoldIntoPrussian))   return false;
  FoldIntoPrussian a=(FoldIntoPrussian)action;
  return a.foldableCompanyNames.equals(foldableCompanyNames);
}","@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action instanceof FoldIntoPrussian))   return false;
  FoldIntoPrussian a=(FoldIntoPrussian)action;
  return ImmutableSet.copyOf(a.foldableCompanies).equals(ImmutableSet.copyOf(foldableCompanies));
}",0.857707509881423
173502,"/** 
 * Deserialize 
 */
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  Company company;
  in.defaultReadObject();
  CompanyManager cmgr=getCompanyManager();
  if (foldableCompanyNames != null) {
    foldableCompanies=new ArrayList<Company>();
    for (    String name : foldableCompanyNames.split(""String_Node_Str"")) {
      foldableCompanies.add(cmgr.getPublicCompany(name));
    }
  }
  if (Util.hasValue(foldedCompanyNames)) {
    foldedCompanies=new ArrayList<Company>();
    for (    String name : foldedCompanyNames.split(""String_Node_Str"")) {
      company=cmgr.getPublicCompany(name);
      if (company == null)       company=cmgr.getPrivateCompany(name);
      if (company != null)       foldedCompanies.add(company);
    }
  }
}","/** 
 * Deserialize 
 */
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  Company company;
  in.defaultReadObject();
  CompanyManager cmgr=getCompanyManager();
  if (foldableCompanyNames != null) {
    foldableCompanies=new ArrayList<Company>();
    for (    String name : foldableCompanyNames.split(""String_Node_Str"")) {
      company=cmgr.getPublicCompany(name);
      if (company == null)       company=cmgr.getPrivateCompany(name);
      if (company != null)       foldableCompanies.add(company);
    }
  }
  if (Util.hasValue(foldedCompanyNames)) {
    foldedCompanies=new ArrayList<Company>();
    for (    String name : foldedCompanyNames.split(""String_Node_Str"")) {
      company=cmgr.getPublicCompany(name);
      if (company == null)       company=cmgr.getPrivateCompany(name);
      if (company != null)       foldedCompanies.add(company);
    }
  }
}",0.8752217622708457
173503,"public void startPrussianFormationRound(OperatingRound_1835 or){
  interruptedRound=or;
  createRound(PrussianFormationRound.class,""String_Node_Str"").start();
}","public void startPrussianFormationRound(OperatingRound_1835 or){
  interruptedRound=or;
  String roundName;
  if (interruptedRound == null) {
    roundName=""String_Node_Str"" + previousRound.getId();
  }
 else {
    roundName=""String_Node_Str"" + or.getId();
  }
  createRound(PrussianFormationRound.class,roundName).start();
}",0.5896907216494846
173504,"private void executeStartPrussian(boolean display){
  prussian.start();
  String message=LocalText.getText(""String_Node_Str"",PR_ID,Currency.format(this,prussian.getIPOPrice()),prussian.getStartSpace());
  ReportBuffer.add(message);
  if (display)   DisplayBuffer.add(message);
  int capFactor=getSoldPercentage(prussian) / (prussian.getShareUnit() * prussian.getShareUnitsForSharePrice());
  int cash=capFactor * prussian.getIPOPrice();
  if (cash > 0) {
    String cashText=Currency.fromBank(cash,prussian);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",prussian.getId(),cashText));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",prussian.getId()));
  }
  executeExchange(Arrays.asList(new Company[]{m2}),true,false);
  prussian.setFloated();
}","private void executeStartPrussian(boolean display){
  prussian.start();
  String message=LocalText.getText(""String_Node_Str"",PR_ID,Currency.format(this,prussian.getIPOPrice()),prussian.getStartSpace().toText());
  ReportBuffer.add(message);
  if (display)   DisplayBuffer.add(message);
  int capFactor=getSoldPercentage(prussian) / (prussian.getShareUnit() * prussian.getShareUnitsForSharePrice());
  int cash=capFactor * prussian.getIPOPrice();
  if (cash > 0) {
    String cashText=Currency.fromBank(cash,prussian);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",prussian.getId(),cashText));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",prussian.getId()));
  }
  executeExchange(Arrays.asList(new Company[]{m2}),true,false);
  prussian.setFloated();
}",0.9942492012779552
173505,"private void executeExchange(List<Company> companies,boolean president,boolean display){
  ExchangeForShare efs;
  PublicCertificate cert;
  Player player;
  for (  Company company : companies) {
    log.debug(""String_Node_Str"" + company.getId());
    if (company instanceof PrivateCompany) {
      player=(Player)((PrivateCompany)company).getOwner();
    }
 else {
      player=((PublicCompany)company).getPresident();
    }
    efs=(ExchangeForShare)Iterables.get(company.getSpecialProperties(),0);
    cert=unavailable.findCertificate(prussian,efs.getShare() / prussian.getShareUnit(),president);
    cert.moveTo(player);
    String message=LocalText.getText(""String_Node_Str"",player.getId(),company.getId(),PR_ID,company instanceof PrivateCompany ? ""String_Node_Str"" : Currency.format(this,((PublicCompany)company).getCash()),company instanceof PrivateCompany ? ""String_Node_Str"" : ((PublicCompany)company).getPortfolioModel().getTrainList().size());
    ReportBuffer.add(message);
    if (display)     DisplayBuffer.add(message);
    message=LocalText.getText(""String_Node_Str"",player.getId(),cert.getShare(),PR_ID,ipo.getId(),company.getId());
    ReportBuffer.add(message);
    if (display)     DisplayBuffer.add(message);
    if (company instanceof PublicCompany) {
      PublicCompany minor=(PublicCompany)company;
      BaseToken token=Iterables.get(minor.getAllBaseTokens(),0);
      Stop city=(Stop)token.getOwner();
      MapHex hex=city.getParent();
      token.moveTo(minor);
      if (!hex.hasTokenOfCompany(prussian) && hex.layBaseToken(prussian,city.getNumber())) {
        message=LocalText.getText(""String_Node_Str"",PR_ID,minor.getId(),city.getSpecificId());
        ReportBuffer.add(message);
        if (display)         DisplayBuffer.add(message);
        prussian.layBaseToken(hex,0);
      }
      if (minor.getCash() > 0) {
        Currency.wireAll(minor,prussian);
      }
      List<Train> trains=new ArrayList<Train>(minor.getPortfolioModel().getTrainList());
      for (      Train train : trains) {
        prussian.getPortfolioModel().addTrain(train);
      }
    }
    company.setClosed();
  }
}","private void executeExchange(List<Company> companies,boolean president,boolean display){
  ExchangeForShare efs;
  PublicCertificate cert;
  Player player;
  for (  Company company : companies) {
    log.debug(""String_Node_Str"" + company.getId());
    if (company instanceof PrivateCompany) {
      player=(Player)((PrivateCompany)company).getOwner();
    }
 else {
      player=((PublicCompany)company).getPresident();
    }
    efs=(ExchangeForShare)Iterables.get(company.getSpecialProperties(),0);
    cert=unavailable.findCertificate(prussian,efs.getShare() / prussian.getShareUnit(),president);
    cert.moveTo(player);
    String message=LocalText.getText(""String_Node_Str"",player.getId(),company.getId(),PR_ID,company instanceof PrivateCompany ? ""String_Node_Str"" : Currency.format(this,((PublicCompany)company).getCash()),company instanceof PrivateCompany ? ""String_Node_Str"" : ((PublicCompany)company).getPortfolioModel().getTrainList().size());
    ReportBuffer.add(message);
    if (display)     DisplayBuffer.add(message);
    message=LocalText.getText(""String_Node_Str"",player.getId(),cert.getShare(),PR_ID,ipo.getParent().getId(),company.getId());
    ReportBuffer.add(message);
    if (display)     DisplayBuffer.add(message);
    if (company instanceof PublicCompany) {
      PublicCompany minor=(PublicCompany)company;
      BaseToken token=Iterables.get(minor.getAllBaseTokens(),0);
      Stop city=(Stop)token.getOwner();
      MapHex hex=city.getParent();
      token.moveTo(minor);
      if (!hex.hasTokenOfCompany(prussian) && hex.layBaseToken(prussian,city.getNumber())) {
        message=LocalText.getText(""String_Node_Str"",PR_ID,minor.getId(),city.getSpecificId());
        ReportBuffer.add(message);
        if (display)         DisplayBuffer.add(message);
        prussian.layBaseToken(hex,0);
      }
      if (minor.getCash() > 0) {
        Currency.wireAll(minor,prussian);
      }
      List<Train> trains=new ArrayList<Train>(minor.getPortfolioModel().getTrainList());
      for (      Train train : trains) {
        prussian.getPortfolioModel().addTrain(train);
      }
    }
    company.setClosed();
  }
}",0.9971883786316776
173506,"public void configureFromXML(Tag tag) throws ConfigurationException {
  String trainClassName=tag.getAttributeAsString(""String_Node_Str"",DEFAULT_TRAIN_CLASS);
  trainClass=Configure.getClassForName(Train.class,trainClassName);
  quantity=tag.getAttributeAsInteger(""String_Node_Str"",quantity);
  quantity+=tag.getAttributeAsInteger(""String_Node_Str"",0);
  initialPortfolio=tag.getAttributeAsString(""String_Node_Str"",initialPortfolio);
  List<Tag> newPhaseTags=tag.getChildren(""String_Node_Str"");
  if (newPhaseTags != null) {
    int index;
    String phaseName;
    newPhaseNames=new HashMap<Integer,String>();
    for (    Tag newPhaseTag : newPhaseTags) {
      phaseName=newPhaseTag.getAttributeAsString(""String_Node_Str"");
      if (!Util.hasValue(phaseName)) {
        throw new ConfigurationException(""String_Node_Str"" + getId() + ""String_Node_Str"");
      }
      index=newPhaseTag.getAttributeAsInteger(""String_Node_Str"",1);
      newPhaseNames.put(index,phaseName);
    }
  }
  Tag swapTag=tag.getChild(""String_Node_Str"");
  if (swapTag != null) {
    exchangeCost=swapTag.getAttributeAsInteger(""String_Node_Str"",0);
    canBeExchanged=(exchangeCost > 0);
  }
  obsoleting=tag.getAttributeAsBoolean(""String_Node_Str"");
}","public void configureFromXML(Tag tag) throws ConfigurationException {
  trainClassName=tag.getAttributeAsString(""String_Node_Str"",trainClassName);
  trainClass=Configure.getClassForName(Train.class,trainClassName);
  quantity=tag.getAttributeAsInteger(""String_Node_Str"",quantity);
  quantity+=tag.getAttributeAsInteger(""String_Node_Str"",0);
  initialPortfolio=tag.getAttributeAsString(""String_Node_Str"",initialPortfolio);
  List<Tag> newPhaseTags=tag.getChildren(""String_Node_Str"");
  if (newPhaseTags != null) {
    int index;
    String phaseName;
    newPhaseNames=new HashMap<Integer,String>();
    for (    Tag newPhaseTag : newPhaseTags) {
      phaseName=newPhaseTag.getAttributeAsString(""String_Node_Str"");
      if (!Util.hasValue(phaseName)) {
        throw new ConfigurationException(""String_Node_Str"" + getId() + ""String_Node_Str"");
      }
      index=newPhaseTag.getAttributeAsInteger(""String_Node_Str"",1);
      newPhaseNames.put(index,phaseName);
    }
  }
  Tag swapTag=tag.getChild(""String_Node_Str"");
  if (swapTag != null) {
    exchangeCost=swapTag.getAttributeAsInteger(""String_Node_Str"",0);
    canBeExchanged=(exchangeCost > 0);
  }
  obsoleting=tag.getAttributeAsBoolean(""String_Node_Str"");
}",0.9844644317252658
173507,"@Override public void configureFromXML(Tag tag) throws ConfigurationException {
  super.configureFromXML(tag);
  Tag assignTag=tag.getChild(""String_Node_Str"");
  if (assignTag == null) {
    throw new ConfigurationException(""String_Node_Str"");
  }
  tokenClassName=assignTag.getAttributeAsString(""String_Node_Str"");
  if (tokenClassName == null) {
    throw new ConfigurationException(""String_Node_Str"");
  }
  try {
    tokenClass=Class.forName(tokenClassName);
  }
 catch (  ClassNotFoundException e) {
    throw new ConfigurationException(""String_Node_Str"" + tokenClassName,e);
  }
  String tokenTagName=tokenClassName.replaceAll(""String_Node_Str"",""String_Node_Str"");
  List<Tag> tokenTags=assignTag.getChildren(tokenTagName);
  if (tokenTags == null || tokenTags.isEmpty()) {
    throw new ConfigurationException(""String_Node_Str"" + tokenTagName + ""String_Node_Str"");
  }
  description=name + ""String_Node_Str"";
  for (  Tag tokenTag : tokenTags) {
    try {
      NamedTrainToken token=(NamedTrainToken)tokenClass.newInstance();
      tokens.add(token);
      token.configureFromXML(tokenTag);
      description+=token.getLongName() + ""String_Node_Str"" + Currency.format(this,token.getValue())+ ""String_Node_Str"";
    }
 catch (    Exception e) {
      throw new ConfigurationException(""String_Node_Str"" + tokenClassName,e);
    }
  }
  description=description.replaceFirst(""String_Node_Str"",""String_Node_Str"");
}","@Override public void configureFromXML(Tag tag) throws ConfigurationException {
  super.configureFromXML(tag);
  Tag assignTag=tag.getChild(""String_Node_Str"");
  if (assignTag == null) {
    throw new ConfigurationException(""String_Node_Str"");
  }
  tokenClassName=assignTag.getAttributeAsString(""String_Node_Str"");
  if (tokenClassName == null) {
    throw new ConfigurationException(""String_Node_Str"");
  }
  tokenClass=Configure.getClassForName(NamedTrainToken.class,tokenClassName);
  String tokenTagName=tokenClassName.replaceAll(""String_Node_Str"",""String_Node_Str"");
  List<Tag> tokenTags=assignTag.getChildren(tokenTagName);
  if (tokenTags == null || tokenTags.isEmpty()) {
    throw new ConfigurationException(""String_Node_Str"" + tokenTagName + ""String_Node_Str"");
  }
  description=name + ""String_Node_Str"";
  for (  Tag tokenTag : tokenTags) {
    String tokenName=tokenTag.getAttributeAsString(""String_Node_Str"");
    if (!Util.hasValue(tokenName)) {
      throw new ConfigurationException(""String_Node_Str"");
    }
    NamedTrainToken token=Configure.create(tokenClass,this,tokenName);
    tokens.add(token);
    token.configureFromXML(tokenTag);
    description+=token.getLongName() + ""String_Node_Str"" + Currency.format(this,token.getValue())+ ""String_Node_Str"";
  }
  description=description.replaceFirst(""String_Node_Str"",""String_Node_Str"");
}",0.4780417566594672
173508,"private NameableTrain(RailsItem parent,String id){
  super(parent,id);
}","/** 
 * Created via Configure
 */
public NameableTrain(RailsItem parent,String id){
  super(parent,id);
}",0.7796610169491526
173509,"@Override public String toText(){
  NamedTrainToken token=getNameToken();
  if (token == null) {
    return getId();
  }
 else {
    return getId() + ""String_Node_Str"" + token.getId()+ ""String_Node_Str"";
  }
}","@Override public String toText(){
  NamedTrainToken token=getNameToken();
  if (token == null) {
    return super.toText();
  }
 else {
    return super.toText() + ""String_Node_Str"" + token.getId()+ ""String_Node_Str"";
  }
}",0.5648148148148148
173510,"private NamedTrainToken(RailsItem parent,String id){
  super(parent,id,NamedTrainToken.class);
}","/** 
 * Used via Configure (reflection)
 */
public NamedTrainToken(RailsItem parent,String id){
  super(parent,id,NamedTrainToken.class);
}",0.774468085106383
173511,"/** 
 * Create a list of certificates that a player may sell in a Stock Round, taking all rules taken into account.
 * @return List of sellable certificates.
 */
public void setSellableShares(){
  if (!mayCurrentPlayerSellAnything())   return;
  int price;
  int number;
  int share, maxShareToSell;
  boolean dumpAllowed;
  PortfolioModel playerPortfolio=currentPlayer.getPortfolioModel();
  for (  PublicCompany company : companyManager.getAllPublicCompanies()) {
    if (!mayPlayerSellShareOfCompany(company))     continue;
    share=maxShareToSell=playerPortfolio.getShare(company);
    if (maxShareToSell == 0)     continue;
    maxShareToSell=Math.min(maxShareToSell,getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT) - pool.getShare(company));
    if (maxShareToSell == 0)     continue;
    if (company.getPresident() == currentPlayer) {
      int presidentShare=company.getCertificates().get(0).getShare();
      if (maxShareToSell > share - presidentShare) {
        dumpAllowed=false;
        int playerShare;
        for (        Player player : gameManager.getPlayers()) {
          if (player == currentPlayer)           continue;
          playerShare=player.getPortfolioModel().getShare(company);
          if (playerShare >= presidentShare) {
            dumpAllowed=true;
            break;
          }
        }
        if (!dumpAllowed)         maxShareToSell=share - presidentShare;
      }
    }
    int[] shareCountPerUnit=new int[5];
    for (    PublicCertificate c : playerPortfolio.getCertificates(company)) {
      if (c.isPresidentShare()) {
        shareCountPerUnit[1]+=c.getShares();
      }
 else {
        ++shareCountPerUnit[c.getShares()];
      }
    }
    price=getCurrentSellPrice(company);
    for (int i=1; i <= 4; i++) {
      number=shareCountPerUnit[i];
      if (number == 0)       continue;
      number=Math.min(number,maxShareToSell / (i * company.getShareUnit()));
      if ((Boolean)gameManager.getGameParameter(GameDef.Parm.NO_SALE_OF_JUST_BOUGHT_CERT) && company.equals(companyBoughtThisTurnWrapper.value())) {
        number--;
      }
      if (number <= 0)       continue;
      possibleActions.add(new SellShares(company.getId(),i,number,price));
    }
  }
}","/** 
 * Create a list of certificates that a player may sell in a Stock Round, taking all rules taken into account.
 * @return List of sellable certificates.
 */
public void setSellableShares(){
  if (!mayCurrentPlayerSellAnything())   return;
  int price;
  int number;
  int share, maxShareToSell;
  boolean dumpAllowed;
  PortfolioModel playerPortfolio=currentPlayer.getPortfolioModel();
  for (  PublicCompany company : companyManager.getAllPublicCompanies()) {
    if (!mayPlayerSellShareOfCompany(company))     continue;
    share=maxShareToSell=playerPortfolio.getShare(company);
    if (maxShareToSell == 0)     continue;
    maxShareToSell=Math.min(maxShareToSell,getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT) - pool.getShare(company));
    if (maxShareToSell == 0)     continue;
    if (company.getPresident() == currentPlayer) {
      int presidentShare=company.getCertificates().get(0).getShare();
      if (maxShareToSell > share - presidentShare) {
        dumpAllowed=false;
        int playerShare;
        for (        Player player : gameManager.getPlayers()) {
          if (player == currentPlayer)           continue;
          playerShare=player.getPortfolioModel().getShare(company);
          if (playerShare >= presidentShare) {
            dumpAllowed=true;
            break;
          }
        }
        if (!dumpAllowed)         maxShareToSell=share - presidentShare;
      }
    }
    int[] shareCountPerUnit=new int[5];
    for (    PublicCertificate c : playerPortfolio.getCertificates(company)) {
      if (c.isPresidentShare()) {
        shareCountPerUnit[1]+=c.getShares();
      }
 else {
        ++shareCountPerUnit[c.getShares()];
      }
    }
    price=getCurrentSellPrice(company);
    for (int i=1; i <= 4; i++) {
      number=shareCountPerUnit[i];
      if (number == 0)       continue;
      if ((Boolean)gameManager.getGameParameter(GameDef.Parm.NO_SALE_OF_JUST_BOUGHT_CERT) && company.equals(companyBoughtThisTurnWrapper.value())) {
        number--;
      }
      if (number <= 0)       continue;
      number=Math.min(number,maxShareToSell / (i * company.getShareUnit()));
      if (number <= 0)       continue;
    }
  }
}",0.946290395994538
173512,"public void nextRound(Round round){
  if (round instanceof StartRound) {
    if (startPacket != null && !startPacket.areAllSold()) {
      startOperatingRound(false);
    }
 else     if (skipFirstStockRound) {
      Phase currentPhase=phaseManager.getCurrentPhase();
      if (currentPhase.getNumberOfOperatingRounds() != numOfORs.value()) {
        numOfORs.set(currentPhase.getNumberOfOperatingRounds());
      }
      log.info(""String_Node_Str"" + currentPhase.getName() + ""String_Node_Str""+ numOfORs);
      relativeORNumber.set(1);
      startOperatingRound(true);
    }
 else {
      startStockRound();
    }
  }
 else   if (round instanceof StockRound) {
    Phase currentPhase=getCurrentPhase();
    if (currentPhase == null)     log.error(""String_Node_Str"",new Exception(""String_Node_Str""));
    numOfORs.set(currentPhase.getNumberOfOperatingRounds());
    log.info(""String_Node_Str"" + currentPhase.getName() + ""String_Node_Str""+ numOfORs);
    relativeORNumber.set(1);
    startOperatingRound(true);
  }
 else   if (round instanceof OperatingRound) {
    if (gameOverPending.value() && !gameEndsAfterSetOfORs) {
      finishGame();
    }
 else     if (relativeORNumber.add(1) <= numOfORs.value()) {
      startOperatingRound(true);
    }
 else     if (startPacket != null && !startPacket.areAllSold()) {
      startStartRound();
    }
 else {
      if (gameOverPending.value() && gameEndsAfterSetOfORs) {
        finishGame();
      }
 else {
        ((OperatingRound)round).checkForeignSales();
        startStockRound();
      }
    }
  }
}","public void nextRound(Round round){
  if (round instanceof StartRound) {
    if (startPacket != null && !startPacket.areAllSold()) {
      startOperatingRound(runIfStartPacketIsNotCompletelySold());
    }
 else     if (skipFirstStockRound) {
      Phase currentPhase=phaseManager.getCurrentPhase();
      if (currentPhase.getNumberOfOperatingRounds() != numOfORs.value()) {
        numOfORs.set(currentPhase.getNumberOfOperatingRounds());
      }
      log.info(""String_Node_Str"" + currentPhase.getName() + ""String_Node_Str""+ numOfORs);
      relativeORNumber.set(1);
      startOperatingRound(true);
    }
 else {
      startStockRound();
    }
  }
 else   if (round instanceof StockRound) {
    Phase currentPhase=getCurrentPhase();
    if (currentPhase == null)     log.error(""String_Node_Str"",new Exception(""String_Node_Str""));
    numOfORs.set(currentPhase.getNumberOfOperatingRounds());
    log.info(""String_Node_Str"" + currentPhase.getName() + ""String_Node_Str""+ numOfORs);
    relativeORNumber.set(1);
    startOperatingRound(true);
  }
 else   if (round instanceof OperatingRound) {
    if (gameOverPending.value() && !gameEndsAfterSetOfORs) {
      finishGame();
    }
 else     if (relativeORNumber.add(1) <= numOfORs.value()) {
      startOperatingRound(true);
    }
 else     if (startPacket != null && !startPacket.areAllSold()) {
      startStartRound();
    }
 else {
      if (gameOverPending.value() && gameEndsAfterSetOfORs) {
        finishGame();
      }
 else {
        ((OperatingRound)round).checkForeignSales();
        startStockRound();
      }
    }
  }
}",0.9865985960433952
173513,"@Override public boolean setPossibleActions(){
  List<StartItem> startItems=startPacket.getItems();
  List<StartItem> buyableItems=new ArrayList<StartItem>();
  int row;
  boolean buyable;
  int items=0;
  int minRow=0;
  for (  StartItem item : startItems) {
    buyable=false;
    if (item.isSold()) {
    }
 else     if (variant.equalsIgnoreCase(CLEMENS_VARIANT)) {
      buyable=true;
    }
 else {
      row=item.getRow();
      if (minRow == 0)       minRow=row;
      if (row == minRow) {
        buyable=true;
      }
 else       if (row == minRow + 1 && items == 1) {
        buyable=true;
      }
    }
    if (buyable) {
      items++;
      item.setStatus(StartItem.BUYABLE);
      buyableItems.add(item);
    }
  }
  possibleActions.clear();
  while (possibleActions.isEmpty()) {
    Player currentPlayer=getCurrentPlayer();
    if (currentPlayer == startPlayer)     ReportBuffer.add(""String_Node_Str"");
    int cashToSpend=currentPlayer.getCash();
    for (    StartItem item : buyableItems) {
      if (item.getBasePrice() <= cashToSpend) {
        possibleActions.add(new BuyStartItem(item,item.getBasePrice(),false));
      }
    }
    if (possibleActions.isEmpty()) {
      String message=LocalText.getText(""String_Node_Str"",currentPlayer.getId());
      ReportBuffer.add(message);
      DisplayBuffer.add(message);
      numPasses.add(1);
      if (numPasses.value() >= numPlayers) {
        numPasses.set(0);
        finishRound();
        if (!possibleActions.isEmpty())         break;
        return false;
      }
      setNextPlayer();
    }
  }
  possibleActions.add(new NullAction(NullAction.PASS));
  return true;
}","@Override public boolean setPossibleActions(){
  List<StartItem> startItems=startPacket.getItems();
  List<StartItem> buyableItems=new ArrayList<StartItem>();
  int row;
  boolean buyable;
  int items=0;
  int minRow=0;
  for (  StartItem item : startItems) {
    buyable=false;
    if (item.isSold()) {
    }
 else     if (variant.equalsIgnoreCase(CLEMENS_VARIANT)) {
      buyable=true;
    }
 else {
      row=item.getRow();
      if (minRow == 0)       minRow=row;
      if (row == minRow) {
        buyable=true;
      }
 else       if (row == minRow + 1 && items == 1) {
        buyable=true;
      }
    }
    if (buyable) {
      items++;
      item.setStatus(StartItem.BUYABLE);
      buyableItems.add(item);
    }
  }
  possibleActions.clear();
  while (possibleActions.isEmpty()) {
    Player currentPlayer=getCurrentPlayer();
    if (currentPlayer == startPlayer)     ReportBuffer.add(""String_Node_Str"");
    int cashToSpend=currentPlayer.getCash();
    for (    StartItem item : buyableItems) {
      if (item.getBasePrice() <= cashToSpend) {
        possibleActions.add(new BuyStartItem(item,item.getBasePrice(),false));
      }
    }
    if (possibleActions.isEmpty()) {
      String message=LocalText.getText(""String_Node_Str"",currentPlayer.getId());
      ReportBuffer.add(message);
      DisplayBuffer.add(message);
      numPasses.add(1);
      if (numPasses.value() >= numPlayers) {
        numPasses.set(0);
        finishRound();
        gameManager.getCurrentRound().setPossibleActions();
        if (!possibleActions.isEmpty())         break;
        return false;
      }
      setNextPlayer();
    }
  }
  possibleActions.add(new NullAction(NullAction.PASS));
  return true;
}",0.9820574162679426
173514,"public boolean buyBonusToken(BuyBonusToken action){
  String errMsg=null;
  int cost;
  SellBonusToken sbt=null;
  MoneyOwner seller=null;
  while (true) {
    sbt=action.getSpecialProperty();
    cost=sbt.getPrice();
    Owner from=sbt.getSeller();
    if (from instanceof BankPortfolio) {
      seller=bank;
    }
 else {
      seller=(MoneyOwner)from;
    }
    if (cost > operatingCompany.value().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),Currency.format(this,operatingCompany.value().getCash()),Currency.format(this,cost));
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),sbt.getId(),seller.getId(),bank.getCurrency().format(cost),errMsg));
    return false;
  }
  ChangeStack.start(this,action);
  String costText=Currency.wire(operatingCompany.value(),cost,seller);
  operatingCompany.value().addBonus(new Bonus(operatingCompany.value(),sbt.getId(),sbt.getValue(),sbt.getLocations()));
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),sbt.getId(),bank.getCurrency().format(sbt.getValue()),seller.getId(),bank.getCurrency().format(sbt.getPrice())));
  sbt.setExercised();
  return true;
}","public boolean buyBonusToken(BuyBonusToken action){
  String errMsg=null;
  int cost;
  SellBonusToken sbt=null;
  MoneyOwner seller=null;
  while (true) {
    sbt=action.getSpecialProperty();
    cost=sbt.getPrice();
    Owner from=sbt.getSeller();
    if (from instanceof BankPortfolio) {
      seller=bank;
    }
 else {
      seller=(MoneyOwner)from;
    }
    if (cost > operatingCompany.value().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),Currency.format(this,operatingCompany.value().getCash()),Currency.format(this,cost));
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),sbt.getId(),seller.getId(),bank.getCurrency().format(cost),errMsg));
    return false;
  }
  ChangeStack.start(this,action);
  String costText=Currency.wire(operatingCompany.value(),cost,seller);
  operatingCompany.value().addBonus(new Bonus(operatingCompany.value(),sbt.getId(),sbt.getValue(),sbt.getLocations()));
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),sbt.getName(),bank.getCurrency().format(sbt.getValue()),seller.getId(),bank.getCurrency().format(sbt.getPrice())));
  sbt.setExercised();
  return true;
}",0.9976708074534162
173515,"/** 
 * Do we have any special properties?
 * @return Boolean
 */
public boolean hasSpecialProperties(){
  return specialProperties != null && !specialProperties.isEmpty();
}","/** 
 * Do we have any special properties?
 * @return Boolean
 */
public boolean hasSpecialProperties(){
  return !specialProperties.isEmpty();
}",0.9090909090909092
173516,"/** 
 * Final initialisation, after all XML has been processed.
 */
public void finishConfiguration(GameManager gameManager) throws ConfigurationException {
  this.gameManager=gameManager;
  bank=gameManager.getBank();
  stockMarket=gameManager.getStockMarket();
  mapManager=gameManager.getMapManager();
  if (turnsWithExtraTileLaysInit != null) {
    turnsWithExtraTileLays=new HashMap<String,IntegerState>();
    for (    String colour : turnsWithExtraTileLaysInit.keySet()) {
      IntegerState tileLays=IntegerState.create(this,""String_Node_Str"" + colour + ""String_Node_Str"",turnsWithExtraTileLaysInit.get(colour));
      turnsWithExtraTileLays.put(colour,tileLays);
    }
  }
  if (maxNumberOfLoans != 0) {
    currentNumberOfLoans=IntegerState.create(this,""String_Node_Str"");
    currentLoanValue=CountingMoneyModel.create(this,""String_Node_Str"",false);
    currentLoanValue.setSuppressZero(true);
  }
  if (hasStockPrice && Util.hasValue(startSpace)) {
    parPrice.setPrice(stockMarket.getStockSpace(startSpace));
    if (parPrice.getPrice() == null)     throw new ConfigurationException(""String_Node_Str"" + startSpace + ""String_Node_Str""+ getId());
    currentPrice.setPrice(parPrice.getPrice());
  }
  if (shareUnit == null) {
    shareUnit=IntegerState.create(this,""String_Node_Str"",DEFAULT_SHARE_UNIT);
  }
  int certIndex=0;
  if (certificateTags != null) {
    int shareTotal=0;
    boolean gotPresident=false;
    PublicCertificate certificate;
    for (    Tag certificateTag : certificateTags) {
      int shares=certificateTag.getAttributeAsInteger(""String_Node_Str"",1);
      boolean president=""String_Node_Str"".equals(certificateTag.getAttributeAsString(""String_Node_Str"",""String_Node_Str""));
      int number=certificateTag.getAttributeAsInteger(""String_Node_Str"",1);
      boolean certIsInitiallyAvailable=certificateTag.getAttributeAsBoolean(""String_Node_Str"",certsAreInitiallyAvailable);
      float certificateCount=certificateTag.getAttributeAsFloat(""String_Node_Str"",1.0f);
      if (president) {
        if (number > 1 || gotPresident)         throw new ConfigurationException(""String_Node_Str"" + getId() + ""String_Node_Str"");
        gotPresident=true;
      }
      for (int k=0; k < number; k++) {
        certificate=new PublicCertificate(this,""String_Node_Str"" + certIndex,shares,president,certIsInitiallyAvailable,certificateCount,certIndex++);
        certificates.add(certificate);
        shareTotal+=shares * shareUnit.value();
      }
    }
    if (shareTotal != 100)     throw new ConfigurationException(""String_Node_Str"" + getId() + ""String_Node_Str"");
  }
  nameCertificates();
  PublicCertificate cert;
  for (int i=0; i < certificates.size(); i++) {
    cert=certificates.get(i);
    cert.setUniqueId(getId(),i);
    cert.setInitiallyAvailable(cert.isInitiallyAvailable() && this.certsAreInitiallyAvailable);
  }
  Set<BaseToken> newTokens=Sets.newHashSet();
  for (int i=0; i < numberOfBaseTokens; i++) {
    BaseToken token=BaseToken.create(this);
    newTokens.add(token);
  }
  baseTokens.initTokens(newTokens);
  if (homeHexNames != null) {
    homeHexes=new ArrayList<MapHex>(2);
    MapHex homeHex;
    for (    String homeHexName : homeHexNames.split(""String_Node_Str"")) {
      homeHex=mapManager.getHex(homeHexName);
      if (homeHex == null) {
        throw new ConfigurationException(""String_Node_Str"" + homeHexName + ""String_Node_Str""+ getId());
      }
      homeHexes.add(homeHex);
      infoText+=""String_Node_Str"" + homeHex.getInfo();
    }
  }
  if (destinationHexName != null) {
    destinationHex=mapManager.getHex(destinationHexName);
    if (destinationHex == null) {
      throw new ConfigurationException(""String_Node_Str"" + destinationHexName + ""String_Node_Str""+ getId());
    }
    infoText+=""String_Node_Str"" + destinationHex.getInfo();
  }
  if (Util.hasValue(privateToCloseOnFirstTrainName)) {
    privateToCloseOnFirstTrain=gameManager.getCompanyManager().getPrivateCompany(privateToCloseOnFirstTrainName);
  }
  infoText+=parentInfoText;
  parentInfoText=""String_Node_Str"";
  if (portfolio.getSpecialProperties() != null) {
    for (    SpecialProperty sp : portfolio.getSpecialProperties()) {
      if (sp instanceof SpecialRight) {
        gameManager.setGuiParameter(GuiDef.Parm.HAS_ANY_RIGHTS,true);
        if (rights == null) {
          rights=HashMapState.create(this,""String_Node_Str"");
        }
        sp.finishConfiguration(gameManager);
      }
    }
  }
  portfolio.finishConfiguration();
}","/** 
 * Final initialisation, after all XML has been processed.
 */
public void finishConfiguration(GameManager gameManager) throws ConfigurationException {
  this.gameManager=gameManager;
  bank=gameManager.getBank();
  stockMarket=gameManager.getStockMarket();
  mapManager=gameManager.getMapManager();
  if (turnsWithExtraTileLaysInit != null) {
    turnsWithExtraTileLays=new HashMap<String,IntegerState>();
    for (    String colour : turnsWithExtraTileLaysInit.keySet()) {
      IntegerState tileLays=IntegerState.create(this,""String_Node_Str"" + colour + ""String_Node_Str"",turnsWithExtraTileLaysInit.get(colour));
      turnsWithExtraTileLays.put(colour,tileLays);
    }
  }
  if (maxNumberOfLoans != 0) {
    currentNumberOfLoans=IntegerState.create(this,""String_Node_Str"");
    currentLoanValue=CountingMoneyModel.create(this,""String_Node_Str"",false);
    currentLoanValue.setSuppressZero(true);
  }
  if (hasStockPrice && Util.hasValue(startSpace)) {
    parPrice.setPrice(stockMarket.getStockSpace(startSpace));
    if (parPrice.getPrice() == null)     throw new ConfigurationException(""String_Node_Str"" + startSpace + ""String_Node_Str""+ getId());
    currentPrice.setPrice(parPrice.getPrice());
  }
  if (shareUnit == null) {
    shareUnit=IntegerState.create(this,""String_Node_Str"",DEFAULT_SHARE_UNIT);
  }
  int certIndex=0;
  if (certificateTags != null) {
    int shareTotal=0;
    boolean gotPresident=false;
    PublicCertificate certificate;
    for (    Tag certificateTag : certificateTags) {
      int shares=certificateTag.getAttributeAsInteger(""String_Node_Str"",1);
      boolean president=""String_Node_Str"".equals(certificateTag.getAttributeAsString(""String_Node_Str"",""String_Node_Str""));
      int number=certificateTag.getAttributeAsInteger(""String_Node_Str"",1);
      boolean certIsInitiallyAvailable=certificateTag.getAttributeAsBoolean(""String_Node_Str"",certsAreInitiallyAvailable);
      float certificateCount=certificateTag.getAttributeAsFloat(""String_Node_Str"",1.0f);
      if (president) {
        if (number > 1 || gotPresident)         throw new ConfigurationException(""String_Node_Str"" + getId() + ""String_Node_Str"");
        gotPresident=true;
      }
      for (int k=0; k < number; k++) {
        certificate=new PublicCertificate(this,""String_Node_Str"" + certIndex,shares,president,certIsInitiallyAvailable,certificateCount,certIndex++);
        certificates.add(certificate);
        shareTotal+=shares * shareUnit.value();
      }
    }
    if (shareTotal != 100)     throw new ConfigurationException(""String_Node_Str"" + getId() + ""String_Node_Str"");
  }
  nameCertificates();
  PublicCertificate cert;
  for (int i=0; i < certificates.size(); i++) {
    cert=certificates.get(i);
    cert.setUniqueId(getId(),i);
    cert.setInitiallyAvailable(cert.isInitiallyAvailable() && this.certsAreInitiallyAvailable);
  }
  Set<BaseToken> newTokens=Sets.newHashSet();
  for (int i=0; i < numberOfBaseTokens; i++) {
    BaseToken token=BaseToken.create(this);
    newTokens.add(token);
  }
  baseTokens.initTokens(newTokens);
  if (homeHexNames != null) {
    homeHexes=new ArrayList<MapHex>(2);
    MapHex homeHex;
    for (    String homeHexName : homeHexNames.split(""String_Node_Str"")) {
      homeHex=mapManager.getHex(homeHexName);
      if (homeHex == null) {
        throw new ConfigurationException(""String_Node_Str"" + homeHexName + ""String_Node_Str""+ getId());
      }
      homeHexes.add(homeHex);
      infoText+=""String_Node_Str"" + homeHex.getInfo();
    }
  }
  if (destinationHexName != null) {
    destinationHex=mapManager.getHex(destinationHexName);
    if (destinationHex == null) {
      throw new ConfigurationException(""String_Node_Str"" + destinationHexName + ""String_Node_Str""+ getId());
    }
    infoText+=""String_Node_Str"" + destinationHex.getInfo();
  }
  if (Util.hasValue(privateToCloseOnFirstTrainName)) {
    privateToCloseOnFirstTrain=gameManager.getCompanyManager().getPrivateCompany(privateToCloseOnFirstTrainName);
  }
  infoText+=parentInfoText;
  parentInfoText=""String_Node_Str"";
  if (portfolio.hasSpecialProperties()) {
    for (    SpecialProperty sp : portfolio.getPersistentSpecialProperties()) {
      if (sp instanceof SpecialRight) {
        gameManager.setGuiParameter(GuiDef.Parm.HAS_ANY_RIGHTS,true);
        if (rights == null) {
          rights=HashMapState.create(this,""String_Node_Str"");
        }
        sp.finishConfiguration(gameManager);
      }
    }
  }
  portfolio.finishConfiguration();
}",0.9973238180196252
173517,"public ImmutableSet<SpecialProperty> getSpecialProperties(){
  return portfolio.getSpecialProperties().items();
}","public ImmutableSet<SpecialProperty> getSpecialProperties(){
  return portfolio.getPersistentSpecialProperties();
}",0.9210526315789472
173518,"@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action instanceof ExchangeTokens))   return false;
  ExchangeTokens a=(ExchangeTokens)action;
  return a.tokensToExchange == tokensToExchange && a.company == company;
}","@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action instanceof ExchangeTokens))   return false;
  ExchangeTokens a=(ExchangeTokens)action;
  if (a.company != this.company)   return false;
  for (int i=0; i < tokensToExchange.size(); i++) {
    if (!(a.tokensToExchange.get(i).equalsAsOption(tokensToExchange.get(i)))) {
      return false;
    }
  }
  return true;
}",0.5402843601895735
173519,"public boolean isPlaced(){
  return getParent().getBaseTokensModel().tokenIsLaid(this);
}","public boolean isPlaced(){
  return !(getOwner() == getParent());
}",0.6538461538461539
173520,"public boolean buyBonusToken(BuyBonusToken action){
  String errMsg=null;
  int cost;
  SellBonusToken sbt=null;
  MoneyOwner seller=null;
  while (true) {
    sbt=action.getSpecialProperty();
    cost=sbt.getPrice();
    seller=(MoneyOwner)sbt.getSeller();
    if (cost > operatingCompany.value().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),Currency.format(this,operatingCompany.value().getCash()),Currency.format(this,cost));
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),sbt.getId(),seller.getId(),bank.getCurrency().format(cost),errMsg));
    return false;
  }
  ChangeStack.start(this,action);
  String costText=Currency.wire(operatingCompany.value(),cost,seller);
  operatingCompany.value().addBonus(new Bonus(operatingCompany.value(),sbt.getId(),sbt.getValue(),sbt.getLocations()));
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),sbt.getId(),bank.getCurrency().format(sbt.getValue()),seller.getId(),bank.getCurrency().format(sbt.getPrice())));
  sbt.setExercised();
  return true;
}","public boolean buyBonusToken(BuyBonusToken action){
  String errMsg=null;
  int cost;
  SellBonusToken sbt=null;
  MoneyOwner seller=null;
  while (true) {
    sbt=action.getSpecialProperty();
    cost=sbt.getPrice();
    Owner from=sbt.getSeller();
    if (from instanceof BankPortfolio) {
      seller=bank;
    }
 else {
      seller=(MoneyOwner)from;
    }
    if (cost > operatingCompany.value().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),Currency.format(this,operatingCompany.value().getCash()),Currency.format(this,cost));
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),sbt.getId(),seller.getId(),bank.getCurrency().format(cost),errMsg));
    return false;
  }
  ChangeStack.start(this,action);
  String costText=Currency.wire(operatingCompany.value(),cost,seller);
  operatingCompany.value().addBonus(new Bonus(operatingCompany.value(),sbt.getId(),sbt.getValue(),sbt.getLocations()));
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),sbt.getId(),bank.getCurrency().format(sbt.getValue()),seller.getId(),bank.getCurrency().format(sbt.getPrice())));
  sbt.setExercised();
  return true;
}",0.9469850263051396
173521,"/** 
 * Who receives the cash when a certificate is bought. With incremental capitalization, this can be the company treasure. This method must be called <i>before</i> transferring the certificate.
 * @param cert
 * @return
 */
protected MoneyOwner getSharePriceRecipient(PublicCompany comp,Owner from,int price){
  MoneyOwner recipient;
  if (comp.hasFloated() && from == ipo.getParent() && comp.getCapitalisation() == PublicCompany.CAPITALISE_INCREMENTAL) {
    recipient=comp;
  }
 else   if (from instanceof BankPortfolio) {
    recipient=((BankPortfolio)from).getParent();
  }
 else {
    recipient=(MoneyOwner)from;
  }
  return recipient;
}","/** 
 * Who receives the cash when a certificate is bought. With incremental capitalization, this can be the company treasure. This method must be called <i>before</i> transferring the certificate.
 * @param cert
 * @return
 */
protected MoneyOwner getSharePriceRecipient(PublicCompany comp,Owner from,int price){
  MoneyOwner recipient;
  if (comp.hasFloated() && from == ipo.getParent() && comp.getCapitalisation() == PublicCompany.CAPITALISE_INCREMENTAL) {
    recipient=comp;
  }
 else   if (from instanceof BankPortfolio) {
    recipient=bank;
  }
 else {
    recipient=(MoneyOwner)from;
  }
  return recipient;
}",0.9754940711462452
173522,"public Set<Train> getAvailableNewTrains(){
  Set<Train> availableTrains=new HashSet<Train>();
  Train train;
  for (  TrainCertificateType type : trainCertTypes) {
    if (type.isAvailable()) {
      train=ipo.getTrainOfType(type);
      if (train != null) {
        availableTrains.add(train);
      }
    }
  }
  return availableTrains;
}","public Set<Train> getAvailableNewTrains(){
  Set<Train> availableTrains=new TreeSet<Train>();
  Train train;
  for (  TrainCertificateType type : trainCertTypes) {
    if (type.isAvailable()) {
      train=ipo.getTrainOfType(type);
      if (train != null) {
        availableTrains.add(train);
      }
    }
  }
  return availableTrains;
}",0.9882352941176472
173523,"/** 
 */
public BuyBonusToken(SellBonusToken specialProperty){
  this.specialProperty=specialProperty;
  this.specialPropertyId=specialProperty.getUniqueId();
  this.privateCompany=(PrivateCompany)specialProperty.getOriginalCompany();
  this.privateCompanyName=privateCompany.getId();
  this.seller=specialProperty.getSeller();
  if (seller != null)   this.sellerName=seller.getId();
  this.name=specialProperty.getId();
  this.price=specialProperty.getPrice();
  this.value=specialProperty.getValue();
  this.locationString=specialProperty.getLocationNameString();
}","/** 
 */
public BuyBonusToken(SellBonusToken specialProperty){
  this.specialProperty=specialProperty;
  this.specialPropertyId=specialProperty.getUniqueId();
  this.privateCompany=(PrivateCompany)specialProperty.getOriginalCompany();
  this.privateCompanyName=privateCompany.getId();
  this.seller=specialProperty.getSeller();
  if (seller != null)   this.sellerName=seller.getId();
  this.name=specialProperty.getName();
  this.price=specialProperty.getPrice();
  this.value=specialProperty.getValue();
  this.locationString=specialProperty.getLocationNameString();
}",0.9947183098591548
173524,"/** 
 * Implements special rules for first time operating in 1856
 */
@Override protected boolean setNextOperatingCompany(boolean initial){
  while (true) {
    if (initial || operatingCompany.value() == null || operatingCompany == null) {
      setOperatingCompany(operatingCompanies.get(0));
      initial=false;
    }
 else {
      int index=operatingCompanies.indexOf(operatingCompany.value());
      if (++index >= operatingCompanies.size()) {
        return false;
      }
      setOperatingCompany(operatingCompanies.get(index));
    }
    if (operatingCompany.value() instanceof PublicCompany_CGR)     return true;
    if (operatingCompany.value().isClosed())     continue;
    if (!operatingCompany.value().hasOperated()) {
      int soldPercentage=getSoldPercentage(operatingCompany.value());
      Train nextAvailableTrain=Iterables.get(gameManager.getTrainManager().getAvailableNewTrains(),0);
      int trainNumber;
      try {
        trainNumber=Integer.parseInt(nextAvailableTrain.getId());
      }
 catch (      NumberFormatException e) {
        trainNumber=6;
      }
      int floatPercentage=10 * trainNumber;
      log.debug(""String_Node_Str"" + floatPercentage + ""String_Node_Str""+ soldPercentage);
      if (soldPercentage < floatPercentage) {
        DisplayBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),String.valueOf(soldPercentage),String.valueOf(floatPercentage)));
        continue;
      }
    }
    return true;
  }
}","/** 
 * Implements special rules for first time operating in 1856
 */
@Override protected boolean setNextOperatingCompany(boolean initial){
  while (true) {
    if (initial || operatingCompany.value() == null || operatingCompany == null) {
      setOperatingCompany(operatingCompanies.get(0));
      initial=false;
    }
 else {
      int index=operatingCompanies.indexOf(operatingCompany.value());
      if (++index >= operatingCompanies.size()) {
        return false;
      }
      setOperatingCompany(operatingCompanies.get(index));
    }
    if (operatingCompany.value() instanceof PublicCompany_CGR)     return true;
    if (operatingCompany.value().isClosed())     continue;
    if (!operatingCompany.value().hasOperated()) {
      int soldPercentage=getSoldPercentage(operatingCompany.value());
      Train nextAvailableTrain=Iterables.get(gameManager.getTrainManager().getAvailableNewTrains(),0);
      log.debug(""String_Node_Str"" + nextAvailableTrain.getCertType().getId());
      int trainNumber;
      try {
        trainNumber=Integer.parseInt(nextAvailableTrain.getCertType().getId());
      }
 catch (      NumberFormatException e) {
        trainNumber=6;
      }
      int floatPercentage=10 * trainNumber;
      log.debug(""String_Node_Str"" + floatPercentage + ""String_Node_Str""+ soldPercentage);
      if (soldPercentage < floatPercentage) {
        DisplayBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),String.valueOf(soldPercentage),String.valueOf(floatPercentage)));
        continue;
      }
    }
    return true;
  }
}",0.9695780176643768
173525,"@Override public void start(StockSpace startSpace){
  super.start(startSpace);
  Train nextAvailableTrain=Iterables.get(gameManager.getTrainManager().getAvailableNewTrains(),0);
  int trainNumber;
  try {
    trainNumber=Integer.parseInt(nextAvailableTrain.getId());
  }
 catch (  NumberFormatException e) {
    trainNumber=6;
  }
  trainNumberAvailableAtStart.set(trainNumber);
  if (trainNumber == 6) {
    this.capitalisation=CAPITALISE_FULL;
  }
}","@Override public void start(StockSpace startSpace){
  super.start(startSpace);
  Train nextAvailableTrain=Iterables.get(gameManager.getTrainManager().getAvailableNewTrains(),0);
  int trainNumber;
  try {
    trainNumber=Integer.parseInt(nextAvailableTrain.getCertType().getId());
  }
 catch (  NumberFormatException e) {
    trainNumber=6;
  }
  trainNumberAvailableAtStart.set(trainNumber);
  if (trainNumber == 6) {
    this.capitalisation=CAPITALISE_FULL;
  }
}",0.9847161572052402
173526,"@Override protected MoneyOwner getSharePriceRecipient(PublicCompany company,Owner from,int price){
  MoneyOwner recipient;
  if (price != 0 && !company.getId().equalsIgnoreCase(PublicCompany_CGR.NAME) && from == ipo.getParent()) {
    PublicCompany_1856 comp=(PublicCompany_1856)company;
switch (comp.getTrainNumberAvailableAtStart()) {
case 2:
case 3:
case 4:
      if (getSoldPercentage(comp) >= 50 && !comp.hasReachedDestination()) {
        recipient=bank;
        comp.addMoneyInEscrow(price);
        ReportBuffer.addWaiting(LocalText.getText(""String_Node_Str"",Currency.format(this,price),Currency.format(this,comp.getMoneyInEscrow()),comp.getId()));
        break;
      }
case 5:
    recipient=comp;
  break;
case 6:
default :
recipient=bank;
}
}
 else {
recipient=(MoneyOwner)from;
}
return recipient;
}","@Override protected MoneyOwner getSharePriceRecipient(PublicCompany company,Owner from,int price){
  MoneyOwner recipient;
  if (price != 0 && !company.getId().equalsIgnoreCase(PublicCompany_CGR.NAME) && from == ipo.getParent()) {
    PublicCompany_1856 comp=(PublicCompany_1856)company;
switch (comp.getTrainNumberAvailableAtStart()) {
case 2:
case 3:
case 4:
      if (getSoldPercentage(comp) >= 50 && !comp.hasReachedDestination()) {
        recipient=bank;
        comp.addMoneyInEscrow(price);
        ReportBuffer.addWaiting(LocalText.getText(""String_Node_Str"",Currency.format(this,price),Currency.format(this,comp.getMoneyInEscrow()),comp.getId()));
        break;
      }
case 5:
    recipient=comp;
  break;
case 6:
default :
recipient=bank;
}
}
 else if (from instanceof BankPortfolio) {
recipient=bank;
}
 else {
recipient=(MoneyOwner)from;
}
return recipient;
}",0.9637982195845696
173527,"/** 
 * This method executes the start item buy action.
 * @param player Buying player.
 * @param item Start item being bought.
 * @param price Buy price.
 */
protected void assignItem(Player player,StartItem item,int price,int sharePrice){
  Certificate primary=item.getPrimary();
  String priceText=Currency.toBank(player,price);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",player.getId(),primary.getId(),priceText));
  transferCertificate(primary,player.getPortfolioModel());
  checksOnBuying(primary,sharePrice);
  if (item.hasSecondary()) {
    Certificate extra=item.getSecondary();
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",player.getId(),extra.getName()));
    transferCertificate(extra,player.getPortfolioModel());
    checksOnBuying(extra,sharePrice);
  }
  item.setSold(player,price);
}","/** 
 * This method executes the start item buy action.
 * @param player Buying player.
 * @param item Start item being bought.
 * @param price Buy price.
 */
protected void assignItem(Player player,StartItem item,int price,int sharePrice){
  Certificate primary=item.getPrimary();
  String priceText=Currency.toBank(player,price);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",player.getId(),primary.getName(),priceText));
  transferCertificate(primary,player.getPortfolioModel());
  checksOnBuying(primary,sharePrice);
  if (item.hasSecondary()) {
    Certificate extra=item.getSecondary();
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",player.getId(),extra.getName()));
    transferCertificate(extra,player.getPortfolioModel());
    checksOnBuying(extra,sharePrice);
  }
  item.setSold(player,price);
}",0.9963592233009708
173528,"/** 
 * Start a company by buying one or more shares (more applies to e.g. 1841)
 * @param player The player that wants to start a company.
 * @param company The company to start.
 * @param price The start (par) price (ignored if the price is fixed).
 * @param shares The number of shares to buy (can be more than 1 in e.g.1841).
 * @return True if the company could be started. False indicates an error.
 */
@Override public boolean startCompany(String playerName,StartCompany action){
  PublicCompany company=action.getCompany();
  int price=action.getPrice();
  int shares=action.getNumberBought();
  String errMsg=null;
  StockSpace startSpace=null;
  int numberOfCertsToBuy=0;
  PublicCertificate cert=null;
  String companyName=company.getId();
  PublicCompany minor=null;
  StartCompany_18EU startAction=null;
  Stop selectedHomeCity=null;
  currentPlayer=getCurrentPlayer();
  while (true) {
    if (!(action instanceof StartCompany_18EU)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    startAction=(StartCompany_18EU)action;
    if (companyBoughtThisTurnWrapper.value() != null) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    company=companyManager.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.hasStarted()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    cert=ipo.findCertificate(company,true);
    if (shares < cert.getShares())     shares=cert.getShares();
    numberOfCertsToBuy=shares - (cert.getShares() - 1);
    if (!mayPlayerBuyCertificate(currentPlayer,company,numberOfCertsToBuy)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if ((startSpace=stockMarket.getStartSpace(price)) == null) {
      errMsg=LocalText.getText(""String_Node_Str"",Currency.format(this,price),company.getId());
      break;
    }
    if (currentPlayer.getCashValue() < shares * price) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!phase5Reached) {
      minor=startAction.getChosenMinor();
      if (minor != null && currentPlayer.getPortfolioModel().getCertificates(minor) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",currentPlayer.getId(),minor.getId());
        break;
      }
    }
 else {
      selectedHomeCity=startAction.getSelectedHomeStation();
      if (selectedHomeCity.getSlots() <= selectedHomeCity.getBaseTokens().size()) {
        errMsg=LocalText.getText(""String_Node_Str"",selectedHomeCity.toString(),company.getId());
        break;
      }
    }
    numberOfCertsToBuy++;
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,companyName,Currency.format(this,price),errMsg));
    return false;
  }
  ChangeStack.start(this,action);
  MapHex homeHex=null;
  int homeCityNumber=1;
  if (minor != null) {
    homeHex=minor.getHomeHexes().get(0);
    homeCityNumber=homeHex.getCityOfBaseToken(minor);
  }
 else   if (selectedHomeCity != null) {
    homeHex=selectedHomeCity.getParent();
    homeCityNumber=selectedHomeCity.getNumber();
  }
  company.setHomeHex(homeHex);
  company.setHomeCityNumber(homeCityNumber);
  company.start(startSpace);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,companyName,Currency.format(this,price),Currency.format(this,shares * price),shares,cert.getShare(),company.getId()));
  cert.moveTo(currentPlayer);
  Currency.wire(currentPlayer,shares * price,company);
  if (minor != null) {
    PublicCertificate cert2=ipo.findCertificate(company,false);
    cert2.moveTo(currentPlayer);
    int minorCash=minor.getCash();
    int minorTrains=minor.getPortfolioModel().getTrainList().size();
    company.transferAssetsFrom(minor);
    minor.setClosed();
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",currentPlayer.getId(),minor.getId(),company.getId(),Currency.format(this,minorCash),minorTrains));
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",currentPlayer.getId(),cert2.getShare(),company.getId(),ipo.getId(),minor.getId()));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),selectedHomeCity.toString()));
  }
  Portfolio.moveAll(ipo.getCertificates(company),company);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getPortfolioModel().getShare(company),company.getId()));
  int tokensCost=100;
  String costText=Currency.toBank(company,tokensCost);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),costText,company.getNumberOfBaseTokens()));
  companyBoughtThisTurnWrapper.set(company);
  hasActed.set(true);
  setPriority();
  return true;
}","/** 
 * Start a company by buying one or more shares (more applies to e.g. 1841)
 * @param player The player that wants to start a company.
 * @param company The company to start.
 * @param price The start (par) price (ignored if the price is fixed).
 * @param shares The number of shares to buy (can be more than 1 in e.g.1841).
 * @return True if the company could be started. False indicates an error.
 */
@Override public boolean startCompany(String playerName,StartCompany action){
  PublicCompany company=action.getCompany();
  int price=action.getPrice();
  int shares=action.getNumberBought();
  String errMsg=null;
  StockSpace startSpace=null;
  int numberOfCertsToBuy=0;
  PublicCertificate cert=null;
  String companyName=company.getId();
  PublicCompany minor=null;
  StartCompany_18EU startAction=null;
  Stop selectedHomeCity=null;
  currentPlayer=getCurrentPlayer();
  while (true) {
    if (!(action instanceof StartCompany_18EU)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    startAction=(StartCompany_18EU)action;
    if (companyBoughtThisTurnWrapper.value() != null) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    company=companyManager.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.hasStarted()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    cert=ipo.findCertificate(company,true);
    if (shares < cert.getShares())     shares=cert.getShares();
    numberOfCertsToBuy=shares - (cert.getShares() - 1);
    if (!mayPlayerBuyCertificate(currentPlayer,company,numberOfCertsToBuy)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if ((startSpace=stockMarket.getStartSpace(price)) == null) {
      errMsg=LocalText.getText(""String_Node_Str"",Currency.format(this,price),company.getId());
      break;
    }
    if (currentPlayer.getCashValue() < shares * price) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!phase5Reached) {
      minor=startAction.getChosenMinor();
      if (minor != null && currentPlayer.getPortfolioModel().getCertificates(minor) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",currentPlayer.getId(),minor.getId());
        break;
      }
    }
 else {
      selectedHomeCity=startAction.getSelectedHomeStation();
      if (selectedHomeCity.getSlots() <= selectedHomeCity.getBaseTokens().size()) {
        errMsg=LocalText.getText(""String_Node_Str"",selectedHomeCity.toString(),company.getId());
        break;
      }
    }
    numberOfCertsToBuy++;
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,companyName,Currency.format(this,price),errMsg));
    return false;
  }
  ChangeStack.start(this,action);
  MapHex homeHex=null;
  int homeCityNumber=1;
  if (minor != null) {
    homeHex=minor.getHomeHexes().get(0);
    homeCityNumber=homeHex.getCityOfBaseToken(minor);
  }
 else   if (selectedHomeCity != null) {
    homeHex=selectedHomeCity.getParent();
    homeCityNumber=selectedHomeCity.getNumber();
  }
  company.setHomeHex(homeHex);
  company.setHomeCityNumber(homeCityNumber);
  company.start(startSpace);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,companyName,Currency.format(this,price),Currency.format(this,shares * price),shares,cert.getShare(),company.getId()));
  cert.moveTo(currentPlayer);
  Currency.wire(currentPlayer,shares * price,company);
  if (minor != null) {
    PublicCertificate cert2=ipo.findCertificate(company,false);
    cert2.moveTo(currentPlayer);
    int minorCash=minor.getCash();
    int minorTrains=minor.getPortfolioModel().getTrainList().size();
    company.transferAssetsFrom(minor);
    minor.setClosed();
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",currentPlayer.getId(),minor.getId(),company.getId(),Currency.format(this,minorCash),minorTrains));
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",currentPlayer.getId(),cert2.getShare(),company.getId(),ipo.getParent().getId(),minor.getId()));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),selectedHomeCity.toString()));
  }
  Portfolio.moveAll(ipo.getCertificates(company),company);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getPortfolioModel().getShare(company),company.getId()));
  int tokensCost=100;
  String costText=Currency.toBank(company,tokensCost);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),costText,company.getNumberOfBaseTokens()));
  companyBoughtThisTurnWrapper.set(company);
  hasActed.set(true);
  setPriority();
  return true;
}",0.9987389659520808
173529,"/** 
 * Used by Configure (via reflection) only
 */
public RevenueManager(Item parent,String id){
  super(parent,id);
}","/** 
 * Used by Configure (via reflection) only
 */
public RevenueManager(RailsRoot parent,String id){
  super(parent,id);
}",0.9547325102880658
173530,"public boolean processOnReload(PossibleAction action) throws Exception {
  DisplayBuffer.clear();
  if (gameName.equals(""String_Node_Str"") && possibleActions.contains(RepayLoans.class) && (!possibleActions.contains(action.getClass()) || (action.getClass() == NullAction.class && ((NullAction)action).getMode() != NullAction.DONE))) {
    log.debug(""String_Node_Str"");
    getCurrentRound().process(new NullAction(NullAction.DONE));
    possibleActions.clear();
    getCurrentRound().setPossibleActions();
    if (!isGameOver())     setCorrectionActions();
  }
  try {
    log.debug(""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action);
    boolean doProcess=true;
    if (skipNextDone) {
      if (action instanceof NullAction && ((NullAction)action).getMode() == NullAction.DONE) {
        if (currentRound.value() instanceof OperatingRound && ((OperatingRound)currentRound.value()).getStep() == skippedStep) {
          doProcess=false;
        }
      }
    }
    skipNextDone=false;
    skippedStep=null;
    if (doProcess && !processCorrectionActions(action) && !getCurrentRound().process(action)) {
      String msg=""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action.toString()+ ""String_Node_Str""+ getCurrentRound().getRoundName()+ ""String_Node_Str"";
      log.error(msg);
      DisplayBuffer.add(msg);
      return false;
    }
    possibleActions.clear();
    getCurrentRound().setPossibleActions();
    String playerName=getCurrentPlayer().getId();
    for (    PossibleAction a : possibleActions.getList()) {
      log.debug(playerName + ""String_Node_Str"" + a.toString());
    }
    if (!isGameOver())     setCorrectionActions();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + action.toString(),e);
    throw new Exception(""String_Node_Str"",e);
  }
  executedActions.add(action);
  log.debug(""String_Node_Str"" + getCurrentPlayer().getId());
  return true;
}","public boolean processOnReload(PossibleAction action) throws Exception {
  DisplayBuffer.clear();
  if (gameName.equals(""String_Node_Str"") && possibleActions.contains(RepayLoans.class) && (!possibleActions.contains(action.getClass()) || (action.getClass() == NullAction.class && ((NullAction)action).getMode() != NullAction.DONE))) {
    log.debug(""String_Node_Str"");
    getCurrentRound().process(new NullAction(NullAction.DONE));
    possibleActions.clear();
    getCurrentRound().setPossibleActions();
    if (!isGameOver())     setCorrectionActions();
  }
  try {
    log.debug(""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action);
    boolean doProcess=true;
    if (skipNextDone) {
      if (action instanceof NullAction && ((NullAction)action).getMode() == NullAction.DONE) {
        if (currentRound.value() instanceof OperatingRound && ((OperatingRound)currentRound.value()).getStep() == skippedStep) {
          doProcess=false;
        }
      }
    }
    skipNextDone=false;
    skippedStep=null;
    if (doProcess && !processCorrectionActions(action) && !getCurrentRound().process(action)) {
      String msg=""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action.toString()+ ""String_Node_Str""+ getCurrentRound().getRoundName()+ ""String_Node_Str"";
      log.error(msg);
      DisplayBuffer.add(msg);
      ChangeStack changeStack=getRoot().getStateManager().getChangeStack();
      if (changeStack.isOpen())       changeStack.close();
      return false;
    }
    possibleActions.clear();
    getCurrentRound().setPossibleActions();
    String playerName=getCurrentPlayer().getId();
    for (    PossibleAction a : possibleActions.getList()) {
      log.debug(playerName + ""String_Node_Str"" + a.toString());
    }
    if (!isGameOver())     setCorrectionActions();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + action.toString(),e);
    throw new Exception(""String_Node_Str"",e);
  }
  executedActions.add(action);
  log.debug(""String_Node_Str"" + getCurrentPlayer().getId());
  return true;
}",0.9660718773561195
173531,"public boolean process(PossibleAction action){
  boolean result=true;
  DisplayBuffer.clear();
  guiHints.clearVisibilityHints();
  if (action instanceof NullAction && ((NullAction)action).getMode() == NullAction.START_GAME) {
    result=true;
  }
 else   if (action != null) {
    action.setActed();
    result=false;
    String actionPlayerName=action.getPlayerName();
    String currentPlayerName=getCurrentPlayer().getId();
    if (!actionPlayerName.equals(currentPlayerName)) {
      DisplayBuffer.add(LocalText.getText(""String_Node_Str"",actionPlayerName,currentPlayerName));
      return false;
    }
    if (!possibleActions.validate(action)) {
      DisplayBuffer.add(LocalText.getText(""String_Node_Str"",action.toString()));
      return false;
    }
    for (; ; ) {
      if (action instanceof GameAction) {
        GameAction gameAction=(GameAction)action;
        result=processGameActions(gameAction);
        if (result)         break;
      }
      result=processCorrectionActions(action) || getCurrentRound().process(action);
      break;
    }
    if (result && !(action instanceof GameAction) && action.hasActed()) {
      executedActions.add(action);
    }
  }
  possibleActions.clear();
  getCurrentRound().setPossibleActions();
  if (!isGameOver() && possibleActions.containsOnlyPass()) {
    result=process(possibleActions.getList().get(0));
  }
  if (!isGameOver())   setCorrectionActions();
  for (  PossibleAction pa : possibleActions.getList()) {
    log.debug(((Player)currentPlayer.value()).getId() + ""String_Node_Str"" + pa.toString());
  }
  return result;
}","public boolean process(PossibleAction action){
  boolean result=true;
  DisplayBuffer.clear();
  guiHints.clearVisibilityHints();
  if (action instanceof NullAction && ((NullAction)action).getMode() == NullAction.START_GAME) {
    result=true;
  }
 else   if (action != null) {
    action.setActed();
    result=false;
    String actionPlayerName=action.getPlayerName();
    String currentPlayerName=getCurrentPlayer().getId();
    if (!actionPlayerName.equals(currentPlayerName)) {
      DisplayBuffer.add(LocalText.getText(""String_Node_Str"",actionPlayerName,currentPlayerName));
      return false;
    }
    if (!possibleActions.validate(action)) {
      DisplayBuffer.add(LocalText.getText(""String_Node_Str"",action.toString()));
      return false;
    }
    for (; ; ) {
      if (action instanceof GameAction) {
        GameAction gameAction=(GameAction)action;
        result=processGameActions(gameAction);
        if (result)         break;
      }
      result=processCorrectionActions(action) || getCurrentRound().process(action);
      break;
    }
    if (result && !(action instanceof GameAction) && action.hasActed()) {
      executedActions.add(action);
    }
  }
  possibleActions.clear();
  getCurrentRound().setPossibleActions();
  if (!isGameOver() && possibleActions.containsOnlyPass()) {
    result=process(possibleActions.getList().get(0));
  }
  if (!isGameOver())   setCorrectionActions();
  ChangeStack changeStack=getRoot().getChangeStack();
  if (action != null) {
    if (result && !(action instanceof GameAction) && action.hasActed()) {
      if (changeStack.isOpen())       changeStack.close();
      recoverySave();
    }
 else {
      if (changeStack.isOpen())       changeStack.cancel();
    }
  }
  for (  PossibleAction pa : possibleActions.getList()) {
    log.debug(((Player)currentPlayer.value()).getId() + ""String_Node_Str"" + pa.toString());
  }
  return result;
}",0.9091950730449728
173532,"/** 
 * Used by Configure (via reflection) only
 */
public MapManager(Item parent,String id){
  super(parent,id);
}","/** 
 * Used by Configure (via reflection) only
 */
public MapManager(RailsRoot parent,String id){
  super(parent,id);
}",0.9531914893617022
173533,"public boolean layBaseToken(LayBaseToken action){
  String errMsg=null;
  int cost=0;
  SpecialTokenLay stl=null;
  boolean extra=false;
  MapHex hex=action.getChosenHex();
  int station=action.getChosenStation();
  String companyName=operatingCompany.value().getId();
  while (true) {
    if (getStep() != GameDef.OrStep.LAY_TOKEN && action.getType() != LayBaseToken.HOME_CITY && action.getType() != LayBaseToken.SPECIAL_PROPERTY) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (operatingCompany.value().getNumberOfFreeBaseTokens() == 0) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (!isTokenLayAllowed(operatingCompany.value(),hex,station)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!hex.hasTokenSlotsLeft(station)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (hex.hasTokenOfCompany(operatingCompany.value())) {
      errMsg=LocalText.getText(""String_Node_Str"",hex.getId(),companyName);
      break;
    }
    if (action != null) {
      List<MapHex> locations=action.getLocations();
      if (locations != null && locations.size() > 0 && !locations.contains(hex) && !locations.contains(null)) {
        errMsg=LocalText.getText(""String_Node_Str"",hex.getId(),action.getLocationNameString());
        break;
      }
      stl=action.getSpecialProperty();
      if (stl != null)       extra=stl.isExtra();
    }
    cost=operatingCompany.value().getBaseTokenLayCost(hex);
    if (stl != null && stl.isFree())     cost=0;
    if (cost > operatingCompany.value().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,Bank.format(operatingCompany.value().getCash()),Bank.format(cost));
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,hex.getId(),Bank.format(cost),errMsg));
    return false;
  }
  if (hex.layBaseToken(operatingCompany.value(),station)) {
    operatingCompany.value().layBaseToken(hex,cost);
    if (action.getType() == LayBaseToken.HOME_CITY) {
      return true;
    }
    if (cost > 0) {
      MoneyModel.cashMove(operatingCompany.value(),bank,cost);
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,hex.getId(),Bank.format(cost)));
    }
 else {
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,hex.getId()));
    }
    if (stl != null) {
      stl.setExercised();
      currentSpecialTokenLays.remove(action);
      log.debug(""String_Node_Str"" + (extra ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
    if (getStep() != GameDef.OrStep.LAY_TOKEN)     return true;
    if (!extra) {
      currentNormalTokenLays.clear();
      log.debug(""String_Node_Str"");
    }
    if (currentNormalTokenLays.isEmpty()) {
      log.debug(""String_Node_Str"");
    }
 else     if (operatingCompany.value().getNumberOfFreeBaseTokens() == 0) {
      log.debug(""String_Node_Str"");
      currentNormalTokenLays.clear();
    }
 else {
      log.debug(""String_Node_Str"");
    }
    setSpecialTokenLays();
    log.debug(""String_Node_Str"" + currentSpecialTokenLays.size() + ""String_Node_Str"");
    if (currentNormalTokenLays.isEmpty() && currentSpecialTokenLays.isEmpty()) {
      nextStep();
    }
  }
  return true;
}","public boolean layBaseToken(LayBaseToken action){
  String errMsg=null;
  int cost=0;
  SpecialTokenLay stl=null;
  boolean extra=false;
  MapHex hex=action.getChosenHex();
  int station=action.getChosenStation();
  String companyName=operatingCompany.value().getId();
  while (true) {
    if (getStep() != GameDef.OrStep.LAY_TOKEN && action.getType() != LayBaseToken.HOME_CITY && action.getType() != LayBaseToken.SPECIAL_PROPERTY) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (operatingCompany.value().getNumberOfFreeBaseTokens() == 0) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (!isTokenLayAllowed(operatingCompany.value(),hex,station)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!hex.hasTokenSlotsLeft(station)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (hex.hasTokenOfCompany(operatingCompany.value())) {
      errMsg=LocalText.getText(""String_Node_Str"",hex.getId(),companyName);
      break;
    }
    if (action != null) {
      List<MapHex> locations=action.getLocations();
      if (locations != null && locations.size() > 0 && !locations.contains(hex) && !locations.contains(null)) {
        errMsg=LocalText.getText(""String_Node_Str"",hex.getId(),action.getLocationNameString());
        break;
      }
      stl=action.getSpecialProperty();
      if (stl != null)       extra=stl.isExtra();
    }
    cost=operatingCompany.value().getBaseTokenLayCost(hex);
    if (stl != null && stl.isFree())     cost=0;
    if (cost > operatingCompany.value().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,Bank.format(operatingCompany.value().getCash()),Bank.format(cost));
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,hex.getId(),Bank.format(cost),errMsg));
    return false;
  }
  getRoot().getChangeStack().newChangeSet(action);
  if (hex.layBaseToken(operatingCompany.value(),station)) {
    operatingCompany.value().layBaseToken(hex,cost);
    if (action.getType() == LayBaseToken.HOME_CITY) {
      return true;
    }
    if (cost > 0) {
      MoneyModel.cashMove(operatingCompany.value(),bank,cost);
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,hex.getId(),Bank.format(cost)));
    }
 else {
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,hex.getId()));
    }
    if (stl != null) {
      stl.setExercised();
      currentSpecialTokenLays.remove(action);
      log.debug(""String_Node_Str"" + (extra ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
    if (getStep() != GameDef.OrStep.LAY_TOKEN)     return true;
    if (!extra) {
      currentNormalTokenLays.clear();
      log.debug(""String_Node_Str"");
    }
    if (currentNormalTokenLays.isEmpty()) {
      log.debug(""String_Node_Str"");
    }
 else     if (operatingCompany.value().getNumberOfFreeBaseTokens() == 0) {
      log.debug(""String_Node_Str"");
      currentNormalTokenLays.clear();
    }
 else {
      log.debug(""String_Node_Str"");
    }
    setSpecialTokenLays();
    log.debug(""String_Node_Str"" + currentSpecialTokenLays.size() + ""String_Node_Str"");
    if (currentNormalTokenLays.isEmpty() && currentSpecialTokenLays.isEmpty()) {
      nextStep();
    }
  }
  return true;
}",0.9923960041747428
173534,"public boolean layTile(LayTile action){
  String errMsg=null;
  int cost=0;
  SpecialTileLay stl=null;
  boolean extra=false;
  PublicCompany company=action.getCompany();
  String companyName=company.getId();
  Tile tile=action.getLaidTile();
  MapHex hex=action.getChosenHex();
  int orientation=action.getOrientation();
  while (true) {
    if (!companyName.equals(operatingCompany.value().getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,operatingCompany.value().getId());
      break;
    }
    if (getStep() != GameDef.OrStep.LAY_TRACK) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (tile == null)     break;
    if (!getCurrentPhase().isTileColourAllowed(tile.getColourName())) {
      errMsg=LocalText.getText(""String_Node_Str"",tile.getExternalId());
      break;
    }
    if (tile.countFreeTiles() == 0) {
      errMsg=LocalText.getText(""String_Node_Str"",tile.getExternalId());
      break;
    }
    if (action != null) {
      List<Tile> tiles=action.getTiles();
      if (tiles != null && !tiles.isEmpty() && !tiles.contains(tile)) {
        errMsg=LocalText.getText(""String_Node_Str"",tile.getExternalId(),hex.getId());
        break;
      }
      stl=action.getSpecialProperty();
      if (stl != null)       extra=stl.isExtra();
    }
    if (!extra && !validateNormalTileLay(tile)) {
      errMsg=LocalText.getText(""String_Node_Str"",tile.getColourName());
      break;
    }
    if (stl != null && stl.isFree()) {
      cost=0;
    }
 else {
      cost=hex.getTileCost();
    }
    if (cost < 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(cost));
      break;
    }
    if (cost % 10 != 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(cost));
      break;
    }
    if (cost > operatingCompany.value().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,Bank.format(operatingCompany.value().getCash()),Bank.format(cost));
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,tile.getExternalId(),hex.getId(),Bank.format(cost),errMsg));
    return false;
  }
  if (tile != null) {
    if (cost > 0)     MoneyModel.cashMove(operatingCompany.value(),bank,cost);
    operatingCompany.value().layTile(hex,tile,orientation,cost);
    if (cost == 0) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,tile.getExternalId(),hex.getId(),hex.getOrientationName(orientation)));
    }
 else {
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,tile.getExternalId(),hex.getId(),hex.getOrientationName(orientation),Bank.format(cost)));
    }
    hex.upgrade(action);
    if (stl != null) {
      stl.setExercised();
      log.debug(""String_Node_Str"" + (extra ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
    if (!extra) {
      log.debug(""String_Node_Str"");
      registerNormalTileLay(tile);
    }
  }
  if (tile == null || !areTileLaysPossible()) {
    nextStep();
  }
  return true;
}","public boolean layTile(LayTile action){
  String errMsg=null;
  int cost=0;
  SpecialTileLay stl=null;
  boolean extra=false;
  PublicCompany company=action.getCompany();
  String companyName=company.getId();
  Tile tile=action.getLaidTile();
  MapHex hex=action.getChosenHex();
  int orientation=action.getOrientation();
  while (true) {
    if (!companyName.equals(operatingCompany.value().getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,operatingCompany.value().getId());
      break;
    }
    if (getStep() != GameDef.OrStep.LAY_TRACK) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (tile == null)     break;
    if (!getCurrentPhase().isTileColourAllowed(tile.getColourName())) {
      errMsg=LocalText.getText(""String_Node_Str"",tile.getExternalId());
      break;
    }
    if (tile.countFreeTiles() == 0) {
      errMsg=LocalText.getText(""String_Node_Str"",tile.getExternalId());
      break;
    }
    if (action != null) {
      List<Tile> tiles=action.getTiles();
      if (tiles != null && !tiles.isEmpty() && !tiles.contains(tile)) {
        errMsg=LocalText.getText(""String_Node_Str"",tile.getExternalId(),hex.getId());
        break;
      }
      stl=action.getSpecialProperty();
      if (stl != null)       extra=stl.isExtra();
    }
    if (!extra && !validateNormalTileLay(tile)) {
      errMsg=LocalText.getText(""String_Node_Str"",tile.getColourName());
      break;
    }
    if (stl != null && stl.isFree()) {
      cost=0;
    }
 else {
      cost=hex.getTileCost();
    }
    if (cost < 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(cost));
      break;
    }
    if (cost % 10 != 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(cost));
      break;
    }
    if (cost > operatingCompany.value().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,Bank.format(operatingCompany.value().getCash()),Bank.format(cost));
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,tile.getExternalId(),hex.getId(),Bank.format(cost),errMsg));
    return false;
  }
  getRoot().getChangeStack().newChangeSet(action);
  if (tile != null) {
    if (cost > 0)     MoneyModel.cashMove(operatingCompany.value(),bank,cost);
    operatingCompany.value().layTile(hex,tile,orientation,cost);
    if (cost == 0) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,tile.getExternalId(),hex.getId(),hex.getOrientationName(orientation)));
    }
 else {
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,tile.getExternalId(),hex.getId(),hex.getOrientationName(orientation),Bank.format(cost)));
    }
    hex.upgrade(action);
    if (stl != null) {
      stl.setExercised();
      log.debug(""String_Node_Str"" + (extra ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
    if (!extra) {
      log.debug(""String_Node_Str"");
      registerNormalTileLay(tile);
    }
  }
  if (tile == null || !areTileLaysPossible()) {
    nextStep();
  }
  return true;
}",0.9916978674914536
173535,"public boolean layBonusToken(LayBonusToken action){
  String errMsg=null;
  int cost=0;
  SpecialTokenLay stl=null;
  boolean extra=false;
  MapHex hex=action.getChosenHex();
  BonusToken token=action.getToken();
  while (true) {
    MapHex location=action.getChosenHex();
    if (location != hex) {
      errMsg=LocalText.getText(""String_Node_Str"",hex.getId(),location.getId());
      break;
    }
    stl=action.getSpecialProperty();
    if (stl != null)     extra=stl.isExtra();
    cost=0;
    if (stl != null && stl.isFree())     cost=0;
    if (cost > operatingCompany.value().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",operatingCompany.value().getId());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",token.getId(),hex.getId(),Bank.format(cost),errMsg));
    return false;
  }
  if (hex.layBonusToken(token,gameManager.getPhaseManager())) {
    operatingCompany.value().addBonus(new Bonus(operatingCompany.value(),token.getId(),token.getValue(),Collections.singletonList(hex)));
    token.setUser(operatingCompany.value());
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),token.getId(),Bank.format(token.getValue()),hex.getId()));
    if (stl != null) {
      stl.setExercised();
      currentSpecialTokenLays.remove(action);
      log.debug(""String_Node_Str"" + (extra ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
  }
  return true;
}","public boolean layBonusToken(LayBonusToken action){
  String errMsg=null;
  int cost=0;
  SpecialTokenLay stl=null;
  boolean extra=false;
  MapHex hex=action.getChosenHex();
  BonusToken token=action.getToken();
  while (true) {
    MapHex location=action.getChosenHex();
    if (location != hex) {
      errMsg=LocalText.getText(""String_Node_Str"",hex.getId(),location.getId());
      break;
    }
    stl=action.getSpecialProperty();
    if (stl != null)     extra=stl.isExtra();
    cost=0;
    if (stl != null && stl.isFree())     cost=0;
    if (cost > operatingCompany.value().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",operatingCompany.value().getId());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",token.getId(),hex.getId(),Bank.format(cost),errMsg));
    return false;
  }
  getRoot().getChangeStack().newChangeSet(action);
  if (hex.layBonusToken(token,gameManager.getPhaseManager())) {
    operatingCompany.value().addBonus(new Bonus(operatingCompany.value(),token.getId(),token.getValue(),Collections.singletonList(hex)));
    token.setUser(operatingCompany.value());
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),token.getId(),Bank.format(token.getValue()),hex.getId()));
    if (stl != null) {
      stl.setExercised();
      currentSpecialTokenLays.remove(action);
      log.debug(""String_Node_Str"" + (extra ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
  }
  return true;
}",0.9832292009207496
173536,"public boolean buyTrain(BuyTrain action){
  Train train=action.getTrain();
  PublicCompany company=action.getCompany();
  String companyName=company.getId();
  Train exchangedTrain=action.getExchangedTrain();
  SpecialTrainBuy stb=null;
  String errMsg=null;
  int presidentCash=action.getPresidentCashToAdd();
  boolean presidentMustSellShares=false;
  int price=action.getPricePaid();
  int actualPresidentCash=0;
  int cashToBeRaisedByPresident=0;
  Player currentPlayer=operatingCompany.value().getPresident();
  while (true) {
    if (getStep() != GameDef.OrStep.BUY_TRAIN) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (train == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (price < 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(price));
      break;
    }
    int fixedPrice=action.getFixedCost();
    if (fixedPrice != 0 && fixedPrice != price) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(price),Bank.format(fixedPrice));
    }
    int trainLimit=operatingCompany.value().getCurrentTrainLimit();
    if (!canBuyTrainNow() && !action.isForExchange()) {
      errMsg=LocalText.getText(""String_Node_Str"",String.valueOf(trainLimit));
      break;
    }
    if (action.mustPresidentAddCash()) {
      presidentCash=action.getPresidentCashToAdd();
      if (currentPlayer.getCashValue() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCashValue();
      }
    }
 else     if (action.mayPresidentAddCash()) {
      presidentCash=price - operatingCompany.value().getCash();
      if (presidentCash > action.getPresidentCashToAdd()) {
        errMsg=LocalText.getText(""String_Node_Str"",Bank.format(action.getPresidentCashToAdd()));
        break;
      }
 else       if (currentPlayer.getCashValue() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCashValue();
      }
    }
 else {
      if (price > operatingCompany.value().getCash()) {
        errMsg=LocalText.getText(""String_Node_Str"",companyName,Bank.format(operatingCompany.value().getCash()),Bank.format(price));
        break;
      }
    }
    if (action.isForExchange()) {
      if (exchangedTrain == null) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
 else       if (operatingCompany.value().getPortfolioModel().getTrainOfType(exchangedTrain.getCertType()) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),exchangedTrain.getId());
        break;
      }
    }
    stb=action.getSpecialProperty();
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getId(),Bank.format(price),errMsg));
    return false;
  }
  Phase previousPhase=getCurrentPhase();
  if (presidentMustSellShares) {
    savedAction=action;
    gameManager.startShareSellingRound(operatingCompany.value().getPresident(),cashToBeRaisedByPresident,operatingCompany.value(),true);
    return true;
  }
  if (actualPresidentCash > 0) {
    MoneyModel.cashMove(currentPlayer,operatingCompany.value(),presidentCash);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),currentPlayer.getId(),Bank.format(actualPresidentCash)));
  }
  Owner oldOwner=train.getOwner();
  if (exchangedTrain != null) {
    Train oldTrain=operatingCompany.value().getPortfolioModel().getTrainOfType(exchangedTrain.getCertType());
    (train.isObsolete() ? scrapHeap : pool).addTrain(oldTrain);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,exchangedTrain.getId(),train.getId(),oldOwner.getId(),Bank.format(price)));
  }
 else   if (stb == null) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getId(),oldOwner.getId(),Bank.format(price)));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getId(),oldOwner.getId(),Bank.format(price),stb.getOriginalCompany().getId()));
  }
  train.setType(action.getType());
  operatingCompany.value().buyTrain(train,price);
  if (oldOwner == ipo.getTrainsModel()) {
    train.getCertType().addToBoughtFromIPO();
    trainManager.setAnyTrainBought(true);
    if (train.getCertType().hasInfiniteQuantity()) {
      ipo.addTrain(trainManager.cloneTrain(train.getCertType()));
    }
  }
  if (oldOwner instanceof Bank) {
    trainsBoughtThisTurn.add(train.getCertType());
  }
  if (stb != null) {
    stb.setExercised();
    log.debug(""String_Node_Str"");
  }
  trainManager.checkTrainAvailability(train,oldOwner);
  if (getCurrentPhase() != previousPhase && checkForExcessTrains()) {
    stepObject.set(GameDef.OrStep.DISCARD_TRAINS);
  }
  if (trainManager.hasPhaseChanged())   newPhaseChecks();
  return true;
}","public boolean buyTrain(BuyTrain action){
  Train train=action.getTrain();
  PublicCompany company=action.getCompany();
  String companyName=company.getId();
  Train exchangedTrain=action.getExchangedTrain();
  SpecialTrainBuy stb=null;
  String errMsg=null;
  int presidentCash=action.getPresidentCashToAdd();
  boolean presidentMustSellShares=false;
  int price=action.getPricePaid();
  int actualPresidentCash=0;
  int cashToBeRaisedByPresident=0;
  Player currentPlayer=operatingCompany.value().getPresident();
  while (true) {
    if (getStep() != GameDef.OrStep.BUY_TRAIN) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (train == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (price < 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(price));
      break;
    }
    int fixedPrice=action.getFixedCost();
    if (fixedPrice != 0 && fixedPrice != price) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(price),Bank.format(fixedPrice));
    }
    int trainLimit=operatingCompany.value().getCurrentTrainLimit();
    if (!canBuyTrainNow() && !action.isForExchange()) {
      errMsg=LocalText.getText(""String_Node_Str"",String.valueOf(trainLimit));
      break;
    }
    if (action.mustPresidentAddCash()) {
      presidentCash=action.getPresidentCashToAdd();
      if (currentPlayer.getCashValue() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCashValue();
      }
    }
 else     if (action.mayPresidentAddCash()) {
      presidentCash=price - operatingCompany.value().getCash();
      if (presidentCash > action.getPresidentCashToAdd()) {
        errMsg=LocalText.getText(""String_Node_Str"",Bank.format(action.getPresidentCashToAdd()));
        break;
      }
 else       if (currentPlayer.getCashValue() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCashValue();
      }
    }
 else {
      if (price > operatingCompany.value().getCash()) {
        errMsg=LocalText.getText(""String_Node_Str"",companyName,Bank.format(operatingCompany.value().getCash()),Bank.format(price));
        break;
      }
    }
    if (action.isForExchange()) {
      if (exchangedTrain == null) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
 else       if (operatingCompany.value().getPortfolioModel().getTrainOfType(exchangedTrain.getCertType()) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),exchangedTrain.getId());
        break;
      }
    }
    stb=action.getSpecialProperty();
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getId(),Bank.format(price),errMsg));
    return false;
  }
  getRoot().getChangeStack().newChangeSet(action);
  Phase previousPhase=getCurrentPhase();
  if (presidentMustSellShares) {
    savedAction=action;
    gameManager.startShareSellingRound(operatingCompany.value().getPresident(),cashToBeRaisedByPresident,operatingCompany.value(),true);
    return true;
  }
  if (actualPresidentCash > 0) {
    MoneyModel.cashMove(currentPlayer,operatingCompany.value(),presidentCash);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),currentPlayer.getId(),Bank.format(actualPresidentCash)));
  }
  Owner oldOwner=train.getOwner();
  if (exchangedTrain != null) {
    Train oldTrain=operatingCompany.value().getPortfolioModel().getTrainOfType(exchangedTrain.getCertType());
    (train.isObsolete() ? scrapHeap : pool).addTrain(oldTrain);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,exchangedTrain.getId(),train.getId(),oldOwner.getId(),Bank.format(price)));
  }
 else   if (stb == null) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getId(),oldOwner.getId(),Bank.format(price)));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getId(),oldOwner.getId(),Bank.format(price),stb.getOriginalCompany().getId()));
  }
  train.setType(action.getType());
  operatingCompany.value().buyTrain(train,price);
  if (oldOwner == ipo.getTrainsModel()) {
    train.getCertType().addToBoughtFromIPO();
    trainManager.setAnyTrainBought(true);
    if (train.getCertType().hasInfiniteQuantity()) {
      ipo.addTrain(trainManager.cloneTrain(train.getCertType()));
    }
  }
  if (oldOwner instanceof Bank) {
    trainsBoughtThisTurn.add(train.getCertType());
  }
  if (stb != null) {
    stb.setExercised();
    log.debug(""String_Node_Str"");
  }
  trainManager.checkTrainAvailability(train,oldOwner);
  if (getCurrentPhase() != previousPhase && checkForExcessTrains()) {
    stepObject.set(GameDef.OrStep.DISCARD_TRAINS);
  }
  if (trainManager.hasPhaseChanged())   newPhaseChecks();
  return true;
}",0.9949208246190618
173537,"/** 
 * The current Company is done operating.
 * @param company Name of the company that finished operating.
 * @return False if an error is found.
 */
public boolean done(){
  if (operatingCompany.value().getPortfolioModel().getNumberOfTrains() == 0 && operatingCompany.value().mustOwnATrain()) {
  }
  nextStep();
  if (getStep() == GameDef.OrStep.FINAL) {
    finishTurn();
  }
  return true;
}","/** 
 * The current Company is done operating.
 * @param action TODO
 * @param company Name of the company that finished operating.
 * @return False if an error is found.
 */
public boolean done(NullAction action){
  if (operatingCompany.value().getPortfolioModel().getNumberOfTrains() == 0 && operatingCompany.value().mustOwnATrain()) {
  }
  getRoot().getChangeStack().newChangeSet(action);
  nextStep();
  if (getStep() == GameDef.OrStep.FINAL) {
    finishTurn();
  }
  return true;
}",0.8984198645598194
173538,"protected boolean buyRight(UseSpecialProperty action){
  String errMsg=null;
  SpecialProperty sp=action.getSpecialProperty();
  if (!(sp instanceof SpecialRight)) {
    errMsg=""String_Node_Str"" + sp.toString();
  }
  SpecialRight right=(SpecialRight)sp;
  String rightName=right.getId();
  String rightValue=right.getValue();
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",action.getCompanyName(),rightName,Bank.format(right.getCost()),errMsg));
    return false;
  }
  operatingCompany.value().setRight(rightName,rightValue);
  MoneyModel.cashMove(operatingCompany.value(),bank,right.getCost());
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),rightName,Bank.format(right.getCost())));
  sp.setExercised();
  return true;
}","protected boolean buyRight(UseSpecialProperty action){
  String errMsg=null;
  SpecialProperty sp=action.getSpecialProperty();
  if (!(sp instanceof SpecialRight)) {
    errMsg=""String_Node_Str"" + sp.toString();
  }
  SpecialRight right=(SpecialRight)sp;
  String rightName=right.getId();
  String rightValue=right.getValue();
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",action.getCompanyName(),rightName,Bank.format(right.getCost()),errMsg));
    return false;
  }
  getRoot().getChangeStack().newChangeSet(action);
  operatingCompany.value().setRight(rightName,rightValue);
  MoneyModel.cashMove(operatingCompany.value(),bank,right.getCost());
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),rightName,Bank.format(right.getCost())));
  sp.setExercised();
  return true;
}",0.9691096305269532
173539,"public boolean setRevenueAndDividend(SetDividend action){
  String errMsg=validateSetRevenueAndDividend(action);
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",Bank.format(action.getActualRevenue()),action.getCompanyName(),errMsg));
    return false;
  }
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",action.getCompanyName(),Bank.format(action.getActualRevenue())));
  int remainingAmount=checkForDeductions(action);
  if (remainingAmount < 0) {
    return true;
  }
  executeSetRevenueAndDividend(action);
  return true;
}","public boolean setRevenueAndDividend(SetDividend action){
  String errMsg=validateSetRevenueAndDividend(action);
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",Bank.format(action.getActualRevenue()),action.getCompanyName(),errMsg));
    return false;
  }
  getRoot().getChangeStack().newChangeSet(action);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",action.getCompanyName(),Bank.format(action.getActualRevenue())));
  int remainingAmount=checkForDeductions(action);
  if (remainingAmount < 0) {
    return true;
  }
  executeSetRevenueAndDividend(action);
  return true;
}",0.9569620253164556
173540,"protected boolean executeOperatingCost(OperatingCost action){
  String companyName=action.getCompanyName();
  OperatingCost.OCType typeOC=action.getOCType();
  int amount=action.getAmount();
  String errMsg=null;
  while (true) {
    if (!companyName.equals(operatingCompany.value().getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,operatingCompany.value().getId());
      break;
    }
    if ((amount + operatingCompany.value().getCash()) < 0) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,Bank.format(operatingCompany.value().getCash()),Bank.format(amount));
      break;
    }
    if (typeOC == OperatingCost.OCType.LAY_BASE_TOKEN && operatingCompany.value().getNumberOfFreeBaseTokens() == 0) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,errMsg));
    return false;
  }
  if (amount > 0) {
    MoneyModel.cashMove(operatingCompany.value(),bank,amount);
  }
 else   if (amount > 0) {
    MoneyModel.cashMove(bank,operatingCompany.value(),-amount);
  }
  if (typeOC == OperatingCost.OCType.LAY_TILE) {
    operatingCompany.value().layTilenNoMapMode(amount);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),Bank.format(amount)));
  }
  if (typeOC == OperatingCost.OCType.LAY_BASE_TOKEN) {
    BaseToken token=operatingCompany.value().getFreeToken();
    if (token == null) {
      log.error(""String_Node_Str"" + operatingCompany.value().getId() + ""String_Node_Str"");
      return false;
    }
 else {
    }
    operatingCompany.value().layBaseTokennNoMapMode(amount);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),Bank.format(amount)));
  }
  return true;
}","protected boolean executeOperatingCost(OperatingCost action){
  String companyName=action.getCompanyName();
  OperatingCost.OCType typeOC=action.getOCType();
  int amount=action.getAmount();
  String errMsg=null;
  while (true) {
    if (!companyName.equals(operatingCompany.value().getId())) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,operatingCompany.value().getId());
      break;
    }
    if ((amount + operatingCompany.value().getCash()) < 0) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,Bank.format(operatingCompany.value().getCash()),Bank.format(amount));
      break;
    }
    if (typeOC == OperatingCost.OCType.LAY_BASE_TOKEN && operatingCompany.value().getNumberOfFreeBaseTokens() == 0) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,errMsg));
    return false;
  }
  getRoot().getChangeStack().newChangeSet(action);
  if (amount > 0) {
    MoneyModel.cashMove(operatingCompany.value(),bank,amount);
  }
 else   if (amount > 0) {
    MoneyModel.cashMove(bank,operatingCompany.value(),-amount);
  }
  if (typeOC == OperatingCost.OCType.LAY_TILE) {
    operatingCompany.value().layTilenNoMapMode(amount);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),Bank.format(amount)));
  }
  if (typeOC == OperatingCost.OCType.LAY_BASE_TOKEN) {
    BaseToken token=operatingCompany.value().getFreeToken();
    if (token == null) {
      log.error(""String_Node_Str"" + operatingCompany.value().getId() + ""String_Node_Str"");
      return false;
    }
 else {
    }
    operatingCompany.value().layBaseTokennNoMapMode(amount);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),Bank.format(amount)));
  }
  return true;
}",0.9862644761648264
173541,"protected boolean repayLoans(RepayLoans action){
  String errMsg=validateRepayLoans(action);
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",action.getCompanyName(),action.getNumberRepaid(),Bank.format(action.getPrice()),errMsg));
    return false;
  }
  int repayment=action.getNumberRepaid() * operatingCompany.value().getValuePerLoan();
  if (repayment > 0 && repayment > operatingCompany.value().getCash()) {
    int remainder=repayment - operatingCompany.value().getCash();
    Player president=operatingCompany.value().getPresident();
    int presCash=president.getCashValue();
    if (remainder > presCash) {
      int cashToBeRaisedByPresident=remainder - presCash;
      log.info(""String_Node_Str"" + remainder + ""String_Node_Str"");
      log.info(""String_Node_Str"" + presCash + ""String_Node_Str""+ cashToBeRaisedByPresident+ ""String_Node_Str"");
      savedAction=action;
      gameManager.startShareSellingRound(operatingCompany.value().getPresident(),cashToBeRaisedByPresident,operatingCompany.value(),false);
      return true;
    }
  }
  if (repayment > 0)   executeRepayLoans(action);
  return true;
}","protected boolean repayLoans(RepayLoans action){
  String errMsg=validateRepayLoans(action);
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",action.getCompanyName(),action.getNumberRepaid(),Bank.format(action.getPrice()),errMsg));
    return false;
  }
  int repayment=action.getNumberRepaid() * operatingCompany.value().getValuePerLoan();
  if (repayment > 0 && repayment > operatingCompany.value().getCash()) {
    int remainder=repayment - operatingCompany.value().getCash();
    Player president=operatingCompany.value().getPresident();
    int presCash=president.getCashValue();
    if (remainder > presCash) {
      int cashToBeRaisedByPresident=remainder - presCash;
      log.info(""String_Node_Str"" + remainder + ""String_Node_Str"");
      log.info(""String_Node_Str"" + presCash + ""String_Node_Str""+ cashToBeRaisedByPresident+ ""String_Node_Str"");
      savedAction=action;
      getRoot().getChangeStack().newChangeSet(action);
      gameManager.startShareSellingRound(operatingCompany.value().getPresident(),cashToBeRaisedByPresident,operatingCompany.value(),false);
      return true;
    }
  }
  getRoot().getChangeStack().newChangeSet(action);
  if (repayment > 0)   executeRepayLoans(action);
  return true;
}",0.9558701082431308
173542,"public boolean buyPrivate(BuyPrivate action){
  String errMsg=null;
  PublicCompany publicCompany=action.getCompany();
  String publicCompanyName=publicCompany.getId();
  PrivateCompany privateCompany=action.getPrivateCompany();
  String privateCompanyName=privateCompany.getId();
  int price=action.getPrice();
  Owner owner=null;
  Player player=null;
  int upperPrice;
  int lowerPrice;
  while (true) {
    if ((privateCompany=companyManager.getPrivateCompany(privateCompanyName)) == null) {
      errMsg=LocalText.getText(""String_Node_Str"",privateCompanyName);
      break;
    }
    if (privateCompany.isClosed()) {
      errMsg=LocalText.getText(""String_Node_Str"",privateCompanyName);
      break;
    }
    owner=privateCompany.getOwner();
    if (!(owner instanceof Player)) {
      errMsg=LocalText.getText(""String_Node_Str"",privateCompanyName);
      break;
    }
    player=(Player)owner;
    upperPrice=privateCompany.getUpperPrice();
    lowerPrice=privateCompany.getLowerPrice();
    if (!isPrivateSellingAllowed()) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (lowerPrice != PrivateCompany.NO_PRICE_LIMIT && price < lowerPrice) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(price),Bank.format(lowerPrice),privateCompanyName);
      break;
    }
    if (upperPrice != PrivateCompany.NO_PRICE_LIMIT && price > upperPrice) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(price),Bank.format(lowerPrice),privateCompanyName);
      break;
    }
    if (price > operatingCompany.value().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",publicCompanyName,Bank.format(operatingCompany.value().getCash()),Bank.format(price));
      break;
    }
    break;
  }
  if (errMsg != null) {
    if (owner != null) {
      DisplayBuffer.add(LocalText.getText(""String_Node_Str"",publicCompanyName,privateCompanyName,owner.getId(),Bank.format(price),errMsg));
    }
 else {
      DisplayBuffer.add(LocalText.getText(""String_Node_Str"",publicCompanyName,privateCompanyName,Bank.format(price),errMsg));
    }
    return false;
  }
  operatingCompany.value().buyPrivate(privateCompany,player,price);
  return true;
}","public boolean buyPrivate(BuyPrivate action){
  String errMsg=null;
  PublicCompany publicCompany=action.getCompany();
  String publicCompanyName=publicCompany.getId();
  PrivateCompany privateCompany=action.getPrivateCompany();
  String privateCompanyName=privateCompany.getId();
  int price=action.getPrice();
  Owner owner=null;
  Player player=null;
  int upperPrice;
  int lowerPrice;
  while (true) {
    if ((privateCompany=companyManager.getPrivateCompany(privateCompanyName)) == null) {
      errMsg=LocalText.getText(""String_Node_Str"",privateCompanyName);
      break;
    }
    if (privateCompany.isClosed()) {
      errMsg=LocalText.getText(""String_Node_Str"",privateCompanyName);
      break;
    }
    owner=privateCompany.getOwner();
    if (!(owner instanceof Player)) {
      errMsg=LocalText.getText(""String_Node_Str"",privateCompanyName);
      break;
    }
    player=(Player)owner;
    upperPrice=privateCompany.getUpperPrice();
    lowerPrice=privateCompany.getLowerPrice();
    if (!isPrivateSellingAllowed()) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (lowerPrice != PrivateCompany.NO_PRICE_LIMIT && price < lowerPrice) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(price),Bank.format(lowerPrice),privateCompanyName);
      break;
    }
    if (upperPrice != PrivateCompany.NO_PRICE_LIMIT && price > upperPrice) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(price),Bank.format(lowerPrice),privateCompanyName);
      break;
    }
    if (price > operatingCompany.value().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",publicCompanyName,Bank.format(operatingCompany.value().getCash()),Bank.format(price));
      break;
    }
    break;
  }
  if (errMsg != null) {
    if (owner != null) {
      DisplayBuffer.add(LocalText.getText(""String_Node_Str"",publicCompanyName,privateCompanyName,owner.getId(),Bank.format(price),errMsg));
    }
 else {
      DisplayBuffer.add(LocalText.getText(""String_Node_Str"",publicCompanyName,privateCompanyName,Bank.format(price),errMsg));
    }
    return false;
  }
  getRoot().getChangeStack().newChangeSet(action);
  operatingCompany.value().buyPrivate(privateCompany,player,price);
  return true;
}",0.9884693646846032
173543,"public boolean buyBonusToken(BuyBonusToken action){
  String errMsg=null;
  int cost;
  SellBonusToken sbt=null;
  CashOwner seller=null;
  while (true) {
    sbt=action.getSpecialProperty();
    cost=sbt.getPrice();
    seller=(CashOwner)sbt.getSeller();
    if (cost > operatingCompany.value().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),Bank.format(operatingCompany.value().getCash()),Bank.format(cost));
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),sbt.getId(),seller.getId(),Bank.format(cost),errMsg));
    return false;
  }
  MoneyModel.cashMove(operatingCompany.value(),seller,cost);
  operatingCompany.value().addBonus(new Bonus(operatingCompany.value(),sbt.getId(),sbt.getValue(),sbt.getLocations()));
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),sbt.getId(),Bank.format(sbt.getValue()),seller.getId(),Bank.format(sbt.getPrice())));
  sbt.setExercised();
  return true;
}","public boolean buyBonusToken(BuyBonusToken action){
  String errMsg=null;
  int cost;
  SellBonusToken sbt=null;
  CashOwner seller=null;
  while (true) {
    sbt=action.getSpecialProperty();
    cost=sbt.getPrice();
    seller=(CashOwner)sbt.getSeller();
    if (cost > operatingCompany.value().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),Bank.format(operatingCompany.value().getCash()),Bank.format(cost));
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),sbt.getId(),seller.getId(),Bank.format(cost),errMsg));
    return false;
  }
  getRoot().getChangeStack().newChangeSet(action);
  MoneyModel.cashMove(operatingCompany.value(),seller,cost);
  operatingCompany.value().addBonus(new Bonus(operatingCompany.value(),sbt.getId(),sbt.getValue(),sbt.getLocations()));
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),sbt.getId(),Bank.format(sbt.getValue()),seller.getId(),Bank.format(sbt.getPrice())));
  sbt.setExercised();
  return true;
}",0.976891708201178
173544,"protected boolean executeClosePrivate(ClosePrivate action){
  PrivateCompany priv=action.getPrivateCompany();
  log.debug(""String_Node_Str"" + priv.getId());
  String errMsg=null;
  if (priv.isClosed())   errMsg=LocalText.getText(""String_Node_Str"",priv.getId());
  if (errMsg != null) {
    DisplayBuffer.add(errMsg);
    return false;
  }
  priv.setClosed();
  return true;
}","protected boolean executeClosePrivate(ClosePrivate action){
  PrivateCompany priv=action.getPrivateCompany();
  log.debug(""String_Node_Str"" + priv.getId());
  String errMsg=null;
  if (priv.isClosed())   errMsg=LocalText.getText(""String_Node_Str"",priv.getId());
  if (errMsg != null) {
    DisplayBuffer.add(errMsg);
    return false;
  }
  getRoot().getChangeStack().newChangeSet(action);
  priv.setClosed();
  return true;
}",0.9363295880149812
173545,"@Override public boolean process(PossibleAction action){
  boolean result=false;
  doneAllowed=false;
  if (action instanceof PossibleORAction && !(action instanceof DiscardTrain)) {
    PublicCompany company=((PossibleORAction)action).getCompany();
    if (company != operatingCompany.value()) {
      DisplayBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),operatingCompany.value().getId()));
      return false;
    }
  }
  selectedAction=action;
  if (selectedAction instanceof LayTile) {
    result=layTile((LayTile)selectedAction);
  }
 else   if (selectedAction instanceof LayBaseToken) {
    result=layBaseToken((LayBaseToken)selectedAction);
  }
 else   if (selectedAction instanceof LayBonusToken) {
    result=layBonusToken((LayBonusToken)selectedAction);
  }
 else   if (selectedAction instanceof BuyBonusToken) {
    result=buyBonusToken((BuyBonusToken)selectedAction);
  }
 else   if (selectedAction instanceof OperatingCost) {
    result=executeOperatingCost((OperatingCost)selectedAction);
  }
 else   if (selectedAction instanceof SetDividend) {
    result=setRevenueAndDividend((SetDividend)selectedAction);
  }
 else   if (selectedAction instanceof BuyTrain) {
    result=buyTrain((BuyTrain)selectedAction);
  }
 else   if (selectedAction instanceof DiscardTrain) {
    result=discardTrain((DiscardTrain)selectedAction);
  }
 else   if (selectedAction instanceof BuyPrivate) {
    result=buyPrivate((BuyPrivate)selectedAction);
  }
 else   if (selectedAction instanceof ReachDestinations) {
    result=reachDestinations((ReachDestinations)selectedAction);
  }
 else   if (selectedAction instanceof TakeLoans) {
    result=takeLoans((TakeLoans)selectedAction);
  }
 else   if (selectedAction instanceof RepayLoans) {
    result=repayLoans((RepayLoans)selectedAction);
  }
 else   if (selectedAction instanceof ExchangeTokens) {
    result=exchangeTokens((ExchangeTokens)selectedAction,false);
  }
 else   if (selectedAction instanceof ClosePrivate) {
    result=executeClosePrivate((ClosePrivate)selectedAction);
  }
 else   if (selectedAction instanceof UseSpecialProperty && ((UseSpecialProperty)selectedAction).getSpecialProperty() instanceof SpecialRight) {
    result=buyRight((UseSpecialProperty)selectedAction);
  }
 else   if (selectedAction instanceof NullAction) {
    NullAction nullAction=(NullAction)action;
switch (nullAction.getMode()) {
case NullAction.DONE:
case NullAction.PASS:
      result=done();
    break;
case NullAction.SKIP:
  skip();
result=true;
break;
}
}
 else if (processGameSpecificAction(action)) {
result=true;
}
 else {
DisplayBuffer.add(LocalText.getText(""String_Node_Str"",selectedAction.toString()));
return false;
}
return result;
}","@Override public boolean process(PossibleAction action){
  boolean result=false;
  doneAllowed=false;
  if (action instanceof PossibleORAction && !(action instanceof DiscardTrain)) {
    PublicCompany company=((PossibleORAction)action).getCompany();
    if (company != operatingCompany.value()) {
      DisplayBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),operatingCompany.value().getId()));
      return false;
    }
  }
  selectedAction=action;
  if (selectedAction instanceof LayTile) {
    result=layTile((LayTile)selectedAction);
  }
 else   if (selectedAction instanceof LayBaseToken) {
    result=layBaseToken((LayBaseToken)selectedAction);
  }
 else   if (selectedAction instanceof LayBonusToken) {
    result=layBonusToken((LayBonusToken)selectedAction);
  }
 else   if (selectedAction instanceof BuyBonusToken) {
    result=buyBonusToken((BuyBonusToken)selectedAction);
  }
 else   if (selectedAction instanceof OperatingCost) {
    result=executeOperatingCost((OperatingCost)selectedAction);
  }
 else   if (selectedAction instanceof SetDividend) {
    result=setRevenueAndDividend((SetDividend)selectedAction);
  }
 else   if (selectedAction instanceof BuyTrain) {
    result=buyTrain((BuyTrain)selectedAction);
  }
 else   if (selectedAction instanceof DiscardTrain) {
    result=discardTrain((DiscardTrain)selectedAction);
  }
 else   if (selectedAction instanceof BuyPrivate) {
    result=buyPrivate((BuyPrivate)selectedAction);
  }
 else   if (selectedAction instanceof ReachDestinations) {
    result=reachDestinations((ReachDestinations)selectedAction);
  }
 else   if (selectedAction instanceof TakeLoans) {
    result=takeLoans((TakeLoans)selectedAction);
  }
 else   if (selectedAction instanceof RepayLoans) {
    result=repayLoans((RepayLoans)selectedAction);
  }
 else   if (selectedAction instanceof ExchangeTokens) {
    result=exchangeTokens((ExchangeTokens)selectedAction,false);
  }
 else   if (selectedAction instanceof ClosePrivate) {
    result=executeClosePrivate((ClosePrivate)selectedAction);
  }
 else   if (selectedAction instanceof UseSpecialProperty && ((UseSpecialProperty)selectedAction).getSpecialProperty() instanceof SpecialRight) {
    result=buyRight((UseSpecialProperty)selectedAction);
  }
 else   if (selectedAction instanceof NullAction) {
    NullAction nullAction=(NullAction)action;
switch (nullAction.getMode()) {
case NullAction.DONE:
case NullAction.PASS:
      result=done(nullAction);
    break;
case NullAction.SKIP:
  skip();
result=true;
break;
}
}
 else if (processGameSpecificAction(action)) {
result=true;
}
 else {
DisplayBuffer.add(LocalText.getText(""String_Node_Str"",selectedAction.toString()));
return false;
}
return result;
}",0.9981529368304396
173546,"public boolean discardTrain(DiscardTrain action){
  Train train=action.getDiscardedTrain();
  PublicCompany company=action.getCompany();
  String companyName=company.getId();
  String errMsg=null;
  while (true) {
    if (getStep() != GameDef.OrStep.BUY_TRAIN && getStep() != GameDef.OrStep.DISCARD_TRAINS) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (train == null && action.isForced()) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!company.getPortfolioModel().getTrainList().contains(train)) {
      errMsg=LocalText.getText(""String_Node_Str"",company.getId(),train.getId());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,(train != null ? train.getId() : ""String_Node_Str""),errMsg));
    return false;
  }
  if (train.getCertType().getPotentialTrainTypes().size() > 1) {
    train.setType(null);
  }
  (train.isObsolete() ? scrapHeap : pool).addTrain(train);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getId()));
  if (!checkForExcessTrains()) {
    setCurrentPlayer(operatingCompany.value().getPresident());
    stepObject.set(GameDef.OrStep.BUY_TRAIN);
  }
  return true;
}","public boolean discardTrain(DiscardTrain action){
  Train train=action.getDiscardedTrain();
  PublicCompany company=action.getCompany();
  String companyName=company.getId();
  String errMsg=null;
  while (true) {
    if (getStep() != GameDef.OrStep.BUY_TRAIN && getStep() != GameDef.OrStep.DISCARD_TRAINS) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (train == null && action.isForced()) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!company.getPortfolioModel().getTrainList().contains(train)) {
      errMsg=LocalText.getText(""String_Node_Str"",company.getId(),train.getId());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,(train != null ? train.getId() : ""String_Node_Str""),errMsg));
    return false;
  }
  getRoot().getChangeStack().newChangeSet(action);
  if (train.getCertType().getPotentialTrainTypes().size() > 1) {
    train.setType(null);
  }
  (train.isObsolete() ? scrapHeap : pool).addTrain(train);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getId()));
  if (!checkForExcessTrains()) {
    setCurrentPlayer(operatingCompany.value().getPresident());
    stepObject.set(GameDef.OrStep.BUY_TRAIN);
  }
  return true;
}",0.9801324503311258
173547,"protected boolean takeLoans(TakeLoans action){
  String errMsg=validateTakeLoans(action);
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",action.getCompanyName(),action.getNumberTaken(),Bank.format(action.getPrice()),errMsg));
    return false;
  }
  executeTakeLoans(action);
  return true;
}","protected boolean takeLoans(TakeLoans action){
  String errMsg=validateTakeLoans(action);
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",action.getCompanyName(),action.getNumberTaken(),Bank.format(action.getPrice()),errMsg));
    return false;
  }
  getRoot().getChangeStack().newChangeSet(action);
  executeTakeLoans(action);
  return true;
}",0.9276595744680852
173548,"public void setClosed(){
  closed.set(true);
  PortfolioOwner shareDestination;
  if (canBeRestarted) {
    if (certsAreInitiallyAvailable) {
      shareDestination=bank.getIpo();
    }
 else {
      shareDestination=bank.getUnavailable();
    }
    reinitialise();
  }
 else {
    shareDestination=bank.getScrapHeap();
    inGameState.set(false);
  }
  for (  PublicCertificate cert : certificates.view()) {
    if (cert.getOwner() != shareDestination.getParent()) {
      shareDestination.getPortfolioModel().getCertificatesModel().getPortfolio().moveInto(cert);
    }
  }
  portfolio.getTrainsModel().getPortfolio().moveAll(bank.getPool());
  int cash=treasury.value();
  if (cash > 0) {
    treasury.setSuppressZero(true);
    MoneyModel.cashMoveToBank(this,cash);
  }
  lastRevenue.setSuppressZero(true);
  setLastRevenue(0);
  for (  BaseToken token : baseTokens.getLaidTokens()) {
    baseTokens.addFreeToken(token);
  }
  stockMarket.close(this);
}","public void setClosed(){
  closed.set(true);
  PortfolioOwner shareDestination;
  if (canBeRestarted) {
    if (certsAreInitiallyAvailable) {
      shareDestination=bank.getIpo();
    }
 else {
      shareDestination=bank.getUnavailable();
    }
    reinitialise();
  }
 else {
    shareDestination=bank.getScrapHeap();
    inGameState.set(false);
  }
  for (  PublicCertificate cert : certificates) {
    if (cert.getOwner() != shareDestination) {
      cert.moveTo(shareDestination);
    }
  }
  portfolio.getTrainsModel().getPortfolio().moveAll(bank.getPool());
  int cash=treasury.value();
  if (cash > 0) {
    treasury.setSuppressZero(true);
    MoneyModel.cashMoveToBank(this,cash);
  }
  lastRevenue.setSuppressZero(true);
  setLastRevenue(0);
  for (  BaseToken token : baseTokens.getLaidTokens()) {
    baseTokens.addFreeToken(token);
  }
  stockMarket.close(this);
}",0.9438079650845608
173549,"/** 
 * Swap this Portfolio's President certificate for common shares in another Portfolio.
 * @param company The company whose Presidency is handed over.
 * @param other The new President's portfolio.
 * @return The common certificates returned.
 */
public List<PublicCertificate> swapPresidentCertificate(PublicCompany company,PortfolioModel other){
  return null;
}","/** 
 * Swap this Portfolio's President certificate for common shares in another Portfolio.
 * @param company The company whose Presidency is handed over.
 * @param other The new President's portfolio.
 * @return The common certificates returned.TODO: Rewrite the method replacing PortfolioModel with Owner
 */
public List<PublicCertificate> swapPresidentCertificate(PublicCompany company,PortfolioModel other){
  List<PublicCertificate> swapped=new ArrayList<PublicCertificate>();
  PublicCertificate swapCert;
  PublicCertificate cert=this.findCertificate(company,true);
  if (cert == null)   return null;
  int shares=cert.getShares();
  if (other.ownsCertificates(company,1,false) >= shares) {
    for (int i=0; i < shares; i++) {
      swapCert=other.findCertificate(company,1,false);
      swapCert.moveTo(getParent());
      swapped.add(swapCert);
    }
  }
 else   if (other.ownsCertificates(company,shares,false) >= 1) {
    swapCert=other.findCertificate(company,2,false);
    swapCert.moveTo(getParent());
    swapped.add(swapCert);
  }
 else {
    return null;
  }
  cert.moveTo(other.getParent());
  return swapped;
}",0.4739652870493992
173550,"public boolean processOnReload(PossibleAction action) throws Exception {
  DisplayBuffer.clear();
  if (gameName.equals(""String_Node_Str"") && possibleActions.contains(RepayLoans.class) && (!possibleActions.contains(action.getClass()) || (action.getClass() == NullAction.class && ((NullAction)action).getMode() != NullAction.DONE))) {
    log.debug(""String_Node_Str"");
    getCurrentRound().process(new NullAction(NullAction.DONE));
    possibleActions.clear();
    getCurrentRound().setPossibleActions();
    if (!isGameOver())     setCorrectionActions();
  }
  try {
    log.debug(""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action);
    boolean doProcess=true;
    if (skipNextDone) {
      if (action instanceof NullAction && ((NullAction)action).getMode() == NullAction.DONE) {
        if (currentRound.value() instanceof OperatingRound && ((OperatingRound)currentRound.value()).getStep() == skippedStep) {
          doProcess=false;
        }
      }
    }
    skipNextDone=false;
    skippedStep=null;
    if (doProcess && !processCorrectionActions(action) && !getCurrentRound().process(action)) {
      String msg=""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action.toString()+ ""String_Node_Str""+ getCurrentRound().getRoundName()+ ""String_Node_Str"";
      log.error(msg);
      DisplayBuffer.add(msg);
      ChangeStack changeStack=getRoot().getStateManager().getChangeStack();
      if (changeStack.isOpen())       changeStack.close();
      return false;
    }
    possibleActions.clear();
    getCurrentRound().setPossibleActions();
    String playerName=getCurrentPlayer().getId();
    for (    PossibleAction a : possibleActions.getList()) {
      log.debug(playerName + ""String_Node_Str"" + a.toString());
    }
    if (!isGameOver())     setCorrectionActions();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + action.toString(),e);
    throw new Exception(""String_Node_Str"",e);
  }
  executedActions.add(action);
  log.debug(""String_Node_Str"" + getCurrentPlayer().getId());
  return true;
}","public boolean processOnReload(PossibleAction action) throws Exception {
  DisplayBuffer.clear();
  if (gameName.equals(""String_Node_Str"") && possibleActions.contains(RepayLoans.class) && (!possibleActions.contains(action.getClass()) || (action.getClass() == NullAction.class && ((NullAction)action).getMode() != NullAction.DONE))) {
    log.debug(""String_Node_Str"");
    getCurrentRound().process(new NullAction(NullAction.DONE));
    possibleActions.clear();
    getCurrentRound().setPossibleActions();
    if (!isGameOver())     setCorrectionActions();
  }
  try {
    log.debug(""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action);
    String playerName=getCurrentPlayer().getId();
    for (    PossibleAction a : possibleActions.getList()) {
      log.debug(playerName + ""String_Node_Str"" + a.toString());
    }
    if (!possibleActions.validate(action)) {
      DisplayBuffer.add(LocalText.getText(""String_Node_Str"",action.toString()));
      return false;
    }
    boolean doProcess=true;
    if (skipNextDone) {
      if (action instanceof NullAction && ((NullAction)action).getMode() == NullAction.DONE) {
        if (currentRound.value() instanceof OperatingRound && ((OperatingRound)currentRound.value()).getStep() == skippedStep) {
          doProcess=false;
        }
      }
    }
    skipNextDone=false;
    skippedStep=null;
    if (doProcess && !processCorrectionActions(action) && !getCurrentRound().process(action)) {
      String msg=""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action.toString()+ ""String_Node_Str""+ getCurrentRound().getRoundName()+ ""String_Node_Str"";
      log.error(msg);
      DisplayBuffer.add(msg);
      ChangeStack changeStack=getRoot().getStateManager().getChangeStack();
      if (changeStack.isOpen())       changeStack.close();
      return false;
    }
    possibleActions.clear();
    getCurrentRound().setPossibleActions();
    if (!isGameOver())     setCorrectionActions();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + action.toString(),e);
    throw new Exception(""String_Node_Str"",e);
  }
  executedActions.add(action);
  log.debug(""String_Node_Str"" + getCurrentPlayer().getId());
  return true;
}",0.8795124238162213
173551,"@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action instanceof BuyCertificate))   return false;
  BuyCertificate a=(BuyCertificate)action;
  return a.certificate == certificate && a.from == from && a.price == price && a.maximumNumber == maximumNumber;
}","@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action.getClass() == BuyCertificate.class))   return false;
  BuyCertificate a=(BuyCertificate)action;
  return a.company == company && a.from == from && a.price == price && a.maximumNumber == maximumNumber;
}",0.8698752228163993
173552,"/** 
 * Deserialize 
 */
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  ObjectInputStream.GetField fields=in.readFields();
  trainUniqueId=(String)fields.get(""String_Node_Str"",trainUniqueId);
  typeName=(String)fields.get(""String_Node_Str"",null);
  fromName=(String)fields.get(""String_Node_Str"",fromName);
  fixedCost=fields.get(""String_Node_Str"",fixedCost);
  forcedBuyIfNoRoute=fields.get(""String_Node_Str"",forcedBuyIfNoRoute);
  trainsForExchangeUniqueIds=(String[])fields.get(""String_Node_Str"",trainsForExchangeUniqueIds);
  forcedExchange=fields.get(""String_Node_Str"",forcedExchange);
  presidentMustAddCash=fields.get(""String_Node_Str"",presidentMustAddCash);
  presidentMayAddCash=fields.get(""String_Node_Str"",presidentMayAddCash);
  presidentCashToAdd=fields.get(""String_Node_Str"",presidentCashToAdd);
  specialPropertyId=fields.get(""String_Node_Str"",specialPropertyId);
  pricePaid=fields.get(""String_Node_Str"",pricePaid);
  addedCash=fields.get(""String_Node_Str"",addedCash);
  exchangedTrainUniqueId=(String)fields.get(""String_Node_Str"",exchangedTrainUniqueId);
  extraMessage=(String)fields.get(""String_Node_Str"",extraMessage);
  GameManager gameManager=GameManager.getInstance();
  TrainManager trainManager=gameManager.getTrainManager();
  CompanyManager companyManager=gameManager.getCompanyManager();
  fromName=companyManager.checkAlias(fromName);
  train=trainManager.getTrainByUniqueId(trainUniqueId);
  if (typeName == null) {
    if (train == null) {
      typeName=trainUniqueId.split(""String_Node_Str"")[0];
      type=trainManager.getTypeByName(typeName);
    }
 else {
      type=train.getType();
      typeName=type.getName();
    }
  }
 else {
    type=trainManager.getTypeByName(typeName);
  }
  if (trainsForExchangeUniqueIds != null && trainsForExchangeUniqueIds.length > 0) {
    trainsForExchange=new HashSet<Train>();
    for (int i=0; i < trainsForExchangeUniqueIds.length; i++) {
      trainsForExchange.add(trainManager.getTrainByUniqueId(trainsForExchangeUniqueIds[i]));
    }
  }
  if (specialPropertyId > 0) {
    specialProperty=(SpecialTrainBuy)SpecialProperty.getByUniqueId(specialPropertyId);
  }
  if (Util.hasValue(exchangedTrainUniqueId)) {
    exchangedTrain=trainManager.getTrainByUniqueId(exchangedTrainUniqueId);
  }
}","/** 
 * Deserialize 
 */
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  ObjectInputStream.GetField fields=in.readFields();
  trainUniqueId=(String)fields.get(""String_Node_Str"",trainUniqueId);
  typeName=(String)fields.get(""String_Node_Str"",null);
  fromName=(String)fields.get(""String_Node_Str"",fromName);
  fixedCost=fields.get(""String_Node_Str"",fixedCost);
  forcedBuyIfNoRoute=fields.get(""String_Node_Str"",forcedBuyIfNoRoute);
  trainsForExchangeUniqueIds=(String[])fields.get(""String_Node_Str"",trainsForExchangeUniqueIds);
  forcedExchange=fields.get(""String_Node_Str"",forcedExchange);
  presidentMustAddCash=fields.get(""String_Node_Str"",presidentMustAddCash);
  presidentMayAddCash=fields.get(""String_Node_Str"",presidentMayAddCash);
  presidentCashToAdd=fields.get(""String_Node_Str"",presidentCashToAdd);
  specialPropertyId=fields.get(""String_Node_Str"",specialPropertyId);
  pricePaid=fields.get(""String_Node_Str"",pricePaid);
  addedCash=fields.get(""String_Node_Str"",addedCash);
  exchangedTrainUniqueId=(String)fields.get(""String_Node_Str"",exchangedTrainUniqueId);
  extraMessage=(String)fields.get(""String_Node_Str"",extraMessage);
  GameManager gameManager=GameManager.getInstance();
  TrainManager trainManager=gameManager.getTrainManager();
  CompanyManager companyManager=gameManager.getCompanyManager();
  fromName=companyManager.checkAlias(fromName);
  train=trainManager.getTrainByUniqueId(trainUniqueId);
  if (typeName == null) {
    if (train == null) {
      typeName=trainUniqueId.split(""String_Node_Str"")[0];
      type=trainManager.getTypeByName(typeName);
    }
 else {
      type=train.getType();
      typeName=type.getName();
    }
  }
 else {
    type=trainManager.getTypeByName(typeName);
  }
  from=gameManager.getPortfolioByName(fromName).getParent();
  if (trainsForExchangeUniqueIds != null && trainsForExchangeUniqueIds.length > 0) {
    trainsForExchange=new HashSet<Train>();
    for (int i=0; i < trainsForExchangeUniqueIds.length; i++) {
      trainsForExchange.add(trainManager.getTrainByUniqueId(trainsForExchangeUniqueIds[i]));
    }
  }
  if (specialPropertyId > 0) {
    specialProperty=(SpecialTrainBuy)SpecialProperty.getByUniqueId(specialPropertyId);
  }
  if (Util.hasValue(exchangedTrainUniqueId)) {
    exchangedTrain=trainManager.getTrainByUniqueId(exchangedTrainUniqueId);
  }
}",0.9869741618620542
173553,"public void actionPerformed(ActionEvent arg0){
  if (arg0.getSource().equals(newButton)) {
    startNewGame();
  }
 else   if (arg0.getSource().equals(optionButton)) {
    toggleOptions();
    this.pack();
  }
 else   if (arg0.getSource().equals(configureButton)) {
    if (configWindow == null) {
      configWindow=new ConfigWindow(false);
      configWindow.init();
      configWindow.setVisible(true);
    }
 else {
      configWindow.setVisible(true);
    }
  }
 else   if (arg0.getSource().equals(loadButton)) {
    String saveDirectory=Config.get(""String_Node_Str"");
    JFileChooser jfc=new JFileChooser();
    jfc.setCurrentDirectory(new File(saveDirectory));
    if (jfc.showOpenDialog(getContentPane()) == JFileChooser.APPROVE_OPTION) {
      File selectedFile=jfc.getSelectedFile();
      loadAndStartGame(selectedFile.getPath(),selectedFile.getParent());
    }
 else {
      return;
    }
  }
 else   if (arg0.getSource().equals(recentButton)) {
    File saveDirectory=new File(Config.get(""String_Node_Str""));
    recentFiles=new TreeSet<File>(new Comparator<File>(){
      public int compare(      File a,      File b){
        return Math.round(b.lastModified() - a.lastModified());
      }
    }
);
    savedFileExtension=Config.get(""String_Node_Str"");
    if (!Util.hasValue(savedFileExtension)) {
      savedFileExtension=GameUIManager.DEFAULT_SAVE_EXTENSION;
    }
    savedFileExtension=""String_Node_Str"" + savedFileExtension;
    getRecentFiles(saveDirectory);
    if (recentFiles == null || recentFiles.size() == 0)     return;
    File[] files=recentFiles.toArray(new File[]{});
    int numOptions=20;
    String[] options=new String[numOptions];
    int dirPathLength=saveDirectory.getPath().length();
    for (int i=0; i < numOptions; i++) {
      options[i]=files[i].getPath().substring(dirPathLength + 1);
    }
    String text=LocalText.getText(""String_Node_Str"");
    String result=(String)JOptionPane.showInputDialog(this,text,text,JOptionPane.OK_CANCEL_OPTION,null,options,options[0]);
    if (result == null)     return;
    File selectedFile=files[Arrays.asList(options).indexOf(result)];
    if (selectedFile != null) {
      loadAndStartGame(selectedFile.getPath(),selectedFile.getParent());
    }
 else {
      return;
    }
  }
 else   if (arg0.getSource().equals(recoveryButton)) {
    String filePath=Config.get(""String_Node_Str"",""String_Node_Str"");
    loadAndStartGame(filePath,null);
  }
 else   if (arg0.getSource().equals(infoButton)) {
    GameInfo gameInfo=this.getSelectedGameInfo();
    JOptionPane.showMessageDialog(this,gameInfo.getDescription(),""String_Node_Str"" + gameInfo.getName(),JOptionPane.INFORMATION_MESSAGE);
  }
 else   if (arg0.getSource().equals(quitButton)) {
    System.exit(0);
  }
 else   if (arg0.getSource().equals(creditsButton)) {
    JOptionPane.showMessageDialog(this,credits,LocalText.getText(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
  }
 else   if (arg0.getSource().equals(gameNameBox)) {
    fillPlayersPane();
    if (optionsPane.isVisible()) {
      toggleOptions();
      toggleOptions();
    }
    this.pack();
  }
 else   if (arg0.getSource() instanceof JComboBox) {
    JComboBox comboBox=(JComboBox)arg0.getSource();
    String[] boxName=comboBox.getName().split(""String_Node_Str"");
    if (boxName[0].equalsIgnoreCase(""String_Node_Str"")) {
switch (comboBox.getSelectedIndex()) {
case NONE_PLAYER:
        playerNameFields[Integer.parseInt(boxName[1])].setText(""String_Node_Str"");
      playerNameFields[Integer.parseInt(boxName[1])].setEnabled(false);
    break;
case HUMAN_PLAYER:
  playerNameFields[Integer.parseInt(boxName[1])].setEnabled(true);
break;
case AI_PLAYER:
playerNameFields[Integer.parseInt(boxName[1])].setText(""String_Node_Str"");
playerNameFields[Integer.parseInt(boxName[1])].setEnabled(false);
break;
}
}
}
 else if (arg0.getSource().equals(randomizeButton)) {
if (playerNameFields.length > 0) {
List<String> playerList=new ArrayList<String>();
for (int i=0; i < playerNameFields.length; i++) {
if (playerNameFields[i] != null && playerNameFields[i].getText().length() > 0) {
playerList.add(playerNameFields[i].getText());
playerNameFields[i].setText(""String_Node_Str"");
}
}
Collections.shuffle(playerList);
for (int i=0; i < playerList.size(); i++) {
playerNameFields[i].setText(playerList.get(i));
}
}
}
}","public void actionPerformed(ActionEvent arg0){
  if (arg0.getSource().equals(newButton)) {
    startNewGame();
  }
 else   if (arg0.getSource().equals(optionButton)) {
    toggleOptions();
    this.pack();
  }
 else   if (arg0.getSource().equals(configureButton)) {
    if (configWindow == null) {
      configWindow=new ConfigWindow(false);
      configWindow.init();
      configWindow.setVisible(true);
    }
 else {
      configWindow.setVisible(true);
    }
  }
 else   if (arg0.getSource().equals(loadButton)) {
    String saveDirectory=Config.get(""String_Node_Str"");
    JFileChooser jfc=new JFileChooser();
    jfc.setCurrentDirectory(new File(saveDirectory));
    if (jfc.showOpenDialog(getContentPane()) == JFileChooser.APPROVE_OPTION) {
      File selectedFile=jfc.getSelectedFile();
      loadAndStartGame(selectedFile.getPath(),selectedFile.getParent());
    }
 else {
      return;
    }
  }
 else   if (arg0.getSource().equals(recentButton)) {
    File saveDirectory=new File(Config.get(""String_Node_Str""));
    recentFiles=new TreeSet<File>(new Comparator<File>(){
      public int compare(      File a,      File b){
        return Math.round(b.lastModified() - a.lastModified());
      }
    }
);
    savedFileExtension=Config.get(""String_Node_Str"");
    if (!Util.hasValue(savedFileExtension)) {
      savedFileExtension=GameUIManager.DEFAULT_SAVE_EXTENSION;
    }
    savedFileExtension=""String_Node_Str"" + savedFileExtension;
    getRecentFiles(saveDirectory);
    if (recentFiles == null || recentFiles.size() == 0)     return;
    File[] files=recentFiles.toArray(new File[]{});
    int numOptions=20;
    numOptions=Math.min(numOptions,recentFiles.size());
    String[] options=new String[numOptions];
    int dirPathLength=saveDirectory.getPath().length();
    for (int i=0; i < numOptions; i++) {
      options[i]=files[i].getPath().substring(dirPathLength + 1);
    }
    String text=LocalText.getText(""String_Node_Str"");
    String result=(String)JOptionPane.showInputDialog(this,text,text,JOptionPane.OK_CANCEL_OPTION,null,options,options[0]);
    if (result == null)     return;
    File selectedFile=files[Arrays.asList(options).indexOf(result)];
    if (selectedFile != null) {
      loadAndStartGame(selectedFile.getPath(),selectedFile.getParent());
    }
 else {
      return;
    }
  }
 else   if (arg0.getSource().equals(recoveryButton)) {
    String filePath=Config.get(""String_Node_Str"",""String_Node_Str"");
    loadAndStartGame(filePath,null);
  }
 else   if (arg0.getSource().equals(infoButton)) {
    GameInfo gameInfo=this.getSelectedGameInfo();
    JOptionPane.showMessageDialog(this,gameInfo.getDescription(),""String_Node_Str"" + gameInfo.getName(),JOptionPane.INFORMATION_MESSAGE);
  }
 else   if (arg0.getSource().equals(quitButton)) {
    System.exit(0);
  }
 else   if (arg0.getSource().equals(creditsButton)) {
    JOptionPane.showMessageDialog(this,credits,LocalText.getText(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
  }
 else   if (arg0.getSource().equals(gameNameBox)) {
    fillPlayersPane();
    if (optionsPane.isVisible()) {
      toggleOptions();
      toggleOptions();
    }
    this.pack();
  }
 else   if (arg0.getSource() instanceof JComboBox) {
    JComboBox comboBox=(JComboBox)arg0.getSource();
    String[] boxName=comboBox.getName().split(""String_Node_Str"");
    if (boxName[0].equalsIgnoreCase(""String_Node_Str"")) {
switch (comboBox.getSelectedIndex()) {
case NONE_PLAYER:
        playerNameFields[Integer.parseInt(boxName[1])].setText(""String_Node_Str"");
      playerNameFields[Integer.parseInt(boxName[1])].setEnabled(false);
    break;
case HUMAN_PLAYER:
  playerNameFields[Integer.parseInt(boxName[1])].setEnabled(true);
break;
case AI_PLAYER:
playerNameFields[Integer.parseInt(boxName[1])].setText(""String_Node_Str"");
playerNameFields[Integer.parseInt(boxName[1])].setEnabled(false);
break;
}
}
}
 else if (arg0.getSource().equals(randomizeButton)) {
if (playerNameFields.length > 0) {
List<String> playerList=new ArrayList<String>();
for (int i=0; i < playerNameFields.length; i++) {
if (playerNameFields[i] != null && playerNameFields[i].getText().length() > 0) {
playerList.add(playerNameFields[i].getText());
playerNameFields[i].setText(""String_Node_Str"");
}
}
Collections.shuffle(playerList);
for (int i=0; i < playerList.size(); i++) {
playerNameFields[i].setText(playerList.get(i));
}
}
}
}",0.9935632183908046
173554,"public void replayGame() throws Exception {
  if (!initialized) {
    throw new ConfigurationException(""String_Node_Str"");
  }
  GameManager gameManager=loadedGame.getGameManager();
  log.debug(""String_Node_Str"");
  gameManager.setReloading(true);
  for (  PossibleAction action : gameData.actions) {
    if (!gameManager.processOnReload(action)) {
      log.error(""String_Node_Str"");
      DisplayBuffer.add(LocalText.getText(""String_Node_Str""));
      break;
    }
  }
  gameManager.setReloading(false);
  ReportBuffer.setCommentItems(gameData.userComments);
  gameManager.finishLoading();
}","public void replayGame() throws Exception {
  if (!initialized) {
    throw new ConfigurationException(""String_Node_Str"");
  }
  GameManager gameManager=loadedGame.getGameManager();
  log.debug(""String_Node_Str"");
  gameManager.setReloading(true);
  gameManager.getCurrentRound().setPossibleActions();
  for (  PossibleAction action : gameData.actions) {
    if (!gameManager.processOnReload(action)) {
      log.error(""String_Node_Str"");
      DisplayBuffer.add(LocalText.getText(""String_Node_Str""));
      break;
    }
  }
  gameManager.setReloading(false);
  ReportBuffer.setCommentItems(gameData.userComments);
  gameManager.finishLoading();
}",0.9564516129032258
173555,"public void finishConfiguration(GameManager gameManager){
  if (gameManager == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  currentTile=gameManager.getTileManager().getTile(preprintedTiled);
  stops=new ArrayList<Stop>(4);
  mStops=new HashMap<Integer,Stop>(4);
  for (  Station s : currentTile.getStations()) {
    Stop c=Stop.create(this,s.getNumber(),s);
    stops.add(c);
    mStops.put(c.getNumber(),c);
  }
}","public void finishConfiguration(GameManager gameManager){
  if (gameManager == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  currentTile=gameManager.getTileManager().getTile(preprintedTileId);
  stops=new ArrayList<Stop>(4);
  mStops=new HashMap<Integer,Stop>(4);
  for (  Station s : currentTile.getStations()) {
    Stop c=Stop.create(this,s.getNumber(),s);
    stops.add(c);
    mStops.put(c.getNumber(),c);
  }
}",0.9988700564971752
173556,"/** 
 * @see rails.common.parser.Configurable#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Tag tag) throws ConfigurationException {
  Pattern namePattern=Pattern.compile(""String_Node_Str"");
  infoText=name=tag.getAttributeAsString(""String_Node_Str"");
  Matcher m=namePattern.matcher(name);
  if (!m.matches()) {
    throw new ConfigurationException(""String_Node_Str"" + name);
  }
  String letters=m.group(1);
  if (letters.length() == 1) {
    letter=letters.charAt(0);
  }
 else {
    letter=26 + letters.charAt(1);
  }
  try {
    number=Integer.parseInt(m.group(2));
    if (number > 90)     number-=100;
  }
 catch (  NumberFormatException e) {
  }
  if (lettersGoHorizontal()) {
    row=number;
    column=letter - '@';
    if (getTileOrientation() == TileOrientation.EW) {
      x=column;
      y=row / 2;
    }
 else {
      x=column;
      y=(row + 1) / 2;
    }
  }
 else {
    row=letter - '@';
    column=number;
    if (getTileOrientation() == TileOrientation.EW) {
      x=(column + 8 + (letterAHasEvenNumbers() ? 1 : 0)) / 2 - 4;
      y=row;
    }
 else {
      x=column;
      y=(row + 1) / 2;
    }
  }
  preprintedTiled=tag.getAttributeAsInteger(""String_Node_Str"",-999);
  preprintedTileRotation=tag.getAttributeAsInteger(""String_Node_Str"",0);
  currentTileRotation=preprintedTileRotation;
  impassable=tag.getAttributeAsString(""String_Node_Str"");
  tileCost=tag.getAttributeAsIntegerArray(""String_Node_Str"",new int[0]);
  valuesPerPhase=tag.getAttributeAsIntegerArray(""String_Node_Str"",null);
  cityName=tag.getAttributeAsString(""String_Node_Str"",""String_Node_Str"");
  if (Util.hasValue(cityName)) {
    infoText+=""String_Node_Str"" + cityName;
  }
  if (tag.getAttributeAsString(""String_Node_Str"") != null) {
    setBlockedForTokenLays(tag.getAttributeAsBoolean(""String_Node_Str"",false));
  }
  reservedForCompany=tag.getAttributeAsString(""String_Node_Str"");
  List<Tag> bonusTags=tag.getChildren(""String_Node_Str"");
  if (bonusTags != null) {
    revenueBonuses=new ArrayList<RevenueBonusTemplate>();
    for (    Tag bonusTag : bonusTags) {
      RevenueBonusTemplate bonus=new RevenueBonusTemplate();
      bonus.configureFromXML(bonusTag);
      revenueBonuses.add(bonus);
    }
  }
  for (  int side : tag.getAttributeAsIntegerArray(""String_Node_Str"",new int[0])) {
    if (openHexSides == null)     openHexSides=new boolean[6];
    openHexSides[side % 6]=true;
  }
  Tag accessTag=tag.getChild(""String_Node_Str"");
  if (accessTag != null) {
    String runThroughString=accessTag.getAttributeAsString(""String_Node_Str"");
    if (Util.hasValue(runThroughString)) {
      try {
        runThroughAllowed=RunThrough.valueOf(runThroughString.toUpperCase());
      }
 catch (      IllegalArgumentException e) {
        throw new ConfigurationException(""String_Node_Str"" + name + ""String_Node_Str""+ runThroughString,e);
      }
    }
    String runToString=accessTag.getAttributeAsString(""String_Node_Str"");
    if (Util.hasValue(runToString)) {
      try {
        runToAllowed=RunTo.valueOf(runToString.toUpperCase());
      }
 catch (      IllegalArgumentException e) {
        throw new ConfigurationException(""String_Node_Str"" + name + ""String_Node_Str""+ runToString,e);
      }
    }
    String loopString=accessTag.getAttributeAsString(""String_Node_Str"");
    if (Util.hasValue(loopString)) {
      try {
        loopAllowed=Loop.valueOf(loopString.toUpperCase());
      }
 catch (      IllegalArgumentException e) {
        throw new ConfigurationException(""String_Node_Str"" + name + ""String_Node_Str""+ loopString,e);
      }
    }
    String typeString=accessTag.getAttributeAsString(""String_Node_Str"");
    if (Util.hasValue(typeString)) {
      try {
        stopType=Type.valueOf(typeString.toUpperCase());
      }
 catch (      IllegalArgumentException e) {
        throw new ConfigurationException(""String_Node_Str"" + name + ""String_Node_Str""+ typeString,e);
      }
    }
    String scoreTypeString=accessTag.getAttributeAsString(""String_Node_Str"");
    if (Util.hasValue(scoreTypeString)) {
      try {
        scoreType=Score.valueOf(scoreTypeString.toUpperCase());
      }
 catch (      IllegalArgumentException e) {
        throw new ConfigurationException(""String_Node_Str"" + name + ""String_Node_Str""+ scoreTypeString,e);
      }
    }
  }
}","/** 
 * @see rails.common.parser.Configurable#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Tag tag) throws ConfigurationException {
  Pattern namePattern=Pattern.compile(""String_Node_Str"");
  infoText=name=tag.getAttributeAsString(""String_Node_Str"");
  Matcher m=namePattern.matcher(name);
  if (!m.matches()) {
    throw new ConfigurationException(""String_Node_Str"" + name);
  }
  String letters=m.group(1);
  if (letters.length() == 1) {
    letter=letters.charAt(0);
  }
 else {
    letter=26 + letters.charAt(1);
  }
  try {
    number=Integer.parseInt(m.group(2));
    if (number > 90)     number-=100;
  }
 catch (  NumberFormatException e) {
  }
  if (lettersGoHorizontal()) {
    row=number;
    column=letter - '@';
    if (getTileOrientation() == TileOrientation.EW) {
      x=column;
      y=row / 2;
    }
 else {
      x=column;
      y=(row + 1) / 2;
    }
  }
 else {
    row=letter - '@';
    column=number;
    if (getTileOrientation() == TileOrientation.EW) {
      x=(column + 8 + (letterAHasEvenNumbers() ? 1 : 0)) / 2 - 4;
      y=row;
    }
 else {
      x=column;
      y=(row + 1) / 2;
    }
  }
  preprintedTileId=tag.getAttributeAsInteger(""String_Node_Str"",-999);
  preprintedTileRotation=tag.getAttributeAsInteger(""String_Node_Str"",0);
  currentTileRotation=preprintedTileRotation;
  impassable=tag.getAttributeAsString(""String_Node_Str"");
  tileCost=tag.getAttributeAsIntegerArray(""String_Node_Str"",new int[0]);
  valuesPerPhase=tag.getAttributeAsIntegerArray(""String_Node_Str"",null);
  cityName=tag.getAttributeAsString(""String_Node_Str"",""String_Node_Str"");
  if (Util.hasValue(cityName)) {
    infoText+=""String_Node_Str"" + cityName;
  }
  if (tag.getAttributeAsString(""String_Node_Str"") != null) {
    setBlockedForTokenLays(tag.getAttributeAsBoolean(""String_Node_Str"",false));
  }
  reservedForCompany=tag.getAttributeAsString(""String_Node_Str"");
  List<Tag> bonusTags=tag.getChildren(""String_Node_Str"");
  if (bonusTags != null) {
    revenueBonuses=new ArrayList<RevenueBonusTemplate>();
    for (    Tag bonusTag : bonusTags) {
      RevenueBonusTemplate bonus=new RevenueBonusTemplate();
      bonus.configureFromXML(bonusTag);
      revenueBonuses.add(bonus);
    }
  }
  for (  int side : tag.getAttributeAsIntegerArray(""String_Node_Str"",new int[0])) {
    if (openHexSides == null)     openHexSides=new boolean[6];
    openHexSides[side % 6]=true;
  }
  Tag accessTag=tag.getChild(""String_Node_Str"");
  if (accessTag != null) {
    String runThroughString=accessTag.getAttributeAsString(""String_Node_Str"");
    if (Util.hasValue(runThroughString)) {
      try {
        runThroughAllowed=RunThrough.valueOf(runThroughString.toUpperCase());
      }
 catch (      IllegalArgumentException e) {
        throw new ConfigurationException(""String_Node_Str"" + name + ""String_Node_Str""+ runThroughString,e);
      }
    }
    String runToString=accessTag.getAttributeAsString(""String_Node_Str"");
    if (Util.hasValue(runToString)) {
      try {
        runToAllowed=RunTo.valueOf(runToString.toUpperCase());
      }
 catch (      IllegalArgumentException e) {
        throw new ConfigurationException(""String_Node_Str"" + name + ""String_Node_Str""+ runToString,e);
      }
    }
    String loopString=accessTag.getAttributeAsString(""String_Node_Str"");
    if (Util.hasValue(loopString)) {
      try {
        loopAllowed=Loop.valueOf(loopString.toUpperCase());
      }
 catch (      IllegalArgumentException e) {
        throw new ConfigurationException(""String_Node_Str"" + name + ""String_Node_Str""+ loopString,e);
      }
    }
    String typeString=accessTag.getAttributeAsString(""String_Node_Str"");
    if (Util.hasValue(typeString)) {
      try {
        stopType=Type.valueOf(typeString.toUpperCase());
      }
 catch (      IllegalArgumentException e) {
        throw new ConfigurationException(""String_Node_Str"" + name + ""String_Node_Str""+ typeString,e);
      }
    }
    String scoreTypeString=accessTag.getAttributeAsString(""String_Node_Str"");
    if (Util.hasValue(scoreTypeString)) {
      try {
        scoreType=Score.valueOf(scoreTypeString.toUpperCase());
      }
 catch (      IllegalArgumentException e) {
        throw new ConfigurationException(""String_Node_Str"" + name + ""String_Node_Str""+ scoreTypeString,e);
      }
    }
  }
}",0.9998838694692834
173557,"public void finishConfiguration(TileManager tileManager) throws ConfigurationException {
  this.tileManager=tileManager;
  for (  Upgrade upgrade : upgrades) {
    Tile tile=tileManager.getTile(upgrade.getTiled());
    if (tile != null) {
      upgrade.setTile(tile);
    }
 else {
      throw new ConfigurationException(""String_Node_Str"" + upgrade.getTiled() + ""String_Node_Str""+ nb);
    }
  }
}","public void finishConfiguration(TileManager tileManager) throws ConfigurationException {
  this.tileManager=tileManager;
  for (  Upgrade upgrade : upgrades) {
    Tile tile=tileManager.getTile(upgrade.getTileId());
    if (tile != null) {
      upgrade.setTile(tile);
    }
 else {
      throw new ConfigurationException(""String_Node_Str"" + upgrade.getTileId() + ""String_Node_Str""+ nb);
    }
  }
}",0.9974874371859296
173558,"/** 
 * @param laidTile The laidTile to set.
 */
public void setLaidTile(Tile laidTile){
  this.laidTile=laidTile;
  this.laidTiled=laidTile.getNb();
}","/** 
 * @param laidTile The laidTile to set.
 */
public void setLaidTile(Tile laidTile){
  this.laidTile=laidTile;
  this.laidTileId=laidTile.getNb();
}",0.9966996699669968
173559,"@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action instanceof LayTile))   return false;
  LayTile a=(LayTile)action;
  return (a.locationNames == null && locationNames == null || a.locationNames.equals(locationNames)) && a.type == type && a.tileColours == tileColours && a.tiles == tiles && a.specialProperty == specialProperty;
}","@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action.getClass() == LayTile.class))   return false;
  LayTile a=(LayTile)action;
  return (Objects.equal(a.locationNames,locationNames) && a.type == type && Objects.equal(a.tiles,tiles) && Objects.equal(a.specialProperty,specialProperty));
}",0.6369047619047619
173560,"/** 
 * Deserialize 
 */
@SuppressWarnings(""String_Node_Str"") private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  ObjectInputStream.GetField fields=in.readFields();
  locationNames=(String)fields.get(""String_Node_Str"",locationNames);
  tileColours=(Map<String,Integer>)fields.get(""String_Node_Str"",tileColours);
  tileIds=(int[])fields.get(""String_Node_Str"",tileIds);
  specialPropertyId=fields.get(""String_Node_Str"",specialPropertyId);
  laidTiled=fields.get(""String_Node_Str"",laidTiled);
  chosenHexName=(String)fields.get(""String_Node_Str"",chosenHexName);
  orientation=fields.get(""String_Node_Str"",orientation);
  relayBaseTokens=fields.get(""String_Node_Str"",relayBaseTokens);
  relaidBaseTokens=(Map<String,Integer>)fields.get(""String_Node_Str"",relaidBaseTokens);
  relaidBaseTokensString=(String)fields.get(""String_Node_Str"",relaidBaseTokensString);
  MapManager mmgr=gameManager.getMapManager();
  TileManager tmgr=gameManager.getTileManager();
  locations=new ArrayList<MapHex>();
  if (Util.hasValue(locationNames)) {
    for (    String hexName : locationNames.split(""String_Node_Str"")) {
      locations.add(mmgr.getHex(hexName));
    }
  }
  if (tileIds != null && tileIds.length > 0) {
    tiles=new ArrayList<Tile>();
    for (int i=0; i < tileIds.length; i++) {
      tiles.add(tmgr.getTile(tileIds[i]));
    }
  }
  if (specialPropertyId > 0) {
    specialProperty=(SpecialTileLay)SpecialProperty.getByUniqueId(specialPropertyId);
  }
  if (laidTiled != 0) {
    laidTile=tmgr.getTile(laidTiled);
  }
  if (chosenHexName != null && chosenHexName.length() > 0) {
    chosenHex=mmgr.getHex(chosenHexName);
  }
}","/** 
 * Deserialize 
 */
@SuppressWarnings(""String_Node_Str"") private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  ObjectInputStream.GetField fields=in.readFields();
  locationNames=(String)fields.get(""String_Node_Str"",locationNames);
  tileColours=(Map<String,Integer>)fields.get(""String_Node_Str"",tileColours);
  tileIds=(int[])fields.get(""String_Node_Str"",tileIds);
  specialPropertyId=fields.get(""String_Node_Str"",specialPropertyId);
  laidTileId=fields.get(""String_Node_Str"",laidTileId);
  chosenHexName=(String)fields.get(""String_Node_Str"",chosenHexName);
  orientation=fields.get(""String_Node_Str"",orientation);
  relayBaseTokens=fields.get(""String_Node_Str"",relayBaseTokens);
  relaidBaseTokens=(Map<String,Integer>)fields.get(""String_Node_Str"",relaidBaseTokens);
  relaidBaseTokensString=(String)fields.get(""String_Node_Str"",relaidBaseTokensString);
  MapManager mmgr=gameManager.getMapManager();
  TileManager tmgr=gameManager.getTileManager();
  locations=new ArrayList<MapHex>();
  if (Util.hasValue(locationNames)) {
    for (    String hexName : locationNames.split(""String_Node_Str"")) {
      locations.add(mmgr.getHex(hexName));
    }
  }
  if (tileIds != null && tileIds.length > 0) {
    tiles=new ArrayList<Tile>();
    for (int i=0; i < tileIds.length; i++) {
      tiles.add(tmgr.getTile(tileIds[i]));
    }
  }
  if (specialPropertyId > 0) {
    specialProperty=(SpecialTileLay)SpecialProperty.getByUniqueId(specialPropertyId);
  }
  if (laidTileId != 0) {
    laidTile=tmgr.getTile(laidTileId);
  }
  if (chosenHexName != null && chosenHexName.length() > 0) {
    chosenHex=mmgr.getHex(chosenHexName);
  }
}",0.998800959232614
173561,"@Override public boolean equalsAsAction(PossibleAction action){
  if (!(action instanceof LayTile))   return false;
  LayTile a=(LayTile)action;
  return (a.laidTiled == laidTiled && a.chosenHexName.equals(chosenHexName) && a.orientation == orientation && (a.relaidBaseTokensString == null && relaidBaseTokensString == null || a.relaidBaseTokensString.equals(relaidBaseTokensString)));
}","@Override public boolean equalsAsAction(PossibleAction action){
  if (!(action instanceof LayTile))   return false;
  LayTile a=(LayTile)action;
  return (a.laidTileId == laidTileId && a.chosenHexName.equals(chosenHexName) && a.orientation == orientation && (a.relaidBaseTokensString == null && relaidBaseTokensString == null || a.relaidBaseTokensString.equals(relaidBaseTokensString)));
}",0.963917525773196
173562,"private boolean execute(MapCorrectionAction action){
  if (action.getStep() == ActionStep.FINISHED) {
    action.setNextStep(ActionStep.FINISHED);
  }
 else   if (action.getNextStep() == ActionStep.CANCELLED) {
    activeTileAction=null;
    return true;
  }
  MapHex hex=action.getLocation();
  Tile chosenTile=action.getChosenTile();
  TileManager tmgr=getParent().getTileManager();
  Tile preprintedTile=tmgr.getTile(hex.getPreprintedTiled());
  String errMsg=null;
  while (true) {
    if (chosenTile != null && rails.util.Util.hasValue(chosenTile.getExternalId()) && chosenTile != hex.getCurrentTile() && chosenTile.countFreeTiles() == 0) {
      errMsg=LocalText.getText(""String_Node_Str"",chosenTile.getExternalId());
      action.selectHex(hex);
      break;
    }
    List<BaseToken> baseTokens=hex.getBaseTokens();
    if (chosenTile != null && baseTokens != null && !baseTokens.isEmpty()) {
      List<Station> stations=chosenTile.getStations();
      int nbSlots=0;
      if (stations != null) {
        for (        Station station : stations) {
          nbSlots+=station.getBaseSlots();
        }
      }
      if (baseTokens.size() > nbSlots) {
        errMsg=LocalText.getText(""String_Node_Str"",chosenTile.getExternalId());
        action.selectHex(hex);
        break;
      }
      if (chosenTile.getNumStations() >= 2 && hex.getCurrentTile().getColourNumber() >= chosenTile.getColourNumber() || hex.getCurrentTile().relayBaseTokensOnUpgrade()) {
        errMsg=LocalText.getText(""String_Node_Str"",chosenTile.getExternalId());
        action.selectHex(hex);
        break;
      }
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",chosenTile.getExternalId(),hex.getId(),errMsg));
    ;
  }
  ActionStep nextStep;
  if (action.getStep() != ActionStep.FINISHED)   nextStep=action.getNextStep();
 else   nextStep=ActionStep.FINISHED;
switch (nextStep) {
case SELECT_TILE:
    List<Tile> possibleTiles=tmgr.getAllUpgrades(preprintedTile,hex);
  if (preprintedTile == hex.getCurrentTile())   possibleTiles.remove(hex.getCurrentTile());
action.setTiles(possibleTiles);
break;
case SELECT_ORIENTATION:
if (preprintedTile == chosenTile) {
action.selectOrientation(hex.getPreprintedTileRotation());
action.setNextStep(ActionStep.CONFIRM);
break;
}
 else if (chosenTile.getFixedOrientation() != -1) {
action.selectOrientation(chosenTile.getFixedOrientation());
action.setNextStep(ActionStep.CONFIRM);
break;
}
 else {
break;
}
case RELAY_BASETOKENS:
if (chosenTile.getNumStations() >= 2 && hex.getCurrentTile().getColourNumber() >= chosenTile.getColourNumber() || hex.getCurrentTile().relayBaseTokensOnUpgrade()) {
ImmutableList.Builder<BaseToken> tokens=ImmutableList.builder();
for (Stop oldStop : hex.getStops()) {
tokens.addAll(oldStop.getBaseTokens());
}
action.setTokensToRelay(tokens.build());
action.setPossibleStations(chosenTile.getStations());
break;
}
 else {
action.selectRelayBaseTokens(null);
return execute(action);
}
case FINISHED:
getRoot().getChangeStack().newChangeSet(action);
int orientation=action.getOrientation();
hex.upgrade(chosenTile,orientation,new HashMap<String,Integer>());
String msg=LocalText.getText(""String_Node_Str"",chosenTile.getExternalId(),hex.getId(),hex.getOrientationName(orientation));
ReportBuffer.add(msg);
getParent().addToNextPlayerMessages(msg,true);
activeTileAction=null;
break;
case CANCELLED:
activeTileAction=null;
}
if (action.getStep() != ActionStep.FINISHED) {
action.moveToNextStep();
}
return true;
}","private boolean execute(MapCorrectionAction action){
  if (action.getStep() == ActionStep.FINISHED) {
    action.setNextStep(ActionStep.FINISHED);
  }
 else   if (action.getNextStep() == ActionStep.CANCELLED) {
    activeTileAction=null;
    return true;
  }
  MapHex hex=action.getLocation();
  Tile chosenTile=action.getChosenTile();
  TileManager tmgr=getParent().getTileManager();
  Tile preprintedTile=tmgr.getTile(hex.getPreprintedTileId());
  String errMsg=null;
  while (true) {
    if (chosenTile != null && rails.util.Util.hasValue(chosenTile.getExternalId()) && chosenTile != hex.getCurrentTile() && chosenTile.countFreeTiles() == 0) {
      errMsg=LocalText.getText(""String_Node_Str"",chosenTile.getExternalId());
      action.selectHex(hex);
      break;
    }
    List<BaseToken> baseTokens=hex.getBaseTokens();
    if (chosenTile != null && baseTokens != null && !baseTokens.isEmpty()) {
      List<Station> stations=chosenTile.getStations();
      int nbSlots=0;
      if (stations != null) {
        for (        Station station : stations) {
          nbSlots+=station.getBaseSlots();
        }
      }
      if (baseTokens.size() > nbSlots) {
        errMsg=LocalText.getText(""String_Node_Str"",chosenTile.getExternalId());
        action.selectHex(hex);
        break;
      }
      if (chosenTile.getNumStations() >= 2 && hex.getCurrentTile().getColourNumber() >= chosenTile.getColourNumber() || hex.getCurrentTile().relayBaseTokensOnUpgrade()) {
        errMsg=LocalText.getText(""String_Node_Str"",chosenTile.getExternalId());
        action.selectHex(hex);
        break;
      }
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",chosenTile.getExternalId(),hex.getId(),errMsg));
    ;
  }
  ActionStep nextStep;
  if (action.getStep() != ActionStep.FINISHED)   nextStep=action.getNextStep();
 else   nextStep=ActionStep.FINISHED;
switch (nextStep) {
case SELECT_TILE:
    List<Tile> possibleTiles=tmgr.getAllUpgrades(preprintedTile,hex);
  if (preprintedTile == hex.getCurrentTile())   possibleTiles.remove(hex.getCurrentTile());
action.setTiles(possibleTiles);
break;
case SELECT_ORIENTATION:
if (preprintedTile == chosenTile) {
action.selectOrientation(hex.getPreprintedTileRotation());
action.setNextStep(ActionStep.CONFIRM);
break;
}
 else if (chosenTile.getFixedOrientation() != -1) {
action.selectOrientation(chosenTile.getFixedOrientation());
action.setNextStep(ActionStep.CONFIRM);
break;
}
 else {
break;
}
case RELAY_BASETOKENS:
if (chosenTile.getNumStations() >= 2 && hex.getCurrentTile().getColourNumber() >= chosenTile.getColourNumber() || hex.getCurrentTile().relayBaseTokensOnUpgrade()) {
ImmutableList.Builder<BaseToken> tokens=ImmutableList.builder();
for (Stop oldStop : hex.getStops()) {
tokens.addAll(oldStop.getBaseTokens());
}
action.setTokensToRelay(tokens.build());
action.setPossibleStations(chosenTile.getStations());
break;
}
 else {
action.selectRelayBaseTokens(null);
return execute(action);
}
case FINISHED:
getRoot().getChangeStack().newChangeSet(action);
int orientation=action.getOrientation();
hex.upgrade(chosenTile,orientation,new HashMap<String,Integer>());
String msg=LocalText.getText(""String_Node_Str"",chosenTile.getExternalId(),hex.getId(),hex.getOrientationName(orientation));
ReportBuffer.add(msg);
getParent().addToNextPlayerMessages(msg,true);
activeTileAction=null;
break;
case CANCELLED:
activeTileAction=null;
}
if (action.getStep() != ActionStep.FINISHED) {
action.moveToNextStep();
}
return true;
}",0.9998579747195
173563,"private void init(GameUIManager gameUIManager){
  TileManager tmgr=gameUIManager.getGameManager().getTileManager();
  Tile tile;
  Field label;
  BufferedImage hexImage;
  ImageIcon hexIcon;
  int picId;
  List<Integer> tileIds=tmgr.getTileds();
  log.debug(""String_Node_Str"" + tileIds.size() + ""String_Node_Str"");
  for (  int tileId : tileIds) {
    if (tileId <= 0)     continue;
    tile=tmgr.getTile(tileId);
    picId=tile.getPictureId();
    hexImage=GameUIManager.getImageLoader().getTile(picId,10);
    hexIcon=new ImageIcon(hexImage);
    hexIcon.setImage(hexIcon.getImage().getScaledInstance((int)(hexIcon.getIconWidth() * GUIHex.NORMAL_SCALE * 0.8),(int)(hexIcon.getIconHeight() * GUIHex.NORMAL_SCALE * 0.8),Image.SCALE_SMOOTH));
    label=new Field(tile,hexIcon,Field.CENTER);
    label.setVerticalTextPosition(Field.BOTTOM);
    label.setHorizontalTextPosition(Field.CENTER);
    label.setVisible(true);
    getContentPane().add(label);
    shownTiles.add(tile);
    labels.add(label);
  }
}","private void init(GameUIManager gameUIManager){
  TileManager tmgr=gameUIManager.getGameManager().getTileManager();
  Tile tile;
  Field label;
  BufferedImage hexImage;
  ImageIcon hexIcon;
  int picId;
  List<Integer> tileIds=tmgr.getTileIds();
  log.debug(""String_Node_Str"" + tileIds.size() + ""String_Node_Str"");
  for (  int tileId : tileIds) {
    if (tileId <= 0)     continue;
    tile=tmgr.getTile(tileId);
    picId=tile.getPictureId();
    hexImage=GameUIManager.getImageLoader().getTile(picId,10);
    hexIcon=new ImageIcon(hexImage);
    hexIcon.setImage(hexIcon.getImage().getScaledInstance((int)(hexIcon.getIconWidth() * GUIHex.NORMAL_SCALE * 0.8),(int)(hexIcon.getIconHeight() * GUIHex.NORMAL_SCALE * 0.8),Image.SCALE_SMOOTH));
    label=new Field(tile,hexIcon,Field.CENTER);
    label.setVerticalTextPosition(Field.BOTTOM);
    label.setHorizontalTextPosition(Field.CENTER);
    label.setVisible(true);
    getContentPane().add(label);
    shownTiles.add(tile);
    labels.add(label);
  }
}",0.9995027349577325
173564,"public void paint(Graphics g){
  Graphics2D g2=(Graphics2D)g;
  tilePainted=provisionalGUITile != null && hexMap.isTilePainted(provisionalGUITile.getTiled()) || currentGUITile != null && hexMap.isTilePainted(currentGUITile.getTiled());
  if (getAntialias()) {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  }
 else {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
  }
  Color terrainColor=Color.WHITE;
  if (isSelected()) {
    if (!hexMap.hasMapImage()) {
      g2.setColor(highlightColor);
      g2.fill(hexagon);
      g2.setColor(terrainColor);
      g2.fill(innerHexagonSelected);
      g2.setColor(Color.black);
      g2.draw(innerHexagonSelected);
    }
 else {
      g2.setColor(highlightColor);
      g2.draw(hexagon);
      Stroke oldStroke=g2.getStroke();
      g2.setStroke(new BasicStroke(4));
      g2.draw(innerHexagonSelected);
      g2.setStroke(oldStroke);
      g2.setColor(Color.black);
    }
  }
 else   if (isSelectable()) {
    if (!hexMap.hasMapImage()) {
      g2.setColor(selectableColor);
      g2.fill(hexagon);
      g2.setColor(terrainColor);
      g2.fill(innerHexagonSelectable);
      g2.setColor(Color.black);
      g2.draw(innerHexagonSelectable);
    }
 else {
      g2.setColor(selectableColor);
      g2.draw(hexagon);
      g2.setColor(Color.black);
    }
  }
  if (tilePainted)   paintOverlay(g2);
  paintStationTokens(g2);
  paintOffStationTokens(g2);
  if (!tilePainted)   return;
  FontMetrics fontMetrics=g2.getFontMetrics();
  if (getHexModel().getTileCost() > 0) {
    g2.drawString(Currency.format(getHexModel(),getHexModel().getTileCost()),rectBound.x + (rectBound.width - fontMetrics.stringWidth(Integer.toString(getHexModel().getTileCost()))) * 3 / 5,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 9 / 15));
  }
  Map<PublicCompany,Stop> homes=getHexModel().getHomes();
  if (homes != null) {
    Stop homeCity;
    Point p;
    for (    PublicCompany company : homes.keySet()) {
      if (company.isClosed())       continue;
      if (model.hasTokenOfCompany(company))       continue;
      homeCity=homes.get(company);
      if (homeCity == null) {
        List<Stop> stops=getHexModel().getStops();
        for (        Stop stop : stops) {
          if (stop.hasTokenSlotsLeft()) {
            homeCity=stop;
            break;
          }
        }
      }
      p=getTokenCenter(1,homeCity.getBaseTokens().size(),getHexModel().getStops().size(),homeCity.getNumber() - 1);
      drawHome(g2,company,p);
    }
  }
  if (getHexModel().isBlockedForTileLays()) {
    List<PrivateCompany> privates=hexMap.getOrUIManager().getGameUIManager().getGameManager().getCompanyManager().getAllPrivateCompanies();
    for (    PrivateCompany p : privates) {
      List<MapHex> blocked=p.getBlockedHexes();
      if (blocked != null) {
        for (        MapHex hex : blocked) {
          if (getHexModel().equals(hex)) {
            String text=""String_Node_Str"" + p.getId() + ""String_Node_Str"";
            g2.drawString(text,rectBound.x + (rectBound.width - fontMetrics.stringWidth(text)) * 1 / 2,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 5 / 15));
          }
        }
      }
    }
  }
  if (model.isReservedForCompany() && currentTiled == model.getPreprintedTiled()) {
    String text=""String_Node_Str"" + model.getReservedForCompany() + ""String_Node_Str"";
    g2.drawString(text,rectBound.x + (rectBound.width - fontMetrics.stringWidth(text)) * 1 / 2,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 5 / 25));
  }
}","public void paint(Graphics g){
  Graphics2D g2=(Graphics2D)g;
  tilePainted=provisionalGUITile != null && hexMap.isTilePainted(provisionalGUITile.getTileId()) || currentGUITile != null && hexMap.isTilePainted(currentGUITile.getTileId());
  if (getAntialias()) {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  }
 else {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
  }
  Color terrainColor=Color.WHITE;
  if (isSelected()) {
    if (!hexMap.hasMapImage()) {
      g2.setColor(highlightColor);
      g2.fill(hexagon);
      g2.setColor(terrainColor);
      g2.fill(innerHexagonSelected);
      g2.setColor(Color.black);
      g2.draw(innerHexagonSelected);
    }
 else {
      g2.setColor(highlightColor);
      g2.draw(hexagon);
      Stroke oldStroke=g2.getStroke();
      g2.setStroke(new BasicStroke(4));
      g2.draw(innerHexagonSelected);
      g2.setStroke(oldStroke);
      g2.setColor(Color.black);
    }
  }
 else   if (isSelectable()) {
    if (!hexMap.hasMapImage()) {
      g2.setColor(selectableColor);
      g2.fill(hexagon);
      g2.setColor(terrainColor);
      g2.fill(innerHexagonSelectable);
      g2.setColor(Color.black);
      g2.draw(innerHexagonSelectable);
    }
 else {
      g2.setColor(selectableColor);
      g2.draw(hexagon);
      g2.setColor(Color.black);
    }
  }
  if (tilePainted)   paintOverlay(g2);
  paintStationTokens(g2);
  paintOffStationTokens(g2);
  if (!tilePainted)   return;
  FontMetrics fontMetrics=g2.getFontMetrics();
  if (getHexModel().getTileCost() > 0) {
    g2.drawString(Currency.format(getHexModel(),getHexModel().getTileCost()),rectBound.x + (rectBound.width - fontMetrics.stringWidth(Integer.toString(getHexModel().getTileCost()))) * 3 / 5,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 9 / 15));
  }
  Map<PublicCompany,Stop> homes=getHexModel().getHomes();
  if (homes != null) {
    Stop homeCity;
    Point p;
    for (    PublicCompany company : homes.keySet()) {
      if (company.isClosed())       continue;
      if (model.hasTokenOfCompany(company))       continue;
      homeCity=homes.get(company);
      if (homeCity == null) {
        List<Stop> stops=getHexModel().getStops();
        for (        Stop stop : stops) {
          if (stop.hasTokenSlotsLeft()) {
            homeCity=stop;
            break;
          }
        }
      }
      p=getTokenCenter(1,homeCity.getBaseTokens().size(),getHexModel().getStops().size(),homeCity.getNumber() - 1);
      drawHome(g2,company,p);
    }
  }
  if (getHexModel().isBlockedForTileLays()) {
    List<PrivateCompany> privates=hexMap.getOrUIManager().getGameUIManager().getGameManager().getCompanyManager().getAllPrivateCompanies();
    for (    PrivateCompany p : privates) {
      List<MapHex> blocked=p.getBlockedHexes();
      if (blocked != null) {
        for (        MapHex hex : blocked) {
          if (getHexModel().equals(hex)) {
            String text=""String_Node_Str"" + p.getId() + ""String_Node_Str"";
            g2.drawString(text,rectBound.x + (rectBound.width - fontMetrics.stringWidth(text)) * 1 / 2,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 5 / 15));
          }
        }
      }
    }
  }
  if (model.isReservedForCompany() && currentTileId == model.getPreprintedTileId()) {
    String text=""String_Node_Str"" + model.getReservedForCompany() + ""String_Node_Str"";
    g2.drawString(text,rectBound.x + (rectBound.width - fontMetrics.stringWidth(text)) * 1 / 2,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 5 / 25));
  }
}",0.9994453688297282
173565,"private void paintOverlay(Graphics2D g2){
  if (provisionalGUITile != null) {
    if (hexMap.isTilePainted(provisionalGUITile.getTiled())) {
      provisionalGUITile.paintTile(g2,center.x,center.y);
    }
  }
 else {
    if (hexMap.isTilePainted(currentGUITile.getTiled())) {
      currentGUITile.paintTile(g2,center.x,center.y);
    }
  }
}","private void paintOverlay(Graphics2D g2){
  if (provisionalGUITile != null) {
    if (hexMap.isTilePainted(provisionalGUITile.getTileId())) {
      provisionalGUITile.paintTile(g2,center.x,center.y);
    }
  }
 else {
    if (hexMap.isTilePainted(currentGUITile.getTileId())) {
      currentGUITile.paintTile(g2,center.x,center.y);
    }
  }
}",0.9970760233918128
173566,"public void setHexModel(MapHex model){
  this.model=model;
  currentTile=model.getCurrentTile();
  hexName=model.getId();
  currentTiled=model.getCurrentTile().getNb();
  currentTileOrientation=model.getCurrentTileRotation();
  currentGUITile=new GUITile(currentTiled,this);
  currentGUITile.setRotation(currentTileOrientation);
  toolTip=null;
  model.addObserver(this);
}","public void setHexModel(MapHex model){
  this.model=model;
  currentTile=model.getCurrentTile();
  hexName=model.getId();
  currentTileId=model.getCurrentTile().getNb();
  currentTileOrientation=model.getCurrentTileRotation();
  currentGUITile=new GUITile(currentTileId,this);
  currentGUITile.setRotation(currentTileOrientation);
  toolTip=null;
  model.addObserver(this);
}",0.997326203208556
173567,"public void update(String notification){
  String[] elements=notification.split(""String_Node_Str"");
  currentTiled=Integer.parseInt(elements[0]);
  currentTileOrientation=Integer.parseInt(elements[1]);
  currentGUITile=new GUITile(currentTiled,this);
  currentGUITile.setRotation(currentTileOrientation);
  currentTile=currentGUITile.getTile();
  hexMap.repaint(getBounds());
  provisionalGUITile=null;
}","public void update(String notification){
  String[] elements=notification.split(""String_Node_Str"");
  currentTileId=Integer.parseInt(elements[0]);
  currentTileOrientation=Integer.parseInt(elements[1]);
  currentGUITile=new GUITile(currentTileId,this);
  currentGUITile.setRotation(currentTileOrientation);
  currentTile=currentGUITile.getTile();
  hexMap.repaint(getBounds());
  provisionalGUITile=null;
}",0.9975308641975308
173568,"protected void setupHexesGUI(){
  hexes=new ArrayList<GUIHex>();
  hexArray=mapManager.getHexes();
  MapHex mh;
  h=new GUIHex[hexArray.length][hexArray[0].length];
  for (int i=minX; i < hexArray.length; i++) {
    for (int j=minY; j < hexArray[0].length; j++) {
      mh=hexArray[i][j];
      if (mh != null) {
        GUIHex hex=new GUIHex(this,calcXCoordinates(mh.getColumn(),tileXOffset),calcYCoordinates(mh.getRow(),tileYOffset),scale,i - minX + 1,j - minY + 1);
        hex.setHexModel(mh);
        hex.originalTiled=hex.currentTiled;
        hexesByName.put(mh.getId(),hex);
        h[i][j]=hex;
        hexes.add(hex);
      }
    }
  }
}","protected void setupHexesGUI(){
  hexes=new ArrayList<GUIHex>();
  hexArray=mapManager.getHexes();
  MapHex mh;
  h=new GUIHex[hexArray.length][hexArray[0].length];
  for (int i=minX; i < hexArray.length; i++) {
    for (int j=minY; j < hexArray[0].length; j++) {
      mh=hexArray[i][j];
      if (mh != null) {
        GUIHex hex=new GUIHex(this,calcXCoordinates(mh.getColumn(),tileXOffset),calcYCoordinates(mh.getRow(),tileYOffset),scale,i - minX + 1,j - minY + 1);
        hex.setHexModel(mh);
        hex.originalTileId=hex.currentTileId;
        hexesByName.put(mh.getId(),hex);
        h[i][j]=hex;
        hexes.add(hex);
      }
    }
  }
}",0.9984567901234568
173569,"public void startShareSellingRound(Player player,int cashToRaise,PublicCompany cashNeedingCompany,boolean problemDumpOtherCompanies){
  interruptedRound=getCurrentRound();
  createRound(shareSellingRoundClass,""String_Node_Str"").start(interruptedRound,player,cashToRaise,cashNeedingCompany,!problemDumpOtherCompanies || forcedSellingCompanyDump);
}","public void startShareSellingRound(Player player,int cashToRaise,PublicCompany cashNeedingCompany,boolean problemDumpOtherCompanies){
  interruptedRound=getCurrentRound();
  String id=""String_Node_Str"" + interruptedRound.getId() + ""String_Node_Str""+ cashNeedingCompany.getId();
  createRound(shareSellingRoundClass,id).start(interruptedRound,player,cashToRaise,cashNeedingCompany,!problemDumpOtherCompanies || forcedSellingCompanyDump);
}",0.7949044585987262
173570,"public boolean buyTrain(BuyTrain action){
  Train train=action.getTrain();
  PublicCompany company=action.getCompany();
  String companyName=company.getId();
  Train exchangedTrain=action.getExchangedTrain();
  SpecialTrainBuy stb=null;
  String errMsg=null;
  int presidentCash=action.getPresidentCashToAdd();
  boolean presidentMustSellShares=false;
  int price=action.getPricePaid();
  int actualPresidentCash=0;
  int cashToBeRaisedByPresident=0;
  Player currentPlayer=operatingCompany.value().getPresident();
  while (true) {
    if (getStep() != GameDef.OrStep.BUY_TRAIN) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (train == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (price < 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Currency.format(this,price));
      break;
    }
    int fixedPrice=action.getFixedCost();
    if (fixedPrice != 0 && fixedPrice != price) {
      errMsg=LocalText.getText(""String_Node_Str"",Currency.format(this,price),Currency.format(this,fixedPrice));
    }
    int trainLimit=operatingCompany.value().getCurrentTrainLimit();
    if (!canBuyTrainNow() && !action.isForExchange()) {
      errMsg=LocalText.getText(""String_Node_Str"",String.valueOf(trainLimit));
      break;
    }
    if (action.mustPresidentAddCash()) {
      presidentCash=action.getPresidentCashToAdd();
      if (currentPlayer.getCashValue() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCashValue();
      }
    }
 else     if (action.mayPresidentAddCash()) {
      presidentCash=price - operatingCompany.value().getCash();
      if (presidentCash > action.getPresidentCashToAdd()) {
        errMsg=LocalText.getText(""String_Node_Str"",Currency.format(this,action.getPresidentCashToAdd()));
        break;
      }
 else       if (currentPlayer.getCashValue() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCashValue();
      }
    }
 else {
      if (price > operatingCompany.value().getCash()) {
        errMsg=LocalText.getText(""String_Node_Str"",companyName,Currency.format(this,operatingCompany.value().getCash()),Currency.format(this,price));
        break;
      }
    }
    if (action.isForExchange()) {
      if (exchangedTrain == null) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
 else       if (operatingCompany.value().getPortfolioModel().getTrainOfType(exchangedTrain.getCertType()) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),exchangedTrain.getId());
        break;
      }
    }
    stb=action.getSpecialProperty();
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getId(),Currency.format(this,price),errMsg));
    return false;
  }
  ChangeStack.start(this,action);
  Phase previousPhase=getCurrentPhase();
  if (presidentMustSellShares) {
    savedAction=action;
    gameManager.startShareSellingRound(operatingCompany.value().getPresident(),cashToBeRaisedByPresident,operatingCompany.value(),true);
    return true;
  }
  if (actualPresidentCash > 0) {
    String cashText=Currency.wire(currentPlayer,actualPresidentCash,operatingCompany.value());
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),currentPlayer.getId(),cashText));
  }
  Owner oldOwner=train.getOwner();
  if (exchangedTrain != null) {
    Train oldTrain=operatingCompany.value().getPortfolioModel().getTrainOfType(exchangedTrain.getCertType());
    (train.isObsolete() ? scrapHeap : pool).addTrain(oldTrain);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,exchangedTrain.getId(),train.getId(),oldOwner.getId(),Currency.format(this,price)));
  }
 else   if (stb == null) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getId(),oldOwner.getId(),Currency.format(this,price)));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getId(),oldOwner.getId(),Currency.format(this,price),stb.getOriginalCompany().getId()));
  }
  train.setType(action.getType());
  operatingCompany.value().buyTrain(train,price);
  if (oldOwner == ipo.getTrainsModel()) {
    train.getCertType().addToBoughtFromIPO();
    trainManager.setAnyTrainBought(true);
    if (train.getCertType().hasInfiniteQuantity()) {
      ipo.addTrain(trainManager.cloneTrain(train.getCertType()));
    }
  }
  if (oldOwner instanceof Bank) {
    trainsBoughtThisTurn.add(train.getCertType());
  }
  if (stb != null) {
    stb.setExercised();
    log.debug(""String_Node_Str"");
  }
  trainManager.checkTrainAvailability(train,oldOwner);
  if (getCurrentPhase() != previousPhase && checkForExcessTrains()) {
    stepObject.set(GameDef.OrStep.DISCARD_TRAINS);
  }
  if (trainManager.hasPhaseChanged())   newPhaseChecks();
  return true;
}","public boolean buyTrain(BuyTrain action){
  Train train=action.getTrain();
  PublicCompany company=action.getCompany();
  String companyName=company.getId();
  Train exchangedTrain=action.getExchangedTrain();
  SpecialTrainBuy stb=null;
  String errMsg=null;
  int presidentCash=action.getPresidentCashToAdd();
  boolean presidentMustSellShares=false;
  int price=action.getPricePaid();
  int actualPresidentCash=0;
  int cashToBeRaisedByPresident=0;
  Player currentPlayer=operatingCompany.value().getPresident();
  while (true) {
    if (getStep() != GameDef.OrStep.BUY_TRAIN) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (train == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (price < 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Currency.format(this,price));
      break;
    }
    int fixedPrice=action.getFixedCost();
    if (fixedPrice != 0 && fixedPrice != price) {
      errMsg=LocalText.getText(""String_Node_Str"",Currency.format(this,price),Currency.format(this,fixedPrice));
    }
    int trainLimit=operatingCompany.value().getCurrentTrainLimit();
    if (!canBuyTrainNow() && !action.isForExchange()) {
      errMsg=LocalText.getText(""String_Node_Str"",String.valueOf(trainLimit));
      break;
    }
    if (action.mustPresidentAddCash()) {
      presidentCash=action.getPresidentCashToAdd();
      if (currentPlayer.getCashValue() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCashValue();
      }
    }
 else     if (action.mayPresidentAddCash()) {
      presidentCash=price - operatingCompany.value().getCash();
      if (presidentCash > action.getPresidentCashToAdd()) {
        errMsg=LocalText.getText(""String_Node_Str"",Currency.format(this,action.getPresidentCashToAdd()));
        break;
      }
 else       if (currentPlayer.getCashValue() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCashValue();
      }
    }
 else {
      if (price > operatingCompany.value().getCash()) {
        errMsg=LocalText.getText(""String_Node_Str"",companyName,Currency.format(this,operatingCompany.value().getCash()),Currency.format(this,price));
        break;
      }
    }
    if (action.isForExchange()) {
      if (exchangedTrain == null) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
 else       if (operatingCompany.value().getPortfolioModel().getTrainOfType(exchangedTrain.getCertType()) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),exchangedTrain.getId());
        break;
      }
    }
    stb=action.getSpecialProperty();
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getId(),Currency.format(this,price),errMsg));
    return false;
  }
  ChangeStack.start(this,action);
  Phase previousPhase=getCurrentPhase();
  if (presidentMustSellShares) {
    savedAction=action;
    gameManager.startShareSellingRound(operatingCompany.value().getPresident(),cashToBeRaisedByPresident,operatingCompany.value(),true);
    return true;
  }
  if (actualPresidentCash > 0) {
    String cashText=Currency.wire(currentPlayer,actualPresidentCash,operatingCompany.value());
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.value().getId(),currentPlayer.getId(),cashText));
  }
  Owner oldOwner=train.getOwner();
  if (exchangedTrain != null) {
    Train oldTrain=operatingCompany.value().getPortfolioModel().getTrainOfType(exchangedTrain.getCertType());
    (train.isObsolete() ? scrapHeap : pool).addTrain(oldTrain);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,exchangedTrain.getId(),train.getId(),oldOwner.getId(),Currency.format(this,price)));
  }
 else   if (stb == null) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getId(),oldOwner.getId(),Currency.format(this,price)));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getId(),oldOwner.getId(),Currency.format(this,price),stb.getOriginalCompany().getId()));
  }
  train.setType(action.getType());
  operatingCompany.value().buyTrain(train,price);
  if (oldOwner == ipo.getParent()) {
    train.getCertType().addToBoughtFromIPO();
    trainManager.setAnyTrainBought(true);
    if (train.getCertType().hasInfiniteQuantity()) {
      ipo.addTrain(trainManager.cloneTrain(train.getCertType()));
    }
  }
  if (oldOwner instanceof BankPortfolio) {
    trainsBoughtThisTurn.add(train.getCertType());
  }
  if (stb != null) {
    stb.setExercised();
    log.debug(""String_Node_Str"");
  }
  trainManager.checkTrainAvailability(train,oldOwner);
  if (getCurrentPhase() != previousPhase && checkForExcessTrains()) {
    stepObject.set(GameDef.OrStep.DISCARD_TRAINS);
  }
  if (trainManager.hasPhaseChanged())   newPhaseChecks();
  return true;
}",0.9974574613729708
173571,"/** 
 * Take the next step after a given one (see nextStep()) 
 */
protected void nextStep(GameDef.OrStep step){
  PublicCompany company=operatingCompany.value();
  int stepIndex;
  for (stepIndex=0; stepIndex < steps.length; stepIndex++) {
    if (steps[stepIndex] == step)     break;
  }
  while (++stepIndex < steps.length) {
    step=steps[stepIndex];
    log.debug(""String_Node_Str"" + step);
    if (step == GameDef.OrStep.LAY_TOKEN && company.getNumberOfFreeBaseTokens() == 0) {
      continue;
    }
    if (step == GameDef.OrStep.CALC_REVENUE) {
      if (!company.canRunTrains()) {
        executeSetRevenueAndDividend(new SetDividend(0,false,new int[]{SetDividend.NO_TRAIN}));
        continue;
      }
    }
    if (step == GameDef.OrStep.PAYOUT) {
      continue;
    }
    if (step == GameDef.OrStep.TRADE_SHARES) {
      if (!company.mayTradeShares() || !company.hasOperated()) {
        continue;
      }
      int ownShare=company.getPortfolioModel().getShare(company);
      int poolShare=pool.getShare(company);
      boolean canBuy=ownShare < getGameParameterAsInt(GameDef.Parm.TREASURY_SHARE_LIMIT) && company.getCash() >= company.getCurrentSpace().getPrice() && poolShare > 0;
      boolean canSell=company.getPortfolioModel().getShare(company) > 0 && poolShare < getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT);
      if (!canBuy && !canSell) {
        if (gameManager.isReloading()) {
          gameManager.setSkipDone(GameDef.OrStep.TRADE_SHARES);
          log.debug(""String_Node_Str"");
        }
        log.info(""String_Node_Str"");
        continue;
      }
      gameManager.startTreasuryShareTradingRound();
    }
    if (!gameSpecificNextStep(step))     continue;
    break;
  }
  if (step == GameDef.OrStep.FINAL) {
    finishTurn();
  }
 else {
    setStep(step);
  }
}","/** 
 * Take the next step after a given one (see nextStep()) 
 */
protected void nextStep(GameDef.OrStep step){
  PublicCompany company=operatingCompany.value();
  int stepIndex;
  for (stepIndex=0; stepIndex < steps.length; stepIndex++) {
    if (steps[stepIndex] == step)     break;
  }
  while (++stepIndex < steps.length) {
    step=steps[stepIndex];
    log.debug(""String_Node_Str"" + step);
    if (step == GameDef.OrStep.LAY_TOKEN && company.getNumberOfFreeBaseTokens() == 0) {
      log.debug(""String_Node_Str"" + step + ""String_Node_Str"");
      continue;
    }
    if (step == GameDef.OrStep.CALC_REVENUE) {
      if (!company.canRunTrains()) {
        log.debug(""String_Node_Str"" + step + ""String_Node_Str"");
        executeSetRevenueAndDividend(new SetDividend(0,false,new int[]{SetDividend.NO_TRAIN}));
        continue;
      }
    }
    if (step == GameDef.OrStep.PAYOUT) {
      log.debug(""String_Node_Str"" + step + ""String_Node_Str"");
      continue;
    }
    if (step == GameDef.OrStep.TRADE_SHARES) {
      if (!company.mayTradeShares() || !company.hasOperated()) {
        continue;
      }
      int ownShare=company.getPortfolioModel().getShare(company);
      int poolShare=pool.getShare(company);
      boolean canBuy=ownShare < getGameParameterAsInt(GameDef.Parm.TREASURY_SHARE_LIMIT) && company.getCash() >= company.getCurrentSpace().getPrice() && poolShare > 0;
      boolean canSell=company.getPortfolioModel().getShare(company) > 0 && poolShare < getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT);
      if (!canBuy && !canSell) {
        if (gameManager.isReloading()) {
          gameManager.setSkipDone(GameDef.OrStep.TRADE_SHARES);
          log.debug(""String_Node_Str"");
        }
        log.info(""String_Node_Str"");
        continue;
      }
      gameManager.startTreasuryShareTradingRound();
    }
    if (!gameSpecificNextStep(step)) {
      log.debug(""String_Node_Str"" + step + ""String_Node_Str"");
      continue;
    }
    break;
  }
  if (step == GameDef.OrStep.FINAL) {
    finishTurn();
  }
 else {
    setStep(step);
  }
}",0.9251805985552116
173572,"public void skip(){
  log.debug(""String_Node_Str"" + stepObject.value());
  nextStep();
}","public void skip(NullAction action){
  log.debug(""String_Node_Str"" + stepObject.value());
  ChangeStack.start(this,action);
  nextStep();
}",0.775330396475771
173573,"@Override public boolean process(PossibleAction action){
  boolean result=false;
  doneAllowed=false;
  if (action instanceof PossibleORAction && !(action instanceof DiscardTrain)) {
    PublicCompany company=((PossibleORAction)action).getCompany();
    if (company != operatingCompany.value()) {
      DisplayBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),operatingCompany.value().getId()));
      return false;
    }
  }
  selectedAction=action;
  if (selectedAction instanceof LayTile) {
    result=layTile((LayTile)selectedAction);
  }
 else   if (selectedAction instanceof LayBaseToken) {
    result=layBaseToken((LayBaseToken)selectedAction);
  }
 else   if (selectedAction instanceof LayBonusToken) {
    result=layBonusToken((LayBonusToken)selectedAction);
  }
 else   if (selectedAction instanceof BuyBonusToken) {
    result=buyBonusToken((BuyBonusToken)selectedAction);
  }
 else   if (selectedAction instanceof OperatingCost) {
    result=executeOperatingCost((OperatingCost)selectedAction);
  }
 else   if (selectedAction instanceof SetDividend) {
    result=setRevenueAndDividend((SetDividend)selectedAction);
  }
 else   if (selectedAction instanceof BuyTrain) {
    result=buyTrain((BuyTrain)selectedAction);
  }
 else   if (selectedAction instanceof DiscardTrain) {
    result=discardTrain((DiscardTrain)selectedAction);
  }
 else   if (selectedAction instanceof BuyPrivate) {
    result=buyPrivate((BuyPrivate)selectedAction);
  }
 else   if (selectedAction instanceof ReachDestinations) {
    result=reachDestinations((ReachDestinations)selectedAction);
  }
 else   if (selectedAction instanceof TakeLoans) {
    result=takeLoans((TakeLoans)selectedAction);
  }
 else   if (selectedAction instanceof RepayLoans) {
    result=repayLoans((RepayLoans)selectedAction);
  }
 else   if (selectedAction instanceof ExchangeTokens) {
    result=exchangeTokens((ExchangeTokens)selectedAction,false);
  }
 else   if (selectedAction instanceof ClosePrivate) {
    result=executeClosePrivate((ClosePrivate)selectedAction);
  }
 else   if (selectedAction instanceof UseSpecialProperty && ((UseSpecialProperty)selectedAction).getSpecialProperty() instanceof SpecialRight) {
    result=buyRight((UseSpecialProperty)selectedAction);
  }
 else   if (selectedAction instanceof NullAction) {
    NullAction nullAction=(NullAction)action;
switch (nullAction.getMode()) {
case NullAction.DONE:
case NullAction.PASS:
      result=done(nullAction);
    break;
case NullAction.SKIP:
  skip();
result=true;
break;
}
}
 else if (processGameSpecificAction(action)) {
result=true;
}
 else {
DisplayBuffer.add(LocalText.getText(""String_Node_Str"",selectedAction.toString()));
return false;
}
return result;
}","@Override public boolean process(PossibleAction action){
  boolean result=false;
  doneAllowed=false;
  if (action instanceof PossibleORAction && !(action instanceof DiscardTrain)) {
    PublicCompany company=((PossibleORAction)action).getCompany();
    if (company != operatingCompany.value()) {
      DisplayBuffer.add(LocalText.getText(""String_Node_Str"",company.getId(),operatingCompany.value().getId()));
      return false;
    }
  }
  selectedAction=action;
  if (selectedAction instanceof LayTile) {
    result=layTile((LayTile)selectedAction);
  }
 else   if (selectedAction instanceof LayBaseToken) {
    result=layBaseToken((LayBaseToken)selectedAction);
  }
 else   if (selectedAction instanceof LayBonusToken) {
    result=layBonusToken((LayBonusToken)selectedAction);
  }
 else   if (selectedAction instanceof BuyBonusToken) {
    result=buyBonusToken((BuyBonusToken)selectedAction);
  }
 else   if (selectedAction instanceof OperatingCost) {
    result=executeOperatingCost((OperatingCost)selectedAction);
  }
 else   if (selectedAction instanceof SetDividend) {
    result=setRevenueAndDividend((SetDividend)selectedAction);
  }
 else   if (selectedAction instanceof BuyTrain) {
    result=buyTrain((BuyTrain)selectedAction);
  }
 else   if (selectedAction instanceof DiscardTrain) {
    result=discardTrain((DiscardTrain)selectedAction);
  }
 else   if (selectedAction instanceof BuyPrivate) {
    result=buyPrivate((BuyPrivate)selectedAction);
  }
 else   if (selectedAction instanceof ReachDestinations) {
    result=reachDestinations((ReachDestinations)selectedAction);
  }
 else   if (selectedAction instanceof TakeLoans) {
    result=takeLoans((TakeLoans)selectedAction);
  }
 else   if (selectedAction instanceof RepayLoans) {
    result=repayLoans((RepayLoans)selectedAction);
  }
 else   if (selectedAction instanceof ExchangeTokens) {
    result=exchangeTokens((ExchangeTokens)selectedAction,false);
  }
 else   if (selectedAction instanceof ClosePrivate) {
    result=executeClosePrivate((ClosePrivate)selectedAction);
  }
 else   if (selectedAction instanceof UseSpecialProperty && ((UseSpecialProperty)selectedAction).getSpecialProperty() instanceof SpecialRight) {
    result=buyRight((UseSpecialProperty)selectedAction);
  }
 else   if (selectedAction instanceof NullAction) {
    NullAction nullAction=(NullAction)action;
switch (nullAction.getMode()) {
case NullAction.DONE:
case NullAction.PASS:
      result=done(nullAction);
    break;
case NullAction.SKIP:
  skip(nullAction);
result=true;
break;
}
}
 else if (processGameSpecificAction(action)) {
result=true;
}
 else {
DisplayBuffer.add(LocalText.getText(""String_Node_Str"",selectedAction.toString()));
return false;
}
return result;
}",0.9981597350018404
173574,"@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action instanceof BuyTrain))   return false;
  BuyTrain a=(BuyTrain)action;
  return a.getTrain() == getTrain() && a.from == from && a.fixedCost == fixedCost && a.trainsForExchange == trainsForExchange;
}","@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action instanceof BuyTrain))   return false;
  BuyTrain a=(BuyTrain)action;
  return a.getTrain() == getTrain() && a.from == from && a.fixedCost == fixedCost && Objects.equal(a.trainsForExchange,trainsForExchange);
}",0.9645390070921984
173575,"@Override public String toString(){
  StringBuffer b=new StringBuffer();
  b.append(company.getId());
  if (train != null) {
    b.append(""String_Node_Str"").append(typeName).append(""String_Node_Str"");
  }
 else {
    b.append(""String_Node_Str"");
  }
  b.append(""String_Node_Str"").append(trainUniqueId).append(""String_Node_Str"").append(from.getId());
  if (fixedCost > 0) {
    b.append(""String_Node_Str"").append(Currency.format(train,fixedCost));
  }
 else {
    b.append(""String_Node_Str"");
  }
  if (specialProperty != null) {
    b.append(""String_Node_Str"").append(specialProperty.getOriginalCompany().getId());
  }
  if (isForExchange()) {
    b.append(forcedExchange ? ""String_Node_Str"" : ""String_Node_Str"");
  }
  if (presidentMustAddCash) {
    b.append(""String_Node_Str"").append(Currency.format(train,presidentCashToAdd));
  }
 else   if (presidentMayAddCash) {
    b.append(""String_Node_Str"").append(Currency.format(train,presidentCashToAdd));
  }
  if (acted) {
    b.append(""String_Node_Str"").append(Currency.format(train,pricePaid));
    if (addedCash > 0)     b.append(""String_Node_Str"" + Currency.format(train,addedCash));
    if (exchangedTrain != null)     b.append(""String_Node_Str"" + exchangedTrain.getId() + ""String_Node_Str"");
  }
  return b.toString();
}","@Override public String toString(){
  StringBuffer b=new StringBuffer();
  b.append(company.getId());
  if (train != null) {
    b.append(""String_Node_Str"").append(typeName).append(""String_Node_Str"");
  }
 else {
    b.append(""String_Node_Str"");
  }
  b.append(""String_Node_Str"").append(trainUniqueId).append(""String_Node_Str"").append(from.getId());
  if (fixedCost > 0) {
    b.append(""String_Node_Str"").append(Currency.format(company,fixedCost));
  }
 else {
    b.append(""String_Node_Str"");
  }
  if (specialProperty != null) {
    b.append(""String_Node_Str"").append(specialProperty.getOriginalCompany().getId());
  }
  if (isForExchange()) {
    b.append(forcedExchange ? ""String_Node_Str"" : ""String_Node_Str"");
  }
  if (presidentMustAddCash) {
    b.append(""String_Node_Str"").append(Currency.format(company,presidentCashToAdd));
  }
 else   if (presidentMayAddCash) {
    b.append(""String_Node_Str"").append(Currency.format(company,presidentCashToAdd));
  }
  if (acted) {
    b.append(""String_Node_Str"").append(Currency.format(company,pricePaid));
    if (addedCash > 0)     b.append(""String_Node_Str"" + Currency.format(company,addedCash));
    if (exchangedTrain != null)     b.append(""String_Node_Str"" + exchangedTrain.getId() + ""String_Node_Str"");
  }
  return b.toString();
}",0.9765625
173576,"@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action instanceof DiscardTrain))   return false;
  DiscardTrain a=(DiscardTrain)action;
  return a.ownedTrains == ownedTrains && a.company == company;
}","@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action instanceof DiscardTrain))   return false;
  DiscardTrain a=(DiscardTrain)action;
  return a.ownedTrains.equals(ownedTrains) && a.company == company;
}",0.8653421633554084
173577,"@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action.getClass() == LayTile.class))   return false;
  LayTile a=(LayTile)action;
  return (Objects.equal(a.locationNames,locationNames) && a.type == type && Objects.equal(a.tiles,tiles) && Objects.equal(a.specialProperty,specialProperty));
}","@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action.getClass() == LayTile.class))   return false;
  LayTile a=(LayTile)action;
  return (Objects.equal(a.locationNames,locationNames) && (Objects.equal(a.tiles,tiles) && specialProperty == null || Objects.equal(a.specialProperty,specialProperty) && specialProperty != null));
}",0.8888888888888888
173578,"@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action instanceof MapCorrectionAction))   return false;
  MapCorrectionAction a=(MapCorrectionAction)action;
  return (a.step == this.step);
}","@Override public boolean equalsAsOption(PossibleAction action){
  if (!(action instanceof MapCorrectionAction))   return false;
  return true;
}",0.7932960893854749
173579,"public void initTokens(Set<BaseToken> tokens){
  allTokens=ImmutableSortedSet.copyOf(tokens);
}","/** 
 * Initialize a set of tokens
 */
public void initTokens(Set<BaseToken> tokens){
  allTokens=ImmutableSortedSet.copyOf(tokens);
  Portfolio.moveAll(allTokens,getParent());
}",0.6959706959706959
173580,"/** 
 * Used to identify portfolios on reload
 */
@Deprecated public String getUniqueName(){
  return getParent().getClass().getSimpleName() + ""String_Node_Str"" + getParent().getId();
}","/** 
 * Used to identify portfolios on reload TODO: Remove that in the future
 */
@Deprecated public String getUniqueName(){
  if (getParent() instanceof BankPortfolio) {
    return Bank.class.getSimpleName() + ""String_Node_Str"" + getParent().getId();
  }
  return getParent().getClass().getSimpleName() + ""String_Node_Str"" + getParent().getId();
}",0.6941838649155723
173581,"@Override public String toText(){
  Player president=company.getPresident();
  if (president == null)   return ""String_Node_Str"";
 else   return company.getPresident().getNameAndPriority();
}","@Override public String toText(){
  Player president=getParent().getPresident();
  if (president == null)   return ""String_Node_Str"";
 else   return getParent().getPresident().getNameAndPriority();
}",0.9282051282051282
173582,"@Override public void skip(){
  if (activeSpPrivC.value()) {
    log.debug(""String_Node_Str"");
    ChangeStack.start(this,null);
    activeSpPrivC.set(false);
    stepObject.set(storeActiveStep);
  }
 else {
    super.skip();
  }
}","@Override public void skip(NullAction action){
  if (activeSpPrivC.value()) {
    log.debug(""String_Node_Str"");
    ChangeStack.start(this,null);
    activeSpPrivC.set(false);
    stepObject.set(storeActiveStep);
  }
 else {
    super.skip(action);
  }
}",0.9525773195876288
173583,"/** 
 * Is the company completely sold out? This method should return true only if the share price should move up at the end of a stock round. Since 1851 (jan 2008) interpreted as: no share is owned either by the Bank or by the company's own Treasury.
 * @return true if the share price can move up.
 */
public boolean isSoldOut(){
  Owner owner;
  for (  PublicCertificate cert : certificates.view()) {
    owner=cert.getOwner();
    if (owner instanceof Bank || owner == cert.getCompany()) {
      return false;
    }
  }
  return true;
}","/** 
 * Is the company completely sold out? This method should return true only if the share price should move up at the end of a stock round. Since 1851 (jan 2008) interpreted as: no share is owned either by the Bank or by the company's own Treasury.
 * @return true if the share price can move up.
 */
public boolean isSoldOut(){
  Owner owner;
  for (  PublicCertificate cert : certificates.view()) {
    owner=cert.getOwner();
    if (owner instanceof BankPortfolio || owner == cert.getCompany()) {
      return false;
    }
  }
  return true;
}",0.9917355371900828
173584,"public void move(Owner from,int amount,Owner to){
  Preconditions.checkArgument(from != to,""String_Node_Str"" + to);
  Preconditions.checkArgument(amount > 0,""String_Node_Str"");
  Wallet<T> newWallet=wm.getWallet(type,to);
  Preconditions.checkArgument(newWallet != null,""String_Node_Str"" + to);
  new WalletChange<T>(newWallet,type.cast(this),amount);
  if (from != wm.getUnkownOwner()) {
    Wallet<T> oldWallet=wm.getWallet(type,from);
    Preconditions.checkArgument(oldWallet != null,""String_Node_Str"" + from);
    new WalletChange<T>(oldWallet,type.cast(this),-amount);
  }
}","public void move(Owner from,int amount,Owner to){
  Preconditions.checkArgument(from != to,""String_Node_Str"" + to);
  Preconditions.checkArgument(amount >= 0,""String_Node_Str"");
  Wallet<T> newWallet=wm.getWallet(type,to);
  Preconditions.checkArgument(newWallet != null,""String_Node_Str"" + to);
  new WalletChange<T>(newWallet,type.cast(this),amount);
  if (from != wm.getUnkownOwner()) {
    Wallet<T> oldWallet=wm.getWallet(type,from);
    Preconditions.checkArgument(oldWallet != null,""String_Node_Str"" + from);
    new WalletChange<T>(oldWallet,type.cast(this),-amount);
  }
}",0.9991386735572784
173585,"/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(String playerName){
  String errMsg=null;
  Player player=getCurrentPlayer();
  StartItem auctionItem=(StartItem)auctionItemState.get();
  while (true) {
    if (!playerName.equals(player.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getName());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName));
  moveStack.start(false);
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.intValue() >= auctionItem.getBidders() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getName());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
      setPriorityPlayer();
    }
 else {
      if (GameOption.OPTION_VALUE_YES.equalsIgnoreCase(getGameOption(""String_Node_Str""))) {
        player.unblockCash(auctionItem.getBid(player));
        auctionItem.setBid(-1,player);
      }
      setNextBiddingPlayer(auctionItem,getCurrentPlayerIndex());
    }
  }
 else {
    if (numPasses.intValue() >= numPlayers) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str""));
      if (startPacket.getFirstUnsoldItem() == startPacket.getFirstItem()) {
        startPacket.getFirstItem().reduceBasePriceBy(5);
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",startPacket.getFirstItem().getName(),Bank.format(startPacket.getFirstItem().getBasePrice())));
        numPasses.set(0);
        if (startPacket.getFirstItem().getBasePrice() == 0) {
          assignItem(getCurrentPlayer(),startPacket.getFirstItem(),0,0);
          gameManager.setPriorityPlayer();
        }
      }
 else {
        numPasses.set(0);
        finishRound();
      }
    }
 else     if (auctionItem != null) {
      setNextBiddingPlayer(auctionItem);
    }
 else {
      setNextPlayer();
    }
  }
  return true;
}","/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(String playerName){
  String errMsg=null;
  Player player=getCurrentPlayer();
  StartItem auctionItem=(StartItem)auctionItemState.get();
  while (true) {
    if (!playerName.equals(player.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getName());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName));
  moveStack.start(false);
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.intValue() >= auctionItem.getBidders() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getName());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
      setPriorityPlayer();
    }
 else {
      if (GameOption.OPTION_VALUE_YES.equalsIgnoreCase(getGameOption(""String_Node_Str""))) {
        player.unblockCash(auctionItem.getBid(player));
        auctionItem.setBid(-1,player);
      }
      setNextBiddingPlayer(auctionItem,getCurrentPlayerIndex());
    }
  }
 else {
    if (numPasses.intValue() >= numPlayers) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str""));
      if (startPacket.getFirstUnsoldItem() == startPacket.getFirstItem()) {
        startPacket.getFirstItem().reduceBasePriceBy(5);
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",startPacket.getFirstItem().getName(),Bank.format(startPacket.getFirstItem().getBasePrice())));
        numPasses.set(0);
        if (startPacket.getFirstItem().getBasePrice() == 0) {
          assignItem(getCurrentPlayer(),startPacket.getFirstItem(),0,0);
          gameManager.setPriorityPlayer();
        }
 else {
          setNextPlayer();
        }
      }
 else {
        numPasses.set(0);
        finishRound();
      }
    }
 else     if (auctionItem != null) {
      setNextBiddingPlayer(auctionItem);
    }
 else {
      setNextPlayer();
    }
  }
  return true;
}",0.990374331550802
173586,"public int storeObject(String typeName,Object object){
  Integer id=storageIds.get(typeName);
  if (id == null)   id=0;
  objectStorage.put(typeName + id,object);
  storageIds.put(typeName,id + 1);
  log.debug(""String_Node_Str"" + typeName + ""String_Node_Str""+ id);
  return id;
}","public int storeObject(String typeName,Object object){
  Integer id=storageIds.get(typeName);
  if (id == null)   id=0;
  objectStorage.put(typeName + id,object);
  storageIds.put(typeName,id + 1);
  return id;
}",0.8635437881873728
173587,"public SpecialProperty(){
  gameManager=GameManager.getInstance();
  uniqueId=gameManager.storeObject(STORAGE_NAME,this);
}","public SpecialProperty(){
  gameManager=GameManager.getInstance();
  uniqueId=gameManager.storeObject(STORAGE_NAME,this) + 1;
}",0.984
173588,"public static SpecialPropertyI getByUniqueId(int i){
  return (SpecialPropertyI)GameManager.getInstance().retrieveObject(STORAGE_NAME,i);
}","public static SpecialPropertyI getByUniqueId(int id){
  id-=1;
  return (SpecialPropertyI)GameManager.getInstance().retrieveObject(STORAGE_NAME,id);
}",0.9619377162629758
173589,"/** 
 * Modify the revenue calculation for the civil war by removing the shortest train
 */
public boolean modifyCalculator(RevenueAdapter revenueAdapter){
  if (!isCivilWar())   return false;
  List<NetworkTrain> trains=revenueAdapter.getTrains();
  if (trains.size() == 0)   return false;
  Collections.sort(trains);
  trains.remove(0);
  return true;
}","/** 
 * Modify the revenue calculation for the civil war by removing the shortest train
 */
public boolean modifyCalculator(RevenueAdapter revenueAdapter){
  if (revenueAdapter.getCompany() != this)   return false;
  if (!isCivilWar())   return false;
  List<NetworkTrain> trains=revenueAdapter.getTrains();
  if (trains.size() == 0)   return false;
  Collections.sort(trains);
  trains.remove(0);
  return true;
}",0.9232769830949284
173590,"public void resetStorage(){
  objectStorage=new HashMap<Integer,Object>();
  storageId=0;
}","public void resetStorage(){
  objectStorage=new HashMap<String,Object>();
  storageIds=new HashMap<String,Integer>();
}",0.8095238095238095
173591,"public Object retrieveObject(int id){
  return objectStorage.get(id);
}","public Object retrieveObject(String typeName,int id){
  return objectStorage.get(typeName + id);
}",0.8402366863905325
173592,"public int storeObject(Object object){
  objectStorage.put(storageId++,object);
  return storageId;
}","public int storeObject(String typeName,Object object){
  Integer id=storageIds.get(typeName);
  if (id == null)   id=0;
  objectStorage.put(typeName + id,object);
  storageIds.put(typeName,id + 1);
  log.debug(""String_Node_Str"" + typeName + ""String_Node_Str""+ id);
  return id;
}",0.3473684210526316
173593,"/** 
 * store element in storage
 * @param object to store
 * @return unique id of the object in the storage TODO move to a better place
 */
public int storeObject(Object object);","/** 
 * store element in storage
 * @param name to identify the type of the object to retrieve
 * @param object to store
 * @return unique id of the object in the storage TODO move to a better place
 */
public int storeObject(String typeName,Object object);",0.7568807339449541
173594,"/** 
 * ask storage for object
 * @param identifier in storage
 * @return object stored under the id (null if none is stored)TODO move to a better place
 */
public Object retrieveObject(int id);","/** 
 * ask storage for object
 * @param name to identify the type of the object to retrieve
 * @param identifier in storage
 * @return object stored under the id (null if none is stored)TODO move to a better place
 */
public Object retrieveObject(String typeName,int id);",0.8326180257510729
173595,"public Token(){
  uniqueId=ID_PREFIX + GameManager.getInstance().storeObject(this);
}","public Token(){
  uniqueId=STORAGE_NAME + ""String_Node_Str"" + GameManager.getInstance().storeObject(STORAGE_NAME,this);
}",0.7572815533980582
173596,"public static TokenI getByUniqueId(String id){
  int i=Integer.valueOf(id.replace(ID_PREFIX,""String_Node_Str""));
  return (Token)GameManager.getInstance().retrieveObject(i);
}","public static TokenI getByUniqueId(String id){
  int i=Integer.valueOf(id.replace(STORAGE_NAME + ""String_Node_Str"",""String_Node_Str""));
  return (Token)GameManager.getInstance().retrieveObject(STORAGE_NAME,i);
}",0.8652849740932642
173597,"public SpecialProperty(){
  gameManager=GameManager.getInstance();
  uniqueId=gameManager.storeObject(this);
}","public SpecialProperty(){
  gameManager=GameManager.getInstance();
  uniqueId=gameManager.storeObject(STORAGE_NAME,this);
}",0.944206008583691
173598,"public static SpecialPropertyI getByUniqueId(int i){
  return (SpecialPropertyI)GameManager.getInstance().retrieveObject(i);
}","public static SpecialPropertyI getByUniqueId(int i){
  return (SpecialPropertyI)GameManager.getInstance().retrieveObject(STORAGE_NAME,i);
}",0.9509433962264152
173599,"protected void setUp() throws Exception {
  super.setUp();
  String reportFilename=gamePath + File.separator + gameName+ ""String_Node_Str""+ Config.get(""String_Node_Str"");
  File reportFile=new File(reportFilename);
  if (reportFile.exists()) {
    log.debug(""String_Node_Str"" + reportFilename);
    Scanner reportScanner=new Scanner(new FileReader(reportFilename));
    expectedReport=new ArrayList<String>();
    while (reportScanner.hasNext())     expectedReport.add(reportScanner.nextLine());
    reportScanner.close();
  }
 else {
    log.debug(""String_Node_Str"" + reportFilename);
  }
  String gameFilename=gamePath + File.separator + gameName+ ""String_Node_Str""+ Config.get(""String_Node_Str"");
  File gameFile=new File(gameFilename);
  if (gameFile.exists()) {
    log.debug(""String_Node_Str"" + gameFilename);
    Game testGame=Game.load(gameFilename);
    if (testGame != null)     testReport=ReportBuffer.getAsList();
  }
 else {
    log.error(""String_Node_Str"" + gameFilename);
  }
}","protected void setUp() throws Exception {
  super.setUp();
  String reportFilename=gamePath + File.separator + gameName+ ""String_Node_Str""+ Config.get(""String_Node_Str"");
  File reportFile=new File(reportFilename);
  if (reportFile.exists()) {
    log.debug(""String_Node_Str"" + reportFilename);
    Scanner reportScanner=new Scanner(new FileReader(reportFilename));
    expectedReport=new ArrayList<String>();
    while (reportScanner.hasNext())     expectedReport.add(reportScanner.nextLine());
    reportScanner.close();
  }
 else {
    log.debug(""String_Node_Str"" + reportFilename);
  }
  String gameFilename=gamePath + File.separator + gameName+ ""String_Node_Str""+ Config.get(""String_Node_Str"");
  File gameFile=new File(gameFilename);
  if (gameFile.exists()) {
    log.debug(""String_Node_Str"" + gameFilename);
    Game testGame=Game.load(gameFilename);
    if (testGame != null) {
      testReport=ReportBuffer.getAsList();
      NDC.clear();
    }
  }
 else {
    log.error(""String_Node_Str"" + gameFilename);
  }
}",0.9855936413313464
173600,"private static void prepareGameReport(File gameFile,String reportFilename){
  Game game=null;
  if (gameFile.exists())   System.out.println(""String_Node_Str"" + gameFile.getAbsolutePath());
  game=Game.load(gameFile.getAbsolutePath());
  if (game != null) {
    List<String> report=ReportBuffer.getAsList();
    PrintWriter reportFile=null;
    try {
      reportFile=new PrintWriter(reportFilename);
    }
 catch (    IOException e) {
      System.err.print(""String_Node_Str"" + reportFilename + ""String_Node_Str"");
    }
    if (reportFile != null) {
      for (      String msg : report) {
        reportFile.println(msg);
      }
      reportFile.close();
      System.out.println(""String_Node_Str"" + reportFilename);
    }
  }
}","private static void prepareGameReport(File gameFile,String reportFilename){
  Game game=null;
  if (gameFile.exists())   System.out.println(""String_Node_Str"" + gameFile.getAbsolutePath());
  game=Game.load(gameFile.getAbsolutePath());
  if (game != null) {
    List<String> report=ReportBuffer.getAsList();
    NDC.clear();
    PrintWriter reportFile=null;
    try {
      reportFile=new PrintWriter(reportFilename);
    }
 catch (    IOException e) {
      System.err.print(""String_Node_Str"" + reportFilename + ""String_Node_Str"");
    }
    if (reportFile != null) {
      for (      String msg : report) {
        reportFile.println(msg);
      }
      reportFile.close();
      System.out.println(""String_Node_Str"" + reportFilename);
    }
  }
}",0.9885057471264368
173601,"public void removeTrain(TrainI train){
  trains.remove(train);
  trainsPerType.get(train.getPreviousType()).remove(train);
  trainsPerCertType.get(train.getCertType()).remove(train);
  train.setHolder(null);
  trainsModel.update();
}","/** 
 * Low-level method, only to be called by Move objects 
 */
private void removeTrain(TrainI train){
  trains.remove(train);
  trainsPerType.get(train.getPreviousType()).remove(train);
  trainsPerCertType.get(train.getCertType()).remove(train);
  train.setHolder(null);
  trainsModel.update();
}",0.150375939849624
173602,"/** 
 * Add a special property. Used to make special properties independent of the private company that originally held it.
 * @param property The special property object to add.
 * @return True if successful.
 */
public boolean addSpecialProperty(SpecialPropertyI property,int position){
  if (specialProperties == null) {
    specialProperties=new ArrayList<SpecialPropertyI>(2);
  }
  boolean result=Util.addToList(specialProperties,property,position);
  if (!result)   return false;
  property.setHolder(this);
  if (owner instanceof PublicCompanyI && property instanceof LocatedBonus) {
    PublicCompanyI company=(PublicCompanyI)owner;
    LocatedBonus locBonus=(LocatedBonus)property;
    Bonus bonus=new Bonus(company,locBonus.getName(),locBonus.getValue(),locBonus.getLocations());
    company.addBonus(bonus);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",owner.getName(),locBonus.getName(),Bank.format(locBonus.getValue()),locBonus.getLocationNameString()));
  }
  return result;
}","/** 
 * Add a special property. Used to make special properties independent of the private company that originally held it. Low-level method, only to be called by Move objects.
 * @param property The special property object to add.
 * @return True if successful.
 */
private boolean addSpecialProperty(SpecialPropertyI property,int position){
  if (specialProperties == null) {
    specialProperties=new ArrayList<SpecialPropertyI>(2);
  }
  boolean result=Util.addToList(specialProperties,property,position);
  if (!result)   return false;
  property.setHolder(this);
  if (owner instanceof PublicCompanyI && property instanceof LocatedBonus) {
    PublicCompanyI company=(PublicCompanyI)owner;
    LocatedBonus locBonus=(LocatedBonus)property;
    Bonus bonus=new Bonus(company,locBonus.getName(),locBonus.getValue(),locBonus.getLocations());
    company.addBonus(bonus);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",owner.getName(),locBonus.getName(),Bank.format(locBonus.getValue()),locBonus.getLocationNameString()));
  }
  return result;
}",0.9689320388349516
173603,"/** 
 * Remove an object.
 * @param object The object to remove.
 * @return True if successful.
 */
public boolean removeObject(Moveable object){
  if (object instanceof PublicCertificateI) {
    removeCertificate((PublicCertificateI)object);
    return true;
  }
 else   if (object instanceof PrivateCompanyI) {
    removePrivate((PrivateCompanyI)object);
    return true;
  }
 else   if (object instanceof TrainI) {
    removeTrain((TrainI)object);
    return true;
  }
 else   if (object instanceof SpecialPropertyI) {
    return removeSpecialProperty((SpecialPropertyI)object);
  }
 else   if (object instanceof TokenI) {
    return removeToken((TokenI)object);
  }
 else {
    return false;
  }
}","/** 
 * Remove an object. Low-level method, only to be called by Move objects.
 * @param object The object to remove.
 * @return True if successful.
 */
public boolean removeObject(Moveable object){
  if (object instanceof PublicCertificateI) {
    removeCertificate((PublicCertificateI)object);
    return true;
  }
 else   if (object instanceof PrivateCompanyI) {
    removePrivate((PrivateCompanyI)object);
    return true;
  }
 else   if (object instanceof TrainI) {
    removeTrain((TrainI)object);
    return true;
  }
 else   if (object instanceof SpecialPropertyI) {
    return removeSpecialProperty((SpecialPropertyI)object);
  }
 else   if (object instanceof TokenI) {
    return removeToken((TokenI)object);
  }
 else {
    return false;
  }
}",0.963573883161512
173604,"public boolean removeToken(TokenI token){
  return tokens.remove(token);
}","/** 
 * Low-level method, only to be called by the local addObject() method. 
 */
public boolean removeToken(TokenI token){
  return tokens.remove(token);
}",0.6434782608695652
173605,"public void addCertificate(PublicCertificateI certificate,int[] position){
  if (certificate.isPresidentShare())   position=new int[]{0,0,0};
  Util.addToList(certificates,certificate,position[0]);
  String companyName=certificate.getCompany().getName();
  if (!certPerCompany.containsKey(companyName)) {
    certPerCompany.put(companyName,new ArrayList<PublicCertificateI>());
  }
  Util.addToList(certPerCompany.get(companyName),certificate,position[1]);
  String certTypeId=certificate.getTypeId();
  if (!certsPerType.containsKey(certTypeId)) {
    certsPerType.put(certTypeId,new ArrayList<PublicCertificateI>());
  }
  Util.addToList(certsPerType.get(certTypeId),certificate,position[2]);
  certificate.setPortfolio(this);
  getShareModel(certificate.getCompany()).addShare(certificate.getShare());
  if (owner instanceof Player) {
    ((Player)owner).updateWorth();
  }
}","/** 
 * Low-level method, only to be called by the local addObject() method. 
 */
private void addCertificate(PublicCertificateI certificate,int[] position){
  if (certificate.isPresidentShare())   position=new int[]{0,0,0};
  Util.addToList(certificates,certificate,position[0]);
  String companyName=certificate.getCompany().getName();
  if (!certPerCompany.containsKey(companyName)) {
    certPerCompany.put(companyName,new ArrayList<PublicCertificateI>());
  }
  Util.addToList(certPerCompany.get(companyName),certificate,position[1]);
  String certTypeId=certificate.getTypeId();
  if (!certsPerType.containsKey(certTypeId)) {
    certsPerType.put(certTypeId,new ArrayList<PublicCertificateI>());
  }
  Util.addToList(certsPerType.get(certTypeId),certificate,position[2]);
  certificate.setPortfolio(this);
  getShareModel(certificate.getCompany()).addShare(certificate.getShare());
  updatePlayerWorth();
}",0.9139664804469274
173606,"public void addPrivate(PrivateCompanyI privateCompany,int position){
  if (!Util.addToList(privateCompanies,privateCompany,position))   return;
  privateCompany.setHolder(this);
  log.debug(""String_Node_Str"" + privateCompany.getName() + ""String_Node_Str""+ name);
  if (privateCompany.getSpecialProperties() != null) {
    log.debug(privateCompany.getName() + ""String_Node_Str"");
  }
 else {
    log.debug(privateCompany.getName() + ""String_Node_Str"");
  }
  privatesOwnedModel.update();
}","/** 
 * Low-level method, only to be called by the local addObject() method and by initialisation code. 
 */
public void addPrivate(PrivateCompanyI privateCompany,int position){
  if (!Util.addToList(privateCompanies,privateCompany,position))   return;
  privateCompany.setHolder(this);
  log.debug(""String_Node_Str"" + privateCompany.getName() + ""String_Node_Str""+ name);
  if (privateCompany.getSpecialProperties() != null) {
    log.debug(privateCompany.getName() + ""String_Node_Str"");
  }
 else {
    log.debug(privateCompany.getName() + ""String_Node_Str"");
  }
  privatesOwnedModel.update();
  updatePlayerWorth();
}",0.8808664259927798
173607,"public boolean removePrivate(PrivateCompanyI privateCompany){
  boolean removed=privateCompanies.remove(privateCompany);
  if (removed) {
    privatesOwnedModel.update();
  }
  return removed;
}","/** 
 * Low-level method, only to be called by the local addObject() method. 
 */
private boolean removePrivate(PrivateCompanyI privateCompany){
  boolean removed=privateCompanies.remove(privateCompany);
  if (removed) {
    privatesOwnedModel.update();
    updatePlayerWorth();
  }
  return removed;
}",0.7620967741935484
173608,"public void addTrain(TrainI train,int[] position){
  Util.addToList(trains,train,position[0]);
  TrainType type=train.getType();
  if (!trainsPerType.containsKey(type)) {
    trainsPerType.put(type,new ArrayList<TrainI>());
  }
  Util.addToList(trainsPerType.get(type),train,position[1]);
  TrainCertificateType certType=train.getCertType();
  if (!trainsPerCertType.containsKey(certType)) {
    trainsPerCertType.put(certType,new ArrayList<TrainI>());
  }
  Util.addToList(trainsPerCertType.get(certType),train,position[2]);
  train.setHolder(this);
  trainsModel.update();
}","/** 
 * Low-level method, only to be called by the local addObject() method. 
 */
private void addTrain(TrainI train,int[] position){
  Util.addToList(trains,train,position[0]);
  TrainType type=train.getType();
  if (!trainsPerType.containsKey(type)) {
    trainsPerType.put(type,new ArrayList<TrainI>());
  }
  Util.addToList(trainsPerType.get(type),train,position[1]);
  TrainCertificateType certType=train.getCertType();
  if (!trainsPerCertType.containsKey(certType)) {
    trainsPerCertType.put(certType,new ArrayList<TrainI>());
  }
  Util.addToList(trainsPerCertType.get(certType),train,position[2]);
  train.setHolder(this);
  trainsModel.update();
}",0.9246963562753036
173609,"/** 
 * Remove a special property.
 * @param property The special property object to remove.
 * @return True if successful.
 */
public boolean removeSpecialProperty(SpecialPropertyI property){
  boolean result=false;
  if (specialProperties != null) {
    result=specialProperties.remove(property);
    if (owner instanceof PublicCompanyI && property instanceof LocatedBonus) {
      PublicCompanyI company=(PublicCompanyI)owner;
      LocatedBonus locBonus=(LocatedBonus)property;
      company.removeBonus(locBonus.getName());
    }
  }
  return result;
}","/** 
 * Remove a special property. Low-level method, only to be called by Move objects.
 * @param property The special property object to remove.
 * @return True if successful.
 */
private boolean removeSpecialProperty(SpecialPropertyI property){
  boolean result=false;
  if (specialProperties != null) {
    result=specialProperties.remove(property);
    if (owner instanceof PublicCompanyI && property instanceof LocatedBonus) {
      PublicCompanyI company=(PublicCompanyI)owner;
      LocatedBonus locBonus=(LocatedBonus)property;
      company.removeBonus(locBonus.getName());
    }
  }
  return result;
}",0.9452054794520548
173610,"public boolean addToken(TokenI token,int position){
  return Util.addToList(tokens,token,position);
}","/** 
 * Low-level method, only to be called by the local addObject() method. 
 */
public boolean addToken(TokenI token,int position){
  return Util.addToList(tokens,token,position);
}",0.7112676056338029
173611,"/** 
 * Add an object.
 * @param object The object to add.
 * @return True if successful.
 */
public boolean addObject(Moveable object,int[] position){
  if (object instanceof PublicCertificateI) {
    if (position == null)     position=new int[]{-1,-1,-1};
    addCertificate((PublicCertificateI)object,position);
    return true;
  }
 else   if (object instanceof PrivateCompanyI) {
    addPrivate((PrivateCompanyI)object,position == null ? -1 : position[0]);
    return true;
  }
 else   if (object instanceof TrainI) {
    if (position == null)     position=new int[]{-1,-1,-1};
    addTrain((TrainI)object,position);
    return true;
  }
 else   if (object instanceof SpecialPropertyI) {
    return addSpecialProperty((SpecialPropertyI)object,position == null ? -1 : position[0]);
  }
 else   if (object instanceof TokenI) {
    return addToken((TokenI)object,position == null ? -1 : position[0]);
  }
 else {
    return false;
  }
}","/** 
 * Add an object. Low-level method, only to be called by Move objects.
 * @param object The object to add.
 * @return True if successful.
 */
public boolean addObject(Moveable object,int[] position){
  if (object instanceof PublicCertificateI) {
    if (position == null)     position=new int[]{-1,-1,-1};
    addCertificate((PublicCertificateI)object,position);
    return true;
  }
 else   if (object instanceof PrivateCompanyI) {
    addPrivate((PrivateCompanyI)object,position == null ? -1 : position[0]);
    return true;
  }
 else   if (object instanceof TrainI) {
    if (position == null)     position=new int[]{-1,-1,-1};
    addTrain((TrainI)object,position);
    return true;
  }
 else   if (object instanceof SpecialPropertyI) {
    return addSpecialProperty((SpecialPropertyI)object,position == null ? -1 : position[0]);
  }
 else   if (object instanceof TokenI) {
    return addToken((TokenI)object,position == null ? -1 : position[0]);
  }
 else {
    return false;
  }
}",0.9725246241575948
173612,"public void removeCertificate(PublicCertificateI certificate){
  certificates.remove(certificate);
  String companyName=certificate.getCompany().getName();
  List<PublicCertificateI> certs=getCertificatesPerCompany(companyName);
  certs.remove(certificate);
  String certTypeId=certificate.getTypeId();
  if (certsPerType.containsKey(certTypeId)) {
    certsPerType.get(certTypeId).remove(0);
    if (certsPerType.get(certTypeId).isEmpty()) {
      certsPerType.remove(certTypeId);
    }
  }
  getShareModel(certificate.getCompany()).addShare(-certificate.getShare());
  if (owner instanceof Player) {
    ((Player)owner).updateWorth();
  }
}","/** 
 * Low-level method, only to be called by the local addObject() method. 
 */
private void removeCertificate(PublicCertificateI certificate){
  certificates.remove(certificate);
  String companyName=certificate.getCompany().getName();
  List<PublicCertificateI> certs=getCertificatesPerCompany(companyName);
  certs.remove(certificate);
  String certTypeId=certificate.getTypeId();
  if (certsPerType.containsKey(certTypeId)) {
    certsPerType.get(certTypeId).remove(0);
    if (certsPerType.get(certTypeId).isEmpty()) {
      certsPerType.remove(certTypeId);
    }
  }
  getShareModel(certificate.getCompany()).addShare(-certificate.getShare());
  updatePlayerWorth();
}",0.6676783004552352
173613,"public boolean addToken(TokenI token,int position);","/** 
 * Add a token. Subclasses may override this method to implement side effects.
 * @param token The token object to add.
 * @return True if successful.
 */
public boolean addToken(TokenI token,int position);",0.3893129770992366
173614,"public boolean layTile(LayTile action){
  String errMsg=null;
  int cost=0;
  SpecialTileLay stl=null;
  boolean extra=false;
  PublicCompanyI company=action.getCompany();
  String companyName=company.getName();
  TileI tile=action.getLaidTile();
  MapHex hex=action.getChosenHex();
  int orientation=action.getOrientation();
  while (true) {
    if (!companyName.equals(operatingCompany.get().getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,operatingCompany.get().getName());
      break;
    }
    if (getStep() != GameDef.OrStep.LAY_TRACK) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (tile == null)     break;
    if (!getCurrentPhase().isTileColourAllowed(tile.getColourName())) {
      errMsg=LocalText.getText(""String_Node_Str"",tile.getExternalId());
      break;
    }
    if (tile.countFreeTiles() == 0) {
      errMsg=LocalText.getText(""String_Node_Str"",tile.getExternalId());
      break;
    }
    if (action != null) {
      List<TileI> tiles=action.getTiles();
      if (tiles != null && !tiles.isEmpty() && !tiles.contains(tile)) {
        errMsg=LocalText.getText(""String_Node_Str"",tile.getExternalId(),hex.getName());
        break;
      }
      stl=action.getSpecialProperty();
      if (stl != null)       extra=stl.isExtra();
    }
    if (!extra && !validateNormalTileLay(tile)) {
      errMsg=LocalText.getText(""String_Node_Str"",tile.getColourName());
      break;
    }
    if (stl != null && stl.isFree()) {
      cost=0;
    }
 else {
      cost=hex.getTileCost();
    }
    if (cost < 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(cost));
      break;
    }
    if (cost % 10 != 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(cost));
      break;
    }
    if (cost > operatingCompany.get().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,Bank.format(operatingCompany.get().getCash()),Bank.format(cost));
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,tile.getExternalId(),hex.getName(),Bank.format(cost),errMsg));
    return false;
  }
  moveStack.start(true);
  if (tile != null) {
    if (cost > 0)     new CashMove(operatingCompany.get(),bank,cost);
    operatingCompany.get().layTile(hex,tile,orientation,cost);
    if (cost == 0) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,tile.getExternalId(),hex.getName(),hex.getOrientationName(orientation)));
    }
 else {
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,tile.getExternalId(),hex.getName(),hex.getOrientationName(orientation),Bank.format(cost)));
    }
    hex.upgrade(action);
    if (stl != null) {
      stl.setExercised();
      currentSpecialTileLays.remove(action);
      log.debug(""String_Node_Str"" + (extra ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
    if (!extra) {
      log.debug(""String_Node_Str"");
      registerNormalTileLay(tile);
    }
    setSpecialTileLays();
    log.debug(""String_Node_Str"" + currentSpecialTileLays.size() + ""String_Node_Str"");
  }
  if (tile == null || currentNormalTileLays.isEmpty() && currentSpecialTileLays.isEmpty()) {
    nextStep();
  }
  return true;
}","public boolean layTile(LayTile action){
  String errMsg=null;
  int cost=0;
  SpecialTileLay stl=null;
  boolean extra=false;
  PublicCompanyI company=action.getCompany();
  String companyName=company.getName();
  TileI tile=action.getLaidTile();
  MapHex hex=action.getChosenHex();
  int orientation=action.getOrientation();
  while (true) {
    if (!companyName.equals(operatingCompany.get().getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,operatingCompany.get().getName());
      break;
    }
    if (getStep() != GameDef.OrStep.LAY_TRACK) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (tile == null)     break;
    if (!getCurrentPhase().isTileColourAllowed(tile.getColourName())) {
      errMsg=LocalText.getText(""String_Node_Str"",tile.getExternalId());
      break;
    }
    if (tile.countFreeTiles() == 0) {
      errMsg=LocalText.getText(""String_Node_Str"",tile.getExternalId());
      break;
    }
    if (action != null) {
      List<TileI> tiles=action.getTiles();
      if (tiles != null && !tiles.isEmpty() && !tiles.contains(tile)) {
        errMsg=LocalText.getText(""String_Node_Str"",tile.getExternalId(),hex.getName());
        break;
      }
      stl=action.getSpecialProperty();
      if (stl != null)       extra=stl.isExtra();
    }
    if (!extra && !validateNormalTileLay(tile)) {
      errMsg=LocalText.getText(""String_Node_Str"",tile.getColourName());
      break;
    }
    if (stl != null && stl.isFree()) {
      cost=0;
    }
 else {
      cost=hex.getTileCost();
    }
    if (cost < 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(cost));
      break;
    }
    if (cost % 10 != 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(cost));
      break;
    }
    if (cost > operatingCompany.get().getCash()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,Bank.format(operatingCompany.get().getCash()),Bank.format(cost));
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,tile.getExternalId(),hex.getName(),Bank.format(cost),errMsg));
    return false;
  }
  moveStack.start(true);
  if (tile != null) {
    if (cost > 0)     new CashMove(operatingCompany.get(),bank,cost);
    operatingCompany.get().layTile(hex,tile,orientation,cost);
    if (cost == 0) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,tile.getExternalId(),hex.getName(),hex.getOrientationName(orientation)));
    }
 else {
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,tile.getExternalId(),hex.getName(),hex.getOrientationName(orientation),Bank.format(cost)));
    }
    hex.upgrade(action);
    if (stl != null) {
      stl.setExercised();
      log.debug(""String_Node_Str"" + (extra ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
    if (!extra) {
      log.debug(""String_Node_Str"");
      registerNormalTileLay(tile);
    }
  }
  if (tile == null || !areTileLaysPossible()) {
    nextStep();
  }
  return true;
}",0.9498422712933754
173615,"/** 
 * Create a List of allowed normal tile lays (see LayTile class). This method should be called only once per company turn in an OR: at the start of the tile laying step.
 */
protected void getNormalTileLays(){
  Map<String,Integer> newTileColours=new HashMap<String,Integer>(getCurrentPhase().getTileColours());
  for (  String colour : newTileColours.keySet()) {
    int allowedNumber=operatingCompany.get().getNumberOfTileLays(colour);
    newTileColours.put(colour,new Integer(allowedNumber));
  }
  tileLaysPerColour.initFromMap(newTileColours);
}","protected List<LayTile> getNormalTileLays(boolean display){
  List<LayTile> currentNormalTileLays=new ArrayList<LayTile>();
  Map<String,Integer> remainingTileLaysPerColour=new HashMap<String,Integer>();
  int lays=0;
  for (  String colourName : tileLaysPerColour.viewKeySet()) {
    lays=tileLaysPerColour.get(colourName);
    if (lays != 0) {
      remainingTileLaysPerColour.put(colourName,lays);
    }
  }
  if (!remainingTileLaysPerColour.isEmpty()) {
    currentNormalTileLays.add(new LayTile(remainingTileLaysPerColour));
  }
  if (display) {
    int size=currentNormalTileLays.size();
    if (size == 0) {
      log.debug(""String_Node_Str"");
    }
 else {
      for (      LayTile tileLay : currentNormalTileLays) {
        log.debug(""String_Node_Str"" + tileLay.toString());
      }
    }
  }
  return currentNormalTileLays;
}",0.1380301941049604
173616,"/** 
 * To be called after each change, to re-establish the currently allowed actions. (new method, intended to absorb code from several other methods).
 */
@Override public boolean setPossibleActions(){
  possibleActions.clear();
  selectedAction=null;
  boolean forced=false;
  doneAllowed=false;
  if (getStep() == GameDef.OrStep.INITIAL) {
    initTurn();
    if (noMapMode) {
      nextStep(GameDef.OrStep.LAY_TOKEN);
    }
 else {
      getNormalTileLays();
      setStep(GameDef.OrStep.LAY_TRACK);
    }
  }
  GameDef.OrStep step=getStep();
  if (step == GameDef.OrStep.LAY_TRACK) {
    if (!operatingCompany.get().hasLaidHomeBaseTokens()) {
      possibleActions.add(new LayBaseToken(operatingCompany.get().getHomeHex()));
      forced=true;
    }
 else {
      setNormalTileLays();
      setSpecialTileLays();
      log.debug(""String_Node_Str"" + currentNormalTileLays.size());
      log.debug(""String_Node_Str"" + currentSpecialTileLays.size());
      possibleActions.addAll(currentNormalTileLays);
      possibleActions.addAll(currentSpecialTileLays);
      possibleActions.add(new NullAction(NullAction.SKIP));
    }
  }
 else   if (step == GameDef.OrStep.LAY_TOKEN) {
    setNormalTokenLays();
    setSpecialTokenLays();
    log.debug(""String_Node_Str"" + currentNormalTokenLays.size());
    log.debug(""String_Node_Str"" + currentSpecialTokenLays.size());
    possibleActions.addAll(currentNormalTokenLays);
    possibleActions.addAll(currentSpecialTokenLays);
    possibleActions.add(new NullAction(NullAction.SKIP));
  }
 else   if (step == GameDef.OrStep.CALC_REVENUE) {
    prepareRevenueAndDividendAction();
    if (noMapMode)     prepareNoMapActions();
  }
 else   if (step == GameDef.OrStep.BUY_TRAIN) {
    setBuyableTrains();
    doneAllowed=true;
    if (noMapMode && (operatingCompany.get().getLastRevenue() == 0))     prepareNoMapActions();
  }
 else   if (step == GameDef.OrStep.DISCARD_TRAINS) {
    forced=true;
    setTrainsToDiscard();
  }
  if (!forced) {
    setBonusTokenLays();
    setDestinationActions();
    setGameSpecificPossibleActions();
    for (    PrivateCompanyI priv : companyManager.getAllPrivateCompanies()) {
      if (!priv.isClosed() && priv.closesManually())       possibleActions.add(new ClosePrivate(priv));
    }
    if (getCurrentPhase().isPrivateSellingAllowed()) {
      int currentPlayerIndex=operatingCompany.get().getPresident().getIndex();
      Player player;
      int minPrice, maxPrice;
      List<Player> players=getPlayers();
      int numberOfPlayers=getNumberOfPlayers();
      for (int i=currentPlayerIndex; i < currentPlayerIndex + numberOfPlayers; i++) {
        player=players.get(i % numberOfPlayers);
        for (        PrivateCompanyI privComp : player.getPortfolio().getPrivateCompanies()) {
          minPrice=(int)(privComp.getBasePrice() * operatingCompany.get().getLowerPrivatePriceFactor());
          maxPrice=(int)(privComp.getBasePrice() * operatingCompany.get().getUpperPrivatePriceFactor());
          possibleActions.add(new BuyPrivate(privComp,minPrice,maxPrice));
        }
      }
    }
    if (operatingCompany.get().canUseSpecialProperties()) {
      List<SpecialPropertyI> commonSP=gameManager.getCommonSpecialProperties();
      if (commonSP != null) {
        SellBonusToken sbt;
        loop:         for (        SpecialPropertyI sp : commonSP) {
          if (sp instanceof SellBonusToken) {
            sbt=(SellBonusToken)sp;
            if (operatingCompany.get().getBonuses() != null) {
              for (              Bonus bonus : operatingCompany.get().getBonuses()) {
                if (bonus.getName().equals(sp.getName()))                 continue loop;
              }
            }
            possibleActions.add(new BuyBonusToken(sbt));
          }
        }
      }
      List<SpecialPropertyI> orsps=operatingCompany.get().getPortfolio().getAllSpecialProperties();
      if (orsps != null) {
        for (        SpecialPropertyI sp : orsps) {
          if (!sp.isExercised() && sp.isUsableIfOwnedByCompany() && sp.isUsableDuringOR()) {
            if (sp instanceof SpecialTokenLay) {
              if (getStep() != GameDef.OrStep.LAY_TOKEN) {
                possibleActions.add(new LayBaseToken((SpecialTokenLay)sp));
              }
            }
 else {
              possibleActions.add(new UseSpecialProperty(sp));
            }
          }
        }
      }
      orsps=getCurrentPlayer().getPortfolio().getAllSpecialProperties();
      if (orsps != null) {
        for (        SpecialPropertyI sp : orsps) {
          if (!sp.isExercised() && sp.isUsableIfOwnedByPlayer() && sp.isUsableDuringOR()) {
            if (sp instanceof SpecialTokenLay) {
              if (getStep() != GameDef.OrStep.LAY_TOKEN) {
                possibleActions.add(new LayBaseToken((SpecialTokenLay)sp));
              }
            }
 else {
              possibleActions.add(new UseSpecialProperty(sp));
            }
          }
        }
      }
    }
  }
  if (doneAllowed) {
    possibleActions.add(new NullAction(NullAction.DONE));
  }
  for (  PossibleAction pa : possibleActions.getList()) {
    try {
      log.debug(operatingCompany.get().getName() + ""String_Node_Str"" + pa.toString());
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"" + pa.getClass(),e);
    }
  }
  return true;
}","/** 
 * To be called after each change, to re-establish the currently allowed actions. (new method, intended to absorb code from several other methods).
 */
@Override public boolean setPossibleActions(){
  possibleActions.clear();
  selectedAction=null;
  boolean forced=false;
  doneAllowed=false;
  if (getStep() == GameDef.OrStep.INITIAL) {
    initTurn();
    if (noMapMode) {
      nextStep(GameDef.OrStep.LAY_TOKEN);
    }
 else {
      initNormalTileLays();
      setStep(GameDef.OrStep.LAY_TRACK);
    }
  }
  GameDef.OrStep step=getStep();
  if (step == GameDef.OrStep.LAY_TRACK) {
    if (!operatingCompany.get().hasLaidHomeBaseTokens()) {
      possibleActions.add(new LayBaseToken(operatingCompany.get().getHomeHex()));
      forced=true;
    }
 else {
      possibleActions.addAll(getNormalTileLays(true));
      possibleActions.addAll(getSpecialTileLays(true));
      possibleActions.add(new NullAction(NullAction.SKIP));
    }
  }
 else   if (step == GameDef.OrStep.LAY_TOKEN) {
    setNormalTokenLays();
    setSpecialTokenLays();
    log.debug(""String_Node_Str"" + currentNormalTokenLays.size());
    log.debug(""String_Node_Str"" + currentSpecialTokenLays.size());
    possibleActions.addAll(currentNormalTokenLays);
    possibleActions.addAll(currentSpecialTokenLays);
    possibleActions.add(new NullAction(NullAction.SKIP));
  }
 else   if (step == GameDef.OrStep.CALC_REVENUE) {
    prepareRevenueAndDividendAction();
    if (noMapMode)     prepareNoMapActions();
  }
 else   if (step == GameDef.OrStep.BUY_TRAIN) {
    setBuyableTrains();
    doneAllowed=true;
    if (noMapMode && (operatingCompany.get().getLastRevenue() == 0))     prepareNoMapActions();
  }
 else   if (step == GameDef.OrStep.DISCARD_TRAINS) {
    forced=true;
    setTrainsToDiscard();
  }
  if (!forced) {
    setBonusTokenLays();
    setDestinationActions();
    setGameSpecificPossibleActions();
    for (    PrivateCompanyI priv : companyManager.getAllPrivateCompanies()) {
      if (!priv.isClosed() && priv.closesManually())       possibleActions.add(new ClosePrivate(priv));
    }
    if (getCurrentPhase().isPrivateSellingAllowed()) {
      int currentPlayerIndex=operatingCompany.get().getPresident().getIndex();
      Player player;
      int minPrice, maxPrice;
      List<Player> players=getPlayers();
      int numberOfPlayers=getNumberOfPlayers();
      for (int i=currentPlayerIndex; i < currentPlayerIndex + numberOfPlayers; i++) {
        player=players.get(i % numberOfPlayers);
        for (        PrivateCompanyI privComp : player.getPortfolio().getPrivateCompanies()) {
          minPrice=(int)(privComp.getBasePrice() * operatingCompany.get().getLowerPrivatePriceFactor());
          maxPrice=(int)(privComp.getBasePrice() * operatingCompany.get().getUpperPrivatePriceFactor());
          possibleActions.add(new BuyPrivate(privComp,minPrice,maxPrice));
        }
      }
    }
    if (operatingCompany.get().canUseSpecialProperties()) {
      List<SpecialPropertyI> commonSP=gameManager.getCommonSpecialProperties();
      if (commonSP != null) {
        SellBonusToken sbt;
        loop:         for (        SpecialPropertyI sp : commonSP) {
          if (sp instanceof SellBonusToken) {
            sbt=(SellBonusToken)sp;
            if (operatingCompany.get().getBonuses() != null) {
              for (              Bonus bonus : operatingCompany.get().getBonuses()) {
                if (bonus.getName().equals(sp.getName()))                 continue loop;
              }
            }
            possibleActions.add(new BuyBonusToken(sbt));
          }
        }
      }
      List<SpecialPropertyI> orsps=operatingCompany.get().getPortfolio().getAllSpecialProperties();
      if (orsps != null) {
        for (        SpecialPropertyI sp : orsps) {
          if (!sp.isExercised() && sp.isUsableIfOwnedByCompany() && sp.isUsableDuringOR()) {
            if (sp instanceof SpecialTokenLay) {
              if (getStep() != GameDef.OrStep.LAY_TOKEN) {
                possibleActions.add(new LayBaseToken((SpecialTokenLay)sp));
              }
            }
 else {
              possibleActions.add(new UseSpecialProperty(sp));
            }
          }
        }
      }
      orsps=getCurrentPlayer().getPortfolio().getAllSpecialProperties();
      if (orsps != null) {
        for (        SpecialPropertyI sp : orsps) {
          if (!sp.isExercised() && sp.isUsableIfOwnedByPlayer() && sp.isUsableDuringOR()) {
            if (sp instanceof SpecialTokenLay) {
              if (getStep() != GameDef.OrStep.LAY_TOKEN) {
                possibleActions.add(new LayBaseToken((SpecialTokenLay)sp));
              }
            }
 else {
              possibleActions.add(new UseSpecialProperty(sp));
            }
          }
        }
      }
    }
  }
  if (doneAllowed) {
    possibleActions.add(new NullAction(NullAction.DONE));
  }
  for (  PossibleAction pa : possibleActions.getList()) {
    try {
      log.debug(operatingCompany.get().getName() + ""String_Node_Str"" + pa.toString());
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"" + pa.getClass(),e);
    }
  }
  return true;
}",0.9688905906001724
173617,"protected boolean checkNormalTileLay(TileI tile,boolean update){
  String colour=tile.getColourName();
  Integer oldAllowedNumberObject=tileLaysPerColour.get(colour);
  if (oldAllowedNumberObject == null)   return false;
  int oldAllowedNumber=oldAllowedNumberObject.intValue();
  if (oldAllowedNumber <= 0)   return false;
  if (!update)   return true;
  if (oldAllowedNumber <= 1) {
    for (    String key : tileLaysPerColour.viewKeySet()) {
      tileLaysPerColour.put(key,new Integer(0));
    }
    log.debug(""String_Node_Str"");
    currentNormalTileLays.clear();
  }
 else {
    for (    String key : tileLaysPerColour.viewKeySet()) {
      if (colour.equals(key)) {
        tileLaysPerColour.put(colour,new Integer(oldAllowedNumber - 1));
      }
 else {
        tileLaysPerColour.put(key,new Integer(0));
      }
    }
    log.debug((oldAllowedNumber - 1) + ""String_Node_Str"" + colour+ ""String_Node_Str"");
  }
  return true;
}","protected boolean checkNormalTileLay(TileI tile,boolean update){
  String colour=tile.getColourName();
  Integer oldAllowedNumberObject=tileLaysPerColour.get(colour);
  if (oldAllowedNumberObject == null)   return false;
  int oldAllowedNumber=oldAllowedNumberObject.intValue();
  if (oldAllowedNumber <= 0)   return false;
  if (update)   updateAllowedTileColours(colour,oldAllowedNumber);
  return true;
}",0.511558538404176
173618,"public void setTileColours(Map<String,Integer> map){
  tileColours=new HashMap<String,Integer>();
  for (  String colourName : map.keySet()) {
    if (map.get(colourName) > 0)     tileColours.put(colourName,map.get(colourName));
  }
}","public void setTileColours(Map<String,Integer> map){
  tileColours=new HashMap<String,Integer>();
  if (map != null) {
    for (    String colourName : map.keySet()) {
      if (map.get(colourName) > 0)       tileColours.put(colourName,map.get(colourName));
    }
  }
}",0.9145129224652088
173619,"@Override public boolean undo(){
  if (keyExisted) {
    map.put(key,oldValue);
  }
  return true;
}","@Override public boolean undo(){
  if (keyExisted) {
    map.put(key,oldValue);
  }
 else {
    map.remove(key);
  }
  return true;
}",0.8583690987124464
173620,"public String toString(){
  return ""String_Node_Str"" + key + ""String_Node_Str"";
}","public String toString(){
  return ""String_Node_Str"" + key + ""String_Node_Str""+ oldValue+ ""String_Node_Str"";
}",0.8481675392670157
173621,"/** 
 * Creates a move that removes key from map
 */
public RemoveFromMap(Map<K,V> map,K key){
  this.map=map;
  this.key=key;
  this.keyExisted=map.containsKey(key);
  MoveSet.add(this);
}","/** 
 * Creates a move that removes key from map
 */
public RemoveFromMap(Map<K,V> map,K key){
  keyExisted=map.containsKey(key);
  if (!keyExisted)   return;
  this.map=map;
  this.key=key;
  this.oldValue=map.get(key);
  MoveSet.add(this);
}",0.7037037037037037
173622,"public void clear(){
  for (  K key : map.keySet()) {
    remove(key);
  }
}","public void clear(){
  List<K> keys=new ArrayList<K>();
  for (  K key : map.keySet()) {
    keys.add(key);
  }
  for (  K key : keys) {
    remove(key);
  }
}",0.6468085106382979
173623,"public void finishConfiguration(GameManagerI gameManager) throws ConfigurationException {
  this.gameManager=gameManager;
  bank=gameManager.getBank();
  ipo=bank.getIpo();
  unavailable=bank.getUnavailable();
  for (  TrainTypeI type : lTrainTypes) {
    type.finishConfiguration(gameManager);
  }
  newTypeIndex.set(0);
  lTrainTypes.get(newTypeIndex.intValue()).setAvailable(bank);
  if (removeTrain) {
    gameManager.setGameParameter(GameDef.Parm.REMOVE_TRAIN_BEFORE_SR,true);
  }
}","public void finishConfiguration(GameManagerI gameManager) throws ConfigurationException {
  this.gameManager=gameManager;
  bank=gameManager.getBank();
  ipo=bank.getIpo();
  unavailable=bank.getUnavailable();
  for (  TrainTypeI type : lTrainTypes) {
    type.finishConfiguration(gameManager);
  }
  newTypeIndex.set(0);
  lTrainTypes.get(newTypeIndex.intValue()).setAvailable(bank);
  if (removeTrain) {
    gameManager.setGameParameter(GameDef.Parm.REMOVE_TRAIN_BEFORE_SR,true);
  }
  gameManager.setGameParameter(GameDef.Parm.FIXED_PRICE_TRAINS_BETWEEN_PRESIDENTS,trainPriceAtFaceValueIfDifferentPresidents);
}",0.8846503178928247
173624,"/** 
 * @see rails.game.ConfigurableComponentI#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Tag tag) throws ConfigurationException {
  TrainType defaultType=null;
  TrainType newType;
  Tag defaultsTag=tag.getChild(""String_Node_Str"");
  if (defaultsTag != null) {
    defaultType=new TrainType(false);
    defaultType.configureFromXML(defaultsTag);
  }
  List<Tag> typeTags=tag.getChildren(""String_Node_Str"");
  for (  Tag typeTag : typeTags) {
    if (defaultType != null) {
      newType=(TrainType)defaultType.clone();
      if (newType == null) {
        throw new ConfigurationException(""String_Node_Str"" + defaultType.getName());
      }
    }
 else {
      newType=new TrainType(true);
    }
    lTrainTypes.add(newType);
    newType.configureFromXML(typeTag);
    mTrainTypes.put(newType.getName(),newType);
  }
  Tag rulesTag=tag.getChild(""String_Node_Str"");
  if (rulesTag != null) {
    gameManager.setGameParameter(GameDef.Parm.FIXED_PRICE_TRAINS_BETWEEN_PRESIDENTS,rulesTag.getChild(""String_Node_Str"") != null);
  }
  for (  TrainTypeI type : lTrainTypes) {
    if (type.getReleasedTrainTypeNames() != null) {
      List<TrainTypeI> rtts=new ArrayList<TrainTypeI>(2);
      for (      String ttName : type.getReleasedTrainTypeNames().split(""String_Node_Str"")) {
        rtts.add(mTrainTypes.get(ttName));
      }
      type.setReleasedTrainTypes(rtts);
    }
    if (type.getRustedTrainTypeName() != null) {
      type.setRustedTrainType(mTrainTypes.get(type.getRustedTrainTypeName()));
      mTrainTypes.get(type.getRustedTrainTypeName()).setPermanent(false);
    }
  }
  Tag removeTrainTag=tag.getChild(""String_Node_Str"");
  if (removeTrainTag != null) {
    removeTrain=true;
  }
}","/** 
 * @see rails.game.ConfigurableComponentI#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Tag tag) throws ConfigurationException {
  TrainType defaultType=null;
  TrainType newType;
  Tag defaultsTag=tag.getChild(""String_Node_Str"");
  if (defaultsTag != null) {
    defaultType=new TrainType(false);
    defaultType.configureFromXML(defaultsTag);
  }
  List<Tag> typeTags=tag.getChildren(""String_Node_Str"");
  for (  Tag typeTag : typeTags) {
    if (defaultType != null) {
      newType=(TrainType)defaultType.clone();
      if (newType == null) {
        throw new ConfigurationException(""String_Node_Str"" + defaultType.getName());
      }
    }
 else {
      newType=new TrainType(true);
    }
    lTrainTypes.add(newType);
    newType.configureFromXML(typeTag);
    mTrainTypes.put(newType.getName(),newType);
  }
  Tag rulesTag=tag.getChild(""String_Node_Str"");
  if (rulesTag != null) {
    trainPriceAtFaceValueIfDifferentPresidents=rulesTag.getChild(""String_Node_Str"") != null;
  }
  for (  TrainTypeI type : lTrainTypes) {
    if (type.getReleasedTrainTypeNames() != null) {
      List<TrainTypeI> rtts=new ArrayList<TrainTypeI>(2);
      for (      String ttName : type.getReleasedTrainTypeNames().split(""String_Node_Str"")) {
        rtts.add(mTrainTypes.get(ttName));
      }
      type.setReleasedTrainTypes(rtts);
    }
    if (type.getRustedTrainTypeName() != null) {
      type.setRustedTrainType(mTrainTypes.get(type.getRustedTrainTypeName()));
      mTrainTypes.get(type.getRustedTrainTypeName()).setPermanent(false);
    }
  }
  Tag removeTrainTag=tag.getChild(""String_Node_Str"");
  if (removeTrainTag != null) {
    removeTrain=true;
  }
}",0.96537558685446
173625,"public List<PublicCompanyI> setOperatingCompanies(List<PublicCompanyI> oldOperatingCompanies,PublicCompanyI lastOperatingCompany){
  Map<Integer,PublicCompanyI> operatingCompanies=new TreeMap<Integer,PublicCompanyI>();
  StockSpaceI space;
  int key;
  int minorNo=0;
  boolean reorder=gameManager.isDynamicOperatingOrder() && oldOperatingCompanies != null && lastOperatingCompany != null;
  int lastOperatingCompanyIndex;
  if (reorder) {
    lastOperatingCompanyIndex=oldOperatingCompanies.indexOf(lastOperatingCompany);
  }
 else {
    lastOperatingCompanyIndex=-1;
  }
  for (  PublicCompanyI company : companyManager.getAllPublicCompanies()) {
    if (!canCompanyOperateThisRound(company))     continue;
    if (reorder && oldOperatingCompanies.indexOf(company) <= lastOperatingCompanyIndex) {
      key=oldOperatingCompanies.indexOf(company);
    }
 else     if (company.hasStockPrice()) {
      space=company.getCurrentSpace();
      key=1000000 * (999 - space.getPrice()) + 10000 * (99 - space.getColumn()) + 100 * (space.getRow() + 1) + space.getStackPosition(company);
    }
 else {
      key=50 + ++minorNo;
    }
    operatingCompanies.put(new Integer(key),company);
  }
  return new ArrayList<PublicCompanyI>(operatingCompanies.values());
}","public List<PublicCompanyI> setOperatingCompanies(List<PublicCompanyI> oldOperatingCompanies,PublicCompanyI lastOperatingCompany){
  Map<Integer,PublicCompanyI> operatingCompanies=new TreeMap<Integer,PublicCompanyI>();
  List<PublicCompanyI> newOperatingCompanies;
  StockSpaceI space;
  int key;
  int minorNo=0;
  boolean reorder=gameManager.isDynamicOperatingOrder() && oldOperatingCompanies != null && lastOperatingCompany != null;
  int lastOperatingCompanyIndex;
  if (reorder) {
    newOperatingCompanies=oldOperatingCompanies;
    lastOperatingCompanyIndex=oldOperatingCompanies.indexOf(lastOperatingCompany);
  }
 else {
    newOperatingCompanies=companyManager.getAllPublicCompanies();
    lastOperatingCompanyIndex=-1;
  }
  for (  PublicCompanyI company : newOperatingCompanies) {
    if (!reorder && !canCompanyOperateThisRound(company))     continue;
    if (reorder && oldOperatingCompanies.indexOf(company) <= lastOperatingCompanyIndex) {
      key=oldOperatingCompanies.indexOf(company);
    }
 else     if (company.hasStockPrice()) {
      space=company.getCurrentSpace();
      key=1000000 * (999 - space.getPrice()) + 10000 * (99 - space.getColumn()) + 100 * (space.getRow() + 1) + space.getStackPosition(company);
    }
 else {
      key=50 + ++minorNo;
    }
    operatingCompanies.put(new Integer(key),company);
  }
  return new ArrayList<PublicCompanyI>(operatingCompanies.values());
}",0.912847483095417
173626,"public StartRoundWindow(StartRound round,GameUIManager parent){
  super();
  this.round=round;
  includeBidding=round.hasBidding();
  showBasePrices=round.hasBasePrices();
  gameUIManager=parent;
  setTitle(LocalText.getText(""String_Node_Str""));
  getContentPane().setLayout(new BorderLayout());
  statusPanel=new JPanel();
  gb=new GridBagLayout();
  statusPanel.setLayout(gb);
  statusPanel.setBorder(BorderFactory.createEtchedBorder());
  statusPanel.setOpaque(true);
  buttonPanel=new JPanel();
  buyButton=new ActionButton(LocalText.getText(""String_Node_Str""));
  buyButton.setMnemonic(KeyEvent.VK_B);
  buyButton.addActionListener(this);
  buyButton.setEnabled(false);
  buttonPanel.add(buyButton);
  if (includeBidding) {
    bidButton=new ActionButton(LocalText.getText(""String_Node_Str"") + ""String_Node_Str"");
    bidButton.setMnemonic(KeyEvent.VK_D);
    bidButton.addActionListener(this);
    bidButton.setEnabled(false);
    buttonPanel.add(bidButton);
    spinnerModel=new SpinnerNumberModel(new Integer(999),new Integer(0),null,new Integer(1));
    bidAmount=new JSpinner(spinnerModel);
    bidAmount.setPreferredSize(new Dimension(50,28));
    bidAmount.setEnabled(false);
    buttonPanel.add(bidAmount);
  }
  passButton=new ActionButton(LocalText.getText(""String_Node_Str""));
  passButton.setMnemonic(KeyEvent.VK_P);
  passButton.addActionListener(this);
  passButton.setEnabled(false);
  buttonPanel.add(passButton);
  buttonPanel.setOpaque(true);
  gbc=new GridBagConstraints();
  players=gameUIManager.getGameManager().getPlayers().toArray(new Player[0]);
  np=GameManager.getInstance().getNumberOfPlayers();
  packet=round.getStartPacket();
  crossIndex=new int[packet.getNumberOfItems()];
  items=round.getStartItems().toArray(new StartItem[0]);
  ni=items.length;
  StartItem item;
  for (int i=0; i < ni; i++) {
    item=items[i];
    crossIndex[item.getIndex()]=i;
  }
  actionableItems=new StartItemAction[ni];
  infoIcon=createInfoIcon();
  init();
  getContentPane().add(statusPanel,BorderLayout.NORTH);
  getContentPane().add(buttonPanel,BorderLayout.SOUTH);
  setTitle(""String_Node_Str"");
  setLocation(300,150);
  setSize(275,325);
  setVisible(true);
  requestFocus();
  addKeyListener(this);
  pack();
}","public StartRoundWindow(StartRound round,GameUIManager parent){
  super();
  this.round=round;
  includeBidding=round.hasBidding();
  showBasePrices=round.hasBasePrices();
  gameUIManager=parent;
  setTitle(LocalText.getText(""String_Node_Str""));
  getContentPane().setLayout(new BorderLayout());
  statusPanel=new JPanel();
  gb=new GridBagLayout();
  statusPanel.setLayout(gb);
  statusPanel.setBorder(BorderFactory.createEtchedBorder());
  statusPanel.setOpaque(true);
  buttonPanel=new JPanel();
  buyButton=new ActionButton(LocalText.getText(""String_Node_Str""));
  buyButton.setMnemonic(KeyEvent.VK_B);
  buyButton.addActionListener(this);
  buyButton.setEnabled(false);
  buttonPanel.add(buyButton);
  if (includeBidding) {
    bidButton=new ActionButton(LocalText.getText(""String_Node_Str"") + ""String_Node_Str"");
    bidButton.setMnemonic(KeyEvent.VK_D);
    bidButton.addActionListener(this);
    bidButton.setEnabled(false);
    buttonPanel.add(bidButton);
    spinnerModel=new SpinnerNumberModel(new Integer(999),new Integer(0),null,new Integer(1));
    bidAmount=new JSpinner(spinnerModel);
    bidAmount.setPreferredSize(new Dimension(50,28));
    bidAmount.setEnabled(false);
    buttonPanel.add(bidAmount);
  }
  passButton=new ActionButton(LocalText.getText(""String_Node_Str""));
  passButton.setMnemonic(KeyEvent.VK_P);
  passButton.addActionListener(this);
  passButton.setEnabled(false);
  buttonPanel.add(passButton);
  buttonPanel.setOpaque(true);
  gbc=new GridBagConstraints();
  players=gameUIManager.getGameManager().getPlayers().toArray(new Player[0]);
  np=gameUIManager.getGameManager().getNumberOfPlayers();
  packet=round.getStartPacket();
  crossIndex=new int[packet.getNumberOfItems()];
  items=round.getStartItems().toArray(new StartItem[0]);
  ni=items.length;
  StartItem item;
  for (int i=0; i < ni; i++) {
    item=items[i];
    crossIndex[item.getIndex()]=i;
  }
  actionableItems=new StartItemAction[ni];
  infoIcon=createInfoIcon();
  init();
  getContentPane().add(statusPanel,BorderLayout.NORTH);
  getContentPane().add(buttonPanel,BorderLayout.SOUTH);
  setTitle(""String_Node_Str"");
  setLocation(300,150);
  setSize(275,325);
  setVisible(true);
  requestFocus();
  addKeyListener(this);
  pack();
}",0.9935224480679026
173627,"public void endOfGameReport(){
  GameManagerI gm=GameManager.getInstance();
  if (gm.getGameOverReportedUI())   return;
 else   gm.setGameOverReportedUI(true);
  JOptionPane.showMessageDialog(this,LocalText.getText(""String_Node_Str""),LocalText.getText(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
  List<String> gameReport=GameManager.getInstance().getGameReport();
  Collections.reverse(gameReport);
  StringBuilder report=new StringBuilder();
  for (  String s : gameReport) {
    report.insert(0,s + ""String_Node_Str"");
    JOptionPane.showMessageDialog(this,report,LocalText.getText(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
  }
}","public void endOfGameReport(){
  GameManagerI gm=gameUIManager.getGameManager();
  if (gm.getGameOverReportedUI())   return;
 else   gm.setGameOverReportedUI(true);
  JOptionPane.showMessageDialog(this,LocalText.getText(""String_Node_Str""),LocalText.getText(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
  List<String> gameReport=gm.getGameReport();
  Collections.reverse(gameReport);
  StringBuilder report=new StringBuilder();
  for (  String s : gameReport) {
    report.insert(0,s + ""String_Node_Str"");
    JOptionPane.showMessageDialog(this,report,LocalText.getText(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
  }
}",0.9556962025316456
173628,"public void keyPressed(KeyEvent e){
  if (e.getKeyCode() == KeyEvent.VK_F1) {
    HelpWindow.displayHelp(GameManager.getInstance().getHelp());
    e.consume();
  }
}","public void keyPressed(KeyEvent e){
  if (e.getKeyCode() == KeyEvent.VK_F1) {
    HelpWindow.displayHelp(gameUIManager.getGameManager().getHelp());
    e.consume();
  }
}",0.9134328358208956
173629,"public void paint(Graphics g){
  Graphics2D g2=(Graphics2D)g;
  if (getAntialias()) {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  }
 else {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
  }
  Color terrainColor=Color.WHITE;
  if (isSelected()) {
    g2.setColor(highlightColor);
    g2.fill(hexagon);
    g2.setColor(terrainColor);
    g2.fill(innerHexagonSelected);
    g2.setColor(Color.black);
    g2.draw(innerHexagonSelected);
  }
 else   if (isSelectable()) {
    g2.setColor(selectableColor);
    g2.fill(hexagon);
    g2.setColor(terrainColor);
    g2.fill(innerHexagonSelectable);
    g2.setColor(Color.black);
    g2.draw(innerHexagonSelectable);
  }
  paintOverlay(g2);
  paintStationTokens(g2);
  paintOffStationTokens(g2);
  FontMetrics fontMetrics=g2.getFontMetrics();
  if (getHexModel().getTileCost() > 0) {
    g2.drawString(Bank.format(getHexModel().getTileCost()),rectBound.x + (rectBound.width - fontMetrics.stringWidth(Integer.toString(getHexModel().getTileCost()))) * 3 / 5,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 9 / 15));
  }
  Map<PublicCompanyI,City> homes=getHexModel().getHomes();
  if (homes != null) {
    City homeCity;
    Point p;
    for (    PublicCompanyI company : homes.keySet()) {
      if (company.isClosed())       continue;
      if (model.hasTokenOfCompany(company))       continue;
      homeCity=homes.get(company);
      if (homeCity == null) {
        List<City> cities=getHexModel().getCities();
        for (        City city : cities) {
          if (city.hasTokenSlotsLeft()) {
            homeCity=city;
            break;
          }
        }
      }
      p=getTokenCenter(1,homeCity.getTokens().size(),getHexModel().getCities().size(),homeCity.getNumber() - 1);
      drawHome(g2,company,p);
    }
  }
  if (getHexModel().isBlockedForTileLays()) {
    List<PrivateCompanyI> privates=GameManager.getInstance().getCompanyManager().getAllPrivateCompanies();
    for (    PrivateCompanyI p : privates) {
      List<MapHex> blocked=p.getBlockedHexes();
      if (blocked != null) {
        for (        MapHex hex : blocked) {
          if (getHexModel().equals(hex)) {
            String text=""String_Node_Str"" + p.getName() + ""String_Node_Str"";
            g2.drawString(text,rectBound.x + (rectBound.width - fontMetrics.stringWidth(text)) * 1 / 2,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 5 / 15));
          }
        }
      }
    }
  }
  if (model.isReservedForCompany() && currentTileId == model.getPreprintedTileId()) {
    String text=""String_Node_Str"" + model.getReservedForCompany() + ""String_Node_Str"";
    g2.drawString(text,rectBound.x + (rectBound.width - fontMetrics.stringWidth(text)) * 1 / 2,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 5 / 25));
  }
}","public void paint(Graphics g){
  Graphics2D g2=(Graphics2D)g;
  if (getAntialias()) {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  }
 else {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
  }
  Color terrainColor=Color.WHITE;
  if (isSelected()) {
    g2.setColor(highlightColor);
    g2.fill(hexagon);
    g2.setColor(terrainColor);
    g2.fill(innerHexagonSelected);
    g2.setColor(Color.black);
    g2.draw(innerHexagonSelected);
  }
 else   if (isSelectable()) {
    g2.setColor(selectableColor);
    g2.fill(hexagon);
    g2.setColor(terrainColor);
    g2.fill(innerHexagonSelectable);
    g2.setColor(Color.black);
    g2.draw(innerHexagonSelectable);
  }
  paintOverlay(g2);
  paintStationTokens(g2);
  paintOffStationTokens(g2);
  FontMetrics fontMetrics=g2.getFontMetrics();
  if (getHexModel().getTileCost() > 0) {
    g2.drawString(Bank.format(getHexModel().getTileCost()),rectBound.x + (rectBound.width - fontMetrics.stringWidth(Integer.toString(getHexModel().getTileCost()))) * 3 / 5,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 9 / 15));
  }
  Map<PublicCompanyI,City> homes=getHexModel().getHomes();
  if (homes != null) {
    City homeCity;
    Point p;
    for (    PublicCompanyI company : homes.keySet()) {
      if (company.isClosed())       continue;
      if (model.hasTokenOfCompany(company))       continue;
      homeCity=homes.get(company);
      if (homeCity == null) {
        List<City> cities=getHexModel().getCities();
        for (        City city : cities) {
          if (city.hasTokenSlotsLeft()) {
            homeCity=city;
            break;
          }
        }
      }
      p=getTokenCenter(1,homeCity.getTokens().size(),getHexModel().getCities().size(),homeCity.getNumber() - 1);
      drawHome(g2,company,p);
    }
  }
  if (getHexModel().isBlockedForTileLays()) {
    List<PrivateCompanyI> privates=hexMap.getOrUIManager().getGameUIManager().getGameManager().getCompanyManager().getAllPrivateCompanies();
    for (    PrivateCompanyI p : privates) {
      List<MapHex> blocked=p.getBlockedHexes();
      if (blocked != null) {
        for (        MapHex hex : blocked) {
          if (getHexModel().equals(hex)) {
            String text=""String_Node_Str"" + p.getName() + ""String_Node_Str"";
            g2.drawString(text,rectBound.x + (rectBound.width - fontMetrics.stringWidth(text)) * 1 / 2,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 5 / 15));
          }
        }
      }
    }
  }
  if (model.isReservedForCompany() && currentTileId == model.getPreprintedTileId()) {
    String text=""String_Node_Str"" + model.getReservedForCompany() + ""String_Node_Str"";
    g2.drawString(text,rectBound.x + (rectBound.width - fontMetrics.stringWidth(text)) * 1 / 2,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 5 / 25));
  }
}",0.9899792674498964
173630,"public int getOperatingCompanyIndex(){
  return operatingCompanies.indexOf(getOperatingCompany());
}","public int getOperatingCompanyIndex(){
  int index=operatingCompanies.indexOf(getOperatingCompany());
  return index;
}",0.8584474885844748
173631,"public AddToList(List<E> list,E object,String listName){
  this(list,object,listName,null);
}","public AddToList(List<E> list,E object,int index,String listName){
  this.object=object;
  this.list=list;
  this.listName=listName;
  this.index=index;
  MoveSet.add(this);
}",0.6119402985074627
173632,"public void add(int index,E element){
  new AddToList<E>(list,element,listName).atIndex(index);
}","public void add(int index,E element){
  new AddToList<E>(list,element,index,listName);
}",0.8864864864864865
173633,"public boolean isTileColourAllowed(String tileColour){
  return tileColours.containsKey(tileColour);
}","public boolean isTileColourAllowed(String tileColour){
  return tileColours != null && tileColours.containsKey(tileColour) && tileColours.get(tileColour) > 0;
}",0.7786259541984732
173634,"public void setTileColours(Map<String,Integer> map){
  tileColours=map;
}","public void setTileColours(Map<String,Integer> map){
  tileColours=new HashMap<String,Integer>();
  for (  String colourName : map.keySet()) {
    if (map.get(colourName) > 0)     tileColours.put(colourName,map.get(colourName));
  }
}",0.4560260586319218
173635,"public void populate(){
  if (hexMap == null)   hexMap=orUIManager.getMapPanel().getMap();
  GUIHex uiHex=hexMap.getSelectedHex();
  MapHex hex=uiHex.getHexModel();
  orUIManager.tileUpgrades=new ArrayList<TileI>();
  List<TileI> tiles;
  for (  LayTile layTile : hexMap.getTileAllowancesForHex(hex)) {
    tiles=layTile.getTiles();
    if (tiles == null) {
      for (      TileI tile : uiHex.getCurrentTile().getValidUpgrades(hex,orUIManager.gameUIManager.getCurrentPhase())) {
        if (!orUIManager.tileUpgrades.contains(tile))         orUIManager.tileUpgrades.add(tile);
      }
    }
 else {
      for (      TileI tile : tiles) {
        if (tile.getColourNumber() <= uiHex.getCurrentTile().getColourNumber())         continue;
        if (!orUIManager.tileUpgrades.contains(tile))         orUIManager.tileUpgrades.add(tile);
      }
    }
  }
}","public void populate(){
  if (hexMap == null)   hexMap=orUIManager.getMapPanel().getMap();
  GUIHex uiHex=hexMap.getSelectedHex();
  MapHex hex=uiHex.getHexModel();
  orUIManager.tileUpgrades=new ArrayList<TileI>();
  List<TileI> tiles;
  for (  LayTile layTile : hexMap.getTileAllowancesForHex(hex)) {
    tiles=layTile.getTiles();
    if (tiles == null) {
      for (      TileI tile : uiHex.getCurrentTile().getValidUpgrades(hex,orUIManager.gameUIManager.getCurrentPhase())) {
        if (!layTile.isTileColourAllowed(tile.getColourName()))         continue;
        if (!orUIManager.tileUpgrades.contains(tile))         orUIManager.tileUpgrades.add(tile);
      }
    }
 else {
      for (      TileI tile : tiles) {
        if (layTile.getTileColours().get(tile.getColourName()) < 1)         continue;
        if (!layTile.isTileColourAllowed(tile.getColourName()))         continue;
        if (!orUIManager.tileUpgrades.contains(tile))         orUIManager.tileUpgrades.add(tile);
      }
    }
  }
}",0.789247311827957
173636,"public void setSkipDone(){
  skipNextDone=true;
}","public void setSkipDone(GameDef.OrStep step){
  skipNextDone=true;
  skippedStep=step;
}",0.7153284671532847
173637,"public boolean processOnReload(PossibleAction action) throws Exception {
  DisplayBuffer.clear();
  if (gameName.equals(""String_Node_Str"") && possibleActions.contains(RepayLoans.class) && (!possibleActions.contains(action.getClass()) || (action.getClass() == NullAction.class && ((NullAction)action).getMode() != NullAction.DONE))) {
    log.debug(""String_Node_Str"");
    getCurrentRound().process(new NullAction(NullAction.DONE));
    possibleActions.clear();
    getCurrentRound().setPossibleActions();
    if (!isGameOver())     setCorrectionActions();
  }
  try {
    log.debug(""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action);
    boolean doProcess=true;
    log.debug(""String_Node_Str"" + skipNextDone);
    if (skipNextDone) {
      if (action instanceof NullAction && ((NullAction)action).getMode() == NullAction.DONE) {
        log.info(""String_Node_Str"");
        doProcess=false;
      }
    }
    skipNextDone=false;
    if (doProcess && !processCorrectionActions(action) && !getCurrentRound().process(action)) {
      String msg=""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action.toString()+ ""String_Node_Str""+ getCurrentRound().getRoundName()+ ""String_Node_Str"";
      log.error(msg);
      DisplayBuffer.add(msg);
      if (moveStack.isOpen())       moveStack.finish();
      return false;
    }
    possibleActions.clear();
    getCurrentRound().setPossibleActions();
    String playerName=getCurrentPlayer().getName();
    for (    PossibleAction a : possibleActions.getList()) {
      log.debug(playerName + ""String_Node_Str"" + a.toString());
    }
    if (!isGameOver())     setCorrectionActions();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + action.toString(),e);
    throw new Exception(""String_Node_Str"",e);
  }
  new AddToList<PossibleAction>(executedActions,action,""String_Node_Str"");
  if (moveStack.isOpen())   moveStack.finish();
  log.debug(""String_Node_Str"" + getCurrentPlayer().getName());
  return true;
}","public boolean processOnReload(PossibleAction action) throws Exception {
  DisplayBuffer.clear();
  if (gameName.equals(""String_Node_Str"") && possibleActions.contains(RepayLoans.class) && (!possibleActions.contains(action.getClass()) || (action.getClass() == NullAction.class && ((NullAction)action).getMode() != NullAction.DONE))) {
    log.debug(""String_Node_Str"");
    getCurrentRound().process(new NullAction(NullAction.DONE));
    possibleActions.clear();
    getCurrentRound().setPossibleActions();
    if (!isGameOver())     setCorrectionActions();
  }
  try {
    log.debug(""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action);
    boolean doProcess=true;
    if (skipNextDone) {
      if (action instanceof NullAction && ((NullAction)action).getMode() == NullAction.DONE) {
        if (currentRound.get() instanceof OperatingRound && ((OperatingRound)currentRound.get()).getStep() == skippedStep) {
          doProcess=false;
        }
      }
    }
    skipNextDone=false;
    skippedStep=null;
    if (doProcess && !processCorrectionActions(action) && !getCurrentRound().process(action)) {
      String msg=""String_Node_Str"" + action.getPlayerName() + ""String_Node_Str""+ action.toString()+ ""String_Node_Str""+ getCurrentRound().getRoundName()+ ""String_Node_Str"";
      log.error(msg);
      DisplayBuffer.add(msg);
      if (moveStack.isOpen())       moveStack.finish();
      return false;
    }
    possibleActions.clear();
    getCurrentRound().setPossibleActions();
    String playerName=getCurrentPlayer().getName();
    for (    PossibleAction a : possibleActions.getList()) {
      log.debug(playerName + ""String_Node_Str"" + a.toString());
    }
    if (!isGameOver())     setCorrectionActions();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + action.toString(),e);
    throw new Exception(""String_Node_Str"",e);
  }
  new AddToList<PossibleAction>(executedActions,action,""String_Node_Str"");
  if (moveStack.isOpen())   moveStack.finish();
  log.debug(""String_Node_Str"" + getCurrentPlayer().getName());
  return true;
}",0.9441849028768132
173638,public void setSkipDone();,public void setSkipDone(GameDef.OrStep step);,0.7323943661971831
173639,"/** 
 * Take the next step after a given one (see nextStep()) 
 */
protected void nextStep(GameDef.OrStep step){
  PublicCompanyI company=operatingCompany.get();
  int stepIndex;
  for (stepIndex=0; stepIndex < steps.length; stepIndex++) {
    if (steps[stepIndex] == step)     break;
  }
  while (++stepIndex < steps.length) {
    step=steps[stepIndex];
    log.debug(""String_Node_Str"" + step);
    if (step == GameDef.OrStep.LAY_TOKEN && company.getNumberOfFreeBaseTokens() == 0) {
      continue;
    }
    if (step == GameDef.OrStep.CALC_REVENUE) {
      if (!company.canRunTrains()) {
        executeSetRevenueAndDividend(new SetDividend(0,false,new int[]{SetDividend.NO_TRAIN}));
        continue;
      }
    }
    if (step == GameDef.OrStep.PAYOUT) {
      continue;
    }
    if (step == GameDef.OrStep.TRADE_SHARES) {
      if (!company.mayTradeShares() || !company.hasOperated()) {
        continue;
      }
      int ownShare=company.getPortfolio().getShare(company);
      int poolShare=pool.getShare(company);
      boolean canBuy=ownShare < getGameParameterAsInt(GameDef.Parm.TREASURY_SHARE_LIMIT) && company.getCash() >= company.getCurrentSpace().getPrice() && poolShare > 0;
      boolean canSell=company.getPortfolio().getShare(company) > 0 && poolShare < getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT);
      if (!canBuy && !canSell) {
        if (gameManager.isReloading()) {
          gameManager.setSkipDone();
          log.debug(""String_Node_Str"");
        }
        log.info(""String_Node_Str"");
        continue;
      }
      gameManager.startTreasuryShareTradingRound();
    }
    if (!gameSpecificNextStep(step))     continue;
    break;
  }
  if (step == GameDef.OrStep.FINAL) {
    finishTurn();
  }
 else {
    setStep(step);
  }
}","/** 
 * Take the next step after a given one (see nextStep()) 
 */
protected void nextStep(GameDef.OrStep step){
  PublicCompanyI company=operatingCompany.get();
  int stepIndex;
  for (stepIndex=0; stepIndex < steps.length; stepIndex++) {
    if (steps[stepIndex] == step)     break;
  }
  while (++stepIndex < steps.length) {
    step=steps[stepIndex];
    log.debug(""String_Node_Str"" + step);
    if (step == GameDef.OrStep.LAY_TOKEN && company.getNumberOfFreeBaseTokens() == 0) {
      continue;
    }
    if (step == GameDef.OrStep.CALC_REVENUE) {
      if (!company.canRunTrains()) {
        executeSetRevenueAndDividend(new SetDividend(0,false,new int[]{SetDividend.NO_TRAIN}));
        continue;
      }
    }
    if (step == GameDef.OrStep.PAYOUT) {
      continue;
    }
    if (step == GameDef.OrStep.TRADE_SHARES) {
      if (!company.mayTradeShares() || !company.hasOperated()) {
        continue;
      }
      int ownShare=company.getPortfolio().getShare(company);
      int poolShare=pool.getShare(company);
      boolean canBuy=ownShare < getGameParameterAsInt(GameDef.Parm.TREASURY_SHARE_LIMIT) && company.getCash() >= company.getCurrentSpace().getPrice() && poolShare > 0;
      boolean canSell=company.getPortfolio().getShare(company) > 0 && poolShare < getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT);
      if (!canBuy && !canSell) {
        if (gameManager.isReloading()) {
          gameManager.setSkipDone(GameDef.OrStep.TRADE_SHARES);
          log.debug(""String_Node_Str"");
        }
        log.info(""String_Node_Str"");
        continue;
      }
      gameManager.startTreasuryShareTradingRound();
    }
    if (!gameSpecificNextStep(step))     continue;
    break;
  }
  if (step == GameDef.OrStep.FINAL) {
    finishTurn();
  }
 else {
    setStep(step);
  }
}",0.9924221161942184
173640,"public void setGameUIManager(GameUIManager gameUIManager){
  this.gameUIManager=gameUIManager;
}","public void setGameUIManager(GameUIManager gameUIManager){
  this.gameUIManager=gameUIManager;
  this.tileManager=gameUIManager.getGameManager().getTileManager();
}",0.7384615384615385
173641,"public GUITile(int tileId,GUIHex guiHex){
  this.guiHex=guiHex;
  this.tileId=tileId;
  this.hex=(MapHex)guiHex.getModel();
  tile=GameManager.getInstance().getTileManager().getTile(tileId);
  if (hex.getTileOrientation() == MapHex.EW) {
    baseRotation=0.5 * DEG60;
  }
 else {
    baseRotation=0.0;
  }
}","public GUITile(int tileId,GUIHex guiHex){
  this.guiHex=guiHex;
  this.tileId=tileId;
  this.hex=(MapHex)guiHex.getModel();
  TileManager tileManager=guiHex.getHexMap().orUIManager.getTileManager();
  tile=tileManager.getTile(tileId);
  if (hex.getTileOrientation() == MapHex.EW) {
    baseRotation=0.5 * DEG60;
  }
 else {
    baseRotation=0.0;
  }
}",0.790273556231003
173642,"public void paintTile(Graphics2D g2,int x,int y){
  int zoomStep=guiHex.getHexMap().getZoomStep();
  tileImage=imageLoader.getTile(tileId,zoomStep);
  if (tileImage != null) {
    double radians=baseRotation + rotation * DEG60;
    int xCenter=(int)Math.round(tileImage.getWidth() * SVG_X_CENTER_LOC * tileScale);
    int yCenter=(int)Math.round(tileImage.getHeight() * SVG_Y_CENTER_LOC * tileScale);
    af=AffineTransform.getRotateInstance(radians,xCenter,yCenter);
    af.scale(tileScale,tileScale);
    RenderingHints rh=new RenderingHints(null);
    rh.put(RenderingHints.KEY_ALPHA_INTERPOLATION,RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);
    rh.put(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
    rh.put(RenderingHints.KEY_COLOR_RENDERING,RenderingHints.VALUE_COLOR_RENDER_QUALITY);
    rh.put(RenderingHints.KEY_DITHERING,RenderingHints.VALUE_DITHER_DISABLE);
    rh.put(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BICUBIC);
    rh.put(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);
    rh.put(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
    AffineTransformOp aop=new AffineTransformOp(af,rh);
    g2.drawImage(tileImage,aop,x - xCenter,y - yCenter);
  }
}","public void paintTile(Graphics2D g2,int x,int y){
  int zoomStep=guiHex.getHexMap().getZoomStep();
  tileImage=imageLoader.getTile(tileId,zoomStep);
  if (tileImage != null) {
    double radians=baseRotation + rotation * DEG60;
    int xCenter=(int)Math.round(tileImage.getWidth() * SVG_X_CENTER_LOC * tileScale);
    int yCenter=(int)Math.round(tileImage.getHeight() * SVG_Y_CENTER_LOC * tileScale);
    af=AffineTransform.getRotateInstance(radians,xCenter,yCenter);
    af.scale(tileScale,tileScale);
    RenderingHints rh=new RenderingHints(null);
    rh.put(RenderingHints.KEY_ALPHA_INTERPOLATION,RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);
    rh.put(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
    rh.put(RenderingHints.KEY_COLOR_RENDERING,RenderingHints.VALUE_COLOR_RENDER_QUALITY);
    rh.put(RenderingHints.KEY_DITHERING,RenderingHints.VALUE_DITHER_DISABLE);
    rh.put(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BICUBIC);
    rh.put(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);
    rh.put(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
    AffineTransformOp aop=new AffineTransformOp(af,rh);
    g2.drawImage(tileImage,aop,x - xCenter,y - yCenter);
  }
 else {
    log.error(""String_Node_Str"" + tileId + ""String_Node_Str""+ guiHex.getName());
  }
}",0.964759378552482
173643,"static void loadGame(String[] args){
  Game game=null;
  String filepath=args[0];
  System.out.println(""String_Node_Str"" + filepath);
  if ((game=Game.load(filepath)) == null) {
    System.err.println(""String_Node_Str"" + filepath + ""String_Node_Str"");
    return;
  }
  GameManagerI gameManager=game.getGameManager();
  GameUIManager gameUIManager;
  String gameUIManagerClassName=gameManager.getClassName(GuiDef.ClassName.GAME_UI_MANAGER);
  try {
    Class<? extends GameUIManager> gameUIManagerClass=Class.forName(gameUIManagerClassName).asSubclass(GameUIManager.class);
    gameUIManager=gameUIManagerClass.newInstance();
    gameUIManager.init(gameManager);
    gameUIManager.startLoadedGame();
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + gameUIManagerClassName + ""String_Node_Str""+ e.getMessage());
    e.printStackTrace(System.err);
    System.exit(1);
  }
}","static void loadGame(String[] args){
  Game game=null;
  String filepath=args[0];
  System.out.println(""String_Node_Str"" + filepath);
  if ((game=Game.load(filepath)) == null) {
    System.err.println(""String_Node_Str"" + filepath + ""String_Node_Str"");
    return;
  }
  GameManagerI gameManager=game.getGameManager();
  GameUIManager gameUIManager;
  String gameUIManagerClassName=gameManager.getClassName(GuiDef.ClassName.GAME_UI_MANAGER);
  try {
    Class<? extends GameUIManager> gameUIManagerClass=Class.forName(gameUIManagerClassName).asSubclass(GameUIManager.class);
    gameUIManager=gameUIManagerClass.newInstance();
    gameUIManager.init(gameManager);
    String directory=new java.io.File(filepath).getParent();
    if (directory != null) {
      gameUIManager.setSaveDirectory(directory);
    }
    gameUIManager.startLoadedGame();
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + gameUIManagerClassName + ""String_Node_Str""+ e.getMessage());
    e.printStackTrace(System.err);
    System.exit(1);
  }
}",0.9249093733816676
173644,"public static void main(String[] args){
  Config.setConfigSelection();
  int nargs=0;
  if (args != null && args.length > 0) {
    nargs=args.length;
    System.out.println(""String_Node_Str"" + nargs);
    for (    String arg : args) {
      System.out.println(""String_Node_Str"" + arg);
    }
  }
  if (nargs >= 1) {
    loadGame(args);
  }
 else {
    new GameSetupWindow();
  }
}","public static void main(String[] args){
  Config.setConfigSelection();
  int nargs=0;
  if (args != null && args.length > 0) {
    nargs=args.length;
    System.out.println(""String_Node_Str"" + nargs);
    for (    String arg : args) {
      System.out.println(""String_Node_Str"" + arg);
    }
  }
  if (nargs >= 1) {
    loadGameOnEventQueue(args);
  }
 else {
    new GameSetupWindow();
  }
}",0.9844559585492229
173645,"public boolean mustSelectAPrice(){
  return startPrices != null && startPrices.length > 1;
}","public boolean mustSelectAPrice(){
  return startPrices != null;
}",0.8354430379746836
173646,"public void actionPerformed(ActionEvent actor){
  JComponent source=(JComponent)actor.getSource();
  List<PossibleAction> actions;
  PossibleAction chosenAction=null;
  if (source instanceof ClickField) {
    gbc=gb.getConstraints(source);
    actions=((ClickField)source).getPossibleActions();
    log.debug(""String_Node_Str"" + actions.get(0).toString());
    if (actions == null || actions.size() == 0) {
      log.warn(""String_Node_Str"");
    }
 else     if (actions.get(0) instanceof SellShares) {
      List<String> options=new ArrayList<String>();
      List<SellShares> sellActions=new ArrayList<SellShares>();
      List<Integer> sellAmounts=new ArrayList<Integer>();
      SellShares sale;
      for (      PossibleAction action : actions) {
        sale=(SellShares)action;
        for (int i=1; i <= sale.getMaximumNumber(); i++) {
          options.add(LocalText.getText(""String_Node_Str"",i,sale.getShare(),i * sale.getShare(),sale.getCompanyName(),Bank.format(i * sale.getShareUnits() * sale.getPrice())));
          sellActions.add(sale);
          sellAmounts.add(i);
        }
      }
      int index=0;
      if (options.size() > 1) {
        String message=LocalText.getText(""String_Node_Str"");
        String sp=(String)JOptionPane.showInputDialog(this,message,message,JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
        index=options.indexOf(sp);
      }
 else       if (options.size() == 1) {
        String message=LocalText.getText(""String_Node_Str"");
        int result=JOptionPane.showConfirmDialog(this,options.get(0),message,JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
        index=(result == JOptionPane.OK_OPTION ? 0 : -1);
      }
      if (index < 0) {
      }
 else {
        chosenAction=sellActions.get(index);
        ((SellShares)chosenAction).setNumberSold(sellAmounts.get(index));
      }
    }
 else     if (actions.get(0) instanceof BuyCertificate) {
      boolean startCompany=false;
      List<String> options=new ArrayList<String>();
      List<BuyCertificate> buyActions=new ArrayList<BuyCertificate>();
      List<Integer> buyAmounts=new ArrayList<Integer>();
      BuyCertificate buy;
      PublicCertificateI cert;
      String companyName=""String_Node_Str"";
      String playerName=""String_Node_Str"";
      int sharePerCert;
      int sharesPerCert;
      int shareUnit;
      for (      PossibleAction action : actions) {
        buy=(BuyCertificate)action;
        playerName=buy.getPlayerName();
        PublicCompanyI company=buy.getCompany();
        companyName=company.getName();
        sharePerCert=buy.getSharePerCertificate();
        shareUnit=company.getShareUnit();
        sharesPerCert=sharePerCert / shareUnit;
        if (buy instanceof StartCompany) {
          startCompany=true;
          int[] startPrices;
          if (((StartCompany)buy).mustSelectAPrice()) {
            startPrices=((StartCompany)buy).getStartPrices();
            Arrays.sort(startPrices);
            for (int i=0; i < startPrices.length; i++) {
              options.add(LocalText.getText(""String_Node_Str"",Bank.format(startPrices[i]),sharePerCert,Bank.format(sharesPerCert * startPrices[i])));
              buyActions.add(buy);
              buyAmounts.add(startPrices[i]);
            }
          }
 else {
            startPrices=new int[]{((StartCompany)buy).getPrice()};
            options.add(LocalText.getText(""String_Node_Str"",companyName,sharePerCert,Bank.format(startPrices[0])));
            buyActions.add(buy);
            buyAmounts.add(startPrices[0]);
          }
        }
 else {
          options.add(LocalText.getText(""String_Node_Str"",sharePerCert,companyName,buy.getFromPortfolio().getName(),Bank.format(sharesPerCert * buy.getPrice())));
          buyActions.add(buy);
          buyAmounts.add(1);
          for (int i=2; i <= buy.getMaximumNumber(); i++) {
            options.add(LocalText.getText(""String_Node_Str"",i,sharePerCert,companyName,buy.getFromPortfolio().getName(),Bank.format(i * sharesPerCert * buy.getPrice())));
            buyActions.add(buy);
            buyAmounts.add(i);
          }
        }
      }
      int index=0;
      if (options.size() > 1) {
        if (startCompany) {
          RadioButtonDialog dialog=new RadioButtonDialog(gameUIManager,LocalText.getText(""String_Node_Str""),LocalText.getText(""String_Node_Str"",playerName,companyName),options.toArray(new String[0]),-1);
          gameUIManager.setCurrentDialog(dialog,actions.get(0));
          return;
        }
 else {
          String sp=(String)JOptionPane.showInputDialog(this,LocalText.getText(startCompany ? ""String_Node_Str"" : ""String_Node_Str""),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
          index=options.indexOf(sp);
        }
      }
 else       if (options.size() == 1) {
        int result=JOptionPane.showConfirmDialog(this,options.get(0),LocalText.getText(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
        index=(result == JOptionPane.OK_OPTION ? 0 : -1);
      }
      if (index < 0) {
      }
 else       if (startCompany) {
        chosenAction=buyActions.get(index);
        ((StartCompany)chosenAction).setStartPrice(buyAmounts.get(index));
        ((StartCompany)chosenAction).setNumberBought(((StartCompany)chosenAction).getSharesPerCertificate());
      }
 else {
        chosenAction=buyActions.get(index);
        ((BuyCertificate)chosenAction).setNumberBought(buyAmounts.get(index));
      }
    }
 else     if (actions.get(0) instanceof CashCorrectionAction) {
      CashCorrectionAction cca=(CashCorrectionAction)actions.get(0);
      String amountString=(String)JOptionPane.showInputDialog(this,LocalText.getText(""String_Node_Str"",cca.getCashHolderName()),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,null,0);
      if (amountString.substring(0,1).equals(""String_Node_Str""))       amountString=amountString.substring(1);
      int amount;
      try {
        amount=Integer.parseInt(amountString);
      }
 catch (      NumberFormatException e) {
        amount=0;
      }
      cca.setAmount(amount);
      chosenAction=cca;
    }
 else {
      chosenAction=processGameSpecificActions(actor,actions.get(0));
    }
  }
 else {
    log.warn(""String_Node_Str"" + source.toString());
  }
  chosenAction=processGameSpecificFollowUpActions(actor,chosenAction);
  if (chosenAction != null)   (parent).process(chosenAction);
  repaint();
}","public void actionPerformed(ActionEvent actor){
  JComponent source=(JComponent)actor.getSource();
  List<PossibleAction> actions;
  PossibleAction chosenAction=null;
  if (source instanceof ClickField) {
    gbc=gb.getConstraints(source);
    actions=((ClickField)source).getPossibleActions();
    log.debug(""String_Node_Str"" + actions.get(0).toString());
    if (actions == null || actions.size() == 0) {
      log.warn(""String_Node_Str"");
    }
 else     if (actions.get(0) instanceof SellShares) {
      List<String> options=new ArrayList<String>();
      List<SellShares> sellActions=new ArrayList<SellShares>();
      List<Integer> sellAmounts=new ArrayList<Integer>();
      SellShares sale;
      for (      PossibleAction action : actions) {
        sale=(SellShares)action;
        for (int i=1; i <= sale.getMaximumNumber(); i++) {
          options.add(LocalText.getText(""String_Node_Str"",i,sale.getShare(),i * sale.getShare(),sale.getCompanyName(),Bank.format(i * sale.getShareUnits() * sale.getPrice())));
          sellActions.add(sale);
          sellAmounts.add(i);
        }
      }
      int index=0;
      if (options.size() > 1) {
        String message=LocalText.getText(""String_Node_Str"");
        String sp=(String)JOptionPane.showInputDialog(this,message,message,JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
        index=options.indexOf(sp);
      }
 else       if (options.size() == 1) {
        String message=LocalText.getText(""String_Node_Str"");
        int result=JOptionPane.showConfirmDialog(this,options.get(0),message,JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
        index=(result == JOptionPane.OK_OPTION ? 0 : -1);
      }
      if (index < 0) {
      }
 else {
        chosenAction=sellActions.get(index);
        ((SellShares)chosenAction).setNumberSold(sellAmounts.get(index));
      }
    }
 else     if (actions.get(0) instanceof BuyCertificate) {
      boolean startCompany=false;
      List<String> options=new ArrayList<String>();
      List<BuyCertificate> buyActions=new ArrayList<BuyCertificate>();
      List<Integer> buyAmounts=new ArrayList<Integer>();
      BuyCertificate buy;
      PublicCertificateI cert;
      String companyName=""String_Node_Str"";
      String playerName=""String_Node_Str"";
      int sharePerCert;
      int sharesPerCert;
      int shareUnit;
      for (      PossibleAction action : actions) {
        buy=(BuyCertificate)action;
        playerName=buy.getPlayerName();
        PublicCompanyI company=buy.getCompany();
        companyName=company.getName();
        sharePerCert=buy.getSharePerCertificate();
        shareUnit=company.getShareUnit();
        sharesPerCert=sharePerCert / shareUnit;
        if (buy instanceof StartCompany) {
          startCompany=true;
          int[] startPrices;
          if (((StartCompany)buy).mustSelectAPrice()) {
            startPrices=((StartCompany)buy).getStartPrices();
            Arrays.sort(startPrices);
            if (startPrices.length > 1) {
              for (int i=0; i < startPrices.length; i++) {
                options.add(LocalText.getText(""String_Node_Str"",Bank.format(startPrices[i]),sharePerCert,Bank.format(sharesPerCert * startPrices[i])));
                buyActions.add(buy);
                buyAmounts.add(startPrices[i]);
              }
            }
 else {
              options.add(LocalText.getText(""String_Node_Str"",companyName,company.getPresidentsShare().getShare(),Bank.format(company.getPresidentsShare().getShares() * startPrices[0])));
              buyActions.add(buy);
              buyAmounts.add(startPrices[0]);
            }
          }
 else {
            startPrices=new int[]{((StartCompany)buy).getPrice()};
            options.add(LocalText.getText(""String_Node_Str"",companyName,sharePerCert,Bank.format(startPrices[0])));
            buyActions.add(buy);
            buyAmounts.add(startPrices[0]);
          }
        }
 else {
          options.add(LocalText.getText(""String_Node_Str"",sharePerCert,companyName,buy.getFromPortfolio().getName(),Bank.format(sharesPerCert * buy.getPrice())));
          buyActions.add(buy);
          buyAmounts.add(1);
          for (int i=2; i <= buy.getMaximumNumber(); i++) {
            options.add(LocalText.getText(""String_Node_Str"",i,sharePerCert,companyName,buy.getFromPortfolio().getName(),Bank.format(i * sharesPerCert * buy.getPrice())));
            buyActions.add(buy);
            buyAmounts.add(i);
          }
        }
      }
      int index=0;
      if (options.size() > 1) {
        if (startCompany) {
          RadioButtonDialog dialog=new RadioButtonDialog(gameUIManager,LocalText.getText(""String_Node_Str""),LocalText.getText(""String_Node_Str"",playerName,companyName),options.toArray(new String[0]),-1);
          gameUIManager.setCurrentDialog(dialog,actions.get(0));
          return;
        }
 else {
          String sp=(String)JOptionPane.showInputDialog(this,LocalText.getText(startCompany ? ""String_Node_Str"" : ""String_Node_Str""),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,options.toArray(new String[0]),options.get(0));
          index=options.indexOf(sp);
        }
      }
 else       if (options.size() == 1) {
        int result=JOptionPane.showConfirmDialog(this,options.get(0),LocalText.getText(""String_Node_Str""),JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE);
        index=(result == JOptionPane.OK_OPTION ? 0 : -1);
      }
      if (index < 0) {
      }
 else       if (startCompany) {
        chosenAction=buyActions.get(index);
        ((StartCompany)chosenAction).setStartPrice(buyAmounts.get(index));
        ((StartCompany)chosenAction).setNumberBought(((StartCompany)chosenAction).getSharesPerCertificate());
      }
 else {
        chosenAction=buyActions.get(index);
        ((BuyCertificate)chosenAction).setNumberBought(buyAmounts.get(index));
      }
    }
 else     if (actions.get(0) instanceof CashCorrectionAction) {
      CashCorrectionAction cca=(CashCorrectionAction)actions.get(0);
      String amountString=(String)JOptionPane.showInputDialog(this,LocalText.getText(""String_Node_Str"",cca.getCashHolderName()),LocalText.getText(""String_Node_Str""),JOptionPane.QUESTION_MESSAGE,null,null,0);
      if (amountString.substring(0,1).equals(""String_Node_Str""))       amountString=amountString.substring(1);
      int amount;
      try {
        amount=Integer.parseInt(amountString);
      }
 catch (      NumberFormatException e) {
        amount=0;
      }
      cca.setAmount(amount);
      chosenAction=cca;
    }
 else {
      chosenAction=processGameSpecificActions(actor,actions.get(0));
    }
  }
 else {
    log.warn(""String_Node_Str"" + source.toString());
  }
  chosenAction=processGameSpecificFollowUpActions(actor,chosenAction);
  if (chosenAction != null)   (parent).process(chosenAction);
  repaint();
}",0.9733403031887088
173647,"/** 
 * Distribute the dividend amongst the shareholders.
 * @param amount
 */
public void payout(int amount){
  if (amount == 0)   return;
  int part;
  int shares;
  Map<CashHolder,Integer> sharesPerRecipient=countSharesPerRecipient();
  Set<CashHolder> recipientSet=sharesPerRecipient.keySet();
  for (  CashHolder recipient : SequenceUtil.sortCashHolders(recipientSet)) {
    if (recipient instanceof Bank)     continue;
    shares=(sharesPerRecipient.get(recipient));
    if (shares == 0)     continue;
    part=(int)Math.ceil(amount * shares * operatingCompany.get().getShareUnit() / 100.0);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",recipient.getName(),Bank.format(part),shares,operatingCompany.get().getShareUnit()));
    new CashMove(bank,recipient,part);
  }
  operatingCompany.get().payout(amount);
}","/** 
 * Distribute the dividend amongst the shareholders.
 * @param amount
 */
public void payout(int amount){
  if (amount == 0)   return;
  int part;
  int shares;
  Map<CashHolder,Integer> sharesPerRecipient=countSharesPerRecipient();
  Set<CashHolder> recipientSet=sharesPerRecipient.keySet();
  for (  CashHolder recipient : SequenceUtil.sortCashHolders(recipientSet)) {
    if (recipient instanceof Bank)     continue;
    shares=(sharesPerRecipient.get(recipient));
    if (shares == 0)     continue;
    part=(int)Math.ceil(amount * shares * operatingCompany.get().getShareUnit() / 100.0);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",recipient.getName(),Bank.format(part),shares,operatingCompany.get().getShareUnit()));
    pay(bank,recipient,part);
  }
  operatingCompany.get().payout(amount);
}",0.9908703590992088
173648,"/** 
 * Split a dividend. TODO Optional rounding down the payout
 * @param amount
 */
public void splitRevenue(int amount){
  if (amount > 0) {
    int numberOfShares=operatingCompany.get().getNumberOfShares();
    int withheld=(amount / (2 * numberOfShares)) * numberOfShares;
    new CashMove(bank,operatingCompany.get(),withheld);
    ReportBuffer.add(operatingCompany.get().getName() + ""String_Node_Str"" + Bank.format(withheld));
    int payed=amount - withheld;
    payout(payed);
  }
}","/** 
 * Split a dividend. TODO Optional rounding down the payout
 * @param amount
 */
public void splitRevenue(int amount){
  if (amount > 0) {
    int numberOfShares=operatingCompany.get().getNumberOfShares();
    int withheld=(amount / (2 * numberOfShares)) * numberOfShares;
    pay(bank,operatingCompany.get(),withheld);
    ReportBuffer.add(operatingCompany.get().getName() + ""String_Node_Str"" + Bank.format(withheld));
    int payed=amount - withheld;
    payout(payed);
  }
}",0.9845837615621787
173649,"/** 
 * Withhold a given amount of revenue (and store it).
 * @param The revenue amount.
 */
public void withhold(int amount){
  if (amount > 0)   new CashMove(bank,operatingCompany.get(),amount);
  operatingCompany.get().withhold(amount);
}","/** 
 * Withhold a given amount of revenue (and store it).
 * @param The revenue amount.
 */
public void withhold(int amount){
  PublicCompanyI company=operatingCompany.get();
  pay(bank,company,amount);
  company.withhold(amount);
  StockSpaceI newSpace=company.getCurrentSpace();
  if (newSpace.closesCompany() && company.canClose()) {
    company.setClosed();
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getName(),newSpace.getName()));
    finishTurn();
    return;
  }
}",0.453804347826087
173650,"protected void moveLeftOrDown(PublicCompanyI company){
  StockSpaceI oldsquare=company.getCurrentSpace();
  StockSpaceI newsquare=oldsquare;
  int row=oldsquare.getRow();
  int col=oldsquare.getColumn();
  if (col > 0 && (newsquare=getStockSpace(row,col - 1)) != null) {
  }
 else   if (row < numRows - 1 && (newsquare=getStockSpace(row + 1,col)) != null) {
  }
 else {
    newsquare=oldsquare;
  }
  if (newsquare.closesCompany()) {
    if (!company.canClose())     return;
    company.setClosed();
    oldsquare.removeToken(company);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getName(),newsquare.getName()));
  }
 else {
    prepareMove(company,oldsquare,newsquare);
  }
}","protected void moveLeftOrDown(PublicCompanyI company){
  StockSpaceI oldsquare=company.getCurrentSpace();
  StockSpaceI newsquare=oldsquare;
  int row=oldsquare.getRow();
  int col=oldsquare.getColumn();
  if (col > 0 && (newsquare=getStockSpace(row,col - 1)) != null) {
  }
 else   if (row < numRows - 1 && (newsquare=getStockSpace(row + 1,col)) != null) {
  }
 else {
    newsquare=oldsquare;
  }
  prepareMove(company,oldsquare,newsquare);
}",0.7782646801051709
173651,"@Override public boolean sellShares(SellShares action){
  Portfolio portfolio=currentPlayer.getPortfolio();
  String playerName=currentPlayer.getName();
  String errMsg=null;
  String companyName=action.getCompanyName();
  PublicCompanyI company=companyManager.getPublicCompany(action.getCompanyName());
  PublicCertificateI cert=null;
  PublicCertificateI presCert=null;
  List<PublicCertificateI> certsToSell=new ArrayList<PublicCertificateI>();
  Player dumpedPlayer=null;
  int presSharesToSell=0;
  int numberToSell=action.getNumberSold();
  int shareUnits=action.getShareUnits();
  int currentIndex=getCurrentPlayerIndex();
  while (true) {
    if (numberToSell <= 0) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!mayPlayerSellShareOfCompany(company)) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (portfolio.getShare(company) < numberToSell) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (pool.getShare(company) + numberToSell * company.getShareUnit() > getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    Iterator<PublicCertificateI> it=portfolio.getCertificatesPerCompany(companyName).iterator();
    while (numberToSell > 0 && it.hasNext()) {
      cert=it.next();
      if (cert.isPresidentShare()) {
        if (cert.isPresidentShare())         presCert=cert;
        continue;
      }
 else       if (shareUnits != cert.getShares()) {
        continue;
      }
      certsToSell.add(cert);
      numberToSell--;
    }
    if (numberToSell == 0)     presCert=null;
    if (numberToSell > 0 && presCert != null && numberToSell <= presCert.getShares()) {
      if (company == cashNeedingCompany || !dumpOtherCompaniesAllowed) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
      Player otherPlayer;
      for (int i=currentIndex + 1; i < currentIndex + numberOfPlayers; i++) {
        otherPlayer=gameManager.getPlayerByIndex(i);
        if (otherPlayer.getPortfolio().getShare(company) >= presCert.getShare()) {
          if (numberToSell > 1 || otherPlayer.getPortfolio().ownsCertificates(company,1,false) >= 1) {
            dumpedPlayer=otherPlayer;
            presSharesToSell=numberToSell;
            numberToSell=0;
            break;
          }
        }
      }
    }
    if (numberToSell > 0) {
      if (presCert != null) {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
 else {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
      break;
    }
    break;
  }
  int numberSold=action.getNumberSold();
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,numberSold,companyName,errMsg));
    return false;
  }
  StockSpaceI sellPrice;
  int price;
  if (sellPrices.containsKey(companyName) && GameOption.convertValueToBoolean(getGameOption(""String_Node_Str""))) {
    price=(sellPrices.get(companyName)).getPrice();
  }
 else {
    sellPrice=company.getCurrentSpace();
    price=sellPrice.getPrice();
    sellPrices.put(companyName,sellPrice);
  }
  int cashAmount=numberSold * price * shareUnits;
  moveStack.start(true).linkToPreviousMoveSet();
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,numberSold,company.getShareUnit(),numberSold * company.getShareUnit(),companyName,Bank.format(cashAmount)));
  boolean soldBefore=sellPrices.containsKey(companyName);
  pay(bank,company,cashAmount);
  adjustSharePrice(company,numberSold,soldBefore);
  if (!company.isClosed()) {
    executeShareTransfer(company,certsToSell,dumpedPlayer,presSharesToSell);
  }
  cashToRaise.add(-numberSold * price);
  if (cashToRaise.intValue() <= 0) {
    gameManager.finishShareSellingRound();
  }
 else   if (getSellableShares().isEmpty()) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",Bank.format(cashToRaise.intValue())));
    currentPlayer.setBankrupt();
    gameManager.registerBankruptcy();
  }
  return true;
}","@Override public boolean sellShares(SellShares action){
  Portfolio portfolio=currentPlayer.getPortfolio();
  String playerName=currentPlayer.getName();
  String errMsg=null;
  String companyName=action.getCompanyName();
  PublicCompanyI company=companyManager.getPublicCompany(action.getCompanyName());
  PublicCertificateI cert=null;
  PublicCertificateI presCert=null;
  List<PublicCertificateI> certsToSell=new ArrayList<PublicCertificateI>();
  Player dumpedPlayer=null;
  int presSharesToSell=0;
  int numberToSell=action.getNumberSold();
  int shareUnits=action.getShareUnits();
  int currentIndex=getCurrentPlayerIndex();
  while (true) {
    if (numberToSell <= 0) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (!mayPlayerSellShareOfCompany(company)) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (portfolio.getShare(company) < numberToSell) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (pool.getShare(company) + numberToSell * company.getShareUnit() > getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    Iterator<PublicCertificateI> it=portfolio.getCertificatesPerCompany(companyName).iterator();
    while (numberToSell > 0 && it.hasNext()) {
      cert=it.next();
      if (cert.isPresidentShare()) {
        if (cert.isPresidentShare())         presCert=cert;
        continue;
      }
 else       if (shareUnits != cert.getShares()) {
        continue;
      }
      certsToSell.add(cert);
      numberToSell--;
    }
    if (numberToSell == 0)     presCert=null;
    if (numberToSell > 0 && presCert != null && numberToSell <= presCert.getShares()) {
      if (company == cashNeedingCompany || !dumpOtherCompaniesAllowed) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
      Player otherPlayer;
      for (int i=currentIndex + 1; i < currentIndex + numberOfPlayers; i++) {
        otherPlayer=gameManager.getPlayerByIndex(i);
        if (otherPlayer.getPortfolio().getShare(company) >= presCert.getShare()) {
          if (numberToSell > 1 || otherPlayer.getPortfolio().ownsCertificates(company,1,false) >= 1) {
            dumpedPlayer=otherPlayer;
            presSharesToSell=numberToSell;
            numberToSell=0;
            break;
          }
        }
      }
    }
    if (numberToSell > 0) {
      if (presCert != null) {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
 else {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
      break;
    }
    break;
  }
  int numberSold=action.getNumberSold();
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,numberSold,companyName,errMsg));
    return false;
  }
  StockSpaceI sellPrice;
  int price;
  if (sellPrices.containsKey(companyName) && GameOption.convertValueToBoolean(getGameOption(""String_Node_Str""))) {
    price=(sellPrices.get(companyName)).getPrice();
  }
 else {
    sellPrice=company.getCurrentSpace();
    price=sellPrice.getPrice();
    sellPrices.put(companyName,sellPrice);
  }
  int cashAmount=numberSold * price * shareUnits;
  moveStack.start(true).linkToPreviousMoveSet();
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,numberSold,company.getShareUnit(),numberSold * company.getShareUnit(),companyName,Bank.format(cashAmount)));
  boolean soldBefore=sellPrices.containsKey(companyName);
  pay(bank,currentPlayer,cashAmount);
  adjustSharePrice(company,numberSold,soldBefore);
  if (!company.isClosed()) {
    executeShareTransfer(company,certsToSell,dumpedPlayer,presSharesToSell);
  }
  cashToRaise.add(-numberSold * price);
  if (cashToRaise.intValue() <= 0) {
    gameManager.finishShareSellingRound();
  }
 else   if (getSellableShares().isEmpty()) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",Bank.format(cashToRaise.intValue())));
    currentPlayer.setBankrupt();
    gameManager.registerBankruptcy();
  }
  return true;
}",0.9978271366489618
173652,"private void importProfile(){
  String directory=Config.get(""String_Node_Str"");
  JFileChooser fc=new JFileChooser(directory);
  fc.setFileFilter(new FileFilter(){
    public boolean accept(    File f){
      return f.isDirectory() || f.getName().toLowerCase().endsWith(CONFIG_EXTENSION) || f.getName().toLowerCase().endsWith(LEGACY_EXTENSION);
    }
    public String getDescription(){
      return CONFIG_DESCRIPTION;
    }
  }
);
  int state=fc.showOpenDialog(this);
  if (state == JFileChooser.APPROVE_OPTION) {
    File file=fc.getSelectedFile();
    if (Config.importProfileFromFile(file)) {
      changeProfile(Config.getActiveProfileName());
    }
 else {
      JOptionPane.showMessageDialog(ConfigWindow.this,LocalText.getText(""String_Node_Str"",Config.getActiveProfileName()),LocalText.getText(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
    }
  }
}","private void importProfile(){
  String directory=Config.get(""String_Node_Str"");
  JFileChooser fc=new JFileChooser(directory);
  fc.setFileFilter(new FileFilter(){
    public boolean accept(    File f){
      return f.isDirectory() || f.getName().toLowerCase().endsWith(CONFIG_EXTENSION) || f.getName().toLowerCase().endsWith(LEGACY_EXTENSION);
    }
    public String getDescription(){
      return CONFIG_DESCRIPTION;
    }
  }
);
  int state=fc.showOpenDialog(this);
  if (state == JFileChooser.APPROVE_OPTION) {
    File file=fc.getSelectedFile();
    if (Config.importProfileFromFile(file)) {
      repaintLater();
    }
 else {
      JOptionPane.showMessageDialog(ConfigWindow.this,LocalText.getText(""String_Node_Str"",Config.getActiveProfileName()),LocalText.getText(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
    }
  }
}",0.966903073286052
173653,"private void changeProfile(String profileName){
  Config.changeActiveProfile(profileName);
  EventQueue.invokeLater(new Runnable(){
    public void run(){
      init();
      ConfigWindow.this.repaint();
    }
  }
);
}","private void changeProfile(String profileName){
  Config.changeActiveProfile(profileName);
  repaintLater();
}",0.6402439024390244
173654,"/** 
 * loads an external user profile defined by the filepath
 */
public static boolean importProfileFromFile(File file){
  String filepath=file.getPath();
  if (loadPropertyFile(userProperties,filepath,false)) {
    String profile=userProperties.getProperty(PROFILENAME_PROPERTY);
    if (!Util.hasValue(profile)) {
      profile=STANDARD_PROFILE_SELECTION;
    }
    selectedProfile=profile;
    loadDefaultProfile();
    setSaveDirDefaults();
    return true;
  }
 else {
    return false;
  }
}","/** 
 * imports an external user profile into an existing profile defined by the filepath
 */
public static boolean importProfileFromFile(File file){
  String filepath=file.getPath();
  Properties importProperties=new Properties();
  if (loadPropertyFile(importProperties,filepath,false)) {
    userProperties.putAll(importProperties);
    setSaveDirDefaults();
    return true;
  }
 else {
    return false;
  }
}",0.488499452354874
173655,"Set<RevenueDynamicModifier> callDynamicModifiers(RevenueAdapter revenueAdapter){
  Set<RevenueDynamicModifier> activeModifiers=new HashSet<RevenueDynamicModifier>();
  for (  RevenueDynamicModifier modifier : dynamicModifiers) {
    if (modifier.prepareModifier(revenueAdapter))     activeModifiers.add(modifier);
  }
  return activeModifiers;
}","Set<RevenueDynamicModifier> callDynamicModifiers(RevenueAdapter revenueAdapter){
  Set<RevenueDynamicModifier> activeModifiers=new HashSet<RevenueDynamicModifier>();
  for (  RevenueDynamicModifier modifier : dynamicModifiers.viewSet()) {
    if (modifier.prepareModifier(revenueAdapter))     activeModifiers.add(modifier);
  }
  return activeModifiers;
}",0.9857142857142858
173656,"public RevenueManager(){
  graphModifiers=new HashSet<NetworkGraphModifier>();
  staticModifiers=new HashSet<RevenueStaticModifier>();
  dynamicModifiers=new HashSet<RevenueDynamicModifier>();
  configurableModifiers=new HashSet<ConfigurableComponentI>();
}","public RevenueManager(){
  graphModifiers=new HashSetState<NetworkGraphModifier>(""String_Node_Str"");
  staticModifiers=new HashSetState<RevenueStaticModifier>(""String_Node_Str"");
  dynamicModifiers=new HashSetState<RevenueDynamicModifier>(""String_Node_Str"");
  configurableModifiers=new HashSet<ConfigurableComponentI>();
}",0.8862068965517241
173657,"void callGraphModifiers(NetworkGraphBuilder graphBuilder){
  for (  NetworkGraphModifier modifier : graphModifiers) {
    modifier.modifyGraph(graphBuilder);
  }
}","void callGraphModifiers(NetworkGraphBuilder graphBuilder){
  for (  NetworkGraphModifier modifier : graphModifiers.viewSet()) {
    modifier.modifyGraph(graphBuilder);
  }
}",0.9702380952380952
173658,"void callStaticModifiers(RevenueAdapter revenueAdapter){
  for (  RevenueStaticModifier modifier : staticModifiers) {
    modifier.modifyCalculator(revenueAdapter);
  }
}","void callStaticModifiers(RevenueAdapter revenueAdapter){
  for (  RevenueStaticModifier modifier : staticModifiers.viewSet()) {
    modifier.modifyCalculator(revenueAdapter);
  }
}",0.9714285714285714
173659,"/** 
 * Remove the token. This method can be called by a certain phase when it starts. See prepareForRemovel().
 */
public void close(){
  owner.removeBonus(name);
  GameManager.getInstance().getRevenueManager().removeStaticModifier(this);
}","/** 
 * Remove the bonus This method can be called by a certain phase when it starts. See prepareForRemovel().
 */
public void close(){
  GameManager.getInstance().getRevenueManager().removeStaticModifier(this);
}",0.6123348017621145
173660,"@Override public boolean undo(){
  list.add(index,object);
  return true;
}","@Override public boolean undo(){
  list.add(index,object);
  updateModels();
  return true;
}",0.8928571428571429
173661,"@Override public boolean execute(){
  list.remove(object);
  return true;
}","@Override public boolean execute(){
  list.remove(object);
  updateModels();
  return true;
}",0.8928571428571429
173662,"public void actionPerformed(ActionEvent e){
  ActionButton button=(ActionButton)e.getSource();
  GameAction action=(GameAction)button.getPossibleActions().get(0);
  gameUIManager.processOnServer(action);
}","public void actionPerformed(ActionEvent e){
  ActionButton button=(ActionButton)e.getSource();
  GameAction action=(GameAction)button.getPossibleActions().get(0);
  if (action instanceof GameAction && (action.getMode() == GameAction.FORCED_UNDO)) {
    if (!timeWarpMode) {
      activateTimeWarp();
    }
  }
  gameUIManager.processOnServer(action);
}",0.7360861759425493
173663,"public void hyperlinkUpdate(HyperlinkEvent e){
  if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
    URL url=e.getURL();
    int index=url.getPort();
    gotoIndex(index + 1);
  }
}","public void hyperlinkUpdate(HyperlinkEvent e){
  if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
    URL url=e.getURL();
    int index=url.getPort();
    gotoIndex(index + 1);
    if (!timeWarpMode) {
      activateTimeWarp();
    }
  }
}",0.87248322147651
173664,"@Override public void updateLog(){
  editorPane.setText(ReportBuffer.getReportItems());
  scrollDown();
  forwardButton.setEnabled(false);
  backwardButton.setEnabled(false);
  boolean haveRedo=false;
  List<GameAction> gameActions=PossibleActions.getInstance().getType(GameAction.class);
  for (  GameAction action : gameActions) {
switch (action.getMode()) {
case GameAction.UNDO:
case GameAction.FORCED_UNDO:
      backwardButton.setPossibleAction(action);
    backwardButton.setEnabled(true);
  break;
case GameAction.REDO:
forwardButton.setPossibleAction(action);
forwardButton.setEnabled(true);
haveRedo=true;
if (!timeWarpMode) activateTimeWarp();
break;
}
}
if (!haveRedo) deactivateTimeWarp();
}","@Override public void updateLog(){
  editorPane.setText(ReportBuffer.getReportItems());
  scrollDown();
  forwardButton.setEnabled(false);
  backwardButton.setEnabled(false);
  boolean haveRedo=false;
  List<GameAction> gameActions=PossibleActions.getInstance().getType(GameAction.class);
  boolean undoFlag=false;
  for (  GameAction action : gameActions) {
switch (action.getMode()) {
case GameAction.UNDO:
      undoFlag=true;
    backwardButton.setPossibleAction(action);
  backwardButton.setEnabled(true);
break;
case GameAction.FORCED_UNDO:
if (undoFlag) break;
backwardButton.setPossibleAction(action);
backwardButton.setEnabled(true);
break;
case GameAction.REDO:
forwardButton.setPossibleAction(action);
forwardButton.setEnabled(true);
haveRedo=true;
break;
}
}
if (!haveRedo) deactivateTimeWarp();
}",0.8592200925313945
173665,"@SuppressWarnings(""String_Node_Str"") public static Game load(String filepath){
  Game game=null;
  log.debug(""String_Node_Str"" + filepath);
  String filename=filepath.replaceAll(""String_Node_Str"",""String_Node_Str"");
  try {
    ObjectInputStream ois=new ObjectInputStream(new FileInputStream(new File(filepath)));
    Object object=ois.readObject();
    if (object instanceof String) {
      log.info(""String_Node_Str"" + (String)object + ""String_Node_Str""+ filename);
      object=ois.readObject();
    }
 else {
      log.info(""String_Node_Str"" + filename);
    }
    if (object instanceof String) {
      log.info(""String_Node_Str"" + (String)object);
      object=ois.readObject();
    }
    long versionID=(Long)object;
    log.debug(""String_Node_Str"" + versionID + ""String_Node_Str""+ object+ ""String_Node_Str"");
    long saveFileVersionID=GameManager.saveFileVersionID;
    if (versionID != saveFileVersionID) {
      throw new Exception(""String_Node_Str"" + versionID + ""String_Node_Str""+ saveFileVersionID);
    }
    String name=(String)ois.readObject();
    log.debug(""String_Node_Str"" + name);
    Map<String,String> selectedGameOptions=(Map<String,String>)ois.readObject();
    List<String> playerNames=(List<String>)ois.readObject();
    game=new Game(name,playerNames,selectedGameOptions);
    if (!game.setup()) {
      throw new ConfigurationException(""String_Node_Str"" + name);
    }
    String startError=game.start();
    if (startError != null) {
      DisplayBuffer.add(startError);
      return null;
    }
    GameManagerI gameManager=game.getGameManager();
    int numberOfActions=0;
    log.debug(""String_Node_Str"");
    Object actionObject=null;
    while (true) {
      try {
        actionObject=ois.readObject();
      }
 catch (      EOFException e) {
        break;
      }
      if (actionObject instanceof List) {
        List<PossibleAction> executedActions=(List<PossibleAction>)actionObject;
        numberOfActions=executedActions.size();
        for (        PossibleAction action : executedActions) {
          if (!gameManager.processOnReload(action)) {
            log.error(""String_Node_Str"");
            DisplayBuffer.add(LocalText.getText(""String_Node_Str""));
            break;
          }
        }
      }
 else       if (actionObject instanceof PossibleAction) {
        while (actionObject instanceof PossibleAction) {
          numberOfActions++;
          if (!gameManager.processOnReload((PossibleAction)actionObject)) {
            log.error(""String_Node_Str"");
            DisplayBuffer.add(LocalText.getText(""String_Node_Str""));
            break;
          }
          try {
            actionObject=ois.readObject();
          }
 catch (          EOFException e) {
            break;
          }
        }
      }
      break;
    }
    if (actionObject instanceof SortedMap) {
      ReportBuffer.setCommentItems((SortedMap<Integer,String>)actionObject);
      log.debug(""String_Node_Str"");
    }
 else {
      try {
        object=ois.readObject();
        if (object instanceof SortedMap) {
          ReportBuffer.setCommentItems((SortedMap<Integer,String>)object);
        }
      }
 catch (      EOFException e) {
      }
    }
    ois.close();
    game.getGameManager().finishLoading();
    return game;
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",e.getMessage()));
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") public static Game load(String filepath){
  Game game=null;
  log.debug(""String_Node_Str"" + filepath);
  String filename=filepath.replaceAll(""String_Node_Str"",""String_Node_Str"");
  try {
    ObjectInputStream ois=new ObjectInputStream(new FileInputStream(new File(filepath)));
    Object object=ois.readObject();
    if (object instanceof String) {
      log.info(""String_Node_Str"" + (String)object + ""String_Node_Str""+ filename);
      object=ois.readObject();
    }
 else {
      log.info(""String_Node_Str"" + filename);
    }
    if (object instanceof String) {
      log.info(""String_Node_Str"" + (String)object);
      object=ois.readObject();
    }
    long versionID=(Long)object;
    log.debug(""String_Node_Str"" + versionID + ""String_Node_Str""+ object+ ""String_Node_Str"");
    long saveFileVersionID=GameManager.saveFileVersionID;
    if (versionID != saveFileVersionID) {
      throw new Exception(""String_Node_Str"" + versionID + ""String_Node_Str""+ saveFileVersionID);
    }
    String name=(String)ois.readObject();
    log.debug(""String_Node_Str"" + name);
    Map<String,String> selectedGameOptions=(Map<String,String>)ois.readObject();
    List<String> playerNames=(List<String>)ois.readObject();
    game=new Game(name,playerNames,selectedGameOptions);
    if (!game.setup()) {
      throw new ConfigurationException(""String_Node_Str"" + name);
    }
    String startError=game.start();
    if (startError != null) {
      DisplayBuffer.add(startError);
      return null;
    }
    GameManagerI gameManager=game.getGameManager();
    int numberOfActions=0;
    log.debug(""String_Node_Str"");
    Object actionObject=null;
    while (true) {
      try {
        actionObject=ois.readObject();
      }
 catch (      EOFException e) {
        break;
      }
      if (actionObject instanceof List) {
        List<PossibleAction> executedActions=(List<PossibleAction>)actionObject;
        numberOfActions=executedActions.size();
        for (        PossibleAction action : executedActions) {
          if (!gameManager.processOnReload(action)) {
            log.error(""String_Node_Str"");
            DisplayBuffer.add(LocalText.getText(""String_Node_Str""));
            break;
          }
        }
      }
 else       if (actionObject instanceof PossibleAction) {
        while (actionObject instanceof PossibleAction) {
          numberOfActions++;
          if (!gameManager.processOnReload((PossibleAction)actionObject)) {
            log.error(""String_Node_Str"");
            DisplayBuffer.add(LocalText.getText(""String_Node_Str""));
            break;
          }
          try {
            actionObject=ois.readObject();
          }
 catch (          EOFException e) {
            break;
          }
        }
      }
      break;
    }
    if (actionObject instanceof SortedMap) {
      ReportBuffer.setCommentItems((SortedMap<Integer,String>)actionObject);
      log.debug(""String_Node_Str"");
    }
 else {
      try {
        object=ois.readObject();
        if (object instanceof SortedMap) {
          ReportBuffer.setCommentItems((SortedMap<Integer,String>)object);
        }
      }
 catch (      IOException e) {
      }
    }
    ois.close();
    game.getGameManager().finishLoading();
    return game;
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",e.getMessage()));
  }
  return null;
}",0.9995619798510732
173666,"public boolean isHomeFor(PublicCompanyI company){
  boolean result=homes != null && homes.get(company) != null;
  return result;
}","public boolean isHomeFor(PublicCompanyI company){
  boolean result=homes != null && homes.containsKey(company);
  return result;
}",0.9230769230769232
173667,"@Override public String toString(){
  StringBuffer b=new StringBuffer();
  b.append(company.getName());
  b.append(""String_Node_Str"").append(getTrain().getName());
  b.append(""String_Node_Str"").append(from.getName());
  if (fixedCost > 0) {
    b.append(""String_Node_Str"").append(Bank.format(fixedCost));
  }
 else {
    b.append(""String_Node_Str"");
  }
  if (specialProperty != null) {
    b.append(""String_Node_Str"").append(specialProperty.getOriginalCompany().getName());
  }
  if (isForExchange()) {
    b.append(forcedExchange ? ""String_Node_Str"" : ""String_Node_Str"");
  }
  if (presidentMustAddCash) {
    b.append(""String_Node_Str"").append(Bank.format(presidentCashToAdd));
  }
 else   if (presidentMayAddCash) {
    b.append(""String_Node_Str"").append(Bank.format(presidentCashToAdd));
  }
  if (acted) {
    b.append(""String_Node_Str"").append(Bank.format(pricePaid));
    if (addedCash > 0)     b.append(""String_Node_Str"" + Bank.format(addedCash));
    if (exchangedTrain != null)     b.append(""String_Node_Str"" + exchangedTrain.getName() + ""String_Node_Str"");
  }
  return b.toString();
}","@Override public String toString(){
  StringBuffer b=new StringBuffer();
  b.append(company.getName());
  if (train != null) {
    b.append(""String_Node_Str"").append(getTrain().getName());
  }
 else {
    b.append(""String_Node_Str"").append(trainUniqueId);
  }
  b.append(""String_Node_Str"").append(from.getName());
  if (fixedCost > 0) {
    b.append(""String_Node_Str"").append(Bank.format(fixedCost));
  }
 else {
    b.append(""String_Node_Str"");
  }
  if (specialProperty != null) {
    b.append(""String_Node_Str"").append(specialProperty.getOriginalCompany().getName());
  }
  if (isForExchange()) {
    b.append(forcedExchange ? ""String_Node_Str"" : ""String_Node_Str"");
  }
  if (presidentMustAddCash) {
    b.append(""String_Node_Str"").append(Bank.format(presidentCashToAdd));
  }
 else   if (presidentMayAddCash) {
    b.append(""String_Node_Str"").append(Bank.format(presidentCashToAdd));
  }
  if (acted) {
    b.append(""String_Node_Str"").append(Bank.format(pricePaid));
    if (addedCash > 0)     b.append(""String_Node_Str"" + Bank.format(addedCash));
    if (exchangedTrain != null)     b.append(""String_Node_Str"" + exchangedTrain.getName() + ""String_Node_Str"");
  }
  return b.toString();
}",0.9580786026200874
173668,"public void removeTile(){
  provisionalGUITile=null;
  setSelected(false);
  setToolTip();
}","public void removeTile(){
  provisionalGUITile=null;
  setSelected(false);
  toolTip=null;
}",0.9456521739130436
173669,"public void removeToken(){
  provisionalGUIToken=null;
  setSelected(false);
  setToolTip();
}","public void removeToken(){
  provisionalGUIToken=null;
  setSelected(false);
  toolTip=null;
}",0.946808510638298
173670,"public void setHexModel(MapHex model){
  this.model=model;
  currentTile=model.getCurrentTile();
  hexName=model.getName();
  currentTileId=model.getCurrentTile().getId();
  currentTileOrientation=model.getCurrentTileRotation();
  currentGUITile=new GUITile(currentTileId,this);
  currentGUITile.setRotation(currentTileOrientation);
  setToolTip();
  model.addObserver(this);
}","public void setHexModel(MapHex model){
  this.model=model;
  currentTile=model.getCurrentTile();
  hexName=model.getName();
  currentTileId=model.getCurrentTile().getId();
  currentTileOrientation=model.getCurrentTileRotation();
  currentGUITile=new GUITile(currentTileId,this);
  currentGUITile.setRotation(currentTileOrientation);
  toolTip=null;
  model.addObserver(this);
}",0.9840848806366048
173671,"public void fixTile(){
  setSelected(false);
  setToolTip();
}","public void fixTile(){
  setSelected(false);
  toolTip=null;
}",0.9193548387096774
173672,"public void fixToken(){
  setSelected(false);
  setToolTip();
}","public void fixToken(){
  setSelected(false);
  toolTip=null;
}",0.9206349206349206
173673,"public String getToolTip(){
  return toolTip;
}","public String getToolTip(){
  if (toolTip != null)   return toolTip;
 else   return getDefaultToolTip();
}",0.6143790849673203
173674,"public void updateOffBoardToolTips(){
  for (  GUIHex hex : hexes) {
    if (hex.getHexModel().hasOffBoardValues()) {
      hex.setToolTip();
    }
  }
}","public void updateOffBoardToolTips(){
}",0.40625
173675,"private void startNewGame(){
  try {
    for (int i=0; i < playerBoxes.length; i++) {
      if (playerBoxes[i] != null && playerBoxes[i].getSelectedIndex() == HUMAN_PLAYER && !playerNameFields[i].getText().equals(""String_Node_Str"")) {
        playerNames.add(playerNameFields[i].getText());
      }
    }
    if (playerNames.size() < Player.MIN_PLAYERS || playerNames.size() > Player.MAX_PLAYERS) {
      if (JOptionPane.showConfirmDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
        return;
      }
    }
  }
 catch (  NullPointerException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this,""String_Node_Str"");
    System.exit(-1);
  }
  if (optionsPane.isVisible()) {
    GameOption option;
    JCheckBox checkbox;
    JComboBox dropdown;
    String value;
    for (int i=0; i < availableOptions.size(); i++) {
      option=availableOptions.get(i);
      if (option.isBoolean()) {
        checkbox=(JCheckBox)optionComponents.get(i);
        value=checkbox.isSelected() ? ""String_Node_Str"" : ""String_Node_Str"";
      }
 else {
        dropdown=(JComboBox)optionComponents.get(i);
        value=(String)dropdown.getSelectedItem();
      }
      selectedOptions.put(option.getName(),value);
      log.info(""String_Node_Str"" + option.getName() + ""String_Node_Str""+ value);
    }
  }
 else {
    GameOption option;
    String value;
    for (int i=0; i < availableOptions.size(); i++) {
      option=availableOptions.get(i);
      value=option.getDefaultValue();
      selectedOptions.put(option.getName(),value);
      log.info(""String_Node_Str"" + option.getName() + ""String_Node_Str""+ value);
    }
  }
  game=new Game(gameName,playerNames,selectedOptions);
  if (!game.setup()) {
    JOptionPane.showMessageDialog(this,DisplayBuffer.get(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(-1);
  }
 else {
    String startError=game.start();
    if (startError != null) {
      JOptionPane.showMessageDialog(this,startError,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      System.exit(-1);
    }
    startGameUIManager(game);
    gameUIManager.gameUIInit();
  }
  this.setVisible(false);
}","private void startNewGame(){
  try {
    for (int i=0; i < playerBoxes.length; i++) {
      if (playerBoxes[i] != null && playerBoxes[i].getSelectedIndex() == HUMAN_PLAYER && !playerNameFields[i].getText().equals(""String_Node_Str"")) {
        playerNames.add(playerNameFields[i].getText());
      }
    }
    if (playerNames.size() < Player.MIN_PLAYERS || playerNames.size() > Player.MAX_PLAYERS) {
      if (JOptionPane.showConfirmDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
        return;
      }
    }
  }
 catch (  NullPointerException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this,""String_Node_Str"");
    System.exit(-1);
  }
  if (optionsPane.isVisible()) {
    GameOption option;
    JCheckBox checkbox;
    JComboBox dropdown;
    String value;
    for (int i=0; i < availableOptions.size(); i++) {
      option=availableOptions.get(i);
      if (option.isBoolean()) {
        checkbox=(JCheckBox)optionComponents.get(i);
        value=checkbox.isSelected() ? ""String_Node_Str"" : ""String_Node_Str"";
      }
 else {
        dropdown=(JComboBox)optionComponents.get(i);
        value=(String)dropdown.getSelectedItem();
      }
      selectedOptions.put(option.getName(),value);
      log.info(""String_Node_Str"" + option.getName() + ""String_Node_Str""+ value);
    }
  }
 else {
    GameOption option;
    String value;
    for (int i=0; i < availableOptions.size(); i++) {
      option=availableOptions.get(i);
      value=option.getDefaultValue();
      selectedOptions.put(option.getName(),value);
      log.info(""String_Node_Str"" + option.getName() + ""String_Node_Str""+ value);
    }
  }
  game=new Game(gameName,playerNames,selectedOptions);
  if (!game.setup()) {
    JOptionPane.showMessageDialog(this,DisplayBuffer.get(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(-1);
  }
 else {
    String startError=game.start();
    if (startError != null) {
      JOptionPane.showMessageDialog(this,startError,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      System.exit(-1);
    }
    startGameUIManager(game);
    gameUIManager.gameUIInit(true);
  }
  this.setVisible(false);
}",0.9990842490842492
173676,"public void gameUIInit(){
  imageLoader=new ImageLoader();
  stockChart=new StockChart(this);
  if (Config.get(""String_Node_Str"").equalsIgnoreCase(""String_Node_Str"")) {
    reportWindow=new ReportWindow(gameManager);
  }
 else {
    reportWindow=new ReportWindowDynamic(this);
  }
  orWindow=new ORWindow(this);
  orUIManager=orWindow.getORUIManager();
  String statusWindowClassName=getClassName(GuiDef.ClassName.STATUS_WINDOW);
  try {
    Class<? extends StatusWindow> statusWindowClass=Class.forName(statusWindowClassName).asSubclass(StatusWindow.class);
    statusWindow=statusWindowClass.newInstance();
    statusWindow.init(this);
  }
 catch (  Exception e) {
    log.fatal(""String_Node_Str"" + statusWindowClassName,e);
    System.exit(1);
  }
  reportWindow.scrollDown();
  configWindow=new ConfigWindow();
  configWindow.init();
}","public void gameUIInit(boolean newGame){
  imageLoader=new ImageLoader();
  stockChart=new StockChart(this);
  if (Config.get(""String_Node_Str"").equalsIgnoreCase(""String_Node_Str"")) {
    reportWindow=new ReportWindow(gameManager);
  }
 else {
    reportWindow=new ReportWindowDynamic(this);
  }
  orWindow=new ORWindow(this);
  orUIManager=orWindow.getORUIManager();
  String statusWindowClassName=getClassName(GuiDef.ClassName.STATUS_WINDOW);
  try {
    Class<? extends StatusWindow> statusWindowClass=Class.forName(statusWindowClassName).asSubclass(StatusWindow.class);
    statusWindow=statusWindowClass.newInstance();
    statusWindow.init(this);
  }
 catch (  Exception e) {
    log.fatal(""String_Node_Str"" + statusWindowClassName,e);
    System.exit(1);
  }
  if (newGame) {
    updateUI();
  }
  reportWindow.scrollDown();
  configWindow=new ConfigWindow();
  configWindow.init();
}",0.9676300578034682
173677,"public void startLoadedGame(){
  gameUIInit();
  processOnServer(new NullAction(NullAction.START_GAME));
  statusWindow.setGameActions();
}","public void startLoadedGame(){
  gameUIInit(false);
  processOnServer(new NullAction(NullAction.START_GAME));
  statusWindow.setGameActions();
}",0.9823321554770318
173678,"public String getOptimalRunPrettyPrint(boolean includeDetails){
  List<RevenueTrainRun> listRuns=getOptimalRun();
  if (listRuns == null)   return LocalText.getText(""String_Node_Str"");
  StringBuffer runPrettyPrint=new StringBuffer();
  for (  RevenueTrainRun run : listRuns) {
    runPrettyPrint.append(run.prettyPrint(includeDetails));
    if (includeDetails)     runPrettyPrint.append(""String_Node_Str"");
 else     if (run != listRuns.get(listRuns.size() - 1))     runPrettyPrint.append(""String_Node_Str"");
  }
  if (includeDetails) {
    for (    RevenueDynamicModifier modifier : dynamicModifiers) {
      runPrettyPrint.append(modifier.prettyPrint(this));
    }
  }
 else {
    int dynamicBonuses=0;
    for (    RevenueDynamicModifier modifier : dynamicModifiers) {
      dynamicBonuses+=modifier.evaluationValue(this.getOptimalRun());
    }
    if (dynamicBonuses != 0) {
      runPrettyPrint.append(""String_Node_Str"" + LocalText.getText(""String_Node_Str"",dynamicBonuses));
    }
  }
  return runPrettyPrint.toString();
}","public String getOptimalRunPrettyPrint(boolean includeDetails){
  List<RevenueTrainRun> listRuns=getOptimalRun();
  if (listRuns == null)   return LocalText.getText(""String_Node_Str"");
  StringBuffer runPrettyPrint=new StringBuffer();
  for (  RevenueTrainRun run : listRuns) {
    runPrettyPrint.append(run.prettyPrint(includeDetails));
    if (!includeDetails && run != listRuns.get(listRuns.size() - 1)) {
      runPrettyPrint.append(""String_Node_Str"");
    }
  }
  if (includeDetails) {
    for (    RevenueDynamicModifier modifier : dynamicModifiers) {
      runPrettyPrint.append(modifier.prettyPrint(this));
    }
  }
 else {
    int dynamicBonuses=0;
    for (    RevenueDynamicModifier modifier : dynamicModifiers) {
      dynamicBonuses+=modifier.evaluationValue(this.getOptimalRun());
    }
    if (dynamicBonuses != 0) {
      runPrettyPrint.append(""String_Node_Str"" + LocalText.getText(""String_Node_Str"",dynamicBonuses));
    }
  }
  return runPrettyPrint.toString();
}",0.922923918448533
173679,"public void revenueUpdate(int bestRevenue,boolean finalResult){
  revenueSelect[orCompIndex].setValue(bestRevenue);
  if (finalResult) {
    revenueAdapter.drawOptimalRunAsPath(orUIManager.getMap());
    orUIManager.getMap().repaint();
    orUIManager.addInformation(""String_Node_Str"" + bestRevenue + ""String_Node_Str""+ revenueAdapter.getOptimalRunPrettyPrint(false));
    orUIManager.addDetail(revenueAdapter.getOptimalRunPrettyPrint(true));
  }
}","public void revenueUpdate(int bestRevenue,boolean finalResult){
  revenueSelect[orCompIndex].setValue(bestRevenue);
  if (finalResult) {
    revenueAdapter.drawOptimalRunAsPath(orUIManager.getMap());
    orUIManager.getMap().repaint();
    orUIManager.addInformation(""String_Node_Str"" + bestRevenue + ""String_Node_Str""+ Util.convertToHtml(revenueAdapter.getOptimalRunPrettyPrint(false)));
    orUIManager.addDetail(Util.convertToHtml(revenueAdapter.getOptimalRunPrettyPrint(true)));
  }
}",0.9572649572649572
173680,"protected void executeNetworkInfo(String companyName){
  GameManagerI gm=orUIManager.getGameUIManager().getGameManager();
  if (companyName.equals(""String_Node_Str"")) {
    NetworkGraphBuilder nwGraph=NetworkGraphBuilder.create(gm);
    SimpleGraph<NetworkVertex,NetworkEdge> mapGraph=nwGraph.getMapGraph();
    mapGraph=NetworkGraphBuilder.optimizeGraph(mapGraph);
    NetworkGraphBuilder.visualize(mapGraph,""String_Node_Str"");
  }
 else {
    CompanyManagerI cm=gm.getCompanyManager();
    PublicCompanyI company=cm.getPublicCompany(companyName);
    List<String> addTrainList=new ArrayList<String>();
    boolean anotherTrain=true;
    RevenueAdapter ra=null;
    while (anotherTrain) {
      ra=RevenueAdapter.createRevenueAdapter(gm,company,gm.getCurrentPhase());
      for (      String addTrain : addTrainList) {
        ra.addTrainByString(addTrain);
      }
      ra.initRevenueCalculator(true);
      log.info(""String_Node_Str"" + ra);
      int revenueValue=ra.calculateRevenue();
      log.info(""String_Node_Str"" + revenueValue);
      log.info(""String_Node_Str"" + ra.getOptimalRunPrettyPrint(true));
      ra.drawOptimalRunAsPath(orUIManager.getMap());
      orUIManager.getMap().repaint();
      JOptionPane.showMessageDialog(orWindow,""String_Node_Str"" + revenueValue + ""String_Node_Str""+ ra.getOptimalRunPrettyPrint(true));
      ra=RevenueAdapter.createRevenueAdapter(gm,company,gm.getCurrentPhase());
      for (      String addTrain : addTrainList) {
        ra.addTrainByString(addTrain);
      }
      ra.initRevenueCalculator(false);
      log.info(""String_Node_Str"" + ra);
      revenueValue=ra.calculateRevenue();
      log.info(""String_Node_Str"" + revenueValue);
      log.info(""String_Node_Str"" + ra.getOptimalRunPrettyPrint(true));
      ra.drawOptimalRunAsPath(orUIManager.getMap());
      orUIManager.getMap().repaint();
      JOptionPane.showMessageDialog(orWindow,""String_Node_Str"" + revenueValue + ""String_Node_Str""+ ra.getOptimalRunPrettyPrint(true));
      String trainString=JOptionPane.showInputDialog(orWindow,""String_Node_Str"",""String_Node_Str"",JOptionPane.QUESTION_MESSAGE);
      if (trainString == null || trainString.equals(""String_Node_Str"")) {
        anotherTrain=false;
      }
 else {
        addTrainList.add(trainString);
      }
    }
    revenueAdapter=ra;
  }
}","protected void executeNetworkInfo(String companyName){
  GameManagerI gm=orUIManager.getGameUIManager().getGameManager();
  if (companyName.equals(""String_Node_Str"")) {
    NetworkGraphBuilder nwGraph=NetworkGraphBuilder.create(gm);
    SimpleGraph<NetworkVertex,NetworkEdge> mapGraph=nwGraph.getMapGraph();
    mapGraph=NetworkGraphBuilder.optimizeGraph(mapGraph);
    NetworkGraphBuilder.visualize(mapGraph,""String_Node_Str"");
  }
 else {
    CompanyManagerI cm=gm.getCompanyManager();
    PublicCompanyI company=cm.getPublicCompany(companyName);
    List<String> addTrainList=new ArrayList<String>();
    boolean anotherTrain=true;
    RevenueAdapter ra=null;
    while (anotherTrain) {
      ra=RevenueAdapter.createRevenueAdapter(gm,company,gm.getCurrentPhase());
      for (      String addTrain : addTrainList) {
        ra.addTrainByString(addTrain);
      }
      ra.initRevenueCalculator(true);
      log.debug(""String_Node_Str"" + ra);
      int revenueValue=ra.calculateRevenue();
      log.debug(""String_Node_Str"" + revenueValue);
      log.debug(""String_Node_Str"" + ra.getOptimalRunPrettyPrint(true));
      ra.drawOptimalRunAsPath(orUIManager.getMap());
      orUIManager.getMap().repaint();
      JOptionPane.showMessageDialog(orWindow,""String_Node_Str"" + revenueValue + ""String_Node_Str""+ ra.getOptimalRunPrettyPrint(true));
      String trainString=JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.QUESTION_MESSAGE);
      if (trainString == null || trainString.equals(""String_Node_Str"")) {
        anotherTrain=false;
      }
 else {
        addTrainList.add(trainString);
      }
    }
    revenueAdapter=ra;
  }
}",0.8279678068410463
173681,"public String toFullInfoString(){
  StringBuffer info=new StringBuffer();
  info.append(""String_Node_Str"" + getConnection());
  info.append(""String_Node_Str"" + greedy);
  info.append(""String_Node_Str"" + distance);
  info.append(""String_Node_Str"" + hiddenVertexes);
  return info.toString();
}","public String toFullInfoString(){
  StringBuffer info=new StringBuffer();
  info.append(""String_Node_Str"" + getConnection());
  info.append(""String_Node_Str"" + greedy);
  info.append(""String_Node_Str"" + distance);
  info.append(""String_Node_Str"" + hiddenVertices);
  return info.toString();
}",0.9931506849315068
173682,"/** 
 * for a given edge it replaces one of the vertices by a different one otherwise copies all edge attributes
 * @return copied edge with replaced vertex, null if oldVertex is neither source, nor target
 */
public static NetworkEdge replaceVertex(NetworkEdge edge,NetworkVertex oldVertex,NetworkVertex newVertex){
  NetworkEdge newEdge;
  if (edge.source == oldVertex) {
    newEdge=new NetworkEdge(newVertex,edge.target,edge.greedy,edge.distance,edge.hiddenVertexes);
  }
 else   if (edge.target == oldVertex) {
    newEdge=new NetworkEdge(edge.source,newVertex,edge.greedy,edge.distance,edge.hiddenVertexes);
  }
 else {
    newEdge=null;
  }
  return newEdge;
}","/** 
 * for a given edge it replaces one of the vertices by a different one otherwise copies all edge attributes
 * @return copied edge with replaced vertex, null if oldVertex is neither source, nor target
 */
public static NetworkEdge replaceVertex(NetworkEdge edge,NetworkVertex oldVertex,NetworkVertex newVertex){
  NetworkEdge newEdge;
  if (edge.source == oldVertex) {
    newEdge=new NetworkEdge(newVertex,edge.target,edge.greedy,edge.distance,edge.hiddenVertices);
  }
 else   if (edge.target == oldVertex) {
    newEdge=new NetworkEdge(edge.source,newVertex,edge.greedy,edge.distance,edge.hiddenVertices);
  }
 else {
    newEdge=null;
  }
  return newEdge;
}",0.9940029985007496
173683,"public NetworkEdge(NetworkVertex source,NetworkVertex target,boolean greedy,int distance,List<NetworkVertex> hiddenVertexes){
  this.source=source;
  this.target=target;
  this.greedy=greedy;
  this.distance=distance;
  this.hiddenVertexes=hiddenVertexes;
}","public NetworkEdge(NetworkVertex source,NetworkVertex target,boolean greedy,int distance,List<NetworkVertex> hiddenVertexes){
  this.source=source;
  this.target=target;
  this.greedy=greedy;
  this.distance=distance;
  this.hiddenVertices=hiddenVertexes;
}",0.9922178988326849
173684,"public static MergeResult mergeEdges(NetworkEdge edgeA,NetworkEdge edgeB){
  log.info(""String_Node_Str"" + edgeA.toFullInfoString() + ""String_Node_Str""+ edgeB.toFullInfoString());
  NetworkVertex sourceA=edgeA.getSource();
  NetworkVertex targetA=edgeA.getTarget();
  NetworkVertex sourceB=edgeB.getSource();
  NetworkVertex targetB=edgeB.getTarget();
  NetworkVertex newSource, newTarget, vertex=null;
  boolean reverseA=false, reverseB=false;
  if (sourceA == sourceB) {
    newSource=targetA;
    newTarget=targetB;
    vertex=sourceA;
    reverseA=true;
  }
 else   if (sourceA == targetB) {
    newSource=targetA;
    newTarget=sourceB;
    vertex=sourceA;
    reverseA=true;
    reverseB=true;
  }
 else   if (targetA == sourceB) {
    newSource=sourceA;
    newTarget=targetB;
    vertex=targetA;
  }
 else   if (targetA == targetB) {
    newSource=sourceA;
    newTarget=sourceB;
    vertex=targetA;
    reverseB=true;
  }
 else {
    return null;
  }
  log.info(""String_Node_Str"" + newSource + ""String_Node_Str""+ newTarget+ ""String_Node_Str""+ vertex);
  int distance=edgeA.getDistance() + edgeB.getDistance();
  List<NetworkVertex> hiddenVertexes=new ArrayList<NetworkVertex>();
  List<NetworkVertex> hiddenA=edgeA.getHiddenVertexes();
  if (reverseA) {
    hiddenA=new ArrayList<NetworkVertex>(hiddenA);
    Collections.reverse(hiddenA);
  }
  List<NetworkVertex> hiddenB=edgeB.getHiddenVertexes();
  if (reverseB) {
    hiddenB=new ArrayList<NetworkVertex>(hiddenB);
    Collections.reverse(hiddenB);
  }
  hiddenVertexes.addAll(hiddenA);
  hiddenVertexes.add(vertex);
  hiddenVertexes.addAll(hiddenB);
  NetworkEdge newEdge=new NetworkEdge(newSource,newTarget,true,distance,hiddenVertexes);
  log.info(""String_Node_Str"" + newEdge.toFullInfoString());
  return new MergeResult(newEdge,vertex);
}","public static MergeResult mergeEdges(NetworkEdge edgeA,NetworkEdge edgeB){
  log.info(""String_Node_Str"" + edgeA.toFullInfoString() + ""String_Node_Str""+ edgeB.toFullInfoString());
  NetworkVertex sourceA=edgeA.getSource();
  NetworkVertex targetA=edgeA.getTarget();
  NetworkVertex sourceB=edgeB.getSource();
  NetworkVertex targetB=edgeB.getTarget();
  NetworkVertex newSource, newTarget, vertex=null;
  boolean reverseA=false, reverseB=false;
  if (sourceA == sourceB) {
    newSource=targetA;
    newTarget=targetB;
    vertex=sourceA;
    reverseA=true;
  }
 else   if (sourceA == targetB) {
    newSource=targetA;
    newTarget=sourceB;
    vertex=sourceA;
    reverseA=true;
    reverseB=true;
  }
 else   if (targetA == sourceB) {
    newSource=sourceA;
    newTarget=targetB;
    vertex=targetA;
  }
 else   if (targetA == targetB) {
    newSource=sourceA;
    newTarget=sourceB;
    vertex=targetA;
    reverseB=true;
  }
 else {
    return null;
  }
  log.info(""String_Node_Str"" + newSource + ""String_Node_Str""+ newTarget+ ""String_Node_Str""+ vertex);
  int distance=edgeA.getDistance() + edgeB.getDistance();
  List<NetworkVertex> hiddenVertexes=new ArrayList<NetworkVertex>();
  List<NetworkVertex> hiddenA=edgeA.getHiddenVertices();
  if (reverseA) {
    hiddenA=new ArrayList<NetworkVertex>(hiddenA);
    Collections.reverse(hiddenA);
  }
  List<NetworkVertex> hiddenB=edgeB.getHiddenVertices();
  if (reverseB) {
    hiddenB=new ArrayList<NetworkVertex>(hiddenB);
    Collections.reverse(hiddenB);
  }
  hiddenVertexes.addAll(hiddenA);
  hiddenVertexes.add(vertex);
  hiddenVertexes.addAll(hiddenB);
  NetworkEdge newEdge=new NetworkEdge(newSource,newTarget,true,distance,hiddenVertexes);
  log.info(""String_Node_Str"" + newEdge.toFullInfoString());
  return new MergeResult(newEdge,vertex);
}",0.9977839335180057
173685,"/** 
 * creates a new virtual vertex with identical properties and links
 */
public static NetworkVertex duplicateVertex(SimpleGraph<NetworkVertex,NetworkEdge> graph,NetworkVertex vertex,String newIdentifier,boolean addOldVertexAsHidden){
  NetworkVertex newVertex=NetworkVertex.getVirtualVertex(vertex.type,newIdentifier);
  newVertex.stationType=vertex.stationType;
  newVertex.value=vertex.value;
  newVertex.sink=vertex.sink;
  newVertex.cityName=vertex.cityName;
  graph.addVertex(newVertex);
  Set<NetworkEdge> edges=graph.edgesOf(vertex);
  for (  NetworkEdge edge : edges) {
    List<NetworkVertex> hiddenVertices;
    if (edge.getSource() == vertex) {
      hiddenVertices=edge.getHiddenVertexes();
      if (addOldVertexAsHidden)       hiddenVertices.add(vertex);
      NetworkEdge newEdge=new NetworkEdge(newVertex,edge.getTarget(),edge.isGreedy(),edge.getDistance(),hiddenVertices);
      graph.addEdge(newVertex,edge.getTarget(),newEdge);
    }
 else {
      hiddenVertices=new ArrayList<NetworkVertex>();
      if (addOldVertexAsHidden)       hiddenVertices.add(vertex);
      hiddenVertices.addAll(edge.getHiddenVertexes());
      NetworkEdge newEdge=new NetworkEdge(edge.getSource(),newVertex,edge.isGreedy(),edge.getDistance(),hiddenVertices);
      graph.addEdge(newEdge.getSource(),newVertex,newEdge);
    }
  }
  return newVertex;
}","/** 
 * creates a new virtual vertex with identical properties and links
 */
public static NetworkVertex duplicateVertex(SimpleGraph<NetworkVertex,NetworkEdge> graph,NetworkVertex vertex,String newIdentifier,boolean addOldVertexAsHidden){
  NetworkVertex newVertex=NetworkVertex.getVirtualVertex(vertex.type,newIdentifier);
  newVertex.stationType=vertex.stationType;
  newVertex.value=vertex.value;
  newVertex.sink=vertex.sink;
  newVertex.cityName=vertex.cityName;
  graph.addVertex(newVertex);
  Set<NetworkEdge> edges=graph.edgesOf(vertex);
  for (  NetworkEdge edge : edges) {
    List<NetworkVertex> hiddenVertices;
    if (edge.getSource() == vertex) {
      hiddenVertices=edge.getHiddenVertices();
      if (addOldVertexAsHidden)       hiddenVertices.add(vertex);
      NetworkEdge newEdge=new NetworkEdge(newVertex,edge.getTarget(),edge.isGreedy(),edge.getDistance(),hiddenVertices);
      graph.addEdge(newVertex,edge.getTarget(),newEdge);
    }
 else {
      hiddenVertices=new ArrayList<NetworkVertex>();
      if (addOldVertexAsHidden)       hiddenVertices.add(vertex);
      hiddenVertices.addAll(edge.getHiddenVertices());
      NetworkEdge newEdge=new NetworkEdge(edge.getSource(),newVertex,edge.isGreedy(),edge.getDistance(),hiddenVertices);
      graph.addEdge(newEdge.getSource(),newVertex,newEdge);
    }
  }
  return newVertex;
}",0.9970414201183432
173686,"GeneralPath getAsPath(HexMap map){
  GeneralPath path=new GeneralPath();
  for (  NetworkEdge edge : edges) {
    Point2D sourcePoint=NetworkVertex.getVertexPoint2D(map,edge.getSource());
    if (sourcePoint != null) {
      path.moveTo((float)sourcePoint.getX(),(float)sourcePoint.getY());
    }
    for (    NetworkVertex hiddenVertex : edge.getHiddenVertexes()) {
      Point2D hiddenPoint=NetworkVertex.getVertexPoint2D(map,hiddenVertex);
      if (hiddenPoint != null) {
        path.lineTo((float)hiddenPoint.getX(),(float)hiddenPoint.getY());
      }
    }
    Point2D targetPoint=NetworkVertex.getVertexPoint2D(map,edge.getTarget());
    if (targetPoint != null) {
      path.lineTo((float)targetPoint.getX(),(float)targetPoint.getY());
    }
  }
  return path;
}","GeneralPath getAsPath(HexMap map){
  GeneralPath path=new GeneralPath();
  for (  NetworkEdge edge : edges) {
    List<NetworkVertex> edgeVertices=edge.getVertexPath();
    boolean initPath=false;
    for (    NetworkVertex edgeVertex : edgeVertices) {
      Point2D edgePoint=NetworkVertex.getVertexPoint2D(map,edgeVertex);
      if (edgePoint == null)       continue;
      if (!initPath) {
        path.moveTo((float)edgePoint.getX(),(float)edgePoint.getY());
        initPath=true;
      }
 else {
        path.lineTo((float)edgePoint.getX(),(float)edgePoint.getY());
      }
    }
  }
  return path;
}",0.2599854756717502
173687,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  ObjectInputStream.GetField fields=in.readFields();
  certUniqueId=(String)fields.get(""String_Node_Str"",null);
  companyName=(String)fields.get(""String_Node_Str"",null);
  fromName=(String)fields.get(""String_Node_Str"",fromName);
  price=fields.get(""String_Node_Str"",price);
  maximumNumber=fields.get(""String_Node_Str"",maximumNumber);
  sharePerCert=fields.get(""String_Node_Str"",-1);
  numberBought=fields.get(""String_Node_Str"",numberBought);
  GameManagerI gameManager=GameManager.getInstance();
  CompanyManagerI companyManager=gameManager.getCompanyManager();
  companyName=companyManager.checkAlias(companyName);
  certUniqueId=companyManager.checkAliasInCertId(certUniqueId);
  if (certUniqueId != null) {
    certificate=PublicCertificate.getByUniqueId(certUniqueId);
    from=gameManager.getPortfolioByName(fromName);
    company=certificate.getCompany();
    companyName=company.getName();
    sharePerCert=certificate.getShare();
  }
 else   if (companyName != null) {
    company=gameManager.getCompanyManager().getPublicCompany(companyName);
    from=gameManager.getPortfolioByUniqueName(fromName);
  }
}","private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  ObjectInputStream.GetField fields=in.readFields();
  certUniqueId=(String)fields.get(""String_Node_Str"",null);
  companyName=(String)fields.get(""String_Node_Str"",null);
  fromName=(String)fields.get(""String_Node_Str"",fromName);
  price=fields.get(""String_Node_Str"",price);
  maximumNumber=fields.get(""String_Node_Str"",maximumNumber);
  sharePerCert=fields.get(""String_Node_Str"",-1);
  numberBought=fields.get(""String_Node_Str"",numberBought);
  GameManagerI gameManager=GameManager.getInstance();
  CompanyManagerI companyManager=gameManager.getCompanyManager();
  companyName=companyManager.checkAlias(companyName);
  if (certUniqueId != null) {
    certUniqueId=companyManager.checkAliasInCertId(certUniqueId);
    certificate=PublicCertificate.getByUniqueId(certUniqueId);
    from=gameManager.getPortfolioByName(fromName);
    company=certificate.getCompany();
    companyName=company.getName();
    sharePerCert=certificate.getShare();
  }
 else   if (companyName != null) {
    company=gameManager.getCompanyManager().getPublicCompany(companyName);
    from=gameManager.getPortfolioByUniqueName(fromName);
  }
}",0.6810273405136703
173688,"protected void setToolTip(){
  StringBuffer tt=new StringBuffer(""String_Node_Str"");
  tt.append(""String_Node_Str"").append(hexName);
  String name=model.getCityName();
  if (Util.hasValue(name)) {
    tt.append(""String_Node_Str"").append(name).append(""String_Node_Str"");
  }
  tt.append(""String_Node_Str"").append(currentTile.getId());
  tt.append(""String_Node_Str"" + currentTileOrientation + ""String_Node_Str"");
  if (model.hasOffBoardValues()) {
    tt.append(""String_Node_Str"");
    tt.append(model.getCurrentOffBoardValue(hexMap.getPhase())).append(""String_Node_Str"");
    int[] values=model.getOffBoardValues();
    for (int i=0; i < values.length; i++) {
      if (i > 0)       tt.append(""String_Node_Str"");
      tt.append(values[i]);
    }
    tt.append(""String_Node_Str"");
  }
 else   if (currentTile.hasStations()) {
    Station st;
    int cityNumber;
    for (    City city : model.getCities()) {
      cityNumber=city.getNumber();
      st=city.getRelatedStation();
      tt.append(""String_Node_Str"").append(st.getType()).append(""String_Node_Str"").append(cityNumber).append(""String_Node_Str"").append(model.getConnectionString(cityNumber)).append(""String_Node_Str"");
      tt.append(st.getValue());
      if (st.getBaseSlots() > 0) {
        tt.append(""String_Node_Str"").append(st.getBaseSlots()).append(""String_Node_Str"");
        List<TokenI> tokens=model.getTokens(cityNumber);
        if (tokens.size() > 0) {
          tt.append(""String_Node_Str"");
          int oldsize=tt.length();
          for (          TokenI token : tokens) {
            if (tt.length() > oldsize)             tt.append(""String_Node_Str"");
            tt.append(token.getName());
          }
          tt.append(""String_Node_Str"");
        }
      }
      tt.append(""String_Node_Str"" + st.getPosition() + ""String_Node_Str"");
    }
  }
  String upgrades=currentTile.getUpgradesString(model);
  if (upgrades.equals(""String_Node_Str"")) {
    tt.append(""String_Node_Str"");
  }
 else {
    tt.append(""String_Node_Str"").append(upgrades);
    if (model.getTileCost() > 0)     tt.append(""String_Node_Str"" + Bank.format(model.getTileCost()));
  }
  if (getHexModel().getDestinations() != null) {
    tt.append(""String_Node_Str"");
    for (    PublicCompanyI dest : getHexModel().getDestinations()) {
      tt.append(""String_Node_Str"");
      tt.append(dest.getName());
    }
  }
  tt.append(""String_Node_Str"");
  toolTip=tt.toString();
}","protected void setToolTip(){
  StringBuffer tt=new StringBuffer(""String_Node_Str"");
  tt.append(""String_Node_Str"").append(hexName);
  String name=model.getCityName();
  if (Util.hasValue(name)) {
    tt.append(""String_Node_Str"").append(name).append(""String_Node_Str"");
  }
  tt.append(""String_Node_Str"").append(currentTile.getId());
  tt.append(""String_Node_Str"" + currentTileOrientation + ""String_Node_Str"");
  if (model.hasOffBoardValues()) {
    tt.append(""String_Node_Str"");
    tt.append(model.getCurrentOffBoardValue(hexMap.getPhase())).append(""String_Node_Str"");
    int[] values=model.getOffBoardValues();
    for (int i=0; i < values.length; i++) {
      if (i > 0)       tt.append(""String_Node_Str"");
      tt.append(values[i]);
    }
    tt.append(""String_Node_Str"");
  }
 else   if (currentTile.hasStations()) {
    Station st;
    int cityNumber;
    for (    City city : model.getCities()) {
      cityNumber=city.getNumber();
      st=city.getRelatedStation();
      tt.append(""String_Node_Str"").append(st.getType()).append(""String_Node_Str"").append(cityNumber).append(""String_Node_Str"").append(model.getConnectionString(cityNumber)).append(""String_Node_Str"");
      tt.append(st.getValue());
      if (st.getBaseSlots() > 0) {
        tt.append(""String_Node_Str"").append(st.getBaseSlots()).append(""String_Node_Str"");
        List<TokenI> tokens=model.getTokens(cityNumber);
        if (tokens.size() > 0) {
          tt.append(""String_Node_Str"");
          int oldsize=tt.length();
          for (          TokenI token : tokens) {
            if (tt.length() > oldsize)             tt.append(""String_Node_Str"");
            tt.append(token.getName());
          }
          tt.append(""String_Node_Str"");
        }
      }
      tt.append(""String_Node_Str"" + st.getPosition() + ""String_Node_Str"");
    }
    tt.append(bonusToolTipText(currentTile.getRevenueBonuses()));
  }
  tt.append(bonusToolTipText(model.getRevenueBonuses()));
  String upgrades=currentTile.getUpgradesString(model);
  if (upgrades.equals(""String_Node_Str"")) {
    tt.append(""String_Node_Str"");
  }
 else {
    tt.append(""String_Node_Str"").append(upgrades);
    if (model.getTileCost() > 0)     tt.append(""String_Node_Str"" + Bank.format(model.getTileCost()));
  }
  if (getHexModel().getDestinations() != null) {
    tt.append(""String_Node_Str"");
    for (    PublicCompanyI dest : getHexModel().getDestinations()) {
      tt.append(""String_Node_Str"");
      tt.append(dest.getName());
    }
  }
  tt.append(""String_Node_Str"");
  toolTip=tt.toString();
}",0.9749899152884228
173689,"/** 
 * Adds cash back to the bank
 */
public boolean addCash(int amount){
  boolean negative=money.addCash(amount);
  if (money.getCash() <= 0 && !broken.booleanValue()) {
    broken.set(true);
    GameManager.getInstance().registerBrokenBank();
  }
  return negative;
}","/** 
 * Adds cash back to the bank
 */
public void addCash(int amount){
  money.addCash(amount);
  if (money.getCash() <= 0 && !broken.booleanValue()) {
    broken.set(true);
    GameManager.getInstance().registerBrokenBank();
  }
}",0.9065606361829026
173690,"/** 
 * Add (or subtract) cash.
 */
public abstract boolean addCash(int amount);","/** 
 * Add (or subtract) cash.
 */
public abstract void addCash(int amount);",0.9426751592356688
173691,"public boolean addCash(int amount){
  boolean result=wallet.addCash(amount);
  return result;
}","public void addCash(int amount){
  wallet.addCash(amount);
}",0.7354838709677419
173692,"/** 
 * Add a given amount to the company treasury.
 * @param amount The amount to add (may be negative).
 */
public boolean addCash(int amount){
  return treasury.addCash(amount);
}","/** 
 * Add a given amount to the company treasury.
 * @param amount The amount to add (may be negative).
 */
public void addCash(int amount){
  treasury.addCash(amount);
}",0.9548022598870056
173693,"/** 
 * Buying one or more single or double-share certificates (more is sometimes possible)
 * @param player The player that wants to buy shares.
 * @param action The executed action
 * @return True if the certificates could be bought. False indicates anerror.
 */
@Override public boolean buyShares(String playerName,BuyCertificate action){
  PublicCompanyI company=action.getCompany();
  Portfolio from=action.getFromPortfolio();
  String companyName=company.getName();
  int number=action.getNumberBought();
  int shareUnit=company.getShareUnit();
  int sharePerCert=action.getSharePerCertificate();
  int shares=number * sharePerCert;
  String errMsg=null;
  int price=0;
  Portfolio portfolio=null;
  currentPlayer=getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,currentPlayer.getName());
      break;
    }
    company=companyManager.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company != operatingCompany) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,operatingCompany.getName());
    }
    if (!company.hasFloated()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.mustHaveOperatedToTradeShares() && !company.hasOperated()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (hasSold.booleanValue()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (shares > from.getShare(company)) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,from.getName());
      break;
    }
    portfolio=operatingCompany.getPortfolio();
    int treasuryShareLimit=getGameParameterAsInt(GameDef.Parm.TREASURY_SHARE_LIMIT);
    if (portfolio.getShare(company) + shares * company.getShareUnit() > treasuryShareLimit) {
      errMsg=LocalText.getText(""String_Node_Str"",String.valueOf(treasuryShareLimit));
      break;
    }
    price=company.getMarketPrice();
    if (operatingCompany.getCash() < shares * price) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,shares,companyName,from.getName(),errMsg));
    return false;
  }
  if (number == 1) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,shareUnit,companyName,from.getName(),Bank.format(shares * price)));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,number,shareUnit,number * shareUnit,companyName,from.getName(),Bank.format(shares * price)));
  }
  moveStack.start(true);
  PublicCertificateI cert2;
  for (int i=0; i < number; i++) {
    cert2=from.findCertificate(company,sharePerCert,false);
    executeTradeCertificate(cert2,portfolio,cert2.getShares() * price);
  }
  hasBought.set(true);
  return true;
}","/** 
 * Buying one or more single or double-share certificates (more is sometimes possible)
 * @param player The player that wants to buy shares.
 * @param action The executed action
 * @return True if the certificates could be bought. False indicates anerror.
 */
@Override public boolean buyShares(String playerName,BuyCertificate action){
  PublicCompanyI company=action.getCompany();
  Portfolio from=action.getFromPortfolio();
  String companyName=company.getName();
  int number=action.getNumberBought();
  int shareUnit=company.getShareUnit();
  int sharePerCert=action.getSharePerCertificate();
  int share=number * sharePerCert;
  int shares=share / shareUnit;
  String errMsg=null;
  int price=0;
  Portfolio portfolio=null;
  currentPlayer=getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,currentPlayer.getName());
      break;
    }
    company=companyManager.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company != operatingCompany) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,operatingCompany.getName());
    }
    if (!company.hasFloated()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.mustHaveOperatedToTradeShares() && !company.hasOperated()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (hasSold.booleanValue()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (share > from.getShare(company)) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,from.getName());
      break;
    }
    portfolio=operatingCompany.getPortfolio();
    int treasuryShareLimit=getGameParameterAsInt(GameDef.Parm.TREASURY_SHARE_LIMIT);
    if (portfolio.getShare(company) + share > treasuryShareLimit) {
      errMsg=LocalText.getText(""String_Node_Str"",String.valueOf(treasuryShareLimit));
      break;
    }
    price=company.getMarketPrice();
    if (operatingCompany.getCash() < shares * price) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,shares,companyName,from.getName(),errMsg));
    return false;
  }
  if (number == 1) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,shareUnit,companyName,from.getName(),Bank.format(shares * price)));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,number,shareUnit,number * shareUnit,companyName,from.getName(),Bank.format(shares * price)));
  }
  moveStack.start(true);
  PublicCertificateI cert2;
  for (int i=0; i < number; i++) {
    cert2=from.findCertificate(company,sharePerCert / shareUnit,false);
    executeTradeCertificate(cert2,portfolio,cert2.getShares() * price);
  }
  hasBought.set(true);
  return true;
}",0.988095238095238
173694,"public boolean addCash(int addedCash){
  cash+=addedCash;
  update();
  if (cash <= 0)   return false;
 else   return true;
}","public void addCash(int addedCash){
  cash+=addedCash;
  update();
}",0.6735751295336787
173695,"public String getText(){
  if (cash == 0 && (option & SUPPRESS_ZERO) > 0 || owner instanceof PublicCompanyI && !((PublicCompanyI)owner).hasStarted()) {
    return ""String_Node_Str"";
  }
 else {
    return Bank.format(cash);
  }
}","@Override public String getText(){
  if (cash == 0 && (option & SUPPRESS_ZERO) > 0 || owner instanceof PublicCompanyI && !((PublicCompanyI)owner).hasStarted()) {
    return ""String_Node_Str"";
  }
 else {
    return Bank.format(cash);
  }
}",0.9786324786324786
173696,"private boolean transferCash(CashHolder from,CashHolder to,int amount){
  return to.addCash(amount) && from.addCash(-amount);
}","private void transferCash(CashHolder from,CashHolder to,int amount){
  to.addCash(amount);
  from.addCash(-amount);
}",0.918032786885246
173697,"public void linkToPreviousMoveSet(){
  if (currentMoveSet != null) {
    currentMoveSet.linkToPreviousMoveSet();
  }
 else {
    log.warn(""String_Node_Str"");
  }
}","public void linkToPreviousMoveSet(){
  if (currentMoveSet != null) {
    currentMoveSet.linkToPreviousMoveSet();
    log.debug(""String_Node_Str"");
  }
 else {
    log.warn(""String_Node_Str"");
  }
}",0.9055555555555556
173698,"public boolean discardTrain(DiscardTrain action){
  TrainI train=action.getDiscardedTrain();
  PublicCompanyI company=action.getCompany();
  String companyName=company.getName();
  String errMsg=null;
  while (true) {
    if (company != cgr) {
      errMsg=LocalText.getText(""String_Node_Str"",company.getName(),cgrName);
      break;
    }
    if (getStep() != STEP_DISCARD_TRAINS) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (train == null && action.isForced()) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (train != null && !company.getPortfolio().getTrainList().contains(train)) {
      errMsg=LocalText.getText(""String_Node_Str"",company.getName(),train.getName());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getName(),errMsg));
    return false;
  }
  moveStack.start(true);
  if (train != null) {
    if (action.isForced())     moveStack.linkToPreviousMoveSet();
    train.moveTo(pool);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getName()));
  }
 else {
    cgrHasDiscardedTrains.set(true);
  }
  return true;
}","public boolean discardTrain(DiscardTrain action){
  TrainI train=action.getDiscardedTrain();
  PublicCompanyI company=action.getCompany();
  String companyName=company.getName();
  String errMsg=null;
  while (true) {
    if (company != cgr) {
      errMsg=LocalText.getText(""String_Node_Str"",company.getName(),cgrName);
      break;
    }
    if (getStep() != STEP_DISCARD_TRAINS) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (train == null && action.isForced()) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (train != null && !company.getPortfolio().getTrainList().contains(train)) {
      errMsg=LocalText.getText(""String_Node_Str"",company.getName(),train.getName());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getName(),errMsg));
    return false;
  }
  moveStack.start(true);
  if (train != null) {
    train.moveTo(pool);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getName()));
  }
 else {
    cgrHasDiscardedTrains.set(true);
  }
  moveStack.linkToPreviousMoveSet();
  return true;
}",0.9568857262452908
173699,"private void formCGR(){
  Player player;
  Portfolio portfolio;
  int count, cgrSharesUsed, oldShares, newShares;
  PublicCertificateI cgrCert, poolCert;
  List<PublicCertificateI> certs=new ArrayList<PublicCertificateI>();
  Player temporaryPresident=null;
  Player newPresident=null;
  Player firstCGRowner=null;
  int maxShares=0;
  setCurrentPlayer(startingPlayer);
  cgrSharesUsed=0;
  ReportBuffer.add(""String_Node_Str"");
  do {
    player=getCurrentPlayer();
    portfolio=player.getPortfolio();
    oldShares=newShares=0;
    certs.clear();
    poolCert=null;
    for (    PublicCertificateI cert : player.getPortfolio().getCertificates()) {
      if (mergingCompanies.contains(cert.getCompany())) {
        certs.add((cert));
        oldShares++;
        if (cert.isPresidentShare()) {
          oldShares++;
        }
      }
    }
    if (oldShares > 0) {
      count=oldShares;
      if (count >= 4 && temporaryPresident == null && cgrSharesUsed <= 18) {
        cgrCert=cgr.getPresidentsShare();
        cgrCert.moveTo(portfolio);
        count-=4;
        cgrSharesUsed+=2;
        newShares+=2;
        temporaryPresident=player;
      }
      while (count >= 2 && cgrSharesUsed <= 19) {
        cgrCert=unavailable.findCertificate(cgr,false);
        cgrCert.moveTo(portfolio);
        count-=2;
        cgrSharesUsed++;
        newShares++;
      }
      String message=LocalText.getText(""String_Node_Str"",player.getName(),oldShares,newShares,PublicCompany_CGR.NAME);
      DisplayBuffer.add(message,false);
      ReportBuffer.add(message);
      if (count == 1) {
        poolCert=certs.get(certs.size() - 1);
        poolCert.moveTo(pool);
        certs.remove(poolCert);
        message=LocalText.getText(""String_Node_Str"",player.getName());
        DisplayBuffer.add(message,false);
        ReportBuffer.add(message);
      }
      if (firstCGRowner == null)       firstCGRowner=player;
      if (newShares > maxShares) {
        maxShares=newShares;
        newPresident=player;
      }
    }
    gameManager.setNextPlayer();
  }
 while (getCurrentPlayer() != startingPlayer);
  certs.clear();
  oldShares=newShares=0;
  for (  PublicCertificateI cert : pool.getCertificates()) {
    if (mergingCompanies.contains(cert.getCompany())) {
      certs.add((cert));
      oldShares++;
    }
  }
  count=oldShares;
  while (count >= 2 && cgrSharesUsed <= 19) {
    cgrCert=unavailable.findCertificate(cgr,false);
    cgrCert.moveTo(pool);
    count-=2;
    cgrSharesUsed++;
    newShares++;
  }
  String message=LocalText.getText(""String_Node_Str"",LocalText.getText(""String_Node_Str""),oldShares,newShares,PublicCompany_CGR.NAME);
  DisplayBuffer.add(message);
  ReportBuffer.add(message);
  for (  PublicCertificateI discardCert : certs) {
    discardCert.moveTo(scrapHeap);
  }
  log.info(cgrSharesUsed + ""String_Node_Str"");
  if (cgrSharesUsed <= 10) {
    cgr.setShareUnit(10);
  }
  message=LocalText.getText(""String_Node_Str"",cgr.getName(),100 / cgr.getShareUnit(),cgr.getShareUnit());
  DisplayBuffer.add(message);
  ReportBuffer.add(message);
  certs=new ArrayList<PublicCertificateI>(unavailable.getCertificatesPerCompany(PublicCompany_CGR.NAME));
  for (  PublicCertificateI cert : certs) {
    cert.moveTo(ipo);
  }
  if (newPresident.getPortfolio().getShare(cgr) == cgr.getShareUnit()) {
    log.debug(""String_Node_Str"" + firstCGRowner.getName());
    cgr.setTemporaryPresident(firstCGRowner);
    newPresident=firstCGRowner;
  }
 else   if (temporaryPresident != null && temporaryPresident != newPresident) {
    log.debug(""String_Node_Str"" + temporaryPresident.getName() + ""String_Node_Str""+ newPresident.getName());
    temporaryPresident.getPortfolio().swapPresidentCertificate(cgr,newPresident.getPortfolio());
  }
  newPresident.getPortfolio().getShareModel(cgr).setShare();
  message=LocalText.getText(""String_Node_Str"",newPresident.getName(),cgrName);
  ReportBuffer.add(message);
  DisplayBuffer.add(message);
  int lowestPrice=999;
  int totalPrice=0;
  int price;
  int numberMerged=mergingCompanies.size();
  for (  PublicCompanyI comp : mergingCompanies) {
    price=comp.getMarketPrice();
    totalPrice+=price;
    if (price < lowestPrice)     lowestPrice=price;
  }
  if (numberMerged >= 3) {
    totalPrice-=lowestPrice;
    numberMerged--;
  }
  int cgrPrice=Math.max(100,(((totalPrice / numberMerged) / 5)) * 5);
  if (cgrPrice == 100) {
    cgr.start(100);
  }
 else {
    int prevColPrice=100;
    int colPrice;
    StockSpaceI startSpace;
    for (int col=6; col <= stockMarket.getNumberOfColumns(); col++) {
      colPrice=stockMarket.getStockSpace(1,col).getPrice();
      if (cgrPrice > colPrice)       continue;
      if (cgrPrice - prevColPrice < colPrice - cgrPrice) {
        startSpace=stockMarket.getStockSpace(1,col - 1);
      }
 else {
        startSpace=stockMarket.getStockSpace(1,col);
      }
      cgr.start(startSpace);
      message=LocalText.getText(""String_Node_Str"",PublicCompany_CGR.NAME,Bank.format(startSpace.getPrice()),startSpace.getName());
      DisplayBuffer.add(message);
      ReportBuffer.add(message);
      break;
    }
  }
  cgr.setFloated();
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",PublicCompany_CGR.NAME));
  int numCompanies=Math.min(11,12 - mergingCompanies.size());
  int numPlayers=gameManager.getNumberOfPlayers();
  int newCertLimit=certLimitsTable[numPlayers - 3][numCompanies - 4];
  gameManager.setPlayerCertificateLimit(newCertLimit);
  message=LocalText.getText(""String_Node_Str"",newCertLimit,numPlayers,numCompanies);
  DisplayBuffer.add(message);
  ReportBuffer.add(message);
  List<BaseToken> homeTokens=new ArrayList<BaseToken>();
  nonHomeTokens=new ArrayList<BaseToken>();
  BaseToken bt;
  MapHex hex;
  City city;
  for (  PublicCompanyI comp : mergingCompanies) {
    for (    TokenI token : comp.getTokens()) {
      if (token instanceof BaseToken) {
        bt=(BaseToken)token;
        if (!bt.isPlaced())         continue;
        city=(City)bt.getHolder();
        hex=city.getHolder();
        if (hex == comp.getHomeHex()) {
          homeTokens.add(bt);
        }
 else {
          nonHomeTokens.add(bt);
        }
      }
    }
    if (comp.getCash() > 0) {
      new CashMove(comp,cgr,comp.getCash());
    }
    List<TrainI> trains=new ArrayList<TrainI>(comp.getPortfolio().getTrainList());
    for (    TrainI train : trains) {
      train.moveTo(cgr.getPortfolio());
      if (train.getType().isPermanent())       cgr.setHadPermanentTrain(true);
    }
    if (comp.getBonuses() != null) {
      List<Bonus> bonuses=new ArrayList<Bonus>(comp.getBonuses());
      bonuses:       for (      Bonus bonus : bonuses) {
        comp.removeBonus(bonus);
        if (cgr.getBonuses() != null) {
          for (          Bonus b : cgr.getBonuses()) {
            if (b.equals(bonus)) {
              List<SellBonusToken> commonSP=gameManager.getSpecialProperties(SellBonusToken.class,true);
              if (commonSP != null) {
                for (                SellBonusToken sp : commonSP) {
                  if (sp.getName().equalsIgnoreCase(b.getName())) {
                    sp.makeResellable();
                    log.debug(""String_Node_Str"" + b.getName() + ""String_Node_Str"");
                    break;
                  }
                }
              }
              log.debug(""String_Node_Str"" + b.getName() + ""String_Node_Str""+ cgrName);
              continue bonuses;
            }
          }
        }
        cgr.addBonus(new Bonus(cgr,bonus.getName(),bonus.getValue(),bonus.getLocations()));
      }
    }
  }
  ReportBuffer.add(""String_Node_Str"");
  for (  BaseToken token : homeTokens) {
    city=(City)token.getHolder();
    hex=city.getHolder();
    token.moveTo(token.getCompany());
    if (hex.layBaseToken(cgr,city.getNumber())) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgrName,token.getCompany().getName(),city.getName()));
      cgr.layBaseToken(hex,0);
    }
  }
  for (  BaseToken token : new ArrayList<BaseToken>(nonHomeTokens)) {
    city=(City)token.getHolder();
    hex=city.getHolder();
    List<BaseToken> otherTokens=hex.getBaseTokens();
    if (otherTokens != null) {
      for (      BaseToken token2 : otherTokens) {
        if (token2.getCompany() == cgr || nonHomeTokens.contains(token2) && token2 != token) {
          ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgrName,token.getCompany().getName(),city.getName()));
          token.moveTo(token.getCompany());
          nonHomeTokens.remove(token);
          break;
        }
      }
    }
  }
  if (homeTokens.size() + nonHomeTokens.size() > cgr.getNumberOfBaseTokens()) {
    Map<String,String> oldTokens=new HashMap<String,String>();
    String cityName;
    for (    BaseToken token : nonHomeTokens) {
      if (token.getHolder() instanceof City) {
        cityName=token.getHolder().getName();
        if (oldTokens.containsKey(cityName)) {
          oldTokens.put(cityName,oldTokens.get(cityName) + ""String_Node_Str"" + token.getCompany().getName());
        }
 else {
          oldTokens.put(cityName,token.getCompany().getName());
        }
      }
    }
    tokensToExchangeFrom=new ArrayList<ExchangeableToken>();
    for (    String key : new TreeSet<String>(oldTokens.keySet())) {
      tokensToExchangeFrom.add(new ExchangeableToken(key,oldTokens.get(key)));
    }
  }
 else {
    executeExchangeTokens(nonHomeTokens);
  }
  for (  PublicCompanyI comp : mergingCompanies) {
    comp.setClosed();
  }
  int trainLimit=cgr.getTrainLimit(gameManager.getCurrentPlayerIndex());
  List<TrainI> trains=cgr.getPortfolio().getTrainList();
  if (cgr.getNumberOfTrains() > trainLimit) {
    ReportBuffer.add(""String_Node_Str"");
    int numberToDiscard=cgr.getNumberOfTrains() - trainLimit;
    List<TrainI> trainsToDiscard=new ArrayList<TrainI>(4);
    for (    TrainI train : trains) {
      if (!train.getType().isPermanent()) {
        trainsToDiscard.add(train);
        if (--numberToDiscard == 0)         break;
      }
    }
    for (    TrainI train : trainsToDiscard) {
      train.moveTo(pool);
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgrName,train.getName()));
    }
  }
}","private void formCGR(){
  Player player;
  Portfolio portfolio;
  int count, cgrSharesUsed, oldShares, newShares;
  PublicCertificateI cgrCert, poolCert;
  List<PublicCertificateI> certs=new ArrayList<PublicCertificateI>();
  Player temporaryPresident=null;
  Player newPresident=null;
  Player firstCGRowner=null;
  int maxShares=0;
  setCurrentPlayer(startingPlayer);
  cgrSharesUsed=0;
  ReportBuffer.add(""String_Node_Str"");
  do {
    player=getCurrentPlayer();
    portfolio=player.getPortfolio();
    oldShares=newShares=0;
    certs.clear();
    poolCert=null;
    for (    PublicCertificateI cert : player.getPortfolio().getCertificates()) {
      if (mergingCompanies.contains(cert.getCompany())) {
        certs.add((cert));
        oldShares++;
        if (cert.isPresidentShare()) {
          oldShares++;
        }
      }
    }
    if (oldShares > 0) {
      count=oldShares;
      if (count >= 4 && temporaryPresident == null && cgrSharesUsed <= 18) {
        cgrCert=cgr.getPresidentsShare();
        cgrCert.moveTo(portfolio);
        count-=4;
        cgrSharesUsed+=2;
        newShares+=2;
        temporaryPresident=player;
      }
      while (count >= 2 && cgrSharesUsed <= 19) {
        cgrCert=unavailable.findCertificate(cgr,false);
        cgrCert.moveTo(portfolio);
        count-=2;
        cgrSharesUsed++;
        newShares++;
      }
      String message=LocalText.getText(""String_Node_Str"",player.getName(),oldShares,newShares,PublicCompany_CGR.NAME);
      DisplayBuffer.add(message,false);
      ReportBuffer.add(message);
      if (count == 1) {
        poolCert=certs.get(certs.size() - 1);
        poolCert.moveTo(pool);
        certs.remove(poolCert);
        message=LocalText.getText(""String_Node_Str"",player.getName());
        DisplayBuffer.add(message,false);
        ReportBuffer.add(message);
      }
      if (firstCGRowner == null)       firstCGRowner=player;
      if (newShares > maxShares) {
        maxShares=newShares;
        newPresident=player;
      }
    }
    gameManager.setNextPlayer();
  }
 while (getCurrentPlayer() != startingPlayer);
  certs.clear();
  oldShares=newShares=0;
  for (  PublicCertificateI cert : pool.getCertificates()) {
    if (mergingCompanies.contains(cert.getCompany())) {
      certs.add((cert));
      oldShares++;
    }
  }
  count=oldShares;
  while (count >= 2 && cgrSharesUsed <= 19) {
    cgrCert=unavailable.findCertificate(cgr,false);
    cgrCert.moveTo(pool);
    count-=2;
    cgrSharesUsed++;
    newShares++;
  }
  String message=LocalText.getText(""String_Node_Str"",LocalText.getText(""String_Node_Str""),oldShares,newShares,PublicCompany_CGR.NAME);
  DisplayBuffer.add(message);
  ReportBuffer.add(message);
  for (  PublicCertificateI discardCert : certs) {
    discardCert.moveTo(scrapHeap);
  }
  log.info(cgrSharesUsed + ""String_Node_Str"");
  if (cgrSharesUsed <= 10) {
    cgr.setShareUnit(10);
  }
  message=LocalText.getText(""String_Node_Str"",cgr.getName(),100 / cgr.getShareUnit(),cgr.getShareUnit());
  DisplayBuffer.add(message);
  ReportBuffer.add(message);
  certs=new ArrayList<PublicCertificateI>(unavailable.getCertificatesPerCompany(PublicCompany_CGR.NAME));
  for (  PublicCertificateI cert : certs) {
    cert.moveTo(ipo);
  }
  if (newPresident.getPortfolio().getShare(cgr) == cgr.getShareUnit()) {
    log.debug(""String_Node_Str"" + firstCGRowner.getName());
    cgr.setTemporaryPresident(firstCGRowner);
    newPresident=firstCGRowner;
  }
 else   if (temporaryPresident != null && temporaryPresident != newPresident) {
    log.debug(""String_Node_Str"" + temporaryPresident.getName() + ""String_Node_Str""+ newPresident.getName());
    temporaryPresident.getPortfolio().swapPresidentCertificate(cgr,newPresident.getPortfolio());
  }
  newPresident.getPortfolio().getShareModel(cgr).setShare();
  message=LocalText.getText(""String_Node_Str"",newPresident.getName(),cgrName);
  ReportBuffer.add(message);
  DisplayBuffer.add(message);
  int lowestPrice=999;
  int totalPrice=0;
  int price;
  int numberMerged=mergingCompanies.size();
  for (  PublicCompanyI comp : mergingCompanies) {
    price=comp.getMarketPrice();
    totalPrice+=price;
    if (price < lowestPrice)     lowestPrice=price;
  }
  if (numberMerged >= 3) {
    totalPrice-=lowestPrice;
    numberMerged--;
  }
  int cgrPrice=Math.max(100,(((totalPrice / numberMerged) / 5)) * 5);
  if (cgrPrice == 100) {
    cgr.start(100);
  }
 else {
    int prevColPrice=100;
    int colPrice;
    StockSpaceI startSpace;
    for (int col=6; col <= stockMarket.getNumberOfColumns(); col++) {
      colPrice=stockMarket.getStockSpace(1,col).getPrice();
      if (cgrPrice > colPrice)       continue;
      if (cgrPrice - prevColPrice < colPrice - cgrPrice) {
        startSpace=stockMarket.getStockSpace(1,col - 1);
      }
 else {
        startSpace=stockMarket.getStockSpace(1,col);
      }
      cgr.start(startSpace);
      message=LocalText.getText(""String_Node_Str"",PublicCompany_CGR.NAME,Bank.format(startSpace.getPrice()),startSpace.getName());
      DisplayBuffer.add(message);
      ReportBuffer.add(message);
      break;
    }
  }
  cgr.setFloated();
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",PublicCompany_CGR.NAME));
  int numCompanies=Math.min(11,12 - mergingCompanies.size());
  int numPlayers=gameManager.getNumberOfPlayers();
  int newCertLimit=certLimitsTable[numPlayers - 3][numCompanies - 4];
  gameManager.setPlayerCertificateLimit(newCertLimit);
  message=LocalText.getText(""String_Node_Str"",newCertLimit,numPlayers,numCompanies);
  DisplayBuffer.add(message);
  ReportBuffer.add(message);
  List<BaseToken> homeTokens=new ArrayList<BaseToken>();
  nonHomeTokens=new ArrayList<BaseToken>();
  BaseToken bt;
  MapHex hex;
  City city;
  for (  PublicCompanyI comp : mergingCompanies) {
    for (    TokenI token : comp.getTokens()) {
      if (token instanceof BaseToken) {
        bt=(BaseToken)token;
        if (!bt.isPlaced())         continue;
        city=(City)bt.getHolder();
        hex=city.getHolder();
        if (hex == comp.getHomeHex()) {
          homeTokens.add(bt);
        }
 else {
          nonHomeTokens.add(bt);
        }
      }
    }
    if (comp.getCash() > 0) {
      new CashMove(comp,cgr,comp.getCash());
    }
    List<TrainI> trains=new ArrayList<TrainI>(comp.getPortfolio().getTrainList());
    for (    TrainI train : trains) {
      train.moveTo(cgr.getPortfolio());
      if (train.getType().isPermanent())       cgr.setHadPermanentTrain(true);
    }
    if (comp.getBonuses() != null) {
      List<Bonus> bonuses=new ArrayList<Bonus>(comp.getBonuses());
      bonuses:       for (      Bonus bonus : bonuses) {
        comp.removeBonus(bonus);
        if (cgr.getBonuses() != null) {
          for (          Bonus b : cgr.getBonuses()) {
            if (b.equals(bonus)) {
              List<SellBonusToken> commonSP=gameManager.getSpecialProperties(SellBonusToken.class,true);
              if (commonSP != null) {
                for (                SellBonusToken sp : commonSP) {
                  if (sp.getName().equalsIgnoreCase(b.getName())) {
                    sp.makeResellable();
                    log.debug(""String_Node_Str"" + b.getName() + ""String_Node_Str"");
                    break;
                  }
                }
              }
              log.debug(""String_Node_Str"" + b.getName() + ""String_Node_Str""+ cgrName);
              continue bonuses;
            }
          }
        }
        cgr.addBonus(new Bonus(cgr,bonus.getName(),bonus.getValue(),bonus.getLocations()));
      }
    }
  }
  ReportBuffer.add(""String_Node_Str"");
  for (  BaseToken token : homeTokens) {
    city=(City)token.getHolder();
    hex=city.getHolder();
    token.moveTo(token.getCompany());
    if (hex.layBaseToken(cgr,city.getNumber())) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgrName,token.getCompany().getName(),city.getName()));
      cgr.layBaseToken(hex,0);
    }
  }
  for (  BaseToken token : new ArrayList<BaseToken>(nonHomeTokens)) {
    city=(City)token.getHolder();
    hex=city.getHolder();
    List<BaseToken> otherTokens=hex.getBaseTokens();
    if (otherTokens != null) {
      for (      BaseToken token2 : otherTokens) {
        if (token2.getCompany() == cgr || nonHomeTokens.contains(token2) && token2 != token) {
          ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgrName,token.getCompany().getName(),city.getName()));
          token.moveTo(token.getCompany());
          nonHomeTokens.remove(token);
          break;
        }
      }
    }
  }
  if (homeTokens.size() + nonHomeTokens.size() > cgr.getNumberOfBaseTokens()) {
    Map<String,String> oldTokens=new HashMap<String,String>();
    String cityName;
    for (    BaseToken token : nonHomeTokens) {
      if (token.getHolder() instanceof City) {
        cityName=token.getHolder().getName();
        if (oldTokens.containsKey(cityName)) {
          oldTokens.put(cityName,oldTokens.get(cityName) + ""String_Node_Str"" + token.getCompany().getName());
        }
 else {
          oldTokens.put(cityName,token.getCompany().getName());
        }
      }
    }
    tokensToExchangeFrom=new ArrayList<ExchangeableToken>();
    for (    String key : new TreeSet<String>(oldTokens.keySet())) {
      tokensToExchangeFrom.add(new ExchangeableToken(key,oldTokens.get(key)));
    }
  }
 else {
    executeExchangeTokens(nonHomeTokens);
  }
  for (  PublicCompanyI comp : mergingCompanies) {
    comp.setClosed();
  }
  int trainLimit=cgr.getCurrentTrainLimit();
  List<TrainI> trains=cgr.getPortfolio().getTrainList();
  if (cgr.getNumberOfTrains() > trainLimit) {
    ReportBuffer.add(""String_Node_Str"");
    int numberToDiscard=cgr.getNumberOfTrains() - trainLimit;
    List<TrainI> trainsToDiscard=new ArrayList<TrainI>(4);
    for (    TrainI train : trains) {
      if (!train.getType().isPermanent()) {
        trainsToDiscard.add(train);
        if (--numberToDiscard == 0)         break;
      }
    }
    for (    TrainI train : trainsToDiscard) {
      train.moveTo(pool);
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgrName,train.getName()));
    }
  }
}",0.9979300147856088
173700,"public City getSelectedHomeStation(){
  return selectedHomeStation;
}","public City getSelectedHomeStation(){
  if (selectedHomeStation == null && selectedHomeStationName != null) {
    MapManager mapManager=GameManager.getInstance().getMapManager();
    String[] parts=parseStationName(selectedHomeStationName);
    MapHex hex=mapManager.getHex(parts[0]);
    selectedHomeStation=hex.getCity(Integer.parseInt(parts[1]));
  }
  return selectedHomeStation;
}",0.185022026431718
173701,"/** 
 * Deserialize 
 */
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  in.defaultReadObject();
  CompanyManagerI cmgr=getCompanyManager();
  if (minorsToMergeNames != null) {
    minorsToMerge=new ArrayList<PublicCompanyI>();
    for (    String name : minorsToMergeNames.split(""String_Node_Str"")) {
      minorsToMerge.add(cmgr.getPublicCompany(name));
    }
  }
  if (chosenMinorName != null) {
    chosenMinor=cmgr.getPublicCompany(chosenMinorName);
  }
  MapManager mapManager=GameManager.getInstance().getMapManager();
  if (availableHomeStationNames != null) {
    availableHomeStations=new ArrayList<City>();
    for (    String cityName : availableHomeStationNames.split(""String_Node_Str"")) {
      String[] parts=parseStationName(cityName);
      MapHex hex=mapManager.getHex(parts[0]);
      availableHomeStations.add(hex.getCity(Integer.parseInt(parts[1])));
    }
  }
  if (selectedHomeStationName != null) {
    String[] parts=parseStationName(selectedHomeStationName);
    MapHex hex=mapManager.getHex(parts[0]);
    selectedHomeStation=hex.getCity(Integer.parseInt(parts[1]));
  }
}","/** 
 * Deserialize 
 */
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  in.defaultReadObject();
  CompanyManagerI cmgr=getCompanyManager();
  if (minorsToMergeNames != null) {
    minorsToMerge=new ArrayList<PublicCompanyI>();
    for (    String name : minorsToMergeNames.split(""String_Node_Str"")) {
      minorsToMerge.add(cmgr.getPublicCompany(name));
    }
  }
  if (chosenMinorName != null) {
    chosenMinor=cmgr.getPublicCompany(chosenMinorName);
  }
  MapManager mapManager=GameManager.getInstance().getMapManager();
  if (availableHomeStationNames != null) {
    availableHomeStations=new ArrayList<City>();
    for (    String cityName : availableHomeStationNames.split(""String_Node_Str"")) {
      String[] parts=parseStationName(cityName);
      MapHex hex=mapManager.getHex(parts[0]);
      availableHomeStations.add(hex.getCity(Integer.parseInt(parts[1])));
    }
  }
}",0.8957528957528957
173702,"@Override public boolean sellShares(SellShares action){
  Portfolio portfolio=operatingCompany.getPortfolio();
  String errMsg=null;
  String companyName=action.getCompanyName();
  PublicCompanyI company=companyManager.getPublicCompany(companyName);
  PublicCertificateI cert=null;
  List<PublicCertificateI> certsToSell=new ArrayList<PublicCertificateI>();
  int numberToSell=action.getNumberSold();
  int shareUnits=action.getShareUnits();
  while (true) {
    if (numberToSell <= 0) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (company != operatingCompany) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,operatingCompany.getName());
      break;
    }
    if (!company.hasFloated()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.mustHaveOperatedToTradeShares() && !company.hasOperated()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (hasSold.booleanValue()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (portfolio.getShare(company) < numberToSell) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (pool.getShare(company) + numberToSell * company.getShareUnit() > getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    Iterator<PublicCertificateI> it=portfolio.getCertificatesPerCompany(companyName).iterator();
    while (numberToSell > 0 && it.hasNext()) {
      cert=it.next();
      if (shareUnits != cert.getShares()) {
        continue;
      }
      certsToSell.add(cert);
      numberToSell--;
    }
    if (numberToSell > 0) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    break;
  }
  int numberSold=action.getNumberSold();
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,numberSold,companyName,errMsg));
    return false;
  }
  StockSpaceI sellPrice;
  int price;
  if (sellPrices.containsKey(companyName)) {
    price=(sellPrices.get(companyName)).getPrice();
  }
 else {
    sellPrice=company.getCurrentSpace();
    price=sellPrice.getPrice();
    sellPrices.put(companyName,sellPrice);
  }
  moveStack.start(true);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,numberSold,company.getShareUnit(),(numberSold * company.getShareUnit()),companyName,Bank.format(numberSold * price)));
  for (  PublicCertificateI cert2 : certsToSell) {
    if (cert2 != null) {
      executeTradeCertificate(cert2,pool,cert2.getShares() * price);
    }
  }
  stockMarket.sell(company,numberSold);
  hasSold.set(true);
  return true;
}","@Override public boolean sellShares(SellShares action){
  Portfolio portfolio=operatingCompany.getPortfolio();
  String errMsg=null;
  String companyName=action.getCompanyName();
  PublicCompanyI company=companyManager.getPublicCompany(companyName);
  PublicCertificateI cert=null;
  List<PublicCertificateI> certsToSell=new ArrayList<PublicCertificateI>();
  int numberToSell=action.getNumberSold();
  int shareUnits=action.getShareUnits();
  while (true) {
    if (numberToSell <= 0) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (company != operatingCompany) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,operatingCompany.getName());
      break;
    }
    if (!company.hasFloated()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.mustHaveOperatedToTradeShares() && !company.hasOperated()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (hasBought.booleanValue()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (portfolio.getShare(company) < numberToSell) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (pool.getShare(company) + numberToSell * company.getShareUnit() > getGameParameterAsInt(GameDef.Parm.POOL_SHARE_LIMIT)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    Iterator<PublicCertificateI> it=portfolio.getCertificatesPerCompany(companyName).iterator();
    while (numberToSell > 0 && it.hasNext()) {
      cert=it.next();
      if (shareUnits != cert.getShares()) {
        continue;
      }
      certsToSell.add(cert);
      numberToSell--;
    }
    if (numberToSell > 0) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    break;
  }
  int numberSold=action.getNumberSold();
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,numberSold,companyName,errMsg));
    return false;
  }
  StockSpaceI sellPrice;
  int price;
  if (sellPrices.containsKey(companyName)) {
    price=(sellPrices.get(companyName)).getPrice();
  }
 else {
    sellPrice=company.getCurrentSpace();
    price=sellPrice.getPrice();
    sellPrices.put(companyName,sellPrice);
  }
  moveStack.start(true);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,numberSold,company.getShareUnit(),(numberSold * company.getShareUnit()),companyName,Bank.format(numberSold * price)));
  for (  PublicCertificateI cert2 : certsToSell) {
    if (cert2 != null) {
      executeTradeCertificate(cert2,pool,cert2.getShares() * price);
    }
  }
  stockMarket.sell(company,numberSold);
  hasSold.set(true);
  return true;
}",0.9982288345731491
173703,"public void modifyCalculator(RevenueAdapter revenueAdapter){
  if (dynamic)   return;
  for (  NetworkTrain networkTrain : revenueAdapter.getTrains()) {
    TrainI train=networkTrain.getRailsTrain();
    if (!(train instanceof NameableTrain))     continue;
    NamedTrainToken token=((NameableTrain)train).getNameToken();
    if (token == null)     continue;
    RevenueBonus bonus=new RevenueBonus(token.getValue(),token.getName());
    bonus.addTrain(train);
    for (    NetworkVertex vertex : NetworkVertex.getVerticesByHexes(revenueAdapter.getVertices(),token.getHexesToPass())) {
      if (!vertex.isStation())       continue;
      bonus.addVertex(vertex);
    }
    revenueAdapter.addRevenueBonus(bonus);
  }
}","public void modifyCalculator(RevenueAdapter revenueAdapter){
  if (dynamic)   return;
  for (  NetworkTrain networkTrain : revenueAdapter.getTrains()) {
    TrainI train=networkTrain.getRailsTrain();
    if (!(train instanceof NameableTrain))     continue;
    NamedTrainToken token=((NameableTrain)train).getNameToken();
    if (token == null)     continue;
    RevenueBonus bonus=defineBonus(revenueAdapter,token,false);
    if (bonus == null)     continue;
    bonus.addTrain(train);
    revenueAdapter.addRevenueBonus(bonus);
  }
}",0.6384676775738228
173704,"public boolean prepareModifier(RevenueAdapter revenueAdapter){
  if (!dynamic)   return false;
  List<NameTrains> sp=revenueAdapter.getCompany().getPortfolio().getSpecialProperties(NameTrains.class,false);
  if (sp.isEmpty())   return false;
  bonuses=new ArrayList<RevenueBonus>();
  bonusMaximum=0;
  for (  NamedTrainToken token : sp.get(0).getTokens()) {
    RevenueBonus bonus=new RevenueBonus(token.getValue(),token.getLongName());
    for (    NetworkVertex vertex : NetworkVertex.getVerticesByHexes(revenueAdapter.getVertices(),token.getHexesToPass())) {
      if (!vertex.isStation())       continue;
      bonus.addVertex(vertex);
    }
    bonuses.add(bonus);
    bonusMaximum+=token.getValue();
  }
  return true;
}","public boolean prepareModifier(RevenueAdapter revenueAdapter){
  if (!dynamic)   return false;
  List<NameTrains> sp=revenueAdapter.getCompany().getPortfolio().getSpecialProperties(NameTrains.class,false);
  if (sp.isEmpty())   return false;
  bonuses=new ArrayList<RevenueBonus>();
  bonusMaximum=0;
  for (  NamedTrainToken token : sp.get(0).getTokens()) {
    RevenueBonus bonus=defineBonus(revenueAdapter,token,true);
    if (bonus == null)     continue;
    bonuses.add(bonus);
    bonusMaximum+=token.getValue();
  }
  return true;
}",0.6492890995260664
173705,"/** 
 * Buying one or more single or double-share certificates (more is sometimes possible)
 * @param player The player that wants to buy shares.
 * @param action The executed BuyCertificates action
 * @return True if the certificates could be bought. False indicates anerror.
 */
public boolean buyShares(String playerName,BuyCertificate action){
  PublicCertificateI cert=action.getCertificate();
  Portfolio from=cert.getPortfolio();
  String companyName=cert.getCompany().getName();
  int number=action.getNumberBought();
  int shares=number * cert.getShares();
  int shareUnit=cert.getShare();
  String errMsg=null;
  int price=0;
  int cost=0;
  PublicCompanyI company=null;
  currentPlayer=getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,currentPlayer.getName());
      break;
    }
    company=companyManager.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (isSaleRecorded(currentPlayer,company)) {
      errMsg=LocalText.getText(""String_Node_Str"",currentPlayer.getName(),companyName);
      break;
    }
    if (!company.isBuyable()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    PublicCompanyI companyBoughtThisTurn=(PublicCompanyI)companyBoughtThisTurnWrapper.getObject();
    if (companyBoughtThisTurn != null && (companyBoughtThisTurn != company || !company.getCurrentSpace().isNoBuyLimit())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    if (shares > from.getShare(company)) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,from.getName());
      break;
    }
    StockSpaceI currentSpace;
    if (from == ipo && company.hasParPrice()) {
      currentSpace=company.getStartSpace();
    }
 else {
      currentSpace=company.getCurrentSpace();
    }
    if (number > 1 && !currentSpace.isNoBuyLimit()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (!currentSpace.isNoCertLimit() && !mayPlayerBuyCertificate(currentPlayer,company,number)) {
      errMsg=currentPlayer.getName() + LocalText.getText(""String_Node_Str"",String.valueOf(gameManager.getPlayerCertificateLimit(currentPlayer)));
      break;
    }
    if (!currentSpace.isNoHoldLimit() && !checkAgainstHoldLimit(currentPlayer,company,shares)) {
      errMsg=LocalText.getText(""String_Node_Str"",currentPlayer.getName(),GameDef.Parm.PLAYER_SHARE_LIMIT.defaultValueAsInt());
      break;
    }
    price=getBuyPrice(action,currentSpace);
    cost=shares * price / company.getShareUnitsForSharePrice();
    if (currentPlayer.getCash() < cost) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,shares,companyName,from.getName(),errMsg));
    return false;
  }
  moveStack.start(true);
  CashHolder priceRecipient=getSharePriceRecipient(cert,cost);
  if (number == 1) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,shareUnit,companyName,from.getName(),Bank.format(cost)));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,number,shareUnit,number * shareUnit,companyName,from.getName(),Bank.format(cost)));
  }
  ReportBuffer.getAllWaiting();
  PublicCertificateI cert2;
  for (int i=0; i < number; i++) {
    cert2=from.findCertificate(company,cert.getShares(),false);
    if (cert2 == null) {
      log.error(""String_Node_Str"" + companyName + ""String_Node_Str""+ shareUnit+ ""String_Node_Str""+ from.getName());
    }
    cert.moveTo(currentPlayer.getPortfolio());
  }
  new CashMove(currentPlayer,priceRecipient,cost);
  if (priceRecipient != from.getOwner()) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",Bank.format(cost),priceRecipient.getName()));
  }
  companyBoughtThisTurnWrapper.set(company);
  hasActed.set(true);
  setPriority();
  company.checkPresidencyOnBuy(currentPlayer);
  if (!company.hasFloated())   checkFlotation(company);
  gameSpecificChecks(from,company);
  return true;
}","/** 
 * Buying one or more single or double-share certificates (more is sometimes possible)
 * @param player The player that wants to buy shares.
 * @param action The executed BuyCertificates action
 * @return True if the certificates could be bought. False indicates anerror.
 */
public boolean buyShares(String playerName,BuyCertificate action){
  PublicCertificateI cert=action.getCertificate();
  Portfolio from=cert.getPortfolio();
  String companyName=cert.getCompany().getName();
  int number=action.getNumberBought();
  int shares=number * cert.getShares();
  int shareUnit=cert.getShare();
  String errMsg=null;
  int price=0;
  int cost=0;
  PublicCompanyI company=null;
  currentPlayer=getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,currentPlayer.getName());
      break;
    }
    company=companyManager.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (isSaleRecorded(currentPlayer,company)) {
      errMsg=LocalText.getText(""String_Node_Str"",currentPlayer.getName(),companyName);
      break;
    }
    if (!company.isBuyable()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    PublicCompanyI companyBoughtThisTurn=(PublicCompanyI)companyBoughtThisTurnWrapper.getObject();
    if (companyBoughtThisTurn != null && (companyBoughtThisTurn != company || !company.getCurrentSpace().isNoBuyLimit())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    if (shares > from.getShare(company)) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,from.getName());
      break;
    }
    StockSpaceI currentSpace;
    if (from == ipo && company.hasParPrice()) {
      currentSpace=company.getStartSpace();
    }
 else {
      currentSpace=company.getCurrentSpace();
    }
    if (number > 1 && !currentSpace.isNoBuyLimit()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (!currentSpace.isNoCertLimit() && !mayPlayerBuyCertificate(currentPlayer,company,number)) {
      errMsg=currentPlayer.getName() + LocalText.getText(""String_Node_Str"",String.valueOf(gameManager.getPlayerCertificateLimit(currentPlayer)));
      break;
    }
    if (!currentSpace.isNoHoldLimit() && !checkAgainstHoldLimit(currentPlayer,company,shares)) {
      errMsg=LocalText.getText(""String_Node_Str"",currentPlayer.getName(),GameDef.Parm.PLAYER_SHARE_LIMIT.defaultValueAsInt());
      break;
    }
    price=getBuyPrice(action,currentSpace);
    cost=shares * price / company.getShareUnitsForSharePrice();
    if (currentPlayer.getCash() < cost) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,shares,companyName,from.getName(),errMsg));
    return false;
  }
  moveStack.start(true);
  CashHolder priceRecipient=getSharePriceRecipient(cert,cost);
  if (number == 1) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,shareUnit,companyName,from.getName(),Bank.format(cost)));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,number,shareUnit,number * shareUnit,companyName,from.getName(),Bank.format(cost)));
  }
  ReportBuffer.getAllWaiting();
  PublicCertificateI cert2;
  for (int i=0; i < number; i++) {
    cert2=from.findCertificate(company,cert.getShares(),false);
    if (cert2 == null) {
      log.error(""String_Node_Str"" + companyName + ""String_Node_Str""+ shareUnit+ ""String_Node_Str""+ from.getName());
    }
    cert2.moveTo(currentPlayer.getPortfolio());
  }
  new CashMove(currentPlayer,priceRecipient,cost);
  if (priceRecipient != from.getOwner()) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",Bank.format(cost),priceRecipient.getName()));
  }
  companyBoughtThisTurnWrapper.set(company);
  hasActed.set(true);
  setPriority();
  company.checkPresidencyOnBuy(currentPlayer);
  if (!company.hasFloated())   checkFlotation(company);
  gameSpecificChecks(from,company);
  return true;
}",0.9998809382069294
173706,"/** 
 * Register a bid. <p> This method does <b>not</b> check off the amount of money that a player has available for bidding.
 * @param amount The bid amount.
 * @param bidder The bidding player.
 */
public void setBid(int amount,Player bidder){
  int index=bidder.getIndex();
  bids[index].set(amount);
  if (amount > 0) {
    lastBidderIndex.set(index);
    minimumBid.set(amount + 5);
  }
 else   if (amount == 0) {
    bids[index].resetOption(MoneyModel.SUPPRESS_ZERO);
    bids[index].update();
  }
 else {
    bids[index].set(0);
    bids[index].update();
  }
}","/** 
 * Register a bid. <p> This method does <b>not</b> check off the amount of money that a player has available for bidding.
 * @param amount The bid amount.
 * @param bidder The bidding player.special amounts are 0 for 18EU as buy price, -1 as standard pass, -2 and below as pass in 18EU 
 */
public void setBid(int amount,Player bidder){
  int index=bidder.getIndex();
  bids[index].set(amount);
  if (amount > 0) {
    lastBidderIndex.set(index);
    minimumBid.set(amount + 5);
  }
 else   if (amount == 0) {
    bids[index].resetOption(MoneyModel.SUPPRESS_ZERO);
    bids[index].update();
  }
 else   if (amount == -1) {
    bids[index].set(0);
    bids[index].update();
  }
}",0.9080735411670664
173707,"/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(String playerName){
  String errMsg=null;
  Player player=getCurrentPlayer();
  StartItem auctionItem=(StartItem)auctionItemState.getObject();
  while (true) {
    if (!playerName.equals(player.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getName());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName));
  moveStack.start(false);
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.intValue() >= auctionItem.getBidders() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getName());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
      setPriorityPlayer();
    }
 else {
      if (GameOption.OPTION_VALUE_YES.equalsIgnoreCase(getGameOption(""String_Node_Str""))) {
        auctionItem.setBid(-1,player);
      }
      setNextBiddingPlayer(auctionItem,getCurrentPlayerIndex());
    }
  }
 else {
    if (numPasses.intValue() >= numPlayers) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str""));
      if (startPacket.getFirstUnsoldItem() == startPacket.getFirstItem()) {
        startPacket.getFirstItem().reduceBasePriceBy(5);
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",startPacket.getFirstItem().getName(),Bank.format(startPacket.getFirstItem().getBasePrice())));
        numPasses.set(0);
        if (startPacket.getFirstItem().getBasePrice() == 0) {
          assignItem(getCurrentPlayer(),startPacket.getFirstItem(),0,0);
          gameManager.setPriorityPlayer();
        }
      }
 else {
        numPasses.set(0);
        finishRound();
      }
    }
 else     if (auctionItem != null) {
      setNextBiddingPlayer(auctionItem);
    }
 else {
      setNextPlayer();
    }
  }
  return true;
}","/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(String playerName){
  String errMsg=null;
  Player player=getCurrentPlayer();
  StartItem auctionItem=(StartItem)auctionItemState.getObject();
  while (true) {
    if (!playerName.equals(player.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getName());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName));
  moveStack.start(false);
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.intValue() >= auctionItem.getBidders() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getName());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
      setPriorityPlayer();
    }
 else {
      if (GameOption.OPTION_VALUE_YES.equalsIgnoreCase(getGameOption(""String_Node_Str""))) {
        player.unblockCash(auctionItem.getBid(player));
        auctionItem.setBid(-1,player);
      }
      setNextBiddingPlayer(auctionItem,getCurrentPlayerIndex());
    }
  }
 else {
    if (numPasses.intValue() >= numPlayers) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str""));
      if (startPacket.getFirstUnsoldItem() == startPacket.getFirstItem()) {
        startPacket.getFirstItem().reduceBasePriceBy(5);
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",startPacket.getFirstItem().getName(),Bank.format(startPacket.getFirstItem().getBasePrice())));
        numPasses.set(0);
        if (startPacket.getFirstItem().getBasePrice() == 0) {
          assignItem(getCurrentPlayer(),startPacket.getFirstItem(),0,0);
          gameManager.setPriorityPlayer();
        }
      }
 else {
        numPasses.set(0);
        finishRound();
      }
    }
 else     if (auctionItem != null) {
      setNextBiddingPlayer(auctionItem);
    }
 else {
      setNextPlayer();
    }
  }
  return true;
}",0.9877889228085478
173708,"/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override public boolean pass(String playerName){
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName));
  moveStack.start(false);
  StartItem auctionedItem=(StartItem)currentAuctionItem.getObject();
switch (getStep()) {
case OPEN_STEP:
case BUY_STEP:
    setNextPlayer();
  if (currentPlayer == selectingPlayer.getObject()) {
    currentBuyPrice.add(-10);
    auctionedItem.setMinimumBid(currentBuyPrice.intValue());
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",auctionedItem.getName(),Bank.format(currentBuyPrice.intValue())));
    setStep(BUY_STEP);
    if (currentBuyPrice.intValue() == 0) {
      auctionedItem.setBid(0,currentPlayer);
      assignItem(currentPlayer,auctionedItem,0,0);
      setStep(SELECT_STEP);
      setNextSelectingPlayer();
    }
  }
break;
case BID_STEP:
auctionedItem.setBid(-1,currentPlayer);
setNextBiddingPlayer();
if (currentPlayer == auctionedItem.getBidder()) {
assignItem(auctionedItem.getBidder(),auctionedItem,auctionedItem.getBid(),0);
setStep(SELECT_STEP);
setNextSelectingPlayer();
}
}
return true;
}","/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override public boolean pass(String playerName){
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName));
  moveStack.start(false);
  StartItem auctionedItem=(StartItem)currentAuctionItem.getObject();
switch (getStep()) {
case OPEN_STEP:
case BUY_STEP:
    setNextPlayer();
  if (currentPlayer == selectingPlayer.getObject()) {
    currentBuyPrice.add(-10);
    auctionedItem.setMinimumBid(currentBuyPrice.intValue());
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",auctionedItem.getName(),Bank.format(currentBuyPrice.intValue())));
    setStep(BUY_STEP);
    if (currentBuyPrice.intValue() == 0) {
      auctionedItem.setBid(0,currentPlayer);
      assignItem(currentPlayer,auctionedItem,0,0);
      setStep(SELECT_STEP);
      setNextSelectingPlayer();
    }
  }
break;
case BID_STEP:
auctionedItem.setBid(-2,currentPlayer);
setNextBiddingPlayer();
if (currentPlayer == auctionedItem.getBidder()) {
assignItem(auctionedItem.getBidder(),auctionedItem,auctionedItem.getBid(),0);
setStep(SELECT_STEP);
setNextSelectingPlayer();
}
}
return true;
}",0.9991539763113368
173709,"/** 
 * Count the number of shares per revenue recipient<p> A special rule applies to 1835 to prevent black privates and minors providing income twice during an OR.
 */
protected Map<CashHolder,Integer> countSharesPerRecipient(){
  Map<CashHolder,Integer> sharesPerRecipient=super.countSharesPerRecipient();
  if (operatingCompany.getName().equalsIgnoreCase(GameManager_1835.PR_ID)) {
    for (    Player player : deniedIncomeShare.keySet()) {
      int share=deniedIncomeShare.get(player);
      int shares=share / operatingCompany.getShareUnit();
      sharesPerRecipient.put(player,sharesPerRecipient.get(player) - shares);
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",player.getName(),share,GameManager_1835.PR_ID));
    }
  }
  return sharesPerRecipient;
}","/** 
 * Count the number of shares per revenue recipient<p> A special rule applies to 1835 to prevent black privates and minors providing income twice during an OR.
 */
protected Map<CashHolder,Integer> countSharesPerRecipient(){
  Map<CashHolder,Integer> sharesPerRecipient=super.countSharesPerRecipient();
  if (operatingCompany.getName().equalsIgnoreCase(GameManager_1835.PR_ID)) {
    for (    Player player : deniedIncomeShare.keySet()) {
      if (!sharesPerRecipient.containsKey(player))       continue;
      int share=deniedIncomeShare.get(player);
      int shares=share / operatingCompany.getShareUnit();
      sharesPerRecipient.put(player,sharesPerRecipient.get(player) - shares);
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",player.getName(),share,GameManager_1835.PR_ID));
    }
  }
  return sharesPerRecipient;
}",0.95856524427953
173710,"public <T extends PossibleAction>void setMapRelatedActions(List<T> actions){
  GUIHex selectedHex=mapPanel.getMap().getSelectedHex();
  int nextSubStep=ORUIManager.INACTIVE;
  allowedTileLays.clear();
  allowedTokenLays.clear();
  for (  T action : actions) {
    if (action instanceof LayTile) {
      allowedTileLays.add((LayTile)action);
    }
 else     if (action instanceof LayToken) {
      allowedTokenLays.add((LayToken)action);
    }
  }
  if (allowedTileLays.size() == 0 && tileLayingEnabled) {
    if (selectedHex != null) {
      selectedHex.removeTile();
      selectedHex.setSelected(false);
      mapPanel.getMap().repaint(selectedHex.getBounds());
      selectedHex=null;
    }
    for (    MapHex hex : hexUpgrades) {
      GUIHex guiHex=map.getHexByName(hex.getName());
      guiHex.setSelectable(false);
      mapPanel.getMap().repaint(guiHex.getBounds());
    }
    hexUpgrades=null;
  }
  if (allowedTokenLays.size() == 0 && tokenLayingEnabled) {
    if (selectedHex != null) {
      selectedHex.removeToken();
      selectedHex.setSelected(false);
      mapPanel.getMap().repaint(selectedHex.getBounds());
      selectedHex=null;
    }
    for (    MapHex hex : hexUpgrades) {
      GUIHex guiHex=map.getHexByName(hex.getName());
      guiHex.setSelectable(false);
      mapPanel.getMap().repaint(guiHex.getBounds());
    }
    hexUpgrades=null;
  }
  if (allowedTileLays.size() > 0) {
    nextSubStep=ORUIManager.SELECT_HEX_FOR_TILE;
    mapPanel.setAllowedTileLays(allowedTileLays);
    if (hexUpgrades != null) {
      for (      MapHex hex : hexUpgrades) {
        GUIHex guiHex=map.getHexByName(hex.getName());
        guiHex.setSelectable(false);
      }
    }
    boolean mapHexes=false;
    hexUpgrades=new ArrayList<MapHex>();
    if (gameUIManager.getGameParameterAsBoolean(GuiDef.Parm.ROUTE_HIGHLIGHT)) {
      for (      LayTile layTile : allowedTileLays) {
switch (layTile.getType()) {
case (LayTile.GENERIC):
          mapHexes=true;
        break;
case (LayTile.SPECIAL_PROPERTY):
      SpecialPropertyI sp=layTile.getSpecialProperty();
    if (sp == null || !(sp instanceof SpecialTileLay) || ((SpecialTileLay)sp).requiresConnection())     break;
case (LayTile.LOCATION_SPECIFIC):
  if (layTile.getLocations() != null)   hexUpgrades.addAll(layTile.getLocations());
}
}
if (mapHexes) {
SimpleGraph<NetworkVertex,NetworkEdge> companyGraph=getCompanyGraph();
List<MapHex> mapHexUpgrades=NetworkGraphBuilder.getMapHexes(companyGraph);
for (MapHex hex : mapHexUpgrades) {
if (hex.isUpgradeableNow(gameUIManager.getCurrentPhase())) hexUpgrades.add(hex);
}
String autoScroll=Config.getGameSpecific(""String_Node_Str"");
if (Util.hasValue(autoScroll) && autoScroll.equalsIgnoreCase(""String_Node_Str"")) {
}
 else {
mapPanel.scrollPaneShowRectangle(NetworkVertex.getVertexMapCoverage(map,companyGraph.vertexSet()));
}
}
for (MapHex hex : hexUpgrades) {
GUIHex guiHex=map.getHexByName(hex.getName());
guiHex.setSelectable(true);
}
}
}
if (allowedTokenLays.size() > 0) {
nextSubStep=ORUIManager.SELECT_HEX_FOR_TOKEN;
mapPanel.setAllowedTokenLays(allowedTokenLays);
if (hexUpgrades != null) {
for (MapHex hex : hexUpgrades) {
GUIHex guiHex=map.getHexByName(hex.getName());
guiHex.setSelectable(false);
}
}
boolean mapHexes=false;
hexUpgrades=new ArrayList<MapHex>();
if (gameUIManager.getGameParameterAsBoolean(GuiDef.Parm.ROUTE_HIGHLIGHT)) {
for (LayToken layToken : allowedTokenLays) {
SpecialPropertyI sp=layToken.getSpecialProperty();
if (sp == null) {
mapHexes=true;
}
 else if (layToken.getLocations() != null) hexUpgrades.addAll(layToken.getLocations());
}
if (mapHexes) {
hexUpgrades=NetworkGraphBuilder.getStationHexes(getCompanyGraph(),orComp);
for (LayToken layToken : allowedTokenLays) {
if (layToken.getLocations() != null) hexUpgrades.addAll(layToken.getLocations());
}
for (MapHex hex : hexUpgrades) {
GUIHex guiHex=map.getHexByName(hex.getName());
guiHex.setSelectable(true);
}
}
}
}
setLocalStep(nextSubStep);
tileLayingEnabled=allowedTileLays.size() > 0;
tokenLayingEnabled=allowedTokenLays.size() > 0;
upgradePanel.setTileMode(tileLayingEnabled);
upgradePanel.setTokenMode(tokenLayingEnabled);
setLocalAction(false);
}","public <T extends PossibleAction>void setMapRelatedActions(List<T> actions){
  GUIHex selectedHex=mapPanel.getMap().getSelectedHex();
  int nextSubStep=ORUIManager.INACTIVE;
  allowedTileLays.clear();
  allowedTokenLays.clear();
  for (  T action : actions) {
    if (action instanceof LayTile) {
      allowedTileLays.add((LayTile)action);
    }
 else     if (action instanceof LayToken) {
      allowedTokenLays.add((LayToken)action);
    }
  }
  if (allowedTileLays.size() == 0 && tileLayingEnabled) {
    if (selectedHex != null) {
      selectedHex.removeTile();
      selectedHex.setSelected(false);
      mapPanel.getMap().repaint(selectedHex.getBounds());
      selectedHex=null;
    }
    for (    MapHex hex : hexUpgrades) {
      GUIHex guiHex=map.getHexByName(hex.getName());
      guiHex.setSelectable(false);
      mapPanel.getMap().repaint(guiHex.getBounds());
    }
    hexUpgrades=null;
  }
  if (allowedTokenLays.size() == 0 && tokenLayingEnabled) {
    if (selectedHex != null) {
      selectedHex.removeToken();
      selectedHex.setSelected(false);
      mapPanel.getMap().repaint(selectedHex.getBounds());
      selectedHex=null;
    }
    for (    MapHex hex : hexUpgrades) {
      GUIHex guiHex=map.getHexByName(hex.getName());
      guiHex.setSelectable(false);
      mapPanel.getMap().repaint(guiHex.getBounds());
    }
    hexUpgrades=null;
  }
  if (allowedTileLays.size() > 0) {
    nextSubStep=ORUIManager.SELECT_HEX_FOR_TILE;
    mapPanel.setAllowedTileLays(allowedTileLays);
    if (hexUpgrades != null) {
      for (      MapHex hex : hexUpgrades) {
        GUIHex guiHex=map.getHexByName(hex.getName());
        guiHex.setSelectable(false);
      }
    }
    boolean mapHexes=false;
    hexUpgrades=new ArrayList<MapHex>();
    if (gameUIManager.getGameParameterAsBoolean(GuiDef.Parm.ROUTE_HIGHLIGHT)) {
      for (      LayTile layTile : allowedTileLays) {
switch (layTile.getType()) {
case (LayTile.GENERIC):
          mapHexes=true;
        break;
case (LayTile.SPECIAL_PROPERTY):
      SpecialPropertyI sp=layTile.getSpecialProperty();
    if (sp == null || !(sp instanceof SpecialTileLay) || ((SpecialTileLay)sp).requiresConnection())     break;
case (LayTile.LOCATION_SPECIFIC):
  if (layTile.getLocations() != null)   hexUpgrades.addAll(layTile.getLocations());
}
}
if (mapHexes) {
SimpleGraph<NetworkVertex,NetworkEdge> companyGraph=getCompanyGraph();
List<MapHex> mapHexUpgrades=NetworkGraphBuilder.getMapHexes(companyGraph);
for (MapHex hex : mapHexUpgrades) {
if (hex.isUpgradeableNow(gameUIManager.getCurrentPhase())) hexUpgrades.add(hex);
}
String autoScroll=Config.getGameSpecific(""String_Node_Str"");
if (Util.hasValue(autoScroll) && autoScroll.equalsIgnoreCase(""String_Node_Str"")) {
}
 else {
mapPanel.scrollPaneShowRectangle(NetworkVertex.getVertexMapCoverage(map,companyGraph.vertexSet()));
}
}
for (MapHex hex : hexUpgrades) {
GUIHex guiHex=map.getHexByName(hex.getName());
guiHex.setSelectable(true);
}
}
}
if (allowedTokenLays.size() > 0) {
nextSubStep=ORUIManager.SELECT_HEX_FOR_TOKEN;
mapPanel.setAllowedTokenLays(allowedTokenLays);
if (hexUpgrades != null) {
for (MapHex hex : hexUpgrades) {
GUIHex guiHex=map.getHexByName(hex.getName());
guiHex.setSelectable(false);
}
}
boolean mapHexes=false;
hexUpgrades=new ArrayList<MapHex>();
if (gameUIManager.getGameParameterAsBoolean(GuiDef.Parm.ROUTE_HIGHLIGHT)) {
for (LayToken layToken : allowedTokenLays) {
SpecialPropertyI sp=layToken.getSpecialProperty();
if (sp == null) {
mapHexes=true;
}
 else if (layToken.getLocations() != null) hexUpgrades.addAll(layToken.getLocations());
}
if (mapHexes) {
hexUpgrades.addAll(NetworkGraphBuilder.getTokenableStationHexes(getCompanyGraph(),orComp));
for (MapHex hex : hexUpgrades) {
GUIHex guiHex=map.getHexByName(hex.getName());
guiHex.setSelectable(true);
}
}
}
}
setLocalStep(nextSubStep);
tileLayingEnabled=allowedTileLays.size() > 0;
tokenLayingEnabled=allowedTokenLays.size() > 0;
upgradePanel.setTileMode(tileLayingEnabled);
upgradePanel.setTokenMode(tokenLayingEnabled);
setLocalAction(false);
}",0.9817251461988304
173711,"public void generateGraph(MapManager mapManager,RevenueManager revenueManager){
  for (  MapHex hex : mapManager.getHexesAsList()) {
    TileI tile=hex.getCurrentTile();
    List<Station> stations=tile.getStations();
    for (    Station station : stations) {
      NetworkVertex stationVertex=new NetworkVertex(hex,station);
      mapGraph.addVertex(stationVertex);
      mapVertexes.put(stationVertex.getIdentifier(),stationVertex);
      log.info(""String_Node_Str"" + stationVertex);
    }
    for (int side=0; side < 6; side++)     if (tile.getTracksPerSide(side).size() != 0) {
      NetworkVertex sideVertex=new NetworkVertex(hex,side + hex.getCurrentTileRotation());
      mapGraph.addVertex(sideVertex);
      mapVertexes.put(sideVertex.getIdentifier(),sideVertex);
      log.info(""String_Node_Str"" + sideVertex);
    }
  }
  for (  MapHex hex : mapManager.getHexesAsList()) {
    TileI tile=hex.getCurrentTile();
    List<Track> tracks=tile.getTracks();
    for (    Track track : tracks) {
      int[] points=track.points();
      NetworkVertex startVertex=getVertexRotated(hex,points[0]);
      NetworkVertex endVertex=getVertexRotated(hex,points[1]);
      log.info(""String_Node_Str"" + track);
      NetworkEdge edge=new NetworkEdge(startVertex,endVertex,false);
      if (startVertex == endVertex) {
        log.error(""String_Node_Str"" + track + ""String_Node_Str""+ hex+ ""String_Node_Str"");
      }
 else {
        mapGraph.addEdge(startVertex,endVertex,edge);
        log.info(""String_Node_Str"" + edge.getConnection());
      }
    }
    for (int side=0; side <= 2; side++) {
      NetworkVertex vertex=getVertex(hex,side);
      MapHex neighborHex=hex.getNeighbor(side);
      if (neighborHex == null) {
        log.info(""String_Node_Str"" + hex.getName() + ""String_Node_Str""+ hex.getOrientationName(side)+ ""String_Node_Str"");
        continue;
      }
      NetworkVertex otherVertex=getVertex(neighborHex,side + 3);
      if (vertex == null && otherVertex == null) {
        log.info(""String_Node_Str"" + hex.getName() + ""String_Node_Str""+ hex.getOrientationName(side));
        log.info(""String_Node_Str"" + neighborHex.getName() + ""String_Node_Str""+ neighborHex.getOrientationName(side + 3));
        continue;
      }
 else       if (vertex == null && otherVertex != null) {
        log.info(""String_Node_Str"" + neighborHex.getName() + ""String_Node_Str""+ neighborHex.getOrientationName(side + 3)+ ""String_Node_Str""+ hex.getName()+ ""String_Node_Str""+ hex.getOrientationName(side));
        vertex=new NetworkVertex(hex,side);
        mapGraph.addVertex(vertex);
        mapVertexes.put(vertex.getIdentifier(),vertex);
        log.info(""String_Node_Str"" + vertex);
      }
 else       if (otherVertex == null) {
        log.info(""String_Node_Str"" + hex.getName() + ""String_Node_Str""+ hex.getOrientationName(side)+ ""String_Node_Str""+ neighborHex.getName()+ ""String_Node_Str""+ neighborHex.getOrientationName(side + 3));
        otherVertex=new NetworkVertex(neighborHex,side + 3);
        mapGraph.addVertex(otherVertex);
        mapVertexes.put(otherVertex.getIdentifier(),otherVertex);
        log.info(""String_Node_Str"" + otherVertex);
      }
      NetworkEdge edge=new NetworkEdge(vertex,otherVertex,true);
      mapGraph.addEdge(vertex,otherVertex,edge);
      log.info(""String_Node_Str"" + edge.getConnection());
    }
  }
  revenueManager.callGraphModifiers(this);
}","public void generateGraph(MapManager mapManager,RevenueManager revenueManager){
  for (  MapHex hex : mapManager.getHexesAsList()) {
    TileI tile=hex.getCurrentTile();
    List<Station> stations=tile.getStations();
    for (    Station station : stations) {
      NetworkVertex stationVertex=new NetworkVertex(hex,station);
      mapGraph.addVertex(stationVertex);
      mapVertexes.put(stationVertex.getIdentifier(),stationVertex);
      log.info(""String_Node_Str"" + stationVertex);
    }
    for (int side=0; side < 6; side++)     if (tile.getTracksPerSide(side).size() != 0) {
      NetworkVertex sideVertex=new NetworkVertex(hex,side + hex.getCurrentTileRotation());
      mapGraph.addVertex(sideVertex);
      mapVertexes.put(sideVertex.getIdentifier(),sideVertex);
      log.info(""String_Node_Str"" + sideVertex);
    }
  }
  for (  MapHex hex : mapManager.getHexesAsList()) {
    TileI tile=hex.getCurrentTile();
    List<Track> tracks=tile.getTracks();
    for (    Track track : tracks) {
      int[] points=track.points();
      NetworkVertex startVertex=getVertexRotated(hex,points[0]);
      NetworkVertex endVertex=getVertexRotated(hex,points[1]);
      log.info(""String_Node_Str"" + track);
      NetworkEdge edge=new NetworkEdge(startVertex,endVertex,false);
      if (startVertex == endVertex) {
        log.error(""String_Node_Str"" + track + ""String_Node_Str""+ hex+ ""String_Node_Str"");
      }
 else {
        mapGraph.addEdge(startVertex,endVertex,edge);
        log.info(""String_Node_Str"" + edge.getConnection());
      }
    }
    for (int side=0; side <= 2; side++) {
      NetworkVertex vertex=getVertex(hex,side);
      MapHex neighborHex=hex.getNeighbor(side);
      if (neighborHex == null) {
        log.info(""String_Node_Str"" + hex.getName() + ""String_Node_Str""+ hex.getOrientationName(side)+ ""String_Node_Str"");
        continue;
      }
      NetworkVertex otherVertex=getVertex(neighborHex,side + 3);
      if (vertex == null && otherVertex == null) {
        log.info(""String_Node_Str"" + hex.getName() + ""String_Node_Str""+ hex.getOrientationName(side));
        log.info(""String_Node_Str"" + neighborHex.getName() + ""String_Node_Str""+ neighborHex.getOrientationName(side + 3));
        continue;
      }
 else       if (vertex == null && otherVertex != null) {
        log.info(""String_Node_Str"" + neighborHex.getName() + ""String_Node_Str""+ neighborHex.getOrientationName(side + 3)+ ""String_Node_Str""+ hex.getName()+ ""String_Node_Str""+ hex.getOrientationName(side));
        vertex=new NetworkVertex(hex,side);
        mapGraph.addVertex(vertex);
        mapVertexes.put(vertex.getIdentifier(),vertex);
        log.info(""String_Node_Str"" + vertex);
      }
 else       if (otherVertex == null) {
        log.info(""String_Node_Str"" + hex.getName() + ""String_Node_Str""+ hex.getOrientationName(side)+ ""String_Node_Str""+ neighborHex.getName()+ ""String_Node_Str""+ neighborHex.getOrientationName(side + 3));
        otherVertex=new NetworkVertex(neighborHex,side + 3);
        mapGraph.addVertex(otherVertex);
        mapVertexes.put(otherVertex.getIdentifier(),otherVertex);
        log.info(""String_Node_Str"" + otherVertex);
      }
      NetworkEdge edge=new NetworkEdge(vertex,otherVertex,true);
      mapGraph.addEdge(vertex,otherVertex,edge);
      log.info(""String_Node_Str"" + edge.getConnection());
    }
  }
  if (revenueManager != null) {
    revenueManager.callGraphModifiers(this);
  }
}",0.9944166911548632
173712,"public void initRevenueCalculator(){
  if (gameManager.getRevenueManager() != null) {
    dynamicModifiers=gameManager.getRevenueManager().callDynamicModifiers(this);
  }
 else {
    dynamicModifiers=null;
  }
  rcGraph=NetworkGraphBuilder.optimizeGraph(graph,protectedVertices);
  rcVertices=new ArrayList<NetworkVertex>(rcGraph.vertexSet());
  Collections.sort(rcVertices,new NetworkVertex.ValueOrder());
  rcEdges=new ArrayList<NetworkEdge>(rcGraph.edgeSet());
  prepareTrainLengths(rcVertices);
  int maxVisitVertices=maxVisitVertices();
  int maxBonusVertices=maxRevenueBonusVertices();
  int maxNeighbors=maxVertexNeighbors(rcVertices);
  rc=new RevenueCalculator(this,rcVertices.size(),rcEdges.size(),maxNeighbors,maxVisitVertices,trains.size(),maxBonusVertices);
  populateRevenueCalculator();
}","public void initRevenueCalculator(){
  if (gameManager.getRevenueManager() != null) {
    dynamicModifiers=gameManager.getRevenueManager().callDynamicModifiers(this);
  }
 else {
    dynamicModifiers=new HashSet<RevenueDynamicModifier>();
  }
  rcGraph=NetworkGraphBuilder.optimizeGraph(graph,protectedVertices);
  rcVertices=new ArrayList<NetworkVertex>(rcGraph.vertexSet());
  Collections.sort(rcVertices,new NetworkVertex.ValueOrder());
  rcEdges=new ArrayList<NetworkEdge>(rcGraph.edgeSet());
  prepareTrainLengths(rcVertices);
  int maxVisitVertices=maxVisitVertices();
  int maxBonusVertices=maxRevenueBonusVertices();
  int maxNeighbors=maxVertexNeighbors(rcVertices);
  rc=new RevenueCalculator(this,rcVertices.size(),rcEdges.size(),maxNeighbors,maxVisitVertices,trains.size(),maxBonusVertices);
  populateRevenueCalculator();
}",0.9762050030506406
173713,"private void populateRevenueCalculator(){
  for (int id=0; id < rcVertices.size(); id++) {
    NetworkVertex v=rcVertices.get(id);
    v.addToRevenueCalculator(rc,id);
    for (int trainId=0; trainId < trains.size(); trainId++) {
      NetworkTrain train=trains.get(trainId);
      rc.setVertexValue(id,trainId,getVertexValue(v,train,phase));
    }
    List<NetworkVertex> neighbors=Graphs.neighborListOf(rcGraph,v);
    int j=0, neighborsArray[]=new int[neighbors.size()];
    for (    NetworkVertex n : neighbors) {
      neighborsArray[j++]=rcVertices.indexOf(n);
    }
    Arrays.sort(neighborsArray,0,j);
    int[] edgesArray=new int[j];
    for (int e=0; e < j; e++) {
      NetworkVertex n=rcVertices.get(neighborsArray[e]);
      edgesArray[e]=rcEdges.indexOf(rcGraph.getEdge(v,n));
    }
    rc.setVertexNeighbors(id,neighborsArray,edgesArray);
  }
  int startVertexId=0, sv[]=new int[startVertices.size()];
  for (  NetworkVertex startVertex : startVertices) {
    sv[startVertexId++]=rcVertices.indexOf(startVertex);
  }
  Arrays.sort(sv);
  rc.setStartVertexes(sv);
  for (int id=0; id < rcEdges.size(); id++) {
    NetworkEdge e=rcEdges.get(id);
    boolean greedy=e.isGreedy();
    int distance=e.getDistance();
    rc.setEdge(id,greedy,distance);
  }
  for (int id=0; id < trains.size(); id++) {
    NetworkTrain train=trains.get(id);
    train.addToRevenueCalculator(rc,id);
  }
  for (  VertexVisit visit : vertexVisitSets) {
    int j=0, setArray[]=new int[visit.set.size()];
    for (    NetworkVertex n : visit.set) {
      setArray[j++]=rcVertices.indexOf(n);
    }
    rc.setVisitSet(setArray);
  }
  log.info(""String_Node_Str"" + rcVertices);
  int id=0;
  for (  RevenueBonus bonus : revenueBonuses) {
    if (bonus.addToRevenueCalculator(rc,id,rcVertices,trains,phase))     id++;
  }
  rc.setDynamicModifiers(dynamicModifiers != null);
}","private void populateRevenueCalculator(){
  for (int id=0; id < rcVertices.size(); id++) {
    NetworkVertex v=rcVertices.get(id);
    v.addToRevenueCalculator(rc,id);
    for (int trainId=0; trainId < trains.size(); trainId++) {
      NetworkTrain train=trains.get(trainId);
      rc.setVertexValue(id,trainId,getVertexValue(v,train,phase));
    }
    List<NetworkVertex> neighbors=Graphs.neighborListOf(rcGraph,v);
    int j=0, neighborsArray[]=new int[neighbors.size()];
    for (    NetworkVertex n : neighbors) {
      neighborsArray[j++]=rcVertices.indexOf(n);
    }
    Arrays.sort(neighborsArray,0,j);
    int[] edgesArray=new int[j];
    for (int e=0; e < j; e++) {
      NetworkVertex n=rcVertices.get(neighborsArray[e]);
      edgesArray[e]=rcEdges.indexOf(rcGraph.getEdge(v,n));
    }
    rc.setVertexNeighbors(id,neighborsArray,edgesArray);
  }
  int startVertexId=0, sv[]=new int[startVertices.size()];
  for (  NetworkVertex startVertex : startVertices) {
    sv[startVertexId++]=rcVertices.indexOf(startVertex);
  }
  Arrays.sort(sv);
  rc.setStartVertexes(sv);
  for (int id=0; id < rcEdges.size(); id++) {
    NetworkEdge e=rcEdges.get(id);
    boolean greedy=e.isGreedy();
    int distance=e.getDistance();
    rc.setEdge(id,greedy,distance);
  }
  for (int id=0; id < trains.size(); id++) {
    NetworkTrain train=trains.get(id);
    train.addToRevenueCalculator(rc,id);
  }
  for (  VertexVisit visit : vertexVisitSets) {
    int j=0, setArray[]=new int[visit.set.size()];
    for (    NetworkVertex n : visit.set) {
      setArray[j++]=rcVertices.indexOf(n);
    }
    rc.setVisitSet(setArray);
  }
  log.info(""String_Node_Str"" + rcVertices);
  int id=0;
  for (  RevenueBonus bonus : revenueBonuses) {
    if (bonus.addToRevenueCalculator(rc,id,rcVertices,trains,phase))     id++;
  }
  rc.setDynamicModifiers(!dynamicModifiers.isEmpty());
}",0.9948993288590604
173714,"private boolean resetOperatingCompanies(List<PublicCompanyI> mergingCompanies){
  PublicCompanyI cgr=companyManager.getPublicCompany(PublicCompany_CGR.NAME);
  boolean cgrCanOperate=cgr.hasStarted();
  boolean roundFinished=false;
  for (  PublicCompanyI company : mergingCompanies) {
    if (companiesOperatedThisRound.contains(company))     cgrCanOperate=false;
  }
  for (  PublicCompanyI c : operatingCompanies) {
    if (c.isClosed()) {
      log.info(c.getName() + ""String_Node_Str"");
    }
 else {
      log.debug(c.getName() + ""String_Node_Str"");
    }
  }
  String message;
  int operatingCompanyIndex=getOperatingCompanyIndex();
  if (cgr.hasStarted()) {
    if (cgrCanOperate) {
      operatingCompanyIndex=Math.max(0,operatingCompanyIndex);
      operatingCompanies.add(operatingCompanyIndex,cgr);
      setOperatingCompany(cgr);
      message=LocalText.getText(""String_Node_Str"",cgr.getName());
    }
 else {
      message=LocalText.getText(""String_Node_Str"",cgr.getName());
      roundFinished=!setNextOperatingCompany(false);
    }
  }
 else {
    message=LocalText.getText(""String_Node_Str"",cgr.getName());
  }
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgr.getName(),getRoundName()));
  ReportBuffer.add(message);
  DisplayBuffer.add(message);
  if (!roundFinished) {
    log.debug(""String_Node_Str"" + operatingCompany.getName());
  }
 else {
    finishOR();
    return false;
  }
  return true;
}","private boolean resetOperatingCompanies(List<PublicCompanyI> mergingCompanies){
  PublicCompanyI cgr=companyManager.getPublicCompany(PublicCompany_CGR.NAME);
  boolean cgrCanOperate=cgr.hasStarted();
  boolean roundFinished=false;
  for (  PublicCompanyI company : mergingCompanies) {
    if (companiesOperatedThisRound.contains(company))     cgrCanOperate=false;
  }
  for (  PublicCompanyI c : operatingCompanies) {
    if (c.isClosed()) {
      log.info(c.getName() + ""String_Node_Str"");
    }
 else {
      log.debug(c.getName() + ""String_Node_Str"");
    }
  }
  String message;
  int operatingCompanyIndex=getOperatingCompanyIndex();
  if (cgr.hasStarted()) {
    if (cgrCanOperate) {
      operatingCompanyIndex=Math.max(0,operatingCompanyIndex);
      operatingCompanies.add(operatingCompanyIndex + 1,cgr);
      setOperatingCompany(cgr);
      message=LocalText.getText(""String_Node_Str"",cgr.getName());
    }
 else {
      message=LocalText.getText(""String_Node_Str"",cgr.getName());
      roundFinished=!setNextOperatingCompany(false);
    }
  }
 else {
    message=LocalText.getText(""String_Node_Str"",cgr.getName());
    roundFinished=!setNextOperatingCompany(false);
  }
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgr.getName(),getRoundName()));
  ReportBuffer.add(message);
  DisplayBuffer.add(message);
  if (!roundFinished) {
    log.debug(""String_Node_Str"" + operatingCompany.getName());
  }
 else {
    finishOR();
    return false;
  }
  return true;
}",0.9810801513587892
173715,"void setTrain(int id,int majors,int minors,boolean ignoreMinors,int multiplyMajors,int multiplyMinors){
  trainMaxMajors[id]=majors;
  trainMaxMinors[id]=minors;
  trainIgnoreMinors[id]=ignoreMinors;
  for (int j=0; j < nbVertexes; j++) {
    if (vertexMajor[id]) {
      vertexValueByTrain[j][id]=vertexValueByTrain[j][id] * multiplyMajors;
    }
    if (vertexMinor[id]) {
      vertexValueByTrain[j][id]=vertexValueByTrain[j][id] * multiplyMinors;
    }
  }
}","void setTrain(int id,int majors,int minors,boolean ignoreMinors,int multiplyMajors,int multiplyMinors){
  trainMaxMajors[id]=majors;
  trainMaxMinors[id]=minors;
  trainIgnoreMinors[id]=ignoreMinors;
  for (int j=0; j < nbVertexes; j++) {
    if (vertexMajor[j]) {
      vertexValueByTrain[j][id]=vertexValueByTrain[j][id] * multiplyMajors;
    }
 else     if (vertexMinor[j]) {
      if (ignoreMinors) {
        vertexValueByTrain[j][id]=0;
      }
 else {
        vertexValueByTrain[j][id]=vertexValueByTrain[j][id] * multiplyMinors;
      }
    }
  }
}",0.9006882989183874
173716,"private void notifyRevenueAdapter(final int revenue,final boolean finalResult){
  String modifier;
  if (finalResult)   modifier=""String_Node_Str"";
 else   modifier=""String_Node_Str"";
  StringBuffer statistics=new StringBuffer();
  statistics.append(nbEvaluations + ""String_Node_Str"");
  if (useRevenuePrediction)   statistics.append(""String_Node_Str"" + nbPredictions + ""String_Node_Str"");
  statistics.append(""String_Node_Str"" + nbEdges + ""String_Node_Str"");
  log.info(""String_Node_Str"" + modifier + ""String_Node_Str""+ revenue+ ""String_Node_Str""+ statistics.toString());
  revenueAdapter.notifyRevenueListener(revenue,finalResult);
}","private void notifyRevenueAdapter(final int revenue,final boolean finalResult){
  String modifier;
  if (finalResult)   modifier=""String_Node_Str"";
 else   modifier=""String_Node_Str"";
  log.info(""String_Node_Str"" + modifier + ""String_Node_Str""+ revenue+ ""String_Node_Str""+ getStatistics());
  revenueAdapter.notifyRevenueListener(revenue,finalResult);
}",0.4878542510121457
173717,"void initialPredictionRuns(int startTrain,int finalTrain){
  if (startTrain > finalTrain)   return;
  useRevenuePrediction=true;
  this.maxCumulatedTrainRevenues=new int[nbTrains];
  initRevenueValues(startTrain,finalTrain);
  if (startTrain == finalTrain)   return;
  nbEvaluations=0;
  nbPredictions=0;
  nbEdges=0;
  log.info(""String_Node_Str"");
  int cumulatedRevenues=0;
  int[] maxSingleTrainRevenues=new int[nbTrains];
  for (int j=finalTrain; j >= startTrain; j--) {
    this.startTrain=j;
    this.finalTrain=j;
    currentBestValue=0;
    runTrain(j);
    log.info(""String_Node_Str"" + j + ""String_Node_Str""+ currentBestValue);
    maxSingleTrainRevenues[j]=currentBestValue;
    cumulatedRevenues+=currentBestValue;
    maxCumulatedTrainRevenues[j]=cumulatedRevenues;
  }
  if (startTrain == finalTrain - 1)   return;
  log.info(""String_Node_Str"");
  this.finalTrain=finalTrain;
  for (int j=finalTrain - 1; j > startTrain; j--) {
    this.startTrain=j;
    currentBestValue=0;
    runTrain(j);
    log.info(""String_Node_Str"" + j + ""String_Node_Str""+ currentBestValue);
    maxCumulatedTrainRevenues[j]=currentBestValue;
    maxCumulatedTrainRevenues[j - 1]=currentBestValue + maxSingleTrainRevenues[j - 1];
  }
}","void initialPredictionRuns(int startTrain,int finalTrain){
  if (startTrain > finalTrain)   return;
  nbEvaluations=0;
  nbPredictions=0;
  nbEdges=0;
  useRevenuePrediction=true;
  this.maxCumulatedTrainRevenues=new int[nbTrains];
  initRevenueValues(startTrain,finalTrain);
  if (startTrain == finalTrain)   return;
  nbEvaluations=0;
  nbPredictions=0;
  nbEdges=0;
  log.info(""String_Node_Str"");
  int cumulatedRevenues=0;
  int[] maxSingleTrainRevenues=new int[nbTrains];
  for (int j=finalTrain; j >= startTrain; j--) {
    this.startTrain=j;
    this.finalTrain=j;
    currentBestValue=0;
    runTrain(j);
    log.info(""String_Node_Str"" + j + ""String_Node_Str""+ currentBestValue+ ""String_Node_Str""+ getStatistics());
    maxSingleTrainRevenues[j]=currentBestValue;
    cumulatedRevenues+=currentBestValue;
    maxCumulatedTrainRevenues[j]=cumulatedRevenues;
  }
  if (startTrain == finalTrain - 1)   return;
  log.info(""String_Node_Str"");
  this.finalTrain=finalTrain;
  for (int j=finalTrain - 1; j > startTrain; j--) {
    this.startTrain=j;
    currentBestValue=0;
    runTrain(j);
    log.info(""String_Node_Str"" + j + ""String_Node_Str""+ currentBestValue+ ""String_Node_Str""+ getStatistics());
    maxCumulatedTrainRevenues[j]=currentBestValue;
    maxCumulatedTrainRevenues[j - 1]=currentBestValue + maxSingleTrainRevenues[j - 1];
  }
}",0.9521214480342546
173718,"int calculateRevenue(int startTrain,int finalTrain){
  log.info(""String_Node_Str"" + startTrain + ""String_Node_Str""+ finalTrain);
  nbEvaluations=0;
  nbPredictions=0;
  nbEdges=0;
  this.startTrain=startTrain;
  this.finalTrain=finalTrain;
  runTrain(startTrain);
  notifyRevenueAdapter(currentBestValue,true);
  return currentBestValue;
}","int calculateRevenue(int startTrain,int finalTrain){
  log.info(""String_Node_Str"" + startTrain + ""String_Node_Str""+ finalTrain);
  this.startTrain=startTrain;
  this.finalTrain=finalTrain;
  runTrain(startTrain);
  notifyRevenueAdapter(currentBestValue,true);
  return currentBestValue;
}",0.9186602870813396
173719,"protected boolean setNextOperatingCompany(boolean initial){
  if (operatingCompanyIndexObject == null) {
    operatingCompanyIndexObject=new IntegerState(""String_Node_Str"");
  }
  if (initial) {
    operatingCompanyIndexObject.set(0);
  }
 else {
    operatingCompanyIndexObject.add(1);
  }
  int operatingCompanyIndex=operatingCompanyIndexObject.intValue();
  if (operatingCompanyIndex >= operatingCompanyArray.length) {
    operatingCompany=null;
    return false;
  }
 else {
    operatingCompany=operatingCompanyArray[operatingCompanyIndex];
    log.debug(""String_Node_Str"" + operatingCompany.getName() + ""String_Node_Str""+ getRoundName());
    return true;
  }
}","protected boolean setNextOperatingCompany(boolean initial){
  if (operatingCompanyIndexObject == null) {
    operatingCompanyIndexObject=new IntegerState(""String_Node_Str"");
  }
  while (true) {
    if (initial) {
      operatingCompanyIndexObject.set(0);
      initial=false;
    }
 else {
      operatingCompanyIndexObject.add(1);
    }
    int operatingCompanyIndex=operatingCompanyIndexObject.intValue();
    if (operatingCompanyIndex >= operatingCompanyArray.length) {
      return false;
    }
 else {
      operatingCompany=operatingCompanyArray[operatingCompanyIndex];
      if (operatingCompany.isClosed())       continue;
      return true;
    }
  }
}",0.6997742663656885
173720,"/** 
 * Get a list of buyable trains for the currently operating company. Omit trains that the company has no money for. If there is no cash to buy any train from the Bank, prepare for emergency train buying.
 */
public void setBuyableTrains(){
  if (operatingCompany == null)   return;
  TrainManager trainMgr=gameManager.getTrainManager();
  int cash=operatingCompany.getCash();
  int cost;
  List<TrainI> trains;
  boolean hasTrains=operatingCompany.getPortfolio().getNumberOfTrains() > 0;
  boolean canBuyTrainNow=canBuyTrainNow();
  boolean presidentMayHelp=!hasTrains && operatingCompany.mustOwnATrain();
  TrainI cheapestTrain=null;
  int costOfCheapestTrain=0;
  if (getCurrentPhase().canBuyMoreTrainsPerTurn() || trainsBoughtThisTurn.isEmpty()) {
    boolean mayBuyMoreOfEachType=getCurrentPhase().canBuyMoreTrainsPerTypePerTurn();
    trains=trainMgr.getAvailableNewTrains();
    for (    TrainI train : trains) {
      if (!operatingCompany.mayBuyTrainType(train))       continue;
      if (!mayBuyMoreOfEachType && trainsBoughtThisTurn.contains(train.getType())) {
        continue;
      }
      cost=train.getCost();
      if (cost <= cash) {
        if (canBuyTrainNow) {
          BuyTrain action=new BuyTrain(train,ipo,cost);
          action.setForcedBuyIfNoRoute(presidentMayHelp);
          possibleActions.add(action);
        }
      }
 else       if (costOfCheapestTrain == 0 || cost < costOfCheapestTrain) {
        cheapestTrain=train;
        costOfCheapestTrain=cost;
      }
      if (train.canBeExchanged() && hasTrains) {
        cost=train.getType().getExchangeCost();
        if (cost <= cash) {
          List<TrainI> exchangeableTrains=operatingCompany.getPortfolio().getUniqueTrains();
          BuyTrain action=new BuyTrain(train,ipo,cost);
          action.setTrainsForExchange(exchangeableTrains);
          possibleActions.add(action);
          canBuyTrainNow=true;
        }
      }
      if (!canBuyTrainNow)       continue;
      for (      SpecialTrainBuy stb : getSpecialProperties(SpecialTrainBuy.class)) {
        int reducedPrice=stb.getPrice(cost);
        if (reducedPrice > cash)         continue;
        BuyTrain bt=new BuyTrain(train,ipo,reducedPrice);
        bt.setSpecialProperty(stb);
        bt.setForcedBuyIfNoRoute(presidentMayHelp);
        possibleActions.add(bt);
      }
    }
    if (!canBuyTrainNow)     return;
    trains=pool.getUniqueTrains();
    for (    TrainI train : trains) {
      if (!mayBuyMoreOfEachType && trainsBoughtThisTurn.contains(train.getType())) {
        continue;
      }
      cost=train.getCost();
      if (cost <= cash) {
        BuyTrain bt=new BuyTrain(train,pool,cost);
        bt.setForcedBuyIfNoRoute(presidentMayHelp);
        possibleActions.add(bt);
      }
 else       if (costOfCheapestTrain == 0 || cost < costOfCheapestTrain) {
        cheapestTrain=train;
        costOfCheapestTrain=cost;
      }
    }
    if (!hasTrains && possibleActions.getType(BuyTrain.class).isEmpty() && cheapestTrain != null && presidentMayHelp) {
      BuyTrain bt=new BuyTrain(cheapestTrain,cheapestTrain.getHolder(),costOfCheapestTrain);
      bt.setPresidentMustAddCash(costOfCheapestTrain - cash);
      bt.setForcedBuyIfNoRoute(presidentMayHelp);
      possibleActions.add(bt);
    }
  }
  if (!canBuyTrainNow)   return;
  if (getCurrentPhase().isTrainTradingAllowed()) {
    PublicCompanyI c;
    BuyTrain bt;
    Player p;
    Portfolio pf;
    int index;
    int numberOfPlayers=getNumberOfPlayers();
    List<List<PublicCompanyI>> companiesPerPlayer=new ArrayList<List<PublicCompanyI>>(numberOfPlayers);
    for (int i=0; i < numberOfPlayers; i++)     companiesPerPlayer.add(new ArrayList<PublicCompanyI>(4));
    List<PublicCompanyI> companies;
    for (int j=0; j < operatingCompanyArray.length; j++) {
      c=operatingCompanyArray[j];
      if (c.isClosed() || c == operatingCompany)       continue;
      p=c.getPresident();
      index=p.getIndex();
      companiesPerPlayer.get(index).add(c);
    }
    int currentPlayerIndex=operatingCompany.getPresident().getIndex();
    for (int i=currentPlayerIndex; i < currentPlayerIndex + numberOfPlayers; i++) {
      companies=companiesPerPlayer.get(i % numberOfPlayers);
      for (      PublicCompanyI company : companies) {
        pf=company.getPortfolio();
        trains=pf.getUniqueTrains();
        for (        TrainI train : trains) {
          if (train.isObsolete())           continue;
          if (i != currentPlayerIndex && getGameParameterAsBoolean(GameDef.Parm.FIXED_PRICE_TRAINS_BETWEEN_PRESIDENTS) || operatingCompany.mustTradeTrainsAtFixedPrice() || company.mustTradeTrainsAtFixedPrice()) {
            if (cash >= train.getCost()) {
              bt=new BuyTrain(train,pf,train.getCost());
            }
 else {
              continue;
            }
          }
 else {
            bt=new BuyTrain(train,pf,0);
          }
          if (presidentMayHelp && cash < train.getCost()) {
            bt.setPresidentMayAddCash(train.getCost() - cash);
          }
          possibleActions.add(bt);
        }
      }
    }
  }
  if (!operatingCompany.mustOwnATrain() || operatingCompany.getPortfolio().getNumberOfTrains() > 0) {
    doneAllowed=true;
  }
}","/** 
 * Get a list of buyable trains for the currently operating company. Omit trains that the company has no money for. If there is no cash to buy any train from the Bank, prepare for emergency train buying.
 */
public void setBuyableTrains(){
  if (operatingCompany == null)   return;
  TrainManager trainMgr=gameManager.getTrainManager();
  int cash=operatingCompany.getCash();
  int cost;
  List<TrainI> trains;
  boolean hasTrains=operatingCompany.getPortfolio().getNumberOfTrains() > 0;
  boolean canBuyTrainNow=canBuyTrainNow();
  boolean presidentMayHelp=!hasTrains && operatingCompany.mustOwnATrain();
  TrainI cheapestTrain=null;
  int costOfCheapestTrain=0;
  if (getCurrentPhase().canBuyMoreTrainsPerTurn() || trainsBoughtThisTurn.isEmpty()) {
    boolean mayBuyMoreOfEachType=getCurrentPhase().canBuyMoreTrainsPerTypePerTurn();
    trains=trainMgr.getAvailableNewTrains();
    for (    TrainI train : trains) {
      if (!operatingCompany.mayBuyTrainType(train))       continue;
      if (!mayBuyMoreOfEachType && trainsBoughtThisTurn.contains(train.getType())) {
        continue;
      }
      cost=train.getCost();
      if (cost <= cash) {
        if (canBuyTrainNow) {
          BuyTrain action=new BuyTrain(train,ipo,cost);
          action.setForcedBuyIfNoRoute(presidentMayHelp);
          possibleActions.add(action);
        }
      }
 else       if (costOfCheapestTrain == 0 || cost < costOfCheapestTrain) {
        cheapestTrain=train;
        costOfCheapestTrain=cost;
      }
      if (train.canBeExchanged() && hasTrains) {
        cost=train.getType().getExchangeCost();
        if (cost <= cash) {
          List<TrainI> exchangeableTrains=operatingCompany.getPortfolio().getUniqueTrains();
          BuyTrain action=new BuyTrain(train,ipo,cost);
          action.setTrainsForExchange(exchangeableTrains);
          possibleActions.add(action);
          canBuyTrainNow=true;
        }
      }
      if (!canBuyTrainNow)       continue;
      for (      SpecialTrainBuy stb : getSpecialProperties(SpecialTrainBuy.class)) {
        int reducedPrice=stb.getPrice(cost);
        if (reducedPrice > cash)         continue;
        BuyTrain bt=new BuyTrain(train,ipo,reducedPrice);
        bt.setSpecialProperty(stb);
        bt.setForcedBuyIfNoRoute(presidentMayHelp);
        possibleActions.add(bt);
      }
    }
    if (!canBuyTrainNow)     return;
    trains=pool.getUniqueTrains();
    for (    TrainI train : trains) {
      if (!mayBuyMoreOfEachType && trainsBoughtThisTurn.contains(train.getType())) {
        continue;
      }
      cost=train.getCost();
      if (cost <= cash) {
        BuyTrain bt=new BuyTrain(train,pool,cost);
        bt.setForcedBuyIfNoRoute(presidentMayHelp);
        possibleActions.add(bt);
      }
 else       if (costOfCheapestTrain == 0 || cost < costOfCheapestTrain) {
        cheapestTrain=train;
        costOfCheapestTrain=cost;
      }
    }
    if (!hasTrains && possibleActions.getType(BuyTrain.class).isEmpty() && cheapestTrain != null && presidentMayHelp) {
      BuyTrain bt=new BuyTrain(cheapestTrain,cheapestTrain.getHolder(),costOfCheapestTrain);
      bt.setPresidentMustAddCash(costOfCheapestTrain - cash);
      bt.setForcedBuyIfNoRoute(presidentMayHelp);
      possibleActions.add(bt);
    }
  }
  if (!canBuyTrainNow)   return;
  if (getCurrentPhase().isTrainTradingAllowed()) {
    PublicCompanyI c;
    BuyTrain bt;
    Player p;
    Portfolio pf;
    int index;
    int numberOfPlayers=getNumberOfPlayers();
    List<List<PublicCompanyI>> companiesPerPlayer=new ArrayList<List<PublicCompanyI>>(numberOfPlayers);
    for (int i=0; i < numberOfPlayers; i++)     companiesPerPlayer.add(new ArrayList<PublicCompanyI>(4));
    List<PublicCompanyI> companies;
    for (int j=0; j < operatingCompanyArray.length; j++) {
      c=operatingCompanyArray[j];
      if (c.isClosed() || c == operatingCompany)       continue;
      p=c.getPresident();
      index=p.getIndex();
      companiesPerPlayer.get(index).add(c);
    }
    int currentPlayerIndex=getCurrentPlayer().getIndex();
    for (int i=currentPlayerIndex; i < currentPlayerIndex + numberOfPlayers; i++) {
      companies=companiesPerPlayer.get(i % numberOfPlayers);
      for (      PublicCompanyI company : companies) {
        pf=company.getPortfolio();
        trains=pf.getUniqueTrains();
        for (        TrainI train : trains) {
          if (train.isObsolete())           continue;
          if (i != currentPlayerIndex && getGameParameterAsBoolean(GameDef.Parm.FIXED_PRICE_TRAINS_BETWEEN_PRESIDENTS) || operatingCompany.mustTradeTrainsAtFixedPrice() || company.mustTradeTrainsAtFixedPrice()) {
            if (cash >= train.getCost()) {
              bt=new BuyTrain(train,pf,train.getCost());
            }
 else {
              continue;
            }
          }
 else {
            bt=new BuyTrain(train,pf,0);
          }
          if (presidentMayHelp && cash < train.getCost()) {
            bt.setPresidentMayAddCash(train.getCost() - cash);
          }
          possibleActions.add(bt);
        }
      }
    }
  }
  if (!operatingCompany.mustOwnATrain() || operatingCompany.getPortfolio().getNumberOfTrains() > 0) {
    doneAllowed=true;
  }
}",0.9962568384681832
173721,"public void start(){
  thisOrNumber=gameManager.getORId();
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",thisOrNumber));
  int count=0;
  for (  PrivateCompanyI priv : companyManager.getAllPrivateCompanies()) {
    if (!priv.isClosed()) {
      if (((Portfolio)priv.getHolder()).getOwner().getClass() != Bank.class) {
        CashHolder recipient=((Portfolio)priv.getHolder()).getOwner();
        int revenue=priv.getRevenueByPhase(getCurrentPhase());
        if (count++ == 0)         ReportBuffer.add(""String_Node_Str"");
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",recipient.getName(),Bank.format(revenue),priv.getName()));
        new CashMove(bank,recipient,revenue);
      }
    }
  }
  if (operatingCompanyArray.length > 0) {
    StringBuilder msg=new StringBuilder();
    for (    PublicCompanyI company : operatingCompanyArray) {
      msg.append(""String_Node_Str"").append(company.getName());
    }
    if (msg.length() > 0)     msg.deleteCharAt(0);
    log.info(""String_Node_Str"" + msg.toString());
    if (stepObject == null) {
      stepObject=new EnumState<GameDef.OrStep>(""String_Node_Str"",GameDef.OrStep.INITIAL);
      stepObject.addObserver(this);
    }
    if (setNextOperatingCompany(true)) {
      setStep(GameDef.OrStep.INITIAL);
    }
    return;
  }
  String text=LocalText.getText(""String_Node_Str"");
  ReportBuffer.add(text);
  DisplayBuffer.add(text);
  finishRound();
}","public void start(){
  thisOrNumber=gameManager.getORId();
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",thisOrNumber));
  privatesPayOut();
  if (operatingCompanyArray.length > 0) {
    StringBuilder msg=new StringBuilder();
    for (    PublicCompanyI company : operatingCompanyArray) {
      msg.append(""String_Node_Str"").append(company.getName());
    }
    if (msg.length() > 0)     msg.deleteCharAt(0);
    log.info(""String_Node_Str"" + msg.toString());
    if (stepObject == null) {
      stepObject=new EnumState<GameDef.OrStep>(""String_Node_Str"",GameDef.OrStep.INITIAL);
      stepObject.addObserver(this);
    }
    if (setNextOperatingCompany(true)) {
      setStep(GameDef.OrStep.INITIAL);
    }
    return;
  }
  String text=LocalText.getText(""String_Node_Str"");
  ReportBuffer.add(text);
  DisplayBuffer.add(text);
  finishRound();
}",0.7372583479789103
173722,"public OperatingRound_1835(GameManagerI gameManager){
  super(gameManager);
}","public OperatingRound_1835(GameManagerI gameManager){
  super(gameManager);
  deniedIncomeShare=new HashMap<Player,Integer>();
}",0.751219512195122
173723,"/** 
 * copy of standard dfs 
 */
private void encounterVertexAgain(NetworkVertex vertex,NetworkEdge edge){
  VisitColor color=getSeenData(vertex);
  if (color != VisitColor.WHITE && color != VisitColor.YELLOW) {
    return;
  }
  int i=stack.indexOf(vertex);
  assert(i > -1);
  stack.remove(i);
  stack.add(vertex);
}","/** 
 * copy of standard dfs 
 */
private void encounterVertexAgain(NetworkVertex vertex,NetworkEdge edge){
  VisitColor color=getSeenData(vertex);
  if (color != VisitColor.WHITE) {
    return;
  }
  int i=stack.indexOf(vertex);
  assert(i > -1);
  stack.remove(i);
  stack.add(vertex);
}",0.950657894736842
173724,"private void recordFinish(){
  NetworkVertex v=popStack();
  putSeenData(v,VisitColor.BLACK);
  finishVertex(v);
}","private void recordFinish(){
  NetworkVertex v=popStack();
  if (getSeenData(v) == VisitColor.WHITE)   putSeenData(v,VisitColor.BLACK);
  finishVertex(v);
}",0.8444444444444444
173725,"private void addUnseenChildrenOf(NetworkVertex vertex,VisitColor previousColor){
  if (company != null && !vertex.canCompanyRunThrough(company))   return;
  for (  NetworkEdge edge : graph.edgesOf(vertex)) {
    if (previousColor == VisitColor.WHITE || edge.isGreedy()) {
      NetworkVertex oppositeV=Graphs.getOppositeVertex(graph,edge,vertex);
      if (isSeenVertex(oppositeV)) {
        encounterVertexAgain(oppositeV,edge);
      }
 else {
        encounterVertex(oppositeV,edge);
      }
    }
  }
}","private void addUnseenChildrenOf(NetworkVertex vertex,VisitColor previousColor){
  if (company != null && !vertex.canCompanyRunThrough(company))   return;
  for (  NetworkEdge edge : graph.edgesOf(vertex)) {
    if (previousColor == VisitColor.WHITE || edge.isGreedy()) {
      NetworkVertex oppositeV=Graphs.getOppositeVertex(graph,edge,vertex);
      if (isSeenVertex(oppositeV,vertex.isSide() && !edge.isGreedy())) {
        encounterVertexAgain(oppositeV,edge);
      }
 else {
        encounterVertex(oppositeV,edge);
      }
    }
  }
}",0.965648854961832
173726,"/** 
 * Determines whether a vertex has been seen yet by this traversal.
 * @param vertex vertex in question
 * @return <tt>true</tt> if vertex has already been seen
 */
private boolean isSeenVertex(NetworkVertex vertex){
  return seen.containsKey(vertex);
}","/** 
 * Determines whether a vertex has been seen yet by this traversal.
 * @param vertex vertex in question
 * @return <tt>true</tt> if vertex has already been seen
 */
private boolean isSeenVertex(NetworkVertex vertex,boolean mustUseGreedy){
  return seen.containsKey(vertex) && (mustUseGreedy || !this.mustUseGreedy.get(vertex));
}",0.8716216216216216
173727,"/** 
 * copy of standard dfs 
 */
private void encounterVertex(NetworkVertex vertex,NetworkEdge edge){
  VisitColor color=VisitColor.WHITE;
  if (vertex.isSide() && !edge.isGreedy())   color=VisitColor.YELLOW;
  putSeenData(vertex,color);
  stack.add(vertex);
  log.debug(""String_Node_Str"" + vertex + ""String_Node_Str""+ color);
}","/** 
 * copy of standard dfs 
 */
private void encounterVertex(NetworkVertex vertex,NetworkEdge edge){
  putSeenData(vertex,VisitColor.WHITE);
  mustUseGreedy.put(vertex,vertex.isSide() && !edge.isGreedy());
  stack.add(vertex);
  log.debug(""String_Node_Str"" + vertex);
}",0.74
173728,"public void refreshRevenueCalculator(){
  rc=null;
}","public void refreshRevenueCalculator(){
  rc=null;
  this.startVertexes=new ArrayList<NetworkVertex>();
}",0.6624203821656051
173729,"public void populateRevenueCalculator(PublicCompanyI company,PhaseI phase){
  if (rc == null)   initRevenueCalculator();
  NetworkVertex.setPhaseForAll(vertexes,phase);
  Collections.sort(vertexes,new NetworkVertex.ValueOrder());
  for (int id=0; id < vertexes.size(); id++) {
    NetworkVertex v=vertexes.get(id);
    if (v.isHQ()) {
      startVertexes.addAll(Graphs.neighborListOf(graph,v));
    }
 else {
      int value=v.getValue();
      boolean city=v.isCityType();
      boolean town=v.isTownType();
      int j=0, e[]=new int[maxNeighbors];
      if (v.canCompanyRunThrough(company)) {
        for (        NetworkVertex n : Graphs.neighborListOf(graph,v)) {
          if (!n.isHQ()) {
            e[j++]=vertexes.lastIndexOf(n);
          }
        }
      }
      Arrays.sort(e,0,j);
      e[j]=-1;
      rc.setVertex(id,value,city,town,e);
    }
  }
  int[] sv=new int[startVertexes.size()];
  for (int j=0; j < startVertexes.size(); j++) {
    sv[j]=vertexes.lastIndexOf(startVertexes.get(j));
  }
  Arrays.sort(sv);
  rc.setStartVertexes(sv);
  for (int id=0; id < edges.size(); id++) {
    NetworkEdge e=edges.get(id);
    int vA=vertexes.lastIndexOf(e.getSource());
    int vB=vertexes.lastIndexOf(e.getTarget());
    boolean greedy=e.isGreedy();
    int distance=e.getDistance();
    rc.setEdge(vA,vB,greedy,distance);
    rc.setEdge(vB,vA,greedy,distance);
  }
  for (int id=0; id < trains.size(); id++) {
    NetworkTrain train=trains.get(id);
    train.addToRevenueCalculator(rc,id);
  }
}","public void populateRevenueCalculator(PublicCompanyI company,PhaseI phase,boolean activatePrediction){
  if (rc == null)   initRevenueCalculator();
  prepareRevenuePrediction(activatePrediction);
  NetworkVertex.setPhaseForAll(vertexes,phase);
  Collections.sort(vertexes,new NetworkVertex.ValueOrder());
  for (int id=0; id < vertexes.size(); id++) {
    NetworkVertex v=vertexes.get(id);
    if (v.isHQ()) {
      startVertexes.addAll(Graphs.neighborListOf(graph,v));
    }
 else {
      int value=v.getValue();
      boolean city=v.isCityType();
      boolean town=v.isTownType();
      int j=0, e[]=new int[maxNeighbors];
      if (v.canCompanyRunThrough(company)) {
        for (        NetworkVertex n : Graphs.neighborListOf(graph,v)) {
          if (!n.isHQ()) {
            e[j++]=vertexes.lastIndexOf(n);
          }
        }
      }
      Arrays.sort(e,0,j);
      e[j]=-1;
      rc.setVertex(id,value,city,town,e);
    }
  }
  int[] sv=new int[startVertexes.size()];
  for (int j=0; j < startVertexes.size(); j++) {
    sv[j]=vertexes.lastIndexOf(startVertexes.get(j));
  }
  Arrays.sort(sv);
  rc.setStartVertexes(sv);
  for (int id=0; id < edges.size(); id++) {
    NetworkEdge e=edges.get(id);
    int vA=vertexes.lastIndexOf(e.getSource());
    int vB=vertexes.lastIndexOf(e.getTarget());
    boolean greedy=e.isGreedy();
    int distance=e.getDistance();
    rc.setEdge(vA,vB,greedy,distance);
    rc.setEdge(vB,vA,greedy,distance);
  }
  for (int id=0; id < trains.size(); id++) {
    NetworkTrain train=trains.get(id);
    train.addToRevenueCalculator(rc,id);
  }
}",0.975767366720517
173730,"/** 
 * arrives at an unvisited vertex
 */
private void nextVertex(int trainId,int vertexId,int previousId){
  boolean trainTerminated;
  if (encounterVertex(trainId,vertexId,true)) {
    trainTerminated=trainTerminated(trainId) || (predictRevenues(trainId));
  }
 else {
    trainTerminated=false;
  }
  boolean evaluateResult=true;
  if (!trainTerminated) {
    for (int j=0; j < maxNeighbors; j++) {
      int neighborId=vertexNeighbors[vertexId][j];
      log.debug(""String_Node_Str"" + j + ""String_Node_Str""+ vertexId+ ""String_Node_Str""+ neighborId);
      if (neighborId == -1)       break;
      if (trainVisited[trainId][neighborId]) {
        log.debug(""String_Node_Str"");
        continue;
      }
      if (travelEdge(vertexId,neighborId,edgeGreedy[previousId][vertexId])) {
        evaluateResult=false;
        nextVertex(trainId,neighborId,vertexId);
      }
    }
    if (trainBottomPos[trainId] == 0 && (vertexCity[vertexId] || vertexTown[vertexId])) {
      runBottom(trainId);
    }
  }
  finalizeVertex(trainId,vertexId,evaluateResult);
  encounterVertex(trainId,vertexId,false);
  returnEdge(trainId);
}","/** 
 * arrives at an unvisited vertex
 */
private void nextVertex(int trainId,int vertexId,int previousId){
  boolean trainTerminated=false;
  if (encounterVertex(trainId,vertexId,true)) {
    if (useRevenuePrediction && predictRevenues(trainId)) {
      encounterVertex(trainId,vertexId,false);
      returnEdge(trainId);
      return;
    }
 else {
      trainTerminated=trainTerminated(trainId);
    }
  }
  boolean evaluateResult=true;
  if (!trainTerminated) {
    for (int j=0; j < maxNeighbors; j++) {
      int neighborId=vertexNeighbors[vertexId][j];
      log.debug(""String_Node_Str"" + j + ""String_Node_Str""+ vertexId+ ""String_Node_Str""+ neighborId);
      if (neighborId == -1)       break;
      if (trainVisited[trainId][neighborId]) {
        log.debug(""String_Node_Str"");
        continue;
      }
      if (travelEdge(vertexId,neighborId,edgeGreedy[previousId][vertexId])) {
        evaluateResult=false;
        nextVertex(trainId,neighborId,vertexId);
      }
    }
    if (trainBottomPos[trainId] == 0 && (vertexCity[vertexId] || vertexTown[vertexId])) {
      runBottom(trainId);
    }
  }
  finalizeVertex(trainId,vertexId,evaluateResult);
  encounterVertex(trainId,vertexId,false);
  returnEdge(trainId);
}",0.8209272649936198
173731,"private void evaluateResults(){
  int totalValue=0;
  for (int j=0; j <= finalTrain; j++) {
    if (trainCities[j] + trainTowns[j] <= 1) {
      log.debug(""String_Node_Str"" + j + ""String_Node_Str"");
    }
 else {
      totalValue+=trainCurrentValue[j];
      log.debug(""String_Node_Str"" + j + ""String_Node_Str""+ trainCurrentValue);
    }
  }
  log.debug(""String_Node_Str"" + totalValue);
  if (totalValue > currentBestValue) {
    currentBestValue=totalValue;
    for (int j=0; j <= finalTrain; j++)     for (int v=0; v < nbVertexes; v++)     if (v < trainStackPos[j])     currentBestRun[j][v]=trainVertexStack[j][v];
 else {
      currentBestRun[j][v]=-1;
      break;
    }
    log.info(""String_Node_Str"" + totalValue);
    notifyRevenueAdapter(currentBestValue,false);
  }
}","private void evaluateResults(){
  int totalValue=0;
  for (int j=0; j <= finalTrain; j++) {
    if (trainCities[j] + trainTowns[j] <= 1) {
      log.debug(""String_Node_Str"" + j + ""String_Node_Str"");
    }
 else {
      totalValue+=trainCurrentValue[j];
      log.debug(""String_Node_Str"" + j + ""String_Node_Str""+ trainCurrentValue);
    }
  }
  nbEvaluations++;
  log.debug(""String_Node_Str"" + totalValue);
  if (totalValue > currentBestValue) {
    currentBestValue=totalValue;
    for (int j=0; j <= finalTrain; j++)     for (int v=0; v < nbVertexes; v++)     if (v < trainStackPos[j])     currentBestRun[j][v]=trainVertexStack[j][v];
 else {
      currentBestRun[j][v]=-1;
      break;
    }
    log.info(""String_Node_Str"" + totalValue);
    notifyRevenueAdapter(currentBestValue,false);
  }
}",0.9879057924888606
173732,"private boolean travelEdge(int startVertex,int endVertex,boolean previousGreedy){
  if (edgeUsed[startVertex][endVertex]) {
    log.debug(""String_Node_Str"" + startVertex + ""String_Node_Str""+ endVertex+ ""String_Node_Str"");
    return false;
  }
 else   if (previousGreedy || edgeGreedy[startVertex][endVertex]) {
    log.debug(""String_Node_Str"" + startVertex + ""String_Node_Str""+ endVertex);
    edgeUsed[startVertex][endVertex]=true;
    edgeUsed[endVertex][startVertex]=true;
    countEdges++;
    log.debug(""String_Node_Str"" + countEdges);
    return true;
  }
 else {
    log.debug(""String_Node_Str"" + startVertex + ""String_Node_Str""+ endVertex+ ""String_Node_Str"");
    return false;
  }
}","private boolean travelEdge(int startVertex,int endVertex,boolean previousGreedy){
  if (edgeUsed[startVertex][endVertex]) {
    log.debug(""String_Node_Str"" + startVertex + ""String_Node_Str""+ endVertex+ ""String_Node_Str"");
    return false;
  }
 else   if (previousGreedy || edgeGreedy[startVertex][endVertex]) {
    log.debug(""String_Node_Str"" + startVertex + ""String_Node_Str""+ endVertex);
    edgeUsed[startVertex][endVertex]=true;
    edgeUsed[endVertex][startVertex]=true;
    countEdges++;
    nbEdges++;
    log.debug(""String_Node_Str"" + countEdges);
    return true;
  }
 else {
    log.debug(""String_Node_Str"" + startVertex + ""String_Node_Str""+ endVertex+ ""String_Node_Str"");
    return false;
  }
}",0.98927805575411
173733,"private void notifyRevenueAdapter(final int revenue,final boolean finalResult){
  revenueAdapter.notifyRevenueListener(revenue,finalResult);
}","private void notifyRevenueAdapter(final int revenue,final boolean finalResult){
  String modifier;
  if (finalResult)   modifier=""String_Node_Str"";
 else   modifier=""String_Node_Str"";
  StringBuffer statistics=new StringBuffer();
  statistics.append(nbEvaluations + ""String_Node_Str"");
  if (useRevenuePrediction)   statistics.append(""String_Node_Str"" + nbPredictions + ""String_Node_Str"");
  statistics.append(""String_Node_Str"" + nbEdges + ""String_Node_Str"");
  log.info(""String_Node_Str"" + modifier + ""String_Node_Str""+ revenue+ ""String_Node_Str""+ statistics.toString());
  revenueAdapter.notifyRevenueListener(revenue,finalResult);
}",0.3655083655083655
173734,"private boolean predictRevenues(int trainId){
  int totalValue=0;
  for (int j=0; j <= finalTrain; j++) {
    int trainValue;
    if (j < trainId) {
      trainValue=trainCurrentValue[j];
    }
 else     if (j > trainId) {
      trainValue=maxTrainRevenues[j];
    }
 else {
      if (trainTownsCostNothing[trainId]) {
        trainValue=0;
      }
 else       if (trainTowns[trainId] == 0) {
        trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j]] * trainMultiplyCities[j];
      }
 else {
        int townDiff=trainMaxTowns[trainId] - trainTowns[trainId];
        if (townDiff > 0) {
          trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j]] * trainMultiplyCities[j] + maxTownRevenues[trainMaxTowns[j] - trainTowns[j]] * trainMultiplyTowns[j];
        }
 else         if (townDiff == 0) {
          trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j]] * trainMultiplyCities[j];
        }
 else {
          trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j] + townDiff] * trainMultiplyCities[j];
        }
      }
    }
    log.debug(""String_Node_Str"" + j + ""String_Node_Str""+ trainValue);
    totalValue+=Math.min(trainValue,maxTrainRevenues[trainId]);
  }
  boolean terminate=(totalValue < currentBestValue);
  if (terminate)   log.debug(""String_Node_Str"" + totalValue);
  return terminate;
}","private boolean predictRevenues(int trainId){
  int totalValue=0;
  for (int j=0; j <= finalTrain; j++) {
    int trainValue;
    if (j < trainId) {
      trainValue=trainCurrentValue[j];
    }
 else     if (j > trainId) {
      trainValue=maxTrainRevenues[j];
    }
 else {
      if (trainTownsCostNothing[j]) {
        trainValue=0;
      }
 else       if (trainTowns[j] == 0) {
        trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j]] * trainMultiplyCities[j];
      }
 else {
        int townDiff=trainMaxTowns[j] - trainTowns[j];
        if (townDiff > 0) {
          trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j]] * trainMultiplyCities[j] + maxTownRevenues[trainMaxTowns[j] - trainTowns[j]] * trainMultiplyTowns[j];
        }
 else         if (townDiff == 0) {
          trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j]] * trainMultiplyCities[j];
        }
 else {
          trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j] + townDiff] * trainMultiplyCities[j];
        }
      }
      trainValue=Math.min(trainValue,maxTrainRevenues[j]);
    }
    log.debug(""String_Node_Str"" + j + ""String_Node_Str""+ trainValue);
    totalValue+=trainValue;
  }
  nbPredictions++;
  boolean terminate=(totalValue <= currentBestValue);
  if (terminate)   log.debug(""String_Node_Str"" + totalValue);
  return terminate;
}",0.9264248704663212
173735,"private void runTrain(int trainId){
  log.debug(""String_Node_Str"" + trainId);
  trainStackPos[trainId]=0;
  trainBottomPos[trainId]=0;
  for (int i=0; i < startVertexes.length; i++) {
    int vertexId=startVertexes[i];
    log.debug(""String_Node_Str"" + i + ""String_Node_Str""+ trainId);
    boolean trainTerminated;
    if (encounterVertex(trainId,startVertexes[i],true)) {
      trainTerminated=trainTerminated(trainId) || (predictRevenues(trainId));
    }
 else {
      trainTerminated=false;
    }
    boolean evaluateResult=true;
    if (!trainTerminated) {
      for (int j=0; j < maxNeighbors; j++) {
        int neighborId=vertexNeighbors[vertexId][j];
        log.debug(""String_Node_Str"" + j + ""String_Node_Str""+ neighborId);
        if (neighborId == -1)         break;
        if (travelEdge(vertexId,neighborId,true)) {
          evaluateResult=false;
          trainStartEdge[trainId]=j;
          nextVertex(trainId,neighborId,vertexId);
        }
      }
    }
    finalizeVertex(trainId,startVertexes[i],evaluateResult);
    encounterVertex(trainId,startVertexes[i],false);
    log.debug(""String_Node_Str"" + vertexId + ""String_Node_Str""+ trainId);
  }
  log.debug(""String_Node_Str"" + trainId);
}","private void runTrain(int trainId){
  log.debug(""String_Node_Str"" + trainId);
  trainStackPos[trainId]=0;
  trainBottomPos[trainId]=0;
  for (int i=0; i < startVertexes.length; i++) {
    int vertexId=startVertexes[i];
    log.debug(""String_Node_Str"" + i + ""String_Node_Str""+ trainId);
    boolean trainTerminated=false;
    if (encounterVertex(trainId,vertexId,true)) {
      if (useRevenuePrediction && predictRevenues(trainId)) {
        encounterVertex(trainId,vertexId,false);
        log.debug(""String_Node_Str"" + vertexId + ""String_Node_Str""+ trainId);
        continue;
      }
 else {
        trainTerminated=trainTerminated(trainId);
      }
    }
    boolean evaluateResult=true;
    if (!trainTerminated) {
      for (int j=0; j < maxNeighbors; j++) {
        int neighborId=vertexNeighbors[vertexId][j];
        log.debug(""String_Node_Str"" + j + ""String_Node_Str""+ neighborId);
        if (neighborId == -1)         break;
        if (travelEdge(vertexId,neighborId,true)) {
          evaluateResult=false;
          trainStartEdge[trainId]=j;
          nextVertex(trainId,neighborId,vertexId);
        }
      }
    }
    finalizeVertex(trainId,vertexId,evaluateResult);
    encounterVertex(trainId,vertexId,false);
    log.debug(""String_Node_Str"" + vertexId + ""String_Node_Str""+ trainId);
  }
  log.debug(""String_Node_Str"" + trainId);
}",0.75390625
173736,"public RevenueCalculator(RevenueAdapter revenueAdapter,int nbVertexes,int maxNeighbors,int nbTrains){
  this.revenueAdapter=revenueAdapter;
  this.nbVertexes=nbVertexes;
  this.maxNeighbors=maxNeighbors;
  this.nbTrains=nbTrains;
  log.debug(""String_Node_Str"" + nbVertexes + ""String_Node_Str""+ maxNeighbors+ ""String_Node_Str""+ nbTrains);
  vertexValue=new int[nbVertexes];
  vertexCity=new boolean[nbVertexes];
  vertexTown=new boolean[nbVertexes];
  vertexNeighbors=new int[nbVertexes][maxNeighbors];
  edgeGreedy=new boolean[nbVertexes][nbVertexes];
  edgeDistance=new int[nbVertexes][nbVertexes];
  edgeUsed=new boolean[nbVertexes][nbVertexes];
  trainCities=new int[nbTrains];
  trainTowns=new int[nbTrains];
  trainTownsCostNothing=new boolean[nbTrains];
  trainMultiplyCities=new int[nbTrains];
  trainMultiplyTowns=new int[nbTrains];
  trainCurrentValue=new int[nbTrains];
  trainMaxCities=new int[nbTrains];
  trainMaxTowns=new int[nbTrains];
  trainVisited=new boolean[nbTrains][nbVertexes];
  trainVertexStack=new int[nbTrains][nbVertexes];
  trainStackPos=new int[nbTrains];
  trainBottomPos=new int[nbTrains];
  trainStartEdge=new int[nbTrains];
  currentBestRun=new int[nbTrains][nbVertexes];
}","public RevenueCalculator(RevenueAdapter revenueAdapter,int nbVertexes,int maxNeighbors,int nbTrains){
  this.revenueAdapter=revenueAdapter;
  this.nbVertexes=nbVertexes;
  this.maxNeighbors=maxNeighbors;
  this.nbTrains=nbTrains;
  log.debug(""String_Node_Str"" + nbVertexes + ""String_Node_Str""+ maxNeighbors+ ""String_Node_Str""+ nbTrains);
  vertexValue=new int[nbVertexes];
  vertexCity=new boolean[nbVertexes];
  vertexTown=new boolean[nbVertexes];
  vertexNeighbors=new int[nbVertexes][maxNeighbors];
  edgeGreedy=new boolean[nbVertexes][nbVertexes];
  edgeDistance=new int[nbVertexes][nbVertexes];
  edgeUsed=new boolean[nbVertexes][nbVertexes];
  trainCities=new int[nbTrains];
  trainTowns=new int[nbTrains];
  trainTownsCostNothing=new boolean[nbTrains];
  trainMultiplyCities=new int[nbTrains];
  trainMultiplyTowns=new int[nbTrains];
  trainCurrentValue=new int[nbTrains];
  trainMaxCities=new int[nbTrains];
  trainMaxTowns=new int[nbTrains];
  trainVisited=new boolean[nbTrains][nbVertexes];
  trainVertexStack=new int[nbTrains][nbVertexes];
  trainStackPos=new int[nbTrains];
  trainBottomPos=new int[nbTrains];
  trainStartEdge=new int[nbTrains];
  currentBestRun=new int[nbTrains][nbVertexes];
  useRevenuePrediction=false;
}",0.9877250409165302
173737,"void setPredictionData(int[] maxCityRevenues,int[] maxTownRevenues){
  this.maxCityRevenues=maxCityRevenues;
  this.maxTownRevenues=maxTownRevenues;
}","void setPredictionData(int[] maxCityRevenues,int[] maxTownRevenues){
  this.maxCityRevenues=maxCityRevenues;
  this.maxTownRevenues=maxTownRevenues;
  useRevenuePrediction=true;
}",0.9118541033434652
173738,"int calculateRevenue(int startTrain,int finalTrain){
  log.info(""String_Node_Str"" + startTrain + ""String_Node_Str""+ finalTrain);
  stopped=false;
  maxTrainRevenues=new int[nbTrains];
  for (int j=0; j < nbTrains; j++) {
    maxTrainRevenues[j]=maxCityRevenues[trainMaxCities[j]] * trainMultiplyCities[j] + maxTownRevenues[trainMaxTowns[j]] * trainMultiplyTowns[j];
  }
  this.finalTrain=finalTrain;
  runTrain(startTrain);
  notifyRevenueAdapter(currentBestValue,true);
  return currentBestValue;
}","int calculateRevenue(int startTrain,int finalTrain){
  log.info(""String_Node_Str"" + startTrain + ""String_Node_Str""+ finalTrain);
  nbEvaluations=0;
  nbPredictions=0;
  nbEdges=0;
  if (useRevenuePrediction) {
    maxTrainRevenues=new int[nbTrains];
    for (int j=0; j < nbTrains; j++) {
      maxTrainRevenues[j]=maxCityRevenues[trainMaxCities[j]] * trainMultiplyCities[j] + maxTownRevenues[trainMaxTowns[j]] * trainMultiplyTowns[j];
    }
  }
  this.finalTrain=finalTrain;
  runTrain(startTrain);
  notifyRevenueAdapter(currentBestValue,true);
  return currentBestValue;
}",0.905027932960894
173739,"public static Point2D getVertexPoint2D(HexMap map,NetworkVertex vertex){
  GUIHex guiHex=map.getHexByName(vertex.getHex().getName());
  if (vertex.isCityType()) {
    return guiHex.getCityPoint2D(vertex.getCity());
  }
 else   if (vertex.isTownType()) {
    return guiHex.getCenterPoint2D();
  }
 else   if (vertex.isSide()) {
    return guiHex.getSidePoint2D(vertex.getSide());
  }
 else {
    return null;
  }
}","public static Point2D getVertexPoint2D(HexMap map,NetworkVertex vertex){
  GUIHex guiHex=map.getHexByName(vertex.getHex().getName());
  if (vertex.isCityType()) {
    return guiHex.getCityPoint2D(vertex.getCity());
  }
 else   if (vertex.isTownType()) {
    return guiHex.getCenterPoint2D();
  }
 else   if (vertex.isSide()) {
    if (map instanceof EWHexMap)     return guiHex.getSidePoint2D(5 - vertex.getSide());
 else     return guiHex.getSidePoint2D((3 + vertex.getSide()) % 6);
  }
 else {
    return null;
  }
}",0.8872180451127819
173740,"/** 
 * arrives at an unvisited vertex
 */
private void nextVertex(int trainId,int vertexId,int previousId){
  Terminated trainTerminated=Terminated.NotYet;
  boolean valueStation=encounterVertex(trainId,vertexId,true);
  if (valueStation) {
    trainTerminated=trainTerminated(trainId);
    if (trainTerminated == Terminated.WithoutEvaluation || trainTerminated == Terminated.NotYet && useRevenuePrediction && predictRevenues(trainId)) {
      encounterVertex(trainId,vertexId,false);
      returnEdge(trainId);
      return;
    }
  }
  if (trainTerminated == Terminated.NotYet) {
    for (int j=0; j < maxNeighbors; j++) {
      int neighborId=vertexNeighbors[vertexId][j];
      log.debug(""String_Node_Str"" + j + ""String_Node_Str""+ vertexId+ ""String_Node_Str""+ neighborId);
      if (neighborId == -1)       break;
      if (trainVisited[trainId][neighborId]) {
        log.debug(""String_Node_Str"");
        continue;
      }
      if (travelEdge(vertexId,neighborId,edgeGreedy[previousId][vertexId])) {
        nextVertex(trainId,neighborId,vertexId);
      }
    }
    if (valueStation && trainBottomPos[trainId] == 0 && (vertexCity[vertexId] || vertexTown[vertexId])) {
      runBottom(trainId);
    }
  }
  finalizeVertex(trainId,vertexId,valueStation);
  encounterVertex(trainId,vertexId,false);
  returnEdge(trainId);
}","/** 
 * arrives at an unvisited vertex
 */
private void nextVertex(int trainId,int vertexId,int previousId){
  Terminated trainTerminated=Terminated.NotYet;
  boolean valueStation=encounterVertex(trainId,vertexId,true);
  if (valueStation) {
    trainTerminated=trainTerminated(trainId);
    if (trainTerminated == Terminated.WithoutEvaluation || useRevenuePrediction && predictRevenues(trainId)) {
      encounterVertex(trainId,vertexId,false);
      returnEdge(trainId);
      return;
    }
  }
  if (trainTerminated == Terminated.NotYet) {
    for (int j=0; j < maxNeighbors; j++) {
      int neighborId=vertexNeighbors[vertexId][j];
      log.debug(""String_Node_Str"" + j + ""String_Node_Str""+ vertexId+ ""String_Node_Str""+ neighborId);
      if (neighborId == -1)       break;
      if (trainVisited[trainId][neighborId]) {
        log.debug(""String_Node_Str"");
        continue;
      }
      if (travelEdge(vertexId,neighborId,edgeGreedy[previousId][vertexId])) {
        nextVertex(trainId,neighborId,vertexId);
      }
    }
    if (valueStation && trainBottomPos[trainId] == 0 && (vertexCity[vertexId] || vertexTown[vertexId])) {
      runBottom(trainId);
    }
  }
  finalizeVertex(trainId,vertexId,valueStation);
  encounterVertex(trainId,vertexId,false);
  returnEdge(trainId);
}",0.9847211611917496
173741,"private boolean predictRevenues(int trainId){
  int totalValue=0;
  for (int j=0; j <= finalTrain; j++) {
    int trainValue;
    if (j < trainId) {
      trainValue=trainCurrentValue[j];
    }
 else     if (j > trainId) {
      trainValue=maxTrainRevenues[j];
    }
 else {
      if (trainMaxTowns[j] == 0) {
        trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j]] * trainMultiplyCities[j];
      }
 else {
        int townDiff=trainMaxTowns[j] - trainTowns[j];
        if (townDiff > 0) {
          trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j]] * trainMultiplyCities[j] + maxTownRevenues[trainMaxTowns[j] - trainTowns[j]] * trainMultiplyTowns[j];
        }
 else         if (townDiff == 0) {
          trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j]] * trainMultiplyCities[j];
        }
 else {
          trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j] + townDiff] * trainMultiplyCities[j];
        }
      }
      trainValue=Math.min(trainValue,maxTrainRevenues[j]);
    }
    log.debug(""String_Node_Str"" + j + ""String_Node_Str""+ trainValue);
    totalValue+=trainValue;
  }
  nbPredictions++;
  boolean terminate=(totalValue <= currentBestValue);
  if (terminate)   log.debug(""String_Node_Str"" + totalValue);
  return terminate;
}","private boolean predictRevenues(int trainId){
  int totalValue=0;
  for (int j=0; j <= finalTrain; j++) {
    int trainValue;
    if (j < trainId) {
      trainValue=trainCurrentValue[j];
    }
 else     if (j > trainId) {
      trainValue=maxTrainRevenues[j];
    }
 else {
      if (trainIgnoreTowns[j]) {
        trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j]] * trainMultiplyCities[j];
      }
 else       if (trainMaxTowns[j] == 0) {
        trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j] - trainTowns[j]] * trainMultiplyCities[j];
      }
 else {
        int townDiff=trainMaxTowns[j] - trainTowns[j];
        if (townDiff > 0) {
          trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j]] * trainMultiplyCities[j] + maxTownRevenues[trainMaxTowns[j] - trainTowns[j]] * trainMultiplyTowns[j];
        }
 else         if (townDiff == 0) {
          trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j]] * trainMultiplyCities[j];
        }
 else {
          trainValue=trainCurrentValue[j] + maxCityRevenues[trainMaxCities[j] - trainCities[j] + townDiff] * trainMultiplyCities[j];
        }
      }
      trainValue=Math.min(trainValue,maxTrainRevenues[j]);
    }
    log.debug(""String_Node_Str"" + j + ""String_Node_Str""+ trainValue);
    totalValue+=trainValue;
  }
  nbPredictions++;
  boolean terminate=(totalValue <= currentBestValue);
  if (terminate)   log.debug(""String_Node_Str"" + totalValue);
  return terminate;
}",0.9380710659898476
173742,"private void runTrain(int trainId){
  log.debug(""String_Node_Str"" + trainId);
  trainStackPos[trainId]=0;
  trainBottomPos[trainId]=0;
  for (int i=0; i < startVertexes.length; i++) {
    int vertexId=startVertexes[i];
    log.debug(""String_Node_Str"" + i + ""String_Node_Str""+ trainId);
    Terminated trainTerminated=Terminated.NotYet;
    boolean valueStation=encounterVertex(trainId,vertexId,true);
    if (valueStation) {
      trainTerminated=trainTerminated(trainId);
      if (trainTerminated == Terminated.WithoutEvaluation || trainTerminated == Terminated.NotYet && useRevenuePrediction && predictRevenues(trainId)) {
        encounterVertex(trainId,vertexId,false);
        log.debug(""String_Node_Str"" + vertexId + ""String_Node_Str""+ trainId);
        continue;
      }
    }
    if (trainTerminated == Terminated.NotYet) {
      for (int j=0; j < maxNeighbors; j++) {
        int neighborId=vertexNeighbors[vertexId][j];
        log.debug(""String_Node_Str"" + j + ""String_Node_Str""+ neighborId);
        if (neighborId == -1)         break;
        if (travelEdge(vertexId,neighborId,true)) {
          trainStartEdge[trainId]=j;
          nextVertex(trainId,neighborId,vertexId);
        }
      }
    }
    finalizeVertex(trainId,vertexId,valueStation);
    encounterVertex(trainId,vertexId,false);
    log.debug(""String_Node_Str"" + vertexId + ""String_Node_Str""+ trainId);
  }
  log.debug(""String_Node_Str"" + trainId);
}","private void runTrain(int trainId){
  log.debug(""String_Node_Str"" + trainId);
  trainStackPos[trainId]=0;
  trainBottomPos[trainId]=0;
  for (int i=0; i < startVertexes.length; i++) {
    int vertexId=startVertexes[i];
    log.debug(""String_Node_Str"" + i + ""String_Node_Str""+ trainId);
    Terminated trainTerminated=Terminated.NotYet;
    boolean valueStation=encounterVertex(trainId,vertexId,true);
    if (valueStation) {
      trainTerminated=trainTerminated(trainId);
      if (trainTerminated == Terminated.WithoutEvaluation || useRevenuePrediction && predictRevenues(trainId)) {
        encounterVertex(trainId,vertexId,false);
        log.debug(""String_Node_Str"" + vertexId + ""String_Node_Str""+ trainId);
        continue;
      }
    }
    if (trainTerminated == Terminated.NotYet) {
      for (int j=0; j < maxNeighbors; j++) {
        int neighborId=vertexNeighbors[vertexId][j];
        log.debug(""String_Node_Str"" + j + ""String_Node_Str""+ neighborId);
        if (neighborId == -1)         break;
        if (travelEdge(vertexId,neighborId,true)) {
          trainStartEdge[trainId]=j;
          nextVertex(trainId,neighborId,vertexId);
        }
      }
    }
    finalizeVertex(trainId,vertexId,valueStation);
    encounterVertex(trainId,vertexId,false);
    log.debug(""String_Node_Str"" + vertexId + ""String_Node_Str""+ trainId);
  }
  log.debug(""String_Node_Str"" + trainId);
}",0.9858256555634302
173743,"public Point2D getSidePoint2D(int side){
  side=(5 - side);
  return new Point2D.Double((xVertex[side] + xVertex[(side + 1) % 6]) / 2,(yVertex[side] + yVertex[(side + 1) % 6]) / 2);
}","public Point2D getSidePoint2D(int side){
  return new Point2D.Double((xVertex[side] + xVertex[(side + 1) % 6]) / 2,(yVertex[side] + yVertex[(side + 1) % 6]) / 2);
}",0.9452449567723344
173744,"/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(String playerName){
  String errMsg=null;
  Player player=getCurrentPlayer();
  StartItem auctionItem=(StartItem)auctionItemState.getObject();
  while (true) {
    if (!playerName.equals(player.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getName());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName));
  moveStack.start(false);
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.intValue() >= auctionItem.getBidders() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getName());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
    }
 else {
      if (GameOption.OPTION_VALUE_YES.equalsIgnoreCase(getGameOption(""String_Node_Str""))) {
        auctionItem.setBid(-1,player);
      }
      setNextBiddingPlayer(auctionItem,getCurrentPlayerIndex());
    }
  }
 else {
    if (numPasses.intValue() >= numPlayers) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str""));
      if (startPacket.getFirstUnsoldItem() == startPacket.getFirstItem()) {
        startPacket.getFirstItem().reduceBasePriceBy(5);
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",startPacket.getFirstItem().getName(),Bank.format(startPacket.getFirstItem().getBasePrice())));
        numPasses.set(0);
        if (startPacket.getFirstItem().getBasePrice() == 0) {
          assignItem(getCurrentPlayer(),startPacket.getFirstItem(),0,0);
          gameManager.setPriorityPlayer();
        }
      }
 else {
        numPasses.set(0);
        finishRound();
      }
    }
 else     if (auctionItem != null) {
      setNextBiddingPlayer(auctionItem);
    }
 else {
      setNextPlayer();
    }
  }
  return true;
}","/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(String playerName){
  String errMsg=null;
  Player player=getCurrentPlayer();
  StartItem auctionItem=(StartItem)auctionItemState.getObject();
  while (true) {
    if (!playerName.equals(player.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName,player.getName());
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName));
  moveStack.start(false);
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.intValue() >= auctionItem.getBidders() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getName());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
      setPriorityPlayer();
    }
 else {
      if (GameOption.OPTION_VALUE_YES.equalsIgnoreCase(getGameOption(""String_Node_Str""))) {
        auctionItem.setBid(-1,player);
      }
      setNextBiddingPlayer(auctionItem,getCurrentPlayerIndex());
    }
  }
 else {
    if (numPasses.intValue() >= numPlayers) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str""));
      if (startPacket.getFirstUnsoldItem() == startPacket.getFirstItem()) {
        startPacket.getFirstItem().reduceBasePriceBy(5);
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",startPacket.getFirstItem().getName(),Bank.format(startPacket.getFirstItem().getBasePrice())));
        numPasses.set(0);
        if (startPacket.getFirstItem().getBasePrice() == 0) {
          assignItem(getCurrentPlayer(),startPacket.getFirstItem(),0,0);
          gameManager.setPriorityPlayer();
        }
      }
 else {
        numPasses.set(0);
        finishRound();
      }
    }
 else     if (auctionItem != null) {
      setNextBiddingPlayer(auctionItem);
    }
 else {
      setNextPlayer();
    }
  }
  return true;
}",0.99400399733511
173745,"/** 
 * Check if a company must be floated, and if so, do it. <p>This method is included here because it is used in various types of Round.
 * @param company
 */
protected void checkFlotation(PublicCompanyI company){
  if (!company.hasStarted() || company.hasFloated())   return;
  int unsoldPercentage=company.getUnsoldPercentage();
  if (unsoldPercentage <= 100 - company.getFloatPercentage()) {
    floatCompany(company);
  }
}","/** 
 * Check if a company must be floated, and if so, do it. <p>This method is included here because it is used in various types of Round.
 * @param company
 */
protected void checkFlotation(PublicCompanyI company){
  if (!company.hasStarted() || company.hasFloated())   return;
  if (getSoldPercentage(company) >= company.getFloatPercentage()) {
    floatCompany(company);
  }
}",0.8074074074074075
173746,"/** 
 * Float a company, including a default implementation of moving cash and shares as a result of flotation. <p>Full capitalisation is implemented as in 1830. Partial capitalisation is implemented as in 1851. Other ways to process the consequences of company flotation must be handled in game-specific subclasses.
 */
protected void floatCompany(PublicCompanyI company){
  int unsoldPercentage=company.getUnsoldPercentage();
  int cash=0;
  int capitalisationMode=company.getCapitalisation();
  if (company.hasStockPrice()) {
    int capFactor=0;
    int shareUnit=company.getShareUnit();
    if (capitalisationMode == PublicCompanyI.CAPITALISE_FULL) {
      capFactor=100 / shareUnit;
    }
 else     if (capitalisationMode == PublicCompanyI.CAPITALISE_INCREMENTAL) {
      capFactor=(100 - unsoldPercentage) / shareUnit;
    }
 else     if (capitalisationMode == PublicCompanyI.CAPITALISE_WHEN_BOUGHT) {
      capFactor=0;
    }
    int price=company.getIPOPrice();
    cash=capFactor * price;
  }
 else {
    cash=company.getFixedPrice();
  }
  cash-=company.getBaseTokensBuyCost();
  company.setFloated();
  if (cash > 0) {
    new CashMove(bank,company,cash);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getName(),Bank.format(cash)));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getName()));
  }
  if (capitalisationMode == PublicCompanyI.CAPITALISE_INCREMENTAL && company.canHoldOwnShares()) {
    List<Certificate> moving=new ArrayList<Certificate>();
    for (    Certificate ipoCert : ipo.getCertificatesPerCompany(company.getName())) {
      moving.add(ipoCert);
    }
    for (    Certificate ipoCert : moving) {
      ipoCert.moveTo(company.getPortfolio());
    }
  }
}","/** 
 * Float a company, including a default implementation of moving cash and shares as a result of flotation. <p>Full capitalisation is implemented as in 1830. Partial capitalisation is implemented as in 1851. Other ways to process the consequences of company flotation must be handled in game-specific subclasses.
 */
protected void floatCompany(PublicCompanyI company){
  int soldPercentage=getSoldPercentage(company);
  int cash=0;
  int capitalisationMode=company.getCapitalisation();
  if (company.hasStockPrice()) {
    int capFactor=0;
    int shareUnit=company.getShareUnit();
    if (capitalisationMode == PublicCompanyI.CAPITALISE_FULL) {
      capFactor=100 / shareUnit;
    }
 else     if (capitalisationMode == PublicCompanyI.CAPITALISE_INCREMENTAL) {
      capFactor=soldPercentage / shareUnit;
    }
 else     if (capitalisationMode == PublicCompanyI.CAPITALISE_WHEN_BOUGHT) {
      capFactor=0;
    }
    int price=company.getIPOPrice();
    cash=capFactor * price;
  }
 else {
    cash=company.getFixedPrice();
  }
  cash-=company.getBaseTokensBuyCost();
  company.setFloated();
  if (cash > 0) {
    new CashMove(bank,company,cash);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getName(),Bank.format(cash)));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",company.getName()));
  }
  if (capitalisationMode == PublicCompanyI.CAPITALISE_INCREMENTAL && company.canHoldOwnShares()) {
    List<Certificate> moving=new ArrayList<Certificate>();
    for (    Certificate ipoCert : ipo.getCertificatesPerCompany(company.getName())) {
      moving.add(ipoCert);
    }
    for (    Certificate ipoCert : moving) {
      ipoCert.moveTo(company.getPortfolio());
    }
  }
}",0.9644611383993066
173747,"/** 
 * Implements special rules for first time operating in 1856
 */
@Override protected boolean setNextOperatingCompany(boolean initial){
  if (operatingCompanyIndexObject == null) {
    operatingCompanyIndexObject=new IntegerState(""String_Node_Str"");
  }
  while (true) {
    if (initial) {
      operatingCompanyIndexObject.set(0);
      initial=false;
    }
 else {
      operatingCompanyIndexObject.add(1);
    }
    int operatingCompanyIndex=operatingCompanyIndexObject.intValue();
    if (operatingCompanyIndex >= operatingCompanyArray.length) {
      return false;
    }
 else {
      operatingCompany=operatingCompanyArray[operatingCompanyIndex];
      if (operatingCompany instanceof PublicCompany_CGR)       return true;
      if (operatingCompany.isClosed())       continue;
      if (!operatingCompany.hasOperated()) {
        int soldPercentage=100 - operatingCompany.getUnsoldPercentage();
        TrainI nextAvailableTrain=gameManager.getTrainManager().getAvailableNewTrains().get(0);
        int trainNumber;
        try {
          trainNumber=Integer.parseInt(nextAvailableTrain.getName());
        }
 catch (        NumberFormatException e) {
          trainNumber=6;
        }
        int floatPercentage=10 * trainNumber;
        log.debug(""String_Node_Str"" + floatPercentage + ""String_Node_Str""+ soldPercentage);
        if (soldPercentage < floatPercentage) {
          DisplayBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.getName(),String.valueOf(soldPercentage),String.valueOf(floatPercentage)));
          continue;
        }
      }
      return true;
    }
  }
}","/** 
 * Implements special rules for first time operating in 1856
 */
@Override protected boolean setNextOperatingCompany(boolean initial){
  if (operatingCompanyIndexObject == null) {
    operatingCompanyIndexObject=new IntegerState(""String_Node_Str"");
  }
  while (true) {
    if (initial) {
      operatingCompanyIndexObject.set(0);
      initial=false;
    }
 else {
      operatingCompanyIndexObject.add(1);
    }
    int operatingCompanyIndex=operatingCompanyIndexObject.intValue();
    if (operatingCompanyIndex >= operatingCompanyArray.length) {
      return false;
    }
 else {
      operatingCompany=operatingCompanyArray[operatingCompanyIndex];
      if (operatingCompany instanceof PublicCompany_CGR)       return true;
      if (operatingCompany.isClosed())       continue;
      if (!operatingCompany.hasOperated()) {
        int soldPercentage=getSoldPercentage(operatingCompany);
        TrainI nextAvailableTrain=gameManager.getTrainManager().getAvailableNewTrains().get(0);
        int trainNumber;
        try {
          trainNumber=Integer.parseInt(nextAvailableTrain.getName());
        }
 catch (        NumberFormatException e) {
          trainNumber=6;
        }
        int floatPercentage=10 * trainNumber;
        log.debug(""String_Node_Str"" + floatPercentage + ""String_Node_Str""+ soldPercentage);
        if (soldPercentage < floatPercentage) {
          DisplayBuffer.add(LocalText.getText(""String_Node_Str"",operatingCompany.getName(),String.valueOf(soldPercentage),String.valueOf(floatPercentage)));
          continue;
        }
      }
      return true;
    }
  }
}",0.9847399563998754
173748,"protected void adjustSharePrice(PublicCompanyI company,int numberSold,boolean soldBefore){
  if (company instanceof PublicCompany_CGR) {
    if (company.canSharePriceVary()) {
      int numberOfSpaces;
      if (company.getShareUnit() == 5) {
        numberOfSpaces=(sharesSoldSoFar.intValue() + numberSold) / 2 - squaresDownSoFar.intValue();
        sharesSoldSoFar.add(numberSold);
        squaresDownSoFar.add(numberOfSpaces);
      }
 else {
        numberOfSpaces=numberSold;
      }
      stockMarket.sell(company,numberOfSpaces);
    }
  }
 else {
    super.adjustSharePrice(company,numberSold,soldBefore);
  }
}","@Override protected void adjustSharePrice(PublicCompanyI company,int numberSold,boolean soldBefore){
  if (company instanceof PublicCompany_CGR) {
    if (company.canSharePriceVary()) {
      int numberOfSpaces;
      if (company.getShareUnit() == 5) {
        numberOfSpaces=(sharesSoldSoFar.intValue() + numberSold) / 2 - squaresDownSoFar.intValue();
        sharesSoldSoFar.add(numberSold);
        squaresDownSoFar.add(numberOfSpaces);
      }
 else {
        numberOfSpaces=numberSold;
      }
      stockMarket.sell(company,numberOfSpaces);
    }
  }
 else {
    super.adjustSharePrice(company,numberSold,soldBefore);
  }
}",0.9919871794871796
173749,"/** 
 * Special 1856 code to check for company flotation.
 * @param company
 */
@Override protected void checkFlotation(PublicCompanyI company){
  if (!company.hasStarted() || company.hasFloated())   return;
  int unsoldPercentage=company.getUnsoldPercentage();
  PublicCompany_1856 comp=(PublicCompany_1856)company;
  int trainNumberAtStart=comp.getTrainNumberAvailableAtStart();
  int floatPercentage=10 * trainNumberAtStart;
  log.debug(""String_Node_Str"" + floatPercentage);
  if (unsoldPercentage <= 100 - floatPercentage) {
    if (!company.hasFloated()) {
      floatCompany(company);
    }
  }
}","/** 
 * Special 1856 code to check for company flotation.
 * @param company
 */
@Override protected void checkFlotation(PublicCompanyI company){
  if (!company.hasStarted() || company.hasFloated())   return;
  int soldPercentage=getSoldPercentage(company);
  PublicCompany_1856 comp=(PublicCompany_1856)company;
  int trainNumberAtStart=comp.getTrainNumberAvailableAtStart();
  int floatPercentage=10 * trainNumberAtStart;
  log.debug(""String_Node_Str"" + floatPercentage);
  if (soldPercentage >= floatPercentage) {
    if (!company.hasFloated()) {
      floatCompany(company);
    }
  }
}",0.945424013434089
173750,"protected void initPlayer(){
  super.initPlayer();
  sharesSoldSoFar.set(0);
  squaresDownSoFar.set(0);
}","@Override protected void initPlayer(){
  super.initPlayer();
  sharesSoldSoFar.set(0);
  squaresDownSoFar.set(0);
}",0.9545454545454546
173751,"@Override protected CashHolder getSharePriceRecipient(PublicCertificateI cert,int cost){
  CashHolder recipient;
  Portfolio oldHolder=(Portfolio)cert.getHolder();
  if (cost != 0 && !cert.getCompany().getName().equalsIgnoreCase(PublicCompany_CGR.NAME) && oldHolder == ipo) {
    PublicCompany_1856 comp=(PublicCompany_1856)(cert).getCompany();
switch (comp.getTrainNumberAvailableAtStart()) {
case 2:
case 3:
case 4:
      if (comp.getUnsoldPercentage() <= 50 && !comp.hasReachedDestination()) {
        recipient=oldHolder.getOwner();
        comp.addMoneyInEscrow(cost);
        ReportBuffer.addWaiting(LocalText.getText(""String_Node_Str"",Bank.format(cost),Bank.format(comp.getMoneyInEscrow()),comp.getName()));
        break;
      }
case 5:
    recipient=(cert).getCompany();
  break;
case 6:
default :
recipient=oldHolder.getOwner();
}
}
 else {
recipient=oldHolder.getOwner();
}
return recipient;
}","@Override protected CashHolder getSharePriceRecipient(PublicCertificateI cert,int cost){
  CashHolder recipient;
  Portfolio oldHolder=(Portfolio)cert.getHolder();
  if (cost != 0 && !cert.getCompany().getName().equalsIgnoreCase(PublicCompany_CGR.NAME) && oldHolder == ipo) {
    PublicCompany_1856 comp=(PublicCompany_1856)(cert).getCompany();
switch (comp.getTrainNumberAvailableAtStart()) {
case 2:
case 3:
case 4:
      if (getSoldPercentage(comp) >= 50 && !comp.hasReachedDestination()) {
        recipient=bank;
        comp.addMoneyInEscrow(cost);
        ReportBuffer.addWaiting(LocalText.getText(""String_Node_Str"",Bank.format(cost),Bank.format(comp.getMoneyInEscrow()),comp.getName()));
        break;
      }
case 5:
    recipient=comp;
  break;
case 6:
default :
recipient=bank;
}
}
 else {
recipient=oldHolder.getOwner();
}
return recipient;
}",0.8977272727272727
173752,"@Override protected void scaleHexesGUI(){
  hexArray=mapManager.getHexes();
  GUIHex hex;
  int ii, jj;
  for (int i=minX; i < hexArray.length; i++) {
    ii=i - minX + 1;
    for (int j=minY; j < hexArray[0].length; j++) {
      jj=j - minY + 1;
      hex=h[i][j];
      if (hex != null) {
        hex.scaleHex(cx + scale * ((GUIHex.SQRT3 * ii) + (GUIHex.SQRT3 / 2 * (jj & 1))),cy + jj * 1.5 * scale,scale,zoomFactor);
      }
    }
  }
  setSize();
}","@Override protected void scaleHexesGUI(){
  hexArray=mapManager.getHexes();
  GUIHex hex;
  int ii, jj;
  for (int i=minX; i < hexArray.length; i++) {
    ii=i - minX + 1;
    for (int j=minY; j < hexArray[0].length; j++) {
      jj=j - minY + 1;
      hex=h[i][j];
      if (hex != null) {
        hex.scaleHex(cx + scale * ((GUIHex.SQRT3 * ii) + (GUIHex.SQRT3 / 2 * (j & 1))),cy + jj * 1.5 * scale,scale,zoomFactor);
      }
    }
  }
  setSize();
}",0.9988925802879292
173753,"/** 
 * Add an object.
 * @param object The object to add.
 * @return True if successful.
 */
public boolean addObject(Moveable object){
  if (object instanceof SpecialPropertyI) {
    return addSpecialProperty((SpecialPropertyI)object);
  }
 else {
    return false;
  }
}","/** 
 * Add an object.
 * @param object The object to add.
 * @return True if successful.
 */
public boolean addObject(Moveable object){
  if (object instanceof SpecialPropertyI) {
    SpecialPropertyI sp=(SpecialPropertyI)object;
    sp.setHolder(null);
    return addSpecialProperty(sp);
  }
 else {
    return false;
  }
}",0.7959866220735786
173754,"/** 
 * Make a full list of trains, like ""2 2 3 3"", to show in any field describing train possessions, except the IPO.
 * @param holder The Portfolio for which this list will be made.
 */
public String makeFullListOfTrains(){
  if (trains == null || trains.isEmpty())   return ""String_Node_Str"";
  List<TrainI> trainsOfType;
  StringBuffer b=new StringBuffer();
  for (  TrainTypeI type : GameManager.getInstance().getTrainManager().getTrainTypes()) {
    trainsOfType=trainsPerType.get(type);
    if (trainsOfType != null && !trainsOfType.isEmpty()) {
      for (      TrainI train : trainsOfType) {
        if (b.length() > 0)         b.append(""String_Node_Str"");
        b.append(train.getName());
      }
    }
  }
  return b.toString();
}","/** 
 * Make a full list of trains, like ""2 2 3 3"", to show in any field describing train possessions, except the IPO.
 */
public String makeFullListOfTrains(){
  if (trains == null || trains.isEmpty())   return ""String_Node_Str"";
  List<TrainI> trainsOfType;
  StringBuffer b=new StringBuffer();
  for (  TrainTypeI type : GameManager.getInstance().getTrainManager().getTrainTypes()) {
    trainsOfType=trainsPerType.get(type);
    if (trainsOfType != null && !trainsOfType.isEmpty()) {
      for (      TrainI train : trainsOfType) {
        if (b.length() > 0)         b.append(""String_Node_Str"");
        b.append(train.getName());
      }
    }
  }
  return b.toString();
}",0.9542575650950036
173755,"/** 
 * Add a special property. Used to make special properties independent of the private company that originally held it.
 * @param property The special property object to add.
 * @return True if successful.
 */
public boolean addSpecialProperty(SpecialPropertyI property){
  boolean result=false;
  if (specialProperties == null) {
    specialProperties=new ArrayList<SpecialPropertyI>(2);
  }
  result=specialProperties.add(property);
  if (owner instanceof PublicCompanyI && property instanceof LocatedBonus) {
    PublicCompanyI company=(PublicCompanyI)owner;
    LocatedBonus locBonus=(LocatedBonus)property;
    Bonus bonus=new Bonus(company,locBonus.getName(),locBonus.getValue(),locBonus.getLocations());
    company.addBonus(bonus);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",owner.getName(),locBonus.getName(),Bank.format(locBonus.getValue()),locBonus.getLocationNameString()));
  }
  return result;
}","/** 
 * Add a special property. Used to make special properties independent of the private company that originally held it.
 * @param property The special property object to add.
 * @return True if successful.
 */
public boolean addSpecialProperty(SpecialPropertyI property){
  boolean result=false;
  if (specialProperties == null) {
    specialProperties=new ArrayList<SpecialPropertyI>(2);
  }
  result=specialProperties.add(property);
  property.setHolder(this);
  if (owner instanceof PublicCompanyI && property instanceof LocatedBonus) {
    PublicCompanyI company=(PublicCompanyI)owner;
    LocatedBonus locBonus=(LocatedBonus)property;
    Bonus bonus=new Bonus(company,locBonus.getName(),locBonus.getValue(),locBonus.getLocations());
    company.addBonus(bonus);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",owner.getName(),locBonus.getName(),Bank.format(locBonus.getValue()),locBonus.getLocationNameString()));
  }
  return result;
}",0.9851222104144528
173756,"/** 
 * Make an abbreviated list of trains, like ""2(6) 3(5)"" etc, to show in the IPO.
 * @param holder The Portfolio for which this list will be made (alwaysIPO).
 */
public String makeAbbreviatedListOfTrains(){
  if (trains == null || trains.isEmpty())   return ""String_Node_Str"";
  StringBuffer b=new StringBuffer();
  List<TrainI> trainsOfType;
  for (  TrainTypeI type : GameManager.getInstance().getTrainManager().getTrainTypes()) {
    trainsOfType=trainsPerType.get(type);
    if (trainsOfType != null && !trainsOfType.isEmpty()) {
      if (b.length() > 0)       b.append(""String_Node_Str"");
      b.append(type.getName()).append(""String_Node_Str"");
      if (type.hasInfiniteAmount()) {
        b.append(""String_Node_Str"");
      }
 else {
        b.append(trainsOfType.size());
      }
      b.append(""String_Node_Str"");
    }
  }
  return b.toString();
}","/** 
 * Make an abbreviated list of trains, like ""2(6) 3(5)"" etc, to show in the IPO.
 */
public String makeAbbreviatedListOfTrains(){
  if (trains == null || trains.isEmpty())   return ""String_Node_Str"";
  StringBuffer b=new StringBuffer();
  List<TrainI> trainsOfType;
  for (  TrainTypeI type : GameManager.getInstance().getTrainManager().getTrainTypes()) {
    trainsOfType=trainsPerType.get(type);
    if (trainsOfType != null && !trainsOfType.isEmpty()) {
      if (b.length() > 0)       b.append(""String_Node_Str"");
      b.append(type.getName()).append(""String_Node_Str"");
      if (type.hasInfiniteAmount()) {
        b.append(""String_Node_Str"");
      }
 else {
        b.append(trainsOfType.size());
      }
      b.append(""String_Node_Str"");
    }
  }
  return b.toString();
}",0.9534180278281912
173757,"public boolean isExecutionable(){
  return holder instanceof Player;
}","public boolean isExecutionable(){
  return originalCompany.getPortfolio().getOwner() instanceof Player;
}",0.7771428571428571
173758,"@Override public boolean undo(){
  stockMarket.processMove(company,to,from);
  return true;
}","@Override public boolean undo(){
  stockMarket.processMoveToStackPosition(company,to,from,fromStackPosition);
  return true;
}",0.8493150684931506
173759,"@Override public String toString(){
  return ""String_Node_Str"" + company.getName() + ""String_Node_Str""+ from+ ""String_Node_Str""+ to;
}","@Override public String toString(){
  return ""String_Node_Str"" + company.getName() + ""String_Node_Str""+ from+ ""String_Node_Str""+ fromStackPosition+ ""String_Node_Str""+ to;
}",0.8758169934640523
173760,"public PriceTokenMove(PublicCompanyI company,StockSpaceI from,StockSpaceI to,StockMarketI stockMarket){
  this.company=company;
  this.from=from;
  this.to=to;
  this.stockMarket=stockMarket;
  MoveSet.add(this);
}","public PriceTokenMove(PublicCompanyI company,StockSpaceI from,StockSpaceI to,StockMarketI stockMarket){
  this.company=company;
  this.from=from;
  this.to=to;
  if (from != null)   fromStackPosition=from.getStackPosition(company);
 else   fromStackPosition=0;
  this.stockMarket=stockMarket;
  MoveSet.add(this);
}",0.8090737240075614
173761,"/** 
 * @return Returns the isBlocked.
 */
public boolean isBlocked(){
  return isBlocked;
}","/** 
 * @return Returns the isBlocked.
 */
public boolean isBlocked(){
  if (isBlockedState == null)   return false;
 else   return isBlockedState.booleanValue();
}",0.71875
173762,"/** 
 * @param isBlocked The isBlocked to set.
 */
public void setBlocked(boolean isBlocked){
  this.isBlocked=isBlocked;
}","/** 
 * @param isBlocked The isBlocked to set (state variable)
 */
public void setBlocked(boolean isBlocked){
  if (isBlockedState == null)   isBlockedState=new BooleanState(""String_Node_Str"",isBlocked);
 else   isBlockedState.set(isBlocked);
}",0.5395095367847411
173763,"public boolean isUpgradeableNow(){
  if (isBlocked) {
    log.debug(""String_Node_Str"" + name + ""String_Node_Str"");
    return false;
  }
  if (currentTile != null) {
    if (currentTile.isUpgradeable()) {
      return true;
    }
 else {
      log.debug(""String_Node_Str"" + name + ""String_Node_Str""+ currentTile.getId()+ ""String_Node_Str"");
      return false;
    }
  }
  log.debug(""String_Node_Str"" + name);
  return false;
}","public boolean isUpgradeableNow(){
  if (isBlocked()) {
    log.debug(""String_Node_Str"" + name + ""String_Node_Str"");
    return false;
  }
  if (currentTile != null) {
    if (currentTile.isUpgradeable()) {
      return true;
    }
 else {
      log.debug(""String_Node_Str"" + name + ""String_Node_Str""+ currentTile.getId()+ ""String_Node_Str"");
      return false;
    }
  }
  log.debug(""String_Node_Str"" + name);
  return false;
}",0.9976635514018692
173764,"@Override public boolean setPossibleActions(){
  boolean passAllowed=false;
  setSellableShares();
  if (isPlayerOverLimits(currentPlayer))   return true;
  passAllowed=true;
  setBuyableCerts();
  setSpecialActions();
  setGameSpecificActions();
  if (passAllowed) {
    if (hasActed.booleanValue()) {
      possibleActions.add(new NullAction(NullAction.DONE));
    }
 else {
      possibleActions.add(new NullAction(NullAction.PASS));
      possibleActions.add(new NullAction(NullAction.AUTOPASS));
    }
  }
  if (getAutopasses() != null) {
    for (    Player player : getAutopasses()) {
      possibleActions.add(new RequestTurn(player));
    }
  }
  return true;
}","@Override public boolean setPossibleActions(){
  currentPlayer=getCurrentPlayer();
  boolean passAllowed=false;
  setSellableShares();
  if (isPlayerOverLimits(currentPlayer))   return true;
  passAllowed=true;
  setBuyableCerts();
  setSpecialActions();
  setGameSpecificActions();
  if (passAllowed) {
    if (hasActed.booleanValue()) {
      possibleActions.add(new NullAction(NullAction.DONE));
    }
 else {
      possibleActions.add(new NullAction(NullAction.PASS));
      possibleActions.add(new NullAction(NullAction.AUTOPASS));
    }
  }
  if (getAutopasses() != null) {
    for (    Player player : getAutopasses()) {
      possibleActions.add(new RequestTurn(player));
    }
  }
  return true;
}",0.9738372093023256
173765,"protected void setNormalTileLays(){
  currentNormalTileLays.clear();
  if (!tileLaysPerColour.isEmpty()) {
    currentNormalTileLays.add(new LayTile(tileLaysPerColour));
  }
}","protected void setNormalTileLays(){
  currentNormalTileLays.clear();
  Map<String,Integer> tileLaysPerColour=(Map<String,Integer>)(tileLaysPerColourState.getObject());
  if (!tileLaysPerColour.isEmpty()) {
    currentNormalTileLays.add(new LayTile(tileLaysPerColour));
  }
}",0.779510022271715
173766,"/** 
 * Create a List of allowed normal tile lays (see LayTile class). This method should be called only once per company turn in an OR: at the start of the tile laying step.
 */
protected void getNormalTileLays(){
  tileLaysPerColour=new HashMap<String,Integer>(getCurrentPhase().getTileColours());
  int allowedNumber;
  for (  String colour : tileLaysPerColour.keySet()) {
    allowedNumber=operatingCompany.getNumberOfTileLays(colour);
    tileLaysPerColour.put(colour,new Integer(allowedNumber));
  }
}","/** 
 * Create a List of allowed normal tile lays (see LayTile class). This method should be called only once per company turn in an OR: at the start of the tile laying step.
 */
protected void getNormalTileLays(){
  Map<String,Integer> tileLaysPerColour=new HashMap<String,Integer>(getCurrentPhase().getTileColours());
  int allowedNumber;
  for (  String colour : tileLaysPerColour.keySet()) {
    allowedNumber=operatingCompany.getNumberOfTileLays(colour);
    tileLaysPerColour.put(colour,new Integer(allowedNumber));
  }
  tileLaysPerColourState=new GenericState<Map<String,Integer>>(""String_Node_Str"",tileLaysPerColour);
}",0.8933920704845815
173767,"/** 
 * To be called after each change, to re-establish the currently allowed actions. (new method, intended to absorb code from several other methods).
 */
@Override public boolean setPossibleActions(){
  int operatingCompanyIndex=operatingCompanyIndexObject.intValue();
  operatingCompany=operatingCompanyArray[operatingCompanyIndex];
  possibleActions.clear();
  selectedAction=null;
  boolean forced=false;
  if (getStep() == GameDef.OrStep.INITIAL) {
    initTurn();
    if (noMapMode) {
      nextStep(GameDef.OrStep.LAY_TOKEN);
    }
 else {
      setStep(GameDef.OrStep.LAY_TRACK);
    }
  }
  GameDef.OrStep step=getStep();
  if (step == GameDef.OrStep.LAY_TRACK) {
    if (!operatingCompany.hasLaidHomeBaseTokens()) {
      possibleActions.add(new LayBaseToken(operatingCompany.getHomeHex()));
      forced=true;
    }
 else {
      setNormalTileLays();
      setSpecialTileLays();
      log.debug(""String_Node_Str"" + currentNormalTileLays.size());
      log.debug(""String_Node_Str"" + currentSpecialTileLays.size());
      possibleActions.addAll(currentNormalTileLays);
      possibleActions.addAll(currentSpecialTileLays);
      possibleActions.add(new NullAction(NullAction.SKIP));
    }
  }
 else   if (step == GameDef.OrStep.LAY_TOKEN) {
    setNormalTokenLays();
    setSpecialTokenLays();
    log.debug(""String_Node_Str"" + currentNormalTokenLays.size());
    log.debug(""String_Node_Str"" + currentSpecialTokenLays.size());
    possibleActions.addAll(currentNormalTokenLays);
    possibleActions.addAll(currentSpecialTokenLays);
    possibleActions.add(new NullAction(NullAction.SKIP));
  }
 else   if (step == GameDef.OrStep.CALC_REVENUE) {
    prepareRevenueAndDividendAction();
    if (noMapMode)     prepareNoMapActions();
  }
 else   if (step == GameDef.OrStep.BUY_TRAIN) {
    setBuyableTrains();
    doneAllowed=true;
    if (noMapMode && (operatingCompany.getLastRevenue() == 0))     prepareNoMapActions();
  }
 else   if (step == GameDef.OrStep.DISCARD_TRAINS) {
    forced=true;
    setTrainsToDiscard();
  }
  if (!forced) {
    setBonusTokenLays();
    setDestinationActions();
    setGameSpecificPossibleActions();
    if (getCurrentPhase().isPrivateSellingAllowed()) {
      int currentPlayerIndex=operatingCompany.getPresident().getIndex();
      Player player;
      int minPrice, maxPrice;
      List<Player> players=getPlayers();
      int numberOfPlayers=getNumberOfPlayers();
      for (int i=currentPlayerIndex; i < currentPlayerIndex + numberOfPlayers; i++) {
        player=players.get(i % numberOfPlayers);
        for (        PrivateCompanyI privComp : player.getPortfolio().getPrivateCompanies()) {
          minPrice=(int)(privComp.getBasePrice() * operatingCompany.getLowerPrivatePriceFactor());
          maxPrice=(int)(privComp.getBasePrice() * operatingCompany.getUpperPrivatePriceFactor());
          possibleActions.add(new BuyPrivate(privComp,minPrice,maxPrice));
        }
      }
    }
    if (operatingCompany.canUseSpecialProperties()) {
      List<SpecialPropertyI> commonSP=gameManager.getCommonSpecialProperties();
      if (commonSP != null) {
        SellBonusToken sbt;
        loop:         for (        SpecialPropertyI sp : commonSP) {
          if (sp instanceof SellBonusToken) {
            sbt=(SellBonusToken)sp;
            if (operatingCompany.getBonuses() != null) {
              for (              Bonus bonus : operatingCompany.getBonuses()) {
                if (bonus.getName().equals(sp.getName()))                 continue loop;
              }
            }
            possibleActions.add(new BuyBonusToken(sbt));
          }
        }
      }
      List<SpecialPropertyI> orsps=operatingCompany.getPortfolio().getAllSpecialProperties();
      if (orsps != null) {
        for (        SpecialPropertyI sp : orsps) {
          if (!sp.isExercised() && sp.isUsableIfOwnedByCompany() && sp.isUsableDuringOR()) {
            if (sp instanceof SpecialTokenLay) {
              if (getStep() != GameDef.OrStep.LAY_TOKEN) {
                possibleActions.add(new LayBaseToken((SpecialTokenLay)sp));
              }
            }
 else {
              possibleActions.add(new UseSpecialProperty(sp));
            }
          }
        }
      }
      orsps=getCurrentPlayer().getPortfolio().getAllSpecialProperties();
      if (orsps != null) {
        for (        SpecialPropertyI sp : orsps) {
          if (!sp.isExercised() && sp.isUsableIfOwnedByPlayer() && sp.isUsableDuringOR()) {
            if (sp instanceof SpecialTokenLay) {
              if (getStep() != GameDef.OrStep.LAY_TOKEN) {
                possibleActions.add(new LayBaseToken((SpecialTokenLay)sp));
              }
            }
 else {
              possibleActions.add(new UseSpecialProperty(sp));
            }
          }
        }
      }
    }
  }
  if (doneAllowed) {
    possibleActions.add(new NullAction(NullAction.DONE));
  }
  for (  PossibleAction pa : possibleActions.getList()) {
    try {
      log.debug(operatingCompany.getName() + ""String_Node_Str"" + pa.toString());
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"" + pa.getClass(),e);
    }
  }
  return true;
}","/** 
 * To be called after each change, to re-establish the currently allowed actions. (new method, intended to absorb code from several other methods).
 */
@Override public boolean setPossibleActions(){
  int operatingCompanyIndex=operatingCompanyIndexObject.intValue();
  operatingCompany=operatingCompanyArray[operatingCompanyIndex];
  possibleActions.clear();
  selectedAction=null;
  boolean forced=false;
  if (getStep() == GameDef.OrStep.INITIAL) {
    initTurn();
    if (noMapMode) {
      nextStep(GameDef.OrStep.LAY_TOKEN);
    }
 else {
      getNormalTileLays();
      setStep(GameDef.OrStep.LAY_TRACK);
    }
  }
  GameDef.OrStep step=getStep();
  if (step == GameDef.OrStep.LAY_TRACK) {
    if (!operatingCompany.hasLaidHomeBaseTokens()) {
      possibleActions.add(new LayBaseToken(operatingCompany.getHomeHex()));
      forced=true;
    }
 else {
      setNormalTileLays();
      setSpecialTileLays();
      log.debug(""String_Node_Str"" + currentNormalTileLays.size());
      log.debug(""String_Node_Str"" + currentSpecialTileLays.size());
      possibleActions.addAll(currentNormalTileLays);
      possibleActions.addAll(currentSpecialTileLays);
      possibleActions.add(new NullAction(NullAction.SKIP));
    }
  }
 else   if (step == GameDef.OrStep.LAY_TOKEN) {
    setNormalTokenLays();
    setSpecialTokenLays();
    log.debug(""String_Node_Str"" + currentNormalTokenLays.size());
    log.debug(""String_Node_Str"" + currentSpecialTokenLays.size());
    possibleActions.addAll(currentNormalTokenLays);
    possibleActions.addAll(currentSpecialTokenLays);
    possibleActions.add(new NullAction(NullAction.SKIP));
  }
 else   if (step == GameDef.OrStep.CALC_REVENUE) {
    prepareRevenueAndDividendAction();
    if (noMapMode)     prepareNoMapActions();
  }
 else   if (step == GameDef.OrStep.BUY_TRAIN) {
    setBuyableTrains();
    doneAllowed=true;
    if (noMapMode && (operatingCompany.getLastRevenue() == 0))     prepareNoMapActions();
  }
 else   if (step == GameDef.OrStep.DISCARD_TRAINS) {
    forced=true;
    setTrainsToDiscard();
  }
  if (!forced) {
    setBonusTokenLays();
    setDestinationActions();
    setGameSpecificPossibleActions();
    if (getCurrentPhase().isPrivateSellingAllowed()) {
      int currentPlayerIndex=operatingCompany.getPresident().getIndex();
      Player player;
      int minPrice, maxPrice;
      List<Player> players=getPlayers();
      int numberOfPlayers=getNumberOfPlayers();
      for (int i=currentPlayerIndex; i < currentPlayerIndex + numberOfPlayers; i++) {
        player=players.get(i % numberOfPlayers);
        for (        PrivateCompanyI privComp : player.getPortfolio().getPrivateCompanies()) {
          minPrice=(int)(privComp.getBasePrice() * operatingCompany.getLowerPrivatePriceFactor());
          maxPrice=(int)(privComp.getBasePrice() * operatingCompany.getUpperPrivatePriceFactor());
          possibleActions.add(new BuyPrivate(privComp,minPrice,maxPrice));
        }
      }
    }
    if (operatingCompany.canUseSpecialProperties()) {
      List<SpecialPropertyI> commonSP=gameManager.getCommonSpecialProperties();
      if (commonSP != null) {
        SellBonusToken sbt;
        loop:         for (        SpecialPropertyI sp : commonSP) {
          if (sp instanceof SellBonusToken) {
            sbt=(SellBonusToken)sp;
            if (operatingCompany.getBonuses() != null) {
              for (              Bonus bonus : operatingCompany.getBonuses()) {
                if (bonus.getName().equals(sp.getName()))                 continue loop;
              }
            }
            possibleActions.add(new BuyBonusToken(sbt));
          }
        }
      }
      List<SpecialPropertyI> orsps=operatingCompany.getPortfolio().getAllSpecialProperties();
      if (orsps != null) {
        for (        SpecialPropertyI sp : orsps) {
          if (!sp.isExercised() && sp.isUsableIfOwnedByCompany() && sp.isUsableDuringOR()) {
            if (sp instanceof SpecialTokenLay) {
              if (getStep() != GameDef.OrStep.LAY_TOKEN) {
                possibleActions.add(new LayBaseToken((SpecialTokenLay)sp));
              }
            }
 else {
              possibleActions.add(new UseSpecialProperty(sp));
            }
          }
        }
      }
      orsps=getCurrentPlayer().getPortfolio().getAllSpecialProperties();
      if (orsps != null) {
        for (        SpecialPropertyI sp : orsps) {
          if (!sp.isExercised() && sp.isUsableIfOwnedByPlayer() && sp.isUsableDuringOR()) {
            if (sp instanceof SpecialTokenLay) {
              if (getStep() != GameDef.OrStep.LAY_TOKEN) {
                possibleActions.add(new LayBaseToken((SpecialTokenLay)sp));
              }
            }
 else {
              possibleActions.add(new UseSpecialProperty(sp));
            }
          }
        }
      }
    }
  }
  if (doneAllowed) {
    possibleActions.add(new NullAction(NullAction.DONE));
  }
  for (  PossibleAction pa : possibleActions.getList()) {
    try {
      log.debug(operatingCompany.getName() + ""String_Node_Str"" + pa.toString());
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"" + pa.getClass(),e);
    }
  }
  return true;
}",0.997383467390251
173768,"/** 
 * This method is only called at the start of each step (unlike updateStatus(), which is called after each user action)
 */
protected void prepareStep(){
  GameDef.OrStep step=stepObject.value();
  if (step == GameDef.OrStep.LAY_TRACK) {
    getNormalTileLays();
  }
 else   if (step == GameDef.OrStep.LAY_TOKEN) {
  }
 else {
    currentSpecialProperties=null;
  }
}","/** 
 * This method is only called at the start of each step (unlike updateStatus(), which is called after each user action)
 */
protected void prepareStep(){
  GameDef.OrStep step=stepObject.value();
  if (step == GameDef.OrStep.LAY_TRACK) {
  }
 else   if (step == GameDef.OrStep.LAY_TOKEN) {
  }
 else {
    currentSpecialProperties=null;
  }
}",0.965229485396384
173769,"protected boolean checkNormalTileLay(TileI tile,boolean update){
  if (tileLaysPerColour.isEmpty())   return false;
  String colour=tile.getColourName();
  Integer oldAllowedNumberObject=tileLaysPerColour.get(colour);
  if (oldAllowedNumberObject == null)   return false;
  int oldAllowedNumber=oldAllowedNumberObject.intValue();
  if (oldAllowedNumber <= 0)   return false;
  if (!update)   return true;
  if (oldAllowedNumber <= 1) {
    tileLaysPerColour.clear();
    log.debug(""String_Node_Str"");
    currentNormalTileLays.clear();
  }
 else {
    tileLaysPerColour.clear();
    tileLaysPerColour.put(colour,new Integer(oldAllowedNumber - 1));
    log.debug((oldAllowedNumber - 1) + ""String_Node_Str"" + colour+ ""String_Node_Str"");
  }
  return true;
}","protected boolean checkNormalTileLay(TileI tile,boolean update){
  Map<String,Integer> tileLaysPerColour=tileLaysPerColourState.getObject();
  if (tileLaysPerColour.isEmpty())   return false;
  String colour=tile.getColourName();
  Integer oldAllowedNumberObject=tileLaysPerColour.get(colour);
  if (oldAllowedNumberObject == null)   return false;
  int oldAllowedNumber=oldAllowedNumberObject.intValue();
  if (oldAllowedNumber <= 0)   return false;
  if (!update)   return true;
  Map<String,Integer> tileLaysPerColourUpdated=new HashMap<String,Integer>();
  if (oldAllowedNumber <= 1) {
    log.debug(""String_Node_Str"");
    currentNormalTileLays.clear();
  }
 else {
    tileLaysPerColourUpdated.put(colour,new Integer(oldAllowedNumber - 1));
    log.debug((oldAllowedNumber - 1) + ""String_Node_Str"" + colour+ ""String_Node_Str"");
  }
  tileLaysPerColourState.set(tileLaysPerColourUpdated);
  return true;
}",0.6006006006006006
173770,"public void actionPerformed(ActionEvent arg0){
  if (arg0.getSource().equals(newButton)) {
    startNewGame();
  }
 else   if (arg0.getSource().equals(optionButton)) {
    toggleOptions();
    this.pack();
  }
 else   if (arg0.getSource().equals(loadButton)) {
    String saveDirectory=Config.get(""String_Node_Str"");
    JFileChooser jfc=new JFileChooser();
    jfc.setCurrentDirectory(new File(saveDirectory));
    if (jfc.showOpenDialog(getContentPane()) == JFileChooser.APPROVE_OPTION) {
      File selectedFile=jfc.getSelectedFile();
      String filepath=selectedFile.getPath();
      saveDirectory=selectedFile.getParent();
      if ((game=Game.load(filepath)) == null) {
        JOptionPane.showMessageDialog(this,DisplayBuffer.get(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        return;
      }
 else       if (DisplayBuffer.getSize() > 0) {
        JOptionPane.showMessageDialog(this,DisplayBuffer.get(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
    startGameUIManager(game);
    gameUIManager.setSaveDirectory(saveDirectory);
    gameUIManager.startLoadedGame();
    setVisible(false);
  }
 else   if (arg0.getSource().equals(infoButton)) {
    JOptionPane.showMessageDialog(this,GamesInfo.getDescription(gameName),""String_Node_Str"" + gameName,JOptionPane.INFORMATION_MESSAGE);
  }
 else   if (arg0.getSource().equals(quitButton)) {
    System.exit(0);
  }
 else   if (arg0.getSource().equals(creditsButton)) {
    JOptionPane.showMessageDialog(this,GamesInfo.getCredits(),LocalText.getText(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
  }
 else   if (arg0.getSource().equals(gameNameBox)) {
    gameName=gameNameBox.getSelectedItem().toString().split(""String_Node_Str"")[0];
    fillPlayersPane();
    if (optionsPane.isVisible()) {
      toggleOptions();
      toggleOptions();
    }
    this.pack();
  }
 else   if (arg0.getSource() instanceof JComboBox) {
    JComboBox comboBox=(JComboBox)arg0.getSource();
    String[] boxName=comboBox.getName().split(""String_Node_Str"");
    if (boxName[0].equalsIgnoreCase(""String_Node_Str"")) {
switch (comboBox.getSelectedIndex()) {
case NONE_PLAYER:
        playerNameFields[Integer.parseInt(boxName[1])].setText(""String_Node_Str"");
      playerNameFields[Integer.parseInt(boxName[1])].setEnabled(false);
    break;
case HUMAN_PLAYER:
  playerNameFields[Integer.parseInt(boxName[1])].setEnabled(true);
break;
case AI_PLAYER:
playerNameFields[Integer.parseInt(boxName[1])].setText(""String_Node_Str"");
playerNameFields[Integer.parseInt(boxName[1])].setEnabled(false);
break;
}
}
}
 else if (arg0.getSource().equals(randomizeButton)) {
if (playerNameFields.length > 0) {
List<String> playerList=new ArrayList<String>();
for (int i=0; i < playerNameFields.length; i++) {
if (playerNameFields[i] != null && playerNameFields[i].getText().length() > 0) {
playerList.add(playerNameFields[i].getText());
playerNameFields[i].setText(""String_Node_Str"");
}
}
Collections.shuffle(playerList);
for (int i=0; i < playerList.size(); i++) {
playerNameFields[i].setText(playerList.get(i));
}
}
fillPlayersPane();
}
}","public void actionPerformed(ActionEvent arg0){
  if (arg0.getSource().equals(newButton)) {
    startNewGame();
  }
 else   if (arg0.getSource().equals(optionButton)) {
    toggleOptions();
    this.pack();
  }
 else   if (arg0.getSource().equals(loadButton)) {
    String saveDirectory=Config.get(""String_Node_Str"");
    JFileChooser jfc=new JFileChooser();
    jfc.setCurrentDirectory(new File(saveDirectory));
    if (jfc.showOpenDialog(getContentPane()) == JFileChooser.APPROVE_OPTION) {
      File selectedFile=jfc.getSelectedFile();
      String filepath=selectedFile.getPath();
      saveDirectory=selectedFile.getParent();
      if ((game=Game.load(filepath)) == null) {
        JOptionPane.showMessageDialog(this,DisplayBuffer.get(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        return;
      }
 else       if (DisplayBuffer.getSize() > 0) {
        JOptionPane.showMessageDialog(this,DisplayBuffer.get(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
    startGameUIManager(game);
    gameUIManager.setSaveDirectory(saveDirectory);
    gameUIManager.startLoadedGame();
    setVisible(false);
  }
 else   if (arg0.getSource().equals(infoButton)) {
    JOptionPane.showMessageDialog(this,GamesInfo.getDescription(gameName),""String_Node_Str"" + gameName,JOptionPane.INFORMATION_MESSAGE);
  }
 else   if (arg0.getSource().equals(quitButton)) {
    System.exit(0);
  }
 else   if (arg0.getSource().equals(creditsButton)) {
    JOptionPane.showMessageDialog(this,GamesInfo.getCredits(),LocalText.getText(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
  }
 else   if (arg0.getSource().equals(gameNameBox)) {
    gameName=gameNameBox.getSelectedItem().toString().split(""String_Node_Str"")[0];
    fillPlayersPane();
    if (optionsPane.isVisible()) {
      toggleOptions();
      toggleOptions();
    }
    this.pack();
  }
 else   if (arg0.getSource() instanceof JComboBox) {
    JComboBox comboBox=(JComboBox)arg0.getSource();
    String[] boxName=comboBox.getName().split(""String_Node_Str"");
    if (boxName[0].equalsIgnoreCase(""String_Node_Str"")) {
switch (comboBox.getSelectedIndex()) {
case NONE_PLAYER:
        playerNameFields[Integer.parseInt(boxName[1])].setText(""String_Node_Str"");
      playerNameFields[Integer.parseInt(boxName[1])].setEnabled(false);
    break;
case HUMAN_PLAYER:
  playerNameFields[Integer.parseInt(boxName[1])].setEnabled(true);
break;
case AI_PLAYER:
playerNameFields[Integer.parseInt(boxName[1])].setText(""String_Node_Str"");
playerNameFields[Integer.parseInt(boxName[1])].setEnabled(false);
break;
}
}
}
 else if (arg0.getSource().equals(randomizeButton)) {
if (playerNameFields.length > 0) {
List<String> playerList=new ArrayList<String>();
for (int i=0; i < playerNameFields.length; i++) {
if (playerNameFields[i] != null && playerNameFields[i].getText().length() > 0) {
playerList.add(playerNameFields[i].getText());
playerNameFields[i].setText(""String_Node_Str"");
}
}
Collections.shuffle(playerList);
for (int i=0; i < playerList.size(); i++) {
playerNameFields[i].setText(playerList.get(i));
}
}
}
}",0.9969100666775086
173771,"public void paint(Graphics g){
  Graphics2D g2=(Graphics2D)g;
  if (getAntialias()) {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  }
 else {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
  }
  Color terrainColor=Color.WHITE;
  if (isSelected()) {
    g2.setColor(highlightColor);
    g2.fill(hexagon);
    g2.setColor(terrainColor);
    g2.fill(innerHexagon);
    g2.setColor(Color.black);
    g2.draw(innerHexagon);
  }
  paintOverlay(g2);
  paintStationTokens(g2);
  paintOffStationTokens(g2);
  FontMetrics fontMetrics=g2.getFontMetrics();
  if (getHexModel().getTileCost() > 0) {
    g2.drawString(Bank.format(getHexModel().getTileCost()),rectBound.x + (rectBound.width - fontMetrics.stringWidth(Integer.toString(getHexModel().getTileCost()))) * 3 / 5,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 9 / 15));
  }
  Map<PublicCompanyI,City> homes=getHexModel().getHomes();
  if (homes != null) {
    City city;
    Point p;
    homes:     for (    PublicCompanyI company : homes.keySet()) {
      if (company.isClosed())       continue;
      city=homes.get(company);
      if (city.getTokens() != null) {
        for (        TokenI token : city.getTokens()) {
          if (token instanceof BaseToken && ((BaseToken)token).getCompany() == company) {
            continue homes;
          }
        }
      }
      p=getTokenCenter(1,0,getHexModel().getCities().size(),city.getNumber() - 1);
      drawHome(g2,company,p);
    }
  }
  if (getHexModel().isBlocked()) {
    List<PrivateCompanyI> privates=GameManager.getInstance().getCompanyManager().getAllPrivateCompanies();
    for (    PrivateCompanyI p : privates) {
      List<MapHex> blocked=p.getBlockedHexes();
      if (blocked != null) {
        for (        MapHex hex : blocked) {
          if (getHexModel().equals(hex)) {
            g2.drawString(""String_Node_Str"" + p.getName() + ""String_Node_Str"",rectBound.x + (rectBound.width - fontMetrics.stringWidth(""String_Node_Str"" + p.getName() + ""String_Node_Str"")) * 1 / 2,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 5 / 15));
          }
        }
      }
    }
  }
}","public void paint(Graphics g){
  Graphics2D g2=(Graphics2D)g;
  if (getAntialias()) {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  }
 else {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
  }
  Color terrainColor=Color.WHITE;
  if (isSelected()) {
    g2.setColor(highlightColor);
    g2.fill(hexagon);
    g2.setColor(terrainColor);
    g2.fill(innerHexagon);
    g2.setColor(Color.black);
    g2.draw(innerHexagon);
  }
  paintOverlay(g2);
  paintStationTokens(g2);
  paintOffStationTokens(g2);
  FontMetrics fontMetrics=g2.getFontMetrics();
  if (getHexModel().getTileCost() > 0) {
    g2.drawString(Bank.format(getHexModel().getTileCost()),rectBound.x + (rectBound.width - fontMetrics.stringWidth(Integer.toString(getHexModel().getTileCost()))) * 3 / 5,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 9 / 15));
  }
  Map<PublicCompanyI,City> homes=getHexModel().getHomes();
  if (homes != null) {
    City city;
    Point p;
    homes:     for (    PublicCompanyI company : homes.keySet()) {
      if (company.isClosed())       continue;
      city=homes.get(company);
      if (model.hasTokenOfCompany(company))       continue homes;
      p=getTokenCenter(1,0,getHexModel().getCities().size(),city.getNumber() - 1);
      drawHome(g2,company,p);
    }
  }
  if (getHexModel().isBlocked()) {
    List<PrivateCompanyI> privates=GameManager.getInstance().getCompanyManager().getAllPrivateCompanies();
    for (    PrivateCompanyI p : privates) {
      List<MapHex> blocked=p.getBlockedHexes();
      if (blocked != null) {
        for (        MapHex hex : blocked) {
          if (getHexModel().equals(hex)) {
            g2.drawString(""String_Node_Str"" + p.getName() + ""String_Node_Str"",rectBound.x + (rectBound.width - fontMetrics.stringWidth(""String_Node_Str"" + p.getName() + ""String_Node_Str"")) * 1 / 2,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 5 / 15));
          }
        }
      }
    }
  }
}",0.933993399339934
173772,"public CashHolder getOwner(){
  return train.getOwner();
}","public CashHolder getOwner(){
  return getTrain().getOwner();
}",0.9586776859504132
173773,"public TrainI getTrain(){
  return train;
}","/** 
 * To be used for all usage of train, also within this class.  After reloading the 2nd copy etc. of a train with unlimited quantity,  the train attribute will be null (because readObject() is called and the train is initiated before the actions have been executed - the second train is in this case only created after buying the first one).
 * @return
 */
public TrainI getTrain(){
  if (train == null) {
    train=GameManager.getInstance().getTrainManager().getTrainByUniqueId(trainUniqueId);
  }
  return train;
}",0.1101243339253996
173774,"/** 
 * Deserialize 
 */
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  ObjectInputStream.GetField fields=in.readFields();
  trainUniqueId=(String)fields.get(""String_Node_Str"",trainUniqueId);
  fromName=(String)fields.get(""String_Node_Str"",fromName);
  fixedCost=fields.get(""String_Node_Str"",fixedCost);
  hasNoTrains=fields.get(""String_Node_Str"",hasNoTrains);
  trainsForExchangeUniqueIds=(String[])fields.get(""String_Node_Str"",trainsForExchangeUniqueIds);
  forcedExchange=fields.get(""String_Node_Str"",forcedExchange);
  presidentMustAddCash=fields.get(""String_Node_Str"",presidentMustAddCash);
  presidentMayAddCash=fields.get(""String_Node_Str"",presidentMayAddCash);
  presidentCashToAdd=fields.get(""String_Node_Str"",presidentCashToAdd);
  specialPropertyId=fields.get(""String_Node_Str"",specialPropertyId);
  pricePaid=fields.get(""String_Node_Str"",pricePaid);
  addedCash=fields.get(""String_Node_Str"",addedCash);
  exchangedTrainUniqueId=(String)fields.get(""String_Node_Str"",exchangedTrainUniqueId);
  extraMessage=(String)fields.get(""String_Node_Str"",extraMessage);
  GameManagerI gameManager=GameManager.getInstance();
  TrainManager trainManager=gameManager.getTrainManager();
  train=trainManager.getTrainByUniqueId(trainUniqueId);
  from=gameManager.getPortfolioByName(fromName);
  if (trainsForExchangeUniqueIds != null && trainsForExchangeUniqueIds.length > 0) {
    trainsForExchange=new ArrayList<TrainI>();
    for (int i=0; i < trainsForExchangeUniqueIds.length; i++) {
      trainsForExchange.add(trainManager.getTrainByUniqueId(trainsForExchangeUniqueIds[i]));
    }
  }
  if (specialPropertyId > 0) {
    specialProperty=(SpecialTrainBuy)SpecialProperty.getByUniqueId(specialPropertyId);
  }
  if (Util.hasValue(exchangedTrainUniqueId)) {
    exchangedTrain=trainManager.getTrainByUniqueId(exchangedTrainUniqueId);
  }
}","/** 
 * Deserialize 
 */
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  ObjectInputStream.GetField fields=in.readFields();
  trainUniqueId=(String)fields.get(""String_Node_Str"",trainUniqueId);
  fromName=(String)fields.get(""String_Node_Str"",fromName);
  fixedCost=fields.get(""String_Node_Str"",fixedCost);
  hasNoTrains=fields.get(""String_Node_Str"",hasNoTrains);
  trainsForExchangeUniqueIds=(String[])fields.get(""String_Node_Str"",trainsForExchangeUniqueIds);
  forcedExchange=fields.get(""String_Node_Str"",forcedExchange);
  presidentMustAddCash=fields.get(""String_Node_Str"",presidentMustAddCash);
  presidentMayAddCash=fields.get(""String_Node_Str"",presidentMayAddCash);
  presidentCashToAdd=fields.get(""String_Node_Str"",presidentCashToAdd);
  specialPropertyId=fields.get(""String_Node_Str"",specialPropertyId);
  pricePaid=fields.get(""String_Node_Str"",pricePaid);
  addedCash=fields.get(""String_Node_Str"",addedCash);
  exchangedTrainUniqueId=(String)fields.get(""String_Node_Str"",exchangedTrainUniqueId);
  extraMessage=(String)fields.get(""String_Node_Str"",extraMessage);
  GameManagerI gameManager=GameManager.getInstance();
  TrainManager trainManager=gameManager.getTrainManager();
  train=trainManager.getTrainByUniqueId(trainUniqueId);
  log.debug(""String_Node_Str"" + trainUniqueId + ""String_Node_Str""+ train,new Exception(""String_Node_Str""));
  from=gameManager.getPortfolioByName(fromName);
  if (trainsForExchangeUniqueIds != null && trainsForExchangeUniqueIds.length > 0) {
    trainsForExchange=new ArrayList<TrainI>();
    for (int i=0; i < trainsForExchangeUniqueIds.length; i++) {
      trainsForExchange.add(trainManager.getTrainByUniqueId(trainsForExchangeUniqueIds[i]));
    }
  }
  if (specialPropertyId > 0) {
    specialProperty=(SpecialTrainBuy)SpecialProperty.getByUniqueId(specialPropertyId);
  }
  if (Util.hasValue(exchangedTrainUniqueId)) {
    exchangedTrain=trainManager.getTrainByUniqueId(exchangedTrainUniqueId);
  }
}",0.9721074380165288
173775,"@Override public boolean equals(PossibleAction action){
  if (!(action instanceof BuyTrain))   return false;
  BuyTrain a=(BuyTrain)action;
  return a.train == train && a.from == from && a.fixedCost == fixedCost && a.trainsForExchange == trainsForExchange;
}","@Override public boolean equals(PossibleAction action){
  if (!(action instanceof BuyTrain))   return false;
  BuyTrain a=(BuyTrain)action;
  return a.getTrain() == getTrain() && a.from == from && a.fixedCost == fixedCost && a.trainsForExchange == trainsForExchange;
}",0.9277566539923956
173776,"@Override public String toString(){
  StringBuffer b=new StringBuffer();
  b.append(company.getName());
  b.append(""String_Node_Str"").append(train.getName());
  b.append(""String_Node_Str"").append(from.getName());
  if (fixedCost > 0) {
    b.append(""String_Node_Str"").append(Bank.format(fixedCost));
  }
 else {
    b.append(""String_Node_Str"");
    if (pricePaid > 0)     b.append(""String_Node_Str"").append(Bank.format(pricePaid));
  }
  if (specialProperty != null) {
    b.append(""String_Node_Str"").append(specialProperty.getCompany().getName());
  }
  if (isForExchange()) {
    b.append(forcedExchange ? ""String_Node_Str"" : ""String_Node_Str"");
  }
  if (presidentMustAddCash)   b.append(""String_Node_Str"").append(Bank.format(presidentCashToAdd));
 else   if (presidentMayAddCash)   b.append(""String_Node_Str"").append(Bank.format(presidentCashToAdd));
  if (pricePaid > 0)   b.append(""String_Node_Str"").append(Bank.format(pricePaid));
  return b.toString();
}","@Override public String toString(){
  StringBuffer b=new StringBuffer();
  b.append(company.getName());
  b.append(""String_Node_Str"").append(getTrain().getName());
  b.append(""String_Node_Str"").append(from.getName());
  if (fixedCost > 0) {
    b.append(""String_Node_Str"").append(Bank.format(fixedCost));
  }
 else {
    b.append(""String_Node_Str"");
    if (pricePaid > 0)     b.append(""String_Node_Str"").append(Bank.format(pricePaid));
  }
  if (specialProperty != null) {
    b.append(""String_Node_Str"").append(specialProperty.getCompany().getName());
  }
  if (isForExchange()) {
    b.append(forcedExchange ? ""String_Node_Str"" : ""String_Node_Str"");
  }
  if (presidentMustAddCash)   b.append(""String_Node_Str"").append(Bank.format(presidentCashToAdd));
 else   if (presidentMayAddCash)   b.append(""String_Node_Str"").append(Bank.format(presidentCashToAdd));
  if (pricePaid > 0)   b.append(""String_Node_Str"").append(Bank.format(pricePaid));
  return b.toString();
}",0.9922239502332816
173777,"public Portfolio getHolder(){
  return train.getHolder();
}","public Portfolio getHolder(){
  return getTrain().getHolder();
}",0.959349593495935
173778,"/** 
 * Create a list of certificates that a player may buy in a Stock Round, taking all rules into account.
 * @return List of buyable certificates.
 */
@Override public void setBuyableCerts(){
  if (!mayCurrentPlayerBuyAnything())   return;
  List<PublicCertificateI> certs;
  PublicCertificateI cert;
  PublicCompanyI comp;
  StockSpaceI stockSpace;
  Portfolio from;
  int price;
  int number;
  boolean mustMergeMinor=!phase5Reached;
  List<PublicCompanyI> minors=null;
  List<City> freeStations=null;
  if (mustMergeMinor) {
    minors=new ArrayList<PublicCompanyI>();
    for (    PublicCertificateI c : getCurrentPlayer().getPortfolio().getCertificates()) {
      if (c.getCompany().getTypeName().equalsIgnoreCase(""String_Node_Str"")) {
        minors.add(c.getCompany());
      }
    }
  }
 else {
    freeStations=new ArrayList<City>();
    MapManager map=gameManager.getMapManager();
    for (    City city : map.getCurrentStations()) {
      if (city.getSlots() > city.getTokens().size()) {
        freeStations.add(city);
      }
    }
  }
  int playerCash=currentPlayer.getCash();
  PublicCompanyI companyBoughtThisTurn=(PublicCompanyI)companyBoughtThisTurnWrapper.getObject();
  if (companyBoughtThisTurn == null) {
    from=ipo;
    Map<String,List<PublicCertificateI>> map=from.getCertsPerCompanyMap();
    int shares;
    for (    String compName : map.keySet()) {
      certs=map.get(compName);
      if (certs == null || certs.isEmpty())       continue;
      cert=certs.get(0);
      comp=cert.getCompany();
      if (isSaleRecorded(currentPlayer,comp))       continue;
      if (maxAllowedNumberOfSharesToBuy(currentPlayer,comp,cert.getShare()) < 1)       continue;
      shares=cert.getShares();
      if (!comp.hasStarted()) {
        if (mustMergeMinor) {
          if (minors.isEmpty())           continue;
        }
 else {
          if (freeStations.isEmpty())           continue;
        }
        List<Integer> startPrices=new ArrayList<Integer>();
        for (        int startPrice : stockMarket.getStartPrices()) {
          if (startPrice * shares <= playerCash) {
            startPrices.add(startPrice);
          }
        }
        if (startPrices.size() > 0) {
          int[] prices=new int[startPrices.size()];
          Arrays.sort(prices);
          for (int i=0; i < prices.length; i++) {
            prices[i]=startPrices.get(i);
          }
          StartCompany_18EU action=new StartCompany_18EU(cert,prices);
          if (mustMergeMinor) {
            action.setMinorsToMerge(minors);
          }
 else {
            action.setAvailableHomeStations(freeStations);
          }
          possibleActions.add(action);
        }
      }
 else       if (comp.getMarketPrice() <= playerCash) {
        possibleActions.add(new BuyCertificate(cert,from,comp.getMarketPrice()));
      }
    }
  }
  from=pool;
  Map<String,List<PublicCertificateI>> map=from.getCertsPerCompanyMap();
  for (  String compName : map.keySet()) {
    certs=map.get(compName);
    if (certs == null || certs.isEmpty())     continue;
    cert=certs.get(0);
    comp=cert.getCompany();
    if (isSaleRecorded(currentPlayer,comp))     continue;
    if (maxAllowedNumberOfSharesToBuy(currentPlayer,comp,cert.getShare()) < 1)     continue;
    price=comp.getMarketPrice();
    if (companyBoughtThisTurn != null) {
      continue;
    }
    while (playerCash < price)     continue;
    possibleActions.add(new BuyCertificate(cert,from,price,1));
  }
  if (gameManager.canAnyCompanyHoldShares()) {
    for (    PublicCompanyI company : companyManager.getAllPublicCompanies()) {
      certs=company.getPortfolio().getCertificatesPerCompany(company.getName());
      if (certs == null || certs.isEmpty())       continue;
      cert=certs.get(0);
      if (isSaleRecorded(currentPlayer,company))       continue;
      if (!mayPlayerBuyCompanyShare(currentPlayer,company,1))       continue;
      if (maxAllowedNumberOfSharesToBuy(currentPlayer,company,certs.get(0).getShare()) < 1)       continue;
      stockSpace=company.getCurrentSpace();
      if (!stockSpace.isNoCertLimit() && !mayPlayerBuyCertificate(currentPlayer,company,1))       continue;
      if (company.getMarketPrice() <= playerCash) {
        possibleActions.add(new BuyCertificate(cert,company.getPortfolio(),company.getMarketPrice()));
      }
    }
  }
}","/** 
 * Create a list of certificates that a player may buy in a Stock Round, taking all rules into account.
 * @return List of buyable certificates.
 */
@Override public void setBuyableCerts(){
  if (!mayCurrentPlayerBuyAnything())   return;
  List<PublicCertificateI> certs;
  PublicCertificateI cert;
  PublicCompanyI comp;
  StockSpaceI stockSpace;
  Portfolio from;
  int price;
  int number;
  boolean mustMergeMinor=!phase5Reached;
  List<PublicCompanyI> minors=null;
  List<City> freeStations=null;
  if (mustMergeMinor) {
    minors=new ArrayList<PublicCompanyI>();
    for (    PublicCertificateI c : getCurrentPlayer().getPortfolio().getCertificates()) {
      if (c.getCompany().getTypeName().equalsIgnoreCase(""String_Node_Str"")) {
        minors.add(c.getCompany());
      }
    }
  }
 else {
    freeStations=new ArrayList<City>();
    MapManager map=gameManager.getMapManager();
    for (    City city : map.getCurrentStations()) {
      if (city.getSlots() > city.getTokens().size()) {
        freeStations.add(city);
      }
    }
  }
  int playerCash=currentPlayer.getCash();
  PublicCompanyI companyBoughtThisTurn=(PublicCompanyI)companyBoughtThisTurnWrapper.getObject();
  if (companyBoughtThisTurn == null) {
    from=ipo;
    Map<String,List<PublicCertificateI>> map=from.getCertsPerCompanyMap();
    int shares;
    for (    String compName : map.keySet()) {
      certs=map.get(compName);
      if (certs == null || certs.isEmpty())       continue;
      cert=certs.get(0);
      comp=cert.getCompany();
      if (isSaleRecorded(currentPlayer,comp))       continue;
      if (maxAllowedNumberOfSharesToBuy(currentPlayer,comp,cert.getShare()) < 1)       continue;
      shares=cert.getShares();
      if (!comp.hasStarted()) {
        if (mustMergeMinor) {
          if (minors.isEmpty())           continue;
        }
 else {
          if (freeStations.isEmpty())           continue;
        }
        List<Integer> startPrices=new ArrayList<Integer>();
        for (        int startPrice : stockMarket.getStartPrices()) {
          if (startPrice * shares <= playerCash) {
            startPrices.add(startPrice);
          }
        }
        if (startPrices.size() > 0) {
          int[] prices=new int[startPrices.size()];
          Arrays.sort(prices);
          for (int i=0; i < prices.length; i++) {
            prices[i]=startPrices.get(i);
          }
          StartCompany_18EU action=new StartCompany_18EU(cert,prices);
          if (mustMergeMinor) {
            action.setMinorsToMerge(minors);
          }
 else {
            action.setAvailableHomeStations(freeStations);
          }
          possibleActions.add(action);
        }
      }
 else       if (comp.getMarketPrice() <= playerCash) {
        possibleActions.add(new BuyCertificate(cert,from,comp.getMarketPrice()));
      }
    }
  }
  from=pool;
  Map<String,List<PublicCertificateI>> map=from.getCertsPerCompanyMap();
  for (  String compName : map.keySet()) {
    certs=map.get(compName);
    if (certs == null || certs.isEmpty())     continue;
    cert=certs.get(0);
    comp=cert.getCompany();
    if (isSaleRecorded(currentPlayer,comp))     continue;
    if (maxAllowedNumberOfSharesToBuy(currentPlayer,comp,cert.getShare()) < 1)     continue;
    price=comp.getMarketPrice();
    if (companyBoughtThisTurn != null) {
      continue;
    }
    if (playerCash < price)     continue;
    possibleActions.add(new BuyCertificate(cert,from,price,1));
  }
  if (gameManager.canAnyCompanyHoldShares()) {
    for (    PublicCompanyI company : companyManager.getAllPublicCompanies()) {
      certs=company.getPortfolio().getCertificatesPerCompany(company.getName());
      if (certs == null || certs.isEmpty())       continue;
      cert=certs.get(0);
      if (isSaleRecorded(currentPlayer,company))       continue;
      if (!mayPlayerBuyCompanyShare(currentPlayer,company,1))       continue;
      if (maxAllowedNumberOfSharesToBuy(currentPlayer,company,certs.get(0).getShare()) < 1)       continue;
      stockSpace=company.getCurrentSpace();
      if (!stockSpace.isNoCertLimit() && !mayPlayerBuyCertificate(currentPlayer,company,1))       continue;
      if (company.getMarketPrice() <= playerCash) {
        possibleActions.add(new BuyCertificate(cert,company.getPortfolio(),company.getMarketPrice()));
      }
    }
  }
}",0.999191965831698
173779,"public void finish(){
  orWindow.finish();
  orWindow.setVisible(false);
}","public void finish(){
  orWindow.finish();
  if (!(gameUIManager.getCurrentRound() instanceof ShareSellingRound)) {
    setORCompanyTurn(-1);
  }
}",0.5158371040723982
173780,"public void setORCompanyTurn(int orCompIndex){
  orPanel.resetORCompanyTurn(orCompIndex);
  this.orCompIndex=orCompIndex;
  orComp=orCompIndex >= 0 ? companies[orCompIndex] : null;
  if (orCompIndex >= 0) {
  }
}","public void setORCompanyTurn(int orCompIndex){
  this.orCompIndex=orCompIndex;
  orComp=orCompIndex >= 0 ? companies[orCompIndex] : null;
  if (orCompIndex >= 0) {
  }
}",0.8871391076115486
173781,"public void updateStatus(PossibleAction actionToComplete){
  mapRelatedActions.clear();
  orPanel.resetActions();
  if (actionToComplete != null) {
    log.debug(""String_Node_Str"" + actionToComplete);
  }
  orStep=oRound.getStep();
  orComp=oRound.getOperatingCompany();
  log.debug(""String_Node_Str"" + orCompIndex);
  log.debug(""String_Node_Str"" + orComp.getName());
  log.debug(""String_Node_Str"" + orStep + ""String_Node_Str""+ (orStep >= 0 ? OperatingRound.stepNames[orStep] : ""String_Node_Str""));
  if (oRound.getOperatingCompanyIndex() != orCompIndex) {
    if (orCompIndex >= 0)     orPanel.finishORCompanyTurn(orCompIndex);
    setORCompanyTurn(oRound.getOperatingCompanyIndex());
  }
  orPanel.initORCompanyTurn(orCompIndex);
  privatesCanBeBoughtNow=possibleActions.contains(BuyPrivate.class);
  orPanel.initPrivateBuying(privatesCanBeBoughtNow);
  if (possibleActions.contains(LayTile.class)) {
    orPanel.initTileLayingStep();
    orWindow.requestFocus();
    log.debug(""String_Node_Str"");
    mapRelatedActions.addAll(possibleActions.getType(LayTile.class));
  }
 else   if (possibleActions.contains(LayBaseToken.class)) {
    orWindow.requestFocus();
    List<LayToken> possibleTokenLays=possibleActions.getType(LayToken.class);
    mapRelatedActions.addAll(possibleTokenLays);
    allowedTokenLays=possibleTokenLays;
    orPanel.initTokenLayingStep();
    log.debug(""String_Node_Str"");
  }
 else   if (possibleActions.contains(SetDividend.class) && localStep == SELECT_PAYOUT) {
    SetDividend action;
    if (actionToComplete != null) {
      action=(SetDividend)actionToComplete;
    }
 else {
      action=possibleActions.getType(SetDividend.class).get(0);
    }
    log.debug(""String_Node_Str"" + action);
    orPanel.initPayoutStep(orCompIndex,action,action.isAllocationAllowed(SetDividend.WITHHOLD),action.isAllocationAllowed(SetDividend.SPLIT),action.isAllocationAllowed(SetDividend.PAYOUT));
    setMessage(LocalText.getText(""String_Node_Str""));
  }
 else   if (possibleActions.contains(SetDividend.class)) {
    SetDividend action=possibleActions.getType(SetDividend.class).get(0);
    orPanel.initRevenueEntryStep(orCompIndex,action);
    String message=LocalText.getText(""String_Node_Str"");
    if (action.getRequiredCash() > 0) {
      message+=""String_Node_Str"" + LocalText.getText(""String_Node_Str"",Bank.format(action.getRequiredCash())) + ""String_Node_Str"";
    }
    setMessage(message);
  }
 else   if (possibleActions.contains(BuyTrain.class)) {
    orPanel.initTrainBuying(true);
    StringBuffer b=new StringBuffer(LocalText.getText(""String_Node_Str""));
    for (    BuyTrain bTrain : possibleActions.getType(BuyTrain.class)) {
      if (bTrain.hasNoTrains()) {
        b.append(""String_Node_Str"");
        b.append(LocalText.getText(""String_Node_Str""));
        b.append(""String_Node_Str"");
        break;
      }
    }
    setMessage(b.toString());
  }
 else   if (possibleActions.contains(DiscardTrain.class)) {
    gameUIManager.discardTrains(possibleActions.getType(DiscardTrain.class).get(0));
  }
 else   if (possibleActions.contains(RepayLoans.class)) {
    orPanel.enableLoanRepayment(possibleActions.getType(RepayLoans.class).get(0));
  }
 else   if (orStep == OperatingRound.STEP_FINAL) {
    orPanel.finishORCompanyTurn(orCompIndex);
  }
  if (possibleActions.contains(TakeLoans.class)) {
    orPanel.enableLoanTaking(possibleActions.getType(TakeLoans.class).get(0));
  }
  setMapRelatedActions(mapRelatedActions);
  GameAction undoAction=null;
  GameAction redoAction=null;
  if (possibleActions.contains(NullAction.class)) {
    List<NullAction> actions=possibleActions.getType(NullAction.class);
    for (    NullAction action : actions) {
switch (action.getMode()) {
case NullAction.DONE:
        orPanel.enableDone(action);
      break;
  }
}
}
if (possibleActions.contains(GameAction.class)) {
List<GameAction> actions=possibleActions.getType(GameAction.class);
for (GameAction action : actions) {
switch (action.getMode()) {
case GameAction.UNDO:
    undoAction=action;
  break;
case GameAction.REDO:
redoAction=action;
break;
}
}
}
orPanel.enableUndo(undoAction);
orPanel.enableRedo(redoAction);
orPanel.initSpecialActions();
if (possibleActions.contains(LayBonusToken.class) && !possibleActions.contains(LayBaseToken.class)) {
List<LayBonusToken> bonusTokenActions=possibleActions.getType(LayBonusToken.class);
for (LayBonusToken btAction : bonusTokenActions) {
SpecialTokenLay stl=btAction.getSpecialProperty();
BonusToken token=(BonusToken)stl.getToken();
String text=LocalText.getText(""String_Node_Str"",token.toString(),stl.getLocationCodeString());
orPanel.addSpecialAction(btAction,text);
}
}
if (possibleActions.contains(BuyBonusToken.class)) {
List<BuyBonusToken> bonusTokenActions=possibleActions.getType(BuyBonusToken.class);
for (BuyBonusToken bbt : bonusTokenActions) {
String text=LocalText.getText(""String_Node_Str"",bbt.getName(),Bank.format(bbt.getValue()),bbt.getSellerName(),Bank.format(bbt.getPrice()));
orPanel.addSpecialAction(bbt,text);
}
}
if (possibleActions.contains(ReachDestinations.class)) {
orPanel.addSpecialAction(possibleActions.getType(ReachDestinations.class).get(0),LocalText.getText(""String_Node_Str""));
}
checkForGameSpecificActions();
orPanel.redisplay();
}","public void updateStatus(PossibleAction actionToComplete){
  mapRelatedActions.clear();
  orPanel.resetActions();
  if (actionToComplete != null) {
    log.debug(""String_Node_Str"" + actionToComplete);
  }
  orStep=oRound.getStep();
  orComp=oRound.getOperatingCompany();
  log.debug(""String_Node_Str"" + orCompIndex + ""String_Node_Str""+ oRound.getRoundName());
  log.debug(""String_Node_Str"" + orComp.getName());
  log.debug(""String_Node_Str"" + orStep + ""String_Node_Str""+ (orStep >= 0 ? OperatingRound.stepNames[orStep] : ""String_Node_Str""));
  if (oRound.getOperatingCompanyIndex() != orCompIndex) {
    if (orCompIndex >= 0)     orPanel.finishORCompanyTurn(orCompIndex);
    setORCompanyTurn(oRound.getOperatingCompanyIndex());
  }
  orPanel.initORCompanyTurn(orCompIndex);
  privatesCanBeBoughtNow=possibleActions.contains(BuyPrivate.class);
  orPanel.initPrivateBuying(privatesCanBeBoughtNow);
  if (possibleActions.contains(LayTile.class)) {
    orPanel.initTileLayingStep();
    orWindow.requestFocus();
    log.debug(""String_Node_Str"");
    mapRelatedActions.addAll(possibleActions.getType(LayTile.class));
  }
 else   if (possibleActions.contains(LayBaseToken.class)) {
    orWindow.requestFocus();
    List<LayToken> possibleTokenLays=possibleActions.getType(LayToken.class);
    mapRelatedActions.addAll(possibleTokenLays);
    allowedTokenLays=possibleTokenLays;
    orPanel.initTokenLayingStep();
    log.debug(""String_Node_Str"");
  }
 else   if (possibleActions.contains(SetDividend.class) && localStep == SELECT_PAYOUT) {
    SetDividend action;
    if (actionToComplete != null) {
      action=(SetDividend)actionToComplete;
    }
 else {
      action=possibleActions.getType(SetDividend.class).get(0);
    }
    log.debug(""String_Node_Str"" + action);
    orPanel.initPayoutStep(orCompIndex,action,action.isAllocationAllowed(SetDividend.WITHHOLD),action.isAllocationAllowed(SetDividend.SPLIT),action.isAllocationAllowed(SetDividend.PAYOUT));
    setMessage(LocalText.getText(""String_Node_Str""));
  }
 else   if (possibleActions.contains(SetDividend.class)) {
    SetDividend action=possibleActions.getType(SetDividend.class).get(0);
    orPanel.initRevenueEntryStep(orCompIndex,action);
    String message=LocalText.getText(""String_Node_Str"");
    if (action.getRequiredCash() > 0) {
      message+=""String_Node_Str"" + LocalText.getText(""String_Node_Str"",Bank.format(action.getRequiredCash())) + ""String_Node_Str"";
    }
    setMessage(message);
  }
 else   if (possibleActions.contains(BuyTrain.class)) {
    orPanel.initTrainBuying(true);
    StringBuffer b=new StringBuffer(LocalText.getText(""String_Node_Str""));
    for (    BuyTrain bTrain : possibleActions.getType(BuyTrain.class)) {
      if (bTrain.hasNoTrains()) {
        b.append(""String_Node_Str"");
        b.append(LocalText.getText(""String_Node_Str""));
        b.append(""String_Node_Str"");
        break;
      }
    }
    setMessage(b.toString());
  }
 else   if (possibleActions.contains(DiscardTrain.class)) {
    gameUIManager.discardTrains(possibleActions.getType(DiscardTrain.class).get(0));
  }
 else   if (possibleActions.contains(RepayLoans.class)) {
    orPanel.enableLoanRepayment(possibleActions.getType(RepayLoans.class).get(0));
  }
 else   if (orStep == OperatingRound.STEP_FINAL) {
    orPanel.finishORCompanyTurn(orCompIndex);
  }
  if (possibleActions.contains(TakeLoans.class)) {
    orPanel.enableLoanTaking(possibleActions.getType(TakeLoans.class).get(0));
  }
  setMapRelatedActions(mapRelatedActions);
  GameAction undoAction=null;
  GameAction redoAction=null;
  if (possibleActions.contains(NullAction.class)) {
    List<NullAction> actions=possibleActions.getType(NullAction.class);
    for (    NullAction action : actions) {
switch (action.getMode()) {
case NullAction.DONE:
        orPanel.enableDone(action);
      break;
  }
}
}
if (possibleActions.contains(GameAction.class)) {
List<GameAction> actions=possibleActions.getType(GameAction.class);
for (GameAction action : actions) {
switch (action.getMode()) {
case GameAction.UNDO:
    undoAction=action;
  break;
case GameAction.REDO:
redoAction=action;
break;
}
}
}
orPanel.enableUndo(undoAction);
orPanel.enableRedo(redoAction);
orPanel.initSpecialActions();
if (possibleActions.contains(LayBonusToken.class) && !possibleActions.contains(LayBaseToken.class)) {
List<LayBonusToken> bonusTokenActions=possibleActions.getType(LayBonusToken.class);
for (LayBonusToken btAction : bonusTokenActions) {
SpecialTokenLay stl=btAction.getSpecialProperty();
BonusToken token=(BonusToken)stl.getToken();
String text=LocalText.getText(""String_Node_Str"",token.toString(),stl.getLocationCodeString());
orPanel.addSpecialAction(btAction,text);
}
}
if (possibleActions.contains(BuyBonusToken.class)) {
List<BuyBonusToken> bonusTokenActions=possibleActions.getType(BuyBonusToken.class);
for (BuyBonusToken bbt : bonusTokenActions) {
String text=LocalText.getText(""String_Node_Str"",bbt.getName(),Bank.format(bbt.getValue()),bbt.getSellerName(),Bank.format(bbt.getPrice()));
orPanel.addSpecialAction(bbt,text);
}
}
if (possibleActions.contains(ReachDestinations.class)) {
orPanel.addSpecialAction(possibleActions.getType(ReachDestinations.class).get(0),LocalText.getText(""String_Node_Str""));
}
checkForGameSpecificActions();
orPanel.redisplay();
}",0.995919142070798
173782,"public void addCertificate(PublicCertificateI certificate){
  boolean atTop=certificate.isPresidentShare();
  if (atTop)   certificates.add(0,certificate);
 else   certificates.add(certificate);
  String companyName=certificate.getCompany().getName();
  if (!certPerCompany.containsKey(companyName)) {
    certPerCompany.put(companyName,new ArrayList<PublicCertificateI>());
  }
  if (atTop)   (certPerCompany.get(companyName)).add(0,certificate);
 else   (certPerCompany.get(companyName)).add(certificate);
  String certTypeId=certificate.getTypeId();
  if (!certsPerType.containsKey(certTypeId)) {
    certsPerType.put(certTypeId,new ArrayList<PublicCertificateI>());
  }
  certsPerType.get(certTypeId).add(certificate);
  certificate.setPortfolio(this);
  getShareModel(certificate.getCompany()).addShare(certificate.getShare());
}","public void addCertificate(PublicCertificateI certificate){
  boolean atTop=certificate.isPresidentShare();
  if (atTop)   certificates.add(0,certificate);
 else   certificates.add(certificate);
  String companyName=certificate.getCompany().getName();
  if (!certPerCompany.containsKey(companyName)) {
    certPerCompany.put(companyName,new ArrayList<PublicCertificateI>());
  }
  if (atTop)   (certPerCompany.get(companyName)).add(0,certificate);
 else   (certPerCompany.get(companyName)).add(certificate);
  String certTypeId=certificate.getTypeId();
  if (!certsPerType.containsKey(certTypeId)) {
    certsPerType.put(certTypeId,new ArrayList<PublicCertificateI>());
  }
  certsPerType.get(certTypeId).add(certificate);
  certificate.setPortfolio(this);
  getShareModel(certificate.getCompany()).addShare(certificate.getShare());
  if (owner instanceof Player) {
    ((Player)owner).updateWorth();
  }
}",0.9586206896551724
173783,"public void removeCertificate(PublicCertificateI certificate){
  certificates.remove(certificate);
  String companyName=certificate.getCompany().getName();
  List<PublicCertificateI> certs=getCertificatesPerCompany(companyName);
  certs.remove(certificate);
  String certTypeId=certificate.getTypeId();
  if (certsPerType.containsKey(certTypeId)) {
    certsPerType.get(certTypeId).remove(0);
    if (certsPerType.get(certTypeId).isEmpty()) {
      certsPerType.remove(certTypeId);
    }
  }
  getShareModel(certificate.getCompany()).addShare(-certificate.getShare());
}","public void removeCertificate(PublicCertificateI certificate){
  certificates.remove(certificate);
  String companyName=certificate.getCompany().getName();
  List<PublicCertificateI> certs=getCertificatesPerCompany(companyName);
  certs.remove(certificate);
  String certTypeId=certificate.getTypeId();
  if (certsPerType.containsKey(certTypeId)) {
    certsPerType.get(certTypeId).remove(0);
    if (certsPerType.get(certTypeId).isEmpty()) {
      certsPerType.remove(certTypeId);
    }
  }
  getShareModel(certificate.getCompany()).addShare(-certificate.getShare());
  if (owner instanceof Player) {
    ((Player)owner).updateWorth();
  }
}",0.9405940594059404
173784,"public void start(Player startingPlayer){
  this.startingPlayer=startingPlayer;
  Player president;
  companiesToRepayLoans=null;
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgrName,startingPlayer.getName()));
  for (  PublicCompanyI company : getOperatingCompanies()) {
    if (company.getCurrentNumberOfLoans() > 0) {
      if (companiesToRepayLoans == null) {
        companiesToRepayLoans=new HashMap<Player,List<PublicCompanyI>>();
      }
      president=company.getPresident();
      if (!companiesToRepayLoans.containsKey(president)) {
        companiesToRepayLoans.put(president,new ArrayList<PublicCompanyI>());
      }
      companiesToRepayLoans.get(president).add(company);
    }
  }
  if (companiesToRepayLoans == null) {
    finishRound();
    return;
  }
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgrName,startingPlayer.getName()));
  setStep(STEP_REPAY_LOANS);
  setCurrentPlayer(startingPlayer);
  process(null);
}","public void start(Player startingPlayer){
  this.startingPlayer=startingPlayer;
  Player president;
  companiesToRepayLoans=null;
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgrName,startingPlayer.getName()));
  for (  PublicCompanyI company : getOperatingCompanies()) {
    if (company.getCurrentNumberOfLoans() > 0) {
      if (companiesToRepayLoans == null) {
        companiesToRepayLoans=new HashMap<Player,List<PublicCompanyI>>();
      }
      president=company.getPresident();
      if (!companiesToRepayLoans.containsKey(president)) {
        companiesToRepayLoans.put(president,new ArrayList<PublicCompanyI>());
      }
      companiesToRepayLoans.get(president).add(company);
    }
  }
  if (companiesToRepayLoans == null) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgr.getName()));
    finishRound();
    return;
  }
  setStep(STEP_REPAY_LOANS);
  setCurrentPlayer(startingPlayer);
  process(null);
}",0.9445910290237468
173785,"private void formCGR(){
  Player player;
  Portfolio portfolio;
  int count, cgrSharesUsed, oldShares, newShares;
  PublicCertificateI cgrCert, poolCert;
  List<PublicCertificateI> certs=new ArrayList<PublicCertificateI>();
  Player temporaryPresident=null;
  Player newPresident=null;
  Player firstCGRowner=null;
  int maxShares=0;
  setCurrentPlayer(startingPlayer);
  cgrSharesUsed=0;
  ReportBuffer.add(""String_Node_Str"");
  do {
    player=getCurrentPlayer();
    portfolio=player.getPortfolio();
    oldShares=newShares=0;
    certs.clear();
    poolCert=null;
    for (    PublicCertificateI cert : player.getPortfolio().getCertificates()) {
      if (mergingCompanies.contains(cert.getCompany())) {
        certs.add((cert));
        oldShares++;
        if (cert.isPresidentShare()) {
          oldShares++;
        }
      }
    }
    if (oldShares > 0) {
      count=oldShares;
      if (count >= 4 && temporaryPresident == null && cgrSharesUsed <= 18) {
        cgrCert=cgr.getPresidentsShare();
        cgrCert.moveTo(portfolio);
        count-=4;
        cgrSharesUsed+=2;
        newShares+=2;
        temporaryPresident=player;
      }
      while (count >= 2 && cgrSharesUsed <= 19) {
        cgrCert=unavailable.findCertificate(cgr,false);
        cgrCert.moveTo(portfolio);
        count-=2;
        cgrSharesUsed++;
        newShares++;
      }
      String message=LocalText.getText(""String_Node_Str"",player.getName(),oldShares,newShares,PublicCompany_CGR.NAME);
      DisplayBuffer.add(message,false);
      ReportBuffer.add(message);
      if (count == 1) {
        poolCert=certs.get(certs.size() - 1);
        poolCert.moveTo(pool);
        certs.remove(poolCert);
        message=LocalText.getText(""String_Node_Str"",player.getName());
        DisplayBuffer.add(message,false);
        ReportBuffer.add(message);
      }
      if (firstCGRowner == null)       firstCGRowner=player;
      if (newShares > maxShares) {
        maxShares=newShares;
        newPresident=player;
      }
    }
    gameManager.setNextPlayer();
  }
 while (getCurrentPlayer() != startingPlayer);
  certs.clear();
  oldShares=newShares=0;
  for (  PublicCertificateI cert : pool.getCertificates()) {
    if (mergingCompanies.contains(cert.getCompany())) {
      certs.add((cert));
      oldShares++;
    }
  }
  count=oldShares;
  while (count >= 2 && cgrSharesUsed <= 19) {
    cgrCert=unavailable.findCertificate(cgr,false);
    cgrCert.moveTo(pool);
    count-=2;
    cgrSharesUsed++;
    newShares++;
  }
  String message=LocalText.getText(""String_Node_Str"",LocalText.getText(""String_Node_Str""),oldShares,newShares,PublicCompany_CGR.NAME);
  DisplayBuffer.add(message);
  ReportBuffer.add(message);
  for (  PublicCertificateI discardCert : certs) {
    discardCert.moveTo(scrapHeap);
  }
  log.info(cgrSharesUsed + ""String_Node_Str"");
  if (cgrSharesUsed <= 10) {
    cgr.setShareUnit(10);
  }
  message=LocalText.getText(""String_Node_Str"",cgr.getName(),100 / cgr.getShareUnit(),cgr.getShareUnit());
  DisplayBuffer.add(message);
  ReportBuffer.add(message);
  certs=new ArrayList<PublicCertificateI>(unavailable.getCertificatesPerCompany(PublicCompany_CGR.NAME));
  for (  PublicCertificateI cert : certs) {
    cert.moveTo(ipo);
  }
  if (newPresident.getPortfolio().getShare(cgr) == cgr.getShareUnit()) {
    log.debug(""String_Node_Str"" + firstCGRowner.getName());
    cgr.setTemporaryPresident(firstCGRowner);
    newPresident=firstCGRowner;
  }
 else   if (temporaryPresident != null && temporaryPresident != newPresident) {
    log.debug(""String_Node_Str"" + temporaryPresident.getName() + ""String_Node_Str""+ newPresident.getName());
    temporaryPresident.getPortfolio().swapPresidentCertificate(cgr,newPresident.getPortfolio());
  }
  newPresident.getPortfolio().getShareModel(cgr).setShare();
  message=LocalText.getText(""String_Node_Str"",newPresident.getName(),cgrName);
  ReportBuffer.add(message);
  DisplayBuffer.add(message);
  int lowestPrice=999;
  int totalPrice=0;
  int price;
  int numberMerged=mergingCompanies.size();
  for (  PublicCompanyI comp : mergingCompanies) {
    price=comp.getMarketPrice();
    totalPrice+=price;
    if (price < lowestPrice)     lowestPrice=price;
  }
  if (numberMerged >= 3) {
    totalPrice-=lowestPrice;
    numberMerged--;
  }
  int cgrPrice=Math.max(100,(((totalPrice / numberMerged) / 5)) * 5);
  if (cgrPrice == 100) {
    cgr.start(100);
  }
 else {
    int prevColPrice=100;
    int colPrice;
    StockSpaceI startSpace;
    for (int col=6; col <= stockMarket.getNumberOfColumns(); col++) {
      colPrice=stockMarket.getStockSpace(1,col).getPrice();
      if (cgrPrice > colPrice)       continue;
      if (cgrPrice - prevColPrice < colPrice - cgrPrice) {
        startSpace=stockMarket.getStockSpace(1,col - 1);
      }
 else {
        startSpace=stockMarket.getStockSpace(1,col);
      }
      cgr.start(startSpace);
      message=LocalText.getText(""String_Node_Str"",PublicCompany_CGR.NAME,Bank.format(startSpace.getPrice()),startSpace.getName());
      DisplayBuffer.add(message);
      ReportBuffer.add(message);
      break;
    }
  }
  cgr.setFloated();
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",PublicCompany_CGR.NAME));
  int numCompanies=Math.min(11,12 - mergingCompanies.size());
  int numPlayers=gameManager.getNumberOfPlayers();
  int newCertLimit=certLimitsTable[numPlayers - 3][numCompanies - 4];
  gameManager.setPlayerCertificateLimit(newCertLimit);
  message=LocalText.getText(""String_Node_Str"",newCertLimit,numPlayers,numCompanies);
  DisplayBuffer.add(message);
  ReportBuffer.add(message);
  List<BaseToken> homeTokens=new ArrayList<BaseToken>();
  nonHomeTokens=new ArrayList<BaseToken>();
  BaseToken bt;
  MapHex hex;
  City city;
  for (  PublicCompanyI comp : mergingCompanies) {
    for (    TokenI token : comp.getTokens()) {
      if (token instanceof BaseToken) {
        bt=(BaseToken)token;
        if (!bt.isPlaced())         continue;
        city=(City)bt.getHolder();
        hex=city.getHolder();
        if (hex == comp.getHomeHex()) {
          homeTokens.add(bt);
        }
 else {
          nonHomeTokens.add(bt);
        }
      }
    }
    if (comp.getCash() > 0) {
      new CashMove(comp,cgr,comp.getCash());
    }
    List<TrainI> trains=new ArrayList<TrainI>(comp.getPortfolio().getTrainList());
    for (    TrainI train : trains) {
      train.moveTo(cgr.getPortfolio());
      if (train.getType().isPermanent())       cgr.setHadPermanentTrain(true);
    }
    if (comp.getBonuses() != null) {
      List<Bonus> bonuses=new ArrayList<Bonus>(comp.getBonuses());
      bonuses:       for (      Bonus bonus : bonuses) {
        comp.removeBonus(bonus);
        if (cgr.getBonuses() != null) {
          for (          Bonus b : cgr.getBonuses()) {
            if (b.equals(bonus)) {
              List<SellBonusToken> commonSP=gameManager.getSpecialProperties(SellBonusToken.class,true);
              if (commonSP != null) {
                for (                SellBonusToken sp : commonSP) {
                  if (sp.getName().equalsIgnoreCase(b.getName())) {
                    sp.makeResellable();
                    log.debug(""String_Node_Str"" + b.getName() + ""String_Node_Str"");
                    break;
                  }
                }
              }
              log.debug(""String_Node_Str"" + b.getName() + ""String_Node_Str""+ cgrName);
              continue bonuses;
            }
          }
        }
        cgr.addBonus(new Bonus(cgr,bonus.getName(),bonus.getValue(),bonus.getLocations()));
      }
    }
  }
  ReportBuffer.add(""String_Node_Str"");
  for (  BaseToken token : homeTokens) {
    city=(City)token.getHolder();
    hex=city.getHolder();
    token.moveTo(token.getCompany());
    if (hex.layBaseToken(cgr,city.getNumber())) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgrName,token.getCompany().getName(),city.getName()));
      cgr.layBaseToken(hex,0);
    }
  }
  for (  BaseToken token : new ArrayList<BaseToken>(nonHomeTokens)) {
    city=(City)token.getHolder();
    hex=city.getHolder();
    List<BaseToken> otherTokens=hex.getBaseTokens();
    if (otherTokens != null) {
      for (      BaseToken token2 : otherTokens) {
        if (token2.getCompany() == cgr || nonHomeTokens.contains(token2) && token2 != token) {
          ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgrName,token.getCompany().getName(),city.getName()));
          token.moveTo(token.getCompany());
          nonHomeTokens.remove(token);
          break;
        }
      }
    }
  }
  if (homeTokens.size() + nonHomeTokens.size() > cgr.getNumberOfBaseTokens()) {
    Map<String,String> oldTokens=new HashMap<String,String>();
    String cityName;
    for (    BaseToken token : nonHomeTokens) {
      if (token.getHolder() instanceof City) {
        cityName=token.getHolder().getName();
        if (oldTokens.containsKey(cityName)) {
          oldTokens.put(cityName,oldTokens.get(cityName) + ""String_Node_Str"" + token.getCompany().getName());
        }
 else {
          oldTokens.put(cityName,token.getCompany().getName());
        }
      }
    }
    tokensToExchangeFrom=new ArrayList<ExchangeableToken>();
    for (    String key : new TreeSet<String>(oldTokens.keySet())) {
      tokensToExchangeFrom.add(new ExchangeableToken(key,oldTokens.get(key)));
    }
  }
 else {
    executeExchangeTokens(nonHomeTokens);
  }
  for (  PublicCompanyI comp : mergingCompanies) {
    comp.setClosed();
  }
  int trainLimit=cgr.getTrainLimit(gameManager.getCurrentPlayerIndex());
  List<TrainI> trains=cgr.getPortfolio().getTrainList();
  if (cgr.getNumberOfTrains() > trainLimit)   ReportBuffer.add(""String_Node_Str"");
  outer:   while (cgr.getNumberOfTrains() > trainLimit) {
    for (    TrainI train : trains) {
      if (!train.getType().isPermanent()) {
        train.moveTo(pool);
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgrName,train.getName()));
        continue outer;
      }
    }
    break;
  }
}","private void formCGR(){
  Player player;
  Portfolio portfolio;
  int count, cgrSharesUsed, oldShares, newShares;
  PublicCertificateI cgrCert, poolCert;
  List<PublicCertificateI> certs=new ArrayList<PublicCertificateI>();
  Player temporaryPresident=null;
  Player newPresident=null;
  Player firstCGRowner=null;
  int maxShares=0;
  setCurrentPlayer(startingPlayer);
  cgrSharesUsed=0;
  ReportBuffer.add(""String_Node_Str"");
  do {
    player=getCurrentPlayer();
    portfolio=player.getPortfolio();
    oldShares=newShares=0;
    certs.clear();
    poolCert=null;
    for (    PublicCertificateI cert : player.getPortfolio().getCertificates()) {
      if (mergingCompanies.contains(cert.getCompany())) {
        certs.add((cert));
        oldShares++;
        if (cert.isPresidentShare()) {
          oldShares++;
        }
      }
    }
    if (oldShares > 0) {
      count=oldShares;
      if (count >= 4 && temporaryPresident == null && cgrSharesUsed <= 18) {
        cgrCert=cgr.getPresidentsShare();
        cgrCert.moveTo(portfolio);
        count-=4;
        cgrSharesUsed+=2;
        newShares+=2;
        temporaryPresident=player;
      }
      while (count >= 2 && cgrSharesUsed <= 19) {
        cgrCert=unavailable.findCertificate(cgr,false);
        cgrCert.moveTo(portfolio);
        count-=2;
        cgrSharesUsed++;
        newShares++;
      }
      String message=LocalText.getText(""String_Node_Str"",player.getName(),oldShares,newShares,PublicCompany_CGR.NAME);
      DisplayBuffer.add(message,false);
      ReportBuffer.add(message);
      if (count == 1) {
        poolCert=certs.get(certs.size() - 1);
        poolCert.moveTo(pool);
        certs.remove(poolCert);
        message=LocalText.getText(""String_Node_Str"",player.getName());
        DisplayBuffer.add(message,false);
        ReportBuffer.add(message);
      }
      if (firstCGRowner == null)       firstCGRowner=player;
      if (newShares > maxShares) {
        maxShares=newShares;
        newPresident=player;
      }
    }
    gameManager.setNextPlayer();
  }
 while (getCurrentPlayer() != startingPlayer);
  certs.clear();
  oldShares=newShares=0;
  for (  PublicCertificateI cert : pool.getCertificates()) {
    if (mergingCompanies.contains(cert.getCompany())) {
      certs.add((cert));
      oldShares++;
    }
  }
  count=oldShares;
  while (count >= 2 && cgrSharesUsed <= 19) {
    cgrCert=unavailable.findCertificate(cgr,false);
    cgrCert.moveTo(pool);
    count-=2;
    cgrSharesUsed++;
    newShares++;
  }
  String message=LocalText.getText(""String_Node_Str"",LocalText.getText(""String_Node_Str""),oldShares,newShares,PublicCompany_CGR.NAME);
  DisplayBuffer.add(message);
  ReportBuffer.add(message);
  for (  PublicCertificateI discardCert : certs) {
    discardCert.moveTo(scrapHeap);
  }
  log.info(cgrSharesUsed + ""String_Node_Str"");
  if (cgrSharesUsed <= 10) {
    cgr.setShareUnit(10);
  }
  message=LocalText.getText(""String_Node_Str"",cgr.getName(),100 / cgr.getShareUnit(),cgr.getShareUnit());
  DisplayBuffer.add(message);
  ReportBuffer.add(message);
  certs=new ArrayList<PublicCertificateI>(unavailable.getCertificatesPerCompany(PublicCompany_CGR.NAME));
  for (  PublicCertificateI cert : certs) {
    cert.moveTo(ipo);
  }
  if (newPresident.getPortfolio().getShare(cgr) == cgr.getShareUnit()) {
    log.debug(""String_Node_Str"" + firstCGRowner.getName());
    cgr.setTemporaryPresident(firstCGRowner);
    newPresident=firstCGRowner;
  }
 else   if (temporaryPresident != null && temporaryPresident != newPresident) {
    log.debug(""String_Node_Str"" + temporaryPresident.getName() + ""String_Node_Str""+ newPresident.getName());
    temporaryPresident.getPortfolio().swapPresidentCertificate(cgr,newPresident.getPortfolio());
  }
  newPresident.getPortfolio().getShareModel(cgr).setShare();
  message=LocalText.getText(""String_Node_Str"",newPresident.getName(),cgrName);
  ReportBuffer.add(message);
  DisplayBuffer.add(message);
  int lowestPrice=999;
  int totalPrice=0;
  int price;
  int numberMerged=mergingCompanies.size();
  for (  PublicCompanyI comp : mergingCompanies) {
    price=comp.getMarketPrice();
    totalPrice+=price;
    if (price < lowestPrice)     lowestPrice=price;
  }
  if (numberMerged >= 3) {
    totalPrice-=lowestPrice;
    numberMerged--;
  }
  int cgrPrice=Math.max(100,(((totalPrice / numberMerged) / 5)) * 5);
  if (cgrPrice == 100) {
    cgr.start(100);
  }
 else {
    int prevColPrice=100;
    int colPrice;
    StockSpaceI startSpace;
    for (int col=6; col <= stockMarket.getNumberOfColumns(); col++) {
      colPrice=stockMarket.getStockSpace(1,col).getPrice();
      if (cgrPrice > colPrice)       continue;
      if (cgrPrice - prevColPrice < colPrice - cgrPrice) {
        startSpace=stockMarket.getStockSpace(1,col - 1);
      }
 else {
        startSpace=stockMarket.getStockSpace(1,col);
      }
      cgr.start(startSpace);
      message=LocalText.getText(""String_Node_Str"",PublicCompany_CGR.NAME,Bank.format(startSpace.getPrice()),startSpace.getName());
      DisplayBuffer.add(message);
      ReportBuffer.add(message);
      break;
    }
  }
  cgr.setFloated();
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",PublicCompany_CGR.NAME));
  int numCompanies=Math.min(11,12 - mergingCompanies.size());
  int numPlayers=gameManager.getNumberOfPlayers();
  int newCertLimit=certLimitsTable[numPlayers - 3][numCompanies - 4];
  gameManager.setPlayerCertificateLimit(newCertLimit);
  message=LocalText.getText(""String_Node_Str"",newCertLimit,numPlayers,numCompanies);
  DisplayBuffer.add(message);
  ReportBuffer.add(message);
  List<BaseToken> homeTokens=new ArrayList<BaseToken>();
  nonHomeTokens=new ArrayList<BaseToken>();
  BaseToken bt;
  MapHex hex;
  City city;
  for (  PublicCompanyI comp : mergingCompanies) {
    for (    TokenI token : comp.getTokens()) {
      if (token instanceof BaseToken) {
        bt=(BaseToken)token;
        if (!bt.isPlaced())         continue;
        city=(City)bt.getHolder();
        hex=city.getHolder();
        if (hex == comp.getHomeHex()) {
          homeTokens.add(bt);
        }
 else {
          nonHomeTokens.add(bt);
        }
      }
    }
    if (comp.getCash() > 0) {
      new CashMove(comp,cgr,comp.getCash());
    }
    List<TrainI> trains=new ArrayList<TrainI>(comp.getPortfolio().getTrainList());
    for (    TrainI train : trains) {
      train.moveTo(cgr.getPortfolio());
      if (train.getType().isPermanent())       cgr.setHadPermanentTrain(true);
    }
    if (comp.getBonuses() != null) {
      List<Bonus> bonuses=new ArrayList<Bonus>(comp.getBonuses());
      bonuses:       for (      Bonus bonus : bonuses) {
        comp.removeBonus(bonus);
        if (cgr.getBonuses() != null) {
          for (          Bonus b : cgr.getBonuses()) {
            if (b.equals(bonus)) {
              List<SellBonusToken> commonSP=gameManager.getSpecialProperties(SellBonusToken.class,true);
              if (commonSP != null) {
                for (                SellBonusToken sp : commonSP) {
                  if (sp.getName().equalsIgnoreCase(b.getName())) {
                    sp.makeResellable();
                    log.debug(""String_Node_Str"" + b.getName() + ""String_Node_Str"");
                    break;
                  }
                }
              }
              log.debug(""String_Node_Str"" + b.getName() + ""String_Node_Str""+ cgrName);
              continue bonuses;
            }
          }
        }
        cgr.addBonus(new Bonus(cgr,bonus.getName(),bonus.getValue(),bonus.getLocations()));
      }
    }
  }
  ReportBuffer.add(""String_Node_Str"");
  for (  BaseToken token : homeTokens) {
    city=(City)token.getHolder();
    hex=city.getHolder();
    token.moveTo(token.getCompany());
    if (hex.layBaseToken(cgr,city.getNumber())) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgrName,token.getCompany().getName(),city.getName()));
      cgr.layBaseToken(hex,0);
    }
  }
  for (  BaseToken token : new ArrayList<BaseToken>(nonHomeTokens)) {
    city=(City)token.getHolder();
    hex=city.getHolder();
    List<BaseToken> otherTokens=hex.getBaseTokens();
    if (otherTokens != null) {
      for (      BaseToken token2 : otherTokens) {
        if (token2.getCompany() == cgr || nonHomeTokens.contains(token2) && token2 != token) {
          ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgrName,token.getCompany().getName(),city.getName()));
          token.moveTo(token.getCompany());
          nonHomeTokens.remove(token);
          break;
        }
      }
    }
  }
  if (homeTokens.size() + nonHomeTokens.size() > cgr.getNumberOfBaseTokens()) {
    Map<String,String> oldTokens=new HashMap<String,String>();
    String cityName;
    for (    BaseToken token : nonHomeTokens) {
      if (token.getHolder() instanceof City) {
        cityName=token.getHolder().getName();
        if (oldTokens.containsKey(cityName)) {
          oldTokens.put(cityName,oldTokens.get(cityName) + ""String_Node_Str"" + token.getCompany().getName());
        }
 else {
          oldTokens.put(cityName,token.getCompany().getName());
        }
      }
    }
    tokensToExchangeFrom=new ArrayList<ExchangeableToken>();
    for (    String key : new TreeSet<String>(oldTokens.keySet())) {
      tokensToExchangeFrom.add(new ExchangeableToken(key,oldTokens.get(key)));
    }
  }
 else {
    executeExchangeTokens(nonHomeTokens);
  }
  for (  PublicCompanyI comp : mergingCompanies) {
    comp.setClosed();
  }
  int trainLimit=cgr.getTrainLimit(gameManager.getCurrentPlayerIndex());
  List<TrainI> trains=cgr.getPortfolio().getTrainList();
  if (cgr.getNumberOfTrains() > trainLimit) {
    ReportBuffer.add(""String_Node_Str"");
    int numberToDiscard=cgr.getNumberOfTrains() - trainLimit;
    List<TrainI> trainsToDiscard=new ArrayList<TrainI>(4);
    for (    TrainI train : trains) {
      if (!train.getType().isPermanent()) {
        trainsToDiscard.add(train);
        if (--numberToDiscard == 0)         break;
      }
    }
    for (    TrainI train : trainsToDiscard) {
      train.moveTo(pool);
      ReportBuffer.add(LocalText.getText(""String_Node_Str"",cgrName,train.getName()));
    }
  }
}",0.9743920595533498
173786,"@Override public boolean setPossibleActions(){
  boolean passAllowed=true;
  possibleActions.clear();
  if (startPacket.areAllSold())   return false;
  if (currentPlayer == startPlayer)   ReportBuffer.add(""String_Node_Str"");
  while (possibleActions.isEmpty()) {
    Player currentPlayer=getCurrentPlayer();
    for (    StartItem item : itemsToSell) {
      if (item.isSold()) {
      }
 else       if (item.getStatus() == StartItem.AUCTIONED) {
        if (currentPlayer.getFreeCash() + item.getBid(currentPlayer) >= item.getMinimumBid()) {
          BidStartItem possibleAction=new BidStartItem(item,item.getMinimumBid(),startPacket.getModulus(),true);
          possibleActions.add(possibleAction);
          break;
        }
 else {
          numPasses.add(1);
          break;
        }
      }
 else       if (item.getStatus() == StartItem.NEEDS_SHARE_PRICE) {
        setPlayer(item.getBidder());
        possibleActions.add(new BuyStartItem(item,item.getBid(),false,true));
        passAllowed=false;
        break;
      }
 else       if (item == startPacket.getFirstUnsoldItem()) {
        if (item.getBidders() == 1) {
          PublicCompanyI comp=item.needsPriceSetting();
          if (comp != null) {
            setPlayer(item.getBidder());
            item.setStatus(StartItem.NEEDS_SHARE_PRICE);
            BuyStartItem newItem=new BuyStartItem(item,item.getBasePrice(),true,true);
            possibleActions.add(newItem);
            break;
          }
 else {
            assignItem(item.getBidder(),item,item.getBid(),0);
          }
        }
 else         if (item.getBidders() > 1) {
          ReportBuffer.add(LocalText.getText(""String_Node_Str"",item.getName()));
          if (item.getStatus() != StartItem.AUCTIONED) {
            setNextBiddingPlayer(item,item.getBidder().getIndex());
            currentPlayer=getCurrentPlayer();
            item.setStatus(StartItem.AUCTIONED);
            auctionItemState.set(item);
          }
          if (currentPlayer.getFreeCash() + item.getBid(currentPlayer) >= item.getMinimumBid()) {
            BidStartItem possibleAction=new BidStartItem(item,item.getMinimumBid(),startPacket.getModulus(),true);
            possibleActions.add(possibleAction);
          }
          break;
        }
 else {
          item.setStatus(StartItem.BUYABLE);
          if (currentPlayer.getFreeCash() >= item.getBasePrice()) {
            possibleActions.add(new BuyStartItem(item,item.getBasePrice(),false));
          }
        }
      }
 else {
        item.setStatus(StartItem.BIDDABLE);
        if (currentPlayer.getFreeCash() + item.getBid(currentPlayer) >= item.getMinimumBid()) {
          BidStartItem possibleAction=new BidStartItem(item,item.getMinimumBid(),startPacket.getModulus(),false);
          possibleActions.add(possibleAction);
        }
      }
    }
    if (gameManager.getStartPacket().areAllSold()) {
      return false;
    }
    if (possibleActions.isEmpty()) {
      numPasses.add(1);
      if (auctionItemState.getObject() == null) {
        setNextPlayer();
      }
 else {
        setNextBiddingPlayer((StartItem)auctionItemState.getObject());
      }
    }
  }
  if (passAllowed) {
    possibleActions.add(new NullAction(NullAction.PASS));
  }
  return true;
}","@Override public boolean setPossibleActions(){
  boolean passAllowed=true;
  possibleActions.clear();
  if (currentPlayer == startPlayer)   ReportBuffer.add(""String_Node_Str"");
  while (possibleActions.isEmpty()) {
    Player currentPlayer=getCurrentPlayer();
    for (    StartItem item : itemsToSell) {
      if (item.isSold()) {
      }
 else       if (item.getStatus() == StartItem.AUCTIONED) {
        if (currentPlayer.getFreeCash() + item.getBid(currentPlayer) >= item.getMinimumBid()) {
          BidStartItem possibleAction=new BidStartItem(item,item.getMinimumBid(),startPacket.getModulus(),true);
          possibleActions.add(possibleAction);
          break;
        }
 else {
          numPasses.add(1);
          break;
        }
      }
 else       if (item.getStatus() == StartItem.NEEDS_SHARE_PRICE) {
        setPlayer(item.getBidder());
        possibleActions.add(new BuyStartItem(item,item.getBid(),false,true));
        passAllowed=false;
        break;
      }
 else       if (item == startPacket.getFirstUnsoldItem()) {
        if (item.getBidders() == 1) {
          PublicCompanyI comp=item.needsPriceSetting();
          if (comp != null) {
            setPlayer(item.getBidder());
            item.setStatus(StartItem.NEEDS_SHARE_PRICE);
            BuyStartItem newItem=new BuyStartItem(item,item.getBasePrice(),true,true);
            possibleActions.add(newItem);
            break;
          }
 else {
            log.error(""String_Node_Str"" + item.getName());
            assignItem(item.getBidder(),item,item.getBid(),0);
          }
        }
 else         if (item.getBidders() > 1) {
          ReportBuffer.add(LocalText.getText(""String_Node_Str"",item.getName()));
          if (item.getStatus() != StartItem.AUCTIONED) {
            setNextBiddingPlayer(item,item.getBidder().getIndex());
            currentPlayer=getCurrentPlayer();
            item.setStatus(StartItem.AUCTIONED);
            auctionItemState.set(item);
          }
          if (currentPlayer.getFreeCash() + item.getBid(currentPlayer) >= item.getMinimumBid()) {
            BidStartItem possibleAction=new BidStartItem(item,item.getMinimumBid(),startPacket.getModulus(),true);
            possibleActions.add(possibleAction);
          }
          break;
        }
 else {
          item.setStatus(StartItem.BUYABLE);
          if (currentPlayer.getFreeCash() >= item.getBasePrice()) {
            possibleActions.add(new BuyStartItem(item,item.getBasePrice(),false));
          }
        }
      }
 else {
        item.setStatus(StartItem.BIDDABLE);
        if (currentPlayer.getFreeCash() + item.getBid(currentPlayer) >= item.getMinimumBid()) {
          BidStartItem possibleAction=new BidStartItem(item,item.getMinimumBid(),startPacket.getModulus(),false);
          possibleActions.add(possibleAction);
        }
      }
    }
    if (possibleActions.isEmpty()) {
      numPasses.add(1);
      if (auctionItemState.getObject() == null) {
        setNextPlayer();
      }
 else {
        setNextBiddingPlayer((StartItem)auctionItemState.getObject());
      }
    }
  }
  if (passAllowed) {
    possibleActions.add(new NullAction(NullAction.PASS));
  }
  return true;
}",0.9710910786447
173787,"@SuppressWarnings(""String_Node_Str"") public static Game load(String filepath){
  Game game=null;
  log.debug(""String_Node_Str"" + filepath);
  String filename=filepath.replaceAll(""String_Node_Str"",""String_Node_Str"");
  try {
    ObjectInputStream ois=new ObjectInputStream(new FileInputStream(new File(filepath)));
    Object object=ois.readObject();
    if (object instanceof String) {
      log.info(""String_Node_Str"" + (String)object + ""String_Node_Str""+ filename);
      object=ois.readObject();
    }
 else {
      log.info(""String_Node_Str"" + filename);
    }
    if (object instanceof String) {
      log.info(""String_Node_Str"" + (String)object);
      object=ois.readObject();
    }
    long versionID=(Long)object;
    log.debug(""String_Node_Str"" + versionID + ""String_Node_Str""+ object+ ""String_Node_Str"");
    long saveFileVersionID=GameManager.saveFileVersionID;
    if (versionID != saveFileVersionID) {
      throw new Exception(""String_Node_Str"" + versionID + ""String_Node_Str""+ saveFileVersionID);
    }
    String name=(String)ois.readObject();
    log.debug(""String_Node_Str"" + name);
    Map<String,String> selectedGameOptions=(Map<String,String>)ois.readObject();
    List<String> playerNames=(List<String>)ois.readObject();
    game=new Game(name,playerNames,selectedGameOptions);
    if (!game.setup()) {
      throw new ConfigurationException(""String_Node_Str"" + name);
    }
    List<PossibleAction> executedActions=(List<PossibleAction>)ois.readObject();
    ois.close();
    log.debug(""String_Node_Str"" + executedActions.size());
    game.start();
    log.debug(""String_Node_Str"");
    game.getGameManager().processOnReload(executedActions);
    return game;
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",e.getMessage()));
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") public static Game load(String filepath){
  Game game=null;
  log.debug(""String_Node_Str"" + filepath);
  String filename=filepath.replaceAll(""String_Node_Str"",""String_Node_Str"");
  try {
    ObjectInputStream ois=new ObjectInputStream(new FileInputStream(new File(filepath)));
    Object object=ois.readObject();
    if (object instanceof String) {
      log.info(""String_Node_Str"" + (String)object + ""String_Node_Str""+ filename);
      object=ois.readObject();
    }
 else {
      log.info(""String_Node_Str"" + filename);
    }
    if (object instanceof String) {
      log.info(""String_Node_Str"" + (String)object);
      object=ois.readObject();
    }
    long versionID=(Long)object;
    log.debug(""String_Node_Str"" + versionID + ""String_Node_Str""+ object+ ""String_Node_Str"");
    long saveFileVersionID=GameManager.saveFileVersionID;
    if (versionID != saveFileVersionID) {
      throw new Exception(""String_Node_Str"" + versionID + ""String_Node_Str""+ saveFileVersionID);
    }
    String name=(String)ois.readObject();
    log.debug(""String_Node_Str"" + name);
    Map<String,String> selectedGameOptions=(Map<String,String>)ois.readObject();
    List<String> playerNames=(List<String>)ois.readObject();
    game=new Game(name,playerNames,selectedGameOptions);
    if (!game.setup()) {
      throw new ConfigurationException(""String_Node_Str"" + name);
    }
    List<PossibleAction> executedActions=(List<PossibleAction>)ois.readObject();
    ois.close();
    log.debug(""String_Node_Str"" + executedActions.size());
    String startError=game.start();
    if (startError != null) {
      DisplayBuffer.add(startError);
      return null;
    }
    log.debug(""String_Node_Str"");
    game.getGameManager().processOnReload(executedActions);
    return game;
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",e.getMessage()));
  }
  return null;
}",0.9642105263157896
173788,"public void start(){
  gameManager.startGame(gameOptions);
}","public String start(){
  if (players.size() < playerManager.minPlayers || players.size() > playerManager.maxPlayers) {
    return name + ""String_Node_Str"" + players.size()+ ""String_Node_Str""+ ""String_Node_Str""+ name+ ""String_Node_Str"";
  }
  gameManager.startGame(gameOptions);
  return null;
}",0.2937853107344633
173789,"public boolean buyTrain(BuyTrain action){
  TrainI train=action.getTrain();
  PublicCompanyI company=action.getCompany();
  String companyName=company.getName();
  TrainI exchangedTrain=action.getExchangedTrain();
  SpecialTrainBuy stb=null;
  String errMsg=null;
  int presidentCash=action.getPresidentCashToAdd();
  boolean presidentMustSellShares=false;
  int price=action.getPricePaid();
  int actualPresidentCash=0;
  Player currentPlayer=operatingCompany.getPresident();
  while (true) {
    if (getStep() != STEP_BUY_TRAIN) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (train == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (price < 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(price));
      break;
    }
    int trainLimit=operatingCompany.getCurrentTrainLimit();
    if (!canBuyTrain()) {
      errMsg=LocalText.getText(""String_Node_Str"",String.valueOf(trainLimit));
      break;
    }
    if (action.mustPresidentAddCash()) {
      presidentCash=action.getPresidentCashToAdd();
      if (currentPlayer.getCash() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCash();
      }
    }
 else     if (action.mayPresidentAddCash()) {
      presidentCash=price - operatingCompany.getCash();
      if (presidentCash > action.getPresidentCashToAdd()) {
        errMsg=LocalText.getText(""String_Node_Str"",Bank.format(action.getPresidentCashToAdd()));
        break;
      }
 else       if (currentPlayer.getCash() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCash();
      }
    }
 else {
      if (price > operatingCompany.getCash()) {
        errMsg=LocalText.getText(""String_Node_Str"",companyName,Bank.format(operatingCompany.getCash()),Bank.format(price));
        break;
      }
    }
    stb=action.getSpecialProperty();
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getName(),Bank.format(price),errMsg));
    return false;
  }
  moveStack.start(true);
  PhaseI previousPhase=getCurrentPhase();
  if (presidentMustSellShares) {
    savedAction=action;
    gameManager.startShareSellingRound(operatingCompany.getPresident(),cashToBeRaisedByPresident,operatingCompany);
    return true;
  }
  if (actualPresidentCash > 0) {
    new CashMove(currentPlayer,operatingCompany,presidentCash);
  }
  Portfolio oldHolder=train.getHolder();
  if (exchangedTrain != null) {
    TrainI oldTrain=operatingCompany.getPortfolio().getTrainOfType(exchangedTrain.getType());
    pool.buyTrain(oldTrain,0);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,exchangedTrain.getName(),train.getName(),oldHolder.getName(),Bank.format(price)));
  }
 else   if (stb == null) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getName(),oldHolder.getName(),Bank.format(price)));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getName(),oldHolder.getName(),Bank.format(price),stb.getCompany().getName()));
  }
  operatingCompany.buyTrain(train,price);
  if (oldHolder == ipo) {
    train.getType().addToBoughtFromIPO();
    if (train.getType().hasInfiniteAmount()) {
      ipo.addTrain(train.getType().cloneTrain());
    }
  }
  if (oldHolder.getOwner() instanceof Bank) {
    trainsBoughtThisTurn.add(train.getType());
  }
  if (stb != null) {
    stb.setExercised();
    log.debug(""String_Node_Str"");
  }
  gameManager.getTrainManager().checkTrainAvailability(train,oldHolder);
  currentPhase=getCurrentPhase();
  if (currentPhase != previousPhase && checkForExcessTrains()) {
    stepObject.set(STEP_DISCARD_TRAINS);
  }
  return true;
}","public boolean buyTrain(BuyTrain action){
  TrainI train=action.getTrain();
  PublicCompanyI company=action.getCompany();
  String companyName=company.getName();
  TrainI exchangedTrain=action.getExchangedTrain();
  SpecialTrainBuy stb=null;
  String errMsg=null;
  int presidentCash=action.getPresidentCashToAdd();
  boolean presidentMustSellShares=false;
  int price=action.getPricePaid();
  int actualPresidentCash=0;
  Player currentPlayer=operatingCompany.getPresident();
  while (true) {
    if (getStep() != STEP_BUY_TRAIN) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (train == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (price < 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(price));
      break;
    }
    int trainLimit=operatingCompany.getCurrentTrainLimit();
    if (!isBelowTrainLimit() && !action.isForcedExchange()) {
      errMsg=LocalText.getText(""String_Node_Str"",String.valueOf(trainLimit));
      break;
    }
    if (action.mustPresidentAddCash()) {
      presidentCash=action.getPresidentCashToAdd();
      if (currentPlayer.getCash() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCash();
      }
    }
 else     if (action.mayPresidentAddCash()) {
      presidentCash=price - operatingCompany.getCash();
      if (presidentCash > action.getPresidentCashToAdd()) {
        errMsg=LocalText.getText(""String_Node_Str"",Bank.format(action.getPresidentCashToAdd()));
        break;
      }
 else       if (currentPlayer.getCash() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCash();
      }
    }
 else {
      if (price > operatingCompany.getCash()) {
        errMsg=LocalText.getText(""String_Node_Str"",companyName,Bank.format(operatingCompany.getCash()),Bank.format(price));
        break;
      }
    }
    stb=action.getSpecialProperty();
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getName(),Bank.format(price),errMsg));
    return false;
  }
  moveStack.start(true);
  PhaseI previousPhase=getCurrentPhase();
  if (presidentMustSellShares) {
    savedAction=action;
    gameManager.startShareSellingRound(operatingCompany.getPresident(),cashToBeRaisedByPresident,operatingCompany);
    return true;
  }
  if (actualPresidentCash > 0) {
    new CashMove(currentPlayer,operatingCompany,presidentCash);
  }
  Portfolio oldHolder=train.getHolder();
  if (exchangedTrain != null) {
    TrainI oldTrain=operatingCompany.getPortfolio().getTrainOfType(exchangedTrain.getType());
    pool.buyTrain(oldTrain,0);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,exchangedTrain.getName(),train.getName(),oldHolder.getName(),Bank.format(price)));
  }
 else   if (stb == null) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getName(),oldHolder.getName(),Bank.format(price)));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",companyName,train.getName(),oldHolder.getName(),Bank.format(price),stb.getCompany().getName()));
  }
  operatingCompany.buyTrain(train,price);
  if (oldHolder == ipo) {
    train.getType().addToBoughtFromIPO();
    if (train.getType().hasInfiniteAmount()) {
      ipo.addTrain(train.getType().cloneTrain());
    }
  }
  if (oldHolder.getOwner() instanceof Bank) {
    trainsBoughtThisTurn.add(train.getType());
  }
  if (stb != null) {
    stb.setExercised();
    log.debug(""String_Node_Str"");
  }
  gameManager.getTrainManager().checkTrainAvailability(train,oldHolder);
  currentPhase=getCurrentPhase();
  if (currentPhase != previousPhase && checkForExcessTrains()) {
    stepObject.set(STEP_DISCARD_TRAINS);
  }
  return true;
}",0.9929328621908128
173790,"/** 
 * Get a list of buyable trains for the currently operating company. Omit trains that the company has no money for. If there is no cash to buy any train from the Bank, prepare for emergency train buying.
 */
public void setBuyableTrains(){
  if (operatingCompany == null)   return;
  TrainManager trainMgr=gameManager.getTrainManager();
  int cash=operatingCompany.getCash();
  int cost;
  List<TrainI> trains;
  boolean hasTrains=operatingCompany.getPortfolio().getNumberOfTrains() > 0;
  boolean atTrainLimit=operatingCompany.getNumberOfTrains() >= operatingCompany.getCurrentTrainLimit();
  boolean canBuyTrainNow=canBuyTrain();
  boolean presidentMayHelp=!hasTrains && operatingCompany.mustOwnATrain();
  TrainI cheapestTrain=null;
  int costOfCheapestTrain=0;
  if (currentPhase.canBuyMoreTrainsPerTurn() || trainsBoughtThisTurn.isEmpty()) {
    boolean mayBuyMoreOfEachType=currentPhase.canBuyMoreTrainsPerTypePerTurn();
    trains=trainMgr.getAvailableNewTrains();
    for (    TrainI train : trains) {
      if (!mayBuyMoreOfEachType && trainsBoughtThisTurn.contains(train.getType())) {
        continue;
      }
      cost=train.getCost();
      if (cost <= cash) {
        if (canBuyTrainNow)         possibleActions.add(new BuyTrain(train,ipo,cost));
      }
 else       if (costOfCheapestTrain == 0 || cost < costOfCheapestTrain) {
        cheapestTrain=train;
        costOfCheapestTrain=cost;
      }
      if (train.canBeExchanged() && hasTrains) {
        cost=train.getType().getFirstExchangeCost();
        if (cost <= cash) {
          List<TrainI> exchangeableTrains=operatingCompany.getPortfolio().getUniqueTrains();
          BuyTrain action=new BuyTrain(train,ipo,cost);
          action.setTrainsForExchange(exchangeableTrains);
          if (atTrainLimit)           action.setForcedExchange(true);
          possibleActions.add(action);
        }
      }
      if (!canBuyTrainNow)       return;
      for (      SpecialTrainBuy stb : getSpecialProperties(SpecialTrainBuy.class)) {
        int reducedPrice=stb.getPrice(cost);
        if (reducedPrice > cash)         continue;
        BuyTrain bt=new BuyTrain(train,ipo,reducedPrice);
        bt.setSpecialProperty(stb);
        possibleActions.add(bt);
      }
    }
    if (!canBuyTrainNow)     return;
    trains=pool.getUniqueTrains();
    for (    TrainI train : trains) {
      if (!mayBuyMoreOfEachType && trainsBoughtThisTurn.contains(train.getType())) {
        continue;
      }
      cost=train.getCost();
      if (cost <= cash) {
        possibleActions.add(new BuyTrain(train,pool,cost));
      }
 else       if (costOfCheapestTrain == 0 || cost < costOfCheapestTrain) {
        cheapestTrain=train;
        costOfCheapestTrain=cost;
      }
    }
    if (!hasTrains && possibleActions.getType(BuyTrain.class).isEmpty() && cheapestTrain != null && presidentMayHelp) {
      possibleActions.add(new BuyTrain(cheapestTrain,cheapestTrain.getHolder(),costOfCheapestTrain).setPresidentMustAddCash(costOfCheapestTrain - cash));
    }
  }
  if (!canBuyTrainNow)   return;
  if (currentPhase.isTrainTradingAllowed()) {
    PublicCompanyI c;
    BuyTrain bt;
    Player p;
    Portfolio pf;
    int index;
    List<List<PublicCompanyI>> companiesPerPlayer=new ArrayList<List<PublicCompanyI>>(numberOfPlayers);
    for (int i=0; i < numberOfPlayers; i++)     companiesPerPlayer.add(new ArrayList<PublicCompanyI>(4));
    List<PublicCompanyI> companies;
    for (int j=0; j < operatingCompanyArray.length; j++) {
      c=operatingCompanyArray[j];
      if (c.isClosed() || c == operatingCompany)       continue;
      p=c.getPresident();
      index=p.getIndex();
      companiesPerPlayer.get(index).add(c);
    }
    int currentPlayerIndex=operatingCompany.getPresident().getIndex();
    for (int i=currentPlayerIndex; i < currentPlayerIndex + numberOfPlayers; i++) {
      companies=companiesPerPlayer.get(i % numberOfPlayers);
      for (      PublicCompanyI company : companies) {
        pf=company.getPortfolio();
        trains=pf.getUniqueTrains();
        for (        TrainI train : trains) {
          if (train.isObsolete())           continue;
          if (i != currentPlayerIndex && trainMgr.buyAtFaceValueBetweenDifferentPresidents() || operatingCompany.mustTradeTrainsAtFixedPrice() || company.mustTradeTrainsAtFixedPrice()) {
            if (cash >= train.getCost()) {
              bt=new BuyTrain(train,pf,train.getCost());
            }
 else {
              continue;
            }
          }
 else {
            bt=new BuyTrain(train,pf,0);
          }
          if (presidentMayHelp && cash < train.getCost()) {
            bt.setPresidentMayAddCash(train.getCost() - cash);
          }
          possibleActions.add(bt);
        }
      }
    }
  }
  if (!operatingCompany.mustOwnATrain() || operatingCompany.getPortfolio().getNumberOfTrains() > 0) {
    doneAllowed=true;
  }
}","/** 
 * Get a list of buyable trains for the currently operating company. Omit trains that the company has no money for. If there is no cash to buy any train from the Bank, prepare for emergency train buying.
 */
public void setBuyableTrains(){
  if (operatingCompany == null)   return;
  TrainManager trainMgr=gameManager.getTrainManager();
  int cash=operatingCompany.getCash();
  int cost;
  List<TrainI> trains;
  boolean hasTrains=operatingCompany.getPortfolio().getNumberOfTrains() > 0;
  boolean atTrainLimit=operatingCompany.getNumberOfTrains() >= operatingCompany.getCurrentTrainLimit();
  boolean canBuyTrainNow=isBelowTrainLimit();
  boolean presidentMayHelp=!hasTrains && operatingCompany.mustOwnATrain();
  TrainI cheapestTrain=null;
  int costOfCheapestTrain=0;
  if (currentPhase.canBuyMoreTrainsPerTurn() || trainsBoughtThisTurn.isEmpty()) {
    boolean mayBuyMoreOfEachType=currentPhase.canBuyMoreTrainsPerTypePerTurn();
    trains=trainMgr.getAvailableNewTrains();
    for (    TrainI train : trains) {
      if (!mayBuyMoreOfEachType && trainsBoughtThisTurn.contains(train.getType())) {
        continue;
      }
      cost=train.getCost();
      if (cost <= cash) {
        if (canBuyTrainNow)         possibleActions.add(new BuyTrain(train,ipo,cost));
      }
 else       if (costOfCheapestTrain == 0 || cost < costOfCheapestTrain) {
        cheapestTrain=train;
        costOfCheapestTrain=cost;
      }
      if (train.canBeExchanged() && hasTrains) {
        cost=train.getType().getFirstExchangeCost();
        if (cost <= cash) {
          List<TrainI> exchangeableTrains=operatingCompany.getPortfolio().getUniqueTrains();
          BuyTrain action=new BuyTrain(train,ipo,cost);
          action.setTrainsForExchange(exchangeableTrains);
          if (atTrainLimit)           action.setForcedExchange(true);
          possibleActions.add(action);
          canBuyTrainNow=true;
        }
      }
      if (!canBuyTrainNow)       continue;
      for (      SpecialTrainBuy stb : getSpecialProperties(SpecialTrainBuy.class)) {
        int reducedPrice=stb.getPrice(cost);
        if (reducedPrice > cash)         continue;
        BuyTrain bt=new BuyTrain(train,ipo,reducedPrice);
        bt.setSpecialProperty(stb);
        possibleActions.add(bt);
      }
    }
    if (!canBuyTrainNow)     return;
    trains=pool.getUniqueTrains();
    for (    TrainI train : trains) {
      if (!mayBuyMoreOfEachType && trainsBoughtThisTurn.contains(train.getType())) {
        continue;
      }
      cost=train.getCost();
      if (cost <= cash) {
        possibleActions.add(new BuyTrain(train,pool,cost));
      }
 else       if (costOfCheapestTrain == 0 || cost < costOfCheapestTrain) {
        cheapestTrain=train;
        costOfCheapestTrain=cost;
      }
    }
    if (!hasTrains && possibleActions.getType(BuyTrain.class).isEmpty() && cheapestTrain != null && presidentMayHelp) {
      possibleActions.add(new BuyTrain(cheapestTrain,cheapestTrain.getHolder(),costOfCheapestTrain).setPresidentMustAddCash(costOfCheapestTrain - cash));
    }
  }
  if (!canBuyTrainNow)   return;
  if (currentPhase.isTrainTradingAllowed()) {
    PublicCompanyI c;
    BuyTrain bt;
    Player p;
    Portfolio pf;
    int index;
    List<List<PublicCompanyI>> companiesPerPlayer=new ArrayList<List<PublicCompanyI>>(numberOfPlayers);
    for (int i=0; i < numberOfPlayers; i++)     companiesPerPlayer.add(new ArrayList<PublicCompanyI>(4));
    List<PublicCompanyI> companies;
    for (int j=0; j < operatingCompanyArray.length; j++) {
      c=operatingCompanyArray[j];
      if (c.isClosed() || c == operatingCompany)       continue;
      p=c.getPresident();
      index=p.getIndex();
      companiesPerPlayer.get(index).add(c);
    }
    int currentPlayerIndex=operatingCompany.getPresident().getIndex();
    for (int i=currentPlayerIndex; i < currentPlayerIndex + numberOfPlayers; i++) {
      companies=companiesPerPlayer.get(i % numberOfPlayers);
      for (      PublicCompanyI company : companies) {
        pf=company.getPortfolio();
        trains=pf.getUniqueTrains();
        for (        TrainI train : trains) {
          if (train.isObsolete())           continue;
          if (i != currentPlayerIndex && trainMgr.buyAtFaceValueBetweenDifferentPresidents() || operatingCompany.mustTradeTrainsAtFixedPrice() || company.mustTradeTrainsAtFixedPrice()) {
            if (cash >= train.getCost()) {
              bt=new BuyTrain(train,pf,train.getCost());
            }
 else {
              continue;
            }
          }
 else {
            bt=new BuyTrain(train,pf,0);
          }
          if (presidentMayHelp && cash < train.getCost()) {
            bt.setPresidentMayAddCash(train.getCost() - cash);
          }
          possibleActions.add(bt);
        }
      }
    }
  }
  if (!operatingCompany.mustOwnATrain() || operatingCompany.getPortfolio().getNumberOfTrains() > 0) {
    doneAllowed=true;
  }
}",0.992766174223128
173791,"/** 
 * Get the player's total worth.
 * @return Total worth
 */
public int getWorth(){
  int worth=wallet.getCash();
  for (  PublicCertificateI cert : portfolio.getCertificates()) {
    worth+=cert.getCompany().getGameEndPrice();
  }
  for (  PrivateCompanyI priv : portfolio.getPrivateCompanies()) {
    worth+=priv.getBasePrice();
  }
  return worth;
}","/** 
 * Get the player's total worth.
 * @return Total worth
 */
public int getWorth(){
  int worth=wallet.getCash();
  for (  PublicCertificateI cert : portfolio.getCertificates()) {
    worth+=cert.getCompany().getGameEndPrice() * cert.getShares();
  }
  for (  PrivateCompanyI priv : portfolio.getPrivateCompanies()) {
    worth+=priv.getBasePrice();
  }
  return worth;
}",0.9740082079343364
173792,"/** 
 * Register a bid. <p> This method does <b>not</b> check off the amount of money that a player has available for bidding.
 * @param amount The bid amount.
 * @param bidder The bidding player.
 */
public void setBid(int amount,Player bidder){
  int index=bidder.getIndex();
  bids[index].set(amount);
  if (amount > 0) {
    lastBidderIndex.set(index);
    minimumBid.set(amount + 5);
  }
 else   if (amount == 0) {
    bids[index].resetOption(MoneyModel.SUPPRESS_ZERO);
    bids[index].update();
  }
}","/** 
 * Register a bid. <p> This method does <b>not</b> check off the amount of money that a player has available for bidding.
 * @param amount The bid amount.
 * @param bidder The bidding player.
 */
public void setBid(int amount,Player bidder){
  int index=bidder.getIndex();
  bids[index].set(amount);
  if (amount > 0) {
    lastBidderIndex.set(index);
    minimumBid.set(amount + 5);
  }
 else   if (amount == 0) {
    bids[index].resetOption(MoneyModel.SUPPRESS_ZERO);
    bids[index].update();
  }
 else {
    bids[index].set(0);
    bids[index].update();
  }
}",0.9422718808193667
173793,"/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(String playerName){
  String errMsg=null;
  Player player=getCurrentPlayer();
  StartItem auctionItem=(StartItem)auctionItemState.getObject();
  while (true) {
    if (!playerName.equals(player.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName));
  moveStack.start(false);
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.intValue() >= auctionItem.getBidders() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getName());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
    }
 else {
      setNextBiddingPlayer(auctionItem,getCurrentPlayerIndex());
    }
  }
 else {
    if (numPasses.intValue() >= numPlayers) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str""));
      if (startPacket.getFirstUnsoldItem() == startPacket.getFirstItem()) {
        startPacket.getFirstItem().reduceBasePriceBy(5);
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",startPacket.getFirstItem().getName(),Bank.format(startPacket.getFirstItem().getBasePrice())));
        numPasses.set(0);
        if (startPacket.getFirstItem().getBasePrice() == 0) {
          assignItem(getCurrentPlayer(),startPacket.getFirstItem(),0,0);
          gameManager.setPriorityPlayer();
        }
      }
 else {
        numPasses.set(0);
        finishRound();
      }
    }
 else     if (auctionItem != null) {
      setNextBiddingPlayer(auctionItem);
    }
 else {
      setNextPlayer();
    }
  }
  return true;
}","/** 
 * Process a player's pass.
 * @param playerName The name of the current player (for checking purposes).
 */
@Override protected boolean pass(String playerName){
  String errMsg=null;
  Player player=getCurrentPlayer();
  StartItem auctionItem=(StartItem)auctionItemState.getObject();
  while (true) {
    if (!playerName.equals(player.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,errMsg));
    return false;
  }
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName));
  moveStack.start(false);
  numPasses.add(1);
  if (auctionItem != null) {
    if (numPasses.intValue() >= auctionItem.getBidders() - 1) {
      int price=auctionItem.getBid();
      log.debug(""String_Node_Str"" + auctionItem.getBidder().getName());
      if (auctionItem.needsPriceSetting() != null) {
        auctionItem.setStatus(StartItem.NEEDS_SHARE_PRICE);
      }
 else {
        assignItem(auctionItem.getBidder(),auctionItem,price,0);
      }
      auctionItemState.set(null);
      numPasses.set(0);
    }
 else {
      auctionItem.setBid(-1,player);
      setNextBiddingPlayer(auctionItem,getCurrentPlayerIndex());
    }
  }
 else {
    if (numPasses.intValue() >= numPlayers) {
      ReportBuffer.add(LocalText.getText(""String_Node_Str""));
      if (startPacket.getFirstUnsoldItem() == startPacket.getFirstItem()) {
        startPacket.getFirstItem().reduceBasePriceBy(5);
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",startPacket.getFirstItem().getName(),Bank.format(startPacket.getFirstItem().getBasePrice())));
        numPasses.set(0);
        if (startPacket.getFirstItem().getBasePrice() == 0) {
          assignItem(getCurrentPlayer(),startPacket.getFirstItem(),0,0);
          gameManager.setPriorityPlayer();
        }
      }
 else {
        numPasses.set(0);
        finishRound();
      }
    }
 else     if (auctionItem != null) {
      setNextBiddingPlayer(auctionItem);
    }
 else {
      setNextPlayer();
    }
  }
  return true;
}",0.991192573196858
173794,"protected boolean isAllowedForHex(MapHex hex,String phaseName){
  if (allowedPhases != null && !allowedPhases.contains(phaseName)) {
    return false;
  }
  if (hexes != null)   convertHexString(hex.getMapManager());
  if (allowedHexes != null) {
    return allowedHexes.contains(hex);
  }
 else   if (disallowedHexes != null) {
    return !disallowedHexes.contains(hex);
  }
 else {
    return true;
  }
}","protected boolean isAllowedForHex(MapHex hex){
  if (hexes != null)   convertHexString(hex.getMapManager());
  if (allowedHexes != null) {
    return allowedHexes.contains(hex);
  }
 else   if (disallowedHexes != null) {
    return !disallowedHexes.contains(hex);
  }
 else {
    return true;
  }
}",0.8409090909090909
173795,"public String getUpgradesString(MapHex hex){
  return upgradesString;
}","/** 
 * Get a delimited list of all possible upgrades, regardless current phase 
 */
public String getUpgradesString(MapHex hex){
  StringBuffer b=new StringBuffer();
  TileI tile;
  for (  Upgrade upgrade : upgrades) {
    tile=upgrade.getTile();
    if (upgrade.isAllowedForHex(hex)) {
      if (b.length() > 0)       b.append(""String_Node_Str"");
      b.append(tile.getExternalId());
    }
  }
  return b.toString();
}",0.1747967479674796
173796,"/** 
 * Modify possibleActions to follow the Pullmann train trading rules.
 */
@Override public void setBuyableTrains(){
  if (operatingCompany == null)   return;
  TrainManager trainMgr=gameManager.getTrainManager();
  int cash=operatingCompany.getCash();
  int cost;
  List<TrainI> trains;
  boolean hasTrains=operatingCompany.getPortfolio().getNumberOfTrains() > 0;
  boolean atTrainLimit=operatingCompany.getNumberOfTrains() >= operatingCompany.getCurrentTrainLimit();
  boolean canBuyTrainNow=canBuyTrain();
  boolean presidentMayHelp=operatingCompany.mustOwnATrain();
  TrainI cheapestTrain=null;
  int costOfCheapestTrain=0;
  TrainI ownedPTrain=null;
  if (hasTrains) {
    ownedPTrain=operatingCompany.getPortfolio().getTrainOfType(pullmannType);
  }
  trains=trainMgr.getAvailableNewTrains();
  for (  TrainI train : trains) {
    cost=train.getCost();
    if (cost <= cash) {
      if (canBuyTrainNow)       possibleActions.add(new BuyTrain(train,ipo,cost));
    }
 else     if (costOfCheapestTrain == 0 || cost < costOfCheapestTrain) {
      cheapestTrain=train;
      costOfCheapestTrain=cost;
    }
    if (atTrainLimit && ownedPTrain != null) {
      BuyTrain action=new BuyTrain(train,ipo,cost);
      List<TrainI> pTrains=new ArrayList<TrainI>();
      pTrains.add(ownedPTrain);
      action.setTrainsForExchange(pTrains);
      action.setForcedExchange(true);
      possibleActions.add(action);
    }
    if (!canBuyTrainNow)     return;
  }
  if (!canBuyTrainNow)   return;
  trains=pool.getUniqueTrains();
  for (  TrainI train : trains) {
    if ((ownedPTrain != null || !hasTrains) && train.getType().getName().equals(""String_Node_Str"")) {
      continue;
    }
    cost=train.getCost();
    if (cost <= cash) {
      possibleActions.add(new BuyTrain(train,pool,cost));
    }
 else     if (costOfCheapestTrain == 0 || cost < costOfCheapestTrain) {
      cheapestTrain=train;
      costOfCheapestTrain=cost;
    }
  }
  if (!hasTrains && presidentMayHelp && possibleActions.getType(BuyTrain.class).isEmpty()&& cheapestTrain != null) {
    possibleActions.add(new BuyTrain(cheapestTrain,cheapestTrain.getHolder(),costOfCheapestTrain).setPresidentMustAddCash(costOfCheapestTrain - cash));
  }
  if (!canBuyTrainNow)   return;
  if (currentPhase.isTrainTradingAllowed()) {
    PublicCompanyI c;
    BuyTrain bt;
    Player p;
    Portfolio pf;
    int index;
    List<List<PublicCompanyI>> companiesPerPlayer=new ArrayList<List<PublicCompanyI>>(numberOfPlayers);
    for (int i=0; i < numberOfPlayers; i++)     companiesPerPlayer.add(new ArrayList<PublicCompanyI>(4));
    List<PublicCompanyI> companies;
    for (int j=0; j < operatingCompanyArray.length; j++) {
      c=operatingCompanyArray[j];
      if (c == operatingCompany)       continue;
      p=c.getPresident();
      index=p.getIndex();
      companiesPerPlayer.get(index).add(c);
    }
    int currentPlayerIndex=operatingCompany.getPresident().getIndex();
    for (int i=currentPlayerIndex; i < currentPlayerIndex + numberOfPlayers; i++) {
      companies=companiesPerPlayer.get(i % numberOfPlayers);
      for (      PublicCompanyI company : companies) {
        pf=company.getPortfolio();
        trains=pf.getUniqueTrains();
        for (        TrainI train : trains) {
          if (train.getType().getName().equals(""String_Node_Str""))           continue;
          bt=new BuyTrain(train,pf,0);
          possibleActions.add(bt);
        }
      }
    }
  }
}","/** 
 * Modify possibleActions to follow the Pullmann train trading rules.
 */
@Override public void setBuyableTrains(){
  if (operatingCompany == null)   return;
  TrainManager trainMgr=gameManager.getTrainManager();
  int cash=operatingCompany.getCash();
  int cost;
  List<TrainI> trains;
  boolean hasTrains=operatingCompany.getPortfolio().getNumberOfTrains() > 0;
  boolean atTrainLimit=operatingCompany.getNumberOfTrains() >= operatingCompany.getCurrentTrainLimit();
  boolean canBuyTrainNow=isBelowTrainLimit();
  boolean presidentMayHelp=operatingCompany.mustOwnATrain();
  TrainI cheapestTrain=null;
  int costOfCheapestTrain=0;
  TrainI ownedPTrain=null;
  if (hasTrains) {
    ownedPTrain=operatingCompany.getPortfolio().getTrainOfType(pullmannType);
  }
  trains=trainMgr.getAvailableNewTrains();
  for (  TrainI train : trains) {
    cost=train.getCost();
    if (cost <= cash) {
      if (canBuyTrainNow)       possibleActions.add(new BuyTrain(train,ipo,cost));
    }
 else     if (costOfCheapestTrain == 0 || cost < costOfCheapestTrain) {
      cheapestTrain=train;
      costOfCheapestTrain=cost;
    }
    if (atTrainLimit && ownedPTrain != null) {
      BuyTrain action=new BuyTrain(train,ipo,cost);
      List<TrainI> pTrains=new ArrayList<TrainI>();
      pTrains.add(ownedPTrain);
      action.setTrainsForExchange(pTrains);
      action.setForcedExchange(true);
      possibleActions.add(action);
    }
    if (!canBuyTrainNow)     return;
  }
  if (!canBuyTrainNow)   return;
  trains=pool.getUniqueTrains();
  for (  TrainI train : trains) {
    if ((ownedPTrain != null || !hasTrains) && train.getType().getName().equals(""String_Node_Str"")) {
      continue;
    }
    cost=train.getCost();
    if (cost <= cash) {
      possibleActions.add(new BuyTrain(train,pool,cost));
    }
 else     if (costOfCheapestTrain == 0 || cost < costOfCheapestTrain) {
      cheapestTrain=train;
      costOfCheapestTrain=cost;
    }
  }
  if (!hasTrains && presidentMayHelp && possibleActions.getType(BuyTrain.class).isEmpty()&& cheapestTrain != null) {
    possibleActions.add(new BuyTrain(cheapestTrain,cheapestTrain.getHolder(),costOfCheapestTrain).setPresidentMustAddCash(costOfCheapestTrain - cash));
  }
  if (!canBuyTrainNow)   return;
  if (currentPhase.isTrainTradingAllowed()) {
    PublicCompanyI c;
    BuyTrain bt;
    Player p;
    Portfolio pf;
    int index;
    List<List<PublicCompanyI>> companiesPerPlayer=new ArrayList<List<PublicCompanyI>>(numberOfPlayers);
    for (int i=0; i < numberOfPlayers; i++)     companiesPerPlayer.add(new ArrayList<PublicCompanyI>(4));
    List<PublicCompanyI> companies;
    for (int j=0; j < operatingCompanyArray.length; j++) {
      c=operatingCompanyArray[j];
      if (c == operatingCompany)       continue;
      p=c.getPresident();
      index=p.getIndex();
      companiesPerPlayer.get(index).add(c);
    }
    int currentPlayerIndex=operatingCompany.getPresident().getIndex();
    for (int i=currentPlayerIndex; i < currentPlayerIndex + numberOfPlayers; i++) {
      companies=companiesPerPlayer.get(i % numberOfPlayers);
      for (      PublicCompanyI company : companies) {
        pf=company.getPortfolio();
        trains=pf.getUniqueTrains();
        for (        TrainI train : trains) {
          if (train.getType().getName().equals(""String_Node_Str""))           continue;
          bt=new BuyTrain(train,pf,0);
          possibleActions.add(bt);
        }
      }
    }
  }
}",0.996230791533778
173797,"private void startNewGame(){
  try {
    for (int i=0; i < playerBoxes.length; i++) {
      if (playerBoxes[i] != null && playerBoxes[i].getSelectedIndex() == HUMAN_PLAYER && !playerNameFields[i].getText().equals(""String_Node_Str"")) {
        playerNames.add(playerNameFields[i].getText());
      }
    }
    if (playerNames.size() < Player.MIN_PLAYERS || playerNames.size() > Player.MAX_PLAYERS) {
      if (JOptionPane.showConfirmDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
        return;
      }
    }
  }
 catch (  NullPointerException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this,""String_Node_Str"");
    System.exit(-1);
  }
  if (optionsPane.isVisible()) {
    GameOption option;
    JCheckBox checkbox;
    JComboBox dropdown;
    String value;
    for (int i=0; i < availableOptions.size(); i++) {
      option=availableOptions.get(i);
      if (option.isBoolean()) {
        checkbox=(JCheckBox)optionComponents.get(i);
        value=checkbox.isSelected() ? ""String_Node_Str"" : ""String_Node_Str"";
      }
 else {
        dropdown=(JComboBox)optionComponents.get(i);
        value=(String)dropdown.getSelectedItem();
      }
      selectedOptions.put(option.getName(),value);
      log.info(""String_Node_Str"" + option.getName() + ""String_Node_Str""+ value);
    }
  }
 else {
    GameOption option;
    String value;
    for (int i=0; i < availableOptions.size(); i++) {
      option=availableOptions.get(i);
      value=option.getDefaultValue();
      selectedOptions.put(option.getName(),value);
      log.info(""String_Node_Str"" + option.getName() + ""String_Node_Str""+ value);
    }
  }
  game=new Game(gameName,playerNames,selectedOptions);
  if (!game.setup()) {
    JOptionPane.showMessageDialog(this,DisplayBuffer.get(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(-1);
  }
 else {
    game.start();
    startGameUIManager(game);
    gameUIManager.gameUIInit();
  }
  this.setVisible(false);
}","private void startNewGame(){
  try {
    for (int i=0; i < playerBoxes.length; i++) {
      if (playerBoxes[i] != null && playerBoxes[i].getSelectedIndex() == HUMAN_PLAYER && !playerNameFields[i].getText().equals(""String_Node_Str"")) {
        playerNames.add(playerNameFields[i].getText());
      }
    }
    if (playerNames.size() < Player.MIN_PLAYERS || playerNames.size() > Player.MAX_PLAYERS) {
      if (JOptionPane.showConfirmDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
        return;
      }
    }
  }
 catch (  NullPointerException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(this,""String_Node_Str"");
    System.exit(-1);
  }
  if (optionsPane.isVisible()) {
    GameOption option;
    JCheckBox checkbox;
    JComboBox dropdown;
    String value;
    for (int i=0; i < availableOptions.size(); i++) {
      option=availableOptions.get(i);
      if (option.isBoolean()) {
        checkbox=(JCheckBox)optionComponents.get(i);
        value=checkbox.isSelected() ? ""String_Node_Str"" : ""String_Node_Str"";
      }
 else {
        dropdown=(JComboBox)optionComponents.get(i);
        value=(String)dropdown.getSelectedItem();
      }
      selectedOptions.put(option.getName(),value);
      log.info(""String_Node_Str"" + option.getName() + ""String_Node_Str""+ value);
    }
  }
 else {
    GameOption option;
    String value;
    for (int i=0; i < availableOptions.size(); i++) {
      option=availableOptions.get(i);
      value=option.getDefaultValue();
      selectedOptions.put(option.getName(),value);
      log.info(""String_Node_Str"" + option.getName() + ""String_Node_Str""+ value);
    }
  }
  game=new Game(gameName,playerNames,selectedOptions);
  if (!game.setup()) {
    JOptionPane.showMessageDialog(this,DisplayBuffer.get(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    System.exit(-1);
  }
 else {
    String startError=game.start();
    if (startError != null) {
      JOptionPane.showMessageDialog(this,startError,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      System.exit(-1);
    }
    startGameUIManager(game);
    gameUIManager.gameUIInit();
  }
  this.setVisible(false);
}",0.9520171878730008
173798,"private void init(){
  TileManager tmgr=gameUIManager.getGameManager().getTileManager();
  TileI tile;
  Field label;
  BufferedImage hexImage;
  ImageIcon hexIcon;
  List<Integer> tileIds=tmgr.getTileIds();
  log.debug(""String_Node_Str"" + tileIds.size() + ""String_Node_Str"");
  for (  int tileId : tileIds) {
    if (tileId <= 0)     continue;
    tile=tmgr.getTile(tileId);
    hexImage=GameUIManager.getImageLoader().getTile(tileId);
    hexIcon=new ImageIcon(hexImage);
    hexIcon.setImage(hexIcon.getImage().getScaledInstance((int)(hexIcon.getIconWidth() * GUIHex.NORMAL_SCALE * 0.8),(int)(hexIcon.getIconHeight() * GUIHex.NORMAL_SCALE * 0.8),Image.SCALE_SMOOTH));
    label=new Field((ModelObject)tile,hexIcon,Field.CENTER);
    label.setVerticalTextPosition(Field.BOTTOM);
    label.setHorizontalTextPosition(Field.CENTER);
    label.setVisible(true);
    getContentPane().add(label);
    shownTiles.add(tile);
    labels.add(label);
  }
}","private void init(GameUIManager gameUIManager){
  TileManager tmgr=gameUIManager.getGameManager().getTileManager();
  TileI tile;
  Field label;
  BufferedImage hexImage;
  ImageIcon hexIcon;
  List<Integer> tileIds=tmgr.getTileIds();
  log.debug(""String_Node_Str"" + tileIds.size() + ""String_Node_Str"");
  for (  int tileId : tileIds) {
    if (tileId <= 0)     continue;
    tile=tmgr.getTile(tileId);
    hexImage=GameUIManager.getImageLoader().getTile(tileId);
    hexIcon=new ImageIcon(hexImage);
    hexIcon.setImage(hexIcon.getImage().getScaledInstance((int)(hexIcon.getIconWidth() * GUIHex.NORMAL_SCALE * 0.8),(int)(hexIcon.getIconHeight() * GUIHex.NORMAL_SCALE * 0.8),Image.SCALE_SMOOTH));
    label=new Field((ModelObject)tile,hexIcon,Field.CENTER);
    label.setVerticalTextPosition(Field.BOTTOM);
    label.setHorizontalTextPosition(Field.CENTER);
    label.setVisible(true);
    getContentPane().add(label);
    shownTiles.add(tile);
    labels.add(label);
  }
}",0.9859448204060384
173799,"public RemainingTilesWindow(ORWindow orWindow){
  super();
  getContentPane().setLayout(new GridLayout(0,COLUMNS,5,5));
  setTitle(""String_Node_Str"");
  setVisible(false);
  setSize(800,600);
  addWindowListener(this);
  init();
  this.setDefaultCloseOperation(WindowConstants.HIDE_ON_CLOSE);
  this.setLocationRelativeTo(orWindow);
  pack();
  setVisible(true);
}","public RemainingTilesWindow(ORWindow orWindow){
  super();
  getContentPane().setLayout(new GridLayout(0,COLUMNS,5,5));
  setTitle(""String_Node_Str"");
  setVisible(false);
  setSize(800,600);
  addWindowListener(this);
  init(orWindow.getGameUIManager());
  this.setDefaultCloseOperation(WindowConstants.HIDE_ON_CLOSE);
  this.setLocationRelativeTo(orWindow);
  pack();
  setVisible(true);
}",0.9642384105960264
173800,"public void initTurn(int actorIndex){
  int i, j;
  dummyButton.setSelected(true);
  if ((j=this.actorIndex) >= 0) {
    upperPlayerCaption[j].setHighlight(false);
    lowerPlayerCaption[j].setHighlight(false);
    for (i=0; i < nc; i++) {
      setPlayerCertButton(i,j,false);
    }
  }
 else   if (j == -1 && compCanHoldOwnShares) {
    treasurySharesCaption.setHighlight(false);
  }
  for (i=0; i < nc; i++) {
    setIPOCertButton(i,false);
    setPoolCertButton(i,false);
    if (compCanHoldOwnShares)     setTreasuryCertButton(i,false);
  }
  this.actorIndex=actorIndex;
  if ((j=this.actorIndex) >= -1) {
    if (j >= 0) {
      upperPlayerCaption[j].setHighlight(true);
      lowerPlayerCaption[j].setHighlight(true);
    }
 else     if (j == -1 && treasurySharesCaption != null) {
      treasurySharesCaption.setHighlight(true);
    }
    PublicCertificateI cert;
    Portfolio holder;
    int index;
    List<BuyCertificate> buyableCerts=possibleActions.getType(BuyCertificate.class);
    if (buyableCerts != null) {
      for (      BuyCertificate bCert : buyableCerts) {
        cert=bCert.getCertificate();
        index=cert.getCompany().getPublicNumber();
        holder=bCert.getFromPortfolio();
        if (holder == ipo) {
          setIPOCertButton(index,true,bCert);
        }
 else         if (holder == pool) {
          setPoolCertButton(index,true,bCert);
        }
 else         if (compCanHoldOwnShares) {
          setTreasuryCertButton(index,true,bCert);
        }
      }
    }
    PublicCompanyI company;
    List<SellShares> sellableShares=possibleActions.getType(SellShares.class);
    if (sellableShares != null) {
      for (      SellShares share : sellableShares) {
        company=share.getCompany();
        index=company.getPublicNumber();
        if (j >= 0) {
          setPlayerCertButton(index,j,true,share);
        }
 else         if (j == -1) {
          setTreasuryCertButton(index,true,share);
        }
      }
    }
    initGameSpecificActions();
    List<NullAction> nullActions=possibleActions.getType(NullAction.class);
    if (nullActions != null) {
      for (      NullAction na : nullActions) {
        (parent).setPassButton(na);
      }
    }
  }
  repaint();
}","public void initTurn(int actorIndex){
  int i, j;
  dummyButton.setSelected(true);
  if ((j=this.actorIndex) >= 0) {
    upperPlayerCaption[j].setHighlight(false);
    lowerPlayerCaption[j].setHighlight(false);
    for (i=0; i < nc; i++) {
      setPlayerCertButton(i,j,false);
    }
  }
 else   if (j == -1 && compCanHoldOwnShares) {
    treasurySharesCaption.setHighlight(false);
  }
  for (i=0; i < nc; i++) {
    setIPOCertButton(i,false);
    setPoolCertButton(i,false);
    setPlayerCertButton(i,actorIndex,false);
    if (compCanHoldOwnShares)     setTreasuryCertButton(i,false);
  }
  this.actorIndex=actorIndex;
  if ((j=this.actorIndex) >= -1) {
    if (j >= 0) {
      upperPlayerCaption[j].setHighlight(true);
      lowerPlayerCaption[j].setHighlight(true);
    }
 else     if (j == -1 && treasurySharesCaption != null) {
      treasurySharesCaption.setHighlight(true);
    }
    PublicCertificateI cert;
    Portfolio holder;
    int index;
    List<BuyCertificate> buyableCerts=possibleActions.getType(BuyCertificate.class);
    if (buyableCerts != null) {
      for (      BuyCertificate bCert : buyableCerts) {
        cert=bCert.getCertificate();
        index=cert.getCompany().getPublicNumber();
        holder=bCert.getFromPortfolio();
        if (holder == ipo) {
          setIPOCertButton(index,true,bCert);
        }
 else         if (holder == pool) {
          setPoolCertButton(index,true,bCert);
        }
 else         if (compCanHoldOwnShares) {
          setTreasuryCertButton(index,true,bCert);
        }
      }
    }
    PublicCompanyI company;
    List<SellShares> sellableShares=possibleActions.getType(SellShares.class);
    if (sellableShares != null) {
      for (      SellShares share : sellableShares) {
        company=share.getCompany();
        index=company.getPublicNumber();
        if (j >= 0) {
          setPlayerCertButton(index,j,true,share);
        }
 else         if (j == -1) {
          setTreasuryCertButton(index,true,share);
        }
      }
    }
    initGameSpecificActions();
    List<NullAction> nullActions=possibleActions.getType(NullAction.class);
    if (nullActions != null) {
      for (      NullAction na : nullActions) {
        (parent).setPassButton(na);
      }
    }
  }
  repaint();
}",0.9899620789649788
173801,"protected void moveLeftOrDown(PublicCompanyI company){
  StockSpaceI oldsquare=company.getCurrentSpace();
  StockSpaceI newsquare=oldsquare;
  int row=oldsquare.getRow();
  int col=oldsquare.getColumn();
  if (col > 0 && (newsquare=getStockSpace(row,col - 1)) != null) {
  }
 else   if (row < numRows - 1 && (newsquare=getStockSpace(row + 1,col)) != null) {
  }
  if (newsquare.closesCompany()) {
    if (!company.canClose())     return;
    company.setClosed();
    oldsquare.removeToken(company);
    ReportBuffer.add(company.getName() + LocalText.getText(""String_Node_Str"") + ""String_Node_Str""+ newsquare.getName());
  }
 else {
    prepareMove(company,oldsquare,newsquare);
  }
}","protected void moveLeftOrDown(PublicCompanyI company){
  StockSpaceI oldsquare=company.getCurrentSpace();
  StockSpaceI newsquare=oldsquare;
  int row=oldsquare.getRow();
  int col=oldsquare.getColumn();
  if (col > 0 && (newsquare=getStockSpace(row,col - 1)) != null) {
  }
 else   if (row < numRows - 1 && (newsquare=getStockSpace(row + 1,col)) != null) {
  }
 else {
    newsquare=oldsquare;
  }
  if (newsquare.closesCompany()) {
    if (!company.canClose())     return;
    company.setClosed();
    oldsquare.removeToken(company);
    ReportBuffer.add(company.getName() + LocalText.getText(""String_Node_Str"") + ""String_Node_Str""+ newsquare.getName());
  }
 else {
    prepareMove(company,oldsquare,newsquare);
  }
}",0.9736279401282965
173802,"/** 
 * Buy a start item against the base price.
 * @param playerName Name of the buying player.
 * @param itemName Name of the bought start item.
 * @param sharePrice If nonzero: share price if item contains a President'sshare
 * @return False in case of any errors.
 */
protected boolean buy(String playerName,BuyStartItem boughtItem){
  StartItem item=boughtItem.getStartItem();
  String errMsg=null;
  Player player=getCurrentPlayer();
  int price=0;
  int sharePrice=0;
  String shareCompName=""String_Node_Str"";
  while (true) {
    if (!boughtItem.setSharePriceOnly()) {
      if (item.getStatus() != StartItem.BUYABLE) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
      price=item.getBasePrice();
      if (item.getBid() > price)       price=item.getBid();
      if (player.getFreeCash() < price) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
    }
 else {
      price=item.getBid();
    }
    if (boughtItem.hasSharePriceToSet()) {
      shareCompName=boughtItem.getCompanyToSetPriceFor();
      sharePrice=boughtItem.getAssociatedSharePrice();
      if (sharePrice == 0) {
        errMsg=LocalText.getText(""String_Node_Str"",shareCompName);
        break;
      }
      if ((stockMarket.getStartSpace(sharePrice)) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",Bank.format(sharePrice),shareCompName);
        break;
      }
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,item.getName(),errMsg));
    return false;
  }
  moveStack.start(false);
  assignItem(player,item,price,sharePrice);
  gameManager.setPriorityPlayer();
  setNextPlayer();
  auctionItemState.set(null);
  numPasses.set(0);
  return true;
}","/** 
 * Buy a start item against the base price.
 * @param playerName Name of the buying player.
 * @param itemName Name of the bought start item.
 * @param sharePrice If nonzero: share price if item contains a President'sshare
 * @return False in case of any errors.
 */
protected boolean buy(String playerName,BuyStartItem boughtItem){
  StartItem item=boughtItem.getStartItem();
  int lastBid=item.getBid();
  String errMsg=null;
  Player player=getCurrentPlayer();
  int price=0;
  int sharePrice=0;
  String shareCompName=""String_Node_Str"";
  while (true) {
    if (!boughtItem.setSharePriceOnly()) {
      if (item.getStatus() != StartItem.BUYABLE) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
      price=item.getBasePrice();
      if (item.getBid() > price)       price=item.getBid();
      if (player.getFreeCash() < price) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
    }
 else {
      price=item.getBid();
    }
    if (boughtItem.hasSharePriceToSet()) {
      shareCompName=boughtItem.getCompanyToSetPriceFor();
      sharePrice=boughtItem.getAssociatedSharePrice();
      if (sharePrice == 0) {
        errMsg=LocalText.getText(""String_Node_Str"",shareCompName);
        break;
      }
      if ((stockMarket.getStartSpace(sharePrice)) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",Bank.format(sharePrice),shareCompName);
        break;
      }
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,item.getName(),errMsg));
    return false;
  }
  moveStack.start(false);
  assignItem(player,item,price,sharePrice);
  if (lastBid == 0) {
    gameManager.setPriorityPlayer();
  }
  setNextPlayer();
  auctionItemState.set(null);
  numPasses.set(0);
  return true;
}",0.984091543399386
173803,"@Override public boolean sellShares(SellShares action){
  Portfolio portfolio=currentPlayer.getPortfolio();
  String playerName=currentPlayer.getName();
  String errMsg=null;
  String companyName=action.getCompanyName();
  PublicCompanyI company=companyManager.getPublicCompany(action.getCompanyName());
  PublicCertificateI cert=null;
  PublicCertificateI presCert=null;
  List<PublicCertificateI> certsToSell=new ArrayList<PublicCertificateI>();
  Player dumpedPlayer=null;
  int presSharesToSell=0;
  int numberToSell=action.getNumberSold();
  int shareUnits=action.getShareUnits();
  int currentIndex=getCurrentPlayerIndex();
  while (true) {
    if (numberToSell <= 0) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (portfolio.getShare(company) < numberToSell) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (pool.getShare(company) + numberToSell * company.getShareUnit() > bank.getPoolShareLimit()) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    Iterator<PublicCertificateI> it=portfolio.getCertificatesPerCompany(companyName).iterator();
    while (numberToSell > 0 && it.hasNext()) {
      cert=it.next();
      if (cert.isPresidentShare()) {
        if (cert.isPresidentShare())         presCert=cert;
        continue;
      }
 else       if (shareUnits != cert.getShares()) {
        continue;
      }
      certsToSell.add(cert);
      numberToSell--;
    }
    if (numberToSell == 0)     presCert=null;
    if (numberToSell > 0 && presCert != null && numberToSell <= presCert.getShares()) {
      if (company == unsellableCompany) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
      Player otherPlayer;
      for (int i=currentIndex + 1; i < currentIndex + numberOfPlayers; i++) {
        otherPlayer=gameManager.getPlayerByIndex(i);
        if (otherPlayer.getPortfolio().getShare(company) >= presCert.getShare()) {
          if (numberToSell > 1 || otherPlayer.getPortfolio().ownsCertificates(company,1,false) >= 1) {
            dumpedPlayer=otherPlayer;
            presSharesToSell=numberToSell;
            numberToSell=0;
            break;
          }
        }
      }
    }
    if (numberToSell > 0) {
      if (presCert != null) {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
 else {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
      break;
    }
    break;
  }
  int numberSold=action.getNumberSold();
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,numberSold,companyName,errMsg));
    return false;
  }
  StockSpaceI sellPrice;
  int price;
  if (sellPrices.containsKey(companyName)) {
    price=(sellPrices.get(companyName)).getPrice();
  }
 else {
    sellPrice=company.getCurrentSpace();
    price=sellPrice.getPrice();
    sellPrices.put(companyName,sellPrice);
  }
  moveStack.start(true);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,numberSold,company.getShareUnit(),numberSold * company.getShareUnit(),companyName,Bank.format(numberSold * price)));
  if (presCert != null && dumpedPlayer != null && presSharesToSell > 0) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",dumpedPlayer.getName(),companyName));
    Portfolio dumpedPortfolio=dumpedPlayer.getPortfolio();
    List<PublicCertificateI> swapped=portfolio.swapPresidentCertificate(company,dumpedPortfolio);
    for (int i=0; i < presSharesToSell; i++) {
      certsToSell.add(swapped.get(i));
    }
  }
  for (  PublicCertificateI cert2 : certsToSell) {
    if (cert2 != null) {
      executeTradeCertificate(cert2,pool,cert2.getShares() * price);
    }
  }
  company.adjustSharePrice(SOLD,numberToSell,gameManager.getStockMarket());
  if (currentPlayer == company.getPresident()) {
    Player otherPlayer;
    for (int i=currentIndex + 1; i < currentIndex + numberOfPlayers; i++) {
      otherPlayer=gameManager.getPlayerByIndex(i);
      if (otherPlayer.getPortfolio().getShare(company) > portfolio.getShare(company)) {
        portfolio.swapPresidentCertificate(company,otherPlayer.getPortfolio());
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",otherPlayer.getName(),company.getName()));
        break;
      }
    }
  }
  cashToRaise.add(-numberSold * price);
  if (cashToRaise.intValue() <= 0) {
    gameManager.finishShareSellingRound();
  }
  return true;
}","@Override public boolean sellShares(SellShares action){
  Portfolio portfolio=currentPlayer.getPortfolio();
  String playerName=currentPlayer.getName();
  String errMsg=null;
  String companyName=action.getCompanyName();
  PublicCompanyI company=companyManager.getPublicCompany(action.getCompanyName());
  PublicCertificateI cert=null;
  PublicCertificateI presCert=null;
  List<PublicCertificateI> certsToSell=new ArrayList<PublicCertificateI>();
  Player dumpedPlayer=null;
  int presSharesToSell=0;
  int numberToSell=action.getNumberSold();
  int shareUnits=action.getShareUnits();
  int currentIndex=getCurrentPlayerIndex();
  while (true) {
    if (numberToSell <= 0) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (portfolio.getShare(company) < numberToSell) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (pool.getShare(company) + numberToSell * company.getShareUnit() > bank.getPoolShareLimit()) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    Iterator<PublicCertificateI> it=portfolio.getCertificatesPerCompany(companyName).iterator();
    while (numberToSell > 0 && it.hasNext()) {
      cert=it.next();
      if (cert.isPresidentShare()) {
        if (cert.isPresidentShare())         presCert=cert;
        continue;
      }
 else       if (shareUnits != cert.getShares()) {
        continue;
      }
      certsToSell.add(cert);
      numberToSell--;
    }
    if (numberToSell == 0)     presCert=null;
    if (numberToSell > 0 && presCert != null && numberToSell <= presCert.getShares()) {
      if (company == unsellableCompany) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
      Player otherPlayer;
      for (int i=currentIndex + 1; i < currentIndex + numberOfPlayers; i++) {
        otherPlayer=gameManager.getPlayerByIndex(i);
        if (otherPlayer.getPortfolio().getShare(company) >= presCert.getShare()) {
          if (numberToSell > 1 || otherPlayer.getPortfolio().ownsCertificates(company,1,false) >= 1) {
            dumpedPlayer=otherPlayer;
            presSharesToSell=numberToSell;
            numberToSell=0;
            break;
          }
        }
      }
    }
    if (numberToSell > 0) {
      if (presCert != null) {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
 else {
        errMsg=LocalText.getText(""String_Node_Str"");
      }
      break;
    }
    break;
  }
  int numberSold=action.getNumberSold();
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,numberSold,companyName,errMsg));
    return false;
  }
  StockSpaceI sellPrice;
  int price;
  if (sellPrices.containsKey(companyName)) {
    price=(sellPrices.get(companyName)).getPrice();
  }
 else {
    sellPrice=company.getCurrentSpace();
    price=sellPrice.getPrice();
    sellPrices.put(companyName,sellPrice);
  }
  moveStack.start(true);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,numberSold,company.getShareUnit(),numberSold * company.getShareUnit(),companyName,Bank.format(numberSold * price)));
  if (presCert != null && dumpedPlayer != null && presSharesToSell > 0) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",dumpedPlayer.getName(),companyName));
    Portfolio dumpedPortfolio=dumpedPlayer.getPortfolio();
    List<PublicCertificateI> swapped=portfolio.swapPresidentCertificate(company,dumpedPortfolio);
    for (int i=0; i < presSharesToSell; i++) {
      certsToSell.add(swapped.get(i));
    }
  }
  for (  PublicCertificateI cert2 : certsToSell) {
    if (cert2 != null) {
      executeTradeCertificate(cert2,pool,cert2.getShares() * price);
    }
  }
  company.adjustSharePrice(SOLD,numberSold,gameManager.getStockMarket());
  if (currentPlayer == company.getPresident()) {
    Player otherPlayer;
    for (int i=currentIndex + 1; i < currentIndex + numberOfPlayers; i++) {
      otherPlayer=gameManager.getPlayerByIndex(i);
      if (otherPlayer.getPortfolio().getShare(company) > portfolio.getShare(company)) {
        portfolio.swapPresidentCertificate(company,otherPlayer.getPortfolio());
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",otherPlayer.getName(),company.getName()));
        break;
      }
    }
  }
  cashToRaise.add(-numberSold * price);
  if (cashToRaise.intValue() <= 0) {
    gameManager.finishShareSellingRound();
  }
  return true;
}",0.998889382496668
173804,"public void updateStatus(){
  StartItem item;
  int i, j;
  for (i=0; i < ni; i++) {
    setItemNameButton(i,false);
    actionableItems[i]=null;
  }
  dummyButton.setSelected(true);
  for (  PossibleAction action : possibleActions.getList()) {
    log.debug(action.getPlayerName() + ""String_Node_Str"" + action);
  }
  List<StartItemAction> actions=possibleActions.getType(StartItemAction.class);
  if (actions == null || actions.isEmpty()) {
    close();
    return;
  }
  int nextPlayerIndex=((PossibleAction)actions.get(0)).getPlayerIndex();
  setSRPlayerTurn(nextPlayerIndex);
  boolean passAllowed=false;
  boolean buyAllowed=false;
  boolean bidAllowed=false;
  boolean selected=false;
  BuyStartItem buyAction;
  for (  StartItemAction action : actions) {
    j=action.getItemIndex();
    i=crossIndex[j];
    actionableItems[i]=action;
    item=action.getStartItem();
    if (action instanceof BuyStartItem) {
      buyAction=(BuyStartItem)action;
      if (!buyAction.setSharePriceOnly()) {
        selected=buyAction.isSelected();
        if (selected) {
          buyButton.setPossibleAction(action);
        }
 else {
          itemNameButton[i].setPossibleAction(action);
        }
        itemNameButton[i].setSelected(selected);
        itemNameButton[i].setEnabled(!selected);
        setItemNameButton(i,true);
        if (includeBidding && showBasePrices)         minBid[i].setText(""String_Node_Str"");
        buyAllowed=selected;
      }
 else {
        PossibleAction lastAction=gameUIManager.getLastAction();
        if (lastAction instanceof GameAction && (((GameAction)lastAction).getMode() == GameAction.UNDO || ((GameAction)lastAction).getMode() == GameAction.FORCED_UNDO)) {
          setItemNameButton(i,true);
          itemNameButton[i].setSelected(true);
          itemNameButton[i].setEnabled(false);
          buyButton.setPossibleAction(action);
          buyAllowed=true;
        }
 else {
          immediateAction=action;
        }
      }
    }
 else     if (action instanceof BidStartItem) {
      BidStartItem bidAction=(BidStartItem)action;
      selected=bidAction.isSelected();
      if (selected) {
        bidButton.addPossibleAction(action);
        bidButton.setPossibleAction(action);
        int mb=bidAction.getMinimumBid();
        spinnerModel.setMinimum(mb);
        spinnerModel.setStepSize(bidAction.getBidIncrement());
        spinnerModel.setValue(mb);
      }
 else {
        itemNameButton[i].setPossibleAction(action);
      }
      bidAllowed=selected;
      itemNameButton[i].setSelected(selected);
      itemNameButton[i].setEnabled(!selected);
      setItemNameButton(i,true);
      minBid[i].setText(Bank.format(item.getMinimumBid()));
    }
  }
  passAllowed=false;
  List<NullAction> inactiveItems=possibleActions.getType(NullAction.class);
  if (inactiveItems != null) {
    for (    NullAction na : inactiveItems) {
switch (na.getMode()) {
case NullAction.PASS:
        passButton.setText(LocalText.getText(""String_Node_Str""));
      passAllowed=true;
    passButton.setPossibleAction(na);
  passButton.setMnemonic(KeyEvent.VK_P);
break;
}
}
}
buyButton.setEnabled(buyAllowed);
if (includeBidding) bidButton.setEnabled(bidAllowed);
passButton.setEnabled(passAllowed);
requestFocus();
}","public void updateStatus(){
  StartItem item;
  int i, j;
  for (i=0; i < ni; i++) {
    setItemNameButton(i,false);
    actionableItems[i]=null;
  }
  dummyButton.setSelected(true);
  for (  PossibleAction action : possibleActions.getList()) {
    log.debug(action.getPlayerName() + ""String_Node_Str"" + action);
  }
  List<StartItemAction> actions=possibleActions.getType(StartItemAction.class);
  if (actions == null || actions.isEmpty()) {
    close();
    return;
  }
  int nextPlayerIndex=((PossibleAction)actions.get(0)).getPlayerIndex();
  setSRPlayerTurn(nextPlayerIndex);
  boolean passAllowed=false;
  boolean buyAllowed=false;
  boolean bidAllowed=false;
  boolean selected=false;
  BuyStartItem buyAction;
  for (  StartItemAction action : actions) {
    j=action.getItemIndex();
    i=crossIndex[j];
    actionableItems[i]=action;
    item=action.getStartItem();
    if (action instanceof BuyStartItem) {
      buyAction=(BuyStartItem)action;
      if (!buyAction.setSharePriceOnly()) {
        selected=buyAction.isSelected();
        if (selected) {
          buyButton.setPossibleAction(action);
        }
 else {
          itemNameButton[i].setPossibleAction(action);
        }
        itemNameButton[i].setSelected(selected);
        itemNameButton[i].setEnabled(!selected);
        setItemNameButton(i,true);
        if (includeBidding && showBasePrices)         minBid[i].setText(""String_Node_Str"");
        buyAllowed=selected;
      }
 else {
        PossibleAction lastAction=gameUIManager.getLastAction();
        if (lastAction instanceof GameAction && (((GameAction)lastAction).getMode() == GameAction.UNDO || ((GameAction)lastAction).getMode() == GameAction.FORCED_UNDO)) {
          setItemNameButton(i,true);
          itemNameButton[i].setSelected(true);
          itemNameButton[i].setEnabled(false);
          buyButton.setPossibleAction(action);
          buyAllowed=true;
        }
 else {
          immediateAction=action;
        }
      }
    }
 else     if (action instanceof BidStartItem) {
      BidStartItem bidAction=(BidStartItem)action;
      selected=bidAction.isSelected();
      if (selected) {
        bidButton.addPossibleAction(action);
        bidButton.setPossibleAction(action);
        int mb=bidAction.getMinimumBid();
        spinnerModel.setMinimum(mb);
        spinnerModel.setStepSize(bidAction.getBidIncrement());
        spinnerModel.setValue(mb);
      }
 else {
        itemNameButton[i].setPossibleAction(action);
      }
      bidAllowed=selected;
      itemNameButton[i].setSelected(selected);
      itemNameButton[i].setEnabled(!selected);
      setItemNameButton(i,true);
      minBid[i].setText(Bank.format(item.getMinimumBid()));
    }
  }
  passAllowed=false;
  List<NullAction> inactiveItems=possibleActions.getType(NullAction.class);
  if (inactiveItems != null) {
    for (    NullAction na : inactiveItems) {
switch (na.getMode()) {
case NullAction.PASS:
        passButton.setText(LocalText.getText(""String_Node_Str""));
      passAllowed=true;
    passButton.setPossibleAction(na);
  passButton.setMnemonic(KeyEvent.VK_P);
break;
}
}
}
buyButton.setEnabled(buyAllowed);
if (includeBidding) {
bidButton.setEnabled(bidAllowed);
bidAmount.setEnabled(bidAllowed);
}
passButton.setEnabled(passAllowed);
requestFocus();
}",0.9941931540342298
173805,"@Override public void configureFromXML(Tag tag) throws ConfigurationException {
  Tag swapTag=tag.getChild(""String_Node_Str"");
  if (swapTag == null) {
    throw new ConfigurationException(""String_Node_Str"");
  }
  publicCompanyName=swapTag.getAttributeAsString(""String_Node_Str"");
  if (!Util.hasValue(publicCompanyName))   throw new ConfigurationException(""String_Node_Str"");
  share=swapTag.getAttributeAsInteger(""String_Node_Str"",10);
}","@Override public void configureFromXML(Tag tag) throws ConfigurationException {
  super.configureFromXML(tag);
  Tag swapTag=tag.getChild(""String_Node_Str"");
  if (swapTag == null) {
    throw new ConfigurationException(""String_Node_Str"");
  }
  publicCompanyName=swapTag.getAttributeAsString(""String_Node_Str"");
  if (!Util.hasValue(publicCompanyName))   throw new ConfigurationException(""String_Node_Str"");
  share=swapTag.getAttributeAsInteger(""String_Node_Str"",10);
}",0.9659714599341384
173806,"/** 
 * Start a company by buying one or more shares (more applies to e.g. 1841)
 * @param player The player that wants to start a company.
 * @param company The company to start.
 * @param price The start (par) price (ignored if the price is fixed).
 * @param shares The number of shares to buy (can be more than 1 in e.g.1841).
 * @return True if the company could be started. False indicates an error.
 */
public boolean startCompany(String playerName,StartCompany action){
  PublicCompanyI company=action.getCertificate().getCompany();
  int price=action.getPrice();
  int shares=action.getNumberBought();
  String errMsg=null;
  StockSpaceI startSpace=null;
  int numberOfCertsToBuy=0;
  PublicCertificateI cert=null;
  String companyName=company.getName();
  currentPlayer=getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    if (companyBoughtThisTurnWrapper.getObject() != null) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.hasStarted()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    cert=ipo.findCertificate(company,true);
    if (shares < cert.getShares())     shares=cert.getShares();
    numberOfCertsToBuy=shares - (cert.getShares() - 1);
    if (!mayPlayerBuyCertificate(currentPlayer,company,numberOfCertsToBuy)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    startSpace=company.getStartSpace();
    if (startSpace != null) {
      price=startSpace.getPrice();
    }
 else {
      if ((startSpace=stockMarket.getStartSpace(price)) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",Bank.format(price),company.getName());
        break;
      }
    }
    if (currentPlayer.getCash() < shares * price) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,companyName,Bank.format(price),errMsg));
    return false;
  }
  moveStack.start(true);
  company.start(startSpace);
  CashHolder priceRecipient=getSharePriceRecipient(cert,price);
  executeTradeCertificate(cert,currentPlayer.getPortfolio(),price * cert.getShares(),priceRecipient);
  for (int i=1; i < numberOfCertsToBuy; i++) {
    cert=ipo.findCertificate(company,false);
    executeTradeCertificate(cert,currentPlayer.getPortfolio(),company.getIPOPrice(),priceRecipient);
  }
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,companyName,Bank.format(price),Bank.format(shares * price),shares,cert.getShare(),priceRecipient.getName()));
  ReportBuffer.getAllWaiting();
  checkFlotation(company);
  companyBoughtThisTurnWrapper.set(company);
  hasActed.set(true);
  setPriority();
  gameSpecificChecks(ipo,company);
  return true;
}","/** 
 * Start a company by buying one or more shares (more applies to e.g. 1841)
 * @param player The player that wants to start a company.
 * @param company The company to start.
 * @param price The start (par) price (ignored if the price is fixed).
 * @param shares The number of shares to buy (can be more than 1 in e.g.1841).
 * @return True if the company could be started. False indicates an error.
 */
public boolean startCompany(String playerName,StartCompany action){
  PublicCompanyI company=action.getCertificate().getCompany();
  int price=action.getPrice();
  int shares=action.getNumberBought();
  String errMsg=null;
  StockSpaceI startSpace=null;
  int numberOfCertsToBuy=0;
  PublicCertificateI cert=null;
  String companyName=company.getName();
  int cost=0;
  currentPlayer=getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    if (companyBoughtThisTurnWrapper.getObject() != null) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.hasStarted()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    cert=ipo.findCertificate(company,true);
    if (shares < cert.getShares())     shares=cert.getShares();
    numberOfCertsToBuy=shares - (cert.getShares() - 1);
    if (!mayPlayerBuyCertificate(currentPlayer,company,numberOfCertsToBuy)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    startSpace=company.getStartSpace();
    if (startSpace != null) {
      price=startSpace.getPrice();
    }
 else {
      if ((startSpace=stockMarket.getStartSpace(price)) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",Bank.format(price),company.getName());
        break;
      }
    }
    cost=shares * price;
    if (currentPlayer.getCash() < cost) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,companyName,Bank.format(price),errMsg));
    return false;
  }
  moveStack.start(true);
  company.start(startSpace);
  CashHolder priceRecipient=getSharePriceRecipient(cert,price);
  cert.moveTo(currentPlayer.getPortfolio());
  for (int i=1; i < numberOfCertsToBuy; i++) {
    cert=ipo.findCertificate(company,false);
    cert.moveTo(currentPlayer.getPortfolio());
  }
  new CashMove(currentPlayer,priceRecipient,cost);
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,companyName,Bank.format(price),Bank.format(cost),shares,cert.getShare(),priceRecipient.getName()));
  ReportBuffer.getAllWaiting();
  checkFlotation(company);
  companyBoughtThisTurnWrapper.set(company);
  hasActed.set(true);
  setPriority();
  gameSpecificChecks(ipo,company);
  return true;
}",0.942690058479532
173807,"/** 
 * Buying one or more single or double-share certificates (more is sometimes possible)
 * @param player The player that wants to buy shares.
 * @param action The executed BuyCertificates action
 * @return True if the certificates could be bought. False indicates anerror.
 */
public boolean buyShares(String playerName,BuyCertificate action){
  PublicCertificateI cert=action.getCertificate();
  Portfolio from=cert.getPortfolio();
  String companyName=cert.getCompany().getName();
  int number=action.getNumberBought();
  int shares=number * cert.getShares();
  int shareUnit=cert.getShare();
  String errMsg=null;
  int price=0;
  int cash=0;
  PublicCompanyI company=null;
  currentPlayer=getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    company=companyManager.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (isSaleRecorded(currentPlayer,company)) {
      errMsg=LocalText.getText(""String_Node_Str"",currentPlayer.getName(),companyName);
      break;
    }
    if (!company.hasStarted()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    PublicCompanyI companyBoughtThisTurn=(PublicCompanyI)companyBoughtThisTurnWrapper.getObject();
    if (companyBoughtThisTurn != null && (companyBoughtThisTurn != company || !company.getCurrentSpace().isNoBuyLimit())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    if (shares > from.getShare(company)) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,from.getName());
      break;
    }
    StockSpaceI currentSpace;
    if (from == ipo && company.hasParPrice()) {
      currentSpace=company.getStartSpace();
    }
 else {
      currentSpace=company.getCurrentSpace();
    }
    if (number > 1 && !currentSpace.isNoBuyLimit()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (!currentSpace.isNoCertLimit() && !mayPlayerBuyCertificate(currentPlayer,company,shares)) {
      errMsg=currentPlayer.getName() + LocalText.getText(""String_Node_Str"",String.valueOf(gameManager.getPlayerCertificateLimit()));
      break;
    }
    if (!currentSpace.isNoHoldLimit() && !mayPlayerBuyCompanyShare(currentPlayer,company,shares)) {
      errMsg=currentPlayer.getName() + LocalText.getText(""String_Node_Str"");
      break;
    }
    price=currentSpace.getPrice();
    cash=shares * price;
    if (currentPlayer.getCash() < cash) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,shares,companyName,from.getName(),errMsg));
    return false;
  }
  moveStack.start(true);
  CashHolder priceRecipient=getSharePriceRecipient(cert,cash);
  if (number == 1) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,shareUnit,companyName,from.getName(),Bank.format(cash)));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,number,shareUnit,number * shareUnit,companyName,from.getName(),Bank.format(cash)));
  }
  ReportBuffer.getAllWaiting();
  PublicCertificateI cert2;
  for (int i=0; i < number; i++) {
    cert2=from.findCertificate(company,cert.getShares(),false);
    if (cert2 == null) {
      log.error(""String_Node_Str"" + companyName + ""String_Node_Str""+ shareUnit+ ""String_Node_Str""+ from.getName());
    }
    executeTradeCertificate(cert2,currentPlayer.getPortfolio(),cash,priceRecipient);
  }
  if (priceRecipient != from.getOwner()) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",Bank.format(price * shares),priceRecipient.getName()));
  }
  companyBoughtThisTurnWrapper.set(company);
  hasActed.set(true);
  setPriority();
  company.checkPresidencyOnBuy(currentPlayer);
  if (!company.hasFloated())   checkFlotation(company);
  gameSpecificChecks(from,company);
  return true;
}","/** 
 * Buying one or more single or double-share certificates (more is sometimes possible)
 * @param player The player that wants to buy shares.
 * @param action The executed BuyCertificates action
 * @return True if the certificates could be bought. False indicates anerror.
 */
public boolean buyShares(String playerName,BuyCertificate action){
  PublicCertificateI cert=action.getCertificate();
  Portfolio from=cert.getPortfolio();
  String companyName=cert.getCompany().getName();
  int number=action.getNumberBought();
  int shares=number * cert.getShares();
  int shareUnit=cert.getShare();
  String errMsg=null;
  int price=0;
  int cost=0;
  PublicCompanyI company=null;
  currentPlayer=getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    company=companyManager.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (isSaleRecorded(currentPlayer,company)) {
      errMsg=LocalText.getText(""String_Node_Str"",currentPlayer.getName(),companyName);
      break;
    }
    if (!company.hasStarted()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    PublicCompanyI companyBoughtThisTurn=(PublicCompanyI)companyBoughtThisTurnWrapper.getObject();
    if (companyBoughtThisTurn != null && (companyBoughtThisTurn != company || !company.getCurrentSpace().isNoBuyLimit())) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    if (shares > from.getShare(company)) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName,from.getName());
      break;
    }
    StockSpaceI currentSpace;
    if (from == ipo && company.hasParPrice()) {
      currentSpace=company.getStartSpace();
    }
 else {
      currentSpace=company.getCurrentSpace();
    }
    if (number > 1 && !currentSpace.isNoBuyLimit()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (!currentSpace.isNoCertLimit() && !mayPlayerBuyCertificate(currentPlayer,company,shares)) {
      errMsg=currentPlayer.getName() + LocalText.getText(""String_Node_Str"",String.valueOf(gameManager.getPlayerCertificateLimit()));
      break;
    }
    if (!currentSpace.isNoHoldLimit() && !mayPlayerBuyCompanyShare(currentPlayer,company,shares)) {
      errMsg=currentPlayer.getName() + LocalText.getText(""String_Node_Str"");
      break;
    }
    price=currentSpace.getPrice();
    cost=shares * price;
    if (currentPlayer.getCash() < cost) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",playerName,shares,companyName,from.getName(),errMsg));
    return false;
  }
  moveStack.start(true);
  CashHolder priceRecipient=getSharePriceRecipient(cert,cost);
  if (number == 1) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,shareUnit,companyName,from.getName(),Bank.format(cost)));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",playerName,number,shareUnit,number * shareUnit,companyName,from.getName(),Bank.format(cost)));
  }
  ReportBuffer.getAllWaiting();
  PublicCertificateI cert2;
  for (int i=0; i < number; i++) {
    cert2=from.findCertificate(company,cert.getShares(),false);
    if (cert2 == null) {
      log.error(""String_Node_Str"" + companyName + ""String_Node_Str""+ shareUnit+ ""String_Node_Str""+ from.getName());
    }
    cert.moveTo(currentPlayer.getPortfolio());
  }
  new CashMove(currentPlayer,priceRecipient,cost);
  if (priceRecipient != from.getOwner()) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",Bank.format(cost),priceRecipient.getName()));
  }
  companyBoughtThisTurnWrapper.set(company);
  hasActed.set(true);
  setPriority();
  company.checkPresidencyOnBuy(currentPlayer);
  if (!company.hasFloated())   checkFlotation(company);
  gameSpecificChecks(from,company);
  return true;
}",0.972089020041805
173808,"private void resetOperatingCompanies(List<PublicCompanyI> mergingCompanies){
  List<PublicCompanyI> companies=new ArrayList<PublicCompanyI>(Arrays.asList(operatingCompanyArray));
  PublicCompanyI cgr=companyManager.getCompanyByName(PublicCompany_CGR.NAME);
  boolean cgrCanOperate=cgr.hasStarted();
  for (  PublicCompanyI company : mergingCompanies) {
    if (companiesOperatedThisRound.contains(company))     cgrCanOperate=false;
  }
  while (setNextOperatingCompany(false) && operatingCompany.isClosed())   ;
  if (operatingCompany != null) {
    operatingCompanyIndex=companies.indexOf(operatingCompany);
  }
  for (  PublicCompanyI c : companies) {
    if (c.isClosed()) {
      log.info(c.getName() + ""String_Node_Str"");
    }
 else {
      log.debug(c.getName() + ""String_Node_Str"");
    }
  }
  String message;
  if (cgr.hasStarted()) {
    if (cgrCanOperate) {
      operatingCompanyIndex=Math.max(0,operatingCompanyIndex);
      companies.add(operatingCompanyIndex,cgr);
      operatingCompany=cgr;
      operatingCompanyIndex=companies.indexOf(operatingCompany);
      message=LocalText.getText(""String_Node_Str"",cgr.getName());
    }
 else {
      message=LocalText.getText(""String_Node_Str"",cgr.getName());
    }
  }
 else {
    message=LocalText.getText(""String_Node_Str"",cgr.getName());
  }
  ReportBuffer.add(message);
  DisplayBuffer.add(message);
  operatingCompanyArray=companies.toArray(new PublicCompanyI[0]);
  operatingCompanyIndexObject.set(operatingCompanyIndex);
  log.debug(""String_Node_Str"" + operatingCompany.getName());
}","private void resetOperatingCompanies(List<PublicCompanyI> mergingCompanies){
  List<PublicCompanyI> companies=new ArrayList<PublicCompanyI>(Arrays.asList(operatingCompanyArray));
  PublicCompanyI cgr=companyManager.getCompanyByName(PublicCompany_CGR.NAME);
  boolean cgrCanOperate=cgr.hasStarted();
  for (  PublicCompanyI company : mergingCompanies) {
    if (companiesOperatedThisRound.contains(company))     cgrCanOperate=false;
  }
  while (setNextOperatingCompany(false) && operatingCompany.isClosed())   ;
  for (  PublicCompanyI c : companies) {
    if (c.isClosed()) {
      log.info(c.getName() + ""String_Node_Str"");
    }
 else {
      log.debug(c.getName() + ""String_Node_Str"");
    }
  }
  String message;
  if (cgr.hasStarted()) {
    if (cgrCanOperate) {
      operatingCompanyIndex=Math.max(0,operatingCompanyIndex);
      companies.add(operatingCompanyIndex,cgr);
      operatingCompany=cgr;
      operatingCompanyIndex=companies.indexOf(operatingCompany);
      message=LocalText.getText(""String_Node_Str"",cgr.getName());
    }
 else {
      message=LocalText.getText(""String_Node_Str"",cgr.getName());
      while (setNextOperatingCompany(false) && operatingCompany.isClosed())       ;
    }
  }
 else {
    message=LocalText.getText(""String_Node_Str"",cgr.getName());
  }
  ReportBuffer.add(message);
  DisplayBuffer.add(message);
  operatingCompanyArray=companies.toArray(new PublicCompanyI[0]);
  if (operatingCompanyIndex < operatingCompanyArray.length) {
    operatingCompanyIndexObject.set(operatingCompanyIndex);
    log.debug(""String_Node_Str"" + operatingCompany.getName());
  }
 else {
    finishOR();
  }
}",0.6107445805843544
173809,"public String getName(){
  return ""String_Node_Str"" + number + ""String_Node_Str""+ mapHex.getName();
}","public String getName(){
  return mapHex.getName() + ""String_Node_Str"" + number;
}",0.6885245901639344
173810,"public boolean buyTrain(BuyTrain action){
  TrainI train=action.getTrain();
  PublicCompanyI company=action.getCompany();
  String companyName=company.getName();
  TrainI exchangedTrain=action.getExchangedTrain();
  SpecialTrainBuy stb=null;
  String errMsg=null;
  int presidentCash=action.getPresidentCashToAdd();
  boolean presidentMustSellShares=false;
  int price=action.getPricePaid();
  int actualPresidentCash=0;
  Player currentPlayer=operatingCompany.getPresident();
  ;
  while (true) {
    if (getStep() != STEP_BUY_TRAIN) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (train == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (price < 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(price));
      break;
    }
    int trainLimit=operatingCompany.getCurrentTrainLimit();
    if (!canBuyTrain()) {
      errMsg=LocalText.getText(""String_Node_Str"",String.valueOf(trainLimit));
      break;
    }
    if (action.mustPresidentAddCash()) {
      presidentCash=action.getPresidentCashToAdd();
      if (currentPlayer.getCash() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCash();
      }
    }
 else     if (action.mayPresidentAddCash()) {
      presidentCash=price - operatingCompany.getCash();
      if (presidentCash > action.getPresidentCashToAdd()) {
        errMsg=LocalText.getText(""String_Node_Str"",Bank.format(action.getPresidentCashToAdd()));
        break;
      }
 else       if (currentPlayer.getCash() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCash();
      }
    }
 else {
      if (price > operatingCompany.getCash()) {
        errMsg=LocalText.getText(""String_Node_Str"",new String[]{companyName,Bank.format(operatingCompany.getCash()),Bank.format(price)});
        break;
      }
    }
    stb=action.getSpecialProperty();
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{companyName,train.getName(),Bank.format(price),errMsg}));
    return false;
  }
  MoveSet.start(true);
  PhaseI previousPhase=getCurrentPhase();
  if (presidentMustSellShares) {
    savedAction=action;
    gameManager.startShareSellingRound(this,operatingCompany,cashToBeRaisedByPresident);
    return true;
  }
  if (actualPresidentCash > 0) {
    new CashMove(currentPlayer,operatingCompany,presidentCash);
  }
  Portfolio oldHolder=train.getHolder();
  if (exchangedTrain != null) {
    TrainI oldTrain=operatingCompany.getPortfolio().getTrainOfType(exchangedTrain.getType());
    Bank.getPool().buyTrain(oldTrain,0);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{companyName,exchangedTrain.getName(),train.getName(),oldHolder.getName(),Bank.format(price)}));
  }
 else   if (stb == null) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{companyName,train.getName(),oldHolder.getName(),Bank.format(price)}));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{companyName,train.getName(),oldHolder.getName(),Bank.format(price),stb.getCompany().getName()}));
  }
  operatingCompany.buyTrain(train,price);
  if (oldHolder == Bank.getIpo())   train.getType().addToBoughtFromIPO();
  if (oldHolder.getOwner() instanceof Bank) {
    trainsBoughtThisTurn.add(train.getType());
  }
  if (stb != null) {
    stb.setExercised();
    log.debug(""String_Node_Str"");
  }
  TrainManager.get().checkTrainAvailability(train,oldHolder);
  currentPhase=getCurrentPhase();
  if (currentPhase != previousPhase && checkForExcessTrains()) {
    stepObject.set(STEP_DISCARD_TRAINS);
  }
  return true;
}","public boolean buyTrain(BuyTrain action){
  TrainI train=action.getTrain();
  PublicCompanyI company=action.getCompany();
  String companyName=company.getName();
  TrainI exchangedTrain=action.getExchangedTrain();
  SpecialTrainBuy stb=null;
  String errMsg=null;
  int presidentCash=action.getPresidentCashToAdd();
  boolean presidentMustSellShares=false;
  int price=action.getPricePaid();
  int actualPresidentCash=0;
  Player currentPlayer=operatingCompany.getPresident();
  while (true) {
    if (getStep() != STEP_BUY_TRAIN) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (train == null) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    if (price < 0) {
      errMsg=LocalText.getText(""String_Node_Str"",Bank.format(price));
      break;
    }
    int trainLimit=operatingCompany.getCurrentTrainLimit();
    if (!canBuyTrain()) {
      errMsg=LocalText.getText(""String_Node_Str"",String.valueOf(trainLimit));
      break;
    }
    if (action.mustPresidentAddCash()) {
      presidentCash=action.getPresidentCashToAdd();
      if (currentPlayer.getCash() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCash();
      }
    }
 else     if (action.mayPresidentAddCash()) {
      presidentCash=price - operatingCompany.getCash();
      if (presidentCash > action.getPresidentCashToAdd()) {
        errMsg=LocalText.getText(""String_Node_Str"",Bank.format(action.getPresidentCashToAdd()));
        break;
      }
 else       if (currentPlayer.getCash() >= presidentCash) {
        actualPresidentCash=presidentCash;
      }
 else {
        presidentMustSellShares=true;
        cashToBeRaisedByPresident=presidentCash - currentPlayer.getCash();
      }
    }
 else {
      if (price > operatingCompany.getCash()) {
        errMsg=LocalText.getText(""String_Node_Str"",new String[]{companyName,Bank.format(operatingCompany.getCash()),Bank.format(price)});
        break;
      }
    }
    stb=action.getSpecialProperty();
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{companyName,train.getName(),Bank.format(price),errMsg}));
    return false;
  }
  MoveSet.start(true);
  PhaseI previousPhase=getCurrentPhase();
  if (presidentMustSellShares) {
    savedAction=action;
    gameManager.startShareSellingRound(this,operatingCompany,cashToBeRaisedByPresident);
    return true;
  }
  if (actualPresidentCash > 0) {
    new CashMove(currentPlayer,operatingCompany,presidentCash);
  }
  Portfolio oldHolder=train.getHolder();
  if (exchangedTrain != null) {
    TrainI oldTrain=operatingCompany.getPortfolio().getTrainOfType(exchangedTrain.getType());
    Bank.getPool().buyTrain(oldTrain,0);
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{companyName,exchangedTrain.getName(),train.getName(),oldHolder.getName(),Bank.format(price)}));
  }
 else   if (stb == null) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{companyName,train.getName(),oldHolder.getName(),Bank.format(price)}));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{companyName,train.getName(),oldHolder.getName(),Bank.format(price),stb.getCompany().getName()}));
  }
  operatingCompany.buyTrain(train,price);
  if (oldHolder == Bank.getIpo()) {
    train.getType().addToBoughtFromIPO();
    if (train.getType().hasInfiniteAmount()) {
      Bank.getIpo().addTrain(train.getType().cloneTrain());
    }
  }
  if (oldHolder.getOwner() instanceof Bank) {
    trainsBoughtThisTurn.add(train.getType());
  }
  if (stb != null) {
    stb.setExercised();
    log.debug(""String_Node_Str"");
  }
  TrainManager.get().checkTrainAvailability(train,oldHolder);
  currentPhase=getCurrentPhase();
  if (currentPhase != previousPhase && checkForExcessTrains()) {
    stepObject.set(STEP_DISCARD_TRAINS);
  }
  return true;
}",0.984159168673172
173811,"/** 
 * @see rails.game.ConfigurableComponentI#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Tag tag) throws ConfigurationException {
  trainClassName=tag.getAttributeAsString(""String_Node_Str"",trainClassName);
  try {
    trainClass=Class.forName(trainClassName).asSubclass(Train.class);
  }
 catch (  ClassNotFoundException e) {
    throw new ConfigurationException(""String_Node_Str"" + trainClassName + ""String_Node_Str"",e);
  }
  if (real) {
    trains=new ArrayList<TrainI>();
    name=tag.getAttributeAsString(""String_Node_Str"");
    if (name == null) {
      throw new ConfigurationException(LocalText.getText(""String_Node_Str""));
    }
    cost=tag.getAttributeAsInteger(""String_Node_Str"");
    if (cost == 0) {
      throw new ConfigurationException(LocalText.getText(""String_Node_Str""));
    }
    amount=tag.getAttributeAsInteger(""String_Node_Str"");
    if (amount == -1) {
      infiniteAmount=true;
    }
 else     if (amount <= 0) {
      throw new ConfigurationException(LocalText.getText(""String_Node_Str""));
    }
    majorStops=tag.getAttributeAsInteger(""String_Node_Str"");
    if (majorStops == 0) {
      throw new ConfigurationException(LocalText.getText(""String_Node_Str""));
    }
    minorStops=tag.getAttributeAsInteger(""String_Node_Str"");
    startedPhaseName=tag.getAttributeAsString(""String_Node_Str"",""String_Node_Str"");
    rustedTrainTypeName=tag.getAttributeAsString(""String_Node_Str"");
    releasedTrainTypeName=tag.getAttributeAsString(""String_Node_Str"");
    obsoleting=tag.getAttributeAsBoolean(""String_Node_Str"");
    initialPortfolio=tag.getAttributeAsString(""String_Node_Str"",initialPortfolio);
  }
 else {
    name=""String_Node_Str"";
    amount=0;
  }
  Tag reachTag=tag.getChild(""String_Node_Str"");
  if (reachTag != null) {
    reachBasis=reachTag.getAttributeAsString(""String_Node_Str"",reachBasis);
    countTowns=reachTag.getAttributeAsString(""String_Node_Str"",countTowns);
  }
  Tag scoreTag=tag.getChild(""String_Node_Str"");
  if (scoreTag != null) {
    scoreTowns=scoreTag.getAttributeAsString(""String_Node_Str"",scoreTowns);
    scoreCities=scoreTag.getAttributeAsString(""String_Node_Str"",scoreCities);
  }
  Tag swapTag=tag.getChild(""String_Node_Str"");
  if (swapTag != null) {
    firstExchangeCost=swapTag.getAttributeAsInteger(""String_Node_Str"",0);
    firstCanBeExchanged=(firstExchangeCost > 0);
  }
  if (real) {
    countHexes=reachBasis.equals(""String_Node_Str"");
    townCountIndicator=countTowns.equals(""String_Node_Str"") ? NO_TOWN_COUNT : minorStops > 0 ? TOWN_COUNT_MINOR : TOWN_COUNT_MAJOR;
    cityScoreFactor=scoreCities.equals(""String_Node_Str"") ? 2 : 1;
    townScoreFactor=scoreTowns.equals(""String_Node_Str"") ? 1 : 0;
    TrainI train;
    if (infiniteAmount) {
      try {
        train=trainClass.newInstance();
      }
 catch (      InstantiationException e) {
        throw new ConfigurationException(""String_Node_Str"" + trainClassName,e);
      }
catch (      IllegalAccessException e) {
        throw new ConfigurationException(""String_Node_Str"" + trainClassName + ""String_Node_Str"",e);
      }
      train.init(this,0);
      trains.add(train);
    }
 else {
      for (int i=0; i < amount; i++) {
        try {
          train=trainClass.newInstance();
        }
 catch (        InstantiationException e) {
          throw new ConfigurationException(""String_Node_Str"" + trainClassName,e);
        }
catch (        IllegalAccessException e) {
          throw new ConfigurationException(""String_Node_Str"" + trainClassName + ""String_Node_Str"",e);
        }
        train.init(this,i);
        trains.add(train);
      }
    }
  }
  numberBoughtFromIPO=new IntegerState(name + ""String_Node_Str"",0);
  available=new BooleanState(name + ""String_Node_Str"",false);
  rusted=new BooleanState(name + ""String_Node_Str"",false);
}","/** 
 * @see rails.game.ConfigurableComponentI#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Tag tag) throws ConfigurationException {
  trainClassName=tag.getAttributeAsString(""String_Node_Str"",trainClassName);
  try {
    trainClass=Class.forName(trainClassName).asSubclass(Train.class);
  }
 catch (  ClassNotFoundException e) {
    throw new ConfigurationException(""String_Node_Str"" + trainClassName + ""String_Node_Str"",e);
  }
  if (real) {
    trains=new ArrayList<TrainI>();
    name=tag.getAttributeAsString(""String_Node_Str"");
    if (name == null) {
      throw new ConfigurationException(LocalText.getText(""String_Node_Str""));
    }
    cost=tag.getAttributeAsInteger(""String_Node_Str"");
    if (cost == 0) {
      throw new ConfigurationException(LocalText.getText(""String_Node_Str""));
    }
    amount=tag.getAttributeAsInteger(""String_Node_Str"");
    if (amount == -1) {
      infiniteAmount=true;
    }
 else     if (amount <= 0) {
      throw new ConfigurationException(LocalText.getText(""String_Node_Str""));
    }
    majorStops=tag.getAttributeAsInteger(""String_Node_Str"");
    if (majorStops == 0) {
      throw new ConfigurationException(LocalText.getText(""String_Node_Str""));
    }
    minorStops=tag.getAttributeAsInteger(""String_Node_Str"");
    startedPhaseName=tag.getAttributeAsString(""String_Node_Str"",""String_Node_Str"");
    rustedTrainTypeName=tag.getAttributeAsString(""String_Node_Str"");
    releasedTrainTypeName=tag.getAttributeAsString(""String_Node_Str"");
    obsoleting=tag.getAttributeAsBoolean(""String_Node_Str"");
    initialPortfolio=tag.getAttributeAsString(""String_Node_Str"",initialPortfolio);
  }
 else {
    name=""String_Node_Str"";
    amount=0;
  }
  Tag reachTag=tag.getChild(""String_Node_Str"");
  if (reachTag != null) {
    reachBasis=reachTag.getAttributeAsString(""String_Node_Str"",reachBasis);
    countTowns=reachTag.getAttributeAsString(""String_Node_Str"",countTowns);
  }
  Tag scoreTag=tag.getChild(""String_Node_Str"");
  if (scoreTag != null) {
    scoreTowns=scoreTag.getAttributeAsString(""String_Node_Str"",scoreTowns);
    scoreCities=scoreTag.getAttributeAsString(""String_Node_Str"",scoreCities);
  }
  Tag swapTag=tag.getChild(""String_Node_Str"");
  if (swapTag != null) {
    firstExchangeCost=swapTag.getAttributeAsInteger(""String_Node_Str"",0);
    firstCanBeExchanged=(firstExchangeCost > 0);
  }
  if (real) {
    countHexes=reachBasis.equals(""String_Node_Str"");
    townCountIndicator=countTowns.equals(""String_Node_Str"") ? NO_TOWN_COUNT : minorStops > 0 ? TOWN_COUNT_MINOR : TOWN_COUNT_MAJOR;
    cityScoreFactor=scoreCities.equals(""String_Node_Str"") ? 2 : 1;
    townScoreFactor=scoreTowns.equals(""String_Node_Str"") ? 1 : 0;
    TrainI train;
    if (infiniteAmount) {
      train=createTrain();
      trains.add(train);
    }
 else {
      for (int i=0; i < amount; i++) {
        train=createTrain();
        trains.add(train);
      }
    }
  }
  numberBoughtFromIPO=new IntegerState(name + ""String_Node_Str"",0);
  available=new BooleanState(name + ""String_Node_Str"",false);
  rusted=new BooleanState(name + ""String_Node_Str"",false);
}",0.8906835881165273
173812,"/** 
 * Deserialize 
 */
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  in.defaultReadObject();
  CompanyManagerI cmgr=Game.getCompanyManager();
  if (minorsToMergeNames != null) {
    minorsToMerge=new ArrayList<PublicCompanyI>();
    for (    String name : minorsToMergeNames.split(""String_Node_Str"")) {
      minorsToMerge.add(cmgr.getPublicCompany(name));
    }
  }
  if (chosenMinorName != null) {
    chosenMinor=cmgr.getPublicCompany(chosenMinorName);
  }
}","/** 
 * Deserialize 
 */
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  in.defaultReadObject();
  CompanyManagerI cmgr=Game.getCompanyManager();
  if (minorsToMergeNames != null) {
    minorsToMerge=new ArrayList<PublicCompanyI>();
    for (    String name : minorsToMergeNames.split(""String_Node_Str"")) {
      minorsToMerge.add(cmgr.getPublicCompany(name));
    }
  }
  if (chosenMinorName != null) {
    chosenMinor=cmgr.getPublicCompany(chosenMinorName);
  }
  MapManager mmgr=MapManager.getInstance();
  if (availableHomeStationNames != null) {
    availableHomeStations=new ArrayList<City>();
    for (    String cityName : availableHomeStationNames.split(""String_Node_Str"")) {
      String[] parts=parseStationName(cityName);
      MapHex hex=mmgr.getHex(parts[0]);
      availableHomeStations.add(hex.getCity(Integer.parseInt(parts[1])));
    }
  }
  if (selectedHomeStationName != null) {
    String[] parts=parseStationName(selectedHomeStationName);
    MapHex hex=mmgr.getHex(parts[0]);
    selectedHomeStation=hex.getCity(Integer.parseInt(parts[1]));
  }
}",0.6280788177339901
173813,"/** 
 * Merge a minor into an already started company. <p>Also covers the actions of the Final Minor Exchange Round, in which minors can also be closed (in that case, the MergeCompanies.major attribute is null, which never occurs in normal stock rounds).
 * @param action
 * @return
 */
protected boolean mergeCompanies(MergeCompanies action){
  PublicCompanyI minor=action.getMergingCompany();
  PublicCompanyI major=action.getSelectedTargetCompany();
  PublicCertificateI cert=null;
  Portfolio pool=Bank.getPool();
  CashHolder cashDestination=null;
  MoveSet.start(true);
  if (major != null) {
    cert=major.getPortfolio().findCertificate(major,false);
    if (cert != null) {
      cashDestination=major;
    }
 else {
      cert=pool.findCertificate(major,false);
    }
  }
  int minorCash=minor.getCash();
  int minorTrains=minor.getPortfolio().getTrainList().size();
  if (cashDestination == null) {
    if (minorCash > 0)     new CashMove(minor,null,minorCash);
    pool.transferAssetsFrom(minor.getPortfolio());
  }
 else {
    major.transferAssetsFrom(minor);
  }
  MapHex homeHex=minor.getHomeHex();
  int homeCityNumber=homeHex.getCityOfBaseToken(minor);
  minor.setClosed();
  if (major != null && action.getReplaceToken()) {
    if (homeHex.layBaseToken(major,homeCityNumber)) {
      major.layBaseToken(homeHex,homeCityNumber);
    }
  }
  if (major != null) {
    checkFlotation(major);
    if (major.getNumberOfTrains() > major.getCurrentTrainLimit() && !compWithExcessTrains.contains(major)) {
      new AddToList<PublicCompanyI>(compWithExcessTrains,major,""String_Node_Str"");
    }
  }
  if (cert != null) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{currentPlayer.getName(),minor.getName(),major.getName(),Bank.format(minorCash),String.valueOf(minorTrains)}));
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{currentPlayer.getName(),String.valueOf(cert.getShare()),major.getName(),cert.getPortfolio().getName(),minor.getName()}));
    cert.moveTo(currentPlayer.getPortfolio());
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",minor.getName()));
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{currentPlayer.getName(),minor.getName(),Bank.format(minorCash),String.valueOf(minorTrains)}));
  }
  hasActed.set(true);
  if (!(this instanceof FinalMinorExchangeRound)) {
    companyBoughtThisTurnWrapper.set(major);
    setPriority();
  }
  return true;
}","/** 
 * Merge a minor into an already started company. <p>Also covers the actions of the Final Minor Exchange Round, in which minors can also be closed (in that case, the MergeCompanies.major attribute is null, which never occurs in normal stock rounds).
 * @param action
 * @return
 */
protected boolean mergeCompanies(MergeCompanies action){
  PublicCompanyI minor=action.getMergingCompany();
  PublicCompanyI major=action.getSelectedTargetCompany();
  PublicCertificateI cert=null;
  Portfolio pool=Bank.getPool();
  CashHolder cashDestination=null;
  MoveSet.start(true);
  if (major != null) {
    cert=major.getPortfolio().findCertificate(major,false);
    if (cert != null) {
      cashDestination=major;
    }
 else {
      cert=pool.findCertificate(major,false);
    }
  }
  int minorCash=minor.getCash();
  int minorTrains=minor.getPortfolio().getTrainList().size();
  if (cashDestination == null) {
    if (minorCash > 0)     new CashMove(minor,null,minorCash);
    pool.transferAssetsFrom(minor.getPortfolio());
  }
 else {
    major.transferAssetsFrom(minor);
  }
  MapHex homeHex=minor.getHomeHex();
  int homeCityNumber=homeHex.getCityOfBaseToken(minor);
  minor.setClosed();
  if (major != null && action.getReplaceToken()) {
    if (homeHex.layBaseToken(major,homeCityNumber)) {
      major.layBaseToken(homeHex,homeCityNumber);
    }
  }
  if (major != null) {
    if (major.getNumberOfTrains() > major.getCurrentTrainLimit() && !compWithExcessTrains.contains(major)) {
      new AddToList<PublicCompanyI>(compWithExcessTrains,major,""String_Node_Str"");
    }
  }
  if (cert != null) {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{currentPlayer.getName(),minor.getName(),major.getName(),Bank.format(minorCash),String.valueOf(minorTrains)}));
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{currentPlayer.getName(),String.valueOf(cert.getShare()),major.getName(),cert.getPortfolio().getName(),minor.getName()}));
    cert.moveTo(currentPlayer.getPortfolio());
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",minor.getName()));
    checkFlotation(major);
  }
 else {
    ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{currentPlayer.getName(),minor.getName(),Bank.format(minorCash),String.valueOf(minorTrains)}));
  }
  hasActed.set(true);
  if (!(this instanceof FinalMinorExchangeRound)) {
    companyBoughtThisTurnWrapper.set(major);
    setPriority();
  }
  return true;
}",0.9890466531440162
173814,"/** 
 * Prepare a tile upgrade. The actual tile replacement is done in replaceTile(), via a TileMove object.
 */
public void upgrade(TileI newTile,int newRotation){
  City newCity;
  String newTracks;
  if (currentTile.getNumStations() == newTile.getNumStations()) {
    for (    City city : cities) {
      Station oldStation=city.getRelatedStation();
      int[] oldTrackEnds=getTrackEndPoints(currentTile,currentTileRotation,oldStation);
      if (oldTrackEnds.length == 0) {
        Station newStation=newTile.getStations().get(city.getNumber() - 1);
        city.setRelatedStation(newStation);
        city.setSlots(newStation.getBaseSlots());
        log.debug(""String_Node_Str"" + city.getUniqueId() + ""String_Node_Str""+ oldStation.getId()+ ""String_Node_Str""+ getConnectionString(currentTile,currentTileRotation,oldStation.getNumber())+ ""String_Node_Str""+ newStation.getId()+ ""String_Node_Str""+ getConnectionString(newTile,newRotation,newStation.getNumber()));
        continue;
      }
      station:       for (      Station newStation : newTile.getStations()) {
        int[] newTrackEnds=getTrackEndPoints(newTile,newRotation,newStation);
        for (int i=0; i < oldTrackEnds.length; i++) {
          for (int j=0; j < newTrackEnds.length; j++) {
            if (oldTrackEnds[i] == newTrackEnds[j]) {
              city.setRelatedStation(newStation);
              city.setSlots(newStation.getBaseSlots());
              newTracks=getConnectionString(newTile,newRotation,newStation.getNumber());
              city.setTrackEdges(newTracks);
              log.debug(""String_Node_Str"" + city.getUniqueId() + ""String_Node_Str""+ oldStation.getId()+ ""String_Node_Str""+ getConnectionString(currentTile,currentTileRotation,oldStation.getNumber())+ ""String_Node_Str""+ newStation.getId()+ ""String_Node_Str""+ newTracks);
              break station;
            }
          }
        }
      }
    }
    new TileMove(this,currentTile,currentTileRotation,cities,newTile,newRotation,cities);
  }
 else {
    List<City> newCities=new ArrayList<City>(4);
    Map<Integer,City> mNewCities=new HashMap<Integer,City>(4);
    Map<City,City> oldToNewCities=new HashMap<City,City>();
    Map<Station,City> newStationsToCities=new HashMap<Station,City>();
    for (    City oldCity : cities) {
      int cityNumber=oldCity.getNumber();
      Station oldStation=oldCity.getRelatedStation();
      int[] oldTrackEnds=getTrackEndPoints(currentTile,currentTileRotation,oldStation);
      log.debug(""String_Node_Str"" + currentTile.getId() + ""String_Node_Str""+ oldCity.getNumber()+ ""String_Node_Str""+ getConnectionString(currentTile,currentTileRotation,oldStation.getNumber()));
      station:       for (      Station newStation : newTile.getStations()) {
        int[] newTrackEnds=getTrackEndPoints(newTile,newRotation,newStation);
        log.debug(""String_Node_Str"" + newTile.getId() + ""String_Node_Str""+ newStation.getNumber()+ ""String_Node_Str""+ getConnectionString(newTile,newRotation,newStation.getNumber()));
        for (int i=0; i < oldTrackEnds.length; i++) {
          for (int j=0; j < newTrackEnds.length; j++) {
            if (oldTrackEnds[i] == newTrackEnds[j]) {
              if (!newStationsToCities.containsKey(newStation)) {
                newCity=new City(this,cityNumber,newStation);
                newCities.add(newCity);
                mNewCities.put(cityNumber,newCity);
                newStationsToCities.put(newStation,newCity);
                newCity.setSlots(newStation.getBaseSlots());
              }
 else {
                newCity=newStationsToCities.get(newStation);
              }
              oldToNewCities.put(oldCity,newCity);
              newTracks=getConnectionString(newTile,newRotation,newStation.getNumber());
              newCity.setTrackEdges(newTracks);
              log.debug(""String_Node_Str"" + oldCity.getUniqueId() + ""String_Node_Str""+ currentTile.getId()+ ""String_Node_Str""+ currentTileRotation+ ""String_Node_Str""+ oldStation.getId()+ ""String_Node_Str""+ getConnectionString(currentTile,currentTileRotation,oldStation.getNumber())+ ""String_Node_Str""+ newCity.getUniqueId()+ ""String_Node_Str""+ newTile.getId()+ ""String_Node_Str""+ newRotation+ ""String_Node_Str""+ newStation.getId()+ ""String_Node_Str""+ newTracks);
              break station;
            }
          }
        }
      }
    }
    for (    Station newStation : newTile.getStations()) {
      if (newStationsToCities.containsKey(newStation))       continue;
      int cityNumber;
      for (cityNumber=1; mNewCities.containsKey(cityNumber); cityNumber++)       ;
      newCity=new City(this,cityNumber,newStation);
      newCities.add(newCity);
      mNewCities.put(cityNumber,newCity);
      newStationsToCities.put(newStation,newCity);
      newCity.setSlots(newStation.getBaseSlots());
      newTracks=getConnectionString(newTile,newRotation,newStation.getNumber());
      newCity.setTrackEdges(newTracks);
      log.debug(""String_Node_Str"" + newCity.getUniqueId() + ""String_Node_Str""+ newTile.getId()+ ""String_Node_Str""+ newRotation+ ""String_Node_Str""+ newStation.getId()+ ""String_Node_Str""+ newTracks);
    }
    Map<TokenI,TokenHolderI> tokenDestinations=new HashMap<TokenI,TokenHolderI>();
    for (    City oldCity : cities) {
      newCity=oldToNewCities.get(oldCity);
      if (newCity != null) {
        oldtoken:         for (        TokenI token : oldCity.getTokens()) {
          if (token instanceof BaseToken) {
            PublicCompanyI company=((BaseToken)token).getCompany();
            for (            TokenI token2 : newCity.getTokens()) {
              if (token2 instanceof BaseToken && company == ((BaseToken)token2).getCompany()) {
                tokenDestinations.put(token,company);
                log.debug(""String_Node_Str"" + token.getUniqueId() + ""String_Node_Str""+ oldCity.getName()+ ""String_Node_Str""+ company.getName());
                ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{company.getName(),getName()}));
                continue oldtoken;
              }
            }
          }
          tokenDestinations.put(token,newCity);
          log.debug(""String_Node_Str"" + token.getUniqueId() + ""String_Node_Str""+ oldCity.getName()+ ""String_Node_Str""+ newCity.getName());
        }
        if (!tokenDestinations.isEmpty()) {
          for (          TokenI token : tokenDestinations.keySet()) {
            token.moveTo(tokenDestinations.get(token));
          }
        }
      }
 else {
        log.debug(""String_Node_Str"");
      }
    }
    new TileMove(this,currentTile,currentTileRotation,cities,newTile,newRotation,newCities);
  }
}","/** 
 * Prepare a tile upgrade. The actual tile replacement is done in replaceTile(), via a TileMove object.
 */
public void upgrade(TileI newTile,int newRotation){
  City newCity;
  String newTracks;
  if (currentTile.getNumStations() == newTile.getNumStations()) {
    for (    City city : cities) {
      Station oldStation=city.getRelatedStation();
      int[] oldTrackEnds=getTrackEndPoints(currentTile,currentTileRotation,oldStation);
      if (oldTrackEnds.length == 0) {
        Station newStation=newTile.getStations().get(city.getNumber() - 1);
        city.setRelatedStation(newStation);
        city.setSlots(newStation.getBaseSlots());
        log.debug(""String_Node_Str"" + city.getUniqueId() + ""String_Node_Str""+ oldStation.getId()+ ""String_Node_Str""+ getConnectionString(currentTile,currentTileRotation,oldStation.getNumber())+ ""String_Node_Str""+ newStation.getId()+ ""String_Node_Str""+ getConnectionString(newTile,newRotation,newStation.getNumber()));
        continue;
      }
      station:       for (      Station newStation : newTile.getStations()) {
        int[] newTrackEnds=getTrackEndPoints(newTile,newRotation,newStation);
        for (int i=0; i < oldTrackEnds.length; i++) {
          for (int j=0; j < newTrackEnds.length; j++) {
            if (oldTrackEnds[i] == newTrackEnds[j]) {
              city.setRelatedStation(newStation);
              city.setSlots(newStation.getBaseSlots());
              newTracks=getConnectionString(newTile,newRotation,newStation.getNumber());
              city.setTrackEdges(newTracks);
              log.debug(""String_Node_Str"" + city.getUniqueId() + ""String_Node_Str""+ oldStation.getId()+ ""String_Node_Str""+ getConnectionString(currentTile,currentTileRotation,oldStation.getNumber())+ ""String_Node_Str""+ newStation.getId()+ ""String_Node_Str""+ newTracks);
              break station;
            }
          }
        }
      }
    }
    new TileMove(this,currentTile,currentTileRotation,cities,newTile,newRotation,cities);
  }
 else {
    List<City> newCities=new ArrayList<City>(4);
    Map<Integer,City> mNewCities=new HashMap<Integer,City>(4);
    Map<City,City> oldToNewCities=new HashMap<City,City>();
    Map<Station,City> newStationsToCities=new HashMap<Station,City>();
    int newCityNumber=0;
    for (    City oldCity : cities) {
      int cityNumber=oldCity.getNumber();
      Station oldStation=oldCity.getRelatedStation();
      int[] oldTrackEnds=getTrackEndPoints(currentTile,currentTileRotation,oldStation);
      log.debug(""String_Node_Str"" + currentTile.getId() + ""String_Node_Str""+ oldCity.getNumber()+ ""String_Node_Str""+ getConnectionString(currentTile,currentTileRotation,oldStation.getNumber()));
      station:       for (      Station newStation : newTile.getStations()) {
        int[] newTrackEnds=getTrackEndPoints(newTile,newRotation,newStation);
        log.debug(""String_Node_Str"" + newTile.getId() + ""String_Node_Str""+ newStation.getNumber()+ ""String_Node_Str""+ getConnectionString(newTile,newRotation,newStation.getNumber()));
        for (int i=0; i < oldTrackEnds.length; i++) {
          for (int j=0; j < newTrackEnds.length; j++) {
            if (oldTrackEnds[i] == newTrackEnds[j]) {
              if (!newStationsToCities.containsKey(newStation)) {
                newCity=new City(this,++newCityNumber,newStation);
                newCities.add(newCity);
                mNewCities.put(cityNumber,newCity);
                newStationsToCities.put(newStation,newCity);
                newCity.setSlots(newStation.getBaseSlots());
              }
 else {
                newCity=newStationsToCities.get(newStation);
              }
              oldToNewCities.put(oldCity,newCity);
              newTracks=getConnectionString(newTile,newRotation,newStation.getNumber());
              newCity.setTrackEdges(newTracks);
              log.debug(""String_Node_Str"" + oldCity.getUniqueId() + ""String_Node_Str""+ currentTile.getId()+ ""String_Node_Str""+ currentTileRotation+ ""String_Node_Str""+ oldStation.getId()+ ""String_Node_Str""+ getConnectionString(currentTile,currentTileRotation,oldStation.getNumber())+ ""String_Node_Str""+ newCity.getUniqueId()+ ""String_Node_Str""+ newTile.getId()+ ""String_Node_Str""+ newRotation+ ""String_Node_Str""+ newStation.getId()+ ""String_Node_Str""+ newTracks);
              break station;
            }
          }
        }
      }
    }
    for (    City oldCity : cities) {
      if (oldToNewCities.containsKey(oldCity))       continue;
      Station oldStation=oldCity.getRelatedStation();
      int[] oldTrackEnds=getTrackEndPoints(currentTile,currentTileRotation,oldStation);
      station:       for (int i=0; i < oldTrackEnds.length; i++) {
        log.debug(""String_Node_Str"" + oldTrackEnds[i]);
        if (oldTrackEnds[i] < 0) {
          int oldStationNumber=-oldTrackEnds[i];
          for (          City oldCity2 : cities) {
            log.debug(""String_Node_Str"" + oldCity2.getNumber() + ""String_Node_Str""+ oldCity2.getRelatedStation().getNumber());
            log.debug(""String_Node_Str"" + oldToNewCities.get(oldCity2));
            if (oldCity2.getRelatedStation().getNumber() == oldStationNumber && oldToNewCities.containsKey(oldCity2)) {
              newCity=oldToNewCities.get(oldCity2);
              oldToNewCities.put(oldCity,newCity);
              log.debug(""String_Node_Str"" + oldCity.getUniqueId() + ""String_Node_Str""+ currentTile.getId()+ ""String_Node_Str""+ currentTileRotation+ ""String_Node_Str""+ oldStation.getId()+ ""String_Node_Str""+ getConnectionString(currentTile,currentTileRotation,oldStation.getNumber())+ ""String_Node_Str""+ newCity.getUniqueId()+ ""String_Node_Str""+ newTile.getId()+ ""String_Node_Str""+ newRotation+ ""String_Node_Str""+ newCity.getRelatedStation().getId()+ ""String_Node_Str""+ newCity.getTrackEdges());
              break station;
            }
          }
        }
      }
    }
    for (    Station newStation : newTile.getStations()) {
      if (newStationsToCities.containsKey(newStation))       continue;
      int cityNumber;
      for (cityNumber=1; mNewCities.containsKey(cityNumber); cityNumber++)       ;
      newCity=new City(this,++newCityNumber,newStation);
      newCities.add(newCity);
      mNewCities.put(cityNumber,newCity);
      newStationsToCities.put(newStation,newCity);
      newCity.setSlots(newStation.getBaseSlots());
      newTracks=getConnectionString(newTile,newRotation,newStation.getNumber());
      newCity.setTrackEdges(newTracks);
      log.debug(""String_Node_Str"" + newCity.getUniqueId() + ""String_Node_Str""+ newTile.getId()+ ""String_Node_Str""+ newRotation+ ""String_Node_Str""+ newStation.getId()+ ""String_Node_Str""+ newTracks);
    }
    Map<TokenI,TokenHolderI> tokenDestinations=new HashMap<TokenI,TokenHolderI>();
    for (    City oldCity : cities) {
      newCity=oldToNewCities.get(oldCity);
      if (newCity != null) {
        oldtoken:         for (        TokenI token : oldCity.getTokens()) {
          if (token instanceof BaseToken) {
            PublicCompanyI company=((BaseToken)token).getCompany();
            for (            TokenI token2 : newCity.getTokens()) {
              if (token2 instanceof BaseToken && company == ((BaseToken)token2).getCompany()) {
                tokenDestinations.put(token,company);
                log.debug(""String_Node_Str"" + token.getUniqueId() + ""String_Node_Str""+ oldCity.getName()+ ""String_Node_Str""+ company.getName());
                ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{company.getName(),getName()}));
                continue oldtoken;
              }
            }
          }
          tokenDestinations.put(token,newCity);
          log.debug(""String_Node_Str"" + token.getUniqueId() + ""String_Node_Str""+ oldCity.getName()+ ""String_Node_Str""+ newCity.getName());
        }
        if (!tokenDestinations.isEmpty()) {
          for (          TokenI token : tokenDestinations.keySet()) {
            token.moveTo(tokenDestinations.get(token));
          }
        }
      }
 else {
        log.debug(""String_Node_Str"");
      }
    }
    new TileMove(this,currentTile,currentTileRotation,cities,newTile,newRotation,newCities);
  }
}",0.8823131094257854
173815,"/** 
 * Create a list of certificates that a player may buy in a Stock Round, taking all rules into account.
 * @return List of buyable certificates.
 */
public void setBuyableCerts(){
  if (!mayCurrentPlayerBuyAnything())   return;
  List<PublicCertificateI> certs;
  PublicCertificateI cert;
  PublicCompanyI comp;
  StockSpaceI stockSpace;
  Portfolio from;
  int price;
  int number;
  int playerCash=currentPlayer.getCash();
  PublicCompanyI companyBoughtThisTurn=(PublicCompanyI)companyBoughtThisTurnWrapper.getObject();
  if (companyBoughtThisTurn == null) {
    from=ipo;
    Map<String,List<PublicCertificateI>> map=from.getCertsPerCompanyMap();
    int shares;
    for (    String compName : map.keySet()) {
      certs=map.get(compName);
      if (certs == null || certs.isEmpty())       continue;
      cert=certs.get(0);
      comp=cert.getCompany();
      if (isSaleRecorded(currentPlayer,comp))       continue;
      if (currentPlayer.maxAllowedNumberOfSharesToBuy(comp,cert.getShare()) < 1)       continue;
      shares=cert.getShares();
      if (!cert.isPresidentShare()) {
        if (cert.getCertificatePrice() <= playerCash) {
          possibleActions.add(new BuyCertificate(cert,from));
        }
      }
 else       if (!comp.hasStarted()) {
        if (comp.hasParPrice()) {
          price=comp.getParPrice().getPrice() * cert.getShares();
          possibleActions.add(new StartCompany(cert,price));
        }
 else {
          List<Integer> startPrices=new ArrayList<Integer>();
          for (          int startPrice : stockMarket.getStartPrices()) {
            if (startPrice * shares <= playerCash) {
              startPrices.add(startPrice);
            }
          }
          if (startPrices.size() > 0) {
            int[] prices=new int[startPrices.size()];
            Arrays.sort(prices);
            for (int i=0; i < prices.length; i++) {
              prices[i]=startPrices.get(i);
            }
            possibleActions.add(new StartCompany(cert,prices));
          }
        }
      }
 else       if (comp.hasParPrice()) {
        price=comp.getParPrice().getPrice() * cert.getShares();
        if (price <= playerCash) {
          possibleActions.add(new BuyCertificate(cert,from,price));
        }
      }
    }
  }
  from=pool;
  Map<String,List<PublicCertificateI>> map=from.getCertsPerCompanyMap();
  for (  String compName : map.keySet()) {
    certs=map.get(compName);
    if (certs == null || certs.isEmpty())     continue;
    number=certs.size();
    cert=certs.get(0);
    comp=cert.getCompany();
    if (isSaleRecorded(currentPlayer,comp))     continue;
    if (currentPlayer.maxAllowedNumberOfSharesToBuy(comp,cert.getShare()) < 1)     continue;
    stockSpace=comp.getCurrentPrice();
    price=stockSpace.getPrice();
    if (companyBoughtThisTurn != null) {
      if (comp != companyBoughtThisTurn)       continue;
      if (!stockSpace.isNoBuyLimit())       continue;
    }
    if (!stockSpace.isNoBuyLimit()) {
      number=1;
      if (!currentPlayer.mayBuyCompanyShare(comp,number))       continue;
      if (!stockSpace.isNoCertLimit() && !currentPlayer.mayBuyCertificate(comp,number))       continue;
    }
    while (number > 0 && playerCash < number * price)     number--;
    if (number > 0) {
      possibleActions.add(new BuyCertificate(cert,from,price,number));
    }
  }
  if (gameManager.canAnyCompanyHoldShares()) {
    for (    PublicCompanyI company : companyManager.getAllPublicCompanies()) {
      certs=company.getPortfolio().getCertificatesPerCompany(company.getName());
      if (certs == null || certs.isEmpty())       continue;
      cert=certs.get(0);
      if (isSaleRecorded(currentPlayer,company))       continue;
      if (!currentPlayer.mayBuyCompanyShare(company,1))       continue;
      if (currentPlayer.maxAllowedNumberOfSharesToBuy(company,certs.get(0).getShare()) < 1)       continue;
      stockSpace=company.getCurrentPrice();
      if (!stockSpace.isNoCertLimit() && !currentPlayer.mayBuyCertificate(company,1))       continue;
      if (cert.getCertificatePrice() <= playerCash) {
        possibleActions.add(new BuyCertificate(cert,company.getPortfolio()));
      }
    }
  }
}","/** 
 * Create a list of certificates that a player may buy in a Stock Round, taking all rules into account.
 * @return List of buyable certificates.
 */
public void setBuyableCerts(){
  if (!mayCurrentPlayerBuyAnything())   return;
  List<PublicCertificateI> certs;
  PublicCertificateI cert;
  PublicCompanyI comp;
  StockSpaceI stockSpace;
  Portfolio from;
  int price;
  int number;
  int playerCash=currentPlayer.getCash();
  PublicCompanyI companyBoughtThisTurn=(PublicCompanyI)companyBoughtThisTurnWrapper.getObject();
  if (companyBoughtThisTurn == null) {
    from=ipo;
    Map<String,List<PublicCertificateI>> map=from.getCertsPerCompanyMap();
    int shares;
    for (    String compName : map.keySet()) {
      certs=map.get(compName);
      if (certs == null || certs.isEmpty())       continue;
      cert=certs.get(0);
      comp=cert.getCompany();
      if (isSaleRecorded(currentPlayer,comp))       continue;
      if (currentPlayer.maxAllowedNumberOfSharesToBuy(comp,cert.getShare()) < 1)       continue;
      shares=cert.getShares();
      if (!cert.isPresidentShare()) {
        if (cert.getCertificatePrice() <= playerCash) {
          possibleActions.add(new BuyCertificate(cert,from));
        }
      }
 else       if (!comp.hasStarted()) {
        if (comp.getParPrice() != null) {
          price=comp.getParPrice().getPrice() * cert.getShares();
          possibleActions.add(new StartCompany(cert,price));
        }
 else {
          List<Integer> startPrices=new ArrayList<Integer>();
          for (          int startPrice : stockMarket.getStartPrices()) {
            if (startPrice * shares <= playerCash) {
              startPrices.add(startPrice);
            }
          }
          if (startPrices.size() > 0) {
            int[] prices=new int[startPrices.size()];
            Arrays.sort(prices);
            for (int i=0; i < prices.length; i++) {
              prices[i]=startPrices.get(i);
            }
            possibleActions.add(new StartCompany(cert,prices));
          }
        }
      }
 else       if (comp.hasParPrice()) {
        price=comp.getParPrice().getPrice() * cert.getShares();
        if (price <= playerCash) {
          possibleActions.add(new BuyCertificate(cert,from,price));
        }
      }
    }
  }
  from=pool;
  Map<String,List<PublicCertificateI>> map=from.getCertsPerCompanyMap();
  for (  String compName : map.keySet()) {
    certs=map.get(compName);
    if (certs == null || certs.isEmpty())     continue;
    number=certs.size();
    cert=certs.get(0);
    comp=cert.getCompany();
    if (isSaleRecorded(currentPlayer,comp))     continue;
    if (currentPlayer.maxAllowedNumberOfSharesToBuy(comp,cert.getShare()) < 1)     continue;
    stockSpace=comp.getCurrentPrice();
    price=stockSpace.getPrice();
    if (companyBoughtThisTurn != null) {
      if (comp != companyBoughtThisTurn)       continue;
      if (!stockSpace.isNoBuyLimit())       continue;
    }
    if (!stockSpace.isNoBuyLimit()) {
      number=1;
      if (!currentPlayer.mayBuyCompanyShare(comp,number))       continue;
      if (!stockSpace.isNoCertLimit() && !currentPlayer.mayBuyCertificate(comp,number))       continue;
    }
    while (number > 0 && playerCash < number * price)     number--;
    if (number > 0) {
      possibleActions.add(new BuyCertificate(cert,from,price,number));
    }
  }
  if (gameManager.canAnyCompanyHoldShares()) {
    for (    PublicCompanyI company : companyManager.getAllPublicCompanies()) {
      certs=company.getPortfolio().getCertificatesPerCompany(company.getName());
      if (certs == null || certs.isEmpty())       continue;
      cert=certs.get(0);
      if (isSaleRecorded(currentPlayer,company))       continue;
      if (!currentPlayer.mayBuyCompanyShare(company,1))       continue;
      if (currentPlayer.maxAllowedNumberOfSharesToBuy(company,certs.get(0).getShare()) < 1)       continue;
      stockSpace=company.getCurrentPrice();
      if (!stockSpace.isNoCertLimit() && !currentPlayer.mayBuyCertificate(company,1))       continue;
      if (cert.getCertificatePrice() <= playerCash) {
        possibleActions.add(new BuyCertificate(cert,company.getPortfolio()));
      }
    }
  }
}",0.9959388437649308
173816,"/** 
 * @see rails.game.ConfigurableComponentI#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Tag tag) throws ConfigurationException {
  try {
    basePrice=tag.getAttributeAsInteger(""String_Node_Str"",0);
    revenue=tag.getAttributeAsInteger(""String_Node_Str"",0);
    Tag blockedTag=tag.getChild(""String_Node_Str"");
    if (blockedTag != null) {
      String[] hexes=blockedTag.getAttributeAsString(""String_Node_Str"").split(""String_Node_Str"");
      if (hexes != null && hexes.length > 0) {
        blockedHexes=new ArrayList<MapHex>();
        for (        String hexName : hexes) {
          MapHex hex=MapManager.getInstance().getHex(hexName);
          blockedHexes.add(hex);
          hex.setBlocked(true);
        }
      }
    }
    Tag spsTag=tag.getChild(""String_Node_Str"");
    if (spsTag != null) {
      closeIfAllExercised=spsTag.getAttributeAsBoolean(""String_Node_Str"",closeIfAllExercised);
      specialProperties=new ArrayList<SpecialPropertyI>();
      List<Tag> spTags=spsTag.getChildren(""String_Node_Str"");
      String className;
      for (      Tag spTag : spTags) {
        className=spTag.getAttributeAsString(""String_Node_Str"");
        if (!Util.hasValue(className))         throw new ConfigurationException(""String_Node_Str"");
        SpecialPropertyI sp=(SpecialPropertyI)Class.forName(className).newInstance();
        sp.setCompany(this);
        specialProperties.add(sp);
        sp.configureFromXML(spTag);
      }
    }
  }
 catch (  Exception e) {
    throw new ConfigurationException(""String_Node_Str"" + name,e);
  }
}","/** 
 * @see rails.game.ConfigurableComponentI#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Tag tag) throws ConfigurationException {
  try {
    basePrice=tag.getAttributeAsInteger(""String_Node_Str"",0);
    revenue=tag.getAttributeAsInteger(""String_Node_Str"",0);
    Tag blockedTag=tag.getChild(""String_Node_Str"");
    if (blockedTag != null) {
      String[] hexes=blockedTag.getAttributeAsString(""String_Node_Str"").split(""String_Node_Str"");
      if (hexes != null && hexes.length > 0) {
        blockedHexes=new ArrayList<MapHex>();
        for (        String hexName : hexes) {
          MapHex hex=MapManager.getInstance().getHex(hexName);
          blockedHexes.add(hex);
          hex.setBlocked(true);
        }
      }
    }
    Tag spsTag=tag.getChild(""String_Node_Str"");
    if (spsTag != null) {
      closeIfAllExercised=spsTag.getAttributeAsBoolean(""String_Node_Str"",closeIfAllExercised);
      List<Tag> spTags=spsTag.getChildren(""String_Node_Str"");
      String className;
      for (      Tag spTag : spTags) {
        className=spTag.getAttributeAsString(""String_Node_Str"");
        if (!Util.hasValue(className))         throw new ConfigurationException(""String_Node_Str"");
        SpecialPropertyI sp=(SpecialPropertyI)Class.forName(className).newInstance();
        sp.setCompany(this);
        specialProperties.add(sp);
        sp.configureFromXML(spTag);
      }
    }
  }
 catch (  Exception e) {
    throw new ConfigurationException(""String_Node_Str"" + name,e);
  }
}",0.9809616005162956
173817,"/** 
 * Buy a start item against the base price.
 * @param playerName Name of the buying player.
 * @param itemName Name of the bought start item.
 * @param sharePrice If nonzero: share price if item contains a President'sshare
 * @return False in case of any errors.
 */
protected boolean buy(String playerName,BuyStartItem boughtItem){
  StartItem item=boughtItem.getStartItem();
  String errMsg=null;
  Player player=getCurrentPlayer();
  int price=0;
  int sharePrice=0;
  String shareCompName=""String_Node_Str"";
  while (true) {
    if (!boughtItem.setSharePriceOnly()) {
      if (item.getStatus() != StartItem.BUYABLE) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
      price=item.getBasePrice();
      if (item.getBid() > price)       price=item.getBid();
      if (player.getFreeCash() < price) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
    }
    if (boughtItem.hasSharePriceToSet()) {
      shareCompName=boughtItem.getCompanyToSetPriceFor();
      sharePrice=boughtItem.getAssociatedSharePrice();
      if (sharePrice == 0) {
        errMsg=LocalText.getText(""String_Node_Str"",shareCompName);
        break;
      }
      if ((StockMarket.getInstance().getStartSpace(sharePrice)) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",new String[]{Bank.format(sharePrice),shareCompName});
        break;
      }
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{playerName,item.getName(),errMsg}));
    return false;
  }
  MoveSet.start(false);
  assignItem(player,item,price,sharePrice);
  gameManager.setPriorityPlayer();
  setNextPlayer();
  auctionItemState.set(null);
  numPasses.set(0);
  return true;
}","/** 
 * Buy a start item against the base price.
 * @param playerName Name of the buying player.
 * @param itemName Name of the bought start item.
 * @param sharePrice If nonzero: share price if item contains a President'sshare
 * @return False in case of any errors.
 */
protected boolean buy(String playerName,BuyStartItem boughtItem){
  StartItem item=boughtItem.getStartItem();
  String errMsg=null;
  Player player=getCurrentPlayer();
  int price=0;
  int sharePrice=0;
  String shareCompName=""String_Node_Str"";
  while (true) {
    if (!boughtItem.setSharePriceOnly()) {
      if (item.getStatus() != StartItem.BUYABLE) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
      price=item.getBasePrice();
      if (item.getBid() > price)       price=item.getBid();
      if (player.getFreeCash() < price) {
        errMsg=LocalText.getText(""String_Node_Str"");
        break;
      }
    }
 else {
      price=item.getBid();
    }
    if (boughtItem.hasSharePriceToSet()) {
      shareCompName=boughtItem.getCompanyToSetPriceFor();
      sharePrice=boughtItem.getAssociatedSharePrice();
      if (sharePrice == 0) {
        errMsg=LocalText.getText(""String_Node_Str"",shareCompName);
        break;
      }
      if ((StockMarket.getInstance().getStartSpace(sharePrice)) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",new String[]{Bank.format(sharePrice),shareCompName});
        break;
      }
    }
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{playerName,item.getName(),errMsg}));
    return false;
  }
  MoveSet.start(false);
  assignItem(player,item,price,sharePrice);
  gameManager.setPriorityPlayer();
  setNextPlayer();
  auctionItemState.set(null);
  numPasses.set(0);
  return true;
}",0.988499298737728
173818,"public boolean setPossibleActions(){
  boolean passAllowed=true;
  possibleActions.clear();
  if (StartPacket.getStartPacket().areAllSold())   return false;
  StartItem auctionItem=(StartItem)auctionItemState.getObject();
  while (possibleActions.isEmpty()) {
    Player currentPlayer=getCurrentPlayer();
    for (    StartItem item : itemsToSell) {
      if (item.isSold()) {
      }
 else       if (item.getStatus() == StartItem.AUCTIONED) {
        item.setStatus(StartItem.AUCTIONED);
        if (currentPlayer.getFreeCash() + auctionItem.getBid(currentPlayer) >= auctionItem.getMinimumBid()) {
          BidStartItem possibleAction=new BidStartItem(auctionItem,auctionItem.getMinimumBid(),startPacket.getModulus(),true);
          possibleActions.add(possibleAction);
          break;
        }
 else {
          break;
        }
      }
 else       if (item.getStatus() == StartItem.NEEDS_SHARE_PRICE) {
        possibleActions.add(new BuyStartItem(item,0,false,true));
        passAllowed=false;
        break;
      }
 else       if (item == startPacket.getFirstUnsoldItem()) {
        if (item.getBidders() == 1) {
          PublicCompanyI comp=item.needsPriceSetting();
          if (comp != null) {
            setPlayer(item.getBidder());
            item.setStatus(StartItem.NEEDS_SHARE_PRICE);
            BuyStartItem newItem=new BuyStartItem(item,item.getBasePrice(),true,true);
            possibleActions.add(newItem);
            break;
          }
 else {
            assignItem(item.getBidder(),item,item.getBid(),0);
          }
        }
 else         if (item.getBidders() > 1) {
          ReportBuffer.add(LocalText.getText(""String_Node_Str"",item.getName()));
          if (item.getStatus() != StartItem.AUCTIONED) {
            setNextBiddingPlayer(item,item.getBidder().getIndex());
            currentPlayer=getCurrentPlayer();
            item.setStatus(StartItem.AUCTIONED);
            auctionItemState.set(item);
          }
          if (currentPlayer.getFreeCash() + item.getBid(currentPlayer) >= item.getMinimumBid()) {
            BidStartItem possibleAction=new BidStartItem(item,item.getMinimumBid(),startPacket.getModulus(),true);
            possibleActions.add(possibleAction);
          }
          break;
        }
 else {
          item.setStatus(StartItem.BUYABLE);
          if (currentPlayer.getFreeCash() >= item.getBasePrice()) {
            possibleActions.add(new BuyStartItem(item,item.getBasePrice(),false));
          }
        }
      }
 else {
        item.setStatus(StartItem.BIDDABLE);
        if (currentPlayer.getFreeCash() + item.getBid(currentPlayer) >= item.getMinimumBid()) {
          BidStartItem possibleAction=new BidStartItem(item,item.getMinimumBid(),startPacket.getModulus(),false);
          possibleActions.add(possibleAction);
        }
      }
    }
    if (StartPacket.getStartPacket().areAllSold()) {
      return false;
    }
    if (possibleActions.isEmpty()) {
      numPasses.add(1);
      if (auctionItemState.getObject() == null) {
        setNextPlayer();
      }
 else {
        setNextBiddingPlayer((StartItem)auctionItemState.getObject());
      }
    }
  }
  if (passAllowed) {
    possibleActions.add(new NullAction(NullAction.PASS));
  }
  return true;
}","public boolean setPossibleActions(){
  boolean passAllowed=true;
  possibleActions.clear();
  if (StartPacket.getStartPacket().areAllSold())   return false;
  StartItem auctionItem=(StartItem)auctionItemState.getObject();
  while (possibleActions.isEmpty()) {
    Player currentPlayer=getCurrentPlayer();
    for (    StartItem item : itemsToSell) {
      if (item.isSold()) {
      }
 else       if (item.getStatus() == StartItem.AUCTIONED) {
        item.setStatus(StartItem.AUCTIONED);
        if (currentPlayer.getFreeCash() + auctionItem.getBid(currentPlayer) >= auctionItem.getMinimumBid()) {
          BidStartItem possibleAction=new BidStartItem(auctionItem,auctionItem.getMinimumBid(),startPacket.getModulus(),true);
          possibleActions.add(possibleAction);
          break;
        }
 else {
          break;
        }
      }
 else       if (item.getStatus() == StartItem.NEEDS_SHARE_PRICE) {
        setPlayer(item.getBidder());
        possibleActions.add(new BuyStartItem(item,item.getBid(),false,true));
        passAllowed=false;
        break;
      }
 else       if (item == startPacket.getFirstUnsoldItem()) {
        if (item.getBidders() == 1) {
          PublicCompanyI comp=item.needsPriceSetting();
          if (comp != null) {
            setPlayer(item.getBidder());
            item.setStatus(StartItem.NEEDS_SHARE_PRICE);
            BuyStartItem newItem=new BuyStartItem(item,item.getBasePrice(),true,true);
            possibleActions.add(newItem);
            break;
          }
 else {
            assignItem(item.getBidder(),item,item.getBid(),0);
          }
        }
 else         if (item.getBidders() > 1) {
          ReportBuffer.add(LocalText.getText(""String_Node_Str"",item.getName()));
          if (item.getStatus() != StartItem.AUCTIONED) {
            setNextBiddingPlayer(item,item.getBidder().getIndex());
            currentPlayer=getCurrentPlayer();
            item.setStatus(StartItem.AUCTIONED);
            auctionItemState.set(item);
          }
          if (currentPlayer.getFreeCash() + item.getBid(currentPlayer) >= item.getMinimumBid()) {
            BidStartItem possibleAction=new BidStartItem(item,item.getMinimumBid(),startPacket.getModulus(),true);
            possibleActions.add(possibleAction);
          }
          break;
        }
 else {
          item.setStatus(StartItem.BUYABLE);
          if (currentPlayer.getFreeCash() >= item.getBasePrice()) {
            possibleActions.add(new BuyStartItem(item,item.getBasePrice(),false));
          }
        }
      }
 else {
        item.setStatus(StartItem.BIDDABLE);
        if (currentPlayer.getFreeCash() + item.getBid(currentPlayer) >= item.getMinimumBid()) {
          BidStartItem possibleAction=new BidStartItem(item,item.getMinimumBid(),startPacket.getModulus(),false);
          possibleActions.add(possibleAction);
        }
      }
    }
    if (StartPacket.getStartPacket().areAllSold()) {
      return false;
    }
    if (possibleActions.isEmpty()) {
      numPasses.add(1);
      if (auctionItemState.getObject() == null) {
        setNextPlayer();
      }
 else {
        setNextBiddingPlayer((StartItem)auctionItemState.getObject());
      }
    }
  }
  if (passAllowed) {
    possibleActions.add(new NullAction(NullAction.PASS));
  }
  return true;
}",0.992198256080771
173819,"public void transferAssetsFrom(PublicCompanyI otherCompany){
  Bank.transferCash(otherCompany,this,otherCompany.getCash());
  portfolio.transferAssetsFrom(otherCompany.getPortfolio());
}","public void transferAssetsFrom(PublicCompanyI otherCompany){
  new CashMove(otherCompany,this,otherCompany.getCash());
  portfolio.transferAssetsFrom(otherCompany.getPortfolio());
}",0.9536784741144414
173820,"/** 
 * Start a company by buying one or more shares (more applies to e.g. 1841)
 * @param player The player that wants to start a company.
 * @param company The company to start.
 * @param price The start (par) price (ignored if the price is fixed).
 * @param shares The number of shares to buy (can be more than 1 in e.g. 1841).
 * @return True if the company could be started. False indicates an error.
 */
@Override public boolean startCompany(String playerName,StartCompany action){
  PublicCompanyI company=action.getCertificate().getCompany();
  int price=action.getPrice();
  int shares=action.getNumberBought();
  String errMsg=null;
  StockSpaceI startSpace=null;
  int numberOfCertsToBuy=0;
  PublicCertificateI cert=null;
  String companyName=company.getName();
  PublicCompanyI minor=null;
  StartCompany_18EU startAction=null;
  currentPlayer=GameManager.getCurrentPlayer();
  while (true) {
    if (!(action instanceof StartCompany_18EU)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    startAction=(StartCompany_18EU)action;
    if (companyBoughtThisTurnWrapper.getObject() != null) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    company=companyMgr.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.hasStarted()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    cert=ipo.findCertificate(company,true);
    if (shares < cert.getShares())     shares=cert.getShares();
    numberOfCertsToBuy=shares - (cert.getShares() - 1);
    if (!currentPlayer.mayBuyCertificate(company,numberOfCertsToBuy)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    startSpace=company.getParPrice();
    if (startSpace != null) {
      price=startSpace.getPrice();
    }
 else {
      if ((startSpace=stockMarket.getStartSpace(price)) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",new String[]{Bank.format(price),company.getName()});
        break;
      }
    }
    if (currentPlayer.getCash() < shares * price) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    minor=startAction.getChosenMinor();
    if (currentPlayer.getPortfolio().getCertificatesPerCompany(minor.getName()) == null) {
      errMsg=LocalText.getText(""String_Node_Str"",new String[]{currentPlayer.getName(),minor.getName()});
      break;
    }
    numberOfCertsToBuy++;
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{playerName,companyName,Bank.format(price),errMsg}));
    return false;
  }
  MoveSet.start(true);
  company.setHomeHex(minor.getHomeHex());
  company.start(startSpace);
  int tokensCost=100;
  cert.moveTo(currentPlayer.getPortfolio());
  Bank.transferCash(currentPlayer,company,shares * price);
  Bank.transferCash(company,null,tokensCost);
  PublicCertificateI cert2=ipo.findCertificate(company,false);
  cert2.moveTo(currentPlayer.getPortfolio());
  Util.moveObjects(ipo.getCertificatesPerCompany(company.getName()),company.getPortfolio());
  int minorCash=minor.getCash();
  int minorTrains=minor.getPortfolio().getTrainList().size();
  company.transferAssetsFrom(minor);
  minor.setClosed();
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{playerName,companyName,Bank.format(price),Bank.format(shares * price),String.valueOf(shares),String.valueOf(cert.getShare()),company.getName()}));
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{currentPlayer.getName(),minor.getName(),company.getName(),Bank.format(minorCash),String.valueOf(minorTrains)}));
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{currentPlayer.getName(),String.valueOf(cert2.getShare()),company.getName(),minor.getName()}));
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{String.valueOf(company.getPortfolio().getShare(company)),company.getName()}));
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{company.getName(),Bank.format(100),String.valueOf(company.getNumberOfBaseTokens())}));
  companyBoughtThisTurnWrapper.set(company);
  hasActed.set(true);
  setPriority();
  return true;
}","/** 
 * Start a company by buying one or more shares (more applies to e.g. 1841)
 * @param player The player that wants to start a company.
 * @param company The company to start.
 * @param price The start (par) price (ignored if the price is fixed).
 * @param shares The number of shares to buy (can be more than 1 in e.g. 1841).
 * @return True if the company could be started. False indicates an error.
 */
@Override public boolean startCompany(String playerName,StartCompany action){
  PublicCompanyI company=action.getCertificate().getCompany();
  int price=action.getPrice();
  int shares=action.getNumberBought();
  String errMsg=null;
  StockSpaceI startSpace=null;
  int numberOfCertsToBuy=0;
  PublicCertificateI cert=null;
  String companyName=company.getName();
  PublicCompanyI minor=null;
  StartCompany_18EU startAction=null;
  currentPlayer=GameManager.getCurrentPlayer();
  while (true) {
    if (!(action instanceof StartCompany_18EU)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    startAction=(StartCompany_18EU)action;
    if (companyBoughtThisTurnWrapper.getObject() != null) {
      errMsg=LocalText.getText(""String_Node_Str"",playerName);
      break;
    }
    company=companyMgr.getPublicCompany(companyName);
    if (company == null) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    if (company.hasStarted()) {
      errMsg=LocalText.getText(""String_Node_Str"",companyName);
      break;
    }
    cert=ipo.findCertificate(company,true);
    if (shares < cert.getShares())     shares=cert.getShares();
    numberOfCertsToBuy=shares - (cert.getShares() - 1);
    if (!currentPlayer.mayBuyCertificate(company,numberOfCertsToBuy)) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    startSpace=company.getParPrice();
    if (startSpace != null) {
      price=startSpace.getPrice();
    }
 else {
      if ((startSpace=stockMarket.getStartSpace(price)) == null) {
        errMsg=LocalText.getText(""String_Node_Str"",new String[]{Bank.format(price),company.getName()});
        break;
      }
    }
    if (currentPlayer.getCash() < shares * price) {
      errMsg=LocalText.getText(""String_Node_Str"");
      break;
    }
    minor=startAction.getChosenMinor();
    if (currentPlayer.getPortfolio().getCertificatesPerCompany(minor.getName()) == null) {
      errMsg=LocalText.getText(""String_Node_Str"",new String[]{currentPlayer.getName(),minor.getName()});
      break;
    }
    numberOfCertsToBuy++;
    break;
  }
  if (errMsg != null) {
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{playerName,companyName,Bank.format(price),errMsg}));
    return false;
  }
  MoveSet.start(true);
  company.setHomeHex(minor.getHomeHex());
  company.start(startSpace);
  int tokensCost=100;
  cert.moveTo(currentPlayer.getPortfolio());
  new CashMove(currentPlayer,company,shares * price);
  new CashMove(company,null,tokensCost);
  PublicCertificateI cert2=ipo.findCertificate(company,false);
  cert2.moveTo(currentPlayer.getPortfolio());
  Util.moveObjects(ipo.getCertificatesPerCompany(company.getName()),company.getPortfolio());
  int minorCash=minor.getCash();
  int minorTrains=minor.getPortfolio().getTrainList().size();
  company.transferAssetsFrom(minor);
  minor.setClosed();
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{playerName,companyName,Bank.format(price),Bank.format(shares * price),String.valueOf(shares),String.valueOf(cert.getShare()),company.getName()}));
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{currentPlayer.getName(),minor.getName(),company.getName(),Bank.format(minorCash),String.valueOf(minorTrains)}));
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{currentPlayer.getName(),String.valueOf(cert2.getShare()),company.getName(),minor.getName()}));
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{String.valueOf(company.getPortfolio().getShare(company)),company.getName()}));
  ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{company.getName(),Bank.format(100),String.valueOf(company.getNumberOfBaseTokens())}));
  companyBoughtThisTurnWrapper.set(company);
  hasActed.set(true);
  setPriority();
  return true;
}",0.9950877192982456
173821,"public void setPreferredSize(Dimension preferredSize){
  this.preferredSize=preferredSize;
}","@Override public void setPreferredSize(Dimension preferredSize){
  this.preferredSize=preferredSize;
}",0.9484536082474226
173822,"public void showUpgrades(){
  upgradePanel.removeAll();
  if (tokenMode && possibleTokenLays != null && possibleTokenLays.size() > 0) {
    Color fgColour=null;
    Color bgColour=null;
    String text=null;
    String description=null;
    TokenIcon icon;
    ActionLabel tokenLabel;
    tokenLabels=new ArrayList<ActionLabel>();
    for (    LayToken action : possibleTokenLays) {
      if (action instanceof LayBaseToken) {
        PublicCompanyI comp=((LayBaseToken)action).getCompany();
        fgColour=comp.getFgColour();
        bgColour=comp.getBgColour();
        description=text=comp.getName();
      }
 else       if (action instanceof LayBonusToken) {
        fgColour=Color.BLACK;
        bgColour=Color.WHITE;
        BonusToken token=(BonusToken)action.getSpecialProperty().getToken();
        description=token.getName();
        text=""String_Node_Str"" + token.getValue();
      }
      icon=new TokenIcon(25,fgColour,bgColour,text);
      tokenLabel=new ActionLabel(icon);
      tokenLabel.setName(description);
      tokenLabel.setText(description);
      tokenLabel.setBackground(defaultLabelBgColour);
      tokenLabel.setOpaque(true);
      tokenLabel.setVisible(true);
      tokenLabel.setBorder(border);
      tokenLabel.addMouseListener(this);
      tokenLabel.addPossibleAction(action);
      tokenLabels.add(tokenLabel);
      upgradePanel.add(tokenLabel);
    }
    setSelectedToken();
  }
 else   if (orUIManager.tileUpgrades == null) {
  }
 else   if (orUIManager.tileUpgrades.size() == 0) {
    orUIManager.setMessage(LocalText.getText(""String_Node_Str""));
  }
 else {
    for (    TileI tile : orUIManager.tileUpgrades) {
      BufferedImage hexImage=getHexImage(tile.getId());
      ImageIcon hexIcon=new ImageIcon(hexImage);
      hexIcon.setImage(hexIcon.getImage().getScaledInstance((int)(hexIcon.getIconWidth() * GUIHex.NORMAL_SCALE * 0.8),(int)(hexIcon.getIconHeight() * GUIHex.NORMAL_SCALE * 0.8),Image.SCALE_SMOOTH));
      JLabel hexLabel=new JLabel(hexIcon);
      hexLabel.setName(tile.getName());
      hexLabel.setText(""String_Node_Str"" + tile.getExternalId());
      hexLabel.setOpaque(true);
      hexLabel.setVisible(true);
      hexLabel.setBorder(border);
      hexLabel.addMouseListener(this);
      upgradePanel.add(hexLabel);
    }
  }
  upgradePanel.add(doneButton);
  upgradePanel.add(cancelButton);
  repaint();
}","public void showUpgrades(){
  upgradePanel.removeAll();
  if (tokenMode && possibleTokenLays != null && possibleTokenLays.size() > 0) {
    Color fgColour=null;
    Color bgColour=null;
    String text=null;
    String description=null;
    TokenIcon icon;
    ActionLabel tokenLabel;
    tokenLabels=new ArrayList<ActionLabel>();
    for (    LayToken action : possibleTokenLays) {
      if (action instanceof LayBaseToken) {
        PublicCompanyI comp=((LayBaseToken)action).getCompany();
        fgColour=comp.getFgColour();
        bgColour=comp.getBgColour();
        description=text=comp.getName();
      }
 else       if (action instanceof LayBonusToken) {
        fgColour=Color.BLACK;
        bgColour=Color.WHITE;
        BonusToken token=(BonusToken)action.getSpecialProperty().getToken();
        description=token.getName();
        text=""String_Node_Str"" + token.getValue();
      }
      icon=new TokenIcon(25,fgColour,bgColour,text);
      tokenLabel=new ActionLabel(icon);
      tokenLabel.setName(description);
      tokenLabel.setText(description);
      tokenLabel.setBackground(defaultLabelBgColour);
      tokenLabel.setOpaque(true);
      tokenLabel.setVisible(true);
      tokenLabel.setBorder(border);
      tokenLabel.addMouseListener(this);
      tokenLabel.addPossibleAction(action);
      tokenLabels.add(tokenLabel);
      upgradePanel.add(tokenLabel);
    }
    setSelectedToken();
  }
 else   if (orUIManager.tileUpgrades == null) {
  }
 else   if (orUIManager.tileUpgrades.size() == 0) {
    orUIManager.setMessage(LocalText.getText(""String_Node_Str""));
  }
 else {
    for (    TileI tile : orUIManager.tileUpgrades) {
      BufferedImage hexImage=getHexImage(tile.getId());
      ImageIcon hexIcon=new ImageIcon(hexImage);
      hexIcon.setImage(hexIcon.getImage().getScaledInstance((int)(hexIcon.getIconWidth() * GUIHex.NORMAL_SCALE * 0.8),(int)(hexIcon.getIconHeight() * GUIHex.NORMAL_SCALE * 0.8),Image.SCALE_SMOOTH));
      HexLabel hexLabel=new HexLabel(hexIcon,tile.getId());
      hexLabel.setName(tile.getName());
      hexLabel.setText(""String_Node_Str"" + tile.getExternalId());
      hexLabel.setOpaque(true);
      hexLabel.setVisible(true);
      hexLabel.setBorder(border);
      hexLabel.addMouseListener(this);
      upgradePanel.add(hexLabel);
    }
  }
  upgradePanel.add(doneButton);
  upgradePanel.add(cancelButton);
  repaint();
}",0.9955854530166072
173823,"public Dimension getPreferredSize(){
  return preferredSize;
}","@Override public Dimension getPreferredSize(){
  return preferredSize;
}",0.9253731343283582
173824,"public void mouseClicked(MouseEvent e){
  Object source=e.getSource();
  if (!(source instanceof JLabel))   return;
  if (tokenMode) {
    if (tokenLabels.contains(source)) {
      orUIManager.tokenSelected((LayToken)((ActionLabel)source).getPossibleActions().get(0));
      setDoneEnabled(true);
    }
 else {
      orUIManager.tokenSelected(null);
    }
    setSelectedToken();
  }
 else {
    int id=Integer.parseInt(((JLabel)e.getSource()).getText());
    orUIManager.tileSelected(id);
  }
}","public void mouseClicked(MouseEvent e){
  Object source=e.getSource();
  if (!(source instanceof JLabel))   return;
  if (tokenMode) {
    if (tokenLabels.contains(source)) {
      orUIManager.tokenSelected((LayToken)((ActionLabel)source).getPossibleActions().get(0));
      setDoneEnabled(true);
    }
 else {
      orUIManager.tokenSelected(null);
    }
    setSelectedToken();
  }
 else {
    int id=((HexLabel)e.getSource()).getInternalId();
    orUIManager.tileSelected(id);
  }
}",0.9183673469387756
173825,"/** 
 * Rotate right (clockwise) until a valid orientation is found. TODO: Currently only impassable hex sides are taken into account.
 * @param initial:First rotation to try. Should be 0 for the initial tile drop, and 1 at subsequent rotation attempts.
 * @return <b>false</b> if no valid rotation exists (i.e. the tile cannotbe laid).
 */
public boolean rotate(int initial,GUITile previousGUITile,boolean mustConnect){
  int i, j, tempRot;
  TileI prevTile=previousGUITile.getTile();
  int prevTileRotation=previousGUITile.getRotation();
  MapHex nHex;
  boolean connected=!mustConnect;
  for (i=initial; i < 6; i++) {
    tempRot=(rotation + i) % 6;
    for (j=0; j < 6; j++) {
      if (tile.hasTracks(j - tempRot)) {
        if (!hex.hasNeighbour(j))         break;
        if (mustConnect) {
          nHex=hex.getNeighbor(j);
          if (nHex.getCurrentTile().hasTracks(j + 3 - nHex.getCurrentTileRotation())) {
            connected=true;
          }
        }
      }
 else {
        if (prevTile.hasTracks(j - prevTileRotation))         break;
      }
    }
    if (j == 6 && connected) {
      setRotation(tempRot);
      return true;
    }
  }
  if (i == 6) {
    return false;
  }
 else {
    return true;
  }
}","/** 
 * Rotate right (clockwise) until a valid orientation is found. TODO: Currently only impassable hex sides are taken into account.
 * @param initial:First rotation to try. Should be 0 for the initial tile drop, and 1 at subsequent rotation attempts.
 * @return <b>false</b> if no valid rotation exists (i.e. the tile cannotbe laid).
 */
public boolean rotate(int initial,GUITile previousGUITile,boolean mustConnect){
  int i, j, tempRot;
  TileI prevTile=previousGUITile.getTile();
  int prevTileRotation=previousGUITile.getRotation();
  MapHex nHex;
  boolean connected;
  for (i=initial; i < 6; i++) {
    connected=!mustConnect;
    tempRot=(rotation + i) % 6;
    for (j=0; j < 6; j++) {
      if (tile.hasTracks(j - tempRot)) {
        if (!hex.hasNeighbour(j))         break;
        if (mustConnect) {
          nHex=hex.getNeighbor(j);
          if (nHex.getCurrentTile().hasTracks(j + 3 - nHex.getCurrentTileRotation())) {
            connected=true;
          }
        }
      }
 else {
        if (prevTile.hasTracks(j - prevTileRotation))         break;
      }
    }
    if (j == 6 && connected) {
      setRotation(tempRot);
      return true;
    }
  }
  if (i == 6) {
    return false;
  }
 else {
    return true;
  }
}",0.9679773003648156
173826,"public void actionPerformed(ActionEvent actor){
  JComponent source=(JComponent)actor.getSource();
  if (source instanceof ClickField) {
    gbc=gb.getConstraints(source);
    itemIndex=gbc.gridy - bidPerPlayerYOffset;
    BuyOrBidStartItem currentActiveItem=(BuyOrBidStartItem)((ClickField)source).getPossibleActions().get(0);
    if (currentActiveItem.getStatus() == StartItem.BUYABLE) {
      buyButton.setEnabled(true);
      buyButton.setPossibleAction(currentActiveItem);
      if (includeBidding) {
        bidButton.setEnabled(false);
        bidAmount.setEnabled(false);
      }
    }
 else     if (currentActiveItem.getStatus() == StartItem.BIDDABLE || currentActiveItem.getStatus() == StartItem.AUCTIONED) {
      buyButton.setEnabled(false);
      if (includeBidding) {
        bidButton.setEnabled(true);
        bidButton.setPossibleAction(currentActiveItem);
        bidAmount.setEnabled(true);
        int minBid=items[itemIndex].getMinimumBid();
        spinnerModel.setMinimum(new Integer(minBid));
        spinnerModel.setValue(new Integer(minBid));
      }
    }
  }
 else   if (source instanceof ActionButton) {
    PossibleAction activeItem=((ActionButton)source).getPossibleActions().get(0);
    if (activeItem instanceof BuyOrBidStartItem) {
      BuyOrBidStartItem action=(BuyOrBidStartItem)activeItem;
switch (action.getStatus()) {
case StartItem.BUYABLE:
        process(action);
      break;
case StartItem.BIDDABLE:
case StartItem.AUCTIONED:
    action.setActualBid(((Integer)spinnerModel.getValue()).intValue());
  process(action);
break;
case StartItem.NEEDS_SHARE_PRICE:
if (requestStartPrice(action)) process(action);
break;
}
}
 else if (activeItem instanceof NullAction) {
process(activeItem);
}
}
}","public void actionPerformed(ActionEvent actor){
  JComponent source=(JComponent)actor.getSource();
  if (source instanceof ClickField) {
    gbc=gb.getConstraints(source);
    itemIndex=gbc.gridy - bidPerPlayerYOffset;
    BuyOrBidStartItem currentActiveItem=(BuyOrBidStartItem)((ClickField)source).getPossibleActions().get(0);
    if (currentActiveItem.getStatus() == StartItem.BUYABLE) {
      buyButton.setEnabled(true);
      buyButton.setPossibleAction(currentActiveItem);
      if (includeBidding) {
        bidButton.setEnabled(false);
        bidAmount.setEnabled(false);
      }
    }
 else     if (currentActiveItem.getStatus() == StartItem.BIDDABLE || currentActiveItem.getStatus() == StartItem.AUCTIONED) {
      buyButton.setEnabled(false);
      if (includeBidding) {
        bidButton.setEnabled(true);
        bidButton.setPossibleAction(currentActiveItem);
        bidAmount.setEnabled(true);
        int minBid=items[itemIndex].getMinimumBid();
        spinnerModel.setMinimum(new Integer(minBid));
        spinnerModel.setValue(new Integer(minBid));
      }
    }
  }
 else   if (source instanceof ActionButton) {
    PossibleAction activeItem=((ActionButton)source).getPossibleActions().get(0);
    if (activeItem instanceof BuyOrBidStartItem) {
      BuyOrBidStartItem action=(BuyOrBidStartItem)activeItem;
switch (action.getStatus()) {
case StartItem.BUYABLE:
        if (action.hasSharePriceToSet()) {
          if (requestStartPrice(action))           process(action);
        }
 else {
          process(action);
        }
      break;
case StartItem.BIDDABLE:
case StartItem.AUCTIONED:
    action.setActualBid(((Integer)spinnerModel.getValue()).intValue());
  process(action);
break;
case StartItem.NEEDS_SHARE_PRICE:
if (requestStartPrice(action)) process(action);
break;
}
}
 else if (activeItem instanceof NullAction) {
process(activeItem);
}
}
}",0.9609310058187864
173827,"public void updateStatus(){
  StartItem item;
  int i, j, status;
  for (i=0; i < ni; i++) {
    setItemNameButton(i,false);
    actionableItems[i]=null;
  }
  dummyButton.setSelected(true);
  for (  PossibleAction action : possibleActions.getList()) {
    log.debug(action.getPlayerName() + ""String_Node_Str"" + action);
  }
  List<BuyOrBidStartItem> actions=possibleActions.getType(BuyOrBidStartItem.class);
  if (actions == null || actions.isEmpty()) {
    close();
    return;
  }
  int nextPlayerIndex=((PossibleAction)actions.get(0)).getPlayerIndex();
  setSRPlayerTurn(nextPlayerIndex);
  boolean passAllowed=false;
  boolean buyAllowed=false;
  boolean bidAllowed=false;
  for (  BuyOrBidStartItem action : actions) {
    j=action.getItemIndex();
    i=crossIndex[j];
    actionableItems[i]=action;
    item=action.getStartItem();
    status=action.getStatus();
    if (status == StartItem.BUYABLE) {
      itemNameButton[i].setToolTipText(LocalText.getText(""String_Node_Str""));
      itemNameButton[i].setSelected(false);
      itemNameButton[i].setEnabled(true);
      itemNameButton[i].setPossibleAction(action);
      setItemNameButton(i,true);
      if (includeBidding)       minBid[i].setText(""String_Node_Str"");
      passAllowed=true;
    }
 else     if (status == StartItem.BIDDABLE) {
      itemNameButton[i].setToolTipText(LocalText.getText(""String_Node_Str""));
      itemNameButton[i].setSelected(false);
      itemNameButton[i].setEnabled(true);
      itemNameButton[i].setPossibleAction(action);
      setItemNameButton(i,true);
      minBid[i].setText(Bank.format(item.getMinimumBid()));
      passAllowed=true;
    }
 else     if (status == StartItem.AUCTIONED) {
      itemNameButton[i].setToolTipText(LocalText.getText(""String_Node_Str""));
      minBid[i].setText(Bank.format(item.getMinimumBid()));
      itemIndex=i;
      setItemNameButton(i,true);
      itemNameButton[i].setSelected(true);
      itemNameButton[i].setEnabled(false);
      bidAllowed=true;
      log.debug(""String_Node_Str"" + bidAllowed);
      bidButton.setPossibleAction(action);
      bidAmount.setEnabled(true);
      int minBid=items[itemIndex].getMinimumBid();
      spinnerModel.setMinimum(new Integer(minBid));
      spinnerModel.setValue(new Integer(minBid));
      passAllowed=true;
    }
 else     if (status == StartItem.NEEDS_SHARE_PRICE) {
      PossibleAction lastAction=gameUIManager.getLastAction();
      if (lastAction instanceof GameAction && (((GameAction)lastAction).getMode() == GameAction.UNDO || ((GameAction)lastAction).getMode() == GameAction.FORCED_UNDO)) {
        setItemNameButton(i,true);
        itemNameButton[i].setSelected(true);
        itemNameButton[i].setEnabled(false);
        buyButton.setPossibleAction(action);
        buyAllowed=true;
      }
 else {
        immediateAction=action;
      }
    }
  }
  List inactiveItems=possibleActions.getType(NullAction.class);
  if (inactiveItems != null) {
    NullAction na;
    for (Iterator it=inactiveItems.iterator(); it.hasNext(); ) {
      na=(NullAction)it.next();
switch (na.getMode()) {
case NullAction.PASS:
        passButton.setText(LocalText.getText(""String_Node_Str""));
      passAllowed=true;
    passButton.setPossibleAction(na);
  passButton.setMnemonic(KeyEvent.VK_P);
break;
}
}
}
buyButton.setEnabled(buyAllowed);
if (includeBidding) bidButton.setEnabled(bidAllowed);
passButton.setEnabled(passAllowed);
pack();
requestFocus();
}","public void updateStatus(){
  StartItem item;
  int i, j, status;
  for (i=0; i < ni; i++) {
    setItemNameButton(i,false);
    actionableItems[i]=null;
  }
  dummyButton.setSelected(true);
  for (  PossibleAction action : possibleActions.getList()) {
    log.debug(action.getPlayerName() + ""String_Node_Str"" + action);
  }
  List<BuyOrBidStartItem> actions=possibleActions.getType(BuyOrBidStartItem.class);
  if (actions == null || actions.isEmpty()) {
    close();
    return;
  }
  int nextPlayerIndex=((PossibleAction)actions.get(0)).getPlayerIndex();
  setSRPlayerTurn(nextPlayerIndex);
  boolean passAllowed=false;
  boolean buyAllowed=false;
  boolean bidAllowed=false;
  for (  BuyOrBidStartItem action : actions) {
    j=action.getItemIndex();
    i=crossIndex[j];
    actionableItems[i]=action;
    item=action.getStartItem();
    status=action.getStatus();
    if (status == StartItem.BUYABLE) {
      itemNameButton[i].setToolTipText(LocalText.getText(""String_Node_Str""));
      itemNameButton[i].setSelected(false);
      itemNameButton[i].setEnabled(true);
      itemNameButton[i].setPossibleAction(action);
      setItemNameButton(i,true);
      if (includeBidding)       minBid[i].setText(""String_Node_Str"");
    }
 else     if (status == StartItem.BIDDABLE) {
      itemNameButton[i].setToolTipText(LocalText.getText(""String_Node_Str""));
      itemNameButton[i].setSelected(false);
      itemNameButton[i].setEnabled(true);
      itemNameButton[i].setPossibleAction(action);
      setItemNameButton(i,true);
      minBid[i].setText(Bank.format(item.getMinimumBid()));
    }
 else     if (status == StartItem.AUCTIONED) {
      itemNameButton[i].setToolTipText(LocalText.getText(""String_Node_Str""));
      minBid[i].setText(Bank.format(item.getMinimumBid()));
      itemIndex=i;
      setItemNameButton(i,true);
      itemNameButton[i].setSelected(true);
      itemNameButton[i].setEnabled(false);
      bidAllowed=true;
      bidButton.setPossibleAction(action);
      bidAmount.setEnabled(true);
      int minBid=items[itemIndex].getMinimumBid();
      spinnerModel.setMinimum(new Integer(minBid));
      spinnerModel.setValue(new Integer(minBid));
    }
 else     if (status == StartItem.NEEDS_SHARE_PRICE) {
      PossibleAction lastAction=gameUIManager.getLastAction();
      if (lastAction instanceof GameAction && (((GameAction)lastAction).getMode() == GameAction.UNDO || ((GameAction)lastAction).getMode() == GameAction.FORCED_UNDO)) {
        setItemNameButton(i,true);
        itemNameButton[i].setSelected(true);
        itemNameButton[i].setEnabled(false);
        buyButton.setPossibleAction(action);
        buyAllowed=true;
      }
 else {
        immediateAction=action;
      }
    }
  }
  passAllowed=false;
  List inactiveItems=possibleActions.getType(NullAction.class);
  if (inactiveItems != null) {
    NullAction na;
    for (Iterator it=inactiveItems.iterator(); it.hasNext(); ) {
      na=(NullAction)it.next();
switch (na.getMode()) {
case NullAction.PASS:
        passButton.setText(LocalText.getText(""String_Node_Str""));
      passAllowed=true;
    passButton.setPossibleAction(na);
  passButton.setMnemonic(KeyEvent.VK_P);
break;
}
}
}
buyButton.setEnabled(buyAllowed);
if (includeBidding) bidButton.setEnabled(bidAllowed);
passButton.setEnabled(passAllowed);
pack();
requestFocus();
}",0.979000295770482
173828,"public static boolean load(GameAction loadAction){
  String filepath=loadAction.getFilepath();
  boolean result=false;
  try {
    ObjectInputStream ois=new ObjectInputStream(new FileInputStream(new File(filepath)));
    name=(String)ois.readObject();
    variant=(String)ois.readObject();
    numberOfPlayers=(Integer)ois.readObject();
    List<String> playerNames=new ArrayList<String>();
    for (int i=0; i < numberOfPlayers; i++) {
      playerNames.add((String)ois.readObject());
    }
    Game.getPlayerManager(playerNames);
    Game.initialise(name);
    if (Util.hasValue(variant))     setVariant(variant);
    Player.initPlayers(Game.getPlayerManager().getPlayersArray());
    List<PossibleAction> executedActions=(List<PossibleAction>)ois.readObject();
    ois.close();
    instance.startGame();
    for (    PossibleAction action : executedActions) {
      instance.processOnReload(action);
    }
    result=true;
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"",e);
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",e.getMessage()));
  }
catch (  ClassNotFoundException e) {
    log.error(""String_Node_Str"",e);
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",e.getMessage()));
  }
  return result;
}","public static boolean load(GameAction loadAction){
  String filepath=loadAction.getFilepath();
  boolean result=false;
  try {
    ObjectInputStream ois=new ObjectInputStream(new FileInputStream(new File(filepath)));
    name=(String)ois.readObject();
    variant=(String)ois.readObject();
    numberOfPlayers=(Integer)ois.readObject();
    List<String> playerNames=new ArrayList<String>();
    for (int i=0; i < numberOfPlayers; i++) {
      playerNames.add((String)ois.readObject());
    }
    Game.getPlayerManager(playerNames);
    Game.initialise(name);
    if (Util.hasValue(variant))     setVariant(variant);
    Player.initPlayers(Game.getPlayerManager().getPlayersArray());
    List<PossibleAction> executedActions=(List<PossibleAction>)ois.readObject();
    ois.close();
    instance.startGame();
    for (    PossibleAction action : executedActions) {
      log.debug(""String_Node_Str"" + action);
      instance.processOnReload(action);
    }
    result=true;
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"",e);
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",e.getMessage()));
  }
catch (  ClassNotFoundException e) {
    log.error(""String_Node_Str"",e);
    DisplayBuffer.add(LocalText.getText(""String_Node_Str"",e.getMessage()));
  }
  return result;
}",0.9822345045400712
173829,"public void skip(){
  log.debug(""String_Node_Str"" + stepObject.intValue());
  MoveSet.start(true);
  nextStep();
  MoveSet.finish();
}","public void skip(){
  log.debug(""String_Node_Str"" + stepObject.intValue());
  MoveSet.start(true);
  nextStep();
}",0.9193548387096774
173830,"/** 
 * Bypass normal order of operations and explicitly set round step. This should only be done for specific rails.game exceptions, such as forced train purchases.
 * @param step
 */
protected void setStep(int step){
  if (step == STEP_INITIAL)   initTurn();
  if (stepObject == null) {
    stepObject=new IntegerState(""String_Node_Str"");
    stepObject.addObserver(this);
  }
  stepObject.set(step);
  prepareStep();
}","/** 
 * Bypass normal order of operations and explicitly set round step. This should only be done for specific rails.game exceptions, such as forced train purchases.
 * @param step
 */
protected void setStep(int step){
  log.debug(""String_Node_Str"" + step);
  if (step == STEP_INITIAL)   initTurn();
  if (stepObject == null) {
    stepObject=new IntegerState(""String_Node_Str"",-1);
    stepObject.addObserver(this);
  }
  stepObject.set(step);
}",0.9319492502883506
173831,"public boolean process(PossibleAction action){
  boolean result=false;
  String playerName=action.getPlayerName();
  Player currentPlayer=getCurrentPlayer();
  if (action instanceof PossibleORAction) {
    PublicCompanyI company=((PossibleORAction)action).getCompany();
    if (company != operatingCompany) {
      DisplayBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{company.getName(),operatingCompany.getName()}));
      return false;
    }
  }
  selectedAction=action;
  if (selectedAction instanceof LayTile) {
    result=layTile((LayTile)selectedAction);
  }
 else   if (selectedAction instanceof LayToken) {
    result=layBaseToken((LayToken)selectedAction);
  }
 else   if (selectedAction instanceof SetDividend) {
    result=setRevenueAndDividend((SetDividend)selectedAction);
  }
 else   if (selectedAction instanceof BuyTrain) {
    result=buyTrain((BuyTrain)selectedAction);
  }
 else   if (selectedAction instanceof DiscardTrain) {
    result=discardTrain((DiscardTrain)selectedAction);
  }
 else   if (selectedAction instanceof BuyPrivate) {
    result=buyPrivate((BuyPrivate)selectedAction);
  }
 else   if (selectedAction instanceof NullAction) {
    NullAction nullAction=(NullAction)action;
switch (nullAction.getMode()) {
case NullAction.PASS:
case NullAction.DONE:
      result=done();
    break;
case NullAction.SKIP:
  skip();
result=true;
break;
}
}
 else {
DisplayBuffer.add(LocalText.getText(""String_Node_Str"",selectedAction.toString()));
return false;
}
return result;
}","public boolean process(PossibleAction action){
  boolean result=false;
  if (action instanceof PossibleORAction) {
    PublicCompanyI company=((PossibleORAction)action).getCompany();
    if (company != operatingCompany) {
      DisplayBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{company.getName(),operatingCompany.getName()}));
      return false;
    }
  }
  selectedAction=action;
  if (selectedAction instanceof LayTile) {
    result=layTile((LayTile)selectedAction);
  }
 else   if (selectedAction instanceof LayToken) {
    result=layBaseToken((LayToken)selectedAction);
  }
 else   if (selectedAction instanceof SetDividend) {
    result=setRevenueAndDividend((SetDividend)selectedAction);
  }
 else   if (selectedAction instanceof BuyTrain) {
    result=buyTrain((BuyTrain)selectedAction);
  }
 else   if (selectedAction instanceof DiscardTrain) {
    result=discardTrain((DiscardTrain)selectedAction);
  }
 else   if (selectedAction instanceof BuyPrivate) {
    result=buyPrivate((BuyPrivate)selectedAction);
  }
 else   if (selectedAction instanceof NullAction) {
    NullAction nullAction=(NullAction)action;
switch (nullAction.getMode()) {
case NullAction.PASS:
case NullAction.DONE:
      result=done();
    break;
case NullAction.SKIP:
  skip();
result=true;
break;
}
}
 else {
DisplayBuffer.add(LocalText.getText(""String_Node_Str"",selectedAction.toString()));
return false;
}
return result;
}",0.970317297850563
173832,"/** 
 * Take the next step after a given one (see nextStep()) 
 */
protected void nextStep(int step){
  int stepIndex;
  for (stepIndex=0; stepIndex < steps.length; stepIndex++) {
    if (steps[stepIndex] == step)     break;
  }
  while (++stepIndex < steps.length) {
    step=steps[stepIndex];
    if (step == STEP_LAY_TOKEN && operatingCompany.getNumberOfFreeBaseTokens() == 0) {
      continue;
    }
    if (step == STEP_CALC_REVENUE) {
      if (operatingCompany.getPortfolio().getNumberOfTrains() == 0) {
        operatingCompany.setLastRevenue(0);
        operatingCompany.setLastRevenueAllocation(SetDividend.UNKNOWN);
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{operatingCompany.getName(),Bank.format(0)}));
        continue;
      }
    }
    if (step == STEP_PAYOUT) {
      int amount=operatingCompany.getLastRevenue();
      if (amount == 0) {
        operatingCompany.withhold(0);
        DisplayBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{operatingCompany.getName(),Bank.format(0)}));
        continue;
      }
 else       if (operatingCompany.isSplitAlways()) {
        operatingCompany.splitRevenue(amount);
        continue;
      }
    }
    break;
  }
  if (step >= steps.length) {
    done();
  }
 else {
    setStep(step);
  }
}","/** 
 * Take the next step after a given one (see nextStep()) 
 */
protected void nextStep(int step){
  log.debug(""String_Node_Str"" + step);
  int stepIndex;
  for (stepIndex=0; stepIndex < steps.length; stepIndex++) {
    if (steps[stepIndex] == step)     break;
  }
  while (++stepIndex < steps.length) {
    step=steps[stepIndex];
    if (step == STEP_LAY_TOKEN && operatingCompany.getNumberOfFreeBaseTokens() == 0) {
      continue;
    }
    if (step == STEP_CALC_REVENUE) {
      if (operatingCompany.getPortfolio().getNumberOfTrains() == 0) {
        operatingCompany.setLastRevenue(0);
        operatingCompany.setLastRevenueAllocation(SetDividend.UNKNOWN);
        ReportBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{operatingCompany.getName(),Bank.format(0)}));
        continue;
      }
    }
    if (step == STEP_PAYOUT) {
      int amount=operatingCompany.getLastRevenue();
      if (amount == 0) {
        operatingCompany.withhold(0);
        DisplayBuffer.add(LocalText.getText(""String_Node_Str"",new String[]{operatingCompany.getName(),Bank.format(0)}));
        continue;
      }
 else       if (operatingCompany.isSplitAlways()) {
        operatingCompany.splitRevenue(amount);
        continue;
      }
    }
    break;
  }
  if (step >= steps.length) {
    done();
  }
 else {
    setStep(step);
  }
}",0.9851767388825542
173833,"/** 
 * Deserialize 
 */
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  in.defaultReadObject();
  train=Train.getByUniqueId(trainUniqueId);
  log.debug(""String_Node_Str"" + trainUniqueId + ""String_Node_Str""+ train);
  from=Portfolio.getByName(fromName);
  if (trainsForExchangeUniqueIds != null && trainsForExchangeUniqueIds.length > 0) {
    trainsForExchange=new ArrayList<TrainI>();
    for (int i=0; i < trainsForExchangeUniqueIds.length; i++) {
      trainsForExchange.add(Train.getByUniqueId(trainsForExchangeUniqueIds[i]));
    }
  }
  if (Util.hasValue(exchangedTrainUniqueId)) {
    exchangedTrain=Train.getByUniqueId(exchangedTrainUniqueId);
  }
}","/** 
 * Deserialize 
 */
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  in.defaultReadObject();
  train=Train.getByUniqueId(trainUniqueId);
  from=Portfolio.getByName(fromName);
  if (trainsForExchangeUniqueIds != null && trainsForExchangeUniqueIds.length > 0) {
    trainsForExchange=new ArrayList<TrainI>();
    for (int i=0; i < trainsForExchangeUniqueIds.length; i++) {
      trainsForExchange.add(Train.getByUniqueId(trainsForExchangeUniqueIds[i]));
    }
  }
  if (Util.hasValue(exchangedTrainUniqueId)) {
    exchangedTrain=Train.getByUniqueId(exchangedTrainUniqueId);
  }
}",0.9435665914221218
173834,"public void loadGame(){
  JFileChooser jfc=new JFileChooser();
  if (providedName != null) {
    jfc.setSelectedFile(new File(providedName));
  }
 else {
    jfc.setCurrentDirectory(new File(saveDirectory));
  }
  if (jfc.showOpenDialog(options.getContentPane()) == JFileChooser.APPROVE_OPTION) {
    File selectedFile=jfc.getSelectedFile();
    String filepath=selectedFile.getPath();
    saveDirectory=selectedFile.getParent();
    GameAction loadAction=new GameAction(GameAction.LOAD);
    loadAction.setFilepath(filepath);
    GameManager.load(loadAction);
    gameUIInit();
    processOnServer(null);
    DisplayBuffer.clear();
    updateUI();
    statusWindow.setGameActions();
  }
}","public void loadGame(){
  JFileChooser jfc=new JFileChooser();
  if (providedName != null) {
    jfc.setSelectedFile(new File(providedName));
  }
 else {
    jfc.setCurrentDirectory(new File(saveDirectory));
  }
  if (jfc.showOpenDialog(options.getContentPane()) == JFileChooser.APPROVE_OPTION) {
    File selectedFile=jfc.getSelectedFile();
    String filepath=selectedFile.getPath();
    saveDirectory=selectedFile.getParent();
    GameAction loadAction=new GameAction(GameAction.LOAD);
    loadAction.setFilepath(filepath);
    GameManager.load(loadAction);
    DisplayBuffer.clear();
    gameUIInit();
    processOnServer(null);
    updateUI();
    statusWindow.setGameActions();
  }
}",0.9608127721335268
173835,"public boolean processOnServer(PossibleAction action){
  lastAction=action;
  log.debug(""String_Node_Str"" + action);
  Player player=GameManager.getCurrentPlayer();
  if (action != null && player != null) {
    action.setPlayerName(player.getName());
  }
  boolean result=gameManager.process(action);
  log.debug(""String_Node_Str"" + result);
  ReportWindow.addLog();
  if (GameManager.isGameOver()) {
    statusWindow.reportGameOver();
    return true;
  }
 else   if (Bank.isJustBroken()) {
    statusWindow.reportBankBroken();
  }
  updateUI();
  statusWindow.setGameActions();
  if (result) {
    return activeWindow.processImmediateAction();
  }
 else {
    return false;
  }
}","public boolean processOnServer(PossibleAction action){
  lastAction=action;
  log.debug(""String_Node_Str"" + action);
  Player player=GameManager.getCurrentPlayer();
  if (action != null && player != null) {
    action.setPlayerName(player.getName());
  }
  boolean result=gameManager.process(action);
  log.debug(""String_Node_Str"" + result);
  activeWindow.displayMessage();
  ReportWindow.addLog();
  if (GameManager.isGameOver()) {
    statusWindow.reportGameOver();
    return true;
  }
 else   if (Bank.isJustBroken()) {
    statusWindow.reportBankBroken();
  }
  updateUI();
  statusWindow.setGameActions();
  if (result) {
    return activeWindow.processImmediateAction();
  }
 else {
    return false;
  }
}",0.9763440860215054
173836,"public void activate(){
  repaintUpgradePanel();
  orPanel.recreate();
  orPanel.updateStatus();
  setVisible(true);
  requestFocus();
}","public void activate(){
  repaintUpgradePanel();
  orPanel.recreate();
  setVisible(true);
  requestFocus();
}",0.8943089430894309
173837,"public void actionPerformed(ActionEvent actor){
  JComponent source=(JComponent)actor.getSource();
  if (source instanceof ClickField) {
    gbc=gb.getConstraints(source);
    itemIndex=gbc.gridy - bidPerPlayerYOffset;
    BuyOrBidStartItem currentActiveItem=(BuyOrBidStartItem)((ClickField)source).getPossibleActions().get(0);
    if (currentActiveItem.getStatus() == StartItem.BUYABLE) {
      buyButton.setEnabled(true);
      buyButton.setPossibleAction(currentActiveItem);
      if (includeBidding) {
        bidButton.setEnabled(false);
        bidAmount.setEnabled(false);
      }
    }
 else     if (currentActiveItem.getStatus() == StartItem.BIDDABLE || currentActiveItem.getStatus() == StartItem.AUCTIONED) {
      buyButton.setEnabled(false);
      if (includeBidding) {
        bidButton.setEnabled(true);
        bidButton.setPossibleAction(currentActiveItem);
        bidAmount.setEnabled(true);
        int minBid=items[itemIndex].getMinimumBid();
        spinnerModel.setMinimum(new Integer(minBid));
        spinnerModel.setValue(new Integer(minBid));
      }
    }
  }
 else   if (source instanceof ActionButton) {
    PossibleAction activeItem=((ActionButton)source).getPossibleActions().get(0);
    if (activeItem instanceof BuyOrBidStartItem) {
      BuyOrBidStartItem action=(BuyOrBidStartItem)activeItem;
switch (action.getStatus()) {
case StartItem.BUYABLE:
        process(action);
      break;
case StartItem.BIDDABLE:
case StartItem.AUCTIONED:
    action.setActualBid(((Integer)spinnerModel.getValue()).intValue());
  process(action);
break;
case StartItem.NEEDS_SHARE_PRICE:
if (requestStartPrice(action)) process(action);
break;
}
}
 else if (activeItem instanceof NullAction) {
process(activeItem);
}
}
displayError();
}","public void actionPerformed(ActionEvent actor){
  JComponent source=(JComponent)actor.getSource();
  if (source instanceof ClickField) {
    gbc=gb.getConstraints(source);
    itemIndex=gbc.gridy - bidPerPlayerYOffset;
    BuyOrBidStartItem currentActiveItem=(BuyOrBidStartItem)((ClickField)source).getPossibleActions().get(0);
    if (currentActiveItem.getStatus() == StartItem.BUYABLE) {
      buyButton.setEnabled(true);
      buyButton.setPossibleAction(currentActiveItem);
      if (includeBidding) {
        bidButton.setEnabled(false);
        bidAmount.setEnabled(false);
      }
    }
 else     if (currentActiveItem.getStatus() == StartItem.BIDDABLE || currentActiveItem.getStatus() == StartItem.AUCTIONED) {
      buyButton.setEnabled(false);
      if (includeBidding) {
        bidButton.setEnabled(true);
        bidButton.setPossibleAction(currentActiveItem);
        bidAmount.setEnabled(true);
        int minBid=items[itemIndex].getMinimumBid();
        spinnerModel.setMinimum(new Integer(minBid));
        spinnerModel.setValue(new Integer(minBid));
      }
    }
  }
 else   if (source instanceof ActionButton) {
    PossibleAction activeItem=((ActionButton)source).getPossibleActions().get(0);
    if (activeItem instanceof BuyOrBidStartItem) {
      BuyOrBidStartItem action=(BuyOrBidStartItem)activeItem;
switch (action.getStatus()) {
case StartItem.BUYABLE:
        process(action);
      break;
case StartItem.BIDDABLE:
case StartItem.AUCTIONED:
    action.setActualBid(((Integer)spinnerModel.getValue()).intValue());
  process(action);
break;
case StartItem.NEEDS_SHARE_PRICE:
if (requestStartPrice(action)) process(action);
break;
}
}
 else if (activeItem instanceof NullAction) {
process(activeItem);
}
}
}",0.9954075774971296
173838,"public boolean process(PossibleAction executedAction){
  Game.getLogger().debug(""String_Node_Str"" + executedAction.toString());
  if (executedAction == null) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"");
    return false;
  }
  gameUIManager.processOnServer(executedAction);
  displayError();
  return true;
}","public boolean process(PossibleAction executedAction){
  Game.getLogger().debug(""String_Node_Str"" + executedAction.toString());
  if (executedAction == null) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"");
    return false;
  }
  gameUIManager.processOnServer(executedAction);
  return true;
}",0.9714285714285714
173839,"private void toggleOptions(){
  if (optionsPane.isVisible()) {
    optionsPane.setVisible(false);
    optionsPane.removeAll();
    optionComponents.clear();
  }
 else {
    availableOptions=GamesInfo.getOptions(gameName);
    if (availableOptions != null && !availableOptions.isEmpty()) {
      for (      GameOption option : availableOptions) {
        if (option.isBoolean()) {
          JCheckBox checkbox=new JCheckBox(LocalText.getText(option.getName()));
          if (option.getDefaultValue().equalsIgnoreCase(""String_Node_Str"")) {
            checkbox.setSelected(true);
          }
          optionsPane.add(checkbox);
          optionComponents.add(checkbox);
        }
 else {
          optionsPane.add(new JLabel(LocalText.getText(""String_Node_Str"",LocalText.getText(option.getName()))));
          JComboBox dropdown=new JComboBox();
          for (          String value : option.getAllowedValues()) {
            dropdown.addItem(value);
          }
          optionsPane.add(dropdown);
          optionComponents.add(dropdown);
        }
      }
    }
 else {
      JLabel label=new JLabel(LocalText.getText(""String_Node_Str""));
      optionsPane.add(label);
    }
    optionsPane.setVisible(true);
  }
}","private void toggleOptions(){
  if (optionsPane.isVisible()) {
    optionsPane.setVisible(false);
    optionsPane.removeAll();
    optionComponents.clear();
  }
 else {
    availableOptions=GamesInfo.getOptions(gameName);
    if (availableOptions != null && !availableOptions.isEmpty()) {
      optionsPane.setLayout(new GridLayout((availableOptions.size()),1));
      for (      GameOption option : availableOptions) {
        if (option.isBoolean()) {
          JCheckBox checkbox=new JCheckBox(LocalText.getText(option.getName()));
          if (option.getDefaultValue().equalsIgnoreCase(""String_Node_Str"")) {
            checkbox.setSelected(true);
          }
          optionsPane.add(checkbox);
          optionComponents.add(checkbox);
        }
 else {
          optionsPane.setLayout(new GridLayout((availableOptions.size() + 1),1));
          optionsPane.add(new JLabel(LocalText.getText(""String_Node_Str"",LocalText.getText(option.getName()))));
          JComboBox dropdown=new JComboBox();
          for (          String value : option.getAllowedValues()) {
            dropdown.addItem(value);
          }
          optionsPane.add(dropdown);
          optionComponents.add(dropdown);
        }
      }
    }
 else {
      JLabel label=new JLabel(LocalText.getText(""String_Node_Str""));
      optionsPane.add(label);
    }
    optionsPane.setVisible(true);
  }
}",0.9399075500770416
173840,"public void actionPerformed(ActionEvent arg0){
  if (arg0.getSource().equals(newButton)) {
    startNewGame();
  }
 else   if (arg0.getSource().equals(optionButton)) {
    toggleOptions();
  }
 else   if (arg0.getSource().equals(loadButton) && gameUIManager.loadGame()) {
    setVisible(false);
  }
 else   if (arg0.getSource().equals(quitButton)) {
    System.exit(0);
  }
 else   if (arg0.getSource().equals(gameNameBox)) {
    gameName=gameNameBox.getSelectedItem().toString().split(""String_Node_Str"")[0];
    fillPlayersPane();
    if (optionsPane.isVisible()) {
      toggleOptions();
      toggleOptions();
    }
  }
}","public void actionPerformed(ActionEvent arg0){
  if (arg0.getSource().equals(newButton)) {
    startNewGame();
  }
 else   if (arg0.getSource().equals(optionButton)) {
    toggleOptions();
    this.pack();
  }
 else   if (arg0.getSource().equals(loadButton) && gameUIManager.loadGame()) {
    setVisible(false);
  }
 else   if (arg0.getSource().equals(quitButton)) {
    System.exit(0);
  }
 else   if (arg0.getSource().equals(gameNameBox)) {
    gameName=gameNameBox.getSelectedItem().toString().split(""String_Node_Str"")[0];
    fillPlayersPane();
    if (optionsPane.isVisible()) {
      toggleOptions();
      toggleOptions();
    }
    this.pack();
  }
}",0.9734789391575664
173841,"private void fillPlayersPane(){
  playersPane.setVisible(false);
  int maxPlayers=GamesInfo.getMaxPlayers(gameName);
  String[] playerList=new String[maxPlayers];
  String[] testPlayers=Config.get(""String_Node_Str"").split(""String_Node_Str"");
  for (int i=0; i < playerNameFields.length; i++) {
    if (playerNameFields[i] != null && playerNameFields[i].getText().length() > 0) {
      playerList[i]=playerNameFields[i].getText();
    }
 else     if (i < testPlayers.length && testPlayers[i].length() > 0) {
      playerList[i]=testPlayers[i];
    }
  }
  playersPane.removeAll();
  playersPane.setLayout(new GridLayout(Player.MAX_PLAYERS + 1,0));
  playersPane.setBorder(BorderFactory.createLoweredBevelBorder());
  playersPane.add(new JLabel(""String_Node_Str""));
  playersPane.add(new JLabel(""String_Node_Str""));
  for (int i=0; i < GamesInfo.getMaxPlayers(gameName); i++) {
    playerBoxes[i]=new JComboBox();
    playerBoxes[i].addItem(""String_Node_Str"");
    playerBoxes[i].addItem(""String_Node_Str"");
    if (testPlayers.length > 0 && i < playerList.length) {
      playerNameFields[i]=new JTextField(playerList[i]);
    }
 else {
      playerNameFields[i]=new JTextField();
    }
    if (playerNameFields[i].getText().length() > 0) {
      playerBoxes[i].setSelectedIndex(1);
    }
 else {
      playerBoxes[i].setSelectedIndex(0);
    }
    playersPane.add(playerBoxes[i]);
    playersPane.add(playerNameFields[i]);
  }
  playersPane.setVisible(true);
}","private void fillPlayersPane(){
  playersPane.setVisible(false);
  int maxPlayers=GamesInfo.getMaxPlayers(gameName);
  String[] playerList=new String[maxPlayers];
  String[] testPlayers=Config.get(""String_Node_Str"").split(""String_Node_Str"");
  for (int i=0; i < playerNameFields.length; i++) {
    if (playerNameFields[i] != null && playerNameFields[i].getText().length() > 0) {
      playerList[i]=playerNameFields[i].getText();
    }
 else     if (i < testPlayers.length && testPlayers[i].length() > 0) {
      playerList[i]=testPlayers[i];
    }
  }
  playersPane.removeAll();
  playersPane.setLayout(new GridLayout(maxPlayers + 1,0));
  playersPane.setBorder(BorderFactory.createLoweredBevelBorder());
  playersPane.add(new JLabel(""String_Node_Str""));
  playersPane.add(new JLabel(""String_Node_Str""));
  for (int i=0; i < GamesInfo.getMaxPlayers(gameName); i++) {
    playerBoxes[i]=new JComboBox();
    playerBoxes[i].addItem(""String_Node_Str"");
    playerBoxes[i].addItem(""String_Node_Str"");
    if (testPlayers.length > 0 && i < playerList.length) {
      playerNameFields[i]=new JTextField(playerList[i]);
    }
 else {
      playerNameFields[i]=new JTextField();
    }
    if (playerNameFields[i].getText().length() > 0) {
      playerBoxes[i].setSelectedIndex(1);
    }
 else {
      playerBoxes[i].setSelectedIndex(0);
    }
    playersPane.add(playerBoxes[i]);
    playersPane.add(playerNameFields[i]);
  }
  playersPane.setVisible(true);
}",0.9903846153846154
173842,"private void populateGridBag(){
  gc.gridx=0;
  gc.gridy=0;
  gc.weightx=1.0;
  gc.weighty=1.0;
  gc.gridwidth=1;
  gc.fill=GridBagConstraints.BOTH;
  this.getContentPane().add(playersPane,gc);
  gc.gridx=0;
  gc.gridy=1;
  gc.fill=1;
  gc.weightx=0.5;
  gc.weighty=0.5;
  gc.gridwidth=1;
  gc.ipady=50;
  this.getContentPane().add(gameListPane,gc);
  gc.gridx=0;
  gc.gridy=2;
  gc.weightx=0.0;
  gc.weighty=0.0;
  gc.gridwidth=1;
  gc.ipady=0;
  gc.fill=GridBagConstraints.HORIZONTAL;
  this.getContentPane().add(optionsPane,gc);
  gc.gridx=0;
  gc.gridy=3;
  gc.weightx=0.0;
  gc.weighty=0.0;
  gc.gridwidth=1;
  gc.ipady=0;
  gc.fill=GridBagConstraints.HORIZONTAL;
  this.getContentPane().add(buttonPane,gc);
}","private void populateGridBag(){
  gc=new GridBagConstraints();
  gc.gridx=0;
  gc.gridy=0;
  gc.weightx=0;
  gc.weighty=0;
  gc.gridwidth=1;
  gc.gridheight=1;
  gc.ipadx=0;
  gc.ipady=0;
  gc.anchor=GridBagConstraints.CENTER;
  gc.fill=GridBagConstraints.HORIZONTAL;
  gc.insets=new Insets(0,0,0,0);
  this.getContentPane().add(playersPane,gc);
  gc=new GridBagConstraints();
  gc.gridx=0;
  gc.gridy=1;
  gc.weightx=0;
  gc.weighty=0;
  gc.gridwidth=1;
  gc.gridheight=1;
  gc.ipadx=0;
  gc.ipady=0;
  gc.anchor=GridBagConstraints.CENTER;
  gc.fill=GridBagConstraints.BOTH;
  gc.insets=new Insets(0,0,0,0);
  this.getContentPane().add(gameListPane,gc);
  gc=new GridBagConstraints();
  gc.gridx=0;
  gc.gridy=2;
  gc.weightx=0;
  gc.weighty=0;
  gc.gridwidth=1;
  gc.gridheight=1;
  gc.ipadx=0;
  gc.ipady=0;
  gc.anchor=GridBagConstraints.CENTER;
  gc.fill=GridBagConstraints.BOTH;
  gc.insets=new Insets(0,0,0,0);
  this.getContentPane().add(optionsPane,gc);
  gc=new GridBagConstraints();
  gc.gridx=0;
  gc.gridy=3;
  gc.weightx=0;
  gc.weighty=0;
  gc.gridwidth=1;
  gc.gridheight=1;
  gc.ipadx=0;
  gc.ipady=0;
  gc.anchor=GridBagConstraints.CENTER;
  gc.fill=GridBagConstraints.HORIZONTAL;
  gc.insets=new Insets(0,0,0,0);
  this.getContentPane().add(buttonPane,gc);
}",0.3596182822702159
173843,"private void initialize(){
  gc=new GridBagConstraints();
  gameListPane=new JPanel();
  playersPane=new JPanel();
  buttonPane=new JPanel();
  optionsPane=new JPanel();
  newButton=new JButton(LocalText.getText(""String_Node_Str""));
  loadButton=new JButton(LocalText.getText(""String_Node_Str""));
  quitButton=new JButton(LocalText.getText(""String_Node_Str""));
  optionButton=new JButton(LocalText.getText(""String_Node_Str""));
  newButton.setMnemonic(KeyEvent.VK_N);
  loadButton.setMnemonic(KeyEvent.VK_L);
  quitButton.setMnemonic(KeyEvent.VK_Q);
  optionButton.setMnemonic(KeyEvent.VK_O);
  this.getContentPane().setLayout(new GridBagLayout());
  this.setTitle(""String_Node_Str"");
  this.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  populateGameList(GamesInfo.getGameNames(),gameNameBox);
  gameListPane.add(new JLabel(""String_Node_Str""));
  gameListPane.add(gameNameBox);
  gameListPane.setLayout(new GridLayout(2,2));
  gameListPane.setBorder(BorderFactory.createLoweredBevelBorder());
  gameListPane.setPreferredSize(new Dimension(1,1));
  newButton.addActionListener(this);
  loadButton.addActionListener(this);
  quitButton.addActionListener(this);
  optionButton.addActionListener(this);
  gameNameBox.addActionListener(this);
  buttonPane.add(newButton);
  buttonPane.add(loadButton);
  buttonPane.add(optionButton);
  buttonPane.add(quitButton);
  buttonPane.setBorder(BorderFactory.createLoweredBevelBorder());
  optionsPane.setLayout(new FlowLayout());
  optionsPane.setVisible(false);
  gameName=gameNameBox.getSelectedItem().toString().split(""String_Node_Str"")[0];
  availableOptions=GamesInfo.getOptions(gameName);
  fillPlayersPane();
}","private void initialize(){
  gameListPane=new JPanel();
  playersPane=new JPanel();
  buttonPane=new JPanel();
  optionsPane=new JPanel();
  newButton=new JButton(LocalText.getText(""String_Node_Str""));
  loadButton=new JButton(LocalText.getText(""String_Node_Str""));
  quitButton=new JButton(LocalText.getText(""String_Node_Str""));
  optionButton=new JButton(LocalText.getText(""String_Node_Str""));
  newButton.setMnemonic(KeyEvent.VK_N);
  loadButton.setMnemonic(KeyEvent.VK_L);
  quitButton.setMnemonic(KeyEvent.VK_Q);
  optionButton.setMnemonic(KeyEvent.VK_O);
  this.getContentPane().setLayout(new GridBagLayout());
  this.setTitle(""String_Node_Str"");
  this.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  populateGameList(GamesInfo.getGameNames(),gameNameBox);
  gameListPane.add(new JLabel(""String_Node_Str""));
  gameListPane.add(gameNameBox);
  gameListPane.setLayout(new GridLayout(2,2));
  gameListPane.setBorder(BorderFactory.createLoweredBevelBorder());
  newButton.addActionListener(this);
  loadButton.addActionListener(this);
  quitButton.addActionListener(this);
  optionButton.addActionListener(this);
  gameNameBox.addActionListener(this);
  buttonPane.add(newButton);
  buttonPane.add(loadButton);
  buttonPane.add(optionButton);
  buttonPane.add(quitButton);
  buttonPane.setBorder(BorderFactory.createLoweredBevelBorder());
  optionsPane.setLayout(new FlowLayout());
  optionsPane.setVisible(false);
  gameName=gameNameBox.getSelectedItem().toString().split(""String_Node_Str"")[0];
  availableOptions=GamesInfo.getOptions(gameName);
  fillPlayersPane();
}",0.974058060531192
173844,"public void setNeighbor(int orientation,MapHex neighbour){
  orientation%=6;
  neighbours[orientation]=neighbour;
}","/** 
 * @return Returns the preprintedTileOrientation.
 */
public void setNeighbor(int orientation,MapHex neighbour){
  orientation%=6;
  neighbours[orientation]=neighbour;
}",0.7958477508650519
173845,"/** 
 * @see rails.game.ConfigurableComponentI#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Element el) throws ConfigurationException {
  NamedNodeMap nnp=el.getAttributes();
  Pattern namePattern=Pattern.compile(""String_Node_Str"");
  name=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  Matcher m=namePattern.matcher(name);
  if (!m.matches()) {
    throw new ConfigurationException(""String_Node_Str"" + name);
  }
  letter=m.group(1).charAt(0);
  try {
    number=Integer.parseInt(m.group(2));
  }
 catch (  NumberFormatException e) {
  }
  if (lettersGoHorizontal) {
    row=number;
    column=letter - '@';
    if (tileOrientation == MapHex.EW) {
      x=column;
      y=row / 2;
    }
 else {
      x=column;
      y=(row + 1) / 2;
    }
  }
 else {
    row=letter - '@';
    column=number;
    if (tileOrientation == MapHex.EW) {
      x=(column + (letterAHasEvenNumbers ? 1 : 0)) / 2;
      y=row;
    }
 else {
      x=column;
      y=(row + 1) / 2;
    }
  }
  String sTileId=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  if (sTileId != null) {
    try {
      preprintedTileId=Integer.parseInt(sTileId);
    }
 catch (    NumberFormatException e) {
      throw new ConfigurationException(""String_Node_Str"" + sTileId);
    }
  }
 else {
    preprintedTileId=-999;
  }
  preprintedTileOrientation=XmlUtils.extractIntegerAttribute(nnp,""String_Node_Str"",0);
  currentTile=TileManager.get().getTile(preprintedTileId);
  currentTileRotation=preprintedTileOrientation;
  impassable=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  tileCost=XmlUtils.extractIntegerAttribute(nnp,""String_Node_Str"",0);
  stations=new ArrayList<Station>();
  for (int i=0; i < currentTile.getStations().size(); i++) {
    Station s=(Station)currentTile.getStations().get(i);
    stations.add(new Station(this,s));
  }
  String valueString=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  if (Util.hasValue(valueString)) {
    String[] values=valueString.split(""String_Node_Str"");
    offBoardValues=new int[values.length];
    for (int i=0; i < values.length; i++) {
      try {
        offBoardValues[i]=Integer.parseInt(values[i]);
      }
 catch (      NumberFormatException e) {
        throw new ConfigurationException(""String_Node_Str"" + values[i] + ""String_Node_Str""+ name,e);
      }
    }
  }
}","/** 
 * @see rails.game.ConfigurableComponentI#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Element el) throws ConfigurationException {
  NamedNodeMap nnp=el.getAttributes();
  Pattern namePattern=Pattern.compile(""String_Node_Str"");
  name=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  Matcher m=namePattern.matcher(name);
  if (!m.matches()) {
    throw new ConfigurationException(""String_Node_Str"" + name);
  }
  letter=m.group(1).charAt(0);
  try {
    number=Integer.parseInt(m.group(2));
  }
 catch (  NumberFormatException e) {
  }
  if (lettersGoHorizontal) {
    row=number;
    column=letter - '@';
    if (tileOrientation == MapHex.EW) {
      x=column;
      y=row / 2;
    }
 else {
      x=column;
      y=(row + 1) / 2;
    }
  }
 else {
    row=letter - '@';
    column=number;
    if (tileOrientation == MapHex.EW) {
      x=(column + (letterAHasEvenNumbers ? 1 : 0)) / 2;
      y=row;
    }
 else {
      x=column;
      y=(row + 1) / 2;
    }
  }
  String sTileId=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  if (sTileId != null) {
    try {
      preprintedTileId=Integer.parseInt(sTileId);
    }
 catch (    NumberFormatException e) {
      throw new ConfigurationException(""String_Node_Str"" + sTileId);
    }
  }
 else {
    preprintedTileId=-999;
  }
  currentTileRotation=XmlUtils.extractIntegerAttribute(nnp,""String_Node_Str"",0);
  currentTile=TileManager.get().getTile(preprintedTileId);
  impassable=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  tileCost=XmlUtils.extractIntegerAttribute(nnp,""String_Node_Str"",0);
  stations=new ArrayList<Station>();
  for (int i=0; i < currentTile.getStations().size(); i++) {
    Station s=(Station)currentTile.getStations().get(i);
    stations.add(new Station(this,s));
  }
  String valueString=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  if (Util.hasValue(valueString)) {
    String[] values=valueString.split(""String_Node_Str"");
    offBoardValues=new int[values.length];
    for (int i=0; i < values.length; i++) {
      try {
        offBoardValues[i]=Integer.parseInt(values[i]);
      }
 catch (      NumberFormatException e) {
        throw new ConfigurationException(""String_Node_Str"" + values[i] + ""String_Node_Str""+ name,e);
      }
    }
  }
}",0.9842841765339074
173846,"public void setHexModel(MapHex model){
  this.model=model;
  currentTile=model.getCurrentTile();
  hexName=model.getName();
  currentTileId=model.getPreprintedTileId();
  currentTileOrientation=model.getPreprintedTileOrientation();
  currentGUITile=new GUITile(currentTileId,model);
  currentGUITile.setRotation(currentTileOrientation);
  setToolTip();
  if (StatusWindow.useObserver) {
    model.addObserver(this);
  }
}","public void setHexModel(MapHex model){
  this.model=model;
  currentTile=model.getCurrentTile();
  hexName=model.getName();
  currentTileId=model.getCurrentTile().getId();
  currentTileOrientation=model.getCurrentTileRotation();
  currentGUITile=new GUITile(currentTileId,model);
  currentGUITile.setRotation(currentTileOrientation);
  setToolTip();
  if (StatusWindow.useObserver) {
    model.addObserver(this);
  }
}",0.9249106078665076
173847,"public void actionPerformed(ActionEvent actor){
  if (!(round instanceof OperatingRound))   return;
  oRound=(OperatingRound)round;
  retrieveStep=true;
  JComponent source=(JComponent)actor.getSource();
  String command=actor.getActionCommand();
  List<PossibleAction> executedActions=null;
  PossibleAction executedAction=null;
  PossibleAction executedActionToComplete=null;
  Class executedActionType=null;
  if (source instanceof ActionTaker) {
    executedActions=((ActionTaker)source).getPossibleActions();
    if (!executedActions.isEmpty()) {
      executedAction=executedActions.get(0);
      executedActionType=executedAction.getClass();
      log.debug(""String_Node_Str"" + executedAction.toString());
    }
  }
  int amount;
  if (executedActionType == SetDividend.class) {
    SetDividend action=(SetDividend)executedAction;
    if (command.equals(SET_REVENUE_CMD)) {
      amount=((Integer)revenueSelect[orCompIndex].getValue()).intValue();
      log.debug(""String_Node_Str"" + amount);
      action.setActualRevenue(amount);
      if (action.getRevenueAllocation() != SetDividend.UNKNOWN) {
        orWindow.process(action);
      }
 else {
        orStep=OperatingRound.STEP_PAYOUT;
        retrieveStep=false;
        executedActionToComplete=action;
      }
    }
 else {
      orWindow.process(action);
    }
  }
 else   if (command.equals(BUY_TRAIN_CMD)) {
    buyTrain();
  }
 else   if (command.equals(BUY_PRIVATE_CMD)) {
    buyPrivate();
  }
 else   if (executedActionType == NullAction.class || executedActionType == GameAction.class) {
    orWindow.process(executedAction);
  }
  ReportWindow.addLog();
  if (!(GameManager.getInstance().getCurrentRound() instanceof OperatingRound)) {
    orWindow.updateORWindow();
  }
}","public void actionPerformed(ActionEvent actor){
  if (!(round instanceof OperatingRound))   return;
  oRound=(OperatingRound)round;
  retrieveStep=true;
  JComponent source=(JComponent)actor.getSource();
  String command=actor.getActionCommand();
  List<PossibleAction> executedActions=null;
  PossibleAction executedAction=null;
  Class executedActionType=null;
  if (source instanceof ActionTaker) {
    executedActions=((ActionTaker)source).getPossibleActions();
    if (!executedActions.isEmpty()) {
      executedAction=executedActions.get(0);
      executedActionType=executedAction.getClass();
      log.debug(""String_Node_Str"" + executedAction.toString());
    }
  }
  int amount;
  if (executedActionType == SetDividend.class) {
    SetDividend action=(SetDividend)executedAction;
    if (command.equals(SET_REVENUE_CMD)) {
      amount=((Integer)revenueSelect[orCompIndex].getValue()).intValue();
      log.debug(""String_Node_Str"" + amount);
      action.setActualRevenue(amount);
      if (action.getRevenueAllocation() != SetDividend.UNKNOWN) {
        orWindow.process(action);
      }
 else {
        orStep=OperatingRound.STEP_PAYOUT;
        retrieveStep=false;
        updateStatus(action);
      }
    }
 else {
      orWindow.process(action);
    }
  }
 else   if (command.equals(BUY_TRAIN_CMD)) {
    buyTrain();
  }
 else   if (command.equals(BUY_PRIVATE_CMD)) {
    buyPrivate();
  }
 else   if (executedActionType == NullAction.class || executedActionType == GameAction.class) {
    orWindow.process(executedAction);
  }
  ReportWindow.addLog();
  if (!(GameManager.getInstance().getCurrentRound() instanceof OperatingRound)) {
    orWindow.updateORWindow();
  }
}",0.9711622487620156
173848,"public void actionPerformed(ActionEvent actor){
  String command=actor.getActionCommand();
  List<PossibleAction> actions=((ActionTaker)actor.getSource()).getPossibleActions();
  PossibleAction executedAction=null;
  if (actions != null && actions.size() > 0) {
    executedAction=actions.get(0);
  }
  if (command.equals(BUY_CMD)) {
    process(executedAction);
  }
 else   if (command.equals(SELL_CMD)) {
    process(executedAction);
  }
 else   if (command.equals(DONE_CMD) || command.equals(PASS_CMD)) {
    if (GameManager.isGameOver()) {
      System.exit(0);
    }
    process(executedAction);
  }
 else   if (command.equals(SWAP_CMD)) {
    SpecialSRProperty sp=(SpecialSRProperty)stockRound.getSpecialProperties().get(0);
    if (sp instanceof ExchangeForShare) {
      ((ExchangeForShare)sp).execute();
      extraButton.setText(""String_Node_Str"");
      extraButton.setEnabled(false);
      extraButton.setVisible(false);
    }
  }
 else   if (command.equals(QUIT_CMD))   System.exit(0);
 else   if (command.equals(SAVE_CMD))   new JFileChooser().showSaveDialog(this);
 else   if (command.equals(REPORT_CMD)) {
    GameUILoader.reportWindow.setVisible(((JMenuItem)actor.getSource()).isSelected());
    return;
  }
 else   if (command.equals(MARKET_CMD)) {
    GameUILoader.stockChart.setVisible(((JMenuItem)actor.getSource()).isSelected());
  }
 else   if (command.equals(MAP_CMD)) {
    GameUILoader.orWindow.setVisible(((JMenuItem)actor.getSource()).isSelected());
  }
 else   if (command.equals(UNDO_CMD)) {
    process(executedAction);
  }
 else   if (command.equals(FORCED_UNDO_CMD)) {
    process(executedAction);
  }
 else   if (command.equals(REDO_CMD)) {
    process(executedAction);
  }
}","public void actionPerformed(ActionEvent actor){
  String command=actor.getActionCommand();
  List<PossibleAction> actions=null;
  if (actor.getSource() instanceof ActionTaker) {
    actions=((ActionTaker)actor.getSource()).getPossibleActions();
  }
  PossibleAction executedAction=null;
  if (actions != null && actions.size() > 0) {
    executedAction=actions.get(0);
  }
  if (command.equals(BUY_CMD)) {
    process(executedAction);
  }
 else   if (command.equals(SELL_CMD)) {
    process(executedAction);
  }
 else   if (command.equals(DONE_CMD) || command.equals(PASS_CMD)) {
    if (GameManager.isGameOver()) {
      System.exit(0);
    }
    process(executedAction);
  }
 else   if (command.equals(SWAP_CMD)) {
    SpecialSRProperty sp=(SpecialSRProperty)stockRound.getSpecialProperties().get(0);
    if (sp instanceof ExchangeForShare) {
      ((ExchangeForShare)sp).execute();
      extraButton.setText(""String_Node_Str"");
      extraButton.setEnabled(false);
      extraButton.setVisible(false);
    }
  }
 else   if (command.equals(QUIT_CMD))   System.exit(0);
 else   if (command.equals(SAVE_CMD))   new JFileChooser().showSaveDialog(this);
 else   if (command.equals(REPORT_CMD)) {
    GameUILoader.reportWindow.setVisible(((JMenuItem)actor.getSource()).isSelected());
    return;
  }
 else   if (command.equals(MARKET_CMD)) {
    GameUILoader.stockChart.setVisible(((JMenuItem)actor.getSource()).isSelected());
  }
 else   if (command.equals(MAP_CMD)) {
    GameUILoader.orWindow.setVisible(((JMenuItem)actor.getSource()).isSelected());
  }
 else   if (command.equals(UNDO_CMD)) {
    process(executedAction);
  }
 else   if (command.equals(FORCED_UNDO_CMD)) {
    process(executedAction);
  }
 else   if (command.equals(REDO_CMD)) {
    process(executedAction);
  }
}",0.9782234957020056
173849,"/** 
 * Check if a player may buy the given number of shares from a given company.
 * @param company The company from which to buy
 * @param number The number of shares (usually 1 but not always so).
 * @return True if it is allowed.
 */
public boolean mayBuyCompanyShare(PublicCompanyI company,int number){
  if (portfolio.ownsShare(company) + number * company.getShareUnit() > playerShareLimit)   return false;
  return true;
}","/** 
 * Check if a player may buy the given number of shares from a given company.
 * @param company The company from which to buy
 * @param number The number of shares (usually 1 but not always so).
 * @return True if it is allowed.
 */
public boolean mayBuyCompanyShare(PublicCompanyI company,int number){
  if (portfolio.ownsShare(company) + number * company.getShareUnit() > playerShareLimit && !company.getCurrentPrice().isNoHoldLimit())   return false;
  return true;
}",0.9491150442477876
173850,"/** 
 * Create a list of certificates that a player may sell in a Stock Round, taking all rules taken into account.
 * @return List of sellable certificates.
 */
public List getSellableCerts(){
  List sellableCerts=new ArrayList();
  if (!mayCurrentPlayerSellAtAll())   return sellableCerts;
  List certs;
  PublicCertificateI cert;
  TradeableCertificate tCert;
  PublicCompanyI comp;
  String compName;
  int price;
  for (Iterator it=currentPlayer.getPortfolio().getUniqueTradeableCertificates().iterator(); it.hasNext(); ) {
    tCert=(TradeableCertificate)it.next();
    cert=tCert.getCert();
    comp=cert.getCompany();
    compName=comp.getName();
    if (cert.getShare() + pool.ownsShare(comp) > Bank.getPoolShareLimit()) {
      continue;
    }
    if (cert.isPresidentShare()) {
      boolean victimFound=false;
      Player[] players=GameManager.getPlayers();
      for (int i=0; i < numberOfPlayers; i++) {
        if (players[i] == currentPlayer)         continue;
        if (players[i].getPortfolio().ownsShare(comp) >= cert.getShare()) {
          victimFound=true;
          break;
        }
      }
      if (!victimFound)       continue;
    }
    if (sellPrices.containsKey(compName)) {
      price=cert.getShares() * ((StockSpaceI)sellPrices.get(compName)).getPrice();
      tCert.setPrice(price);
    }
    sellableCerts.add(tCert);
  }
  return sellableCerts;
}","/** 
 * Create a list of certificates that a player may sell in a Stock Round, taking all rules taken into account.
 * @return List of sellable certificates.
 */
public List getSellableCerts(){
  List sellableCerts=new ArrayList();
  if (!mayCurrentPlayerSellAtAll())   return sellableCerts;
  List certs;
  PublicCertificateI cert;
  TradeableCertificate tCert;
  PublicCompanyI comp;
  String compName;
  int price;
  for (Iterator it=currentPlayer.getPortfolio().getUniqueTradeableCertificates().iterator(); it.hasNext(); ) {
    tCert=(TradeableCertificate)it.next();
    cert=tCert.getCert();
    comp=cert.getCompany();
    compName=comp.getName();
    if (cert.isPresidentShare()) {
      if (comp.getShareUnit() + pool.ownsShare(comp) > Bank.getPoolShareLimit()) {
        continue;
      }
      boolean victimFound=false;
      Player[] players=GameManager.getPlayers();
      for (int i=0; i < numberOfPlayers; i++) {
        if (players[i] == currentPlayer)         continue;
        if (players[i].getPortfolio().ownsShare(comp) >= cert.getShare()) {
          victimFound=true;
          break;
        }
      }
      if (!victimFound)       continue;
    }
 else {
      if (cert.getShare() + pool.ownsShare(comp) > Bank.getPoolShareLimit()) {
        continue;
      }
    }
    if (sellPrices.containsKey(compName)) {
      price=cert.getShares() * ((StockSpaceI)sellPrices.get(compName)).getPrice();
      tCert.setPrice(price);
    }
    sellableCerts.add(tCert);
  }
  return sellableCerts;
}",0.8602002071108042
173851,"/** 
 * Buying one or more single or double-share certificates (more is sometimes possible)
 * @param player The player that wants to buy shares.
 * @param portfolio The portfolio from which to buy shares.
 * @param company The company of which to buy shares.
 * @param shares The number of shares to buy.
 * @param unit The number of share units in each certificate to buy (e.g. value is 2 for 20% Badische or 10% Preussische non-president certificates in 1835).
 * @return True if the certificates could be bought. False indicates anerror. TODO Usage of 'unit' argument.
 */
public boolean buyShare(String playerName,Portfolio from,String companyName,int shares,int unit){
  String errMsg=null;
  int price=0;
  PublicCompanyI company=null;
  currentPlayer=GameManager.getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=""String_Node_Str"" + playerName;
      break;
    }
    company=companyMgr.getPublicCompany(companyName);
    if (company == null) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (isSaleRecorded(currentPlayer,company)) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"" + companyName+ ""String_Node_Str"";
      break;
    }
    if (!company.hasStarted()) {
      errMsg=""String_Node_Str"" + companyName + ""String_Node_Str"";
      break;
    }
    if (companyBoughtThisTurn != null && (companyBoughtThisTurn != company || !company.getCurrentPrice().isNoBuyLimit())) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"" + companyBoughtThisTurn.getName()+ ""String_Node_Str"";
      break;
    }
    if (shares > from.ownsShare(company)) {
      errMsg=companyName + ""String_Node_Str"";
      break;
    }
    StockSpaceI currentSpace;
    if (from == ipo && company.hasParPrice()) {
      currentSpace=company.getParPrice();
    }
 else {
      currentSpace=company.getCurrentPrice();
    }
    if (shares > 1 && !currentSpace.isNoBuyLimit()) {
      errMsg=""String_Node_Str"" + companyName + ""String_Node_Str"";
      break;
    }
    if (!currentSpace.isNoCertLimit() && !currentPlayer.mayBuyCertificates(shares)) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"";
      break;
    }
    if (!currentSpace.isNoHoldLimit() && !currentPlayer.mayBuyCompanyShare(company,shares)) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"";
      break;
    }
    price=currentSpace.getPrice();
    if (currentPlayer.getCash() < shares * price) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"";
      break;
    }
    break;
  }
  if (errMsg != null) {
    Log.error(playerName + ""String_Node_Str"" + shares+ ""String_Node_Str""+ companyName+ ""String_Node_Str""+ from.getName()+ ""String_Node_Str""+ errMsg);
    return false;
  }
  PublicCertificateI cert;
  for (int i=0; i < shares; i++) {
    cert=from.findCertificate(company,false);
    Log.write(playerName + ""String_Node_Str"" + shares+ ""String_Node_Str""+ cert.getShare()+ ""String_Node_Str""+ companyName+ ""String_Node_Str""+ from.getName()+ ""String_Node_Str""+ Bank.format(shares * price)+ ""String_Node_Str"");
    currentPlayer.buy(cert,price * cert.getShares());
  }
  companyBoughtThisTurn=company;
  hasPassed=false;
  setPriority();
  if (from == ipo)   company.checkFlotation();
  return true;
}","/** 
 * Buying one or more single or double-share certificates (more is sometimes possible)
 * @param player The player that wants to buy shares.
 * @param portfolio The portfolio from which to buy shares.
 * @param company The company of which to buy shares.
 * @param shares The number of shares to buy.
 * @param unit The number of share units in each certificate to buy (e.g. value is 2 for 20% Badische or 10% Preussische non-president certificates in 1835).
 * @return True if the certificates could be bought. False indicates anerror. TODO Usage of 'unit' argument.
 */
public boolean buyShare(String playerName,Portfolio from,String companyName,int shares,int unit){
  String errMsg=null;
  int price=0;
  PublicCompanyI company=null;
  currentPlayer=GameManager.getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=""String_Node_Str"" + playerName;
      break;
    }
    company=companyMgr.getPublicCompany(companyName);
    if (company == null) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (isSaleRecorded(currentPlayer,company)) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"" + companyName+ ""String_Node_Str"";
      break;
    }
    if (!company.hasStarted()) {
      errMsg=""String_Node_Str"" + companyName + ""String_Node_Str"";
      break;
    }
    if (companyBoughtThisTurn != null && (companyBoughtThisTurn != company || !company.getCurrentPrice().isNoBuyLimit())) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"" + companyBoughtThisTurn.getName()+ ""String_Node_Str"";
      break;
    }
    if (shares > from.ownsShare(company)) {
      errMsg=companyName + ""String_Node_Str"";
      break;
    }
    StockSpaceI currentSpace;
    if (from == ipo && company.hasParPrice()) {
      currentSpace=company.getParPrice();
    }
 else {
      currentSpace=company.getCurrentPrice();
    }
    if (shares > 1 && !currentSpace.isNoBuyLimit()) {
      errMsg=""String_Node_Str"" + companyName + ""String_Node_Str"";
      break;
    }
    if (!currentSpace.isNoCertLimit() && !currentPlayer.mayBuyCertificate(company,shares)) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"";
      break;
    }
    if (!currentSpace.isNoHoldLimit() && !currentPlayer.mayBuyCompanyShare(company,shares)) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"";
      break;
    }
    price=currentSpace.getPrice();
    if (currentPlayer.getCash() < shares * price) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"";
      break;
    }
    break;
  }
  if (errMsg != null) {
    Log.error(playerName + ""String_Node_Str"" + shares+ ""String_Node_Str""+ companyName+ ""String_Node_Str""+ from.getName()+ ""String_Node_Str""+ errMsg);
    return false;
  }
  PublicCertificateI cert;
  for (int i=0; i < shares; i++) {
    cert=from.findCertificate(company,false);
    Log.write(playerName + ""String_Node_Str"" + shares+ ""String_Node_Str""+ cert.getShare()+ ""String_Node_Str""+ companyName+ ""String_Node_Str""+ from.getName()+ ""String_Node_Str""+ Bank.format(shares * price)+ ""String_Node_Str"");
    currentPlayer.buy(cert,price * cert.getShares());
  }
  companyBoughtThisTurn=company;
  hasPassed=false;
  setPriority();
  if (from == ipo)   company.checkFlotation();
  return true;
}",0.998313142156111
173852,"/** 
 * Start a company by buying one or more shares (more applies to e.g. 1841)
 * @param player The player that wants to start a company.
 * @param company The company to start.
 * @param price The start (par) price (ignored if the price is fixed).
 * @param shares The number of shares to buy (can be more than 1 in e.g. 1841).
 * @return True if the company could be started. False indicates an error.
 */
public boolean startCompany(String playerName,String companyName,int price,int shares){
  String errMsg=null;
  StockSpaceI startSpace=null;
  int numberOfCertsToBuy=0;
  PublicCertificateI cert=null;
  PublicCompanyI company=null;
  currentPlayer=GameManager.getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=""String_Node_Str"" + playerName;
      break;
    }
    if (companyBoughtThisTurn != null) {
      errMsg=""String_Node_Str"";
      break;
    }
    company=companyMgr.getPublicCompany(companyName);
    if (company == null) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (company.hasStarted()) {
      errMsg=company.getName() + ""String_Node_Str"";
      break;
    }
    cert=ipo.findCertificate(company,true);
    if (shares < cert.getShares())     shares=cert.getShares();
    numberOfCertsToBuy=shares - (cert.getShares() - 1);
    if (!currentPlayer.mayBuyCertificates(numberOfCertsToBuy)) {
      errMsg=""String_Node_Str"";
      break;
    }
    startSpace=company.getParPrice();
    if (startSpace != null) {
      price=startSpace.getPrice();
    }
 else {
      if ((startSpace=stockMarket.getStartSpace(price)) == null) {
        errMsg=""String_Node_Str"" + price;
        break;
      }
    }
    if (currentPlayer.getCash() < shares * price) {
      errMsg=""String_Node_Str"";
      break;
    }
    break;
  }
  if (errMsg != null) {
    Log.error(playerName + ""String_Node_Str"" + companyName+ ""String_Node_Str""+ errMsg);
    return false;
  }
  company.start(startSpace);
  currentPlayer.getPortfolio().buyCertificate(cert,ipo,cert.getCertificatePrice());
  for (int i=1; i < numberOfCertsToBuy; i++) {
    cert=ipo.findCertificate(company,false);
    currentPlayer.getPortfolio().buyCertificate(cert,ipo,cert.getCertificatePrice());
  }
  Log.write(playerName + ""String_Node_Str"" + companyName+ ""String_Node_Str""+ price+ ""String_Node_Str""+ shares+ ""String_Node_Str""+ cert.getShare()+ ""String_Node_Str""+ Bank.format(shares * price)+ ""String_Node_Str"");
  company.checkFlotation();
  companyBoughtThisTurn=company;
  hasPassed=false;
  setPriority();
  return true;
}","/** 
 * Start a company by buying one or more shares (more applies to e.g. 1841)
 * @param player The player that wants to start a company.
 * @param company The company to start.
 * @param price The start (par) price (ignored if the price is fixed).
 * @param shares The number of shares to buy (can be more than 1 in e.g. 1841).
 * @return True if the company could be started. False indicates an error.
 */
public boolean startCompany(String playerName,String companyName,int price,int shares){
  String errMsg=null;
  StockSpaceI startSpace=null;
  int numberOfCertsToBuy=0;
  PublicCertificateI cert=null;
  PublicCompanyI company=null;
  currentPlayer=GameManager.getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=""String_Node_Str"" + playerName;
      break;
    }
    if (companyBoughtThisTurn != null) {
      errMsg=""String_Node_Str"";
      break;
    }
    company=companyMgr.getPublicCompany(companyName);
    if (company == null) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (company.hasStarted()) {
      errMsg=company.getName() + ""String_Node_Str"";
      break;
    }
    cert=ipo.findCertificate(company,true);
    if (shares < cert.getShares())     shares=cert.getShares();
    numberOfCertsToBuy=shares - (cert.getShares() - 1);
    if (!currentPlayer.mayBuyCertificate(company,numberOfCertsToBuy)) {
      errMsg=""String_Node_Str"";
      break;
    }
    startSpace=company.getParPrice();
    if (startSpace != null) {
      price=startSpace.getPrice();
    }
 else {
      if ((startSpace=stockMarket.getStartSpace(price)) == null) {
        errMsg=""String_Node_Str"" + price;
        break;
      }
    }
    if (currentPlayer.getCash() < shares * price) {
      errMsg=""String_Node_Str"";
      break;
    }
    break;
  }
  if (errMsg != null) {
    Log.error(playerName + ""String_Node_Str"" + companyName+ ""String_Node_Str""+ errMsg);
    return false;
  }
  company.start(startSpace);
  currentPlayer.getPortfolio().buyCertificate(cert,ipo,cert.getCertificatePrice());
  for (int i=1; i < numberOfCertsToBuy; i++) {
    cert=ipo.findCertificate(company,false);
    currentPlayer.getPortfolio().buyCertificate(cert,ipo,cert.getCertificatePrice());
  }
  Log.write(playerName + ""String_Node_Str"" + companyName+ ""String_Node_Str""+ price+ ""String_Node_Str""+ shares+ ""String_Node_Str""+ cert.getShare()+ ""String_Node_Str""+ Bank.format(shares * price)+ ""String_Node_Str"");
  company.checkFlotation();
  companyBoughtThisTurn=company;
  hasPassed=false;
  setPriority();
  return true;
}",0.9978570037015392
173853,"public static void setNoSaleInFirstSR(){
  noSaleInFirstSR=true;
}","/** 
 * Can the current player do any buying?
 * @return True if any buying is allowed.
 */
public static void setNoSaleInFirstSR(){
  noSaleInFirstSR=true;
}",0.5892857142857143
173854,"/** 
 * Create a list of certificates that a player may buy in a Stock Round, taking all rules into account.
 * @return List of buyable certificates.
 */
public List getBuyableCerts(){
  List buyableCerts=new ArrayList();
  if (!mayCurrentPlayerBuyAtAll() || !currentPlayer.mayBuyCertificates(1))   return buyableCerts;
  List certs;
  PublicCertificateI cert;
  TradeableCertificate tCert;
  PublicCompanyI comp;
  int price;
  int playerCash=currentPlayer.getCash();
  String compName;
  Map map=Bank.getIpo().getCertsPerCompanyMap();
  int lowestStartPrice=999;
  int highestStartPrice=0;
  int shares;
  int[] startPrices=stockMarket.getStartPrices();
  for (Iterator it=map.keySet().iterator(); it.hasNext(); ) {
    compName=(String)it.next();
    certs=(List)map.get(compName);
    if (certs == null || certs.isEmpty())     continue;
    cert=(PublicCertificateI)certs.get(0);
    comp=cert.getCompany();
    if (isSaleRecorded(currentPlayer,comp))     continue;
    if (!currentPlayer.mayBuyCompanyShare(comp,1))     continue;
    shares=cert.getShares();
    if (!comp.hasStarted()) {
      for (int i=0; i < startPrices.length; i++) {
        if (startPrices[i] * shares <= playerCash) {
          buyableCerts.add(new TradeableCertificate(cert,startPrices[i]));
        }
      }
    }
 else     if (comp.hasParPrice()) {
      price=comp.getParPrice().getPrice() * cert.getShares();
      if (playerCash < price)       continue;
      buyableCerts.add(new TradeableCertificate(cert,price));
    }
 else {
      price=comp.getCurrentPrice().getPrice() * cert.getShares();
      if (playerCash < price)       continue;
      buyableCerts.add(new TradeableCertificate(cert,price));
    }
  }
  for (Iterator it=Bank.getPool().getUniqueTradeableCertificates().iterator(); it.hasNext(); ) {
    tCert=(TradeableCertificate)it.next();
    if (playerCash < tCert.getPrice())     continue;
    comp=tCert.getCert().getCompany();
    if (isSaleRecorded(currentPlayer,comp))     continue;
    if (!currentPlayer.mayBuyCompanyShare(comp,1))     continue;
    buyableCerts.add(tCert);
  }
  return buyableCerts;
}","/** 
 * Create a list of certificates that a player may buy in a Stock Round, taking all rules into account.
 * @return List of buyable certificates.
 */
public List getBuyableCerts(){
  List buyableCerts=new ArrayList();
  List certs;
  PublicCertificateI cert;
  TradeableCertificate tCert;
  PublicCompanyI comp;
  int price;
  int playerCash=currentPlayer.getCash();
  if (this.companyBoughtThisTurn == null) {
    String compName;
    Map map=Bank.getIpo().getCertsPerCompanyMap();
    int lowestStartPrice=999;
    int highestStartPrice=0;
    int shares;
    int[] startPrices=stockMarket.getStartPrices();
    for (Iterator it=map.keySet().iterator(); it.hasNext(); ) {
      compName=(String)it.next();
      certs=(List)map.get(compName);
      if (certs == null || certs.isEmpty())       continue;
      cert=(PublicCertificateI)certs.get(0);
      comp=cert.getCompany();
      if (isSaleRecorded(currentPlayer,comp))       continue;
      if (!currentPlayer.mayBuyCompanyShare(comp,1))       continue;
      shares=cert.getShares();
      if (!comp.hasStarted()) {
        for (int i=0; i < startPrices.length; i++) {
          if (startPrices[i] * shares <= playerCash) {
            buyableCerts.add(new TradeableCertificate(cert,startPrices[i]));
          }
        }
      }
 else       if (comp.hasParPrice()) {
        price=comp.getParPrice().getPrice() * cert.getShares();
        if (playerCash < price)         continue;
        buyableCerts.add(new TradeableCertificate(cert,price));
      }
 else {
        price=comp.getCurrentPrice().getPrice() * cert.getShares();
        if (playerCash < price)         continue;
        buyableCerts.add(new TradeableCertificate(cert,price));
      }
    }
  }
  for (Iterator it=Bank.getPool().getUniqueTradeableCertificates().iterator(); it.hasNext(); ) {
    tCert=(TradeableCertificate)it.next();
    if (playerCash < tCert.getPrice())     continue;
    comp=tCert.getCert().getCompany();
    if (isSaleRecorded(currentPlayer,comp))     continue;
    if (companyBoughtThisTurn != null) {
      if (comp != companyBoughtThisTurn)       continue;
      if (!comp.getCurrentPrice().isNoBuyLimit())       continue;
    }
    if (!currentPlayer.mayBuyCompanyShare(comp,1))     continue;
    if (!currentPlayer.mayBuyCertificate(comp,1))     continue;
    buyableCerts.add(tCert);
  }
  return buyableCerts;
}",0.7671721677074042
173855,"private void init(){
  certPerPlayer=new Field[nc][np];
  certPerPlayerButton=new ClickField[nc][np];
  certInIPO=new Field[nc];
  certInIPOButton=new ClickField[nc];
  certInPool=new Field[nc];
  certInPoolButton=new ClickField[nc];
  parPrice=new Field[nc];
  currPrice=new Field[nc];
  compCash=new Field[nc];
  compRevenue=new Field[nc];
  compTrains=new Field[nc];
  compPrivates=new Field[nc];
  playerCash=new Field[np];
  playerPrivates=new Field[np];
  playerWorth=new Field[np];
  upperPlayerCaption=new Caption[np];
  lowerPlayerCaption=new Caption[np];
  certPerPlayerXOffset=1;
  certPerPlayerYOffset=2;
  certInIPOXOffset=np + 1;
  certInIPOYOffset=2;
  certInPoolXOffset=np + 2;
  certInPoolYOffset=2;
  parPriceXOffset=np + 3;
  parPriceYOffset=2;
  currPriceXOffset=np + 4;
  currPriceYOffset=2;
  compCashXOffset=np + 5;
  compCashYOffset=2;
  compRevenueXOffset=np + 6;
  compRevenueYOffset=2;
  compTrainsXOffset=np + 7;
  compTrainsYOffset=2;
  compPrivatesXOffset=np + 8;
  compPrivatesYOffset=2;
  playerCashXOffset=1;
  playerCashYOffset=nc + 2;
  playerPrivatesXOffset=1;
  playerPrivatesYOffset=nc + 3;
  playerWorthXOffset=1;
  playerWorthYOffset=nc + 4;
  bankCashXOffset=np + 2;
  bankCashYOffset=nc + 3;
  poolTrainsXOffset=np + 3;
  poolTrainsYOffset=nc + 3;
  newTrainsXOffset=np + 5;
  newTrainsYOffset=nc + 3;
  futureTrainsXOffset=np + 6;
  futureTrainsYOffset=nc + 3;
  addField(new Caption(""String_Node_Str""),0,0,1,2,WIDE_RIGHT + WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),certPerPlayerXOffset,0,np,1,0);
  for (int i=0; i < np; i++) {
    playerIndex.put(players[i],new Integer(i));
    f=upperPlayerCaption[i]=new Caption(players[i].getName());
    addField(f,certPerPlayerXOffset + i,1,1,1,WIDE_BOTTOM);
  }
  addField(new Caption(""String_Node_Str""),certInIPOXOffset,0,2,1,WIDE_LEFT + WIDE_RIGHT);
  addField(new Caption(""String_Node_Str""),certInIPOXOffset,1,1,1,WIDE_LEFT + WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),certInPoolXOffset,1,1,1,WIDE_RIGHT + WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),parPriceXOffset,0,2,1,WIDE_RIGHT);
  addField(new Caption(""String_Node_Str""),parPriceXOffset,1,1,1,WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),currPriceXOffset,1,1,1,WIDE_RIGHT + WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),compCashXOffset,0,4,1,0);
  addField(new Caption(""String_Node_Str""),compCashXOffset,1,1,1,WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),compRevenueXOffset,1,1,1,WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),compTrainsXOffset,1,1,1,WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),compPrivatesXOffset,1,1,1,WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),compPrivatesXOffset + 1,0,1,2,WIDE_LEFT + WIDE_BOTTOM);
  for (int i=0; i < nc; i++) {
    c=companies[i];
    companyIndex.put(c,new Integer(i));
    f=new Caption(c.getName());
    f.setForeground(c.getFgColour());
    f.setBackground(c.getBgColour());
    addField(f,0,certPerPlayerYOffset + i,1,1,WIDE_RIGHT);
    for (int j=0; j < np; j++) {
      f=certPerPlayer[i][j]=new Field(players[j].getPortfolio().getShareModel(c));
      addField(f,certPerPlayerXOffset + j,certPerPlayerYOffset + i,1,1,0);
      f=certPerPlayerButton[i][j]=new ClickField(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",this,buySellGroup);
      addField(f,certPerPlayerXOffset + j,certPerPlayerYOffset + i,1,1,0);
    }
    f=certInIPO[i]=new Field(Bank.getIpo().getShareModel(c));
    addField(f,certInIPOXOffset,certInIPOYOffset + i,1,1,WIDE_LEFT);
    f=certInIPOButton[i]=new ClickField(certInIPO[i].getText(),""String_Node_Str"",""String_Node_Str"",this,buySellGroup);
    f.setVisible(false);
    addField(f,certInIPOXOffset,certInIPOYOffset + i,1,1,WIDE_LEFT);
    certInIPO[i].setPreferredSize(certInIPOButton[i].getPreferredSize());
    f=certInPool[i]=new Field(Bank.getPool().getShareModel(c));
    addField(f,certInPoolXOffset,certInPoolYOffset + i,1,1,WIDE_RIGHT);
    f=certInPoolButton[i]=new ClickField(certInPool[i].getText(),""String_Node_Str"",""String_Node_Str"",this,buySellGroup);
    f.setVisible(false);
    addField(f,certInPoolXOffset,certInPoolYOffset + i,1,1,WIDE_RIGHT);
    certInPool[i].setPreferredSize(certInIPOButton[i].getPreferredSize());
    f=parPrice[i]=new Field(c.getParPriceModel());
    addField(f,parPriceXOffset,parPriceYOffset + i,1,1,0);
    f=currPrice[i]=new Field(c.getCurrentPriceModel());
    addField(f,currPriceXOffset,currPriceYOffset + i,1,1,WIDE_RIGHT);
    f=compCash[i]=new Field(c.getCashModel());
    addField(f,compCashXOffset,compCashYOffset + i,1,1,0);
    f=compRevenue[i]=new Field(c.getLastRevenueModel());
    addField(f,compRevenueXOffset,compRevenueYOffset + i,1,1,0);
    f=compTrains[i]=new Field(c.getPortfolio().getTrainsModel().option(TrainsModel.FULL_LIST));
    addField(f,compTrainsXOffset,compTrainsYOffset + i,1,1,0);
    f=compPrivates[i]=new Field(c.getPortfolio().getPrivatesModel().option(PrivatesModel.SPACE));
    addField(f,compPrivatesXOffset,compPrivatesYOffset + i,1,1,0);
    f=new Caption(c.getName());
    f.setForeground(c.getFgColour());
    f.setBackground(c.getBgColour());
    addField(f,compPrivatesXOffset + 1,compPrivatesYOffset + i,1,1,WIDE_LEFT);
  }
  addField(new Caption(""String_Node_Str""),0,playerCashYOffset,1,1,WIDE_TOP + WIDE_RIGHT);
  for (int i=0; i < np; i++) {
    f=playerCash[i]=new Field(players[i].getCashModel());
    addField(f,playerCashXOffset + i,playerCashYOffset,1,1,WIDE_TOP);
  }
  addField(new Caption(""String_Node_Str""),0,playerPrivatesYOffset,1,1,WIDE_RIGHT);
  for (int i=0; i < np; i++) {
    f=playerPrivates[i]=new Field(players[i].getPortfolio().getPrivatesModel().option(PrivatesModel.BREAK));
    addField(f,playerPrivatesXOffset + i,playerPrivatesYOffset,1,1,0);
  }
  addField(new Caption(""String_Node_Str""),0,playerWorthYOffset,1,1,WIDE_RIGHT);
  for (int i=0; i < np; i++) {
    f=playerWorth[i]=new Field(players[i].getWorthModel(),true);
    addField(f,playerWorthXOffset + i,playerWorthYOffset,1,1,0);
  }
  for (int i=0; i < np; i++) {
    f=lowerPlayerCaption[i]=new Caption(players[i].getName());
    addField(f,i + 1,playerWorthYOffset + 1,1,1,WIDE_TOP);
  }
  addField(new Caption(""String_Node_Str""),bankCashXOffset - 1,bankCashYOffset - 1,1,2,WIDE_TOP + WIDE_LEFT);
  addField(new Caption(""String_Node_Str""),bankCashXOffset,bankCashYOffset - 1,1,1,WIDE_TOP);
  bankCash=new Field(Bank.getInstance().getCashModel());
  addField(bankCash,bankCashXOffset,bankCashYOffset,1,1,0);
  addField(new Caption(""String_Node_Str""),poolTrainsXOffset,poolTrainsYOffset - 1,2,1,WIDE_TOP + WIDE_RIGHT);
  poolTrains=new Field(Bank.getPool().getTrainsModel().option(TrainsModel.FULL_LIST));
  addField(poolTrains,poolTrainsXOffset,poolTrainsYOffset,2,1,WIDE_RIGHT);
  addField(new Caption(""String_Node_Str""),newTrainsXOffset,newTrainsYOffset - 1,1,1,WIDE_TOP);
  newTrains=new Field(Bank.getIpo().getTrainsModel().option(TrainsModel.ABBR_LIST));
  addField(newTrains,newTrainsXOffset,newTrainsYOffset,1,1,0);
  dummyButton=new ClickField(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",this,buySellGroup);
  addField(new Caption(""String_Node_Str""),futureTrainsXOffset,futureTrainsYOffset - 1,3,1,WIDE_LEFT + WIDE_TOP);
  futureTrains=new Field(Bank.getUnavailable().getTrainsModel().option(TrainsModel.ABBR_LIST));
  addField(futureTrains,futureTrainsXOffset,futureTrainsYOffset,3,1,WIDE_LEFT);
  dummyButton=new ClickField(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",this,buySellGroup);
}","private void init(){
  certPerPlayer=new Field[nc][np];
  certPerPlayerButton=new ClickField[nc][np];
  certInIPO=new Field[nc];
  certInIPOButton=new ClickField[nc];
  certInPool=new Field[nc];
  certInPoolButton=new ClickField[nc];
  parPrice=new Field[nc];
  currPrice=new Field[nc];
  compCash=new Field[nc];
  compRevenue=new Field[nc];
  compTrains=new Field[nc];
  compPrivates=new Field[nc];
  playerCash=new Field[np];
  playerPrivates=new Field[np];
  playerWorth=new Field[np];
  playerCertCount=new Field[np];
  upperPlayerCaption=new Caption[np];
  lowerPlayerCaption=new Caption[np];
  certPerPlayerXOffset=1;
  certPerPlayerYOffset=2;
  certInIPOXOffset=np + 1;
  certInIPOYOffset=2;
  certInPoolXOffset=np + 2;
  certInPoolYOffset=2;
  parPriceXOffset=np + 3;
  parPriceYOffset=2;
  currPriceXOffset=np + 4;
  currPriceYOffset=2;
  compCashXOffset=np + 5;
  compCashYOffset=2;
  compRevenueXOffset=np + 6;
  compRevenueYOffset=2;
  compTrainsXOffset=np + 7;
  compTrainsYOffset=2;
  compPrivatesXOffset=np + 8;
  compPrivatesYOffset=2;
  playerCashXOffset=1;
  playerCashYOffset=nc + 2;
  playerPrivatesXOffset=1;
  playerPrivatesYOffset=nc + 3;
  playerWorthXOffset=1;
  playerWorthYOffset=nc + 4;
  playerCertCountXOffset=1;
  playerCertCountYOffset=nc + 5;
  certLimitXOffset=np + 2;
  certLimitYOffset=playerCertCountYOffset;
  bankCashXOffset=np + 2;
  bankCashYOffset=nc + 3;
  poolTrainsXOffset=np + 3;
  poolTrainsYOffset=nc + 3;
  newTrainsXOffset=np + 5;
  newTrainsYOffset=nc + 3;
  futureTrainsXOffset=np + 6;
  futureTrainsYOffset=nc + 3;
  addField(new Caption(""String_Node_Str""),0,0,1,2,WIDE_RIGHT + WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),certPerPlayerXOffset,0,np,1,0);
  for (int i=0; i < np; i++) {
    playerIndex.put(players[i],new Integer(i));
    f=upperPlayerCaption[i]=new Caption(players[i].getName());
    addField(f,certPerPlayerXOffset + i,1,1,1,WIDE_BOTTOM);
  }
  addField(new Caption(""String_Node_Str""),certInIPOXOffset,0,2,1,WIDE_LEFT + WIDE_RIGHT);
  addField(new Caption(""String_Node_Str""),certInIPOXOffset,1,1,1,WIDE_LEFT + WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),certInPoolXOffset,1,1,1,WIDE_RIGHT + WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),parPriceXOffset,0,2,1,WIDE_RIGHT);
  addField(new Caption(""String_Node_Str""),parPriceXOffset,1,1,1,WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),currPriceXOffset,1,1,1,WIDE_RIGHT + WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),compCashXOffset,0,4,1,0);
  addField(new Caption(""String_Node_Str""),compCashXOffset,1,1,1,WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),compRevenueXOffset,1,1,1,WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),compTrainsXOffset,1,1,1,WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),compPrivatesXOffset,1,1,1,WIDE_BOTTOM);
  addField(new Caption(""String_Node_Str""),compPrivatesXOffset + 1,0,1,2,WIDE_LEFT + WIDE_BOTTOM);
  for (int i=0; i < nc; i++) {
    c=companies[i];
    companyIndex.put(c,new Integer(i));
    f=new Caption(c.getName());
    f.setForeground(c.getFgColour());
    f.setBackground(c.getBgColour());
    addField(f,0,certPerPlayerYOffset + i,1,1,WIDE_RIGHT);
    for (int j=0; j < np; j++) {
      f=certPerPlayer[i][j]=new Field(players[j].getPortfolio().getShareModel(c));
      addField(f,certPerPlayerXOffset + j,certPerPlayerYOffset + i,1,1,0);
      f=certPerPlayerButton[i][j]=new ClickField(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",this,buySellGroup);
      addField(f,certPerPlayerXOffset + j,certPerPlayerYOffset + i,1,1,0);
    }
    f=certInIPO[i]=new Field(Bank.getIpo().getShareModel(c));
    addField(f,certInIPOXOffset,certInIPOYOffset + i,1,1,WIDE_LEFT);
    f=certInIPOButton[i]=new ClickField(certInIPO[i].getText(),""String_Node_Str"",""String_Node_Str"",this,buySellGroup);
    f.setVisible(false);
    addField(f,certInIPOXOffset,certInIPOYOffset + i,1,1,WIDE_LEFT);
    certInIPO[i].setPreferredSize(certInIPOButton[i].getPreferredSize());
    f=certInPool[i]=new Field(Bank.getPool().getShareModel(c));
    addField(f,certInPoolXOffset,certInPoolYOffset + i,1,1,WIDE_RIGHT);
    f=certInPoolButton[i]=new ClickField(certInPool[i].getText(),""String_Node_Str"",""String_Node_Str"",this,buySellGroup);
    f.setVisible(false);
    addField(f,certInPoolXOffset,certInPoolYOffset + i,1,1,WIDE_RIGHT);
    certInPool[i].setPreferredSize(certInIPOButton[i].getPreferredSize());
    f=parPrice[i]=new Field(c.getParPriceModel());
    addField(f,parPriceXOffset,parPriceYOffset + i,1,1,0);
    f=currPrice[i]=new Field(c.getCurrentPriceModel());
    addField(f,currPriceXOffset,currPriceYOffset + i,1,1,WIDE_RIGHT);
    f=compCash[i]=new Field(c.getCashModel());
    addField(f,compCashXOffset,compCashYOffset + i,1,1,0);
    f=compRevenue[i]=new Field(c.getLastRevenueModel());
    addField(f,compRevenueXOffset,compRevenueYOffset + i,1,1,0);
    f=compTrains[i]=new Field(c.getPortfolio().getTrainsModel().option(TrainsModel.FULL_LIST));
    addField(f,compTrainsXOffset,compTrainsYOffset + i,1,1,0);
    f=compPrivates[i]=new Field(c.getPortfolio().getPrivatesModel().option(PrivatesModel.SPACE));
    addField(f,compPrivatesXOffset,compPrivatesYOffset + i,1,1,0);
    f=new Caption(c.getName());
    f.setForeground(c.getFgColour());
    f.setBackground(c.getBgColour());
    addField(f,compPrivatesXOffset + 1,compPrivatesYOffset + i,1,1,WIDE_LEFT);
  }
  addField(new Caption(""String_Node_Str""),0,playerCashYOffset,1,1,WIDE_TOP + WIDE_RIGHT);
  for (int i=0; i < np; i++) {
    f=playerCash[i]=new Field(players[i].getCashModel());
    addField(f,playerCashXOffset + i,playerCashYOffset,1,1,WIDE_TOP);
  }
  addField(new Caption(""String_Node_Str""),0,playerPrivatesYOffset,1,1,WIDE_RIGHT);
  for (int i=0; i < np; i++) {
    f=playerPrivates[i]=new Field(players[i].getPortfolio().getPrivatesModel().option(PrivatesModel.BREAK));
    addField(f,playerPrivatesXOffset + i,playerPrivatesYOffset,1,1,0);
  }
  addField(new Caption(""String_Node_Str""),0,playerWorthYOffset,1,1,WIDE_RIGHT);
  for (int i=0; i < np; i++) {
    f=playerWorth[i]=new Field(players[i].getWorthModel(),true);
    addField(f,playerWorthXOffset + i,playerWorthYOffset,1,1,0);
  }
  addField(new Caption(""String_Node_Str""),0,playerCertCountYOffset,1,1,WIDE_RIGHT + WIDE_TOP);
  for (int i=0; i < np; i++) {
    f=playerCertCount[i]=new Field(players[i].getCertCountModel(),true);
    addField(f,playerCertCountXOffset + i,playerCertCountYOffset,1,1,WIDE_TOP);
  }
  for (int i=0; i < np; i++) {
    f=lowerPlayerCaption[i]=new Caption(players[i].getName());
    addField(f,i + 1,playerCertCountYOffset + 1,1,1,WIDE_TOP);
  }
  addField(new Caption(""String_Node_Str""),certLimitXOffset - 1,certLimitYOffset,1,1,WIDE_TOP + WIDE_LEFT);
  addField(new Field(""String_Node_Str"" + Player.getCertLimit()),certLimitXOffset,certLimitYOffset,1,1,WIDE_TOP);
  addField(new Caption(""String_Node_Str""),bankCashXOffset - 1,bankCashYOffset - 1,1,2,WIDE_TOP + WIDE_LEFT);
  addField(new Caption(""String_Node_Str""),bankCashXOffset,bankCashYOffset - 1,1,1,WIDE_TOP);
  bankCash=new Field(Bank.getInstance().getCashModel());
  addField(bankCash,bankCashXOffset,bankCashYOffset,1,1,0);
  addField(new Caption(""String_Node_Str""),poolTrainsXOffset,poolTrainsYOffset - 1,2,1,WIDE_TOP + WIDE_RIGHT);
  poolTrains=new Field(Bank.getPool().getTrainsModel().option(TrainsModel.FULL_LIST));
  addField(poolTrains,poolTrainsXOffset,poolTrainsYOffset,2,1,WIDE_RIGHT);
  addField(new Caption(""String_Node_Str""),newTrainsXOffset,newTrainsYOffset - 1,1,1,WIDE_TOP);
  newTrains=new Field(Bank.getIpo().getTrainsModel().option(TrainsModel.ABBR_LIST));
  addField(newTrains,newTrainsXOffset,newTrainsYOffset,1,1,0);
  dummyButton=new ClickField(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",this,buySellGroup);
  addField(new Caption(""String_Node_Str""),futureTrainsXOffset,futureTrainsYOffset - 1,3,1,WIDE_LEFT + WIDE_TOP);
  futureTrains=new Field(Bank.getUnavailable().getTrainsModel().option(TrainsModel.ABBR_LIST));
  addField(futureTrains,futureTrainsXOffset,futureTrainsYOffset,3,1,WIDE_LEFT);
  dummyButton=new ClickField(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",this,buySellGroup);
}",0.9488336617301214
173856,"public void layTile(MapHex hex,TileI tile,int orientation){
  if (!(round instanceof OperatingRound))   return;
  oRound=(OperatingRound)round;
  if (tile == null) {
    oRound.skip(orCompName);
  }
 else {
    if (oRound.layTile(orCompName,hex,tile,orientation)) {
      int cost=oRound.getLastTileLayCost();
      tileCost[orCompIndex].setText(cost > 0 ? Bank.format(cost) : ""String_Node_Str"");
      tiles[orCompIndex].setText(oRound.getLastTileLaid());
    }
 else {
      displayError();
    }
    button3.setEnabled(true);
  }
  LogWindow.addLog();
  if (oRound.getStep() != OperatingRound.STEP_LAY_TRACK) {
    this.requestFocus();
  }
  updateStatus();
}","public void layTile(MapHex hex,TileI tile,int orientation){
  if (!(round instanceof OperatingRound))   return;
  oRound=(OperatingRound)round;
  if (tile == null) {
    oRound.skip(orCompName);
  }
 else {
    int cost=oRound.getLastTileLayCost();
    tileCost[orCompIndex].setText(cost > 0 ? Bank.format(cost) : ""String_Node_Str"");
    tiles[orCompIndex].setText(oRound.getLastTileLaid());
    button3.setEnabled(true);
  }
  LogWindow.addLog();
  if (oRound.getStep() != OperatingRound.STEP_LAY_TRACK) {
    this.requestFocus();
  }
  updateStatus();
  return;
}",0.904645476772616
173857,"private void displayMessage(String text){
  JOptionPane.showMessageDialog(this,text);
}","public void displayMessage(String text){
  JOptionPane.showMessageDialog(this,text);
}",0.9479768786127168
173858,"private void displayError(){
  JOptionPane.showMessageDialog(this,Log.getErrorBuffer());
}","public void displayError(){
  JOptionPane.showMessageDialog(this,Log.getErrorBuffer());
}",0.9497206703910616
173859,"public void processDone(){
  HexMap map=mapPanel.getMap();
  GUIHex selectedHex=map.getSelectedHex();
  setSubStep(INACTIVE);
  if (baseTokenLayingEnabled) {
    if (selectedHex != null) {
      if (selectedHex.getHexModel().getStations().size() == 1) {
        selectedHex.fixToken(0);
        map.selectHex(null);
      }
 else {
        Object[] stations=selectedHex.getHexModel().getStations().toArray();
        Station station=(Station)JOptionPane.showInputDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,stations,stations[0]);
        try {
          selectedHex.fixToken(selectedHex.getHexModel().getStations().indexOf(station));
        }
 catch (        ArrayIndexOutOfBoundsException e) {
          Log.error(""String_Node_Str"");
        }
      }
    }
  }
 else {
    if (selectedHex != null) {
      selectedHex.fixTile(tileLayingEnabled);
      map.selectHex(null);
    }
  }
  updateUpgradePanel();
}","public void processDone(){
  HexMap map=mapPanel.getMap();
  GUIHex selectedHex=map.getSelectedHex();
  setSubStep(INACTIVE);
  if (baseTokenLayingEnabled) {
    if (selectedHex != null) {
      if (selectedHex.getHexModel().getStations().size() == 1) {
        selectedHex.fixToken(0);
        map.selectHex(null);
      }
 else {
        Object[] stations=selectedHex.getHexModel().getStations().toArray();
        Station station=(Station)JOptionPane.showInputDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,stations,stations[0]);
        try {
          selectedHex.fixToken(selectedHex.getHexModel().getStations().indexOf(station));
        }
 catch (        ArrayIndexOutOfBoundsException e) {
          Log.error(""String_Node_Str"");
        }
      }
    }
  }
 else {
    if (selectedHex != null) {
      if (!selectedHex.fixTile(tileLayingEnabled)) {
        selectedHex.removeTile();
      }
      map.selectHex(null);
    }
  }
  updateUpgradePanel();
}",0.9335394126738794
173860,"public void fixTile(boolean tileLayingEnabled){
  if (tileLayingEnabled) {
    currentGUITile=provisionalGUITile;
    if (currentGUITile != null) {
      currentTile=currentGUITile.getTile();
      currentTileId=currentTile.getId();
      currentTileOrientation=provisionalTileOrientation;
    }
    GameUILoader.orWindow.getORPanel().layTile(model,currentTile,currentTileOrientation);
  }
  setSelected(false);
  setToolTip();
}","public boolean fixTile(boolean tileLayingEnabled){
  boolean canFixTile=true;
  if (tileLayingEnabled && provisionalGUITile != null) {
    OperatingRound or=(OperatingRound)GameManager.getInstance().getCurrentRound();
    canFixTile=or.layTile(or.getOperatingCompany().getName(),model,provisionalGUITile.getTile(),provisionalTileOrientation);
    if (canFixTile) {
      currentGUITile=provisionalGUITile;
      if (currentGUITile != null) {
        currentTile=currentGUITile.getTile();
        currentTileId=currentTile.getId();
        currentTileOrientation=provisionalTileOrientation;
      }
      GameUILoader.orWindow.getORPanel().layTile(model,currentTile,currentTileOrientation);
    }
 else {
      GameUILoader.orWindow.getORPanel().displayError();
    }
  }
  setSelected(false);
  setToolTip();
  return canFixTile;
}",0.5571428571428572
173861,"/** 
 * A (perhaps temporary) method via which the cost of track laying can be accounted for.
 * @param companyName The name of the company that lays the track.
 * @param amountSpent The cost of laying the track, which is subtracted from the company treasury.
 */
public boolean layTile(String companyName,MapHex hex,TileI tile,int orientation){
  String errMsg=null;
  int cost=0;
  SpecialTileLay stl=null;
  while (true) {
    if (!companyName.equals(operatingCompany.getName())) {
      errMsg=""String_Node_Str"" + companyName + ""String_Node_Str""+ operatingCompany.getName()+ ""String_Node_Str"";
      break;
    }
    if (step != STEP_LAY_TRACK) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (tile == null)     break;
    if (!tile.isLayableNow()) {
      errMsg=""String_Node_Str"" + tile.getName() + ""String_Node_Str"";
      break;
    }
    if (tile.countFreeTiles() == 0) {
      errMsg=""String_Node_Str"" + tile.getName() + ""String_Node_Str"";
      break;
    }
    if (currentSpecialProperties != null) {
      stl=(SpecialTileLay)checkForUseOfSpecialProperty(hex);
      if (stl == null && normalTileLaysDone >= normalTileLaysAllowed) {
        errMsg=""String_Node_Str"";
        break;
      }
    }
    if (hex.getCurrentTile().getId() == hex.getPreprintedTileId()) {
      cost=hex.getTileCost();
    }
 else {
      cost=0;
    }
    if (cost < 0) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (cost % 10 != 0) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (cost > operatingCompany.getCash()) {
      errMsg=""String_Node_Str"";
      break;
    }
    break;
  }
  if (errMsg != null) {
    Log.error(""String_Node_Str"" + errMsg);
    return false;
  }
  if (tile != null) {
    hex.upgrade(tile,orientation);
    if (cost > 0)     Bank.transferCash((CashHolder)operatingCompany,null,cost);
    tileLayCost[operatingCompanyIndex]=cost;
    tilesLaid[operatingCompanyIndex]=Util.appendWithComma(tilesLaid[operatingCompanyIndex],""String_Node_Str"" + tile.getName() + ""String_Node_Str""+ hex.getName()+ ""String_Node_Str""+ MapHex.getOrientationName(orientation));
    Log.write(operatingCompany.getName() + ""String_Node_Str"" + tile.getName()+ ""String_Node_Str""+ hex.getName()+ (cost > 0 ? ""String_Node_Str"" + Bank.format(cost) : ""String_Node_Str""));
    if (stl != null) {
      stl.setExercised();
      if (stl.isExtra())       extraTileLaysDone++;
 else       normalTileLaysDone++;
      currentSpecialProperties=operatingCompany.getPortfolio().getSpecialProperties(game.special.SpecialTileLay.class);
    }
 else {
      normalTileLaysDone++;
    }
  }
  if (tile == null || normalTileLaysDone >= normalTileLaysAllowed && extraTileLaysDone >= extraTileLaysAllowed) {
    nextStep(operatingCompany);
  }
  return true;
}","/** 
 * A (perhaps temporary) method via which the cost of track laying can be accounted for.
 * @param companyName The name of the company that lays the track.
 * @param amountSpent The cost of laying the track, which is subtracted from the company treasury.
 */
public boolean layTile(String companyName,MapHex hex,TileI tile,int orientation){
  String errMsg=null;
  int cost=0;
  SpecialTileLay stl=null;
  while (true) {
    if (!companyName.equals(operatingCompany.getName())) {
      errMsg=""String_Node_Str"" + companyName + ""String_Node_Str""+ operatingCompany.getName()+ ""String_Node_Str"";
      break;
    }
    if (step != STEP_LAY_TRACK) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (tile == null)     break;
    if (!tile.isLayableNow()) {
      errMsg=""String_Node_Str"" + tile.getName() + ""String_Node_Str"";
      break;
    }
    if (tile.countFreeTiles() == 0) {
      errMsg=""String_Node_Str"" + tile.getName() + ""String_Node_Str"";
      break;
    }
    if (currentSpecialProperties != null) {
      stl=(SpecialTileLay)checkForUseOfSpecialProperty(hex);
      if (stl == null && normalTileLaysDone >= normalTileLaysAllowed) {
        errMsg=""String_Node_Str"";
        break;
      }
    }
    if (hex.getCurrentTile().getId() == hex.getPreprintedTileId()) {
      cost=hex.getTileCost();
    }
 else {
      cost=0;
    }
    if (cost < 0) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (cost % 10 != 0) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (cost > operatingCompany.getCash()) {
      errMsg=""String_Node_Str"";
      break;
    }
    break;
  }
  if (errMsg != null) {
    Log.error(""String_Node_Str"" + hex.getName() + ""String_Node_Str""+ Bank.format(cost)+ ""String_Node_Str""+ errMsg);
    return false;
  }
  if (tile != null) {
    hex.upgrade(tile,orientation);
    if (cost > 0)     Bank.transferCash((CashHolder)operatingCompany,null,cost);
    tileLayCost[operatingCompanyIndex]=cost;
    tilesLaid[operatingCompanyIndex]=Util.appendWithComma(tilesLaid[operatingCompanyIndex],""String_Node_Str"" + tile.getName() + ""String_Node_Str""+ hex.getName()+ ""String_Node_Str""+ MapHex.getOrientationName(orientation));
    Log.write(operatingCompany.getName() + ""String_Node_Str"" + tile.getName()+ ""String_Node_Str""+ hex.getName()+ (cost > 0 ? ""String_Node_Str"" + Bank.format(cost) : ""String_Node_Str""));
    if (stl != null) {
      stl.setExercised();
      if (stl.isExtra())       extraTileLaysDone++;
 else       normalTileLaysDone++;
      currentSpecialProperties=operatingCompany.getPortfolio().getSpecialProperties(game.special.SpecialTileLay.class);
    }
 else {
      normalTileLaysDone++;
    }
  }
  if (tile == null || normalTileLaysDone >= normalTileLaysAllowed && extraTileLaysDone >= extraTileLaysAllowed) {
    nextStep(operatingCompany);
  }
  return true;
}",0.9869759143621766
173862,"public void layBaseToken(MapHex hex,int station){
  if (!(round instanceof OperatingRound))   return;
  oRound=(OperatingRound)round;
  if (hex == null) {
    oRound.skip(orCompName);
  }
 else   if (oRound.layBaseToken(orCompName,hex,station)) {
    int cost=oRound.getLastBaseTokenLayCost();
    tokenCost[orCompIndex].setText(cost > 0 ? Bank.format(cost) : ""String_Node_Str"");
    tokens[orCompIndex].setText(oRound.getLastBaseTokenLaid());
  }
 else {
    displayError();
  }
  button3.setEnabled(true);
  LogWindow.addLog();
  if (oRound.getStep() != OperatingRound.STEP_LAY_TOKEN) {
    GameUILoader.orWindow.enableBaseTokenLaying(false);
    this.requestFocus();
  }
  updateStatus();
}","public void layBaseToken(MapHex hex,int station){
  if (!(round instanceof OperatingRound))   return;
  oRound=(OperatingRound)round;
  if (hex == null) {
    oRound.skip(orCompName);
  }
 else {
    int cost=oRound.getLastBaseTokenLayCost();
    tokenCost[orCompIndex].setText(cost > 0 ? Bank.format(cost) : ""String_Node_Str"");
    tokens[orCompIndex].setText(oRound.getLastBaseTokenLaid());
  }
  button3.setEnabled(true);
  LogWindow.addLog();
  if (oRound.getStep() != OperatingRound.STEP_LAY_TOKEN) {
    GameUILoader.orWindow.enableBaseTokenLaying(false);
    this.requestFocus();
  }
  updateStatus();
}",0.9363008442056792
173863,"public void processDone(){
  HexMap map=mapPanel.getMap();
  GUIHex selectedHex=map.getSelectedHex();
  setSubStep(INACTIVE);
  if (baseTokenLayingEnabled) {
    if (selectedHex != null) {
      if (selectedHex.getHexModel().getStations().size() == 1) {
        selectedHex.fixToken(0);
        map.selectHex(null);
      }
 else {
        Object[] stations=selectedHex.getHexModel().getStations().toArray();
        Station station=(Station)JOptionPane.showInputDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,stations,stations[0]);
        try {
          selectedHex.fixToken(selectedHex.getHexModel().getStations().indexOf(station));
        }
 catch (        ArrayIndexOutOfBoundsException e) {
          Log.error(""String_Node_Str"");
        }
      }
    }
  }
 else {
    if (selectedHex != null) {
      if (!selectedHex.fixTile(tileLayingEnabled)) {
        selectedHex.removeTile();
      }
      map.selectHex(null);
    }
  }
  updateUpgradePanel();
}","public void processDone(){
  HexMap map=mapPanel.getMap();
  GUIHex selectedHex=map.getSelectedHex();
  if (baseTokenLayingEnabled) {
    if (selectedHex != null) {
      if (selectedHex.getHexModel().getStations().size() == 1) {
        if (selectedHex.fixToken(0)) {
        }
 else {
          setSubStep(SELECT_HEX_FOR_TOKEN);
        }
        map.selectHex(null);
      }
 else {
        Object[] stations=selectedHex.getHexModel().getStations().toArray();
        Station station=(Station)JOptionPane.showInputDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,stations,stations[0]);
        try {
          if (selectedHex.fixToken(selectedHex.getHexModel().getStations().indexOf(station))) {
          }
 else {
            setSubStep(SELECT_HEX_FOR_TOKEN);
          }
        }
 catch (        ArrayIndexOutOfBoundsException e) {
          Log.error(""String_Node_Str"");
        }
      }
    }
  }
 else {
    if (selectedHex != null) {
      if (!selectedHex.fixTile(tileLayingEnabled)) {
        selectedHex.removeTile();
        setSubStep(SELECT_HEX_FOR_TILE);
      }
 else {
      }
      map.selectHex(null);
    }
  }
  updateUpgradePanel();
}",0.751487414187643
173864,"public void fixToken(int station){
  GameUILoader.orWindow.getORPanel().layBaseToken(model,station);
  setSelected(false);
}","public boolean fixToken(int station){
  OperatingRound or=(OperatingRound)GameManager.getInstance().getCurrentRound();
  boolean canFixToken=or.layBaseToken(or.getOperatingCompany().getName(),model,station);
  if (canFixToken) {
    GameUILoader.orWindow.getORPanel().layBaseToken(model,station);
  }
 else {
    GameUILoader.orWindow.getORPanel().displayError();
  }
  setSelected(false);
  return canFixToken;
}",0.4469273743016759
173865,"public void mouseClicked(MouseEvent arg0){
  Point point=arg0.getPoint();
  GUIHex clickedHex=getHexContainingPoint(point);
  if (ORWindow.baseTokenLayingEnabled) {
    selectHex(clickedHex);
    if (selectedHex != null) {
      GameUILoader.orWindow.setSubStep(ORWindow.CONFIRM_TOKEN);
    }
 else {
      GameUILoader.orWindow.setSubStep(ORWindow.SELECT_HEX_FOR_TOKEN);
    }
  }
 else   if (ORWindow.tileLayingEnabled) {
    if (GameUILoader.orWindow.getSubStep() == ORWindow.ROTATE_OR_CONFIRM_TILE && clickedHex == selectedHex) {
      selectedHex.rotateTile();
      repaint(selectedHex.getBounds());
    }
 else {
      if (selectedHex != null && clickedHex != selectedHex) {
        selectedHex.removeTile();
        selectHex(null);
      }
      if (clickedHex != null) {
        if (clickedHex.getHexModel().isUpgradeableNow()) {
          selectHex(clickedHex);
          GameUILoader.orWindow.setSubStep(ORWindow.SELECT_TILE);
        }
 else {
          JOptionPane.showMessageDialog(this,""String_Node_Str"");
        }
      }
    }
  }
  GameUILoader.orWindow.updateUpgradePanel();
  GameUILoader.orWindow.updateORPanel();
}","public void mouseClicked(MouseEvent arg0){
  Point point=arg0.getPoint();
  GUIHex clickedHex=getHexContainingPoint(point);
  if (ORWindow.baseTokenLayingEnabled) {
    selectHex(clickedHex);
    if (selectedHex != null) {
      GameUILoader.orWindow.setSubStep(ORWindow.CONFIRM_TOKEN);
    }
 else {
      GameUILoader.orWindow.setSubStep(ORWindow.SELECT_HEX_FOR_TOKEN);
    }
  }
 else   if (ORWindow.tileLayingEnabled) {
    if (GameUILoader.orWindow.getSubStep() == ORWindow.ROTATE_OR_CONFIRM_TILE && clickedHex == selectedHex) {
      selectedHex.rotateTile();
      repaint(selectedHex.getBounds());
      return;
    }
 else {
      if (selectedHex != null && clickedHex != selectedHex) {
        selectedHex.removeTile();
        selectHex(null);
      }
      if (clickedHex != null) {
        if (clickedHex.getHexModel().isUpgradeableNow()) {
          selectHex(clickedHex);
          GameUILoader.orWindow.setSubStep(ORWindow.SELECT_TILE);
        }
 else {
          JOptionPane.showMessageDialog(this,""String_Node_Str"");
        }
      }
    }
  }
  GameUILoader.orWindow.updateUpgradePanel();
  GameUILoader.orWindow.updateORPanel();
}",0.993886462882096
173866,"public void windowClosing(WindowEvent e){
  StatusWindow.uncheckMenuItemBox(StatusWindow.MAP);
  dispose();
}","public void windowClosing(WindowEvent e){
  StatusWindow.uncheckMenuItemBox(StatusWindow.MAP);
  parent.setOrWindow(null);
  dispose();
}",0.8861788617886179
173867,"public ORWindow(OperatingRound round,StatusWindow parent){
  super();
  getContentPane().setLayout(new BorderLayout());
  if (round != null) {
    mapPanel=GameUILoader.mapPanel;
    upgradePanel=new UpgradesPanel(mapPanel.getMap());
    getContentPane().add(upgradePanel,BorderLayout.WEST);
    mapPanel.setUpgradesPanel(upgradePanel);
    mapPanel.getMap().setUpgradesPanel(upgradePanel);
    ORPanel=new ORPanel(round,parent,this);
    getContentPane().add(ORPanel,BorderLayout.SOUTH);
    setSize(800,750);
  }
 else   if (OperatingRound.getLastORNumber() > 0) {
    mapPanel=GameUILoader.mapPanel;
    setSize(mapPanel.getSize());
    mapPanel.setVisible(true);
  }
 else {
    mapPanel=new MapPanel();
    setSize(mapPanel.getSize());
  }
  getContentPane().add(mapPanel,BorderLayout.CENTER);
  setTitle(""String_Node_Str"");
  setLocation(10,10);
  setVisible(true);
  addWindowListener(this);
  LogWindow.addLog();
}","public ORWindow(OperatingRound round,StatusWindow parent){
  super();
  getContentPane().setLayout(new BorderLayout());
  this.parent=parent;
  if (round != null) {
    mapPanel=GameUILoader.mapPanel;
    upgradePanel=new UpgradesPanel(mapPanel.getMap());
    getContentPane().add(upgradePanel,BorderLayout.WEST);
    mapPanel.setUpgradesPanel(upgradePanel);
    mapPanel.getMap().setUpgradesPanel(upgradePanel);
    ORPanel=new ORPanel(round,parent,this);
    getContentPane().add(ORPanel,BorderLayout.SOUTH);
    setSize(800,750);
  }
 else   if (OperatingRound.getLastORNumber() > 0) {
    mapPanel=GameUILoader.mapPanel;
    setSize(mapPanel.getSize());
    mapPanel.setVisible(true);
  }
 else {
    mapPanel=new MapPanel();
    setSize(mapPanel.getSize());
  }
  getContentPane().add(mapPanel,BorderLayout.CENTER);
  setTitle(""String_Node_Str"");
  setLocation(10,10);
  setVisible(true);
  addWindowListener(this);
  LogWindow.addLog();
}",0.9882100750267953
173868,"public void upgrade(TileI newTile,int newOrientation){
  if (currentTile != null)   currentTile.remove(this);
  newTile.lay(this);
  if (hasTokens)   moveTokens(newTile);
  currentTile=newTile;
  currentTileRotation=newOrientation;
}","public void upgrade(TileI newTile,int newOrientation){
  if (currentTile != null)   currentTile.remove(this);
  newTile.lay(this);
  moveTokens(newTile);
  currentTile=newTile;
  currentTileRotation=newOrientation;
}",0.9220489977728286
173869,"public void actionPerformed(ActionEvent actor){
  int returnVal=0;
  player=GameManager.getCurrentPlayer();
  if (actor.getActionCommand().equalsIgnoreCase(""String_Node_Str"")) {
    buyButtonClicked();
    passButton.setText(""String_Node_Str"");
    passButton.setMnemonic(KeyEvent.VK_D);
  }
 else   if (actor.getActionCommand().equalsIgnoreCase(""String_Node_Str"")) {
    sellButtonClicked();
    passButton.setText(""String_Node_Str"");
    passButton.setMnemonic(KeyEvent.VK_D);
  }
 else   if (actor.getActionCommand().equalsIgnoreCase(""String_Node_Str"")) {
    stockRound.done(gameStatus.getSRPlayer());
    passButton.setText(""String_Node_Str"");
    passButton.setMnemonic(KeyEvent.VK_P);
  }
  try {
    JMenuItem menuItem=(JMenuItem)actor.getSource();
    if (menuItem.getText().equalsIgnoreCase(""String_Node_Str""))     System.exit(0);
    if (menuItem.getText().equalsIgnoreCase(""String_Node_Str""))     returnVal=new JFileChooser().showSaveDialog(this);
    if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && menuItem.isSelected())     GameUILoader.messageWindow.setVisible(true);
 else     if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && !menuItem.isSelected())     GameUILoader.messageWindow.setVisible(false);
    if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && menuItem.isSelected())     GameUILoader.stockChart.setVisible(true);
 else     if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && !menuItem.isSelected())     GameUILoader.stockChart.setVisible(false);
    if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && menuItem.isSelected())     orWindow=new ORWindow(null,this);
 else     if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && !menuItem.isSelected()) {
      orWindow.dispose();
      orWindow=null;
    }
  }
 catch (  ClassCastException e) {
  }
  LogWindow.addLog();
  pack();
  currentRound=GameManager.getInstance().getCurrentRound();
  if (currentRound instanceof StockRound)   gameStatus.setSRPlayerTurn(GameManager.getCurrentPlayerIndex());
 else   if (currentRound instanceof OperatingRound) {
    gameStatus.setSRPlayerTurn(-1);
    updateStatus();
  }
}","public void actionPerformed(ActionEvent actor){
  int returnVal=0;
  player=GameManager.getCurrentPlayer();
  if (actor.getActionCommand().equalsIgnoreCase(BUY)) {
    buyButtonClicked();
    passButton.setText(DONE);
    passButton.setMnemonic(KeyEvent.VK_D);
  }
 else   if (actor.getActionCommand().equalsIgnoreCase(SELL)) {
    sellButtonClicked();
    passButton.setText(DONE);
    passButton.setMnemonic(KeyEvent.VK_D);
  }
 else   if (actor.getActionCommand().equalsIgnoreCase(DONE)) {
    stockRound.done(gameStatus.getSRPlayer());
    passButton.setText(PASS);
    passButton.setMnemonic(KeyEvent.VK_P);
  }
 else   if (actor.getActionCommand().equalsIgnoreCase(QUIT))   System.exit(0);
 else   if (actor.getActionCommand().equalsIgnoreCase(SAVE))   returnVal=new JFileChooser().showSaveDialog(this);
 else   if (actor.getActionCommand().equalsIgnoreCase(LOG) && ((JMenuItem)actor.getSource()).isSelected()) {
    GameUILoader.messageWindow.setVisible(true);
    return;
  }
 else   if (actor.getActionCommand().equalsIgnoreCase(LOG) && !((JMenuItem)actor.getSource()).isSelected()) {
    GameUILoader.messageWindow.setVisible(false);
    return;
  }
 else   if (actor.getActionCommand().equalsIgnoreCase(MARKET) && ((JMenuItem)actor.getSource()).isSelected()) {
    GameUILoader.stockChart.setVisible(true);
    return;
  }
 else   if (actor.getActionCommand().equalsIgnoreCase(MARKET) && !((JMenuItem)actor.getSource()).isSelected()) {
    GameUILoader.stockChart.setVisible(false);
    return;
  }
 else   if (actor.getActionCommand().equalsIgnoreCase(MAP) && ((JMenuItem)actor.getSource()).isSelected()) {
    orWindow=new ORWindow(null,this);
    return;
  }
 else   if (actor.getActionCommand().equalsIgnoreCase(MAP) && !((JMenuItem)actor.getSource()).isSelected()) {
    orWindow.dispose();
    orWindow=null;
    return;
  }
  LogWindow.addLog();
  pack();
  currentRound=GameManager.getInstance().getCurrentRound();
  if (currentRound instanceof StockRound)   gameStatus.setSRPlayerTurn(GameManager.getCurrentPlayerIndex());
 else   if (currentRound instanceof OperatingRound) {
    gameStatus.setSRPlayerTurn(-1);
    updateStatus();
  }
}",0.541241890639481
173870,"public void initMenu(){
  menuBar=new JMenuBar();
  fileMenu=new JMenu(""String_Node_Str"");
  optMenu=new JMenu(""String_Node_Str"");
  fileMenu.setMnemonic(KeyEvent.VK_F);
  optMenu.setMnemonic(KeyEvent.VK_O);
  menuItem=new JMenuItem(""String_Node_Str"");
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_S);
  menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,ActionEvent.ALT_MASK));
  menuItem.addActionListener(this);
  fileMenu.add(menuItem);
  fileMenu.addSeparator();
  menuItem=new JMenuItem(""String_Node_Str"");
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_Q);
  menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q,ActionEvent.ALT_MASK));
  menuItem.addActionListener(this);
  fileMenu.add(menuItem);
  menuBar.add(fileMenu);
  menuItem=new JMenuItem(""String_Node_Str"");
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_S);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  optMenu.addSeparator();
  menuItem=new JCheckBoxMenuItem(MARKET);
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_K);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  menuItem=new JCheckBoxMenuItem(MAP);
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_M);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  menuItem=new JCheckBoxMenuItem(LOG);
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_L);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  menuBar.add(optMenu);
  setJMenuBar(menuBar);
}","public void initMenu(){
  menuBar=new JMenuBar();
  fileMenu=new JMenu(""String_Node_Str"");
  optMenu=new JMenu(""String_Node_Str"");
  fileMenu.setMnemonic(KeyEvent.VK_F);
  optMenu.setMnemonic(KeyEvent.VK_O);
  menuItem=new JMenuItem(SAVE);
  menuItem.setName(SAVE);
  menuItem.setActionCommand(SAVE);
  menuItem.setMnemonic(KeyEvent.VK_S);
  menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,ActionEvent.ALT_MASK));
  menuItem.addActionListener(this);
  fileMenu.add(menuItem);
  fileMenu.addSeparator();
  menuItem=new JMenuItem(QUIT);
  menuItem.setName(QUIT);
  menuItem.setActionCommand(QUIT);
  menuItem.setMnemonic(KeyEvent.VK_Q);
  menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q,ActionEvent.ALT_MASK));
  menuItem.addActionListener(this);
  fileMenu.add(menuItem);
  menuBar.add(fileMenu);
  menuItem=new JMenuItem(""String_Node_Str"");
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_S);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  optMenu.addSeparator();
  menuItem=new JCheckBoxMenuItem(MARKET);
  menuItem.setName(MARKET);
  menuItem.setActionCommand(MARKET);
  menuItem.setMnemonic(KeyEvent.VK_K);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  menuItem=new JCheckBoxMenuItem(MAP);
  menuItem.setName(MAP);
  menuItem.setActionCommand(MAP);
  menuItem.setMnemonic(KeyEvent.VK_M);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  menuItem=new JCheckBoxMenuItem(LOG);
  menuItem.setName(LOG);
  menuItem.setActionCommand(LOG);
  menuItem.setMnemonic(KeyEvent.VK_L);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  menuBar.add(optMenu);
  setJMenuBar(menuBar);
}",0.8763702801461632
173871,"public StatusWindow(){
  cm=Game.getCompanyManager();
  companies=(PublicCompanyI[])cm.getAllPublicCompanies().toArray(new PublicCompanyI[0]);
  ipo=Bank.getIpo();
  pool=Bank.getPool();
  gameStatus=new GameStatus(this);
  buttonPanel=new JPanel();
  buyButton=new JButton(""String_Node_Str"");
  sellButton=new JButton(""String_Node_Str"");
  passButton=new JButton(""String_Node_Str"");
  buyButton.setMnemonic(KeyEvent.VK_B);
  sellButton.setMnemonic(KeyEvent.VK_S);
  passButton.setMnemonic(KeyEvent.VK_P);
  buttonPanel.add(buyButton);
  buttonPanel.add(sellButton);
  buttonPanel.add(passButton);
  buyButton.setActionCommand(""String_Node_Str"");
  sellButton.setActionCommand(""String_Node_Str"");
  passButton.setActionCommand(""String_Node_Str"");
  buyButton.addActionListener(this);
  sellButton.addActionListener(this);
  passButton.addActionListener(this);
  setSize(800,300);
  setLocation(25,450);
  buttonPanel.setBorder(BorderFactory.createEtchedBorder());
  buttonPanel.setOpaque(false);
  setTitle(""String_Node_Str"");
  pane.setLayout(new BorderLayout());
  init();
  initMenu();
  pane.add(gameStatus,BorderLayout.NORTH);
  pane.add(buttonPanel,BorderLayout.CENTER);
  pane.setOpaque(true);
  setContentPane(pane);
  refreshStatus();
  setVisible(true);
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  gmgr=GameManager.getInstance();
  currentRound=gmgr.getCurrentRound();
  updateStatus();
  pack();
  gameStatus.addKeyListener(this);
  buttonPanel.addKeyListener(this);
  addKeyListener(this);
}","public StatusWindow(){
  cm=Game.getCompanyManager();
  companies=(PublicCompanyI[])cm.getAllPublicCompanies().toArray(new PublicCompanyI[0]);
  ipo=Bank.getIpo();
  pool=Bank.getPool();
  gameStatus=new GameStatus(this);
  buttonPanel=new JPanel();
  buyButton=new JButton(BUY);
  sellButton=new JButton(SELL);
  passButton=new JButton(PASS);
  buyButton.setMnemonic(KeyEvent.VK_B);
  sellButton.setMnemonic(KeyEvent.VK_S);
  passButton.setMnemonic(KeyEvent.VK_P);
  buttonPanel.add(buyButton);
  buttonPanel.add(sellButton);
  buttonPanel.add(passButton);
  buyButton.setActionCommand(BUY);
  sellButton.setActionCommand(SELL);
  passButton.setActionCommand(DONE);
  buyButton.addActionListener(this);
  sellButton.addActionListener(this);
  passButton.addActionListener(this);
  setSize(800,300);
  setLocation(25,450);
  buttonPanel.setBorder(BorderFactory.createEtchedBorder());
  buttonPanel.setOpaque(false);
  setTitle(""String_Node_Str"");
  pane.setLayout(new BorderLayout());
  init();
  initMenu();
  pane.add(gameStatus,BorderLayout.NORTH);
  pane.add(buttonPanel,BorderLayout.CENTER);
  pane.setOpaque(true);
  setContentPane(pane);
  refreshStatus();
  setVisible(true);
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  gmgr=GameManager.getInstance();
  currentRound=gmgr.getCurrentRound();
  updateStatus();
  pack();
  gameStatus.addKeyListener(this);
  buttonPanel.addKeyListener(this);
  addKeyListener(this);
}",0.9136641740312712
173872,"public void updateStatus(){
  if (currentRound instanceof StartRound) {
    passButton.setEnabled(false);
    startRound=(StartRound)currentRound;
    if (startRoundWindow == null)     startRoundWindow=new StartRoundWindow(startRound,this);
    startRoundWindow.setSRPlayerTurn(startRound.getCurrentPlayerIndex());
    GameUILoader.stockChart.setVisible(false);
    GameUILoader.mapPanel.setVisible(false);
  }
 else   if (currentRound instanceof StockRound) {
    passButton.setEnabled(true);
    stockRound=(StockRound)currentRound;
    gameStatus.setSRPlayerTurn(GameManager.getCurrentPlayerIndex());
    GameUILoader.stockChart.setVisible(true);
    GameUILoader.mapPanel.setVisible(false);
    enableCheckBoxMenuItem(""String_Node_Str"");
    disableCheckBoxMenuItem(""String_Node_Str"");
    refreshStatus();
    toFront();
  }
 else   if (currentRound instanceof OperatingRound) {
    passButton.setEnabled(false);
    operatingRound=(OperatingRound)currentRound;
    if (orWindow == null)     orWindow=new ORWindow(operatingRound,this);
    GameUILoader.stockChart.setVisible(false);
    GameUILoader.mapPanel.setVisible(true);
    orWindow.requestFocus();
    enableCheckBoxMenuItem(""String_Node_Str"");
    disableCheckBoxMenuItem(""String_Node_Str"");
  }
}","public void updateStatus(){
  if (currentRound instanceof StartRound) {
    passButton.setEnabled(false);
    startRound=(StartRound)currentRound;
    if (startRoundWindow == null)     startRoundWindow=new StartRoundWindow(startRound,this);
    startRoundWindow.setSRPlayerTurn(startRound.getCurrentPlayerIndex());
    GameUILoader.stockChart.setVisible(false);
    GameUILoader.mapPanel.setVisible(false);
    disableCheckBoxMenuItem(MAP);
    disableCheckBoxMenuItem(MARKET);
  }
 else   if (currentRound instanceof StockRound) {
    passButton.setEnabled(true);
    stockRound=(StockRound)currentRound;
    gameStatus.setSRPlayerTurn(GameManager.getCurrentPlayerIndex());
    GameUILoader.stockChart.setVisible(true);
    GameUILoader.mapPanel.setVisible(false);
    enableCheckBoxMenuItem(MARKET);
    disableCheckBoxMenuItem(MAP);
    refreshStatus();
    toFront();
  }
 else   if (currentRound instanceof OperatingRound) {
    passButton.setEnabled(false);
    operatingRound=(OperatingRound)currentRound;
    if (orWindow == null)     orWindow=new ORWindow(operatingRound,this);
    GameUILoader.stockChart.setVisible(false);
    GameUILoader.mapPanel.setVisible(true);
    orWindow.requestFocus();
    enableCheckBoxMenuItem(MAP);
    disableCheckBoxMenuItem(MARKET);
  }
}",0.9382618953991348
173873,"public MapPanel(){
  Scale.set(15);
  setLayout(new BorderLayout());
  mmgr=MapManager.getInstance();
  try {
    map=(HexMap)Class.forName(mmgr.getMapUIClassName()).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  addMouseListener(map);
  addMouseMotionListener(map);
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  scrollPane=new JScrollPane(map);
  scrollPane.setSize(map.getPreferredSize());
  scrollPane.addMouseListener(map);
  add(scrollPane,BorderLayout.CENTER);
  setSize(map.getPreferredSize().width,map.getPreferredSize().height);
  setLocation(25,25);
}","public MapPanel(){
  Scale.set(15);
  setLayout(new BorderLayout());
  mmgr=MapManager.getInstance();
  try {
    map=(HexMap)Class.forName(mmgr.getMapUIClassName()).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  addMouseListener(map);
  addMouseMotionListener(map);
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  scrollPane=new JScrollPane(map);
  scrollPane.setSize(map.getPreferredSize());
  scrollPane.getViewport().addMouseListener(map);
  add(scrollPane,BorderLayout.CENTER);
  setSize(map.getPreferredSize().width,map.getPreferredSize().height);
  setLocation(25,25);
}",0.9896449704142012
173874,"public void configureFromXML(Element el) throws ConfigurationException {
  NamedNodeMap attributes;
  String colourList;
  String[] colourArray=new String[0];
  tileColours=new HashMap();
  NodeList nl=el.getElementsByTagName(""String_Node_Str"");
  if (nl != null && nl.getLength() > 0) {
    attributes=nl.item(0).getAttributes();
    colourList=XmlUtils.extractStringAttribute(attributes,""String_Node_Str"");
    if (colourList != null)     colourArray=colourList.split(""String_Node_Str"");
    for (int i=0; i < colourArray.length; i++) {
      tileColours.put(colourArray[i],null);
    }
  }
  nl=el.getElementsByTagName(""String_Node_Str"");
  if (nl != null && nl.getLength() > 0) {
    attributes=nl.item(0).getAttributes();
    privateSellingAllowed=previousPrivateSellingAllowed=XmlUtils.extractBooleanAttribute(attributes,""String_Node_Str"",previousPrivateSellingAllowed);
    privatesClose=XmlUtils.extractBooleanAttribute(attributes,""String_Node_Str"",false);
  }
  nl=el.getElementsByTagName(""String_Node_Str"");
  if (nl != null && nl.getLength() > 0) {
    attributes=nl.item(0).getAttributes();
    numberOfOperatingRounds=previousNumberOfOperatingRounds=XmlUtils.extractIntegerAttribute(attributes,""String_Node_Str"",previousNumberOfOperatingRounds);
  }
}","public void configureFromXML(Element el) throws ConfigurationException {
  NamedNodeMap attributes;
  String colourList;
  String[] colourArray=new String[0];
  tileColours=new HashMap();
  NodeList nl=el.getElementsByTagName(""String_Node_Str"");
  if (nl != null && nl.getLength() > 0) {
    attributes=nl.item(0).getAttributes();
    colourList=XmlUtils.extractStringAttribute(attributes,""String_Node_Str"",previousTileColours);
  }
 else {
    colourList=previousTileColours;
  }
  if (colourList != null)   colourArray=colourList.split(""String_Node_Str"");
  for (int i=0; i < colourArray.length; i++) {
    tileColours.put(colourArray[i],null);
  }
  nl=el.getElementsByTagName(""String_Node_Str"");
  if (nl != null && nl.getLength() > 0) {
    attributes=nl.item(0).getAttributes();
    privateSellingAllowed=previousPrivateSellingAllowed=XmlUtils.extractBooleanAttribute(attributes,""String_Node_Str"",previousPrivateSellingAllowed);
    privatesClose=XmlUtils.extractBooleanAttribute(attributes,""String_Node_Str"",false);
  }
 else {
    privateSellingAllowed=previousPrivateSellingAllowed;
  }
  nl=el.getElementsByTagName(""String_Node_Str"");
  if (nl != null && nl.getLength() > 0) {
    attributes=nl.item(0).getAttributes();
    numberOfOperatingRounds=previousNumberOfOperatingRounds=XmlUtils.extractIntegerAttribute(attributes,""String_Node_Str"",previousNumberOfOperatingRounds);
  }
 else {
    numberOfOperatingRounds=previousNumberOfOperatingRounds;
  }
  System.out.println(""String_Node_Str"" + index + ""String_Node_Str""+ name+ ""String_Node_Str""+ numberOfOperatingRounds+ ""String_Node_Str"");
}",0.8702023726448012
173875,"/** 
 * A (perhaps temporary) method via which the cost of station token laying can be accounted for.
 * @param companyName The name of the company that lays the token.
 * @param amountSpent The cost of laying the token, which is subtracted from the company treasury.
 * @return
 */
public boolean layBaseToken(String companyName,MapHex hex,int station){
  String errMsg=null;
  int cost=0;
  while (true) {
    if (!companyName.equals(operatingCompany.getName())) {
      errMsg=""String_Node_Str"" + companyName;
      break;
    }
    if (step != STEP_LAY_TOKEN) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (!operatingCompany.hasTokens()) {
      errMsg=""String_Node_Str"";
      break;
    }
    cost=Game.getCompanyManager().getBaseTokenLayCostBySequence(operatingCompany.getNextBaseTokenIndex());
    if (cost > operatingCompany.getCash()) {
      errMsg=""String_Node_Str"";
      break;
    }
    break;
  }
  if (errMsg != null) {
    Log.error(""String_Node_Str"" + hex.getName() + ""String_Node_Str""+ Bank.format(cost)+ ""String_Node_Str""+ errMsg);
    return false;
  }
  if (!operatingCompany.layBaseToken(hex))   return false;
  lastBaseTokenLaid=hex.getName();
  lastBaseTokenLayCost=cost;
  if (cost > 0) {
    Bank.transferCash((CashHolder)operatingCompany,null,cost);
    Log.write(companyName + ""String_Node_Str"" + hex.getName()+ ""String_Node_Str""+ Bank.format(cost));
  }
 else {
    Log.write(companyName + ""String_Node_Str"" + hex.getName());
  }
  nextStep(operatingCompany);
  return true;
}","/** 
 * A (perhaps temporary) method via which the cost of station token laying can be accounted for.
 * @param companyName The name of the company that lays the token.
 * @param amountSpent The cost of laying the token, which is subtracted from the company treasury.
 * @return
 */
public boolean layBaseToken(String companyName,MapHex hex,int station){
  String errMsg=null;
  int cost=0;
  while (true) {
    if (!companyName.equals(operatingCompany.getName())) {
      errMsg=""String_Node_Str"" + companyName;
      break;
    }
    if (step != STEP_LAY_TOKEN) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (!operatingCompany.hasTokens()) {
      errMsg=""String_Node_Str"";
      break;
    }
    cost=Game.getCompanyManager().getBaseTokenLayCostBySequence(operatingCompany.getNextBaseTokenIndex());
    if (cost > operatingCompany.getCash()) {
      errMsg=""String_Node_Str"";
      break;
    }
    break;
  }
  if (errMsg != null) {
    Log.error(""String_Node_Str"" + hex.getName() + ""String_Node_Str""+ Bank.format(cost)+ ""String_Node_Str""+ errMsg);
    return false;
  }
  if (!operatingCompany.layBaseToken(hex,station))   return false;
  lastBaseTokenLaid=hex.getName();
  lastBaseTokenLayCost=cost;
  if (cost > 0) {
    Bank.transferCash((CashHolder)operatingCompany,null,cost);
    Log.write(companyName + ""String_Node_Str"" + hex.getName()+ ""String_Node_Str""+ Bank.format(cost));
  }
 else {
    Log.write(companyName + ""String_Node_Str"" + hex.getName());
  }
  nextStep(operatingCompany);
  return true;
}",0.997377049180328
173876,"public boolean layBaseToken(MapHex hex){
  return hex.addToken(this,0);
}","public boolean layBaseToken(MapHex hex,int station){
  return hex.addToken(this,station);
}",0.8780487804878049
173877,public boolean layBaseToken(MapHex hex);,"public boolean layBaseToken(MapHex hex,int station);",0.8695652173913043
173878,"private Point getTokenOrigin(int numTokens,int currentToken,int numStations,int currentStation){
  Point p=new Point();
switch (numStations) {
case 1:
switch (numTokens) {
case 1:
      p.x=(center.x - 9);
    p.y=(center.y - 9);
  return p;
case 2:
if (currentToken == 0) {
  p.x=(center.x - 5);
  p.y=(center.y - 9);
  return p;
}
 else {
  p.x=(center.x - 17);
  p.y=(center.y - 9);
  return p;
}
case 3:
if (currentToken == 0) {
p.x=(center.x - 14);
p.y=(center.y - 3);
return p;
}
 else if (currentToken == 1) {
p.x=(center.x - 5);
p.y=(center.y - 3);
return p;
}
 else {
p.x=(center.x - 9);
p.y=(center.y - 14);
return p;
}
case 4:
case 5:
case 6:
default :
return center;
}
case 2:
if (currentStation == 0) {
switch (numTokens) {
case 1:
p.x=(center.x - 14);
p.y=(center.y + 3);
return p;
case 2:
if (currentToken == 0) {
p.x=(center.x - 14);
p.y=(center.y + 3);
return p;
}
 else {
p.x=(center.x - 20);
p.y=(center.y + 12);
return p;
}
default :
return center;
}
}
 else {
switch (numTokens) {
case 1:
p.x=(center.x - 1);
p.y=(center.y - 20);
return p;
case 2:
if (currentToken == 0) {
p.x=(center.x - 1);
p.y=(center.y - 20);
return p;
}
 else {
p.x=(center.x - 6);
p.y=(center.y - 8);
return p;
}
default :
return center;
}
}
case 3:
default :
return center;
}
}","private Point getTokenOrigin(int numTokens,int currentToken,int numStations,int currentStation){
  Point p=new Point();
switch (numStations) {
case 1:
switch (numTokens) {
case 1:
      p.x=(center.x - 9);
    p.y=(center.y - 9);
  return p;
case 2:
if (currentToken == 0) {
  p.x=(center.x - 5);
  p.y=(center.y - 9);
  return p;
}
 else {
  p.x=(center.x - 17);
  p.y=(center.y - 9);
  return p;
}
case 3:
if (currentToken == 0) {
p.x=(center.x - 14);
p.y=(center.y - 3);
return p;
}
 else if (currentToken == 1) {
p.x=(center.x - 5);
p.y=(center.y - 3);
return p;
}
 else {
p.x=(center.x - 9);
p.y=(center.y - 14);
return p;
}
case 4:
case 5:
case 6:
default :
return center;
}
case 2:
if (currentStation == 0) {
switch (numTokens) {
case 1:
p.x=(center.x - 14);
p.y=(center.y + 3);
return p;
case 2:
if (currentToken == 0) {
p.x=(center.x - 20);
p.y=(center.y - 3);
return p;
}
 else {
p.x=(center.x - 10);
p.y=(center.y + 9);
return p;
}
default :
return center;
}
}
 else {
switch (numTokens) {
case 1:
p.x=(center.x - 1);
p.y=(center.y - 20);
return p;
case 2:
if (currentToken == 0) {
p.x=(center.x - 6);
p.y=(center.y - 23);
return p;
}
 else {
p.x=(center.x + 6);
p.y=(center.y - 12);
return p;
}
default :
return center;
}
}
case 3:
default :
return center;
}
}",0.7177672955974843
173879,"public void processDone(){
  if (baseTokenLayingEnabled) {
    if (selectedHex != null) {
      if (selectedHex.getHexModel().getStations().size() == 1)       selectedHex.fixToken(1);
 else {
        Object[] stations=selectedHex.getHexModel().getStations().toArray();
        Station station=(Station)JOptionPane.showInputDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,stations,stations[0]);
        selectedHex.fixToken(selectedHex.getHexModel().getStations().indexOf(station));
      }
    }
  }
 else {
    if (selectedHex != null)     selectedHex.fixTile(tileLayingEnabled);
  }
}","public void processDone(){
  if (baseTokenLayingEnabled) {
    if (selectedHex != null) {
      if (selectedHex.getHexModel().getStations().size() == 1)       selectedHex.fixToken(0);
 else {
        Object[] stations=selectedHex.getHexModel().getStations().toArray();
        Station station=(Station)JOptionPane.showInputDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,stations,stations[0]);
        selectedHex.fixToken(selectedHex.getHexModel().getStations().indexOf(station));
      }
    }
  }
 else {
    if (selectedHex != null)     selectedHex.fixTile(tileLayingEnabled);
  }
}",0.9983792544570502
173880,"public int getTrainLimit(int phaseIndex){
  if (phaseIndex > trainLimit.length) {
    return trainLimit[trainLimit.length - 1];
  }
 else {
    return trainLimit[phaseIndex];
  }
}","public int getTrainLimit(int phaseIndex){
  return trainLimit[Math.min(phaseIndex,trainLimit.length - 1)];
}",0.6041666666666666
173881,"/** 
 * Add it to the error buffer 
 */
public static void error(String message){
  if (XmlUtils.hasValue(message)) {
    System.out.println(message);
    errorBuffer.append(message);
  }
}","/** 
 * Add it to the error buffer 
 */
public static void error(String message){
  if (Utils.hasValue(message)) {
    System.out.println(message);
    errorBuffer.append(message);
  }
}",0.992
173882,"/** 
 * Log a message, and add it to the display buffer 
 */
public static void write(String message){
  if (XmlUtils.hasValue(message)) {
    System.out.println(message);
    messageBuffer.append(message).append(""String_Node_Str"");
  }
}","/** 
 * Log a message, and add it to the display buffer 
 */
public static void write(String message){
  if (Utils.hasValue(message)) {
    System.out.println(message);
    messageBuffer.append(message).append(""String_Node_Str"");
  }
}",0.9936575052854124
173883,"public MapPanel(){
  Scale.set(15);
  setLayout(new BorderLayout());
  mmgr=MapManager.getInstance();
  try {
    map=(HexMap)Class.forName(mmgr.getMapUIClassName()).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  addMouseListener(map);
  addMouseMotionListener(map);
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  scrollPane=new JScrollPane(map);
  scrollPane.setSize(map.getPreferredSize());
  scrollPane.getViewport().addMouseListener(map);
  add(scrollPane,BorderLayout.CENTER);
  setSize(map.getPreferredSize().width,map.getPreferredSize().height);
  setLocation(25,25);
}","public MapPanel(){
  Scale.set(15);
  setLayout(new BorderLayout());
  mmgr=MapManager.getInstance();
  try {
    map=(HexMap)Class.forName(mmgr.getMapUIClassName()).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  scrollPane=new JScrollPane(map);
  scrollPane.setSize(map.getPreferredSize());
  add(scrollPane,BorderLayout.CENTER);
  setSize(map.getPreferredSize().width,map.getPreferredSize().height);
  setLocation(25,25);
}",0.861904761904762
173884,"public ORWindow(){
  super();
  getContentPane().setLayout(new BorderLayout());
  messagePanel=new MessagePanel();
  getContentPane().add(messagePanel,BorderLayout.NORTH);
  if (mapPanel == null)   mapPanel=new MapPanel();
 else   mapPanel=GameUILoader.getMapPanel();
  getContentPane().add(mapPanel,BorderLayout.CENTER);
  addMouseListener(mapPanel.getMap());
  upgradePanel=new UpgradesPanel();
  getContentPane().add(upgradePanel,BorderLayout.WEST);
  addMouseListener(upgradePanel);
  ORPanel=new ORPanel();
  getContentPane().add(ORPanel,BorderLayout.SOUTH);
  setTitle(""String_Node_Str"");
  setLocation(10,10);
  setVisible(true);
  setSize(800,600);
  addWindowListener(this);
  LogWindow.addLog();
}","public ORWindow(){
  super();
  getContentPane().setLayout(new BorderLayout());
  messagePanel=new MessagePanel();
  getContentPane().add(messagePanel,BorderLayout.NORTH);
  if (mapPanel == null)   mapPanel=new MapPanel();
 else   mapPanel=GameUILoader.getMapPanel();
  getContentPane().add(mapPanel,BorderLayout.CENTER);
  upgradePanel=new UpgradesPanel();
  getContentPane().add(upgradePanel,BorderLayout.WEST);
  addMouseListener(upgradePanel);
  ORPanel=new ORPanel();
  getContentPane().add(ORPanel,BorderLayout.SOUTH);
  setTitle(""String_Node_Str"");
  setLocation(10,10);
  setVisible(true);
  setSize(800,600);
  addWindowListener(this);
  LogWindow.addLog();
}",0.9716363636363636
173885,"public void setupHexes(){
  setupHexesGUI();
}","public void setupHexes(){
  setupHexesGUI();
  addMouseListener(this);
  addMouseMotionListener(this);
}",0.6133333333333333
173886,"private void playHomeTokens(){
  PublicCompanyI[] companies=(PublicCompanyI[])Game.getCompanyManager().getAllPublicCompanies().toArray(new PublicCompanyI[0]);
  for (int compIndex=0; compIndex < companies.length; compIndex++) {
    System.out.println(companies[compIndex]);
    if (companies[compIndex].hasFloated() && companies[compIndex].hasStarted()) {
      MapHex[][] map=MapManager.getInstance().getHexes();
      for (int i=0; i < map.length; i++) {
        for (int j=0; j < map[i].length; j++) {
          if (((PublicCompany)companies[compIndex]).getMaxCityTokens() == ((PublicCompany)companies[compIndex]).getNumCityTokens()) {
            try {
              if (map[i][j].getCompanyHome().equals(companies[compIndex])) {
                if (map[i][j].getPreferredHomeCity() > 0)                 map[i][j].addToken(companies[compIndex],map[i][j].getPreferredHomeCity() - 1);
 else                 map[i][j].addToken(companies[compIndex]);
              }
            }
 catch (            NullPointerException e) {
            }
          }
        }
      }
    }
  }
}","private void playHomeTokens(){
  PublicCompanyI[] companies=(PublicCompanyI[])Game.getCompanyManager().getAllPublicCompanies().toArray(new PublicCompanyI[0]);
  for (int compIndex=0; compIndex < companies.length; compIndex++) {
    if (companies[compIndex].hasFloated() && companies[compIndex].hasStarted()) {
      MapHex[][] map=MapManager.getInstance().getHexes();
      for (int i=0; i < map.length; i++) {
        for (int j=0; j < map[i].length; j++) {
          if (((PublicCompany)companies[compIndex]).getMaxCityTokens() == ((PublicCompany)companies[compIndex]).getNumCityTokens()) {
            try {
              if (map[i][j].getCompanyHome().equals(companies[compIndex])) {
                if (map[i][j].getPreferredHomeCity() > 0)                 map[i][j].addToken(companies[compIndex],map[i][j].getPreferredHomeCity() - 1);
 else                 map[i][j].addToken(companies[compIndex]);
              }
            }
 catch (            NullPointerException e) {
            }
          }
        }
      }
    }
  }
}",0.9782813975448535
173887,"private void paintToken(Graphics2D g2){
  if (getHexModel().getStations().size() > 1) {
    paintSplitStations(g2);
    return;
  }
  int numTokens=getHexModel().getTokens(0).size();
  ArrayList tokens=(ArrayList)getHexModel().getTokens(0);
  for (int i=0; i < tokens.size(); i++) {
    PublicCompany co=(PublicCompany)tokens.get(i);
    Point origin=getTokenOrigin(numTokens,i);
    drawToken(g2,co,origin);
  }
}","private void paintToken(Graphics2D g2){
  if (getHexModel().getStations().size() > 1) {
    paintSplitStations(g2);
    return;
  }
  int numTokens=getHexModel().getTokens(0).size();
  ArrayList tokens=(ArrayList)getHexModel().getTokens(0);
  for (int i=0; i < tokens.size(); i++) {
    PublicCompany co=(PublicCompany)tokens.get(i);
    Point origin=getTokenOrigin(numTokens,i,1,0);
    drawToken(g2,co,origin);
  }
}",0.9951923076923076
173888,"private void paintSplitStations(Graphics2D g2){
  int numStations=getHexModel().getStations().size();
  for (int i=0; i < numStations; i++) {
    int numTokens=getHexModel().getTokens(i).size();
    ArrayList tokens=(ArrayList)getHexModel().getTokens(i);
    Point origin=getTokenOrigin(numTokens,i);
    for (int j=0; j < tokens.size(); j++) {
      PublicCompany co=(PublicCompany)tokens.get(j);
switch (numStations) {
case 2:
switch (i) {
case 0:
          origin.y+=-5;
case 1:
        origin.y+=5;
default :
      break;
  }
case 3:
switch (i) {
case 0:
case 1:
case 2:
default :
  break;
}
default :
break;
}
drawToken(g2,co,origin);
}
}
}","private void paintSplitStations(Graphics2D g2){
  int numStations=getHexModel().getStations().size();
  int numTokens;
  ArrayList tokens;
  Point origin;
  PublicCompany co;
  for (int i=0; i < numStations; i++) {
    numTokens=getHexModel().getTokens(i).size();
    tokens=(ArrayList)getHexModel().getTokens(i);
    for (int j=0; j < tokens.size(); j++) {
      origin=getTokenOrigin(numTokens,j,numStations,i);
      co=(PublicCompany)tokens.get(j);
      drawToken(g2,co,origin);
    }
  }
}",0.6
173889,"private Point getTokenOrigin(int numTokens,int currentToken){
  Point p;
switch (numTokens) {
case 1:
    p=findCenter();
  p.x+=-9;
p.y+=-9;
return p;
case 2:
if (currentToken == 0) {
p=findCenter();
p.x+=-14;
p.y+=-9;
return p;
}
 else {
p=findCenter();
p.x+=-4;
p.y+=-9;
return p;
}
case 3:
case 4:
case 5:
case 6:
default :
return findCenter();
}
}","private Point getTokenOrigin(int numTokens,int currentToken,int numStations,int currentStation){
  Point c=findCenter();
  Point p=new Point();
switch (numStations) {
case 1:
switch (numTokens) {
case 1:
      p.x=(c.x - 9);
    p.y=(c.y - 9);
  return p;
default :
return findCenter();
}
case 2:
if (currentStation == 0) {
switch (numTokens) {
case 1:
p.x=(c.x - 14);
p.y=(c.y + 3);
return p;
default :
return findCenter();
}
}
 else {
switch (numTokens) {
case 1:
p.x=(c.x - 1);
p.y=(c.y - 20);
return p;
default :
return findCenter();
}
}
case 3:
default :
return findCenter();
}
}",0.4081196581196581
173890,"public void init(String name,CompanyTypeI type){
  this.name=name;
  this.type=type;
}","public void init(String name,CompanyTypeI type){
  this.name=name;
  this.type=type;
  this.tokens=new ArrayList();
}",0.8472906403940886
173891,"private void moveTokens(TileI newTile){
  ArrayList newStations=(ArrayList)newTile.getStations();
  if (newStations.size() < stations.size() && newStations.size() <= 1) {
    System.out.println(""String_Node_Str"");
    for (int i=0; i < stations.size(); i++) {
      ArrayList tokens=(ArrayList)((Station)stations.get(i)).getTokens();
      for (int j=0; j < tokens.size(); j++) {
        ((Station)newStations.get(0)).addToken((PublicCompany)tokens.get(j));
      }
    }
    stations=new ArrayList(newStations);
  }
 else {
    for (int i=0; i < stations.size(); i++) {
      ArrayList tokens=(ArrayList)((Station)stations.get(i)).getTokens();
      for (int j=0; j < tokens.size(); j++) {
        ((Station)newStations.get(i)).addToken((PublicCompany)tokens.get(j));
      }
    }
    stations=new ArrayList(newStations);
  }
}","private void moveTokens(TileI newTile){
  ArrayList movedTokens=new ArrayList();
  ArrayList co=(ArrayList)Game.getCompanyManager().getAllPublicCompanies();
  Iterator it=co.iterator();
  while (it.hasNext()) {
    PublicCompany c=(PublicCompany)it.next();
    if (c.hasTokens()) {
      ArrayList t=(ArrayList)c.getTokens();
      Iterator it2=t.iterator();
      while (it2.hasNext()) {
        MapHex hex=(MapHex)it2.next();
        if (hex.equals(this)) {
          System.out.println(""String_Node_Str"" + hex + ""String_Node_Str""+ this);
          movedTokens.add(c);
        }
      }
    }
  }
  if (newTile.getStations().size() <= stations.size() && newTile.getStations().size() == 1) {
    stations=new ArrayList(newTile.getStations());
    Iterator it3=movedTokens.iterator();
    while (it3.hasNext()) {
      ((Station)stations.get(0)).addToken((PublicCompany)it3.next());
    }
    return;
  }
 else {
    ArrayList newStations=new ArrayList(newTile.getStations());
    for (int j=0; j < stations.size(); j++) {
      for (int k=0; k < ((Station)stations.get(j)).getTokens().size(); k++) {
        Iterator it3=movedTokens.iterator();
        while (it3.hasNext()) {
          ArrayList tokens=(ArrayList)((Station)stations.get(j)).getTokens();
          if (((CompanyI)tokens.get(k)).equals(((CompanyI)it.next()))) {
            ((Station)newStations.get(j)).addToken((CompanyI)it.next());
          }
        }
      }
    }
    stations.clear();
    stations=newStations;
  }
}",0.168103448275862
173892,"private void paintToken(Graphics2D g2){
  if (getHexModel().getStations().size() > 1) {
    paintSplitStations(g2);
    return;
  }
  int numTokens=getHexModel().getTokens(0).size();
  ArrayList tokens=(ArrayList)getHexModel().getTokens(0);
  System.out.println(""String_Node_Str"" + getHexModel().getName() + ""String_Node_Str""+ tokens);
  for (int i=0; i < tokens.size(); i++) {
    PublicCompany co=(PublicCompany)tokens.get(i);
    Point origin=getTokenOrigin(numTokens,i,1,0);
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ origin.x+ ""String_Node_Str""+ origin.y+ ""String_Node_Str"");
    drawToken(g2,co,origin);
  }
}","private void paintToken(Graphics2D g2){
  if (getHexModel().getStations().size() > 1) {
    paintSplitStations(g2);
    return;
  }
  int numTokens=getHexModel().getTokens(0).size();
  ArrayList tokens=(ArrayList)getHexModel().getTokens(0);
  System.out.println(""String_Node_Str"" + getHexModel().getName() + ""String_Node_Str""+ tokens);
  for (int i=0; i < tokens.size(); i++) {
    PublicCompany co=(PublicCompany)tokens.get(i);
    Point origin=getTokenOrigin(numTokens,i,1,0);
    drawToken(g2,co,origin);
  }
}",0.891398783666377
173893,"private Point getTokenOrigin(int numTokens,int currentToken,int numStations,int currentStation){
  Point p=new Point();
switch (numStations) {
case 1:
switch (numTokens) {
case 1:
      p.x=(center.x - 9);
    p.y=(center.y - 9);
  return p;
case 2:
if (currentToken == 0) {
  p.x=(center.x - 9);
  p.y=(center.y - 9);
  return p;
}
 else {
  p.x=(center.x - 14);
  p.y=(center.y + 3);
  return p;
}
case 3:
if (currentToken == 0) {
p.x=(center.x - 9);
p.y=(center.y - 9);
return p;
}
 else if (currentToken == 1) {
p.x=(center.x - 14);
p.y=(center.y + 3);
return p;
}
 else {
p.x=(center.x);
p.y=(center.y);
return p;
}
case 4:
case 5:
case 6:
default :
return center;
}
case 2:
if (currentStation == 0) {
switch (numTokens) {
case 1:
p.x=(center.x - 14);
p.y=(center.y + 3);
return p;
case 2:
if (currentToken == 0) {
p.x=(center.x - 14);
p.y=(center.y + 3);
return p;
}
 else {
p.x=(center.x - 20);
p.y=(center.y + 12);
return p;
}
default :
return center;
}
}
 else {
switch (numTokens) {
case 1:
p.x=(center.x - 1);
p.y=(center.y - 20);
return p;
case 2:
if (currentToken == 0) {
p.x=(center.x - 1);
p.y=(center.y - 20);
return p;
}
 else {
p.x=(center.x - 6);
p.y=(center.y - 8);
return p;
}
default :
return center;
}
}
case 3:
default :
return center;
}
}","private Point getTokenOrigin(int numTokens,int currentToken,int numStations,int currentStation){
  Point p=new Point();
switch (numStations) {
case 1:
switch (numTokens) {
case 1:
      p.x=(center.x - 9);
    p.y=(center.y - 9);
  return p;
case 2:
if (currentToken == 0) {
  p.x=(center.x - 5);
  p.y=(center.y - 9);
  return p;
}
 else {
  p.x=(center.x - 17);
  p.y=(center.y - 9);
  return p;
}
case 3:
if (currentToken == 0) {
p.x=(center.x - 14);
p.y=(center.y - 3);
return p;
}
 else if (currentToken == 1) {
p.x=(center.x - 5);
p.y=(center.y - 3);
return p;
}
 else {
p.x=(center.x - 9);
p.y=(center.y - 14);
return p;
}
case 4:
case 5:
case 6:
default :
return center;
}
case 2:
if (currentStation == 0) {
switch (numTokens) {
case 1:
p.x=(center.x - 14);
p.y=(center.y + 3);
return p;
case 2:
if (currentToken == 0) {
p.x=(center.x - 14);
p.y=(center.y + 3);
return p;
}
 else {
p.x=(center.x - 20);
p.y=(center.y + 12);
return p;
}
default :
return center;
}
}
 else {
switch (numTokens) {
case 1:
p.x=(center.x - 1);
p.y=(center.y - 20);
return p;
case 2:
if (currentToken == 0) {
p.x=(center.x - 1);
p.y=(center.y - 20);
return p;
}
 else {
p.x=(center.x - 6);
p.y=(center.y - 8);
return p;
}
default :
return center;
}
}
case 3:
default :
return center;
}
}",0.8355029585798817
173894,"/** 
 * @see game.ConfigurableComponentI#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Element el) throws ConfigurationException {
  NamedNodeMap nnp=el.getAttributes();
  Pattern namePattern=Pattern.compile(""String_Node_Str"");
  name=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  Matcher m=namePattern.matcher(name);
  if (!m.matches()) {
    throw new ConfigurationException(""String_Node_Str"" + name);
  }
  letter=m.group(1).charAt(0);
  try {
    number=Integer.parseInt(m.group(2));
  }
 catch (  NumberFormatException e) {
  }
  if (lettersGoHorizontal) {
    row=number;
    column=letter - '@';
    if (tileOrientation == MapHex.EW) {
      x=column;
      y=row / 2;
    }
 else {
      x=column;
      y=(row + 1) / 2;
    }
  }
 else {
    row=letter - '@';
    column=number;
    if (tileOrientation == MapHex.EW) {
      x=(column + (letterAHasEvenNumbers ? 1 : 0)) / 2;
      y=row;
    }
 else {
      x=column;
      y=(row + 1) / 2;
    }
  }
  String sTileId=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  if (sTileId != null) {
    try {
      preprintedTileId=Integer.parseInt(sTileId);
    }
 catch (    NumberFormatException e) {
      throw new ConfigurationException(""String_Node_Str"" + sTileId);
    }
  }
 else {
    preprintedTileId=-999;
  }
  preprintedTileOrientation=XmlUtils.extractIntegerAttribute(nnp,""String_Node_Str"",0);
  currentTile=TileManager.get().getTile(preprintedTileId);
  currentTileRotation=preprintedTileOrientation;
  impassable=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  tileCost=XmlUtils.extractIntegerAttribute(nnp,""String_Node_Str"",0);
  stations=(ArrayList)currentTile.getStations();
  preferredCity=XmlUtils.extractIntegerAttribute(nnp,""String_Node_Str"",0);
  companyHomeName=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  companyDestinationName=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
}","/** 
 * @see game.ConfigurableComponentI#configureFromXML(org.w3c.dom.Element)
 */
public void configureFromXML(Element el) throws ConfigurationException {
  NamedNodeMap nnp=el.getAttributes();
  Pattern namePattern=Pattern.compile(""String_Node_Str"");
  name=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  Matcher m=namePattern.matcher(name);
  if (!m.matches()) {
    throw new ConfigurationException(""String_Node_Str"" + name);
  }
  letter=m.group(1).charAt(0);
  try {
    number=Integer.parseInt(m.group(2));
  }
 catch (  NumberFormatException e) {
  }
  if (lettersGoHorizontal) {
    row=number;
    column=letter - '@';
    if (tileOrientation == MapHex.EW) {
      x=column;
      y=row / 2;
    }
 else {
      x=column;
      y=(row + 1) / 2;
    }
  }
 else {
    row=letter - '@';
    column=number;
    if (tileOrientation == MapHex.EW) {
      x=(column + (letterAHasEvenNumbers ? 1 : 0)) / 2;
      y=row;
    }
 else {
      x=column;
      y=(row + 1) / 2;
    }
  }
  String sTileId=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  if (sTileId != null) {
    try {
      preprintedTileId=Integer.parseInt(sTileId);
    }
 catch (    NumberFormatException e) {
      throw new ConfigurationException(""String_Node_Str"" + sTileId);
    }
  }
 else {
    preprintedTileId=-999;
  }
  preprintedTileOrientation=XmlUtils.extractIntegerAttribute(nnp,""String_Node_Str"",0);
  currentTile=TileManager.get().getTile(preprintedTileId);
  currentTileRotation=preprintedTileOrientation;
  impassable=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  tileCost=XmlUtils.extractIntegerAttribute(nnp,""String_Node_Str"",0);
  preferredCity=XmlUtils.extractIntegerAttribute(nnp,""String_Node_Str"",0);
  companyHomeName=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  companyDestinationName=XmlUtils.extractStringAttribute(nnp,""String_Node_Str"");
  stations=new ArrayList();
  for (int i=0; i < currentTile.getStations().size(); i++) {
    Station s=(Station)currentTile.getStations().get(i);
    stations.add(new Station(s.getId(),s.getType(),s.getValue(),s.getBaseSlots()));
  }
}",0.9301061990614968
173895,"public void upgrade(TileI newTile,int newOrientation){
  if (currentTile != null)   currentTile.remove(this);
  moveTokens(newTile);
  newTile.lay(this);
  currentTile=newTile;
  currentTileRotation=newOrientation;
}","public void upgrade(TileI newTile,int newOrientation){
  if (currentTile != null)   currentTile.remove(this);
  if (hasTokens)   moveTokens(newTile);
  newTile.lay(this);
  currentTile=newTile;
  currentTileRotation=newOrientation;
}",0.9621380846325168
173896,"private void moveTokens(TileI newTile){
  ArrayList newStations=(ArrayList)newTile.getStations();
  if (newStations.size() < stations.size() && newStations.size() <= 1) {
    System.out.println(""String_Node_Str"");
    for (int i=0; i < stations.size(); i++) {
      ArrayList tokens=(ArrayList)((Station)stations.get(i)).getTokens();
      for (int j=0; j < tokens.size(); j++) {
        ((Station)newStations.get(0)).addToken((PublicCompany)tokens.get(j));
      }
    }
    stations=newStations;
  }
 else {
    for (int i=0; i < stations.size(); i++) {
      ArrayList tokens=(ArrayList)((Station)stations.get(i)).getTokens();
      for (int j=0; j < tokens.size(); j++) {
        ((Station)newStations.get(i)).addToken((PublicCompany)tokens.get(j));
      }
    }
    stations=newStations;
  }
}","private void moveTokens(TileI newTile){
  ArrayList newStations=(ArrayList)newTile.getStations();
  if (newStations.size() < stations.size() && newStations.size() <= 1) {
    System.out.println(""String_Node_Str"");
    for (int i=0; i < stations.size(); i++) {
      ArrayList tokens=(ArrayList)((Station)stations.get(i)).getTokens();
      for (int j=0; j < tokens.size(); j++) {
        ((Station)newStations.get(0)).addToken((PublicCompany)tokens.get(j));
      }
    }
    stations=new ArrayList(newStations);
  }
 else {
    for (int i=0; i < stations.size(); i++) {
      ArrayList tokens=(ArrayList)((Station)stations.get(i)).getTokens();
      for (int j=0; j < tokens.size(); j++) {
        ((Station)newStations.get(i)).addToken((PublicCompany)tokens.get(j));
      }
    }
    stations=new ArrayList(newStations);
  }
}",0.961916461916462
173897,"public LogWindow(){
  messageWindow=this;
  message=new JLabel(""String_Node_Str"");
  message.setBackground(Color.WHITE);
  message.setOpaque(true);
  message.setVerticalAlignment(SwingConstants.TOP);
  messagePanel=new JPanel(new GridBagLayout());
  messageScroller=new JScrollPane(message,ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  vbar=messageScroller.getVerticalScrollBar();
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.gridx=gbc.gridy=0;
  gbc.weightx=gbc.weighty=0.5;
  gbc.fill=GridBagConstraints.BOTH;
  messagePanel.add(messageScroller,gbc);
  setContentPane(messagePanel);
  setSize(400,400);
  setLocation(600,400);
  messagePanel.setBorder(BorderFactory.createEtchedBorder());
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
}","public LogWindow(){
  messageWindow=this;
  message=new JLabel(""String_Node_Str"");
  message.setBackground(Color.WHITE);
  message.setOpaque(true);
  message.setVerticalAlignment(SwingConstants.TOP);
  messagePanel=new JPanel(new GridBagLayout());
  messageScroller=new JScrollPane(message,ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  vbar=messageScroller.getVerticalScrollBar();
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.gridx=gbc.gridy=0;
  gbc.weightx=gbc.weighty=0.5;
  gbc.fill=GridBagConstraints.BOTH;
  messagePanel.add(messageScroller,gbc);
  setContentPane(messagePanel);
  setSize(400,400);
  setLocation(600,400);
  messagePanel.setBorder(BorderFactory.createEtchedBorder());
  setTitle(""String_Node_Str"");
  addWindowListener(this);
}",0.9597113650030066
173898,"public MapWindow(){
  Scale.set(15);
  Container contentPane=this.getContentPane();
  contentPane.setLayout(new BorderLayout());
  mmgr=MapManager.getInstance();
  try {
    map=(HexMap)Class.forName(mmgr.getMapUIClassName()).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  map.addMouseListener(map);
  map.addMouseMotionListener(map);
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  scrollPane=new JScrollPane(map);
  scrollPane.setSize(map.getPreferredSize());
  contentPane.add(scrollPane,BorderLayout.CENTER);
  upgradePanel=new UpgradesPanel(map);
  contentPane.add(upgradePanel,BorderLayout.WEST);
  map.setUpgradesPanel(upgradePanel);
  setSize(map.getPreferredSize().width + 100,map.getPreferredSize().height + 40);
  setLocation(25,25);
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  pack();
}","public MapWindow(){
  Scale.set(15);
  Container contentPane=this.getContentPane();
  contentPane.setLayout(new BorderLayout());
  mmgr=MapManager.getInstance();
  try {
    map=(HexMap)Class.forName(mmgr.getMapUIClassName()).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  map.addMouseListener(map);
  map.addMouseMotionListener(map);
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  scrollPane=new JScrollPane(map);
  scrollPane.setSize(map.getPreferredSize());
  contentPane.add(scrollPane,BorderLayout.CENTER);
  upgradePanel=new UpgradesPanel(map);
  contentPane.add(upgradePanel,BorderLayout.WEST);
  map.setUpgradesPanel(upgradePanel);
  setSize(map.getPreferredSize().width + 100,map.getPreferredSize().height + 40);
  setLocation(25,25);
  setTitle(""String_Node_Str"");
  addWindowListener(this);
  pack();
}",0.9635584137191854
173899,"public void initMenu(){
  menuBar=new JMenuBar();
  fileMenu=new JMenu(""String_Node_Str"");
  optMenu=new JMenu(""String_Node_Str"");
  fileMenu.setMnemonic(KeyEvent.VK_F);
  optMenu.setMnemonic(KeyEvent.VK_O);
  menuItem=new JMenuItem(""String_Node_Str"");
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_S);
  menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,ActionEvent.ALT_MASK));
  menuItem.addActionListener(this);
  fileMenu.add(menuItem);
  fileMenu.addSeparator();
  menuItem=new JMenuItem(""String_Node_Str"");
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_Q);
  menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q,ActionEvent.ALT_MASK));
  menuItem.addActionListener(this);
  fileMenu.add(menuItem);
  menuBar.add(fileMenu);
  menuItem=new JMenuItem(""String_Node_Str"");
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_S);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  optMenu.addSeparator();
  menuItem=new JCheckBoxMenuItem(""String_Node_Str"");
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_K);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  menuItem=new JCheckBoxMenuItem(""String_Node_Str"");
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_M);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  menuItem=new JCheckBoxMenuItem(""String_Node_Str"");
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_L);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  menuBar.add(optMenu);
  setJMenuBar(menuBar);
}","public void initMenu(){
  menuBar=new JMenuBar();
  fileMenu=new JMenu(""String_Node_Str"");
  optMenu=new JMenu(""String_Node_Str"");
  fileMenu.setMnemonic(KeyEvent.VK_F);
  optMenu.setMnemonic(KeyEvent.VK_O);
  menuItem=new JMenuItem(""String_Node_Str"");
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_S);
  menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,ActionEvent.ALT_MASK));
  menuItem.addActionListener(this);
  fileMenu.add(menuItem);
  fileMenu.addSeparator();
  menuItem=new JMenuItem(""String_Node_Str"");
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_Q);
  menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q,ActionEvent.ALT_MASK));
  menuItem.addActionListener(this);
  fileMenu.add(menuItem);
  menuBar.add(fileMenu);
  menuItem=new JMenuItem(""String_Node_Str"");
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_S);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  optMenu.addSeparator();
  menuItem=new JCheckBoxMenuItem(marketString);
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_K);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  menuItem=new JCheckBoxMenuItem(mapString);
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_M);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  menuItem=new JCheckBoxMenuItem(logString);
  menuItem.setName(""String_Node_Str"");
  menuItem.setMnemonic(KeyEvent.VK_L);
  menuItem.addActionListener(this);
  optMenu.add(menuItem);
  menuBar.add(optMenu);
  setJMenuBar(menuBar);
}",0.9831132944427388
173900,"public MapWindow(){
  Scale.set(15);
  Container contentPane=this.getContentPane();
  contentPane.setLayout(new BorderLayout());
  mmgr=MapManager.getInstance();
  try {
    map=(HexMap)Class.forName(mmgr.getMapUIClassName()).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  map.addMouseListener(map);
  addMouseListener(map);
  map.addMouseMotionListener(map);
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  scrollPane=new JScrollPane(map);
  scrollPane.setSize(map.getPreferredSize());
  contentPane.add(scrollPane,BorderLayout.CENTER);
  upgradePanel=new UpgradesPanel();
  contentPane.add(upgradePanel,BorderLayout.WEST);
  map.setUpgradesPanel(upgradePanel);
  setSize(map.getPreferredSize().width + 100,map.getPreferredSize().height + 40);
  setLocation(25,25);
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
}","public MapWindow(){
  Scale.set(15);
  Container contentPane=this.getContentPane();
  contentPane.setLayout(new BorderLayout());
  mmgr=MapManager.getInstance();
  try {
    map=(HexMap)Class.forName(mmgr.getMapUIClassName()).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  map.addMouseListener(map);
  addMouseListener(map);
  map.addMouseMotionListener(map);
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  scrollPane=new JScrollPane(map);
  scrollPane.setSize(map.getPreferredSize());
  contentPane.add(scrollPane,BorderLayout.CENTER);
  upgradePanel=new UpgradesPanel();
  contentPane.add(upgradePanel,BorderLayout.WEST);
  map.setUpgradesPanel(upgradePanel);
  setSize(map.getPreferredSize().width + 100,map.getPreferredSize().height + 40);
  setLocation(25,25);
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  pack();
}",0.9948078920041536
173901,"public void paint(Graphics g){
  Graphics2D g2=(Graphics2D)g;
  if (getAntialias()) {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  }
 else {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
  }
  Color terrainColor=Color.WHITE;
  if (isSelected()) {
    tileScale=0.3;
    g2.setColor(highlightColor);
    g2.fill(hexagon);
    g2.setColor(terrainColor);
    g2.fill(innerHexagon);
    g2.setColor(Color.black);
    g2.draw(innerHexagon);
  }
 else {
    if (tileScale != 0.33)     tileScale=0.33;
    g2.setColor(terrainColor);
    g2.fill(hexagon);
  }
  g2.setColor(Color.black);
  g2.draw(hexagon);
  FontMetrics fontMetrics=g2.getFontMetrics();
  g2.drawString(hexName,rectBound.x + (rectBound.width - fontMetrics.stringWidth(getHexModel().getName())) * 2 / 5,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 3 / 10));
  g2.drawString(""String_Node_Str"" + model.getX() + ""String_Node_Str""+ model.getY()+ ""String_Node_Str"",rectBound.x + (rectBound.width - fontMetrics.stringWidth(""String_Node_Str"" + getHexModel().getX() + ""String_Node_Str""+ getHexModel().getY()+ ""String_Node_Str"")) * 1 / 3,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 1 / 2));
  g2.drawString(tileId == -999 ? ""String_Node_Str"" : ""String_Node_Str"" + tileId,rectBound.x + (rectBound.width - fontMetrics.stringWidth(""String_Node_Str"" + getHexModel().getPreprintedTileId())) * 2 / 5,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 7 / 10));
}","public void paint(Graphics g){
  Graphics2D g2=(Graphics2D)g;
  if (getAntialias()) {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  }
 else {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
  }
  Color terrainColor=Color.WHITE;
  if (isSelected()) {
    tileScale=0.3;
    g2.setColor(highlightColor);
    g2.fill(hexagon);
    g2.setColor(terrainColor);
    g2.fill(innerHexagon);
    g2.setColor(Color.black);
    g2.draw(innerHexagon);
  }
 else {
    if (tileScale != 0.33)     tileScale=0.33;
  }
  paintOverlay(g2);
}",0.55637707948244
173902,"public void paintOverlay(Graphics2D g){
  BufferedImage overlay=tileImage;
  if (overlay != null) {
    Point center=findCenter();
    af=AffineTransform.getRotateInstance(rotation);
    af.scale(tileScale,tileScale);
    AffineTransformOp aop=new AffineTransformOp(af,AffineTransformOp.TYPE_BILINEAR);
    g.drawImage(tileImage,aop,(center.x + x_adjust),(center.y + y_adjust));
    g.setTransform(AffineTransform.getRotateInstance(0));
  }
}","public void paintOverlay(Graphics2D g2){
  if (tileImage != null) {
    Point center=findCenter();
    af=AffineTransform.getRotateInstance(rotation);
    af.scale(tileScale,tileScale);
    AffineTransformOp aop=new AffineTransformOp(af,AffineTransformOp.TYPE_BILINEAR);
    g2.drawImage(tileImage,aop,center.x + x_adjust,center.y + y_adjust);
  }
}",0.8419721871049305
173903,"protected void setupHexesGUI(){
  hexes.clear();
  MapManager mmgr=MapManager.getInstance();
  MapHex[][] hexArray=mmgr.getHexes();
  MapHex mh;
  h=new GUIHex[hexArray.length][hexArray[0].length];
  for (int i=0; i < hexArray.length; i++) {
    for (int j=0; j < hexArray[0].length; j++) {
      mh=hexArray[i][j];
      if (mh != null) {
        GUIEWHex hex=new GUIEWHex((cx + scale * ((GUIHex.SQRT3 * i) + (GUIHex.SQRT3 / 2 * (j & 1)))),(cy + j * 1.5 * scale),scale,this,i,j);
        hex.setName(mh.getName());
        hex.setTileId(mh.getPreprintedTileId());
        hex.setTileOrientation(mh.getPreprintedTileOrientation());
        hex.setTileFilename(mh.getTileFileName());
        hex.setHexModel(mh);
        imageLoader.loadTile(mh.getPreprintedTileId());
        hex.setTileImage(imageLoader.getTile(mh.getPreprintedTileId()));
        hex.x_adjust=hex.x_adjust_arr[hex.tileOrientation];
        hex.y_adjust=hex.y_adjust_arr[hex.tileOrientation];
        hex.rotation=hex.rotation_arr[hex.tileOrientation];
        h[i][j]=hex;
        hexes.add(hex);
      }
    }
  }
}","protected void setupHexesGUI(){
  hexes=new ArrayList();
  MapManager mmgr=MapManager.getInstance();
  MapHex[][] hexArray=mmgr.getHexes();
  MapHex mh;
  h=new GUIHex[hexArray.length][hexArray[0].length];
  for (int i=0; i < hexArray.length; i++) {
    for (int j=0; j < hexArray[0].length; j++) {
      mh=hexArray[i][j];
      if (mh != null) {
        GUIEWHex hex=new GUIEWHex((cx + scale * ((GUIHex.SQRT3 * i) + (GUIHex.SQRT3 / 2 * (j & 1)))),(cy + j * 1.5 * scale),scale,this,i,j);
        hex.setName(mh.getName());
        hex.setTileId(mh.getPreprintedTileId());
        hex.setTileOrientation(mh.getPreprintedTileOrientation());
        hex.setTileFilename(mh.getTileFileName());
        hex.setHexModel(mh);
        imageLoader.loadTile(mh.getPreprintedTileId());
        hex.setTileImage(imageLoader.getTile(mh.getPreprintedTileId()));
        hex.x_adjust=hex.x_adjust_arr[hex.tileOrientation];
        hex.y_adjust=hex.y_adjust_arr[hex.tileOrientation];
        hex.rotation=hex.rotation_arr[hex.tileOrientation];
        h[i][j]=hex;
        hexes.add(hex);
      }
    }
  }
}",0.9908172635445364
173904,"protected void setupHexesGUI(){
  hexes.clear();
  scale=Scale.get();
  MapManager mmgr=MapManager.getInstance();
  MapHex[][] hexArray=mmgr.getHexes();
  MapHex mh;
  h=new GUIHex[hexArray.length][hexArray[0].length];
  for (int i=0; i < hexArray.length; i++) {
    for (int j=0; j < hexArray[0].length; j++) {
      mh=hexArray[i][j];
      if (mh != null) {
        GUINSHex hex=new GUINSHex((int)Math.round(cx + 3 * i * scale),(int)Math.round(cy + (2 * j + (i & 1)) * GUIHex.SQRT3 * scale),scale,this,i,j);
        hex.setName(mh.getName());
        hex.setTileId(mh.getPreprintedTileId());
        hex.setTileOrientation(mh.getPreprintedTileOrientation());
        hex.setTileFilename(mh.getTileFileName());
        hex.setHexModel(mh);
        imageLoader.loadTile(hexArray[i][j].getPreprintedTileId());
        hex.setTileImage(imageLoader.getTile(hexArray[i][j].getPreprintedTileId()));
        hex.x_adjust=hex.x_adjust_arr[hex.tileOrientation];
        hex.y_adjust=hex.y_adjust_arr[hex.tileOrientation];
        hex.rotation=hex.rotation_arr[hex.tileOrientation];
        h[i][j]=hex;
        hexes.add(hex);
      }
    }
  }
}","protected void setupHexesGUI(){
  hexes=new ArrayList();
  scale=Scale.get();
  MapManager mmgr=MapManager.getInstance();
  MapHex[][] hexArray=mmgr.getHexes();
  MapHex mh;
  h=new GUIHex[hexArray.length][hexArray[0].length];
  for (int i=0; i < hexArray.length; i++) {
    for (int j=0; j < hexArray[0].length; j++) {
      mh=hexArray[i][j];
      if (mh != null) {
        GUINSHex hex=new GUINSHex((int)Math.round(cx + 3 * i * scale),(int)Math.round(cy + (2 * j + (i & 1)) * GUIHex.SQRT3 * scale),scale,this,i,j);
        hex.setName(mh.getName());
        hex.setTileId(mh.getPreprintedTileId());
        hex.setTileOrientation(mh.getPreprintedTileOrientation());
        hex.setTileFilename(mh.getTileFileName());
        hex.setHexModel(mh);
        imageLoader.loadTile(hexArray[i][j].getPreprintedTileId());
        hex.setTileImage(imageLoader.getTile(hexArray[i][j].getPreprintedTileId()));
        hex.x_adjust=hex.x_adjust_arr[hex.tileOrientation];
        hex.y_adjust=hex.y_adjust_arr[hex.tileOrientation];
        hex.rotation=hex.rotation_arr[hex.tileOrientation];
        h[i][j]=hex;
        hexes.add(hex);
      }
    }
  }
}",0.9912510936132984
173905,"public MapWindow(){
  GUIHex.setOverlay(true);
  mmgr=MapManager.getInstance();
  try {
    map=(HexMap)Class.forName(mmgr.getMapUIClassName()).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  scrollPane=new ScrollPane();
  scrollPane.add(map);
  map.addMouseListener(map);
  scrollPane.addMouseListener(map);
  addMouseListener(map);
  scrollPane.setSize(map.getMinimumSize());
  setSize(scrollPane.getPreferredSize());
  getContentPane().add(scrollPane);
  setLocation(25,25);
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
}","public MapWindow(){
  GUIHex.setOverlay(true);
  mmgr=MapManager.getInstance();
  try {
    map=(HexMap)Class.forName(mmgr.getMapUIClassName()).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  scrollPane=new ScrollPane();
  scrollPane.add(map);
  map.addMouseListener(map);
  scrollPane.addMouseListener(map);
  addMouseListener(map);
  scrollPane.setSize(map.getMinimumSize());
  setSize(scrollPane.getPreferredSize());
  getContentPane().add(scrollPane);
  setLocation(25,25);
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  System.out.println(""String_Node_Str"" + map.isLightweight());
}",0.9532293986636972
173906,"public void actionPerformed(ActionEvent actor){
  int returnVal=0;
  player=GameManager.getCurrentPlayer();
  if (actor.getActionCommand().equalsIgnoreCase(""String_Node_Str"")) {
    buyButtonClicked();
    passButton.setText(""String_Node_Str"");
  }
 else   if (actor.getActionCommand().equalsIgnoreCase(""String_Node_Str"")) {
    sellButtonClicked();
    passButton.setText(""String_Node_Str"");
  }
 else   if (actor.getActionCommand().equalsIgnoreCase(""String_Node_Str"")) {
    stockRound.done(gameStatus.getSRPlayer());
    passButton.setText(""String_Node_Str"");
  }
  try {
    JMenuItem menuItem=(JMenuItem)actor.getSource();
    if (menuItem.getText().equalsIgnoreCase(""String_Node_Str""))     System.exit(0);
    if (menuItem.getText().equalsIgnoreCase(""String_Node_Str""))     returnVal=new JFileChooser().showSaveDialog(this);
    if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && menuItem.isSelected())     GameUILoader.messageWindow.setVisible(true);
 else     if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && !menuItem.isSelected())     GameUILoader.messageWindow.setVisible(false);
    if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && menuItem.isSelected())     GameUILoader.stockChart.setVisible(true);
 else     if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && !menuItem.isSelected())     GameUILoader.stockChart.setVisible(false);
    if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && menuItem.isSelected())     GameUILoader.mapWindow.setVisible(true);
 else     if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && !menuItem.isSelected())     GameUILoader.mapWindow.setVisible(false);
  }
 catch (  ClassCastException e) {
  }
  LogWindow.addLog();
  pack();
  currentRound=GameManager.getInstance().getCurrentRound();
  if (currentRound instanceof StockRound)   gameStatus.setSRPlayerTurn(GameManager.getCurrentPlayerIndex());
 else   if (currentRound instanceof OperatingRound) {
    gameStatus.setSRPlayerTurn(-1);
    updateStatus();
  }
}","public void actionPerformed(ActionEvent actor){
  int returnVal=0;
  player=GameManager.getCurrentPlayer();
  if (actor.getActionCommand().equalsIgnoreCase(""String_Node_Str"")) {
    buyButtonClicked();
    passButton.setText(""String_Node_Str"");
    passButton.setMnemonic(KeyEvent.VK_D);
  }
 else   if (actor.getActionCommand().equalsIgnoreCase(""String_Node_Str"")) {
    sellButtonClicked();
    passButton.setText(""String_Node_Str"");
    passButton.setMnemonic(KeyEvent.VK_D);
  }
 else   if (actor.getActionCommand().equalsIgnoreCase(""String_Node_Str"")) {
    stockRound.done(gameStatus.getSRPlayer());
    passButton.setText(""String_Node_Str"");
    passButton.setMnemonic(KeyEvent.VK_P);
  }
  try {
    JMenuItem menuItem=(JMenuItem)actor.getSource();
    if (menuItem.getText().equalsIgnoreCase(""String_Node_Str""))     System.exit(0);
    if (menuItem.getText().equalsIgnoreCase(""String_Node_Str""))     returnVal=new JFileChooser().showSaveDialog(this);
    if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && menuItem.isSelected())     GameUILoader.messageWindow.setVisible(true);
 else     if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && !menuItem.isSelected())     GameUILoader.messageWindow.setVisible(false);
    if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && menuItem.isSelected())     GameUILoader.stockChart.setVisible(true);
 else     if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && !menuItem.isSelected())     GameUILoader.stockChart.setVisible(false);
    if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && menuItem.isSelected())     GameUILoader.mapWindow.setVisible(true);
 else     if (menuItem.getText().equalsIgnoreCase(""String_Node_Str"") && !menuItem.isSelected())     GameUILoader.mapWindow.setVisible(false);
  }
 catch (  ClassCastException e) {
  }
  LogWindow.addLog();
  pack();
  currentRound=GameManager.getInstance().getCurrentRound();
  if (currentRound instanceof StockRound)   gameStatus.setSRPlayerTurn(GameManager.getCurrentPlayerIndex());
 else   if (currentRound instanceof OperatingRound) {
    gameStatus.setSRPlayerTurn(-1);
    updateStatus();
  }
}",0.9691608893138896
173907,"public void paint(Graphics g){
  Graphics2D g2=(Graphics2D)g;
  if (getAntialias()) {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  }
 else {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
  }
  Color terrainColor=getBattleHexModel().getTerrainColor();
  if (isSelected()) {
    if (terrainColor.equals(highlightColor)) {
    }
 else {
      g2.setColor(highlightColor);
    }
    g2.fill(hexagon);
    g2.setColor(terrainColor);
    g2.fill(innerHexagon);
    g2.setColor(Color.black);
    g2.draw(innerHexagon);
  }
 else {
    g2.setColor(terrainColor);
    g2.fill(hexagon);
  }
  g2.setColor(Color.black);
  g2.draw(hexagon);
  if ((useOverlay) && (paintOverlay(g2))) {
  }
 else {
    for (int i=0; i < 6; i++) {
      char hexside=getBattleHexModel().getHexside(i);
      int n;
      if (hexside != ' ') {
        n=(i + 1) % 6;
        drawHexside(g2,xVertex[i],yVertex[i],xVertex[n],yVertex[n],hexside);
      }
      hexside=getBattleHexModel().getOppositeHexside(i);
      if (hexside != ' ') {
        n=(i + 1) % 6;
        drawHexside(g2,xVertex[n],yVertex[n],xVertex[i],yVertex[i],hexside);
      }
    }
  }
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
  String name=getBattleHexModel().getTerrainName().toUpperCase();
  FontMetrics fontMetrics=g2.getFontMetrics();
  g2.drawString(name,rectBound.x + ((rectBound.width - fontMetrics.stringWidth(name)) / 2),rectBound.y + ((fontMetrics.getHeight() + rectBound.height) / 2));
  g2.drawString(getBattleHexModel().getLabel(),rectBound.x + (rectBound.width - fontMetrics.stringWidth(getBattleHexModel().getLabel())) / 3,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) / 4));
  g2.drawString(hexName,rectBound.x + (rectBound.width - fontMetrics.stringWidth(getBattleHexModel().getLabel())) / 2,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 2 / 3));
  g2.drawString(tileId == -999 ? ""String_Node_Str"" : ""String_Node_Str"" + tileId,rectBound.x + (rectBound.width - fontMetrics.stringWidth(getBattleHexModel().getLabel())) / 2,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 4 / 9));
}","public void paint(Graphics g){
  super.paint(g);
  Graphics2D g2=(Graphics2D)g;
  if (getAntialias()) {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  }
 else {
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
  }
  Color terrainColor=getBattleHexModel().getTerrainColor();
  if (isSelected()) {
    if (terrainColor.equals(highlightColor)) {
    }
 else {
      g2.setColor(highlightColor);
    }
    g2.fill(hexagon);
    g2.setColor(terrainColor);
    g2.fill(innerHexagon);
    g2.setColor(Color.black);
    g2.draw(innerHexagon);
  }
 else {
    g2.setColor(terrainColor);
    g2.fill(hexagon);
  }
  g2.setColor(Color.black);
  g2.draw(hexagon);
  if ((useOverlay) && (paintOverlay(g2))) {
  }
 else {
    for (int i=0; i < 6; i++) {
      char hexside=getBattleHexModel().getHexside(i);
      int n;
      if (hexside != ' ') {
        n=(i + 1) % 6;
        drawHexside(g2,xVertex[i],yVertex[i],xVertex[n],yVertex[n],hexside);
      }
      hexside=getBattleHexModel().getOppositeHexside(i);
      if (hexside != ' ') {
        n=(i + 1) % 6;
        drawHexside(g2,xVertex[n],yVertex[n],xVertex[i],yVertex[i],hexside);
      }
    }
  }
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
  String name=getBattleHexModel().getTerrainName().toUpperCase();
  FontMetrics fontMetrics=g2.getFontMetrics();
  g2.drawString(name,rectBound.x + ((rectBound.width - fontMetrics.stringWidth(name)) / 2),rectBound.y + ((fontMetrics.getHeight() + rectBound.height) / 2));
  g2.drawString(getBattleHexModel().getLabel(),rectBound.x + (rectBound.width - fontMetrics.stringWidth(getBattleHexModel().getLabel())) / 3,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) / 4));
  g2.drawString(hexName,rectBound.x + (rectBound.width - fontMetrics.stringWidth(getBattleHexModel().getLabel())) / 2,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 2 / 3));
  g2.drawString(tileId == -999 ? ""String_Node_Str"" : ""String_Node_Str"" + tileId,rectBound.x + (rectBound.width - fontMetrics.stringWidth(getBattleHexModel().getLabel())) / 2,rectBound.y + ((fontMetrics.getHeight() + rectBound.height) * 4 / 9));
}",0.9959695476936856
173908,"public void repaint(){
  try {
    if (getBattleHexModel().isEntrance()) {
      map.repaint();
    }
 else {
      map.repaint(getBounds().x,getBounds().y,getBounds().width,getBounds().height);
    }
  }
 catch (  NullPointerException e) {
  }
}","public void repaint(){
  super.repaint();
  try {
    if (getBattleHexModel().isEntrance()) {
      map.repaint();
    }
 else {
      System.out.println(getBounds());
      map.repaint();
    }
  }
 catch (  NullPointerException e) {
  }
}",0.7530864197530864
173909,"public void paintComponent(Graphics g){
  super.paintComponent(g);
  Graphics2D g2=(Graphics2D)g;
  try {
    Rectangle rectClip=g.getClipBounds();
    if (rectClip == null) {
      return;
    }
    Iterator it=hexes.iterator();
    while (it.hasNext()) {
      GUIHex hex=(GUIHex)it.next();
      if (!hex.getBattleHexModel().isEntrance() && rectClip.intersects(hex.getBounds())) {
        hex.paint(g);
      }
    }
    Object oldantialias=g2.getRenderingHint(RenderingHints.KEY_ANTIALIASING);
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
    Font oldFont=g.getFont();
    FontMetrics fm;
    String dn=null;
    String bn=null;
    String sub=null;
    if (sub == null) {
      sub=(dn.equals(bn) ? null : bn);
    }
    fm=g.getFontMetrics();
    int tma=fm.getMaxAscent();
    g.drawString(dn,80,4 + tma);
    if (sub != null) {
      fm=g.getFontMetrics();
      int tma2=fm.getMaxAscent();
      g.drawString(sub,80,4 + tma + 8+ tma2);
    }
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,oldantialias);
    g.setFont(oldFont);
  }
 catch (  NullPointerException ex) {
  }
}","public void paintComponent(Graphics g){
  super.paintComponent(g);
  Graphics2D g2=(Graphics2D)g;
  try {
    Rectangle rectClip=g.getClipBounds();
    if (rectClip == null) {
      return;
    }
    Iterator it=hexes.iterator();
    while (it.hasNext()) {
      GUIHex hex=(GUIHex)it.next();
      if (!hex.getBattleHexModel().isEntrance() && rectClip.intersects(hex.getBounds())) {
        hex.paint(g);
      }
    }
    Object oldantialias=g2.getRenderingHint(RenderingHints.KEY_ANTIALIASING);
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
    Font oldFont=g.getFont();
    FontMetrics fm;
    String dn=""String_Node_Str"";
    String bn=null;
    String sub=null;
    if (sub == null) {
      sub=(dn.equals(bn) ? null : bn);
    }
    fm=g.getFontMetrics();
    int tma=fm.getMaxAscent();
    g.drawString(dn,80,4 + tma);
    if (sub != null) {
      fm=g.getFontMetrics();
      int tma2=fm.getMaxAscent();
      g.drawString(sub,80,4 + tma + 8+ tma2);
    }
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,oldantialias);
    g.setFont(oldFont);
  }
 catch (  NullPointerException ex) {
  }
}",0.9908336970755128
173910,"public void mouseClicked(MouseEvent arg0){
  Point point=arg0.getPoint();
  try {
    GUIHex hex=getHexContainingPoint(point);
    if (hex.isSelected() && hexSelected == true) {
      hex.x_adjust=hex.x_adjust_arr[hex.arr_index];
      hex.y_adjust=hex.y_adjust_arr[hex.arr_index];
      hex.rotation=hex.rotation_arr[hex.arr_index];
    }
 else     if (!hex.isSelected() && hexSelected == false) {
      hex.setSelected(true);
      hexSelected=true;
    }
 else {
      unselectAllHexes();
      hex.setSelected(true);
      hexSelected=true;
    }
    hex.repaint();
  }
 catch (  NullPointerException e) {
  }
}","public void mouseClicked(MouseEvent arg0){
  Point point=arg0.getPoint();
  try {
    GUIHex hex=getHexContainingPoint(point);
    if (hex.isSelected() && hexSelected == true) {
      hex.x_adjust=hex.x_adjust_arr[hex.arr_index];
      hex.y_adjust=hex.y_adjust_arr[hex.arr_index];
      hex.rotation=hex.rotation_arr[hex.arr_index];
      hex.rotateHexCW();
    }
 else     if (!hex.isSelected() && hexSelected == false) {
      hex.setSelected(true);
      hexSelected=true;
    }
 else {
      unselectAllHexes();
      hex.setSelected(true);
      hexSelected=true;
    }
    hex.repaint();
  }
 catch (  NullPointerException e) {
  }
}",0.9800796812749004
173911,"public MapWindow(){
  GUIHex.setOverlay(true);
  Scale.set(15);
  Container contentPane=this.getContentPane();
  contentPane.setLayout(new BorderLayout());
  mmgr=MapManager.getInstance();
  try {
    map=(HexMap)Class.forName(mmgr.getMapUIClassName()).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  map.addMouseListener(map);
  addMouseListener(map);
  addWindowListener(map);
  scrollPane=new JScrollPane(map);
  scrollPane.setSize(map.getPreferredSize());
  scrollPane.getViewport().setScrollMode(JViewport.SIMPLE_SCROLL_MODE);
  contentPane.add(scrollPane,BorderLayout.CENTER);
  setSize(map.getPreferredSize());
  setLocation(25,25);
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
}","public MapWindow(){
  GUIHex.setOverlay(true);
  Scale.set(15);
  Container contentPane=this.getContentPane();
  contentPane.setLayout(new BorderLayout());
  mmgr=MapManager.getInstance();
  try {
    map=(HexMap)Class.forName(mmgr.getMapUIClassName()).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  map.addMouseListener(map);
  addMouseListener(map);
  addWindowListener(map);
  scrollPane=new ScrollPane();
  scrollPane.add(map);
  scrollPane.setSize(map.getPreferredSize());
  contentPane.add(scrollPane,BorderLayout.CENTER);
  setSize(map.getPreferredSize());
  setLocation(25,25);
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
}",0.9276105060858424
173912,"public void paintComponent(Graphics g){
  try {
    super.paintComponent(g);
    Rectangle rectClip=g.getClipBounds();
    if (rectClip == null) {
      return;
    }
    System.out.println(rectClip);
    for (int x=(hexes.size() - 1); x > 0; x--) {
      GUIHex hex=(GUIHex)hexes.get(x);
      Rectangle hexrect=hex.getBounds();
      if (g.hitClip(hexrect.x,hexrect.y,hexrect.width,hexrect.height)) {
        hex.paint(g);
      }
    }
  }
 catch (  NullPointerException ex) {
  }
}","public void paintComponent(Graphics g){
  try {
    super.paintComponent(g);
    Rectangle rectClip=g.getClipBounds();
    if (rectClip == null) {
      return;
    }
    for (int x=(hexes.size() - 1); x > 0; x--) {
      GUIHex hex=(GUIHex)hexes.get(x);
      Rectangle hexrect=hex.getBounds();
      if (g.hitClip(hexrect.x,hexrect.y,hexrect.width,hexrect.height)) {
        hex.paint(g);
      }
    }
  }
 catch (  NullPointerException ex) {
  }
}",0.9636752136752136
173913,"public MapWindow(){
  GUIHex.setOverlay(true);
  mmgr=MapManager.getInstance();
  try {
    map=(HexMap)Class.forName(mmgr.getMapUIClassName()).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  scrollPane=new ScrollPane();
  scrollPane.add(map);
  map.addMouseListener(map);
  scrollPane.addMouseListener(map);
  addMouseListener(map);
  scrollPane.setSize(map.getMinimumSize());
  setSize(scrollPane.getPreferredSize());
  getContentPane().add(scrollPane);
  setLocation(25,25);
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  System.out.println(""String_Node_Str"" + map.isLightweight());
}","public MapWindow(){
  GUIHex.setOverlay(true);
  Scale.set(15);
  mmgr=MapManager.getInstance();
  try {
    map=(HexMap)Class.forName(mmgr.getMapUIClassName()).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  scrollPane=new ScrollPane();
  scrollPane.add(map);
  map.addMouseListener(map);
  scrollPane.addMouseListener(map);
  addMouseListener(map);
  scrollPane.setSize(map.getMinimumSize());
  setSize(scrollPane.getPreferredSize());
  getContentPane().add(scrollPane);
  setLocation(25,25);
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  System.out.println(""String_Node_Str"" + map.isLightweight());
}",0.9880868955851436
173914,"protected void setupHexesGUI(){
  hexes.clear();
  MapManager mmgr=MapManager.getInstance();
  MapHex[][] hexArray=mmgr.getHexes();
  MapHex mh;
  h=new GUIHex[hexArray.length][hexArray[0].length];
  for (int i=0; i < hexArray.length; i++) {
    for (int j=0; j < hexArray[0].length; j++) {
      mh=hexArray[i][j];
      if (mh != null) {
        GUIEWHex hex=new GUIEWHex((cx + scale * ((GUIHex.SQRT3 * i) + (GUIHex.SQRT3 / 2 * (j & 1)))),(cy + j * 1.5 * scale),scale,this,i,j);
        hex.setName(hexArray[i][j].getName());
        hex.setTileId(hexArray[i][j].getPreprintedTileId());
        hex.setTileOrientation(hexArray[i][j].getPreprintedTileOrientation());
        hex.setTileFilename(hexArray[i][j].getTileFileName());
        imageLoader.loadTile(hexArray[i][j].getPreprintedTileId());
        hex.setTileImage(imageLoader.getTile(hexArray[i][j].getPreprintedTileId()));
        h[i][j]=hex;
        hexes.add(hex);
      }
    }
  }
}","protected void setupHexesGUI(){
  hexes.clear();
  MapManager mmgr=MapManager.getInstance();
  MapHex[][] hexArray=mmgr.getHexes();
  MapHex mh;
  h=new GUIHex[hexArray.length][hexArray[0].length];
  for (int i=0; i < hexArray.length; i++) {
    for (int j=0; j < hexArray[0].length; j++) {
      mh=hexArray[i][j];
      if (mh != null) {
        GUIEWHex hex=new GUIEWHex((cx + scale * ((GUIHex.SQRT3 * i) + (GUIHex.SQRT3 / 2 * (j & 1)))),(cy + j * 1.5 * scale),scale,this,i,j);
        hex.setName(hexArray[i][j].getName());
        hex.setTileId(hexArray[i][j].getPreprintedTileId());
        hex.setTileOrientation(hexArray[i][j].getPreprintedTileOrientation());
        hex.setTileFilename(hexArray[i][j].getTileFileName());
        imageLoader.loadTile(hexArray[i][j].getPreprintedTileId());
        hex.setTileImage(imageLoader.getTile(hexArray[i][j].getPreprintedTileId()));
        hex.x_adjust=hex.x_adjust_arr[hex.tileOrientation];
        hex.y_adjust=hex.y_adjust_arr[hex.tileOrientation];
        hex.rotation=hex.rotation_arr[hex.tileOrientation];
        h[i][j]=hex;
        hexes.add(hex);
      }
    }
  }
}",0.907514450867052
173915,"public void paint(Graphics g){
  super.paint(g);
  Graphics2D g2=(Graphics2D)g;
  Point center=findCenter();
  x_adjust=x_adjust_arr[tileOrientation];
  y_adjust=y_adjust_arr[tileOrientation];
  rotation=rotation_arr[tileOrientation];
  af=AffineTransform.getRotateInstance(rotation);
  af.scale(tileScale,tileScale);
  AffineTransformOp aop=new AffineTransformOp(af,AffineTransformOp.TYPE_BILINEAR);
  g2.drawImage(tileImage,aop,(center.x + x_adjust),(center.y + y_adjust));
  if (arr_index == 6) {
    arr_index=1;
  }
 else   arr_index++;
}","public void paint(Graphics g){
  super.paint(g);
  Graphics2D g2=(Graphics2D)g;
  Point center=findCenter();
  af=AffineTransform.getRotateInstance(rotation);
  af.scale(tileScale,tileScale);
  AffineTransformOp aop=new AffineTransformOp(af,AffineTransformOp.TYPE_BILINEAR);
  g2.drawImage(tileImage,aop,(center.x + x_adjust),(center.y + y_adjust));
  if (arr_index == 6) {
    arr_index=1;
  }
 else   arr_index++;
}",0.86875
173916,"public void paint(Graphics g){
  super.paint(g);
  Graphics2D g2=(Graphics2D)g;
  Point center=findCenter();
  af=AffineTransform.getRotateInstance(rotation);
  af.scale(tileScale,tileScale);
  AffineTransformOp aop=new AffineTransformOp(af,AffineTransformOp.TYPE_BILINEAR);
  g2.drawImage(tileImage,aop,(center.x + x_adjust),(center.y + y_adjust));
  if (arr_index == 6) {
    arr_index=1;
  }
 else   arr_index++;
}","public void paint(Graphics g){
  super.paint(g);
  Graphics2D g2=(Graphics2D)g;
  Point center=findCenter();
  af=AffineTransform.getRotateInstance(rotation);
  af.scale(tileScale,tileScale);
  AffineTransformOp aop=new AffineTransformOp(af,AffineTransformOp.TYPE_BILINEAR);
  g2.setClip(hexagon);
  g2.drawImage(tileImage,aop,(center.x + x_adjust),(center.y + y_adjust));
  if (arr_index == 6) {
    arr_index=1;
  }
 else   arr_index++;
}",0.97316219369895
173917,"public void paintComponent(Graphics g){
  super.paintComponent(g);
  Rectangle rectClip=g.getClipBounds();
  if (rectClip == null) {
    return;
  }
}","public void paintComponent(Graphics g){
  super.paintComponent(g);
}",0.6238532110091743
173918,"public BattleMap(){
  super();
  battleFrame=new JFrame();
  battleFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
  Container contentPane=battleFrame.getContentPane();
  contentPane.setLayout(new BorderLayout());
  battleFrame.addWindowListener(this);
  addMouseListener(this);
  if (location == null) {
    location=new Point2D.Double(0,2 * scale);
  }
  battleFrame.setLocation((int)location.getX(),(int)location.getY());
  contentPane.add(new JScrollPane(this),BorderLayout.CENTER);
  defaultCursor=battleFrame.getCursor();
  battleFrame.setVisible(true);
  battleFrame.pack();
  battleFrame.setSize(600,600);
}","public BattleMap(){
  super();
  battleFrame=new JFrame();
  battleFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
  Container contentPane=battleFrame.getContentPane();
  contentPane.setLayout(new BorderLayout());
  battleFrame.addWindowListener(this);
  addMouseListener(this);
  if (location == null) {
    location=new Point2D.Double(0,2 * scale);
  }
  battleFrame.setLocation((int)location.getX(),(int)location.getY());
  contentPane.add(new JScrollPane(this),BorderLayout.CENTER);
  defaultCursor=battleFrame.getCursor();
  battleFrame.setVisible(true);
  rescale();
}",0.9530090684253916
173919,"protected void setupHexesGUI(){
  hexes.clear();
  for (int i=0; i < h.length; i++) {
    for (int j=0; j < h[0].length; j++) {
      if (show[i][j]) {
        GUIEWHex hex=new GUIEWHex((cx + (GUIHex.SQRT3 * i * scale) + (GUIHex.SQRT3 / 2 * scale * (j & 1))),(cy + j * 1.5 * scale),scale,this,i,j);
        h[i][j]=hex;
        hexes.add(hex);
      }
    }
  }
}","protected void setupHexesGUI(){
  hexes.clear();
  for (int i=0; i < h.length; i++) {
    for (int j=0; j < h[0].length; j++) {
      if (show[i][j]) {
        GUIEWHex hex=new GUIEWHex((cx + scale * ((GUIHex.SQRT3 * i) + (GUIHex.SQRT3 / 2 * (j & 1)))),(cy + j * 1.5 * scale),scale,this,i,j);
        h[i][j]=hex;
        hexes.add(hex);
      }
    }
  }
}",0.9638888888888888
173920,"/** 
 * Add terrain, hexsides, elevation, and exits to hexes. Cliffs are bidirectional; other hexside obstacles are noted only on the high side, since they only interfere with uphill movement. 
 */
private static synchronized void setupHexesGameState(String terrain,GUIHex[][] h,boolean serverSideFirstLoad){
  List directories=null;
  String rndSourceName=null;
  BattleHex[][] hexModel=new BattleHex[h.length][h[0].length];
  for (int i=0; i < h.length; i++) {
    for (int j=0; j < h[0].length; j++) {
      if (show[i][j]) {
        hexModel[i][j]=new BattleHex(i,j);
      }
    }
  }
  try {
    if ((rndSourceName == null) || (!serverSideFirstLoad)) {
    }
 else {
    }
    final String[] hazards=null;
    HashMap t2n=new HashMap();
    for (int i=0; i < hazards.length; i++) {
      int count=0;
      for (int x=0; x < 6; x++) {
        for (int y=0; y < 6; y++) {
          if (show[x][y]) {
            if (hexModel[x][y].getTerrain().equals(hazards[i])) {
              count++;
            }
          }
        }
      }
      if (count > 0) {
        t2n.put(hazards[i],new Integer(count));
      }
    }
    hazardNumberMap.put(terrain,t2n);
    char[] hazardSides=BattleHex.getHexsides();
    HashMap s2n=new HashMap();
    for (int i=0; i < hazardSides.length; i++) {
      int count=0;
      for (int x=0; x < 6; x++) {
        for (int y=0; y < 6; y++) {
          if (show[x][y]) {
            for (int k=0; k < 6; k++) {
              if (hexModel[x][y].getHexside(k) == hazardSides[i]) {
                count++;
              }
            }
          }
        }
      }
      if (count > 0) {
        s2n.put(new Character(hazardSides[i]),new Integer(count));
      }
    }
    hazardSideNumberMap.put(terrain,s2n);
    for (int i=0; i < hexModel.length; i++) {
      BattleHex[] row=hexModel[i];
      for (int j=0; j < row.length; j++) {
        BattleHex hex=row[j];
        if (show[i][j]) {
          h[i][j].setHexModel(hex);
        }
      }
    }
  }
 catch (  Exception e) {
    Log.error(""String_Node_Str"" + terrain + ""String_Node_Str""+ e);
    e.printStackTrace();
  }
}","/** 
 * Add terrain, hexsides, elevation, and exits to hexes. Cliffs are bidirectional; other hexside obstacles are noted only on the high side, since they only interfere with uphill movement. 
 */
private static synchronized void setupHexesGameState(String terrain,GUIHex[][] h,boolean serverSideFirstLoad){
  List directories=null;
  String rndSourceName=null;
  BattleHex[][] hexModel=new BattleHex[h.length][h[0].length];
  for (int i=0; i < h.length; i++) {
    for (int j=0; j < h[0].length; j++) {
      if (show[i][j]) {
        hexModel[i][j]=new BattleHex(i,j);
      }
    }
  }
  try {
    if ((rndSourceName == null) || (!serverSideFirstLoad)) {
    }
    final String[] hazards=null;
    HashMap t2n=new HashMap();
    for (int i=0; i < hazards.length; i++) {
      int count=0;
      for (int x=0; x < 6; x++) {
        for (int y=0; y < 6; y++) {
          if (show[x][y]) {
            if (hexModel[x][y].getTerrain().equals(hazards[i])) {
              count++;
            }
          }
        }
      }
      if (count > 0) {
        t2n.put(hazards[i],new Integer(count));
      }
    }
    hazardNumberMap.put(terrain,t2n);
    char[] hazardSides=BattleHex.getHexsides();
    HashMap s2n=new HashMap();
    for (int i=0; i < hazardSides.length; i++) {
      int count=0;
      for (int x=0; x < 6; x++) {
        for (int y=0; y < 6; y++) {
          if (show[x][y]) {
            for (int k=0; k < 6; k++) {
              if (hexModel[x][y].getHexside(k) == hazardSides[i]) {
                count++;
              }
            }
          }
        }
      }
      if (count > 0) {
        s2n.put(new Character(hazardSides[i]),new Integer(count));
      }
    }
    hazardSideNumberMap.put(terrain,s2n);
    for (int i=0; i < hexModel.length; i++) {
      BattleHex[] row=hexModel[i];
      for (int j=0; j < row.length; j++) {
        BattleHex hex=row[j];
        if (show[i][j]) {
          h[i][j].setHexModel(hex);
        }
      }
    }
  }
 catch (  Exception e) {
    Log.error(""String_Node_Str"" + terrain + ""String_Node_Str""+ e);
    e.printStackTrace();
  }
}",0.9966730038022814
173921,"public Dimension getPreferredSize(){
  return new Dimension(60,55);
}","public Dimension getPreferredSize(){
  return new Dimension(550,350);
}",0.9571428571428572
173922,"/** 
 * Check if a player may buy the given number of shares from a given company.
 * @param company The company from which to buy
 * @param number The number of shares (usually 1 but not always so).
 * @return True if it is allowed.
 */
public boolean mayBuyCompanyShare(PublicCompanyI company,int number){
  if (portfolio.countShares(company) + number * company.getShareUnit() > 60)   return false;
  return true;
}","/** 
 * Check if a player may buy the given number of shares from a given company.
 * @param company The company from which to buy
 * @param number The number of shares (usually 1 but not always so).
 * @return True if it is allowed.
 */
public boolean mayBuyCompanyShare(PublicCompanyI company,int number){
  if (portfolio.ownsShare(company) + number * company.getShareUnit() > 60)   return false;
  return true;
}",0.9879807692307692
173923,"/** 
 * Find any certificate 
 */
public PublicCertificateI findCertificate(PublicCompanyI company,boolean president){
  String companyName=company.getName();
  if (!certPerCompany.containsKey(companyName))   return null;
  Iterator it=((List)certPerCompany.get(companyName)).iterator();
  PublicCertificateI cert;
  while (it.hasNext()) {
    cert=(PublicCertificateI)it.next();
    if (cert.getCompany() == company && president == cert.isPresidentShare()) {
      return cert;
    }
  }
  return null;
}","/** 
 * Find any certificate 
 */
public PublicCertificateI findCertificate(PublicCompanyI company,boolean president){
  String companyName=company.getName();
  if (!certPerCompany.containsKey(companyName)) {
    System.out.println(""String_Node_Str"" + name + ""String_Node_Str""+ company.getName());
    return null;
  }
  Iterator it=((List)certPerCompany.get(companyName)).iterator();
  PublicCertificateI cert;
  while (it.hasNext()) {
    cert=(PublicCertificateI)it.next();
    if (cert.getCompany() == company && president == cert.isPresidentShare()) {
      return cert;
    }
  }
  return null;
}",0.8870822041553749
173924,"/** 
 * Set a par price.
 * @param playerName The name of the par price setting player.
 * @param companyName The name of teh company for which a par price is set.
 * @param parPrice The par price.
 */
public boolean setPrice(String playerName,String companyName,int parPrice){
  String errMsg=null;
  Player player=GameManager.getCurrentPlayer();
  StockSpaceI startSpace=null;
  while (true) {
    if (!playerName.equals(player.getName())) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (!companyName.equals(companyNeedingPrice.getName())) {
      errMsg=""String_Node_Str"";
      break;
    }
    if ((startSpace=StockMarket.getInstance().getStartSpace(parPrice)) == null) {
      errMsg=""String_Node_Str"";
      break;
    }
    break;
  }
  if (errMsg != null) {
    Log.error(""String_Node_Str"" + Bank.format(parPrice) + ""String_Node_Str""+ playerName+ ""String_Node_Str""+ companyName+ ""String_Node_Str""+ errMsg);
    return false;
  }
  Log.write(playerName + ""String_Node_Str"" + companyName+ ""String_Node_Str""+ Bank.format(parPrice));
  companyNeedingPrice.start(startSpace);
  if (!companyNeedingPrice.hasFloated() && Bank.getIpo().countShares(companyNeedingPrice) <= (100 - companyNeedingPrice.getFloatPercentage())) {
    companyNeedingPrice.setFloated(10 * parPrice);
    Log.write(companyName + ""String_Node_Str"" + Bank.format(companyNeedingPrice.getCash()));
  }
  companyNeedingPrice=null;
  setNextAction();
  return true;
}","/** 
 * Set a par price.
 * @param playerName The name of the par price setting player.
 * @param companyName The name of teh company for which a par price is set.
 * @param parPrice The par price.
 */
public boolean setPrice(String playerName,String companyName,int parPrice){
  String errMsg=null;
  Player player=GameManager.getCurrentPlayer();
  StockSpaceI startSpace=null;
  while (true) {
    if (!playerName.equals(player.getName())) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (!companyName.equals(companyNeedingPrice.getName())) {
      errMsg=""String_Node_Str"";
      break;
    }
    if ((startSpace=StockMarket.getInstance().getStartSpace(parPrice)) == null) {
      errMsg=""String_Node_Str"";
      break;
    }
    break;
  }
  if (errMsg != null) {
    Log.error(""String_Node_Str"" + Bank.format(parPrice) + ""String_Node_Str""+ playerName+ ""String_Node_Str""+ companyName+ ""String_Node_Str""+ errMsg);
    return false;
  }
  Log.write(playerName + ""String_Node_Str"" + companyName+ ""String_Node_Str""+ Bank.format(parPrice));
  companyNeedingPrice.start(startSpace);
  if (!companyNeedingPrice.hasFloated() && Bank.getIpo().ownsShare(companyNeedingPrice) <= (100 - companyNeedingPrice.getFloatPercentage())) {
    companyNeedingPrice.setFloated(10 * parPrice);
    Log.write(companyName + ""String_Node_Str"" + Bank.format(companyNeedingPrice.getCash()));
  }
  companyNeedingPrice=null;
  setNextAction();
  return true;
}",0.9965469613259668
173925,"/** 
 * Sell one or more shares (one or multiple share units, normally 10% each).
 * @param player Name of the selling player.
 * @param company Name of the company of which shares are sold.
 * @param number The number of shares to sell.TODO Does not yet cater for double shares (incl. president). TODO Bank pool limit to be made configurable.
 * @return False if an error is found.
 */
public boolean sellShares(String playerName,String companyName,int number){
  Portfolio portfolio=currentPlayer.getPortfolio();
  String errMsg=null;
  PublicCompanyI company=null;
  currentPlayer=GameManager.getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=""String_Node_Str"" + playerName;
      break;
    }
    if (sequenceRule == SELL_BUY_OR_BUY_SELL && hasBoughtThisTurn && hasSoldThisTurnBeforeBuying || sequenceRule == SELL_BUY && hasBoughtThisTurn) {
      errMsg=""String_Node_Str"";
      break;
    }
    company=companyMgr.getPublicCompany(companyName);
    if (company == null) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (portfolio.countShares(company) < number) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (pool.countShares(company) + number * company.getShareUnit() > 50) {
      errMsg=""String_Node_Str"";
      break;
    }
    break;
  }
  if (errMsg != null) {
    Log.error(playerName + ""String_Node_Str"" + number+ ""String_Node_Str""+ companyName+ ""String_Node_Str""+ errMsg);
    return false;
  }
  PublicCertificateI cert;
  int price=company.getCurrentPrice().getPrice();
  Log.write(playerName + ""String_Node_Str"" + number+ ""String_Node_Str""+ (number * company.getShareUnit())+ ""String_Node_Str""+ companyName+ ""String_Node_Str""+ Bank.format(number * price));
  for (int i=0; i < number; i++) {
    cert=portfolio.findCertificate(company,false);
    pool.buyCertificate(cert,portfolio,cert.getShares() * price);
  }
  stockMarket.sell(company,number);
  if (!playersThatSoldThisRound.containsKey(currentPlayer)) {
    playersThatSoldThisRound.put(currentPlayer,new HashMap());
  }
  ((HashMap)playersThatSoldThisRound.get(currentPlayer)).put(company,null);
  if (!hasBoughtThisTurn)   hasSoldThisTurnBeforeBuying=true;
  hasPassed=false;
  setPriority();
  return true;
}","/** 
 * Sell one or more shares (one or multiple share units, normally 10% each).
 * @param player Name of the selling player.
 * @param company Name of the company of which shares are sold.
 * @param number The number of shares to sell.TODO Does not yet cater for double shares (incl. president).
 * @return False if an error is found.
 */
public boolean sellShares(String playerName,String companyName,int number){
  Portfolio portfolio=currentPlayer.getPortfolio();
  String errMsg=null;
  PublicCompanyI company=null;
  currentPlayer=GameManager.getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=""String_Node_Str"" + playerName;
      break;
    }
    if (sequenceRule == SELL_BUY_OR_BUY_SELL && hasBoughtThisTurn && hasSoldThisTurnBeforeBuying || sequenceRule == SELL_BUY && hasBoughtThisTurn) {
      errMsg=""String_Node_Str"";
      break;
    }
    company=companyMgr.getPublicCompany(companyName);
    if (company == null) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (portfolio.ownsShare(company) < number) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (pool.ownsShare(company) + number * company.getShareUnit() > Bank.getPoolShareLimit()) {
      errMsg=""String_Node_Str"";
      break;
    }
    break;
  }
  if (errMsg != null) {
    Log.error(playerName + ""String_Node_Str"" + number+ ""String_Node_Str""+ companyName+ ""String_Node_Str""+ errMsg);
    return false;
  }
  PublicCertificateI cert;
  int price=company.getCurrentPrice().getPrice();
  Log.write(playerName + ""String_Node_Str"" + number+ ""String_Node_Str""+ (number * company.getShareUnit())+ ""String_Node_Str""+ companyName+ ""String_Node_Str""+ Bank.format(number * price));
  for (int i=0; i < number; i++) {
    cert=portfolio.findCertificate(company,false);
    pool.buyCertificate(cert,portfolio,cert.getShares() * price);
  }
  stockMarket.sell(company,number);
  if (!playersThatSoldThisRound.containsKey(currentPlayer)) {
    playersThatSoldThisRound.put(currentPlayer,new HashMap());
  }
  ((HashMap)playersThatSoldThisRound.get(currentPlayer)).put(company,null);
  if (!hasBoughtThisTurn)   hasSoldThisTurnBeforeBuying=true;
  hasPassed=false;
  setPriority();
  return true;
}",0.9751221679253664
173926,"/** 
 * Check if the current player can sell shares of a given company.
 * @param company The company to be checked
 * @return True if shares of the company can be sold.TODO Make Bank Pool share limit configurable.
 */
public boolean isCompanySellable(PublicCompanyI company){
  if (currentPlayer.getPortfolio().findCertificate(company,false) == null)   return false;
  if (pool.countShares(company) * company.getShareUnit() >= 50)   return false;
  return true;
}","/** 
 * Check if the current player can sell shares of a company.
 * @param companyName Name of the company to be checked
 * @return True if the company can be sold.TODO Make Bank Pool share limit configurable.
 */
public boolean isCompanySellable(String companyName){
  PublicCompanyI company=companyMgr.getPublicCompany(companyName);
  if (currentPlayer.getPortfolio().ownsShare(company) == 0)   return false;
  if (pool.ownsShare(company) >= Bank.getPoolShareLimit())   return false;
  return true;
}",0.655635987590486
173927,"/** 
 * Buying one or more shares (more is sometimes possible)
 * @param player The player that wants to buy shares.
 * @param portfolio The portfolio from which to buy shares. 
 * @param company The company of which to buy shares.
 * @param shares The number of shares to buy.
 * @return True if the company could be started. False indicates an error.TODO Does not yet cater for double non-president shares as in 1835. 
 * @return False if an error is found.
 */
public boolean buyShare(String playerName,Portfolio from,String companyName,int shares){
  String errMsg=null;
  int price=0;
  PublicCompanyI company=null;
  currentPlayer=GameManager.getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=""String_Node_Str"" + playerName;
      break;
    }
    if (hasBoughtThisTurn) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"";
      break;
    }
    if (playersThatSoldThisRound.containsKey(currentPlayer) && ((HashMap)playersThatSoldThisRound.get(currentPlayer)).containsKey(companyName)) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"" + companyName+ ""String_Node_Str"";
      break;
    }
    company=companyMgr.getPublicCompany(companyName);
    if (company == null) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (!company.hasStarted()) {
      errMsg=""String_Node_Str"" + companyName + ""String_Node_Str"";
      break;
    }
    if (shares > from.countShares(company)) {
      errMsg=companyName + ""String_Node_Str"";
      break;
    }
    StockSpaceI currentSpace=company.getCurrentPrice();
    if (shares > 1 && !currentSpace.isNoBuyLimit()) {
      errMsg=""String_Node_Str"" + companyName + ""String_Node_Str"";
      break;
    }
    if (!currentSpace.isNoCertLimit() && !currentPlayer.mayBuyCertificates(shares)) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"";
      break;
    }
    if (!currentSpace.isNoHoldLimit() && !currentPlayer.mayBuyCompanyShare(company,shares)) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"";
      break;
    }
    price=currentSpace.getPrice();
    if (currentPlayer.getCash() < shares * price) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"";
      break;
    }
    break;
  }
  if (errMsg != null) {
    Log.error(playerName + ""String_Node_Str"" + shares+ ""String_Node_Str""+ companyName+ ""String_Node_Str""+ from.getName()+ ""String_Node_Str""+ errMsg);
    return false;
  }
  PublicCertificateI cert;
  for (int i=0; i < shares; i++) {
    cert=from.findCertificate(company,false);
    currentPlayer.getPortfolio().buyCertificate(cert,from,price * cert.getShares());
    Log.write(playerName + ""String_Node_Str"" + shares+ ""String_Node_Str""+ cert.getShare()+ ""String_Node_Str""+ companyName+ ""String_Node_Str""+ from.getName()+ ""String_Node_Str""+ Bank.format(shares * price)+ ""String_Node_Str"");
  }
  hasBoughtThisTurn=true;
  hasPassed=false;
  setPriority();
  if (from == ipo && !company.hasFloated() && from.countShares(company) <= (100 - company.getFloatPercentage())) {
    company.setFloated(10 * price);
    Log.write(companyName + ""String_Node_Str"" + Bank.format(company.getCash()));
  }
  return true;
}","/** 
 * Buying one or more shares (more is sometimes possible)
 * @param player The player that wants to buy shares.
 * @param portfolio The portfolio from which to buy shares. 
 * @param company The company of which to buy shares.
 * @param shares The number of shares to buy.
 * @return True if the company could be started. False indicates an error.TODO Does not yet cater for double non-president shares as in 1835. 
 * @return False if an error is found.
 */
public boolean buyShare(String playerName,Portfolio from,String companyName,int shares){
  String errMsg=null;
  int price=0;
  PublicCompanyI company=null;
  currentPlayer=GameManager.getCurrentPlayer();
  while (true) {
    if (!playerName.equals(currentPlayer.getName())) {
      errMsg=""String_Node_Str"" + playerName;
      break;
    }
    if (hasBoughtThisTurn) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"";
      break;
    }
    if (playersThatSoldThisRound.containsKey(currentPlayer) && ((HashMap)playersThatSoldThisRound.get(currentPlayer)).containsKey(companyName)) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"" + companyName+ ""String_Node_Str"";
      break;
    }
    company=companyMgr.getPublicCompany(companyName);
    if (company == null) {
      errMsg=""String_Node_Str"";
      break;
    }
    if (!company.hasStarted()) {
      errMsg=""String_Node_Str"" + companyName + ""String_Node_Str"";
      break;
    }
    if (shares > from.ownsShare(company)) {
      errMsg=companyName + ""String_Node_Str"";
      break;
    }
    StockSpaceI currentSpace=company.getCurrentPrice();
    if (shares > 1 && !currentSpace.isNoBuyLimit()) {
      errMsg=""String_Node_Str"" + companyName + ""String_Node_Str"";
      break;
    }
    if (!currentSpace.isNoCertLimit() && !currentPlayer.mayBuyCertificates(shares)) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"";
      break;
    }
    if (!currentSpace.isNoHoldLimit() && !currentPlayer.mayBuyCompanyShare(company,shares)) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"";
      break;
    }
    price=currentSpace.getPrice();
    if (currentPlayer.getCash() < shares * price) {
      errMsg=currentPlayer.getName() + ""String_Node_Str"";
      break;
    }
    break;
  }
  if (errMsg != null) {
    Log.error(playerName + ""String_Node_Str"" + shares+ ""String_Node_Str""+ companyName+ ""String_Node_Str""+ from.getName()+ ""String_Node_Str""+ errMsg);
    return false;
  }
  PublicCertificateI cert;
  for (int i=0; i < shares; i++) {
    cert=from.findCertificate(company,false);
    currentPlayer.getPortfolio().buyCertificate(cert,from,price * cert.getShares());
    Log.write(playerName + ""String_Node_Str"" + shares+ ""String_Node_Str""+ cert.getShare()+ ""String_Node_Str""+ companyName+ ""String_Node_Str""+ from.getName()+ ""String_Node_Str""+ Bank.format(shares * price)+ ""String_Node_Str"");
  }
  hasBoughtThisTurn=true;
  hasPassed=false;
  setPriority();
  if (from == ipo && !company.hasFloated() && from.ownsShare(company) <= (100 - company.getFloatPercentage())) {
    company.setFloated(10 * price);
    Log.write(companyName + ""String_Node_Str"" + Bank.format(company.getCash()));
  }
  return true;
}",0.9936848752762868
173928,"/** 
 * Central method for transferring all cash.
 * @param from Who pays the money (null = Bank).
 * @param to Who received the money (null = Bank).
 * @param amount The amount of money.
 */
public static void transferCash(CashHolder from,CashHolder to,int amount){
  if (from == null)   from=instance;
 else   if (to == null)   to=instance;
  from.addCash(-amount);
  to.addCash(amount);
}","/** 
 * Central method for transferring all cash.
 * @param from Who pays the money (null = Bank).
 * @param to Who received the money (null = Bank).
 * @param amount The amount of money.
 */
public static void transferCash(CashHolder from,CashHolder to,int amount){
  if (from == null)   from=instance;
 else   if (to == null)   to=instance;
  System.out.println(""String_Node_Str"" + amount);
  from.addCash(-amount);
  to.addCash(amount);
}",0.939903846153846
173929,"public void buyShare(Certificate share) throws NullPointerException {
  if (hasBoughtStockThisTurn)   return;
  for (int i=0; i < companiesSoldThisTurn.size(); i++) {
    if (share.company.getName().equalsIgnoreCase(companiesSoldThisTurn.get(i).toString()))     return;
  }
  if (portfolio.getCertificates().size() >= playerCertificateLimit)   return;
  try {
    getPortfolio().buyCertificate(share,portfolio,share.getCertificatePrice());
  }
 catch (  NullPointerException e) {
    throw e;
  }
  Game.getPlayerManager().setBoughtStockLast(this);
  hasBoughtStockThisTurn=true;
}","public void buyShare(Certificate share) throws NullPointerException {
  if (hasBoughtStockThisTurn)   return;
  for (int i=0; i < companiesSoldThisTurn.size(); i++) {
    if (share.company.getName().equalsIgnoreCase(companiesSoldThisTurn.get(i).toString()))     return;
  }
  if (portfolio.getCertificates().size() >= playerCertificateLimit)   return;
  try {
    getPortfolio().buyCertificate(share,share.getPortfolio(),share.getCompany().getCurrentPrice().getPrice());
  }
 catch (  NullPointerException e) {
    throw e;
  }
  Game.getPlayerManager().setBoughtStockLast(this);
  hasBoughtStockThisTurn=true;
}",0.942162615255658
173930,"public CertificateI getNextAvailableCertificate(PublicCompanyI company){
  ArrayList certs=(ArrayList)company.getCertificates();
  for (int i=0; i < certs.size(); i++) {
    if (((CertificateI)certs.get(i)).isAvailable()) {
      return (CertificateI)certs.get(i);
    }
  }
  return null;
}","public CertificateI getNextAvailableCertificate(){
  for (int i=0; i < certificates.size(); i++) {
    if (((CertificateI)certificates.get(i)).isAvailable()) {
      return (CertificateI)certificates.get(i);
    }
  }
  return null;
}",0.8114285714285714
173931,"public void buyCertificate(CertificateI certificate,Portfolio from,int price){
  if (owner instanceof Player) {
  }
 else {
    Log.write(from.getName() + ""String_Node_Str"" + certificate.getShare()+ ""String_Node_Str""+ certificate.getCompany().getName()+ ""String_Node_Str""+ getName()+ ""String_Node_Str""+ price+ ""String_Node_Str"");
  }
  from.removeCertificate(certificate);
  this.addCertificate(certificate);
  certificate.setPortfolio(this);
  certificate.setAvailable(false);
  Bank.transferCash(owner,from.owner,price);
}","public void buyCertificate(CertificateI certificate,Portfolio from,int price){
  if (owner instanceof Player) {
    Log.write(from.getName() + ""String_Node_Str"" + certificate.getShare()+ ""String_Node_Str""+ certificate.getCompany().getName()+ ""String_Node_Str""+ getName()+ ""String_Node_Str""+ price+ ""String_Node_Str"");
  }
 else {
    Log.write(from.getName() + ""String_Node_Str"" + certificate.getShare()+ ""String_Node_Str""+ certificate.getCompany().getName()+ ""String_Node_Str""+ getName()+ ""String_Node_Str""+ price+ ""String_Node_Str"");
  }
  from.removeCertificate(certificate);
  this.addCertificate(certificate);
  certificate.setPortfolio(this);
  certificate.setAvailable(false);
  if (from.name.equalsIgnoreCase(""String_Node_Str""))   Bank.transferCash(owner,(PublicCompany)certificate.getCompany(),price);
 else   Bank.transferCash(owner,from.owner,price);
}",0.7483777937995674
173932,"public static boolean startCompany(String playerName,String companyName,StockSpace startSpace){
  Player player=Game.getPlayerManager().getPlayerByName(playerName);
  PublicCompany company=(PublicCompany)Game.getCompanyManager().getPublicCompany(companyName);
  if (player.getCash() >= startSpace.getPrice() * 2) {
    company.setParPrice(startSpace);
    company.setClosed(false);
    Bank.transferCash(player,company,startSpace.getPrice() * 2);
    return true;
  }
 else   return false;
}","public static boolean startCompany(String playerName,String companyName,StockSpace startSpace){
  Player player=Game.getPlayerManager().getPlayerByName(playerName);
  PublicCompany company=(PublicCompany)Game.getCompanyManager().getPublicCompany(companyName);
  Certificate cert=(Certificate)Bank.getIpo().getCertificates().get(0);
  if (player.getCash() >= (startSpace.getPrice() * 2)) {
    company.setParPrice(startSpace);
    company.setClosed(false);
    int price=startSpace.getPrice() * (cert.getShare() / company.getShareUnit());
    Bank.transferCash(player,company,price);
    return true;
  }
 else   return false;
}",0.8336314847942755
173933,"public void actionPerformed(ActionEvent arg0){
  try {
    String companySelected=companyStatus.getCompanySelected();
    CompanyManager cm=(CompanyManager)Game.getCompanyManager();
    PublicCompany co=(PublicCompany)cm.getPublicCompany(companySelected);
    StockMarket stockMarket=(StockMarket)Game.getStockMarket();
    if (arg0.getActionCommand().equalsIgnoreCase(""String_Node_Str"")) {
      Player p;
      PublicCompany c;
      int[] x;
      if (playerStatus.getPlayerSelected() == null && companyStatus.getCompanySelected() == null) {
        x=certStatus.findLabelPosition(certStatus.getSelectedLabel());
        p=(Player)Game.getPlayerManager().getPlayersArrayList().get(x[1] - 1);
        c=(PublicCompany)Game.getCompanyManager().getAllPublicCompanies().get(x[0] - 1);
      }
 else {
        p=Game.getPlayerManager().getPlayerByName(playerStatus.getPlayerSelected());
        c=(PublicCompany)Game.getCompanyManager().getPublicCompany(companyStatus.getCompanySelected());
      }
      if (p.hasBoughtStockThisTurn()) {
        JOptionPane.showMessageDialog(this,""String_Node_Str"");
        return;
      }
      try {
        p.buyShare((Certificate)c.getPortfolio().getNextAvailableCertificate(c));
      }
 catch (      NullPointerException e) {
        companyStatus.setCompanySelected(c.getName());
        playerStatus.setPlayerSelected(p.getName());
        startCompany();
      }
      playerStatus.setPlayerSelected(null);
      companyStatus.setCompanySelected(null);
      repaint();
    }
  }
 catch (  NullPointerException e) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"");
    e.printStackTrace();
  }
}","public void actionPerformed(ActionEvent arg0){
  if (arg0.getActionCommand().equalsIgnoreCase(""String_Node_Str"")) {
    buyButtonClicked();
  }
}",0.1517010596765198
173934,"private void startCompany(){
  String companySelected=companyStatus.getCompanySelected();
  CompanyManager cm=(CompanyManager)Game.getCompanyManager();
  StockMarket stockMarket=(StockMarket)Game.getStockMarket();
  PublicCompany co=(PublicCompany)cm.getPublicCompany(companySelected);
  if (companyStatus.getCompanySelected() != null && playerStatus.getPlayerSelected() != null) {
    StockSpace sp=(StockSpace)JOptionPane.showInputDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null,stockMarket.getStartSpaces().toArray(),stockMarket.getStartSpaces().get(0));
    PublicCompany.startCompany(playerStatus.getPlayerSelected(),companyStatus.getCompanySelected(),sp);
    Player player=Game.getPlayerManager().getPlayerByName(playerStatus.getPlayerSelected());
    player.buyShare((Certificate)co.getCertificates().get(0));
    StockChart.refreshStockPanel();
  }
 else   JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.OK_OPTION);
}","private void startCompany(){
  StockMarket stockMarket=(StockMarket)Game.getStockMarket();
  if (companyStatus.getCompanySelected() != null && playerStatus.getPlayerSelected() != null) {
    StockSpace sp=(StockSpace)JOptionPane.showInputDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null,stockMarket.getStartSpaces().toArray(),stockMarket.getStartSpaces().get(0));
    PublicCompany.startCompany(playerStatus.getPlayerSelected(),companyStatus.getCompanySelected(),sp);
    Player player=Game.getPlayerManager().getPlayerByName(playerStatus.getPlayerSelected());
    player.buyShare((Certificate)company.getCertificates().get(0));
    StockChart.refreshStockPanel();
  }
 else   JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.OK_OPTION);
}",0.8430735930735931
173935,"public void refreshStatus(){
  companyStatus.refreshPanel();
  playerStatus.refreshPanel();
  certStatus.refreshPanel();
  updateStatus();
  this.pack();
  System.out.println(this.getWidth() + ""String_Node_Str"" + this.getHeight());
}","public void refreshStatus(){
  companyStatus.refreshPanel();
  playerStatus.refreshPanel();
  certStatus.refreshPanel();
  updateStatus();
  this.pack();
  System.out.println(""String_Node_Str"" + this.getWidth() + ""String_Node_Str""+ this.getHeight());
}",0.9567010309278352
173936,"/** 
 * @param share
 * @throws NullPointerException if company hasn't started yet. UI needs to handle this.
 */
public void buyShare(Certificate share) throws NullPointerException {
  if (hasBoughtStockThisTurn)   return;
  for (int i=0; i < companiesSoldThisTurn.size(); i++) {
    if (share.company.getName().equalsIgnoreCase(companiesSoldThisTurn.get(i).toString()))     return;
  }
  if (portfolio.getCertificates().size() >= playerCertificateLimit)   return;
  try {
    getPortfolio().buyCertificate(share,share.getPortfolio(),share.getCompany().getCurrentPrice().getPrice());
  }
 catch (  NullPointerException e) {
    throw e;
  }
  Game.getPlayerManager().setBoughtStockLast(this);
  hasBoughtStockThisTurn=true;
}","public void buyShare(Certificate share) throws NullPointerException {
  try {
    buyShare(share,share.getCompany().getCurrentPrice().getPrice());
  }
 catch (  NullPointerException e) {
    throw e;
  }
}",0.1483870967741935
173937,"public static boolean startCompany(String playerName,String companyName,StockSpace startSpace){
  Player player=Game.getPlayerManager().getPlayerByName(playerName);
  PublicCompany company=(PublicCompany)Game.getCompanyManager().getPublicCompany(companyName);
  Certificate cert=(Certificate)Bank.getIpo().getCertificates().get(0);
  if (player.getCash() >= (startSpace.getPrice() * 2)) {
    company.setParPrice(startSpace);
    company.setClosed(false);
    int price=startSpace.getPrice() * (cert.getShare() / company.getShareUnit());
    Bank.transferCash(player,company,price);
    return true;
  }
 else   return false;
}","public static boolean startCompany(String playerName,String companyName,StockSpace startSpace){
  Player player=Game.getPlayerManager().getPlayerByName(playerName);
  PublicCompany company=(PublicCompany)Game.getCompanyManager().getPublicCompany(companyName);
  Certificate cert=(Certificate)Bank.getIpo().getCertificates().get(0);
  if (player.getCash() >= (startSpace.getPrice() * (cert.getShare() / company.getShareUnit()))) {
    company.setParPrice(startSpace);
    company.setClosed(false);
    int price=startSpace.getPrice() * (cert.getShare() / company.getShareUnit());
    player.buyShare(cert,price);
    return true;
  }
 else   return false;
}",0.8464536243180046
173938,"private void startCompany(){
  StockMarket stockMarket=(StockMarket)Game.getStockMarket();
  if (companyStatus.getCompanySelected() != null && playerStatus.getPlayerSelected() != null) {
    StockSpace sp=(StockSpace)JOptionPane.showInputDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null,stockMarket.getStartSpaces().toArray(),stockMarket.getStartSpaces().get(0));
    PublicCompany.startCompany(playerStatus.getPlayerSelected(),companyStatus.getCompanySelected(),sp);
    Player player=Game.getPlayerManager().getPlayerByName(playerStatus.getPlayerSelected());
    player.buyShare((Certificate)company.getCertificates().get(0));
    StockChart.refreshStockPanel();
  }
 else   JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.OK_OPTION);
}","private void startCompany(){
  StockMarket stockMarket=(StockMarket)Game.getStockMarket();
  if (companyStatus.getCompanySelected() != null && playerStatus.getPlayerSelected() != null) {
    StockSpace sp=(StockSpace)JOptionPane.showInputDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE,null,stockMarket.getStartSpaces().toArray(),stockMarket.getStartSpaces().get(0));
    PublicCompany.startCompany(playerStatus.getPlayerSelected(),companyStatus.getCompanySelected(),sp);
    StockChart.refreshStockPanel();
  }
 else   JOptionPane.showMessageDialog(this,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.OK_OPTION);
}",0.8924515698062793
173939,"private void populateStockPanel(){
  int depth=0;
  Point origin=new Point(20,0);
  Dimension size=new Dimension(40,40);
  StockSpace[][] market=stockMarket.getStockChart();
  JLabel priceLabel;
  JLayeredPane layeredPane;
  ArrayList tokenList;
  Color bgColour;
  Color fgColour;
  PublicCompany co;
  StockToken token;
  stockGrid.setColumns(market[0].length);
  stockGrid.setRows(market.length);
  for (int i=0; i < market.length; i++) {
    for (int j=0; j < market[0].length; j++) {
      layeredPane=new JLayeredPane();
      priceLabel=new JLabel();
      stockPanel.add(layeredPane);
      priceLabel.setBounds(1,1,size.width,size.height);
      priceLabel.setOpaque(true);
      layeredPane.add(priceLabel,new Integer(0),depth);
      layeredPane.moveToBack(priceLabel);
      layeredPane.setPreferredSize(new Dimension(40,30));
      try {
        priceLabel.setText(Integer.toString(market[i][j].getPrice()));
      }
 catch (      NullPointerException e) {
        priceLabel.setText(""String_Node_Str"");
      }
      try {
        priceLabel.setBackground(stringToColor(market[i][j].getColour()));
      }
 catch (      NullPointerException e) {
        priceLabel.setBackground(Color.WHITE);
      }
      try {
        if (market[i][j].isStart()) {
          priceLabel.setBorder(BorderFactory.createLineBorder(Color.red,2));
        }
      }
 catch (      NullPointerException e) {
      }
      try {
        if (market[i][j].hasTokens()) {
          tokenList=market[i][j].getTokens();
          for (int k=0; k < tokenList.size(); k++) {
            co=(PublicCompany)tokenList.get(k);
            bgColour=co.getBgColour();
            fgColour=co.getFgColour();
            token=new StockToken(fgColour,bgColour);
            token.setBounds(origin.x,origin.y,size.width,size.height);
            layeredPane.add(token,new Integer(0),depth);
            layeredPane.moveToFront(token);
            origin.y+=6;
          }
        }
      }
 catch (      NullPointerException e) {
      }
    }
  }
}","private void populateStockPanel(){
  int depth=0;
  Dimension size=new Dimension(40,40);
  StockSpace[][] market=stockMarket.getStockChart();
  JLabel priceLabel;
  JLayeredPane layeredPane;
  ArrayList tokenList;
  stockGrid.setColumns(market[0].length);
  stockGrid.setRows(market.length);
  for (int i=0; i < market.length; i++) {
    for (int j=0; j < market[0].length; j++) {
      layeredPane=new JLayeredPane();
      priceLabel=new JLabel();
      stockPanel.add(layeredPane);
      priceLabel.setBounds(1,1,size.width,size.height);
      priceLabel.setOpaque(true);
      layeredPane.add(priceLabel,new Integer(0),depth);
      layeredPane.moveToBack(priceLabel);
      layeredPane.setPreferredSize(new Dimension(40,30));
      try {
        priceLabel.setText(Integer.toString(market[i][j].getPrice()));
      }
 catch (      NullPointerException e) {
        priceLabel.setText(""String_Node_Str"");
      }
      try {
        priceLabel.setBackground(stringToColor(market[i][j].getColour()));
      }
 catch (      NullPointerException e) {
        priceLabel.setBackground(Color.WHITE);
      }
      try {
        if (market[i][j].isStart()) {
          priceLabel.setBorder(BorderFactory.createLineBorder(Color.red,2));
        }
      }
 catch (      NullPointerException e) {
      }
      try {
        if (market[i][j].hasTokens()) {
          tokenList=market[i][j].getTokens();
          placeToken(tokenList,layeredPane);
        }
      }
 catch (      NullPointerException e) {
      }
    }
  }
}",0.8391647855530474
173940,"public void mouseClicked(MouseEvent arg0){
  StockTest.StockUITest();
}","public void mouseClicked(MouseEvent arg0){
  System.out.println(""String_Node_Str"");
  StockTest.StockUITest();
}",0.7759562841530054
173941,"private void initialize(){
  gc=new GridBagConstraints();
  optionsPane=new JPanel();
  playersPane=new JPanel();
  buttonPane=new JPanel();
  newButton=new JButton(""String_Node_Str"");
  this.setLayout(new GridBagLayout());
  this.setTitle(""String_Node_Str"");
  this.setPreferredSize(new Dimension(300,400));
  this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  playersPane.add(new JLabel(""String_Node_Str""));
  playersPane.setBorder(BorderFactory.createLoweredBevelBorder());
  optionsPane.add(new JLabel(""String_Node_Str""));
  optionsPane.setBorder(BorderFactory.createLoweredBevelBorder());
  buttonPane.add(newButton);
  buttonPane.addMouseListener(this);
  buttonPane.setBorder(BorderFactory.createLoweredBevelBorder());
}","private void initialize(){
  gc=new GridBagConstraints();
  optionsPane=new JPanel();
  playersPane=new JPanel();
  buttonPane=new JPanel();
  newButton=new JButton(""String_Node_Str"");
  loadButton=new JButton(""String_Node_Str"");
  this.setLayout(new GridBagLayout());
  this.setTitle(""String_Node_Str"");
  this.setPreferredSize(new Dimension(300,400));
  this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  playersPane.add(new JLabel(""String_Node_Str""));
  playersPane.setBorder(BorderFactory.createLoweredBevelBorder());
  optionsPane.add(new JLabel(""String_Node_Str""));
  optionsPane.setBorder(BorderFactory.createLoweredBevelBorder());
  newButton.addMouseListener(this);
  buttonPane.add(newButton);
  buttonPane.add(loadButton);
  buttonPane.setBorder(BorderFactory.createLoweredBevelBorder());
}",0.8697916666666666
173942,"public static void NewGame(String gameName,ArrayList playerNames){
  initialise(gameName);
  companyManager=(CompanyManagerI)getCompanyManager();
  companyList=(ArrayList)companyManager.getAllPublicCompanies();
  stockMarket=(StockMarket)getStockMarket();
  players=new Player[playerNames.size()];
  for (int i=0; i < playerNames.size(); i++) {
    players[i]=new Player(playerNames.get(i).toString());
  }
  Player.initPlayers(players);
}","public static void NewGame(String gameName,ArrayList playerNames){
  initialise(gameName);
  companyManager=getCompanyManager();
  companyList=(ArrayList)companyManager.getAllPublicCompanies();
  stockMarket=getStockMarket();
  playerManager=getPlayerManager(playerNames);
}",0.6339410939691444
173943,"public void sellShare(Stock share){
}","public int sellShare(Certificate share){
  Portfolio.sellCertificate(share,portfolio,share.getCompany().getCurrentPrice().getPrice());
  return 1;
}",0.3351351351351351
173944,"public void buyShare(Stock share){
}","public int buyShare(Certificate share){
  if (hasBoughtStockThisTurn)   return 0;
  for (int i=0; i < companiesSoldThisTurn.size(); i++) {
    if (share.company.getName().equalsIgnoreCase(companiesSoldThisTurn.get(i).toString()))     return 0;
  }
  if (portfolio.getCertificates().size() >= playerCertificateLimit)   return 0;
  share.getPortfolio().buyCertificate(share,this.portfolio,share.getCompany().getCurrentPrice().getPrice());
  Game.getPlayerManager().setBoughtStockLast(this);
  hasBoughtStockThisTurn=true;
  return 1;
}",0.0632688927943761
173945,"private void populateStockPanel(){
  game.StockPrice[][] market=modelChart.getStockChart();
  stockGrid.setColumns(market[0].length);
  stockGrid.setRows(market.length);
  for (int x=0; x < market.length; x++) {
    for (int y=0; y < market.length; y++) {
      JTextField foo;
      try {
        foo=new JTextField(Integer.toString(market[x][y].getPrice()));
      }
 catch (      NullPointerException e) {
        foo=new JTextField(""String_Node_Str"");
        foo.setBorder(null);
      }
      try {
        setStockBGColor(market[x][y].getColour(),foo);
      }
 catch (      NullPointerException e) {
        foo.setBackground(Color.WHITE);
      }
      foo.setEditable(false);
      stockPanel.add(foo);
    }
  }
}","private void populateStockPanel(){
  game.StockPrice[][] market=modelChart.getStockChart();
  stockGrid.setColumns(market[0].length);
  stockGrid.setRows(market.length);
  for (int x=0; x < market.length; x++) {
    for (int y=0; y < market[0].length; y++) {
      JTextField foo;
      try {
        foo=new JTextField(Integer.toString(market[x][y].getPrice()));
      }
 catch (      NullPointerException e) {
        foo=new JTextField(""String_Node_Str"");
        foo.setBorder(null);
      }
      try {
        setStockBGColor(market[x][y].getColour(),foo);
      }
 catch (      NullPointerException e) {
        foo.setBackground(Color.WHITE);
      }
      foo.setEditable(false);
      stockPanel.add(foo);
    }
  }
}",0.9979324603721572
173946,"public void print(boolean printable){
  httpClientBase.print(printable);
}","public static void print(boolean printable){
  httpClientBase.print(printable);
}",0.9548387096774194
173947,"public void print(boolean printable){
  if (printable) {
    if (-1 == client.networkInterceptors().indexOf(networkInterceptor)) {
      client=client.newBuilder().addNetworkInterceptor(networkInterceptor).build();
    }
  }
 else {
    client.networkInterceptors().remove(networkInterceptor);
  }
}","public void print(boolean printable){
  if (printable) {
    if (-1 == client.networkInterceptors().indexOf(networkInterceptor)) {
      client=client.newBuilder().addNetworkInterceptor(networkInterceptor).build();
    }
  }
 else {
  }
}",0.8752327746741154
173948,"public static void addUseAsBaseType(Class<?> clazz){
  USE_AS_BASE_TYPES.add(clazz);
}","public static void addUseAsBaseType(Class<?> clazz){
  if (null == clazz) {
    throw new NullPointerException();
  }
  if (!isBaseType(clazz)) {
    USE_AS_BASE_TYPES.add(clazz);
  }
}",0.6346863468634686
173949,"public static boolean isUseAsBaseType(Class<?> clazz){
  if (null == clazz) {
    throw new NullPointerException();
  }
  return USE_AS_BASE_TYPES.contains(clazz);
}","public static boolean isUseAsBaseType(Class<?> clazz){
  if (null == clazz) {
    throw new NullPointerException();
  }
  return isBaseType(clazz) || USE_AS_BASE_TYPES.contains(clazz);
}",0.9401709401709402
173950,"/** 
 * Make sure there is #no cycle reference# in the from parameter
 * @param < T > the type of source object
 * @param from the object to be clone (make sure no cycle reference in the object)
 * @return the clone object
 */
public static <T>T deepClone(T from){
  if (null == from) {
    return null;
  }
  try {
    Class<?> clazz=from.getClass();
    if (clazz.isArray()) {
      int length=Array.getLength(from);
      @SuppressWarnings(""String_Node_Str"") T clone=(T)Array.newInstance(from.getClass().getComponentType(),length);
      for (int i=0; i < length; i++) {
        Array.set(clone,i,deepClone(Array.get(from,i)));
      }
      return clone;
    }
 else     if (isBaseType(clazz) || isUseAsBaseType(clazz)) {
      return from;
    }
 else {
      @SuppressWarnings(""String_Node_Str"") T clone=(T)clazz.newInstance();
      BeanCopier copier=getCopier(clazz,clazz);
      copier.copy(from,clone,new Converter(){
        @Override public Object convert(        Object value,        @SuppressWarnings(""String_Node_Str"") Class target,        Object context){
          return deepClone(value);
        }
      }
);
      return clone;
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + from.getClass().getCanonicalName() + ""String_Node_Str""+ from,e);
  }
}","/** 
 * Make sure there is #no cycle reference# in the from parameter
 * @param < T > the type of source object
 * @param from the object to be clone (make sure no cycle reference in the object)
 * @return the clone object
 */
public static <T>T deepClone(T from){
  if (null == from) {
    return null;
  }
  try {
    Class<?> clazz=from.getClass();
    if (clazz.isArray()) {
      int length=Array.getLength(from);
      @SuppressWarnings(""String_Node_Str"") T clone=(T)Array.newInstance(from.getClass().getComponentType(),length);
      for (int i=0; i < length; i++) {
        Array.set(clone,i,deepClone(Array.get(from,i)));
      }
      return clone;
    }
 else     if (isBaseType(clazz) || isUseAsBaseType(clazz)) {
      return from;
    }
 else {
      @SuppressWarnings(""String_Node_Str"") T clone=(T)clazz.newInstance();
      BeanCopier copier=getCopier(clazz,clazz);
      copier.copy(from,clone,new Converter(){
        @Override public Object convert(        Object value,        @SuppressWarnings(""String_Node_Str"") Class target,        Object context){
          return deepClone(value);
        }
      }
);
      return clone;
    }
  }
 catch (  Throwable t) {
    throw new RuntimeException(""String_Node_Str"" + from.getClass().getCanonicalName() + ""String_Node_Str""+ from,t);
  }
}",0.9716257668711656
173951,"public static void addBaseType(Class<?> clazz){
  BASE_TYPES.add(clazz);
}","public static void addBaseType(Class<?> clazz){
  if (null == clazz) {
    throw new NullPointerException();
  }
  BASE_TYPES.add(clazz);
}",0.6948356807511737
173952,"public <T>String toString(T obj) throws ReflectiveOperationException {
  if (null == obj) {
    return ""String_Node_Str"";
  }
  String type=obj.getClass().getCanonicalName();
  if (type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"")) {
    return new String((char[])obj);
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"")) {
    return new String((byte[])obj);
  }
 else   if (type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant(((java.sql.Timestamp)obj).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (type.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant(((java.sql.Time)obj).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (type.equals(""String_Node_Str"")) {
    return ((java.sql.Date)obj).toLocalDate().format(DateTimeFormatter.BASIC_ISO_DATE);
  }
 else   if (type.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant(((java.util.Date)obj).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant((((java.util.Calendar)obj).getTime()).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (type.equals(""String_Node_Str"")) {
    java.sql.Clob clob=(java.sql.Clob)obj;
    StringBuilder sb=new StringBuilder();
    BufferedReader br;
    try {
      br=new BufferedReader(clob.getCharacterStream());
      String line=null;
      while (null != (line=br.readLine())) {
        sb.append(line);
      }
    }
 catch (    SQLException|IOException e) {
      throw new ReflectiveOperationException(e.getMessage());
    }
    return sb.toString();
  }
 else   if (type.equals(""String_Node_Str"")) {
    java.sql.Blob blob=(java.sql.Blob)obj;
    StringBuilder sb=new StringBuilder();
    BufferedReader br;
    try {
      br=new BufferedReader(new InputStreamReader(blob.getBinaryStream()));
      String line=null;
      while (null != (line=br.readLine())) {
        sb.append(line);
      }
    }
 catch (    SQLException|IOException e) {
      throw new ReflectiveOperationException(e.getMessage());
    }
    return sb.toString();
  }
 else {
    throw new ReflectiveOperationException(""String_Node_Str"" + obj.getClass().getName() + ""String_Node_Str""+ obj.getClass().getCanonicalName()+ ""String_Node_Str""+ String.valueOf(obj));
  }
}","public <T>String toString(T obj) throws ReflectiveOperationException {
  if (null == obj) {
    return ""String_Node_Str"";
  }
  @SuppressWarnings(""String_Node_Str"") Class<T> type=(Class<T>)obj.getClass();
  String typeName=obj.getClass().getCanonicalName();
  if (typeName.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (typeName.equals(""String_Node_Str"")) {
    return new String((char[])obj);
  }
 else   if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (typeName.equals(""String_Node_Str"") || typeName.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (typeName.equals(""String_Node_Str"")) {
    return new String((byte[])obj);
  }
 else   if (typeName.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (typeName.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant(((java.sql.Timestamp)obj).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (typeName.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant(((java.sql.Time)obj).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (typeName.equals(""String_Node_Str"")) {
    return ((java.sql.Date)obj).toLocalDate().format(DateTimeFormatter.BASIC_ISO_DATE);
  }
 else   if (typeName.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant(((java.util.Date)obj).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (typeName.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (typeName.equals(""String_Node_Str"") || java.util.Calendar.class.isAssignableFrom(type)) {
    return LocalDateTime.ofInstant((((java.util.Calendar)obj).getTime()).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (typeName.equals(""String_Node_Str"")) {
    java.sql.Clob clob=(java.sql.Clob)obj;
    StringBuilder sb=new StringBuilder();
    BufferedReader br;
    try {
      br=new BufferedReader(clob.getCharacterStream());
      String line=null;
      while (null != (line=br.readLine())) {
        sb.append(line);
      }
    }
 catch (    SQLException|IOException e) {
      throw new ReflectiveOperationException(e.getMessage());
    }
    return sb.toString();
  }
 else   if (typeName.equals(""String_Node_Str"")) {
    java.sql.Blob blob=(java.sql.Blob)obj;
    StringBuilder sb=new StringBuilder();
    BufferedReader br;
    try {
      br=new BufferedReader(new InputStreamReader(blob.getBinaryStream()));
      String line=null;
      while (null != (line=br.readLine())) {
        sb.append(line);
      }
    }
 catch (    SQLException|IOException e) {
      throw new ReflectiveOperationException(e.getMessage());
    }
    return sb.toString();
  }
 else {
    throw new ReflectiveOperationException(""String_Node_Str"" + obj.getClass().getName() + ""String_Node_Str""+ obj.getClass().getCanonicalName()+ ""String_Node_Str""+ String.valueOf(obj));
  }
}",0.965040650406504
173953,"/** 
 * Test for   {@link Arrays#isEmpty(java.lang.Object[])}.
 */
@Test public void testIsEmptyObject(){
  final Object[] emptyArray=new Object[]{};
  final Object[] notEmptyArray=new Object[]{new String(""String_Node_Str"")};
  assertTrue(Arrays.isEmpty((Object[])null));
  assertTrue(Arrays.isEmpty(emptyArray));
  assertFalse(Arrays.isEmpty(notEmptyArray));
}","/** 
 * Test for {Arrays#isEmpty(java.lang.Object[])}.
 */
@Test public void testIsEmptyObject(){
  final Object[] emptyArray=new Object[]{};
  final Object[] notEmptyArray=new Object[]{new String(""String_Node_Str"")};
  assertTrue(Arrays.isEmpty((Object[])null));
  assertTrue(Arrays.isEmpty(emptyArray));
  assertFalse(Arrays.isEmpty(notEmptyArray));
}",0.988795518207283
173954,"/** 
 * Tests for   {@link Arrays#isEmpty(long[])},   {@link Arrays#isEmpty(int[])},   {@link Arrays#isEmpty(short[])},   {@link Arrays#isEmpty(char[])},  {@link Arrays#isEmpty(byte[])},   {@link Arrays#isEmpty(double[])},   {@link Arrays#isEmpty(float[])} and {@link Arrays#isEmpty(boolean[])}.
 */
@Test public void testIsEmptyPrimitives(){
  final long[] emptyLongArray=new long[]{};
  final long[] notEmptyLongArray=new long[]{1L};
  assertTrue(Arrays.isEmpty((long[])null));
  assertTrue(Arrays.isEmpty(emptyLongArray));
  assertFalse(Arrays.isEmpty(notEmptyLongArray));
  final int[] emptyIntArray=new int[]{};
  final int[] notEmptyIntArray=new int[]{1};
  assertTrue(Arrays.isEmpty((int[])null));
  assertTrue(Arrays.isEmpty(emptyIntArray));
  assertFalse(Arrays.isEmpty(notEmptyIntArray));
  final short[] emptyShortArray=new short[]{};
  final short[] notEmptyShortArray=new short[]{1};
  assertTrue(Arrays.isEmpty((short[])null));
  assertTrue(Arrays.isEmpty(emptyShortArray));
  assertFalse(Arrays.isEmpty(notEmptyShortArray));
  final char[] emptyCharArray=new char[]{};
  final char[] notEmptyCharArray=new char[]{1};
  assertTrue(Arrays.isEmpty((char[])null));
  assertTrue(Arrays.isEmpty(emptyCharArray));
  assertFalse(Arrays.isEmpty(notEmptyCharArray));
  final byte[] emptyByteArray=new byte[]{};
  final byte[] notEmptyByteArray=new byte[]{1};
  assertTrue(Arrays.isEmpty((byte[])null));
  assertTrue(Arrays.isEmpty(emptyByteArray));
  assertFalse(Arrays.isEmpty(notEmptyByteArray));
  final double[] emptyDoubleArray=new double[]{};
  final double[] notEmptyDoubleArray=new double[]{1.0};
  assertTrue(Arrays.isEmpty((double[])null));
  assertTrue(Arrays.isEmpty(emptyDoubleArray));
  assertFalse(Arrays.isEmpty(notEmptyDoubleArray));
  final float[] emptyFloatArray=new float[]{};
  final float[] notEmptyFloatArray=new float[]{1.0F};
  assertTrue(Arrays.isEmpty((float[])null));
  assertTrue(Arrays.isEmpty(emptyFloatArray));
  assertFalse(Arrays.isEmpty(notEmptyFloatArray));
  final boolean[] emptyBooleanArray=new boolean[]{};
  final boolean[] notEmptyBooleanArray=new boolean[]{true};
  assertTrue(Arrays.isEmpty((boolean[])null));
  assertTrue(Arrays.isEmpty(emptyBooleanArray));
  assertFalse(Arrays.isEmpty(notEmptyBooleanArray));
}","/** 
 * Tests for {Arrays#isEmpty(long[])}, {Arrays#isEmpty(int[])}, {Arrays#isEmpty(short[])}, {Arrays#isEmpty(char[])}, {Arrays#isEmpty(byte[])}, {Arrays#isEmpty(double[])}, {Arrays#isEmpty(float[])} and {Arrays#isEmpty(boolean[])}.
 */
@Test public void testIsEmptyPrimitives(){
  final long[] emptyLongArray=new long[]{};
  final long[] notEmptyLongArray=new long[]{1L};
  assertTrue(Arrays.isEmpty((long[])null));
  assertTrue(Arrays.isEmpty(emptyLongArray));
  assertFalse(Arrays.isEmpty(notEmptyLongArray));
  final int[] emptyIntArray=new int[]{};
  final int[] notEmptyIntArray=new int[]{1};
  assertTrue(Arrays.isEmpty((int[])null));
  assertTrue(Arrays.isEmpty(emptyIntArray));
  assertFalse(Arrays.isEmpty(notEmptyIntArray));
  final short[] emptyShortArray=new short[]{};
  final short[] notEmptyShortArray=new short[]{1};
  assertTrue(Arrays.isEmpty((short[])null));
  assertTrue(Arrays.isEmpty(emptyShortArray));
  assertFalse(Arrays.isEmpty(notEmptyShortArray));
  final char[] emptyCharArray=new char[]{};
  final char[] notEmptyCharArray=new char[]{1};
  assertTrue(Arrays.isEmpty((char[])null));
  assertTrue(Arrays.isEmpty(emptyCharArray));
  assertFalse(Arrays.isEmpty(notEmptyCharArray));
  final byte[] emptyByteArray=new byte[]{};
  final byte[] notEmptyByteArray=new byte[]{1};
  assertTrue(Arrays.isEmpty((byte[])null));
  assertTrue(Arrays.isEmpty(emptyByteArray));
  assertFalse(Arrays.isEmpty(notEmptyByteArray));
  final double[] emptyDoubleArray=new double[]{};
  final double[] notEmptyDoubleArray=new double[]{1.0};
  assertTrue(Arrays.isEmpty((double[])null));
  assertTrue(Arrays.isEmpty(emptyDoubleArray));
  assertFalse(Arrays.isEmpty(notEmptyDoubleArray));
  final float[] emptyFloatArray=new float[]{};
  final float[] notEmptyFloatArray=new float[]{1.0F};
  assertTrue(Arrays.isEmpty((float[])null));
  assertTrue(Arrays.isEmpty(emptyFloatArray));
  assertFalse(Arrays.isEmpty(notEmptyFloatArray));
  final boolean[] emptyBooleanArray=new boolean[]{};
  final boolean[] notEmptyBooleanArray=new boolean[]{true};
  assertTrue(Arrays.isEmpty((boolean[])null));
  assertTrue(Arrays.isEmpty(emptyBooleanArray));
  assertFalse(Arrays.isEmpty(notEmptyBooleanArray));
}",0.9832026875699889
173955,"/** 
 * Tests for   {@link Arrays#isNotEmpty(long[])},   {@link Arrays#isNotEmpty(int[])},   {@link Arrays#isNotEmpty(short[])},   {@link Arrays#isNotEmpty(char[])},  {@link Arrays#isNotEmpty(byte[])},   {@link Arrays#isNotEmpty(double[])},   {@link Arrays#isNotEmpty(float[])} and {@link Arrays#isNotEmpty(boolean[])}.
 */
@Test public void testIsNotEmptyPrimitives(){
  final long[] emptyLongArray=new long[]{};
  final long[] notEmptyLongArray=new long[]{1L};
  assertFalse(Arrays.isNotEmpty((long[])null));
  assertFalse(Arrays.isNotEmpty(emptyLongArray));
  assertTrue(Arrays.isNotEmpty(notEmptyLongArray));
  final int[] emptyIntArray=new int[]{};
  final int[] notEmptyIntArray=new int[]{1};
  assertFalse(Arrays.isNotEmpty((int[])null));
  assertFalse(Arrays.isNotEmpty(emptyIntArray));
  assertTrue(Arrays.isNotEmpty(notEmptyIntArray));
  final short[] emptyShortArray=new short[]{};
  final short[] notEmptyShortArray=new short[]{1};
  assertFalse(Arrays.isNotEmpty((short[])null));
  assertFalse(Arrays.isNotEmpty(emptyShortArray));
  assertTrue(Arrays.isNotEmpty(notEmptyShortArray));
  final char[] emptyCharArray=new char[]{};
  final char[] notEmptyCharArray=new char[]{1};
  assertFalse(Arrays.isNotEmpty((char[])null));
  assertFalse(Arrays.isNotEmpty(emptyCharArray));
  assertTrue(Arrays.isNotEmpty(notEmptyCharArray));
  final byte[] emptyByteArray=new byte[]{};
  final byte[] notEmptyByteArray=new byte[]{1};
  assertFalse(Arrays.isNotEmpty((byte[])null));
  assertFalse(Arrays.isNotEmpty(emptyByteArray));
  assertTrue(Arrays.isNotEmpty(notEmptyByteArray));
  final double[] emptyDoubleArray=new double[]{};
  final double[] notEmptyDoubleArray=new double[]{1.0};
  assertFalse(Arrays.isNotEmpty((double[])null));
  assertFalse(Arrays.isNotEmpty(emptyDoubleArray));
  assertTrue(Arrays.isNotEmpty(notEmptyDoubleArray));
  final float[] emptyFloatArray=new float[]{};
  final float[] notEmptyFloatArray=new float[]{1.0F};
  assertFalse(Arrays.isNotEmpty((float[])null));
  assertFalse(Arrays.isNotEmpty(emptyFloatArray));
  assertTrue(Arrays.isNotEmpty(notEmptyFloatArray));
  final boolean[] emptyBooleanArray=new boolean[]{};
  final boolean[] notEmptyBooleanArray=new boolean[]{true};
  assertFalse(Arrays.isNotEmpty((boolean[])null));
  assertFalse(Arrays.isNotEmpty(emptyBooleanArray));
  assertTrue(Arrays.isNotEmpty(notEmptyBooleanArray));
}","/** 
 * Tests for {Arrays#isNotEmpty(long[])}, {Arrays#isNotEmpty(int[])}, {Arrays#isNotEmpty(short[])}, {Arrays#isNotEmpty(char[])}, {Arrays#isNotEmpty(byte[])}, {Arrays#isNotEmpty(double[])}, {Arrays#isNotEmpty(float[])} and {Arrays#isNotEmpty(boolean[])}.
 */
@Test public void testIsNotEmptyPrimitives(){
  final long[] emptyLongArray=new long[]{};
  final long[] notEmptyLongArray=new long[]{1L};
  assertFalse(Arrays.isNotEmpty((long[])null));
  assertFalse(Arrays.isNotEmpty(emptyLongArray));
  assertTrue(Arrays.isNotEmpty(notEmptyLongArray));
  final int[] emptyIntArray=new int[]{};
  final int[] notEmptyIntArray=new int[]{1};
  assertFalse(Arrays.isNotEmpty((int[])null));
  assertFalse(Arrays.isNotEmpty(emptyIntArray));
  assertTrue(Arrays.isNotEmpty(notEmptyIntArray));
  final short[] emptyShortArray=new short[]{};
  final short[] notEmptyShortArray=new short[]{1};
  assertFalse(Arrays.isNotEmpty((short[])null));
  assertFalse(Arrays.isNotEmpty(emptyShortArray));
  assertTrue(Arrays.isNotEmpty(notEmptyShortArray));
  final char[] emptyCharArray=new char[]{};
  final char[] notEmptyCharArray=new char[]{1};
  assertFalse(Arrays.isNotEmpty((char[])null));
  assertFalse(Arrays.isNotEmpty(emptyCharArray));
  assertTrue(Arrays.isNotEmpty(notEmptyCharArray));
  final byte[] emptyByteArray=new byte[]{};
  final byte[] notEmptyByteArray=new byte[]{1};
  assertFalse(Arrays.isNotEmpty((byte[])null));
  assertFalse(Arrays.isNotEmpty(emptyByteArray));
  assertTrue(Arrays.isNotEmpty(notEmptyByteArray));
  final double[] emptyDoubleArray=new double[]{};
  final double[] notEmptyDoubleArray=new double[]{1.0};
  assertFalse(Arrays.isNotEmpty((double[])null));
  assertFalse(Arrays.isNotEmpty(emptyDoubleArray));
  assertTrue(Arrays.isNotEmpty(notEmptyDoubleArray));
  final float[] emptyFloatArray=new float[]{};
  final float[] notEmptyFloatArray=new float[]{1.0F};
  assertFalse(Arrays.isNotEmpty((float[])null));
  assertFalse(Arrays.isNotEmpty(emptyFloatArray));
  assertTrue(Arrays.isNotEmpty(notEmptyFloatArray));
  final boolean[] emptyBooleanArray=new boolean[]{};
  final boolean[] notEmptyBooleanArray=new boolean[]{true};
  assertFalse(Arrays.isNotEmpty((boolean[])null));
  assertFalse(Arrays.isNotEmpty(emptyBooleanArray));
  assertTrue(Arrays.isNotEmpty(notEmptyBooleanArray));
}",0.983970933960248
173956,"/** 
 * Test for   {@link Arrays#isNotEmpty(java.lang.Object[])}.
 */
@Test public void testIsNotEmptyObject(){
  final Object[] emptyArray=new Object[]{};
  final Object[] notEmptyArray=new Object[]{new String(""String_Node_Str"")};
  assertFalse(Arrays.isNotEmpty((Object[])null));
  assertFalse(Arrays.isNotEmpty(emptyArray));
  assertTrue(Arrays.isNotEmpty(notEmptyArray));
}","/** 
 * Test for {Arrays#isNotEmpty(java.lang.Object[])}.
 */
@Test public void testIsNotEmptyObject(){
  final Object[] emptyArray=new Object[]{};
  final Object[] notEmptyArray=new Object[]{new String(""String_Node_Str"")};
  assertFalse(Arrays.isNotEmpty((Object[])null));
  assertFalse(Arrays.isNotEmpty(emptyArray));
  assertTrue(Arrays.isNotEmpty(notEmptyArray));
}",0.9892761394101875
173957,"/** 
 * Test for   {@link Strings#isMixedCase(CharSequence)}.
 */
@Test public void testIsMixedCase(){
  assertFalse(Strings.isMixedCase(null));
  assertFalse(Strings.isMixedCase(Strings.EMPTY));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertTrue(Strings.isMixedCase(""String_Node_Str""));
  assertTrue(Strings.isMixedCase(""String_Node_Str""));
  assertTrue(Strings.isMixedCase(""String_Node_Str""));
  assertTrue(Strings.isMixedCase(""String_Node_Str""));
  assertTrue(Strings.isMixedCase(""String_Node_Str""));
  assertTrue(Strings.isMixedCase(""String_Node_Str""));
}","/** 
 * Test for {Strings#isMixedCase(CharSequence)}.
 */
@Test public void testIsMixedCase(){
  assertFalse(Strings.isMixedCase(null));
  assertFalse(Strings.isMixedCase(Strings.EMPTY));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertFalse(Strings.isMixedCase(""String_Node_Str""));
  assertTrue(Strings.isMixedCase(""String_Node_Str""));
  assertTrue(Strings.isMixedCase(""String_Node_Str""));
  assertTrue(Strings.isMixedCase(""String_Node_Str""));
  assertTrue(Strings.isMixedCase(""String_Node_Str""));
  assertTrue(Strings.isMixedCase(""String_Node_Str""));
  assertTrue(Strings.isMixedCase(""String_Node_Str""));
}",0.9958202716823408
173958,"/** 
 * Tests   {@link Strings#toString(byte[],String)}
 * @throws java.io.UnsupportedEncodingException because the method under test max throw it
 * @see Strings#toString(byte[],String)
 */
@Test public void testToString() throws UnsupportedEncodingException {
  final String expectedString=""String_Node_Str"";
  byte[] expectedBytes=expectedString.getBytes(Charset.defaultCharset());
  assertArrayEquals(expectedBytes,expectedString.getBytes());
  assertEquals(expectedString,Strings.toEncodedString(expectedBytes,null));
  assertEquals(expectedString,Strings.toEncodedString(expectedBytes,Charset.forName(System.getProperty(""String_Node_Str""))));
  final String encoding=""String_Node_Str"";
  expectedBytes=expectedString.getBytes(Charset.forName(encoding));
  assertEquals(expectedString,Strings.toEncodedString(expectedBytes,Charset.forName(encoding)));
}","/** 
 * Tests {Strings#toString(byte[], String)}
 * @throws java.io.UnsupportedEncodingException because the method under test max throw it
 */
@Test public void testToString() throws UnsupportedEncodingException {
  final String expectedString=""String_Node_Str"";
  byte[] expectedBytes=expectedString.getBytes(Charset.defaultCharset());
  assertArrayEquals(expectedBytes,expectedString.getBytes());
  assertEquals(expectedString,Strings.toEncodedString(expectedBytes,null));
  assertEquals(expectedString,Strings.toEncodedString(expectedBytes,Charset.forName(System.getProperty(""String_Node_Str""))));
  final String encoding=""String_Node_Str"";
  expectedBytes=expectedString.getBytes(Charset.forName(encoding));
  assertEquals(expectedString,Strings.toEncodedString(expectedBytes,Charset.forName(encoding)));
}",0.3786698621929299
173959,"/** 
 * Test for   {@link Strings#isAllUpperCase(CharSequence)}.
 */
@Test public void testIsAllUpperCase(){
  assertFalse(Strings.isAllUpperCase(null));
  assertFalse(Strings.isAllUpperCase(Strings.EMPTY));
  assertFalse(Strings.isAllUpperCase(""String_Node_Str""));
  assertTrue(Strings.isAllUpperCase(""String_Node_Str""));
  assertFalse(Strings.isAllUpperCase(""String_Node_Str""));
  assertFalse(Strings.isAllUpperCase(""String_Node_Str""));
  assertFalse(Strings.isAllUpperCase(""String_Node_Str""));
  assertFalse(Strings.isAllUpperCase(""String_Node_Str""));
  assertFalse(Strings.isAllUpperCase(""String_Node_Str""));
  assertFalse(Strings.isAllUpperCase(""String_Node_Str""));
}","/** 
 * Test for {Strings#isAllUpperCase(CharSequence)}.
 */
@Test public void testIsAllUpperCase(){
  assertFalse(Strings.isAllUpperCase(null));
  assertFalse(Strings.isAllUpperCase(Strings.EMPTY));
  assertFalse(Strings.isAllUpperCase(""String_Node_Str""));
  assertTrue(Strings.isAllUpperCase(""String_Node_Str""));
  assertFalse(Strings.isAllUpperCase(""String_Node_Str""));
  assertFalse(Strings.isAllUpperCase(""String_Node_Str""));
  assertFalse(Strings.isAllUpperCase(""String_Node_Str""));
  assertFalse(Strings.isAllUpperCase(""String_Node_Str""));
  assertFalse(Strings.isAllUpperCase(""String_Node_Str""));
  assertFalse(Strings.isAllUpperCase(""String_Node_Str""));
}",0.994011976047904
173960,"/** 
 * Test for   {@link Strings#isAllLowerCase(CharSequence)}.
 */
@Test public void testIsAllLowerCase(){
  assertFalse(Strings.isAllLowerCase(null));
  assertFalse(Strings.isAllLowerCase(Strings.EMPTY));
  assertFalse(Strings.isAllLowerCase(""String_Node_Str""));
  assertTrue(Strings.isAllLowerCase(""String_Node_Str""));
  assertFalse(Strings.isAllLowerCase(""String_Node_Str""));
  assertFalse(Strings.isAllLowerCase(""String_Node_Str""));
  assertFalse(Strings.isAllLowerCase(""String_Node_Str""));
  assertFalse(Strings.isAllLowerCase(""String_Node_Str""));
  assertFalse(Strings.isAllLowerCase(""String_Node_Str""));
  assertFalse(Strings.isAllLowerCase(""String_Node_Str""));
}","/** 
 * Test for {Strings#isAllLowerCase(CharSequence)}.
 */
@Test public void testIsAllLowerCase(){
  assertFalse(Strings.isAllLowerCase(null));
  assertFalse(Strings.isAllLowerCase(Strings.EMPTY));
  assertFalse(Strings.isAllLowerCase(""String_Node_Str""));
  assertTrue(Strings.isAllLowerCase(""String_Node_Str""));
  assertFalse(Strings.isAllLowerCase(""String_Node_Str""));
  assertFalse(Strings.isAllLowerCase(""String_Node_Str""));
  assertFalse(Strings.isAllLowerCase(""String_Node_Str""));
  assertFalse(Strings.isAllLowerCase(""String_Node_Str""));
  assertFalse(Strings.isAllLowerCase(""String_Node_Str""));
  assertFalse(Strings.isAllLowerCase(""String_Node_Str""));
}",0.994011976047904
173961,"/** 
 * A sanity check for   {@link Strings#EMPTY}.
 */
@Test public void testEMPTY(){
  assertNotNull(Strings.EMPTY);
  assertEquals(""String_Node_Str"",Strings.EMPTY);
  assertEquals(0,Strings.EMPTY.length());
}","/** 
 * A sanity check for {Strings#EMPTY}.
 */
@Test public void testEMPTY(){
  assertNotNull(Strings.EMPTY);
  assertEquals(""String_Node_Str"",Strings.EMPTY);
  assertEquals(0,Strings.EMPTY.length());
}",0.9806763285024156
173962,"public <T>String toString(T obj) throws ReflectiveOperationException {
  if (null == obj) {
    return ""String_Node_Str"";
  }
  String type=obj.getClass().getName();
  if (type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"")) {
    return new String((char[])obj);
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"")) {
    return new String((byte[])obj);
  }
 else   if (type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant(((java.sql.Timestamp)obj).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (type.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant(((java.sql.Time)obj).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (type.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant(((java.sql.Date)obj).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.BASIC_ISO_DATE);
  }
 else   if (type.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant(((java.util.Date)obj).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant((((java.util.Calendar)obj).getTime()).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (type.equals(""String_Node_Str"")) {
    java.sql.Clob clob=(java.sql.Clob)obj;
    StringBuilder sb=new StringBuilder();
    BufferedReader br;
    try {
      br=new BufferedReader(clob.getCharacterStream());
      String line=null;
      while (null != (line=br.readLine())) {
        sb.append(line);
      }
    }
 catch (    SQLException|IOException e) {
      throw new ReflectiveOperationException(e.getMessage());
    }
    return sb.toString();
  }
 else   if (type.equals(""String_Node_Str"")) {
    java.sql.Blob blob=(java.sql.Blob)obj;
    StringBuilder sb=new StringBuilder();
    BufferedReader br;
    try {
      br=new BufferedReader(new InputStreamReader(blob.getBinaryStream()));
      String line=null;
      while (null != (line=br.readLine())) {
        sb.append(line);
      }
    }
 catch (    SQLException|IOException e) {
      throw new ReflectiveOperationException(e.getMessage());
    }
    return sb.toString();
  }
 else {
    throw new ReflectiveOperationException(""String_Node_Str"" + obj.getClass().getName() + ""String_Node_Str""+ obj.getClass().getCanonicalName()+ ""String_Node_Str""+ String.valueOf(obj));
  }
}","public <T>String toString(T obj) throws ReflectiveOperationException {
  if (null == obj) {
    return ""String_Node_Str"";
  }
  String type=obj.getClass().getCanonicalName();
  if (type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"")) {
    return new String((char[])obj);
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"")) {
    return new String((byte[])obj);
  }
 else   if (type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant(((java.sql.Timestamp)obj).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (type.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant(((java.sql.Time)obj).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (type.equals(""String_Node_Str"")) {
    return ((java.sql.Date)obj).toLocalDate().format(DateTimeFormatter.BASIC_ISO_DATE);
  }
 else   if (type.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant(((java.util.Date)obj).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (type.equals(""String_Node_Str"")) {
    return obj.toString();
  }
 else   if (type.equals(""String_Node_Str"")) {
    return LocalDateTime.ofInstant((((java.util.Calendar)obj).getTime()).toInstant(),ZoneId.systemDefault()).format(DateTimeFormatter.ofPattern(""String_Node_Str""));
  }
 else   if (type.equals(""String_Node_Str"")) {
    java.sql.Clob clob=(java.sql.Clob)obj;
    StringBuilder sb=new StringBuilder();
    BufferedReader br;
    try {
      br=new BufferedReader(clob.getCharacterStream());
      String line=null;
      while (null != (line=br.readLine())) {
        sb.append(line);
      }
    }
 catch (    SQLException|IOException e) {
      throw new ReflectiveOperationException(e.getMessage());
    }
    return sb.toString();
  }
 else   if (type.equals(""String_Node_Str"")) {
    java.sql.Blob blob=(java.sql.Blob)obj;
    StringBuilder sb=new StringBuilder();
    BufferedReader br;
    try {
      br=new BufferedReader(new InputStreamReader(blob.getBinaryStream()));
      String line=null;
      while (null != (line=br.readLine())) {
        sb.append(line);
      }
    }
 catch (    SQLException|IOException e) {
      throw new ReflectiveOperationException(e.getMessage());
    }
    return sb.toString();
  }
 else {
    throw new ReflectiveOperationException(""String_Node_Str"" + obj.getClass().getName() + ""String_Node_Str""+ obj.getClass().getCanonicalName()+ ""String_Node_Str""+ String.valueOf(obj));
  }
}",0.9856365918281969
173963,"@SuppressWarnings(""String_Node_Str"") public <T>T toObject(String text,Class<T> clazz) throws ReflectiveOperationException {
  if (null == text) {
    return null;
  }
 else {
    text=text.trim();
  }
  String type=clazz.getName();
  if (type.equals(""String_Node_Str"")) {
    return (T)text;
  }
 else   if (type.equals(""String_Node_Str"")) {
    return (T)text.toCharArray();
  }
 else   if (type.equals(""String_Node_Str"")) {
    if (text.length() == 1) {
      return (T)new Character(text.charAt(0));
    }
 else {
      throw new ReflectiveOperationException(""String_Node_Str"" + text + ""String_Node_Str"");
    }
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return (T)new Integer(text);
  }
 else   if (type.equals(""String_Node_Str"")) {
    try {
      return (T)text.getBytes(encoding.getCode());
    }
 catch (    UnsupportedEncodingException e) {
      throw new ReflectiveOperationException(e.getMessage());
    }
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return (T)new Float(text);
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return (T)new Double(text);
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return (T)new Long(text);
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return (T)new Boolean(text);
  }
 else   if (type.equals(""String_Node_Str"")) {
    return (T)new BigDecimal(text);
  }
 else   if (type.equals(""String_Node_Str"")) {
    return (T)java.sql.Timestamp.from(LocalDateTime.parse(text,DateTimeFormatter.ofPattern(""String_Node_Str"")).atZone(ZoneId.systemDefault()).toInstant());
  }
 else   if (type.equals(""String_Node_Str"")) {
    return (T)java.sql.Timestamp.from(LocalDateTime.parse(text,DateTimeFormatter.ofPattern(""String_Node_Str"")).atZone(ZoneId.systemDefault()).toInstant());
  }
 else   if (type.equals(""String_Node_Str"")) {
    return (T)java.sql.Date.from(LocalDateTime.parse(text,DateTimeFormatter.ofPattern(""String_Node_Str"")).atZone(ZoneId.systemDefault()).toInstant());
  }
 else   if (type.equals(""String_Node_Str"")) {
    return (T)java.util.Date.from(LocalDateTime.parse(text,DateTimeFormatter.ofPattern(""String_Node_Str"")).atZone(ZoneId.systemDefault()).toInstant());
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return (T)new Byte(text);
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return (T)new Short(text);
  }
 else   if (type.equals(""String_Node_Str"")) {
    return (T)new java.math.BigInteger(text);
  }
 else   if (type.equals(""String_Node_Str"")) {
    java.util.Calendar ca=java.util.Calendar.getInstance();
    ca.setTime(java.util.Date.from(LocalDateTime.parse(text,DateTimeFormatter.ofPattern(""String_Node_Str"")).atZone(ZoneId.systemDefault()).toInstant()));
    return (T)ca;
  }
 else   if (java.sql.Clob.class.isAssignableFrom(clazz)) {
    java.sql.Clob clob=null;
    try {
      clob=((java.sql.Clob)clazz.newInstance());
      clob.setString(0,text);
    }
 catch (    SQLException e) {
      throw new ReflectiveOperationException(e.getMessage());
    }
    return (T)clob;
  }
 else   if (type.equals(""String_Node_Str"")) {
    java.sql.Blob blob=null;
    try {
      blob=((java.sql.Blob)clazz.newInstance());
      blob.setBytes(0,text.getBytes(encoding.getCode()));
    }
 catch (    SQLException|UnsupportedEncodingException e) {
      throw new ReflectiveOperationException(e.getMessage());
    }
    return (T)blob;
  }
 else {
    throw new ReflectiveOperationException(""String_Node_Str"" + clazz.getName() + ""String_Node_Str""+ clazz.getCanonicalName()+ ""String_Node_Str""+ String.valueOf(text));
  }
}","@SuppressWarnings(""String_Node_Str"") public <T>T toObject(String text,Class<T> clazz) throws ReflectiveOperationException {
  if (null == text) {
    return null;
  }
 else {
    text=text.trim();
  }
  String type=clazz.getCanonicalName();
  if (type.equals(""String_Node_Str"")) {
    return (T)text;
  }
 else   if (type.equals(""String_Node_Str"")) {
    return (T)text.toCharArray();
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    if (text.length() == 1) {
      return (T)new Character(text.charAt(0));
    }
 else {
      throw new ReflectiveOperationException(""String_Node_Str"" + text + ""String_Node_Str"");
    }
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return (T)new Integer(text);
  }
 else   if (type.equals(""String_Node_Str"")) {
    try {
      return (T)text.getBytes(encoding.getCode());
    }
 catch (    UnsupportedEncodingException e) {
      throw new ReflectiveOperationException(e.getMessage());
    }
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return (T)new Float(text);
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return (T)new Double(text);
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return (T)new Long(text);
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return (T)new Boolean(text);
  }
 else   if (type.equals(""String_Node_Str"")) {
    return (T)new BigDecimal(text);
  }
 else   if (type.equals(""String_Node_Str"")) {
    return (T)java.sql.Timestamp.from(LocalDateTime.parse(text,DateTimeFormatter.ofPattern(""String_Node_Str"")).atZone(ZoneId.systemDefault()).toInstant());
  }
 else   if (type.equals(""String_Node_Str"")) {
    return (T)java.sql.Timestamp.from(LocalDateTime.parse(text,DateTimeFormatter.ofPattern(""String_Node_Str"")).atZone(ZoneId.systemDefault()).toInstant());
  }
 else   if (type.equals(""String_Node_Str"")) {
    return (T)java.sql.Date.valueOf(LocalDate.parse(text,DateTimeFormatter.ofPattern(""String_Node_Str"")));
  }
 else   if (type.equals(""String_Node_Str"")) {
    return (T)java.util.Date.from(LocalDateTime.parse(text,DateTimeFormatter.ofPattern(""String_Node_Str"")).atZone(ZoneId.systemDefault()).toInstant());
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return (T)new Byte(text);
  }
 else   if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
    return (T)new Short(text);
  }
 else   if (type.equals(""String_Node_Str"")) {
    return (T)new java.math.BigInteger(text);
  }
 else   if (type.equals(""String_Node_Str"")) {
    java.util.Calendar ca=java.util.Calendar.getInstance();
    ca.setTime(java.util.Date.from(LocalDateTime.parse(text,DateTimeFormatter.ofPattern(""String_Node_Str"")).atZone(ZoneId.systemDefault()).toInstant()));
    return (T)ca;
  }
 else   if (java.sql.Clob.class.isAssignableFrom(clazz)) {
    java.sql.Clob clob=null;
    try {
      clob=((java.sql.Clob)clazz.newInstance());
      clob.setString(0,text);
    }
 catch (    SQLException e) {
      throw new ReflectiveOperationException(e.getMessage());
    }
    return (T)clob;
  }
 else   if (type.equals(""String_Node_Str"")) {
    java.sql.Blob blob=null;
    try {
      blob=((java.sql.Blob)clazz.newInstance());
      blob.setBytes(0,text.getBytes(encoding.getCode()));
    }
 catch (    SQLException|UnsupportedEncodingException e) {
      throw new ReflectiveOperationException(e.getMessage());
    }
    return (T)blob;
  }
 else {
    throw new ReflectiveOperationException(""String_Node_Str"" + clazz.getName() + ""String_Node_Str""+ clazz.getCanonicalName()+ ""String_Node_Str""+ String.valueOf(text));
  }
}",0.9866101020814
173964,"/** 
 * Returns the hash code of a non-  {@code null} argument and 0 for a {@code null} argument.
 * @param o an object
 * @return the hash code of a non-{@code null} argument and 0 for a {@code null} argument
 * @see Object#hashCode
 */
public static <T>int hashCode(T o){
  if (null == o || !o.getClass().isArray()) {
    return java.util.Objects.hashCode(o);
  }
 else {
    String canonicalName=o.getClass().getCanonicalName();
    if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((int[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((short[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((long[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((float[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((double[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((boolean[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((char[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((byte[])o);
    }
 else {
      return java.util.Arrays.hashCode((Object[])o);
    }
  }
}","/** 
 * Returns the hash code of a non-  {@code null} argument and 0 for a {@code null} argument.
 * @param o an object
 * @return the hash code of a non-{@code null} argument and 0 for a {@code null} argument
 * @see Object#hashCode
 */
public static <T>int hashCode(T o){
  if (null == o || !o.getClass().isArray()) {
    return java.util.Objects.hashCode(o);
  }
 else {
    String canonicalName=o.getClass().getCanonicalName();
    if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((int[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((short[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((long[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((float[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((double[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((boolean[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((char[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((byte[])o);
    }
 else {
      return java.util.Arrays.deepHashCode((Object[])o);
    }
  }
}",0.9978843441466856
173965,"/** 
 * Make sure there is #no cycle reference# in the from parameter
 * @param < T > the type of source object
 * @param from the object to be clone (make sure no cycle reference in the object)
 * @return the clone object
 */
public static <T>T deepClone(T from){
  if (null == from) {
    return null;
  }
  try {
    Class<?> clazz=from.getClass();
    if (clazz.isArray()) {
      int length=Array.getLength(from);
      @SuppressWarnings(""String_Node_Str"") T clone=(T)Array.newInstance(from.getClass().getComponentType(),length);
      for (int i=0; i < length; i++) {
        Array.set(clone,i,deepClone(Array.get(from,i)));
      }
      return clone;
    }
 else     if (isBaseType(clazz)) {
      return from;
    }
 else {
      @SuppressWarnings(""String_Node_Str"") T clone=(T)clazz.newInstance();
      BeanCopier copier=getCopier(clazz,clazz);
      copier.copy(from,clone,new Converter(){
        @Override public Object convert(        Object value,        @SuppressWarnings(""String_Node_Str"") Class target,        Object context){
          return deepClone(value);
        }
      }
);
      return clone;
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + from.getClass().getCanonicalName() + ""String_Node_Str""+ from,e);
  }
}","/** 
 * Make sure there is #no cycle reference# in the from parameter
 * @param < T > the type of source object
 * @param from the object to be clone (make sure no cycle reference in the object)
 * @return the clone object
 */
public static <T>T deepClone(T from){
  if (null == from) {
    return null;
  }
  try {
    Class<?> clazz=from.getClass();
    if (clazz.isArray()) {
      int length=Array.getLength(from);
      @SuppressWarnings(""String_Node_Str"") T clone=(T)Array.newInstance(from.getClass().getComponentType(),length);
      for (int i=0; i < length; i++) {
        Array.set(clone,i,deepClone(Array.get(from,i)));
      }
      return clone;
    }
 else     if (isBaseType(clazz) || isUseAsBaseType(clazz)) {
      return from;
    }
 else {
      @SuppressWarnings(""String_Node_Str"") T clone=(T)clazz.newInstance();
      BeanCopier copier=getCopier(clazz,clazz);
      copier.copy(from,clone,new Converter(){
        @Override public Object convert(        Object value,        @SuppressWarnings(""String_Node_Str"") Class target,        Object context){
          return deepClone(value);
        }
      }
);
      return clone;
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + from.getClass().getCanonicalName() + ""String_Node_Str""+ from,e);
  }
}",0.9899302865995352
173966,"/** 
 * Returns   {@code true} if the arguments are deeply equal to each other and {@code false} otherwise.Two  {@code null} values are deeply equal. If both arguments are arrays, the algorithm in {@link java.util.Arrays#deepEquals(Object[],Object[]) java.util.Arrays.deepEquals}is used to determine equality. Otherwise, equality is determined by using the   {@link Object#equals equals} method of the first argument.
 * @param a an object
 * @param b an object to be compared with {@code a} for deep equality
 * @return {@code true} if the arguments are deeply equal to each other and {@code false} otherwise
 * @see java.util.Arrays#deepEquals(Object[],Object[])
 * @see java.util.Objects#equals(Object,Object)
 */
public static boolean deepEquals(Object a,Object b){
  return java.util.Objects.deepEquals(a,b);
}","/** 
 * Returns   {@code true} if the arguments are deeply equal to each other and {@code false} otherwise.Two  {@code null} values are deeply equal. If both arguments are arrays, the algorithm in {@link java.util.Arrays#deepEquals(Object[],Object[]) java.util.Arrays.deepEquals} is used to determine equality. Otherwise, equality is determined by using the {@link Object#equals equals} method of thefirst argument.
 * @param a an object
 * @param b an object to be compared with {@code a} for deep equality
 * @return {@code true} if the arguments are deeply equal to each other and {@code false} otherwise
 * @see java.util.Arrays#deepEquals(Object[],Object[])
 * @see java.util.Objects#equals(Object,Object)
 */
public static boolean deepEquals(Object a,Object b){
  return java.util.Objects.deepEquals(a,b);
}",0.9975429975429976
173967,"public static boolean isWrapperType(Class<?> clazz){
  return WRAPPER_TYPES.contains(clazz);
}","public static boolean isWrapperType(Class<?> clazz){
  if (null == clazz) {
    throw new NullPointerException();
  }
  return WRAPPER_TYPES.contains(clazz);
}",0.7430830039525692
173968,"/** 
 * Returns the hash code of a non-  {@code null} argument and 0 for a {@code null} argument.
 * @param o an object
 * @return the hash code of a non-{@code null} argument and 0 for a {@code null} argument
 * @see Object#hashCode
 */
public static int hashCode(Object o){
  return java.util.Objects.hashCode(o);
}","/** 
 * Returns the hash code of a non-  {@code null} argument and 0 for a {@code null} argument.
 * @param o an object
 * @return the hash code of a non-{@code null} argument and 0 for a {@code null} argument
 * @see Object#hashCode
 */
public static <T>int hashCode(T o){
  if (null == o || !o.getClass().isArray()) {
    return java.util.Objects.hashCode(o);
  }
 else {
    String canonicalName=o.getClass().getCanonicalName();
    if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((int[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((short[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((long[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((float[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((double[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((boolean[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((char[])o);
    }
 else     if (canonicalName.equals(""String_Node_Str"")) {
      return java.util.Arrays.hashCode((byte[])o);
    }
 else {
      return java.util.Arrays.hashCode((Object[])o);
    }
  }
}",0.3462204270051933
173969,"/** 
 * Make sure there is #no cycle reference# in the from parameter
 * @param < T > the type of source object
 * @param from the object to be clone (make sure no cycle reference in the object)
 * @return the clone object
 */
public static <T>T deepClone(T from){
  try {
    if (null == from) {
      return null;
    }
    BeanCopier copier=getCopier(from.getClass(),from.getClass());
    if (from.getClass().isArray()) {
      int length=Array.getLength(from);
      @SuppressWarnings(""String_Node_Str"") T clone=(T)Array.newInstance(from.getClass().getComponentType(),length);
      for (int i=0; i < length; i++) {
        Array.set(clone,i,deepClone(Array.get(from,i)));
      }
      return clone;
    }
 else     if (isWrapperType(from.getClass())) {
      return from;
    }
 else {
      @SuppressWarnings(""String_Node_Str"") T clone=(T)from.getClass().newInstance();
      copier.copy(from,clone,new Converter(){
        @Override public Object convert(        Object pojo,        @SuppressWarnings(""String_Node_Str"") Class fieldType,        Object fieldName){
          return deepClone(pojo);
        }
      }
);
      return clone;
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Make sure there is #no cycle reference# in the from parameter
 * @param < T > the type of source object
 * @param from the object to be clone (make sure no cycle reference in the object)
 * @return the clone object
 */
public static <T>T deepClone(T from){
  if (null == from) {
    return null;
  }
  try {
    Class<?> clazz=from.getClass();
    if (clazz.isArray()) {
      int length=Array.getLength(from);
      @SuppressWarnings(""String_Node_Str"") T clone=(T)Array.newInstance(from.getClass().getComponentType(),length);
      for (int i=0; i < length; i++) {
        Array.set(clone,i,deepClone(Array.get(from,i)));
      }
      return clone;
    }
 else     if (isBaseType(clazz)) {
      return from;
    }
 else {
      @SuppressWarnings(""String_Node_Str"") T clone=(T)clazz.newInstance();
      BeanCopier copier=getCopier(clazz,clazz);
      copier.copy(from,clone,new Converter(){
        @Override public Object convert(        Object value,        @SuppressWarnings(""String_Node_Str"") Class target,        Object context){
          return deepClone(value);
        }
      }
);
      return clone;
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + from.getClass().getCanonicalName() + ""String_Node_Str""+ from,e);
  }
}",0.8243297318927572
173970,"@Test public void testDeepClone(){
  byte b=1;
  b=Objects.deepClone(b);
  byte[] bytes=Objects.deepClone(new byte[10]);
  Array.getLength(bytes);
  Assert.assertTrue(10 == bytes.length);
  int[] ints=Objects.deepClone(new int[10]);
  Assert.assertTrue(10 == ints.length);
  PoJo pojo=new PoJo();
  pojo.setIn(0);
  ints[0]=1;
  pojo.setIns(ints);
  pojo.setObjs(new Object[10]);
  pojo.setStr(""String_Node_Str"");
  pojo.setStrs(new String[3]);
  bytes[9]=10;
  pojo.setBytes(bytes);
  pojo.getBytes()[2]=1;
  Assert.assertFalse(pojo == Objects.deepClone(pojo));
  Assert.assertTrue(0 == pojo.getIn());
  Assert.assertTrue(1 == pojo.getIns()[0]);
  Assert.assertTrue(""String_Node_Str"".equals(pojo.getStr()));
  Assert.assertTrue(10 == pojo.getBytes()[9]);
}","@Test public void testDeepClone(){
  BeanCopier bc=BeanCopier.create(String.class,String.class,false);
  String str=null;
  bc.copy(""String_Node_Str"",str,null);
  Assert.assertTrue(String.class.equals(""String_Node_Str"".getClass()));
  Assert.assertTrue(Objects.isBaseType(""String_Node_Str"".getClass()));
  Assert.assertTrue(Objects.isBaseType(String.class));
  Assert.assertTrue(Objects.isBaseType(Date.class));
  Assert.assertFalse(Objects.isWrapperType(""String_Node_Str"".getClass()));
  Assert.assertTrue(Objects.isWrapperType(new Boolean(false).getClass()));
  byte b=1;
  b=Objects.deepClone(b);
  byte[] bytes=Objects.deepClone(new byte[10]);
  Array.getLength(bytes);
  Assert.assertTrue(10 == bytes.length);
  int[] ints=Objects.deepClone(new int[10]);
  Assert.assertTrue(10 == ints.length);
  PoJo pojo=new PoJo();
  pojo.setIn(0);
  ints[0]=1;
  pojo.setIns(ints);
  pojo.setObjs(new Object[10]);
  pojo.setStr(""String_Node_Str"");
  pojo.setStrs(new String[3]);
  bytes[9]=10;
  pojo.setBytes(bytes);
  pojo.getBytes()[2]=1;
  Assert.assertFalse(pojo == Objects.deepClone(pojo));
  Assert.assertTrue(0 == pojo.getIn());
  Assert.assertTrue(1 == pojo.getIns()[0]);
  Assert.assertTrue(""String_Node_Str"".equals(pojo.getStr()));
  Assert.assertTrue(10 == pojo.getBytes()[9]);
  Assert.assertTrue(Objects.deepClone(""String_Node_Str"").equals(""String_Node_Str""));
  String[] strs=Objects.deepClone(new String[]{""String_Node_Str"",""String_Node_Str""});
  Assert.assertTrue(strs[0].equals(""String_Node_Str""));
}",0.6675485008818343
173971,"public static ObjectTextConvertor custom(final Encoding encoding,final String separate,final String linkbreak,final boolean withname,final String associate){
  return new ObjectTextConvertor(encoding,separate,linkbreak,withname,associate);
}","public static ObjectTextConvertor custom(final Encoding encoding,final Character separate,final String linkbreak,final boolean withname,final Character associate){
  return new ObjectTextConvertor(encoding,separate,linkbreak,withname,associate);
}",0.8729508196721312
173972,"/** 
 * @param bean to be converted to text string
 * @return the text string
 * @throws ReflectiveOperationException when there is any exception during conversion.
 */
private <T>String doToText(final T bean) throws ReflectiveOperationException {
  @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)bean.getClass();
  if (isBean(clazz)) {
    Field[] fields=clazz.getDeclaredFields();
    StringBuilder sb=new StringBuilder();
    Method method=null;
    String fieldName=null;
    Object fieldValue=null;
    Field f=null;
    for (int i=0; i < fields.length; i++) {
      f=fields[i];
      fieldName=f.getName().substring(0,1).toUpperCase() + f.getName().substring(1);
      f.setAccessible(true);
      fieldValue=f.get(bean);
      sb.append(fieldName);
      sb.append(associate);
      if (null != fieldValue) {
        if (0 == i && Iterable.class.isAssignableFrom(f.getType())) {
          Iterator<?> it=((Iterable<?>)fieldValue).iterator();
          while (it.hasNext()) {
            try {
              sb.append(doToText(it.next()) + linebreak);
            }
 catch (            Exception e) {
              if (e instanceof ReflectiveOperationException) {
                throw (ReflectiveOperationException)e;
              }
 else {
                throw new ReflectiveOperationException(e.getMessage());
              }
            }
          }
        }
 else {
          try {
            sb.append(baseTypeConvertor.toString(fieldValue));
          }
 catch (          Exception e) {
            if (e instanceof ReflectiveOperationException) {
              throw (ReflectiveOperationException)e;
            }
 else {
              throw new ReflectiveOperationException(e.getMessage());
            }
          }
        }
      }
      if (i < (fields.length - 1)) {
        sb.append(separate);
      }
    }
    return sb.toString();
  }
 else {
    throw new ReflectiveOperationException(""String_Node_Str"");
  }
}","/** 
 * @param bean to be converted to text string
 * @return the text string
 * @throws ReflectiveOperationException when there is any exception during conversion.
 */
private <T>String doToText(final T bean) throws ReflectiveOperationException {
  @SuppressWarnings(""String_Node_Str"") Class<T> clazz=(Class<T>)bean.getClass();
  if (isBean(clazz)) {
    Field[] fields=clazz.getDeclaredFields();
    StringBuilder sb=new StringBuilder();
    Method method=null;
    String fieldName=null;
    Object fieldValue=null;
    Field f=null;
    for (int i=0; i < fields.length; i++) {
      f=fields[i];
      fieldName=f.getName().substring(0,1).toUpperCase() + f.getName().substring(1);
      f.setAccessible(true);
      fieldValue=f.get(bean);
      if (withname) {
        sb.append(fieldName);
        sb.append(associator);
      }
      if (null != fieldValue) {
        if (0 == i && Iterable.class.isAssignableFrom(f.getType())) {
          Iterator<?> it=((Iterable<?>)fieldValue).iterator();
          while (it.hasNext()) {
            try {
              sb.append(doToText(it.next()) + linebreak);
            }
 catch (            Exception e) {
              if (e instanceof ReflectiveOperationException) {
                throw (ReflectiveOperationException)e;
              }
 else {
                throw new ReflectiveOperationException(e.getMessage());
              }
            }
          }
        }
 else {
          try {
            sb.append(baseTypeConvertor.toString(fieldValue));
          }
 catch (          Exception e) {
            if (e instanceof ReflectiveOperationException) {
              throw (ReflectiveOperationException)e;
            }
 else {
              throw new ReflectiveOperationException(e.getMessage());
            }
          }
        }
      }
      if (i < (fields.length - 1)) {
        sb.append(separator);
      }
    }
    return sb.toString();
  }
 else {
    throw new ReflectiveOperationException(""String_Node_Str"");
  }
}",0.979746835443038
173973,"/** 
 * @param text text to be convert to object
 * @param clazz target class type of object
 * @return target object
 * @throws ReflectiveOperationException when there is any exception during conversion
 */
private <T>T doToBean(final String text,final Class<T> clazz) throws ReflectiveOperationException {
  Field[] fields=clazz.getDeclaredFields();
  T bean=clazz.newInstance();
  String fieldName=null;
  if (fields.length == 1 && List.class.isAssignableFrom(fields[0].getType())) {
    fieldName=fields[0].getName().substring(0,1).toUpperCase() + fields[0].getName().substring(1);
    Class<?> genericClass=(Class<?>)((ParameterizedType)fields[0].getGenericType()).getActualTypeArguments()[0];
    List<Object> list=new ArrayList<Object>();
    String subText=text.substring(text.indexOf(associate) + 1);
    byte[] textBytes;
    try {
      textBytes=subText.getBytes(encoding.getCode());
      InputStream in=new ByteArrayInputStream(textBytes);
      BufferedReader br=new BufferedReader(new InputStreamReader(in));
      String subLine;
      while (null != (subLine=br.readLine())) {
        list.add(doToBean(subLine,genericClass));
      }
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    if (list.size() > 0) {
      Method method=clazz.getMethod(""String_Node_Str"" + fieldName,fields[0].getType());
      method.invoke(bean,list);
    }
  }
 else {
    String[] fieldTexts=text.split(separate);
    if (withname) {
      if (fieldTexts.length != fields.length) {
        throw new RuntimeException(""String_Node_Str"" + fieldTexts.length + ""String_Node_Str""+ fields.length);
      }
      for (int i=0; i < fieldTexts.length; i++) {
        try {
          fields[i].setAccessible(true);
          fields[i].set(bean,baseTypeConvertor.toObject(fieldTexts[i],fields[i].getType()));
        }
 catch (        Exception e) {
          throw new ReflectiveOperationException(e);
        }
      }
    }
 else {
      for (      String fieldText : fieldTexts) {
        String[] fieldPair=null;
        int associatorIndex=fieldText.indexOf(associate);
        if (associatorIndex > 0 && associatorIndex < fieldText.length() - 1) {
          fieldPair=new String[2];
          fieldPair[0]=fieldText.substring(0,associatorIndex);
          fieldPair[1]=fieldText.substring(associatorIndex + 1);
          Field field=clazz.getDeclaredField(fieldPair[0].substring(0,1).toLowerCase() + fieldPair[0].substring(1));
          try {
            field.setAccessible(true);
            field.set(bean,baseTypeConvertor.toObject(fieldPair[1],field.getType()));
          }
 catch (          Exception e) {
            throw new ReflectiveOperationException(e);
          }
        }
 else         if (associatorIndex != fieldText.length() - 1) {
          throw new RuntimeException(""String_Node_Str"" + fieldText);
        }
      }
    }
  }
  return bean;
}","/** 
 * @param text text to be convert to object
 * @param clazz target class type of object
 * @return target object
 * @throws ReflectiveOperationException when there is any exception during conversion
 */
private <T>T doToBean(final String text,final Class<T> clazz) throws ReflectiveOperationException {
  Field[] fields=clazz.getDeclaredFields();
  T bean=clazz.newInstance();
  String fieldName=null;
  if (fields.length == 1 && List.class.isAssignableFrom(fields[0].getType())) {
    fieldName=fields[0].getName().substring(0,1).toUpperCase() + fields[0].getName().substring(1);
    Class<?> genericClass=(Class<?>)((ParameterizedType)fields[0].getGenericType()).getActualTypeArguments()[0];
    List<Object> list=new ArrayList<Object>();
    String subText=text.substring(text.indexOf(associator) + 1);
    byte[] textBytes;
    try {
      textBytes=subText.getBytes(encoding.getCode());
      InputStream in=new ByteArrayInputStream(textBytes);
      BufferedReader br=new BufferedReader(new InputStreamReader(in));
      String subLine;
      while (null != (subLine=br.readLine())) {
        list.add(doToBean(subLine,genericClass));
      }
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    if (list.size() > 0) {
      Method method=clazz.getMethod(""String_Node_Str"" + fieldName,fields[0].getType());
      method.invoke(bean,list);
    }
  }
 else {
    String[] fieldTexts=Strings.split(text,separator);
    if (withname) {
      for (      String fieldText : fieldTexts) {
        String[] fieldPair=null;
        int associatorIndex=fieldText.indexOf(associator);
        if (associatorIndex > 0 && associatorIndex < fieldText.length() - 1) {
          fieldPair=new String[2];
          fieldPair[0]=fieldText.substring(0,associatorIndex);
          fieldPair[1]=fieldText.substring(associatorIndex + 1);
          Field field=clazz.getDeclaredField(fieldPair[0].substring(0,1).toLowerCase() + fieldPair[0].substring(1));
          try {
            field.setAccessible(true);
            field.set(bean,baseTypeConvertor.toObject(fieldPair[1],field.getType()));
          }
 catch (          Exception e) {
            throw new ReflectiveOperationException(e);
          }
        }
 else         if (associatorIndex != fieldText.length() - 1) {
          throw new RuntimeException(""String_Node_Str"" + fieldText);
        }
      }
    }
 else {
      if (fieldTexts.length != fields.length) {
        for (int i=0; i < fieldTexts.length; i++) {
          System.out.println(""String_Node_Str"" + fieldTexts[i]);
        }
        throw new RuntimeException(""String_Node_Str"" + fieldTexts.length + ""String_Node_Str""+ fields.length);
      }
      for (int i=0; i < fieldTexts.length; i++) {
        try {
          fields[i].setAccessible(true);
          fields[i].set(bean,baseTypeConvertor.toObject(fieldTexts[i],fields[i].getType()));
        }
 catch (        Exception e) {
          throw new ReflectiveOperationException(e);
        }
      }
    }
  }
  return bean;
}",0.8
173974,"public ObjectTextConvertor(Encoding encoding,String separate,String linebreak,boolean withname,String... associate){
  this.encoding=encoding;
  this.separate=separate;
  if (withname) {
    if (null == associate || null == associate[0] || 0 == associate[0].length()) {
      this.associate=associate[0];
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 else {
    this.associate=null;
  }
  this.linebreak=linebreak;
  this.baseTypeConvertor=new BaseTypeObjectStringConvertor(encoding);
  this.withname=withname;
}","public ObjectTextConvertor(Encoding encoding,Character separator,String linebreak,boolean withname,Character... associator){
  this.encoding=encoding;
  this.separator=separator;
  if (withname) {
    if (null == associator || null == associator[0]) {
      this.associator=associator[0];
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 else {
    this.associator=null;
  }
  this.linebreak=linebreak;
  this.baseTypeConvertor=new BaseTypeObjectStringConvertor(encoding);
  this.withname=withname;
}",0.8099173553719008
173975,"@Test public void testText() throws ReflectiveOperationException {
  TextPoJo pojo=new TextPoJo();
  pojo.setF1(""String_Node_Str"");
  pojo.setF3(""String_Node_Str"");
  String text=Objects.Text.toString(pojo);
  System.out.println(text);
}","@Test public void testText() throws ReflectiveOperationException {
  TextPoJo pojo=new TextPoJo();
  pojo.setF1(""String_Node_Str"");
  pojo.setF3(""String_Node_Str"");
  String text=Objects.Text.toString(pojo);
  System.out.println(text);
  TextPoJo pojo2=Objects.Text.toObject(text,TextPoJo.class);
  System.out.println(pojo2.getF1());
  System.out.println(pojo2.getF3());
  Assert.assertTrue(pojo2.getF1() == pojo2.getF1() && pojo2.getF1().equals(""String_Node_Str""));
  Assert.assertTrue(pojo2.getF3() == pojo2.getF3() && pojo2.getF3().equals(""String_Node_Str""));
}",0.5917602996254682
173976,"@Test public void test() throws Exception {
  Map map=new HashMap();
  Urls.parseParameters(map,null);
  String text1=""String_Node_Str"";
  Map<String,String> m=new HashMap<String,String>();
  Urls.parseParameters(m,text1);
  System.out.println(m.get(""String_Node_Str"").toString());
  System.out.println(m.get(""String_Node_Str"").toString());
  System.out.println(Urls.buildQueryData(m));
  Urls.parseParameters(m,text1,null);
}","@Test public void test() throws Exception {
  Map map=new HashMap();
  Urls.parseParameters(map,null);
  String text1=""String_Node_Str"";
  Map<String,String> m=new HashMap<String,String>();
  Urls.parseParameters(m,text1);
  System.out.println(m.get(""String_Node_Str"").toString());
  System.out.println(m.get(""String_Node_Str"").toString());
  System.out.println(Urls.buildQueryData(m));
  thrown.expect(NullPointerException.class);
  thrown.expectMessage(""String_Node_Str"");
  Urls.parseParameters(m,text1,null);
}",0.9063829787234042
173977,"@SuppressWarnings(""String_Node_Str"") public String getPreferredPrefix(String namespaceUri,String suggestion,boolean requirePrefix){
  String prefix=nspref.get(namespaceUri);
  if (prefix != null) {
    return prefix;
  }
  if (namespaceUri.equals(WellKnownNamespace.XML_SCHEMA_INSTANCE))   return ""String_Node_Str"";
  if (namespaceUri.equals(WellKnownNamespace.XML_SCHEMA))   return ""String_Node_Str"";
  if (namespaceUri.equals(WellKnownNamespace.XML_MIME_URI))   return ""String_Node_Str"";
  return suggestion;
}","@SuppressWarnings(""String_Node_Str"") public String getPreferredPrefix(String namespaceUri,String suggestion,boolean requirePrefix){
  String prefix=nspref.get(namespaceUri);
  if (prefix != null) {
    return prefix;
  }
  return suggestion;
}",0.5986754966887418
173978,"/** 
 * Convert from object to XML string
 */
public String toString(final Object obj) throws JAXBException {
  JAXBContext cachedContext=getCachedContext(obj.getClass());
  Marshaller marshaller=cachedContext.createMarshaller();
  try {
    marshaller.setProperty(Marshaller.JAXB_ENCODING,encoding.getCode());
    marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,formatted);
    if (Strings.isEmpty(headers)) {
      marshaller.setProperty(Marshaller.JAXB_FRAGMENT,fragment);
    }
 else {
      marshaller.setProperty(""String_Node_Str"",headers);
    }
    if (null != namespacePrefixMapper) {
      System.out.println(""String_Node_Str"");
      NamespacePrefixMapper mapper=new DefaultNamespacePrefixMapper(namespacePrefixMapper);
      marshaller.setProperty(""String_Node_Str"",mapper);
    }
  }
 catch (  PropertyException e) {
    throw new JAXBException(e);
  }
catch (  IllegalArgumentException e) {
    throw new JAXBException(e);
  }
  StringWriter writer=new StringWriter();
  marshaller.marshal(obj,writer);
  return writer.toString();
}","/** 
 * Convert from object to XML string
 */
public String toString(final Object obj) throws JAXBException {
  JAXBContext cachedContext=getCachedContext(obj.getClass());
  Marshaller marshaller=cachedContext.createMarshaller();
  StringWriter writer=new StringWriter();
  try {
    marshaller.setProperty(Marshaller.JAXB_ENCODING,encoding.getCode());
    marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,formatted);
    if (Strings.isEmpty(headers)) {
      marshaller.setProperty(Marshaller.JAXB_FRAGMENT,fragment);
    }
 else {
      marshaller.setProperty(Marshaller.JAXB_FRAGMENT,true);
      writer.write(headers);
    }
    if (null != namespacePrefixMapper) {
      NamespacePrefixMapper mapper=new DefaultNamespacePrefixMapper(namespacePrefixMapper);
      marshaller.setProperty(""String_Node_Str"",mapper);
    }
  }
 catch (  PropertyException e) {
    throw new JAXBException(e);
  }
catch (  IllegalArgumentException e) {
    throw new JAXBException(e);
  }
  marshaller.marshal(obj,writer);
  return writer.toString();
}",0.9083969465648856
173979,"@Test public void testXML() throws JAXBException {
  byte b=1;
  b=Objects.deepClone(b);
  byte[] bytes=Objects.deepClone(new byte[10]);
  Array.getLength(bytes);
  Assert.assertTrue(10 == bytes.length);
  int[] ints=Objects.deepClone(new int[10]);
  Assert.assertTrue(10 == ints.length);
  PoJo pojo=new PoJo();
  pojo.setIn(0);
  ints[0]=1;
  pojo.setIns(ints);
  pojo.setObjs(new Object[10]);
  pojo.setStr(""String_Node_Str"");
  pojo.setStrs(new String[3]);
  bytes[9]=10;
  pojo.setBytes(bytes);
  pojo.getBytes()[2]=1;
  String xml=Objects.Xml.toString(pojo);
  ObjectsXml xmlConvertor=Objects.Xml.custom(null,false,Encoding.GB18030,true,""String_Node_Str"");
  String xml2=xmlConvertor.toString(pojo);
  System.out.println(xml);
  System.out.println(xml2);
  PoJo pojo2=Objects.Xml.toObject(xml,PoJo.class);
  Assert.assertTrue(0 == pojo2.getIn());
  Assert.assertTrue(1 == pojo2.getIns()[0]);
  Assert.assertTrue(""String_Node_Str"".equals(pojo2.getStr()));
  Assert.assertTrue(10 == pojo2.getBytes()[9]);
}","@Test public void testXML() throws JAXBException {
  byte b=1;
  b=Objects.deepClone(b);
  byte[] bytes=Objects.deepClone(new byte[10]);
  Array.getLength(bytes);
  Assert.assertTrue(10 == bytes.length);
  int[] ints=Objects.deepClone(new int[10]);
  Assert.assertTrue(10 == ints.length);
  PoJo pojo=new PoJo();
  pojo.setIn(0);
  ints[0]=1;
  pojo.setIns(ints);
  pojo.setObjs(new Object[10]);
  pojo.setStr(""String_Node_Str"");
  pojo.setStrs(new String[3]);
  bytes[9]=10;
  pojo.setBytes(bytes);
  pojo.getBytes()[2]=1;
  String xml=Objects.Xml.toString(pojo);
  System.out.println(xml);
  PoJo pojo2=Objects.Xml.toObject(xml,PoJo.class);
  Assert.assertTrue(0 == pojo2.getIn());
  Assert.assertTrue(1 == pojo2.getIns()[0]);
  Assert.assertTrue(""String_Node_Str"".equals(pojo2.getStr()));
  Assert.assertTrue(10 == pojo2.getBytes()[9]);
  ObjectsXml xmlConvertor=Objects.Xml.custom(null,false,Encoding.GB18030,false,""String_Node_Str"");
  xml=xmlConvertor.toString(pojo);
  System.out.println(xml);
  pojo2=xmlConvertor.toObject(xml,PoJo.class);
  Assert.assertTrue(0 == pojo2.getIn());
  Assert.assertTrue(1 == pojo2.getIns()[0]);
  Assert.assertTrue(""String_Node_Str"".equals(pojo2.getStr()));
  Assert.assertTrue(10 == pojo2.getBytes()[9]);
}",0.7287234042553191
173980,"@Test public void testText() throws ReflectiveOperationException {
  TextPoJo pojo=new TextPoJo();
  pojo.setF1(""String_Node_Str"");
  pojo.setF3(""String_Node_Str"");
  String text=Objects.Text.toString(pojo);
  System.out.println(text);
  TextPoJo pojo2=Objects.Text.toObject(text,TextPoJo.class);
  Assert.assertTrue(pojo2.getF1() == pojo2.getF1() && pojo2.getF1().equals(""String_Node_Str""));
  Assert.assertTrue(pojo2.getF3() == pojo2.getF3() && pojo2.getF3().equals(""String_Node_Str""));
  ObjectsText convertor=Objects.Text.custom(Encoding.GB18030,'|',""String_Node_Str"",true,'=');
  text=convertor.toString(pojo);
  System.out.println(text);
  pojo2=convertor.toObject(text,TextPoJo.class);
  Assert.assertTrue(pojo2.getF1() == pojo2.getF1() && pojo2.getF1().equals(""String_Node_Str""));
  Assert.assertTrue(pojo2.getF3() == pojo2.getF3() && pojo2.getF3().equals(""String_Node_Str""));
  TextPoJo2 textPoJo2=new TextPoJo2();
  textPoJo2.setList(new ArrayList<TextPoJo>());
  textPoJo2.getList().add(pojo2);
  textPoJo2.getList().add(pojo);
  textPoJo2.getList().add(pojo);
  text=Objects.Text.toString(textPoJo2);
  System.out.println(text);
  TextPoJo2 textPoJo3=Objects.Text.toObject(text,TextPoJo2.class);
  Assert.assertTrue(textPoJo2.getList().get(0).getF1() == pojo2.getF1() && pojo2.getF1().equals(""String_Node_Str""));
  Assert.assertTrue(textPoJo2.getList().get(0).getF3() == pojo2.getF3() && pojo2.getF3().equals(""String_Node_Str""));
}","@Test public void testText() throws ReflectiveOperationException {
  TextPoJo pojo=new TextPoJo();
  pojo.setF1(""String_Node_Str"");
  pojo.setF3(""String_Node_Str"");
  String text=Objects.Text.toString(pojo);
  System.out.println(text);
  TextPoJo pojo2=Objects.Text.toObject(text,TextPoJo.class);
  Assert.assertTrue(pojo2.getF1() == pojo2.getF1() && pojo2.getF1().equals(""String_Node_Str""));
  Assert.assertTrue(pojo2.getF3() == pojo2.getF3() && pojo2.getF3().equals(""String_Node_Str""));
  ObjectsText convertor=Objects.Text.custom(Encoding.GB18030,'|',""String_Node_Str"",true,'=');
  text=convertor.toString(pojo);
  System.out.println(text);
  pojo2=convertor.toObject(text,TextPoJo.class);
  Assert.assertTrue(pojo2.getF1() == pojo2.getF1() && pojo2.getF1().equals(""String_Node_Str""));
  Assert.assertTrue(pojo2.getF3() == pojo2.getF3() && pojo2.getF3().equals(""String_Node_Str""));
  TextPoJo2 textPoJo2=new TextPoJo2();
  textPoJo2.setList(new ArrayList<TextPoJo>());
  textPoJo2.getList().add(pojo2);
  textPoJo2.getList().add(pojo);
  textPoJo2.getList().add(pojo);
  text=Objects.Text.toString(textPoJo2);
  System.out.println(text);
  TextPoJo2 textPoJo3=Objects.Text.toObject(text,TextPoJo2.class);
  Assert.assertTrue(textPoJo2.getList().get(0).getF1() == pojo2.getF1() && pojo2.getF1().equals(""String_Node_Str""));
  Assert.assertTrue(textPoJo2.getList().get(0).getF3() == pojo2.getF3() && pojo2.getF3().equals(""String_Node_Str""));
  text=convertor.toString(textPoJo2);
  System.out.println(text);
  textPoJo3=convertor.toObject(text,TextPoJo2.class);
  Assert.assertTrue(textPoJo2.getList().get(0).getF1() == pojo2.getF1() && pojo2.getF1().equals(""String_Node_Str""));
  Assert.assertTrue(textPoJo2.getList().get(0).getF3() == pojo2.getF3() && pojo2.getF3().equals(""String_Node_Str""));
}",0.8907407407407407
173981,"@Override public IToken evaluate(ICharacterScanner scanner,boolean resume){
  char start=(char)scanner.read();
  if (!isWordStart(start)) {
    scanner.unread();
    return Token.UNDEFINED;
  }
  ScanContext context=new ScanContext();
  context.state=State.INITIAL;
  do {
    char c=(char)scanner.read();
    if (ICharacterScanner.EOF == c || (!isWordPart(c,context))) {
      scanner.unread();
      break;
    }
    if (context.hasEndReached()) {
      break;
    }
    if (context.state == State.INITIAL) {
      context.state=State.NORMAL;
    }
  }
 while (true);
  return getSuccessToken();
}","@Override public IToken evaluate(ICharacterScanner scanner,boolean resume){
  char start=(char)scanner.read();
  if (!isWordStart(start)) {
    scanner.unread();
    return Token.UNDEFINED;
  }
  ScanContext context=new ScanContext();
  context.state=State.INITIAL;
  do {
    int read=scanner.read();
    char c=(char)read;
    if (ICharacterScanner.EOF == read || (!isWordPart(c,context))) {
      scanner.unread();
      break;
    }
    if (context.hasEndReached()) {
      break;
    }
    if (context.state == State.INITIAL) {
      context.state=State.NORMAL;
    }
  }
 while (true);
  return getSuccessToken();
}",0.9360655737704918
173982,"private boolean selectfirstMatching(Object[] elements){
  if (treeViewer == null) {
    return false;
  }
  if (textFilter == null) {
    return false;
  }
  if (elements == null) {
    return false;
  }
  for (int i=0; i < elements.length; i++) {
    Object element=elements[i];
    if (textFilter.isMatching(element)) {
      StructuredSelection selection=new StructuredSelection(element);
      treeViewer.setSelection(selection,true);
      return true;
    }
    ITreeContentProvider contentProvider=getTreeContentProvider();
    Object[] children=contentProvider.getChildren(element);
    boolean selectionDone=selectfirstMatching(children);
    if (selectionDone) {
      return true;
    }
  }
  return false;
}","private boolean selectfirstMatching(Object[] elements){
  if (treeViewer == null) {
    return false;
  }
  if (textFilter == null) {
    return false;
  }
  if (elements == null) {
    return false;
  }
  for (int i=0; i < elements.length; i++) {
    Object element=elements[i];
    if (Boolean.TRUE.equals(textFilter.isMatchingOrNull(element))) {
      StructuredSelection selection=new StructuredSelection(element);
      treeViewer.setSelection(selection,true);
      return true;
    }
    ITreeContentProvider contentProvider=getTreeContentProvider();
    Object[] children=contentProvider.getChildren(element);
    boolean selectionDone=selectfirstMatching(children);
    if (selectionDone) {
      return true;
    }
  }
  return false;
}",0.9815699658703072
173983,"private boolean selectTreePath(Viewer viewer,TreePath parentPath,Object element){
  for (int i=0; i < parentPath.getSegmentCount() - 1; i++) {
    if (element.equals(parentPath.getSegment(i))) {
      return false;
    }
  }
  if (!(viewer instanceof TreeViewer)) {
    return true;
  }
  if (matcher == null) {
    return true;
  }
  TreeViewer treeViewer=(TreeViewer)viewer;
  Boolean matchingResult=isMatching(element);
  if (matchingResult != null) {
    return matchingResult;
  }
  return hasUnfilteredChild(treeViewer,parentPath,element);
}","private boolean selectTreePath(Viewer viewer,TreePath parentPath,Object element){
  for (int i=0; i < parentPath.getSegmentCount() - 1; i++) {
    if (element.equals(parentPath.getSegment(i))) {
      return false;
    }
  }
  if (!(viewer instanceof TreeViewer)) {
    return true;
  }
  if (matcher == null) {
    return true;
  }
  TreeViewer treeViewer=(TreeViewer)viewer;
  Boolean matchingResult=isMatchingOrNull(element);
  if (matchingResult != null) {
    return matchingResult;
  }
  return hasUnfilteredChild(treeViewer,parentPath,element);
}",0.9945454545454544
173984,"/** 
 * Creates configuration by given adaptable
 * @param adaptable must provide  {@link ColorManager} and {@link IFile}
 */
public BashSourceViewerConfiguration(IAdaptable adaptable){
  Assert.isNotNull(adaptable,""String_Node_Str"");
  this.annotationHoover=new BashEditorAnnotationHoover();
  this.colorManager=adaptable.getAdapter(ColorManager.class);
  Assert.isNotNull(colorManager,""String_Node_Str"");
  this.defaultTextAttribute=new TextAttribute(colorManager.getColor(getPreferences().getColor(COLOR_NORMAL_TEXT)));
  this.adaptable=adaptable;
}","/** 
 * Creates configuration by given adaptable
 * @param adaptable must provide  {@link ColorManager} and {@link IFile}
 */
public BashSourceViewerConfiguration(IAdaptable adaptable){
  IPreferenceStore generalTextStore=EditorsUI.getPreferenceStore();
  this.fPreferenceStore=new ChainedPreferenceStore(new IPreferenceStore[]{getPreferences().getPreferenceStore(),generalTextStore});
  Assert.isNotNull(adaptable,""String_Node_Str"");
  this.annotationHoover=new BashEditorAnnotationHoover();
  this.colorManager=adaptable.getAdapter(ColorManager.class);
  Assert.isNotNull(colorManager,""String_Node_Str"");
  this.defaultTextAttribute=new TextAttribute(colorManager.getColor(getPreferences().getColor(COLOR_NORMAL_TEXT)));
  this.adaptable=adaptable;
}",0.8466257668711656
173985,"/** 
 * A very simple variable handling: <br> We differt between: <html> <table border='1'> <tr> <th>Expression</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>$a</td> <td>STANDARD</td> <td>Termination by followed whitespace, string start, or special variable ending e.g. for $$</td> </tr> <tr> <td>$a['arrayname']</td> <td>STANDARD</td> <td>Termination by last balanced ']'</td> </tr> <tr> <td>${...}</td> <td>CURLY_BRACED</td> <td>Termination by last balanced '}'</td> </tr> <tr> <td>$(...)</td> <td>GROUPED</td> <td>Termination by last balanced ')'</td> </tr> </table> </html>
 * @param context
 * @return
 */
private boolean isVariableStateHandled(ParseContext context){
  char c=context.getCharAtPos();
  if (context.inState(CODE) || context.inState(INIT)) {
    if (c == '$') {
      context.addTokenAndResetText();
      context.appendCharToText();
      context.switchTo(VARIABLE);
      return true;
    }
    return false;
  }
  if (!context.inState(VARIABLE)) {
    return false;
  }
  VariableContext variableContext=context.getVariableContext();
  VariableType type=variableContext.getType();
  if (type == null || type == VariableType.INITIAL) {
    return handleInitialVariableTypeDetermination(context,c);
  }
 else   if (type == VariableType.GROUPED) {
    return handleGroupedVariable(context);
  }
 else   if (type == VariableType.CURLY_BRACED) {
    return handleCurlyBracedVariable(context,c,variableContext);
  }
 else   if (type == VariableType.STANDARD) {
    return handleStandardVariables(context,c,variableContext);
  }
 else {
    return false;
  }
}","/** 
 * A very simple variable handling: <br> We differt between: <html> <table border='1'> <tr> <th>Expression</th> <th>Type</th> <th>Description</th> </tr> <tr> <td>$a</td> <td>STANDARD</td> <td>Termination by followed whitespace, string start, or special variable ending e.g. for $$</td> </tr> <tr> <td>$a['arrayname']</td> <td>STANDARD</td> <td>Termination by last balanced ']'</td> </tr> <tr> <td>${...}</td> <td>CURLY_BRACED</td> <td>Termination by last balanced '}'</td> </tr> <tr> <td>$(...)</td> <td>GROUPED</td> <td>Termination by last balanced ')'</td> </tr> </table> </html>
 * @param context
 * @return
 */
private boolean isVariableStateHandled(ParseContext context){
  char c=context.getCharAtPos();
  if (context.inState(CODE) || context.inState(INIT)) {
    if (c == '$') {
      context.addTokenAndResetText();
      context.currentToken.start--;
      context.appendCharToText();
      context.switchTo(VARIABLE);
      return true;
    }
    return false;
  }
  if (!context.inState(VARIABLE)) {
    return false;
  }
  VariableContext variableContext=context.getVariableContext();
  VariableType type=variableContext.getType();
  if (type == null || type == VariableType.INITIAL) {
    return handleInitialVariableTypeDetermination(context,c);
  }
 else   if (type == VariableType.GROUPED) {
    return handleGroupedVariable(context);
  }
 else   if (type == VariableType.CURLY_BRACED) {
    return handleCurlyBracedVariable(context,c,variableContext);
  }
 else   if (type == VariableType.STANDARD) {
    return handleStandardVariables(context,c,variableContext);
  }
 else {
    return false;
  }
}",0.9887710542732376
173986,"private void parse(ParseContext context){
  char c=context.getCharAtPos();
  if (context.inState(VARIABLE)) {
    if (c == '$') {
      context.appendCharToText();
      return;
    }
    if (c == '#') {
      context.appendCharToText();
      return;
    }
    if (c == '[') {
      context.variableArrayOpened();
      context.appendCharToText();
      return;
    }
    if (c == ']') {
      context.variableArrayClosed();
      context.appendCharToText();
      return;
    }
    if (c == '{' || c == '}') {
      context.appendCharToText();
      if (c == '}') {
        context.addTokenAndResetText();
        context.switchTo(CODE);
      }
      return;
    }
    if (Character.isWhitespace(c)) {
      context.addTokenAndResetText();
      return;
    }
    if (context.isInsideVariableArray()) {
      if (isStringChar(c)) {
        context.appendCharToText();
        return;
      }
      context.appendCharToText();
      return;
    }
 else {
      if (Character.isWhitespace(c)) {
        context.addTokenAndResetText();
        context.switchTo(ParserState.CODE);
        return;
      }
      if (isStringChar(c)) {
        context.addTokenAndResetText();
        context.switchTo(ParserState.CODE);
      }
 else {
        context.appendCharToText();
        return;
      }
    }
  }
  if (context.inState(INSIDE_COMMENT)) {
    if (c == '\n') {
      context.addTokenAndResetText();
      context.switchTo(CODE);
      return;
    }
 else {
      context.appendCharToText();
    }
    return;
  }
  if (c == '\'') {
    handleString(INSIDE_SINGLE_STRING,context,INSIDE_DOUBLE_TICKED,INSIDE_DOUBLE_STRING);
    return;
  }
  if (c == '\""') {
    handleString(INSIDE_DOUBLE_STRING,context,INSIDE_DOUBLE_TICKED,INSIDE_SINGLE_STRING);
    return;
  }
  if (c == '`') {
    handleString(INSIDE_DOUBLE_TICKED,context,INSIDE_SINGLE_STRING,INSIDE_DOUBLE_STRING);
    return;
  }
  if (context.insideString()) {
    context.appendCharToText();
    return;
  }
  if (c == '\r') {
    context.moveCurrentPosWhenEmptyText();
    return;
  }
  if (c == '\n') {
    context.addTokenAndResetText();
    if (context.inState(INSIDE_COMMENT)) {
      context.switchTo(CODE);
    }
    return;
  }
  if (c == ';') {
    context.addTokenAndResetText();
    context.switchTo(CODE);
    return;
  }
  if (c == '=') {
    context.appendCharToText();
    if (!context.inState(VARIABLE)) {
      context.addTokenAndResetText();
    }
    return;
  }
  if (c == '$') {
    context.appendCharToText();
    context.switchTo(VARIABLE);
    return;
  }
  if (c == '{' || c == '}') {
    context.addTokenAndResetText();
    context.appendCharToText();
    context.addTokenAndResetText();
    context.switchTo(CODE);
    return;
  }
  if (c == '#') {
    context.addTokenAndResetText();
    context.switchTo(INSIDE_COMMENT);
    context.appendCharToText();
  }
 else {
    if (Character.isWhitespace(c)) {
      context.addTokenAndResetText();
      return;
    }
    context.appendCharToText();
  }
}","private void parse(ParseContext context){
  char c=context.getCharAtPos();
  if (context.inState(VARIABLE)) {
    if (c == '$') {
      context.appendCharToText();
      return;
    }
    if (c == '#') {
      context.appendCharToText();
      return;
    }
    if (c == '[') {
      context.variableArrayOpened();
      context.appendCharToText();
      return;
    }
    if (c == ']') {
      context.variableArrayClosed();
      context.appendCharToText();
      return;
    }
    if (c == '{' || c == '}') {
      context.appendCharToText();
      if (c == '}') {
        context.addTokenAndResetText();
        context.switchTo(CODE);
      }
      return;
    }
    if (Character.isWhitespace(c)) {
      context.addTokenAndResetText();
      return;
    }
    if (context.isInsideVariableArray()) {
      if (isStringChar(c)) {
        context.appendCharToText();
        return;
      }
      context.appendCharToText();
      return;
    }
 else {
      if (Character.isWhitespace(c)) {
        context.addTokenAndResetText();
        context.switchTo(ParserState.CODE);
        return;
      }
      if (isStringChar(c)) {
        context.addTokenAndResetText();
        context.switchTo(ParserState.CODE);
      }
 else {
        context.appendCharToText();
        return;
      }
    }
  }
  if (context.inState(INSIDE_COMMENT)) {
    if (c == '\n') {
      context.addTokenAndResetText();
      context.switchTo(CODE);
      return;
    }
 else {
      context.appendCharToText();
    }
    return;
  }
  if (c == '\'') {
    handleString(INSIDE_SINGLE_STRING,context,INSIDE_DOUBLE_TICKED,INSIDE_DOUBLE_STRING);
    return;
  }
  if (c == '\""') {
    handleString(INSIDE_DOUBLE_STRING,context,INSIDE_DOUBLE_TICKED,INSIDE_SINGLE_STRING);
    return;
  }
  if (c == '`') {
    handleString(INSIDE_DOUBLE_TICKED,context,INSIDE_SINGLE_STRING,INSIDE_DOUBLE_STRING);
    return;
  }
  if (context.insideString()) {
    context.appendCharToText();
    return;
  }
  if (c == '\r') {
    context.moveCurrentPosWhenEmptyText();
    return;
  }
  if (c == '\n') {
    context.addTokenAndResetText();
    if (context.inState(INSIDE_COMMENT)) {
      context.switchTo(CODE);
    }
    return;
  }
  if (c == ';') {
    context.addTokenAndResetText();
    context.switchTo(CODE);
    return;
  }
  if (c == '=') {
    context.appendCharToText();
    if (!context.inState(VARIABLE)) {
      context.addTokenAndResetText();
    }
    return;
  }
  if (c == '$') {
    context.addTokenAndResetText();
    context.appendCharToText();
    context.switchTo(VARIABLE);
    return;
  }
  if (c == '{' || c == '}') {
    context.addTokenAndResetText();
    context.appendCharToText();
    context.addTokenAndResetText();
    context.switchTo(CODE);
    return;
  }
  if (c == '#') {
    context.addTokenAndResetText();
    context.switchTo(INSIDE_COMMENT);
    context.appendCharToText();
  }
 else {
    if (Character.isWhitespace(c)) {
      context.addTokenAndResetText();
      return;
    }
    context.appendCharToText();
  }
}",0.994013967409378
173987,"@Test public void bugfix_45() throws Exception {
  String string=""String_Node_Str"";
  List<ParseToken> tokens=parserToTest.parse(string);
  assertThat(tokens).containsTokens(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@Test public void bugfix_45() throws Exception {
  String string=""String_Node_Str"";
  List<ParseToken> tokens=parserToTest.parse(string);
  assertThat(tokens).containsTokens(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.927710843373494
173988,"public void rebuildOutline(){
  String text=getDocumentText();
  IPreferenceStore store=BashEditorUtil.getPreferences().getPreferenceStore();
  final boolean validateBlocks=store.getBoolean(VALIDATE_BLOCK_STATEMENTS.getId());
  final boolean validateDo=store.getBoolean(VALIDATE_DO_STATEMENTS.getId());
  final boolean validateIf=store.getBoolean(VALIDATE_IF_STATEMENTS.getId());
  final boolean validateFunctions=store.getBoolean(VALIDATE_IF_STATEMENTS.getId());
  EclipseUtil.safeAsyncExec(new Runnable(){
    @Override public void run(){
      BashEditorUtil.removeScriptErrors(BashEditor.this);
      modelBuilder.setIgnoreBlockValidation(!validateBlocks);
      modelBuilder.setIgnoreDoValidation(!validateDo);
      modelBuilder.setIgnoreIfValidation(!validateIf);
      modelBuilder.setIgnoreFunctionValidation(!validateFunctions);
      BashScriptModel model=modelBuilder.build(text);
      getOutlinePage().rebuild(model);
      if (model.hasErrors()) {
        addErrorMarkers(model);
      }
    }
  }
);
}","/** 
 * Does rebuild the outline - this is done asynchronous
 */
public void rebuildOutline(){
  String text=getDocumentText();
  IPreferenceStore store=BashEditorUtil.getPreferences().getPreferenceStore();
  final boolean validateBlocks=store.getBoolean(VALIDATE_BLOCK_STATEMENTS.getId());
  final boolean validateDo=store.getBoolean(VALIDATE_DO_STATEMENTS.getId());
  final boolean validateIf=store.getBoolean(VALIDATE_IF_STATEMENTS.getId());
  final boolean validateFunctions=store.getBoolean(VALIDATE_IF_STATEMENTS.getId());
  EclipseUtil.safeAsyncExec(new Runnable(){
    @Override public void run(){
      BashEditorUtil.removeScriptErrors(BashEditor.this);
      modelBuilder.setIgnoreBlockValidation(!validateBlocks);
      modelBuilder.setIgnoreDoValidation(!validateDo);
      modelBuilder.setIgnoreIfValidation(!validateIf);
      modelBuilder.setIgnoreFunctionValidation(!validateFunctions);
      BashScriptModel model=modelBuilder.build(text);
      getOutlinePage().rebuild(model);
      if (model.hasErrors()) {
        addErrorMarkers(model);
      }
    }
  }
);
}",0.9690328727965698
173989,"public void createControl(Composite parent){
  super.createControl(parent);
  labelProvider=new BashEditorOutlineLabelProvider();
  TreeViewer viewer=getTreeViewer();
  viewer.setContentProvider(contentProvider);
  viewer.addDoubleClickListener(this);
  viewer.setLabelProvider(new DelegatingStyledCellLabelProvider(labelProvider));
  viewer.addSelectionChangedListener(this);
  if (input != null) {
    viewer.setInput(input);
  }
}","public void createControl(Composite parent){
  super.createControl(parent);
  labelProvider=new BashEditorOutlineLabelProvider();
  TreeViewer viewer=getTreeViewer();
  viewer.setContentProvider(contentProvider);
  viewer.addDoubleClickListener(this);
  viewer.setLabelProvider(new DelegatingStyledCellLabelProvider(labelProvider));
  viewer.addSelectionChangedListener(this);
  if (input != null) {
    viewer.setInput(input);
  }
  if (input == null && editor != null) {
    editor.rebuildOutline();
  }
}",0.9212765957446808
173990,"void switchTo(ParserState parserState){
  this.parserState=parserState;
  if (ParserState.VARIABLE.equals(parserState)) {
    variableState=VariableState.NO_ARRAY;
  }
}","void switchTo(ParserState parserState){
  this.parserState=parserState;
  if (ParserState.VARIABLE.equals(parserState)) {
    getVariableContext().variableState=VariableState.NO_ARRAY;
  }
 else {
    variableContext=null;
  }
}",0.8513853904282116
173991,"private void parse(ParseContext context){
  char c=context.getCharAtPos();
  if (context.inState(VARIABLE)) {
    if (c == '$') {
      context.appendCharToText();
      return;
    }
    if (c == '#') {
      context.appendCharToText();
      return;
    }
    if (c == '[') {
      context.variableArrayOpened();
      context.appendCharToText();
      return;
    }
    if (c == ']') {
      context.variableArrayClosed();
      context.appendCharToText();
      return;
    }
    if (c == '{' || c == '}') {
      context.appendCharToText();
      if (c == '}') {
        context.addTokenAndResetText();
        context.switchTo(CODE);
      }
      return;
    }
    if (Character.isWhitespace(c)) {
      context.addTokenAndResetText();
      return;
    }
    if (context.isInsideVariableArray()) {
      if (isStringChar(c)) {
        context.appendCharToText();
        return;
      }
      context.appendCharToText();
      return;
    }
 else {
      if (Character.isWhitespace(c)) {
        context.addTokenAndResetText();
        context.switchTo(ParserState.CODE);
        return;
      }
      if (isStringChar(c)) {
        context.addTokenAndResetText();
        context.switchTo(ParserState.CODE);
      }
 else {
        context.appendCharToText();
        return;
      }
    }
  }
  if (context.inState(INSIDE_COMMENT)) {
    if (c == '\n') {
      context.addTokenAndResetText();
      context.switchTo(CODE);
      return;
    }
 else {
      context.appendCharToText();
    }
    return;
  }
  if (c == '\'') {
    handleString(INSIDE_SINGLE_STRING,context,INSIDE_DOUBLE_TICKED,INSIDE_DOUBLE_STRING);
    return;
  }
  if (c == '\""') {
    handleString(INSIDE_DOUBLE_STRING,context,INSIDE_DOUBLE_TICKED,INSIDE_SINGLE_STRING);
    return;
  }
  if (c == '`') {
    handleString(INSIDE_DOUBLE_TICKED,context,INSIDE_SINGLE_STRING,INSIDE_DOUBLE_STRING);
    return;
  }
  if (context.insideString()) {
    context.appendCharToText();
    return;
  }
  if (c == '\r') {
    context.moveCurrentPosWhenEmptyText();
    return;
  }
  if (c == '\n') {
    context.addTokenAndResetText();
    if (context.inState(INSIDE_COMMENT)) {
      context.switchTo(CODE);
    }
    return;
  }
  if (c == ';') {
    context.addTokenAndResetText();
    context.switchTo(CODE);
    return;
  }
  if (c == '=') {
    context.appendCharToText();
    if (!context.inState(VARIABLE)) {
      context.addTokenAndResetText();
    }
    return;
  }
  if (c == '$') {
    context.addTokenAndResetText();
    context.appendCharToText();
    context.switchTo(VARIABLE);
    return;
  }
  if (c == '{' || c == '}') {
    context.addTokenAndResetText();
    context.appendCharToText();
    context.addTokenAndResetText();
    context.switchTo(CODE);
    return;
  }
  if (c == '#') {
    context.addTokenAndResetText();
    context.switchTo(INSIDE_COMMENT);
    context.appendCharToText();
  }
 else {
    if (Character.isWhitespace(c)) {
      context.addTokenAndResetText();
      return;
    }
    context.appendCharToText();
  }
}","private void parse(ParseContext context){
  char c=context.getCharAtPos();
  if (context.inState(VARIABLE)) {
    VariableContext variableContext=context.getVariableContext();
    if (c == '$') {
      context.appendCharToText();
      return;
    }
    if (c == '#') {
      context.appendCharToText();
      return;
    }
    if (c == '[') {
      variableContext.variableArrayOpened();
      context.appendCharToText();
      return;
    }
    if (c == ']') {
      variableContext.variableArrayClosed();
      context.appendCharToText();
      return;
    }
    if (c == '{' || c == '}') {
      context.appendCharToText();
      if (c == '{') {
        variableContext.incrementVariableOpenCurlyBraces();
      }
      if (c == '}') {
        variableContext.incrementVariableCloseCurlyBraces();
      }
      if (c == '}' && variableContext.areVariableCurlyBracesBalanced()) {
        context.addTokenAndResetText();
        context.switchTo(CODE);
      }
      return;
    }
    if (Character.isWhitespace(c)) {
      context.addTokenAndResetText();
      return;
    }
    if (variableContext.isInsideVariableArray()) {
      if (isStringChar(c)) {
        context.appendCharToText();
        return;
      }
      context.appendCharToText();
      return;
    }
 else {
      if (Character.isWhitespace(c)) {
        context.addTokenAndResetText();
        context.switchTo(ParserState.CODE);
        return;
      }
      if (isStringChar(c)) {
        context.addTokenAndResetText();
        context.switchTo(ParserState.CODE);
      }
 else {
        context.appendCharToText();
        return;
      }
    }
  }
  if (context.inState(INSIDE_COMMENT)) {
    if (c == '\n') {
      context.addTokenAndResetText();
      context.switchTo(CODE);
      return;
    }
 else {
      context.appendCharToText();
    }
    return;
  }
  if (c == '\'') {
    handleString(INSIDE_SINGLE_STRING,context,INSIDE_DOUBLE_TICKED,INSIDE_DOUBLE_STRING);
    return;
  }
  if (c == '\""') {
    handleString(INSIDE_DOUBLE_STRING,context,INSIDE_DOUBLE_TICKED,INSIDE_SINGLE_STRING);
    return;
  }
  if (c == '`') {
    handleString(INSIDE_DOUBLE_TICKED,context,INSIDE_SINGLE_STRING,INSIDE_DOUBLE_STRING);
    return;
  }
  if (context.insideString()) {
    context.appendCharToText();
    return;
  }
  if (c == '\r') {
    context.moveCurrentPosWhenEmptyText();
    return;
  }
  if (c == '\n') {
    context.addTokenAndResetText();
    if (context.inState(INSIDE_COMMENT)) {
      context.switchTo(CODE);
    }
    return;
  }
  if (c == ';') {
    context.addTokenAndResetText();
    context.switchTo(CODE);
    return;
  }
  if (c == '=') {
    context.appendCharToText();
    if (!context.inState(VARIABLE)) {
      context.addTokenAndResetText();
    }
    return;
  }
  if (c == '$') {
    context.addTokenAndResetText();
    context.appendCharToText();
    context.switchTo(VARIABLE);
    return;
  }
  if (c == '{' || c == '}') {
    context.addTokenAndResetText();
    context.appendCharToText();
    context.addTokenAndResetText();
    context.switchTo(CODE);
    return;
  }
  if (c == '#') {
    context.addTokenAndResetText();
    context.switchTo(INSIDE_COMMENT);
    context.appendCharToText();
  }
 else {
    if (Character.isWhitespace(c)) {
      context.addTokenAndResetText();
      return;
    }
    context.appendCharToText();
  }
}",0.8896908834144045
173992,"private void parse(ParseContext context){
  char c=context.getCharAtPos();
  if (context.inState(State.INSIDE_COMMENT)) {
    if (c == '\n') {
      context.addTokenAndResetText();
      context.switchTo(State.CODE);
      return;
    }
 else {
      context.appendCharToText();
    }
    return;
  }
  if (c == '\'') {
    if (context.inState(State.INSIDE_DOUBLE_STRING)) {
      context.appendCharToText();
      return;
    }
    if (context.inState(State.INSIDE_DOUBLE_TICKED)) {
      context.appendCharToText();
      return;
    }
    if (context.getCharBefore() == '\\') {
      context.appendCharToText();
      return;
    }
    if (context.inState(State.INSIDE_SINGLE_STRING)) {
      context.appendCharToText();
      context.switchTo(State.CODE);
      return;
    }
    context.switchTo(State.INSIDE_SINGLE_STRING);
    return;
  }
  if (c == '\""') {
    if (context.inState(State.INSIDE_SINGLE_STRING)) {
      context.appendCharToText();
      return;
    }
    if (context.inState(State.INSIDE_DOUBLE_TICKED)) {
      context.appendCharToText();
      return;
    }
    if (context.getCharBefore() == '\\') {
      context.appendCharToText();
      return;
    }
    if (context.inState(State.INSIDE_DOUBLE_STRING)) {
      context.appendCharToText();
      context.switchTo(State.CODE);
      return;
    }
    context.switchTo(State.INSIDE_DOUBLE_STRING);
    return;
  }
  if (c == '`') {
    if (context.inState(State.INSIDE_SINGLE_STRING)) {
      context.appendCharToText();
      return;
    }
    if (context.inState(State.INSIDE_DOUBLE_STRING)) {
      context.appendCharToText();
      return;
    }
    if (context.getCharBefore() == '\\') {
      context.appendCharToText();
      return;
    }
    if (context.inState(State.INSIDE_DOUBLE_TICKED)) {
      context.appendCharToText();
      context.switchTo(State.CODE);
      return;
    }
    context.switchTo(State.INSIDE_DOUBLE_TICKED);
    return;
  }
  if (context.insideString()) {
    context.appendCharToText();
    return;
  }
  if (c == '\r') {
    context.moveCurrentPosWhenEmptyText();
    return;
  }
  if (c == '\n') {
    context.addTokenAndResetText();
    context.switchTo(State.CODE);
    return;
  }
  if (c == ';') {
    context.addTokenAndResetText();
    context.switchTo(State.CODE);
    return;
  }
  if (c == '$') {
    context.appendCharToText();
    context.switchTo(State.VARIABLE);
    return;
  }
  if (c == '{' || c == '}') {
    if (context.inState(State.VARIABLE)) {
      context.appendCharToText();
      if (c == '}') {
        context.addTokenAndResetText();
        context.switchTo(State.CODE);
      }
      return;
    }
    context.addTokenAndResetText();
    context.appendCharToText();
    context.addTokenAndResetText();
    context.switchTo(State.CODE);
    return;
  }
  if (c == '#' && !context.inState(State.VARIABLE)) {
    context.addTokenAndResetText();
    context.switchTo(State.INSIDE_COMMENT);
    context.appendCharToText();
  }
 else {
    if (Character.isWhitespace(c)) {
      context.addTokenAndResetText();
      return;
    }
    context.appendCharToText();
  }
}","private void parse(ParseContext context){
  char c=context.getCharAtPos();
  if (context.inState(State.INSIDE_COMMENT)) {
    if (c == '\n') {
      context.addTokenAndResetText();
      context.switchTo(State.CODE);
      return;
    }
 else {
      context.appendCharToText();
    }
    return;
  }
  if (c == '\'') {
    if (context.inState(State.INSIDE_DOUBLE_STRING)) {
      context.appendCharToText();
      return;
    }
    if (context.inState(State.INSIDE_DOUBLE_TICKED)) {
      context.appendCharToText();
      return;
    }
    if (context.getCharBefore() == '\\') {
      context.appendCharToText();
      return;
    }
    if (context.inState(State.INSIDE_SINGLE_STRING)) {
      context.appendCharToText();
      context.restoreStateBeforeString();
      return;
    }
    context.switchToStringState(State.INSIDE_SINGLE_STRING);
    context.appendCharToText();
    return;
  }
  if (c == '\""') {
    if (context.inState(State.INSIDE_SINGLE_STRING)) {
      context.appendCharToText();
      return;
    }
    if (context.inState(State.INSIDE_DOUBLE_TICKED)) {
      context.appendCharToText();
      return;
    }
    if (context.getCharBefore() == '\\') {
      context.appendCharToText();
      return;
    }
    if (context.inState(State.INSIDE_DOUBLE_STRING)) {
      context.appendCharToText();
      context.restoreStateBeforeString();
      return;
    }
    context.switchToStringState(State.INSIDE_DOUBLE_STRING);
    context.appendCharToText();
    return;
  }
  if (c == '`') {
    if (context.inState(State.INSIDE_SINGLE_STRING)) {
      context.appendCharToText();
      return;
    }
    if (context.inState(State.INSIDE_DOUBLE_STRING)) {
      context.appendCharToText();
      return;
    }
    if (context.getCharBefore() == '\\') {
      context.appendCharToText();
      return;
    }
    if (context.inState(State.INSIDE_DOUBLE_TICKED)) {
      context.appendCharToText();
      context.restoreStateBeforeString();
      return;
    }
    context.switchToStringState(State.INSIDE_DOUBLE_TICKED);
    context.appendCharToText();
    return;
  }
  if (context.insideString()) {
    context.appendCharToText();
    return;
  }
  if (c == '\r') {
    context.moveCurrentPosWhenEmptyText();
    return;
  }
  if (c == '\n') {
    context.addTokenAndResetText();
    if (context.inState(State.INSIDE_COMMENT)) {
      context.switchTo(State.CODE);
    }
    return;
  }
  if (c == ';') {
    context.addTokenAndResetText();
    context.switchTo(State.CODE);
    return;
  }
  if (c == '=') {
    context.appendCharToText();
    context.addTokenAndResetText();
    return;
  }
  if (c == '$') {
    context.appendCharToText();
    context.switchTo(State.VARIABLE);
    return;
  }
  if (c == '{' || c == '}') {
    if (context.inState(State.VARIABLE)) {
      context.appendCharToText();
      if (c == '}') {
        context.addTokenAndResetText();
        context.switchTo(State.CODE);
      }
      return;
    }
    context.addTokenAndResetText();
    context.appendCharToText();
    context.addTokenAndResetText();
    context.switchTo(State.CODE);
    return;
  }
  if (c == '#' && !context.inState(State.VARIABLE)) {
    context.addTokenAndResetText();
    context.switchTo(State.INSIDE_COMMENT);
    context.appendCharToText();
  }
 else {
    if (Character.isWhitespace(c)) {
      context.addTokenAndResetText();
      return;
    }
    context.appendCharToText();
  }
}",0.9033149171270718
173993,"@Test public void a_double_string_containing_double_ticked_string_has_token_with_singlestring_contained(){
  List<ParseToken> tokens=parserToTest.parse(""String_Node_Str"");
  assertThat(tokens).containsNotToken(""String_Node_Str"");
}","@Test public void a_double_string_containing_double_ticked_string_has_token_with_singlestring_contained(){
  List<ParseToken> tokens=parserToTest.parse(""String_Node_Str"");
  assertThat(tokens).containsOneToken(""String_Node_Str"");
}",0.987012987012987
173994,"@Test public void a_single_string_containing_double_string_has_token_with_singlestring_contained(){
  List<ParseToken> tokens=parserToTest.parse(""String_Node_Str"");
  assertThat(tokens).containsNotToken(""String_Node_Str"");
}","@Test public void a_single_string_containing_double_string_has_token_with_singlestring_contained(){
  List<ParseToken> tokens=parserToTest.parse(""String_Node_Str"");
  assertThat(tokens).containsOneToken(""String_Node_Str"");
}",0.9866071428571428
173995,"@Test public void a_double_string_containing_single_string_has_token_with_singlestring_contained(){
  List<ParseToken> tokens=parserToTest.parse(""String_Node_Str"");
  assertThat(tokens).containsNotToken(""String_Node_Str"");
}","@Test public void a_double_string_containing_single_string_has_token_with_singlestring_contained(){
  List<ParseToken> tokens=parserToTest.parse(""String_Node_Str"");
  assertThat(tokens).containsOneToken(""String_Node_Str"");
}",0.9866071428571428
173996,"@Test public void a_single_string_containing_double_ticked_string_has_token_with_singlestring_contained(){
  List<ParseToken> tokens=parserToTest.parse(""String_Node_Str"");
  assertThat(tokens).containsNotToken(""String_Node_Str"");
}","@Test public void a_single_string_containing_double_ticked_string_has_token_with_singlestring_contained(){
  List<ParseToken> tokens=parserToTest.parse(""String_Node_Str"");
  assertThat(tokens).containsOneToken(""String_Node_Str"");
}",0.987012987012987
173997,"private void parse(ParseContext context){
  char c=context.getCharAtPos();
  if (context.inState(VARIABLE)) {
    VariableContext variableContext=context.getVariableContext();
    if (c == '$') {
      context.appendCharToText();
      return;
    }
    if (c == '#') {
      context.appendCharToText();
      return;
    }
    if (c == '[') {
      variableContext.variableArrayOpened();
      context.appendCharToText();
      return;
    }
    if (c == ']') {
      variableContext.variableArrayClosed();
      context.appendCharToText();
      return;
    }
    if (c == '{' || c == '}') {
      context.appendCharToText();
      if (c == '{') {
        variableContext.incrementVariableOpenCurlyBraces();
      }
      if (c == '}') {
        variableContext.incrementVariableCloseCurlyBraces();
      }
      if (c == '}' && variableContext.areVariableCurlyBracesBalanced()) {
        context.addTokenAndResetText();
        context.switchTo(CODE);
      }
      return;
    }
    if (Character.isWhitespace(c)) {
      context.addTokenAndResetText();
      return;
    }
    if (variableContext.isInsideVariableArray()) {
      if (isStringChar(c)) {
        context.appendCharToText();
        return;
      }
      context.appendCharToText();
      return;
    }
 else {
      if (Character.isWhitespace(c)) {
        context.addTokenAndResetText();
        context.switchTo(ParserState.CODE);
        return;
      }
      if (isStringChar(c)) {
        context.addTokenAndResetText();
        context.switchTo(ParserState.CODE);
      }
 else {
        context.appendCharToText();
        return;
      }
    }
  }
  if (context.inState(INSIDE_COMMENT)) {
    if (c == '\n') {
      context.addTokenAndResetText();
      context.switchTo(CODE);
      return;
    }
 else {
      context.appendCharToText();
    }
    return;
  }
  if (c == '\'') {
    handleString(INSIDE_SINGLE_STRING,context,INSIDE_DOUBLE_TICKED,INSIDE_DOUBLE_STRING);
    return;
  }
  if (c == '\""') {
    handleString(INSIDE_DOUBLE_STRING,context,INSIDE_DOUBLE_TICKED,INSIDE_SINGLE_STRING);
    return;
  }
  if (c == '`') {
    handleString(INSIDE_DOUBLE_TICKED,context,INSIDE_SINGLE_STRING,INSIDE_DOUBLE_STRING);
    return;
  }
  if (context.insideString()) {
    context.appendCharToText();
    return;
  }
  if (c == '\r') {
    context.moveCurrentPosWhenEmptyText();
    return;
  }
  if (c == '\n') {
    context.addTokenAndResetText();
    if (context.inState(INSIDE_COMMENT)) {
      context.switchTo(CODE);
    }
    return;
  }
  if (c == ';') {
    context.addTokenAndResetText();
    context.switchTo(CODE);
    return;
  }
  if (c == '=') {
    context.appendCharToText();
    if (!context.inState(VARIABLE)) {
      context.addTokenAndResetText();
    }
    return;
  }
  if (c == '$') {
    context.addTokenAndResetText();
    context.appendCharToText();
    context.switchTo(VARIABLE);
    return;
  }
  if (c == '{' || c == '}') {
    context.addTokenAndResetText();
    context.appendCharToText();
    context.addTokenAndResetText();
    context.switchTo(CODE);
    return;
  }
  if (c == '#') {
    context.addTokenAndResetText();
    context.switchTo(INSIDE_COMMENT);
    context.appendCharToText();
  }
 else {
    if (Character.isWhitespace(c)) {
      context.addTokenAndResetText();
      return;
    }
    context.appendCharToText();
  }
}","private void parse(ParseContext context){
  char c=context.getCharAtPos();
  if (context.inState(VARIABLE)) {
    VariableContext variableContext=context.getVariableContext();
    if (c == '$') {
      context.appendCharToText();
      if (context.getCharBefore() == '$') {
        context.addTokenAndResetText();
        context.switchTo(CODE);
      }
      return;
    }
    if (c == '#') {
      context.appendCharToText();
      return;
    }
    if (c == '[') {
      variableContext.variableArrayOpened();
      context.appendCharToText();
      return;
    }
    if (c == ']') {
      variableContext.variableArrayClosed();
      context.appendCharToText();
      return;
    }
    if (c == '{' || c == '}') {
      context.appendCharToText();
      if (c == '{') {
        variableContext.incrementVariableOpenCurlyBraces();
      }
      if (c == '}') {
        variableContext.incrementVariableCloseCurlyBraces();
      }
      if (c == '}' && variableContext.areVariableCurlyBracesBalanced()) {
        context.addTokenAndResetText();
        context.switchTo(CODE);
      }
      return;
    }
    if (Character.isWhitespace(c)) {
      context.addTokenAndResetText();
      return;
    }
    if (variableContext.isInsideVariableArray()) {
      if (isStringChar(c)) {
        context.appendCharToText();
        return;
      }
      context.appendCharToText();
      return;
    }
 else {
      if (Character.isWhitespace(c)) {
        context.addTokenAndResetText();
        context.switchTo(ParserState.CODE);
        return;
      }
      if (isStringChar(c)) {
        context.addTokenAndResetText();
        context.switchTo(ParserState.CODE);
      }
 else {
        context.appendCharToText();
        return;
      }
    }
  }
  if (context.inState(INSIDE_COMMENT)) {
    if (c == '\n') {
      context.addTokenAndResetText();
      context.switchTo(CODE);
      return;
    }
 else {
      context.appendCharToText();
    }
    return;
  }
  if (c == '\'') {
    handleString(INSIDE_SINGLE_STRING,context,INSIDE_DOUBLE_TICKED,INSIDE_DOUBLE_STRING);
    return;
  }
  if (c == '\""') {
    handleString(INSIDE_DOUBLE_STRING,context,INSIDE_DOUBLE_TICKED,INSIDE_SINGLE_STRING);
    return;
  }
  if (c == '`') {
    handleString(INSIDE_DOUBLE_TICKED,context,INSIDE_SINGLE_STRING,INSIDE_DOUBLE_STRING);
    return;
  }
  if (context.insideString()) {
    context.appendCharToText();
    return;
  }
  if (c == '\r') {
    context.moveCurrentPosWhenEmptyText();
    return;
  }
  if (c == '\n') {
    context.addTokenAndResetText();
    if (context.inState(INSIDE_COMMENT)) {
      context.switchTo(CODE);
    }
    return;
  }
  if (c == ';') {
    context.addTokenAndResetText();
    context.switchTo(CODE);
    return;
  }
  if (c == '=') {
    context.appendCharToText();
    if (!context.inState(VARIABLE)) {
      context.addTokenAndResetText();
    }
    return;
  }
  if (c == '$') {
    context.addTokenAndResetText();
    context.appendCharToText();
    context.switchTo(VARIABLE);
    return;
  }
  if (c == '{' || c == '}') {
    context.addTokenAndResetText();
    context.appendCharToText();
    context.addTokenAndResetText();
    context.switchTo(CODE);
    return;
  }
  if (c == '#') {
    context.addTokenAndResetText();
    context.switchTo(INSIDE_COMMENT);
    context.appendCharToText();
  }
 else {
    if (Character.isWhitespace(c)) {
      context.addTokenAndResetText();
      return;
    }
    context.appendCharToText();
  }
}",0.9818181818181818
173998,"/** 
 * Scans for functions like: <pre> #!/bin/bash  function quit {  exit  }  function hello {  echo Hello!  }  hello quit echo foo </pre>
 * @param bashScript
 */
void buildFunctions(String bashScript,BashScriptModel model){
  scanForIdentifierFollowedByWord(bashScript,model,""String_Node_Str"");
}","/** 
 * Scans for functions like: <pre> #!/bin/bash  function quit {  exit  }  function hello {  echo Hello!  }  hello quit echo foo </pre>
 * @param bashScript
 */
void buildFunctions(String bashScript,BashScriptModel model){
  String scanString=""String_Node_Str"";
  int pos=0;
  while (true) {
    if (pos >= bashScript.length()) {
      break;
    }
    pos=bashScript.indexOf(scanString,pos);
    if (pos < 0) {
      break;
    }
    if (pos > 0) {
      char before=bashScript.charAt(pos - 1);
      if (!Character.isWhitespace(before)) {
        pos++;
        continue;
      }
    }
    int namePos=pos + scanString.length();
    while (true) {
      char charAt=bashScript.charAt(namePos);
      if (namePos >= bashScript.length()) {
        break;
      }
      if (!Character.isWhitespace(charAt)) {
        break;
      }
      namePos++;
    }
    StringBuilder sb=new StringBuilder();
    while (true) {
      if (namePos >= bashScript.length()) {
        break;
      }
      char charAt=bashScript.charAt(namePos);
      if (Character.isLetterOrDigit(charAt) || charAt == '_' || charAt == '-') {
        sb.append(charAt);
        namePos++;
      }
 else {
        break;
      }
    }
    BashFunction bashFunction=new BashFunction();
    bashFunction.name=sb.toString();
    bashFunction.position=pos;
    bashFunction.length=namePos - pos;
    model.functions.add(bashFunction);
    pos=namePos + 1;
  }
}",0.2863768115942029
173999,"@Override public void getAdImage(){
  mModel.getAdImage(new Subscriber<AdList>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      mView.showErrorTip(e.getLocalizedMessage());
    }
    @Override public void onNext(    AdList adList){
      mView.onAdImgGet(adList);
      SharedPreManager.getInstance().putAdList(mContext,adList);
    }
  }
);
}","@Override public void getAdImage(){
  mModel.getAdImage(new Subscriber<AdList>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      mView.showErrorTip(e.getLocalizedMessage());
      Log.e(""String_Node_Str"",""String_Node_Str"");
      getCacheAdImage();
    }
    @Override public void onNext(    AdList adList){
      if (adList == null) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        getCacheAdImage();
        return;
      }
      mView.onAdImgGet(adList);
      SharedPreManager.getInstance().putAdList(mContext,adList);
    }
  }
);
}",0.7960396039603961
174000,"@Override public void getCacheAdImage(){
  AdList adList=SharedPreManager.getInstance().getAdList(mContext);
  if (adList != null) {
    mView.onAdImgGet(adList);
  }
}","@Override public void getCacheAdImage(){
  AdList adList=SharedPreManager.getInstance().getAdList(mContext);
  if (adList != null) {
    mView.onAdImgGet(adList);
  }
 else {
    mView.skip();
  }
}",0.918032786885246
