record_number,buggy_code,fixed_code,code_similarity
50001,"public void appendState(StringBuffer sbState){
  sbState.append(""String_Node_Str"");
  for (  Connection conn : mapConnections.values()) {
    sbState.append(""String_Node_Str"" + conn.getEndPoint());
    sbState.append(""String_Node_Str"" + conn.live());
    sbState.append(""String_Node_Str"" + conn.getWriteHandler().size());
  }
  sbState.append(""String_Node_Str"");
}","public void appendState(StringBuffer sbState){
  long now=System.currentTimeMillis();
  sbState.append(""String_Node_Str"");
  for (  Connection conn : mapConnections.values()) {
    long wr=(now - conn.getWriteHandler().lastRegistration) / 1000;
    long wh=(now - conn.getWriteHandler().lastHandle) / 1000;
    long rr=(now - conn.getReadHandler().lastRegistration) / 1000;
    long rh=(now - conn.getReadHandler().lastHandle) / 1000;
    sbState.append(""String_Node_Str"" + conn.getEndPoint());
    sbState.append(""String_Node_Str"" + conn.live());
    sbState.append(""String_Node_Str"" + conn.getWriteHandler().size());
    sbState.append(""String_Node_Str"").append(wr).append(""String_Node_Str"").append(wh);
    sbState.append(""String_Node_Str"").append(rr).append(""String_Node_Str"").append(rh);
  }
  sbState.append(""String_Node_Str"");
}",0.6071726438698916
50002,"public final void handle(){
  if (!connection.live()) {
    logger.log(Level.FINEST,""String_Node_Str"");
    return;
  }
  try {
    if (socketReader == null) {
      int readBytes=socketChannel.read(protocolBuffer);
      if (readBytes == -1) {
        throw new EOFException();
      }
      if (!protocolBuffer.hasRemaining()) {
        String protocol=new String(protocolBuffer.array());
        WriteHandler writeHandler=connection.getWriteHandler();
        if (""String_Node_Str"".equals(protocol)) {
          writeHandler.setProtocol(""String_Node_Str"");
          socketReader=new SocketPacketReader(node,socketChannel,connection);
        }
 else {
          writeHandler.setProtocol(""String_Node_Str"");
          inBuffer.put(protocolBuffer.array());
          socketReader=new SocketTextReader(node,connection);
          connection.connectionManager.incrementTextConnections();
        }
      }
    }
    if (socketReader == null)     return;
    int readBytes=socketChannel.read(inBuffer);
    if (readBytes == -1) {
      throw new EOFException();
    }
  }
 catch (  Throwable e) {
    handleSocketException(e);
    return;
  }
  try {
    if (inBuffer.position() == 0)     return;
    inBuffer.flip();
    socketReader.read(inBuffer);
    if (inBuffer.hasRemaining()) {
      inBuffer.compact();
    }
 else {
      inBuffer.clear();
    }
  }
 catch (  Exception t) {
    handleSocketException(t);
  }
 finally {
    run();
  }
}","public final void handle(){
  lastHandle=System.currentTimeMillis();
  if (!connection.live()) {
    logger.log(Level.FINEST,""String_Node_Str"");
    return;
  }
  try {
    if (socketReader == null) {
      int readBytes=socketChannel.read(protocolBuffer);
      if (readBytes == -1) {
        throw new EOFException();
      }
      if (!protocolBuffer.hasRemaining()) {
        String protocol=new String(protocolBuffer.array());
        WriteHandler writeHandler=connection.getWriteHandler();
        if (""String_Node_Str"".equals(protocol)) {
          writeHandler.setProtocol(""String_Node_Str"");
          socketReader=new SocketPacketReader(node,socketChannel,connection);
        }
 else {
          writeHandler.setProtocol(""String_Node_Str"");
          inBuffer.put(protocolBuffer.array());
          socketReader=new SocketTextReader(node,connection);
          connection.connectionManager.incrementTextConnections();
        }
      }
    }
    if (socketReader == null)     return;
    int readBytes=socketChannel.read(inBuffer);
    if (readBytes == -1) {
      throw new EOFException();
    }
  }
 catch (  Throwable e) {
    handleSocketException(e);
    return;
  }
  try {
    if (inBuffer.position() == 0)     return;
    inBuffer.flip();
    socketReader.read(inBuffer);
    if (inBuffer.hasRemaining()) {
      inBuffer.compact();
    }
 else {
      inBuffer.clear();
    }
  }
 catch (  Throwable t) {
    handleSocketException(t);
  }
}",0.9555938037865748
50003,"public final void run(){
  registerOp(inSelector.selector,SelectionKey.OP_READ);
}","public final void run(){
  lastRegistration=System.currentTimeMillis();
  registerOp(inSelector.selector,SelectionKey.OP_READ);
}",0.7772511848341233
50004,"public final void run(){
  try {
    while (live) {
      threadWatcher.incrementRunCount();
      long currentMillis=System.currentTimeMillis();
      if ((currentMillis - lastPublish) > TEN_SECOND_MILLIS) {
        publishUtilization();
        lastPublish=currentMillis;
      }
      processSelectionQueue();
      if (!live)       return;
      int selectedKeyCount;
      try {
        long startWait=System.nanoTime();
        selectedKeyCount=selector.select(waitTime);
        long now=System.nanoTime();
        threadWatcher.addWait((now - startWait),now);
        if (Thread.interrupted()) {
          node.handleInterruptedException(Thread.currentThread(),new RuntimeException());
          return;
        }
      }
 catch (      Throwable exp) {
        continue;
      }
      if (selectedKeyCount == 0) {
        continue;
      }
      final Set<SelectionKey> setSelectedKeys=selector.selectedKeys();
      final Iterator<SelectionKey> it=setSelectedKeys.iterator();
      while (it.hasNext()) {
        final SelectionKey sk=it.next();
        it.remove();
        try {
          if (sk.isValid()) {
            sk.interestOps(sk.interestOps() & ~sk.readyOps());
            SelectionHandler selectionHandler=(SelectionHandler)sk.attachment();
            selectionHandler.handle();
          }
        }
 catch (        CancelledKeyException e) {
        }
catch (        Throwable e) {
          handleSelectorException(e);
        }
      }
    }
  }
 catch (  OutOfMemoryError e) {
    node.onOutOfMemory(e);
  }
catch (  Throwable e) {
    logger.log(Level.WARNING,""String_Node_Str"" + Thread.currentThread().getName(),e);
  }
 finally {
    try {
      logger.log(Level.FINE,""String_Node_Str"" + Thread.currentThread().getName());
      selector.close();
    }
 catch (    final Exception ignored) {
    }
  }
}","public final void run(){
  try {
    while (live) {
      threadWatcher.incrementRunCount();
      long currentMillis=System.currentTimeMillis();
      if ((currentMillis - lastPublish) > TEN_SECOND_MILLIS) {
        publishUtilization();
        lastPublish=currentMillis;
      }
      processSelectionQueue();
      if (!live)       return;
      int selectedKeyCount;
      try {
        long startWait=System.nanoTime();
        selectedKeyCount=selector.select(waitTime);
        long now=System.nanoTime();
        threadWatcher.addWait((now - startWait),now);
        if (Thread.interrupted()) {
          node.handleInterruptedException(Thread.currentThread(),new RuntimeException());
          return;
        }
      }
 catch (      Throwable exp) {
        continue;
      }
      if (selectedKeyCount == 0) {
        continue;
      }
      final Set<SelectionKey> setSelectedKeys=selector.selectedKeys();
      final Iterator<SelectionKey> it=setSelectedKeys.iterator();
      while (it.hasNext()) {
        final SelectionKey sk=it.next();
        it.remove();
        try {
          if (sk.isValid()) {
            if (!sk.isReadable())             sk.interestOps(sk.interestOps() & ~sk.readyOps());
            SelectionHandler selectionHandler=(SelectionHandler)sk.attachment();
            selectionHandler.handle();
          }
 else {
            logger.log(Level.WARNING,sk.isWritable() + ""String_Node_Str"" + Thread.currentThread().getName());
          }
        }
 catch (        CancelledKeyException e) {
          logger.log(Level.WARNING,""String_Node_Str"" + Thread.currentThread().getName(),e);
        }
catch (        Throwable e) {
          handleSelectorException(e);
        }
      }
    }
  }
 catch (  OutOfMemoryError e) {
    node.onOutOfMemory(e);
  }
catch (  Throwable e) {
    logger.log(Level.WARNING,""String_Node_Str"" + Thread.currentThread().getName(),e);
  }
 finally {
    try {
      logger.log(Level.FINE,""String_Node_Str"" + Thread.currentThread().getName());
      selector.close();
    }
 catch (    final Exception ignored) {
    }
  }
}",0.8395313295975547
50005,"public void enqueueSocketWritable(SocketWritable socketWritable){
  socketWritable.onEnqueue();
  writeQueue.offer(socketWritable);
  outSelector.writeQueueSize.incrementAndGet();
  if (informSelector.compareAndSet(true,false)) {
    outSelector.addTask(this);
    outSelector.selector.wakeup();
  }
}","public void enqueueSocketWritable(SocketWritable socketWritable){
  socketWritable.onEnqueue();
  writeQueue.offer(socketWritable);
  outSelector.writeQueueSize.incrementAndGet();
  if (true || informSelector.compareAndSet(true,false)) {
    outSelector.addTask(this);
    outSelector.selector.wakeup();
  }
}",0.9868852459016394
50006,"private void registerWrite(){
  registerOp(outSelector.selector,SelectionKey.OP_WRITE);
}","private void registerWrite(){
  lastRegistration=System.currentTimeMillis();
  registerOp(outSelector.selector,SelectionKey.OP_WRITE);
}",0.7911111111111111
50007,"public void handle(){
  if (socketWriter == null) {
    setProtocol(""String_Node_Str"");
  }
  if (lastWritable == null) {
    lastWritable=poll();
    if (lastWritable == null && socketBB.position() == 0) {
      ready=true;
      return;
    }
  }
  if (!connection.live())   return;
  try {
    while (socketBB.hasRemaining()) {
      if (lastWritable == null) {
        lastWritable=poll();
      }
      if (lastWritable != null) {
        boolean complete=socketWriter.write(lastWritable,socketBB);
        if (complete) {
          if (lastWritable instanceof Packet) {
            node.getPacketPool().release((Packet)lastWritable);
          }
          lastWritable=null;
        }
 else {
          if (socketBB.hasRemaining()) {
            break;
          }
        }
      }
 else {
        break;
      }
    }
    if (socketBB.position() > 0) {
      socketBB.flip();
      try {
        int written=socketChannel.write(socketBB);
      }
 catch (      Exception e) {
        lastWritable=null;
        handleSocketException(e);
        return;
      }
      if (socketBB.hasRemaining()) {
        socketBB.compact();
      }
 else {
        socketBB.clear();
      }
    }
  }
 catch (  Throwable t) {
    logger.log(Level.SEVERE,""String_Node_Str"" + connection.getEndPoint(),t);
    t.printStackTrace();
  }
 finally {
    ready=false;
    registerWrite();
  }
}","public void handle(){
  lastHandle=System.currentTimeMillis();
  runCount++;
  if (socketWriter == null) {
    setProtocol(""String_Node_Str"");
  }
  if (lastWritable == null) {
    lastWritable=poll();
    if (lastWritable == null && socketBB.position() == 0) {
      ready=true;
      return;
    }
  }
  if (!connection.live())   return;
  try {
    while (socketBB.hasRemaining()) {
      if (lastWritable == null) {
        lastWritable=poll();
      }
      if (lastWritable != null) {
        boolean complete=socketWriter.write(lastWritable,socketBB);
        if (complete) {
          if (lastWritable instanceof Packet) {
            node.getPacketPool().release((Packet)lastWritable);
          }
          lastWritable=null;
        }
 else {
          if (socketBB.hasRemaining()) {
            break;
          }
        }
      }
 else {
        break;
      }
    }
    if (socketBB.position() > 0) {
      socketBB.flip();
      try {
        int written=socketChannel.write(socketBB);
      }
 catch (      Exception e) {
        lastWritable=null;
        handleSocketException(e);
        return;
      }
      if (socketBB.hasRemaining()) {
        socketBB.compact();
      }
 else {
        socketBB.clear();
      }
    }
  }
 catch (  Throwable t) {
    logger.log(Level.SEVERE,""String_Node_Str"" + connection.getEndPoint(),t);
    t.printStackTrace();
  }
 finally {
    ready=false;
    registerWrite();
  }
}",0.980447920369712
50008,"public boolean writeTo(ByteBuffer bb){
  IOUtil.copyToHeapBuffer(header,bb);
  IOUtil.copyToHeapBuffer(value,bb);
  IOUtil.copyToHeapBuffer(lastOne,bb);
  return !(header != null && header.hasRemaining() || (value != null && value.hasRemaining()) || (lastOne != null && lastOne.hasRemaining()));
}","public boolean writeTo(ByteBuffer bb){
  if (value != null) {
    IOUtil.copyToHeapBuffer(value,bb);
  }
  if (lastOne != null) {
    IOUtil.copyToHeapBuffer(lastOne,bb);
  }
  return !(value != null && value.hasRemaining()) || (lastOne != null && lastOne.hasRemaining());
}",0.5078809106830122
50009,"public void setValue(byte[] value,boolean singleGet){
  if (value == null) {
    if (singleGet) {
      lastOne=ByteBuffer.wrap(END);
    }
    return;
  }
  lastOne=ByteBuffer.wrap((singleGet) ? RETURN_END : RETURN);
  this.value=ByteBuffer.wrap(value);
  int valueLenInt=value.length;
  byte[] valueLen=String.valueOf(valueLenInt).getBytes();
  byte[] keyBytes=key.getBytes();
  int headerSize=VALUE_SPACE.length + keyBytes.length + FLAG_ZERO.length+ valueLen.length+ RETURN.length;
  header=ByteBuffer.allocate(headerSize);
  header.put(VALUE_SPACE);
  header.put(keyBytes);
  header.put(FLAG_ZERO);
  header.put(valueLen);
  header.put(RETURN);
  header.flip();
}","public void setValue(MemcacheEntry entry,boolean singleGet){
  if (entry != null)   value=entry.toNewBuffer();
  lastOne=(singleGet) ? ByteBuffer.wrap(END) : null;
}",0.2524038461538461
50010,"public void handle(GetCommand getCommand){
  String key=getCommand.getKey();
  String mapName=""String_Node_Str"";
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=key.substring(0,index);
    key=key.substring(index + 1);
  }
  byte[] valueBytes=textCommandService.getByteArray(mapName,key);
  textCommandService.incrementGetCount();
  if (valueBytes != null) {
    textCommandService.incrementHitCount();
  }
  getCommand.setValue(valueBytes,single);
  textCommandService.sendResponse(getCommand);
}","public void handle(GetCommand getCommand){
  String key=getCommand.getKey();
  String mapName=""String_Node_Str"";
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=key.substring(0,index);
    key=key.substring(index + 1);
  }
  Object value=textCommandService.get(mapName,key);
  MemcacheEntry entry=null;
  if (value != null) {
    if (value instanceof MemcacheEntry) {
      entry=(MemcacheEntry)value;
    }
 else {
      try {
        entry=new MemcacheEntry(key,IOUtil.serializeToBytes(value),0);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
  textCommandService.incrementGetCount();
  if (entry != null) {
    textCommandService.incrementHitCount();
  }
  getCommand.setValue(entry,single);
  textCommandService.sendResponse(getCommand);
}",0.6788990825688074
50011,"/** 
 * ""set"" means ""store this data"". <p/> ""add"" means ""store this data, but only if the server *doesn't* already hold data for this key"". <p/> ""replace"" means ""store this data, but only if the server *does already hold data for this key"". <p/> <p/> After sending the command line and the data block the client awaits the reply, which may be: <p/> - ""STORED\r\n"", to indicate success. <p/> - ""NOT_STORED\r\n"" to indicate the data was not stored, but not because of an error. This normally means that either that the condition for an ""add"" or a ""replace"" command wasn't met, or that the item is in a delete queue (see the ""delete"" command below).
 */
public void handle(SetCommand request){
  String key=request.getKey();
  String mapName=""String_Node_Str"";
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=key.substring(0,index);
    key=key.substring(index + 1);
  }
  byte[] value=request.getValue();
  int ttl=textCommandService.getAdjustedTTLSeconds(request.getExpiration());
  textCommandService.incrementSetCount();
  if (SET == request.getType()) {
    request.setResponse(STORED);
    if (request.shouldReply()) {
      textCommandService.sendResponse(request);
    }
    textCommandService.put(mapName,key,value,ttl);
  }
 else   if (ADD == request.getType()) {
    boolean added=(textCommandService.putIfAbsent(mapName,key,value,ttl) == null);
    if (added) {
      request.setResponse(STORED);
    }
 else {
      request.setResponse(NOT_STORED);
    }
    if (request.shouldReply()) {
      textCommandService.sendResponse(request);
    }
  }
 else   if (REPLACE == request.getType()) {
    boolean replaced=(textCommandService.replace(mapName,key,value) != null);
    if (replaced) {
      request.setResponse(STORED);
    }
 else {
      request.setResponse(NOT_STORED);
    }
    if (request.shouldReply()) {
      textCommandService.sendResponse(request);
    }
  }
}","/** 
 * ""set"" means ""store this data"". <p/> ""add"" means ""store this data, but only if the server *doesn't* already hold data for this key"". <p/> ""replace"" means ""store this data, but only if the server *does already hold data for this key"". <p/> <p/> After sending the command line and the data block the client awaits the reply, which may be: <p/> - ""STORED\r\n"", to indicate success. <p/> - ""NOT_STORED\r\n"" to indicate the data was not stored, but not because of an error. This normally means that either that the condition for an ""add"" or a ""replace"" command wasn't met, or that the item is in a delete queue (see the ""delete"" command below).
 */
public void handle(SetCommand request){
  String key=request.getKey();
  String mapName=""String_Node_Str"";
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=key.substring(0,index);
    key=key.substring(index + 1);
  }
  Object value=new MemcacheEntry(key,request.getValue(),request.getFlag());
  int ttl=textCommandService.getAdjustedTTLSeconds(request.getExpiration());
  textCommandService.incrementSetCount();
  if (SET == request.getType()) {
    request.setResponse(STORED);
    if (request.shouldReply()) {
      textCommandService.sendResponse(request);
    }
    textCommandService.put(mapName,key,value,ttl);
  }
 else   if (ADD == request.getType()) {
    boolean added=(textCommandService.putIfAbsent(mapName,key,value,ttl) == null);
    if (added) {
      request.setResponse(STORED);
    }
 else {
      request.setResponse(NOT_STORED);
    }
    if (request.shouldReply()) {
      textCommandService.sendResponse(request);
    }
  }
 else   if (REPLACE == request.getType()) {
    boolean replaced=(textCommandService.replace(mapName,key,value) != null);
    if (replaced) {
      request.setResponse(STORED);
    }
 else {
      request.setResponse(NOT_STORED);
    }
    if (request.shouldReply()) {
      textCommandService.sendResponse(request);
    }
  }
}",0.9867152904402188
50012,"public boolean validateJoinRequest(JoinRequest joinRequest) throws Exception {
  boolean valid=Packet.PACKET_VERSION == joinRequest.packetVersion && buildNumber == joinRequest.buildNumber;
  if (valid) {
    try {
      config.checkCompatibility(joinRequest.config);
    }
 catch (    Exception e) {
      logger.log(Level.INFO,""String_Node_Str"" + e.getMessage());
      throw e;
    }
  }
  return valid;
}","public boolean validateJoinRequest(JoinRequest joinRequest) throws Exception {
  boolean valid=Packet.PACKET_VERSION == joinRequest.packetVersion && buildNumber == joinRequest.buildNumber;
  if (valid) {
    try {
      valid=config.isCompatible(joinRequest.config);
    }
 catch (    Exception e) {
      logger.log(Level.INFO,""String_Node_Str"" + e.getMessage());
      throw e;
    }
  }
  return valid;
}",0.9754299754299754
50013,"/** 
 * @param config
 * @return true if config is compatible with this one, false if config belongs to another group
 * @throws RuntimeException if map, queue, topic configs are incompatible 
 */
public boolean isCompatible(final Config config){
  if (config == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!this.groupConfig.equals(config.getGroupConfig())) {
    return false;
  }
  if (checkCompatibility) {
    checkMapConfigCompatible(config);
    checkQueueConfigCompatible(config);
    checkTopicConfigCompatible(config);
  }
  return true;
}","/** 
 * @param config
 * @return true if config is compatible with this one, false if config belongs to another group
 * @throws RuntimeException if map, queue, topic configs are incompatible 
 */
public boolean isCompatible(final Config config){
  if (config == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!this.groupConfig.getName().equals(config.getGroupConfig().getName())) {
    return false;
  }
  if (!this.groupConfig.getPassword().equals(config.getGroupConfig().getPassword())) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (checkCompatibility) {
    checkMapConfigCompatible(config);
    checkQueueConfigCompatible(config);
    checkTopicConfigCompatible(config);
  }
  return true;
}",0.877643504531722
50014,"protected static Object getConvertedRealValue(Object firstValue,Object value){
  if (firstValue == null)   return value;
  if (firstValue.getClass() == value.getClass()) {
    return value;
  }
 else   if (value instanceof String) {
    String str=(String)value;
    return getRealObject(firstValue,str);
  }
 else   throw new RuntimeException(""String_Node_Str"" + value);
}","protected static Object getConvertedRealValue(Object firstValue,Object value){
  if (firstValue == null)   return value;
  if (firstValue.getClass() == value.getClass()) {
    return value;
  }
 else   if (value instanceof String) {
    String str=(String)value;
    return getRealObject(firstValue,str);
  }
 else   if (value != null) {
    String str=String.valueOf(value);
    return getRealObject(firstValue,str);
  }
 else   throw new RuntimeException(""String_Node_Str"" + value);
}",0.8684516880093132
50015,"public void putAll(final Map<? extends K,? extends V> map){
  int counter=0;
  List<Future> lsFutures=new ArrayList<Future>(map.size());
  for (  final K key : map.keySet()) {
    final V value=map.get(key);
    lsFutures.add(putAsync(key,value));
  }
  for (  Future future : lsFutures) {
    try {
      System.out.println(""String_Node_Str"" + counter++);
      future.get();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","public void putAll(final Map<? extends K,? extends V> map){
  int counter=0;
  List<Future> lsFutures=new ArrayList<Future>(map.size());
  for (  final K key : map.keySet()) {
    final V value=map.get(key);
    lsFutures.add(putAsync(key,value));
  }
  for (  Future future : lsFutures) {
    try {
      future.get();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}",0.932061978545888
50016,"protected Object getValue(Packet response){
  if (response.getValue() != null) {
    return toObject(response.getValue());
  }
  return null;
}","protected Object getValue(Packet response){
  if (response.getValue() != null) {
    Object result=toObject(response.getValue());
    if (result instanceof ClientServiceException) {
      throw new RuntimeException(((ClientServiceException)result).getThrowable());
    }
    return result;
  }
  return null;
}",0.543046357615894
50017,"public void handle(Node node,Packet packet){
  try {
    processCall(node,packet);
  }
 catch (  RuntimeException e) {
    logger.log(Level.WARNING,""String_Node_Str"" + packet.operation + ""String_Node_Str""+ e.getMessage(),e);
    packet.clearForResponse();
    packet.setValue(toData(e));
  }
  sendResponse(packet);
}","public void handle(Node node,Packet packet){
  try {
    processCall(node,packet);
  }
 catch (  RuntimeException e) {
    logger.log(Level.WARNING,""String_Node_Str"" + packet.operation + ""String_Node_Str""+ e.getMessage(),e);
    packet.clearForResponse();
    packet.setValue(toData(new ClientServiceException(e)));
  }
  sendResponse(packet);
}",0.9546827794561934
50018,"private Object txnalRemove(ClusterOperation operation,String name,Object key,Object value,long timeout){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,timeout);
      if (!locked) {
        throwCME(key);
      }
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=threadContext.toObject(oldValue);
      }
      int removedValueCount=0;
      if (oldObject != null) {
        if (oldObject instanceof DistributedTimeoutException) {
          return oldObject;
        }
        if (oldObject instanceof CMap.Values) {
          CMap.Values values=(CMap.Values)oldObject;
          removedValueCount=values.size();
        }
 else {
          removedValueCount=1;
        }
      }
      txn.attachRemoveOp(name,key,value,(oldObject == null),removedValueCount);
      return oldObject;
    }
 else {
      return txn.attachRemoveOp(name,key,value,false);
    }
  }
 else {
    Object oldValue=objectCall(operation,name,key,value,timeout,-1);
    if (oldValue != null) {
      if (oldValue instanceof AddressAwareException) {
        rethrowException(operation,(AddressAwareException)oldValue);
      }
      if (!(oldValue instanceof DistributedTimeoutException)) {
        backup(CONCURRENT_MAP_BACKUP_REMOVE);
      }
    }
    return oldValue;
  }
}","private Object txnalRemove(ClusterOperation operation,String name,Object key,Object value,long timeout){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,timeout);
      if (!locked) {
        throwCME(key);
      }
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=threadContext.isClient() ? oldValue : threadContext.toObject(oldValue);
      }
      int removedValueCount=0;
      if (oldObject != null) {
        if (oldObject instanceof DistributedTimeoutException) {
          return oldObject;
        }
        if (oldObject instanceof CMap.Values) {
          CMap.Values values=(CMap.Values)oldObject;
          removedValueCount=values.size();
        }
 else {
          removedValueCount=1;
        }
      }
      txn.attachRemoveOp(name,key,value,(oldObject == null),removedValueCount);
      return oldObject;
    }
 else {
      return txn.attachRemoveOp(name,key,value,false);
    }
  }
 else {
    Object oldValue=objectCall(operation,name,key,value,timeout,-1);
    if (oldValue != null) {
      if (oldValue instanceof AddressAwareException) {
        rethrowException(operation,(AddressAwareException)oldValue);
      }
      if (!(oldValue instanceof DistributedTimeoutException)) {
        backup(CONCURRENT_MAP_BACKUP_REMOVE);
      }
    }
    return oldValue;
  }
}",0.9880803011292346
50019,"private Object txnalReplaceIfSame(ClusterOperation operation,String name,Object key,Object newValue,Object expectedValue,long timeout){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=toObject(oldValue);
      }
      if (oldObject == null) {
        return Boolean.FALSE;
      }
 else {
        if (expectedValue.equals(oldValue)) {
          txn.attachPutOp(name,key,newValue,false);
          return Boolean.TRUE;
        }
 else {
          return Boolean.FALSE;
        }
      }
    }
 else {
      if (expectedValue.equals(txn.get(name,key))) {
        txn.attachPutOp(name,key,newValue,false);
        return Boolean.TRUE;
      }
 else {
        return Boolean.FALSE;
      }
    }
  }
 else {
    Data dataExpected=toData(expectedValue);
    Data dataNew=toData(newValue);
    setLocal(operation,name,key,new MultiData(dataExpected,dataNew),timeout,-1);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : dataNew.hashCode();
    setIndexValues(request,newValue);
    request.setBooleanRequest();
    doOp();
    Object returnObject=getResultAsBoolean();
    if (!Boolean.FALSE.equals(returnObject)) {
      request.value=dataNew;
      backup(CONCURRENT_MAP_BACKUP_PUT);
    }
    return returnObject;
  }
}","private Object txnalReplaceIfSame(ClusterOperation operation,String name,Object key,Object newValue,Object expectedValue,long timeout){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=threadContext.isClient() ? oldValue : threadContext.toObject(oldValue);
      }
      if (oldObject == null) {
        return Boolean.FALSE;
      }
 else {
        if (expectedValue.equals(oldValue)) {
          txn.attachPutOp(name,key,newValue,false);
          return Boolean.TRUE;
        }
 else {
          return Boolean.FALSE;
        }
      }
    }
 else {
      if (expectedValue.equals(txn.get(name,key))) {
        txn.attachPutOp(name,key,newValue,false);
        return Boolean.TRUE;
      }
 else {
        return Boolean.FALSE;
      }
    }
  }
 else {
    Data dataExpected=toData(expectedValue);
    Data dataNew=toData(newValue);
    setLocal(operation,name,key,new MultiData(dataExpected,dataNew),timeout,-1);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : dataNew.hashCode();
    setIndexValues(request,newValue);
    request.setBooleanRequest();
    doOp();
    Object returnObject=getResultAsBoolean();
    if (!Boolean.FALSE.equals(returnObject)) {
      request.value=dataNew;
      backup(CONCURRENT_MAP_BACKUP_PUT);
    }
    return returnObject;
  }
}",0.9846698113207548
50020,"private Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout,long ttl){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=toObject(oldValue);
      }
      if (operation == ClusterOperation.CONCURRENT_MAP_PUT_IF_ABSENT && oldObject != null) {
        txn.attachPutOp(name,key,oldObject,0,ttl,false);
      }
 else {
        txn.attachPutOp(name,key,value,0,ttl,(oldObject == null));
      }
      return threadContext.isClient() ? oldValue : oldObject;
    }
 else {
      if (operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
        Object existingValue=txn.get(name,key);
        if (existingValue != null) {
          return existingValue;
        }
      }
      return txn.attachPutOp(name,key,value,false);
    }
  }
 else {
    setLocal(operation,name,key,value,timeout,ttl);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    if (operation == CONCURRENT_MAP_TRY_PUT) {
      request.setBooleanRequest();
      doOp();
      Boolean returnObject=getResultAsBoolean();
      if (returnObject) {
        backup(CONCURRENT_MAP_BACKUP_PUT);
      }
      return returnObject;
    }
 else {
      request.setObjectRequest();
      doOp();
      Object returnObject=getResultAsObject();
      if (operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL && returnObject == null) {
        return null;
      }
      if (returnObject instanceof AddressAwareException) {
        rethrowException(operation,(AddressAwareException)returnObject);
      }
      request.longValue=Long.MIN_VALUE;
      backup(CONCURRENT_MAP_BACKUP_PUT);
      return returnObject;
    }
  }
}","private Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout,long ttl){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=threadContext.isClient() ? oldValue : threadContext.toObject(oldValue);
      }
      if (operation == ClusterOperation.CONCURRENT_MAP_PUT_IF_ABSENT && oldObject != null) {
        txn.attachPutOp(name,key,oldObject,0,ttl,false);
      }
 else {
        txn.attachPutOp(name,key,value,0,ttl,(oldObject == null));
      }
      return oldObject;
    }
 else {
      if (operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
        Object existingValue=txn.get(name,key);
        if (existingValue != null) {
          return existingValue;
        }
      }
      return txn.attachPutOp(name,key,value,false);
    }
  }
 else {
    setLocal(operation,name,key,value,timeout,ttl);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    if (operation == CONCURRENT_MAP_TRY_PUT) {
      request.setBooleanRequest();
      doOp();
      Boolean returnObject=getResultAsBoolean();
      if (returnObject) {
        backup(CONCURRENT_MAP_BACKUP_PUT);
      }
      return returnObject;
    }
 else {
      request.setObjectRequest();
      doOp();
      Object returnObject=getResultAsObject();
      if (operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL && returnObject == null) {
        return null;
      }
      if (returnObject instanceof AddressAwareException) {
        rethrowException(operation,(AddressAwareException)returnObject);
      }
      request.longValue=Long.MIN_VALUE;
      backup(CONCURRENT_MAP_BACKUP_PUT);
      return returnObject;
    }
  }
}",0.9787535410764872
50021,"public boolean removeItem(String name,Object key,Object value){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    try {
      boolean locked;
      if (!txn.has(name,key)) {
        MLock mlock=new MLock();
        locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
        if (!locked)         throwCME(key);
        Object oldObject=null;
        Data oldValue=mlock.oldValue;
        if (oldValue != null) {
          oldObject=threadContext.toObject(oldValue);
        }
        txn.attachRemoveOp(name,key,null,(oldObject == null));
        return (oldObject != null);
      }
 else {
        return (txn.attachRemoveOp(name,key,null,false) != null);
      }
    }
 catch (    Exception e1) {
      e1.printStackTrace();
    }
    return false;
  }
 else {
    boolean removed=booleanCall(CONCURRENT_MAP_REMOVE_ITEM,name,key,value,0,-1);
    if (removed) {
      backup(CONCURRENT_MAP_BACKUP_REMOVE);
    }
    return removed;
  }
}","public boolean removeItem(String name,Object key,Object value){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    try {
      boolean locked;
      if (!txn.has(name,key)) {
        MLock mlock=new MLock();
        locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
        if (!locked)         throwCME(key);
        Object oldObject=null;
        Data oldValue=mlock.oldValue;
        if (oldValue != null) {
          oldObject=threadContext.isClient() ? oldValue : threadContext.toObject(oldValue);
        }
        txn.attachRemoveOp(name,key,null,(oldObject == null));
        return (oldObject != null);
      }
 else {
        return (txn.attachRemoveOp(name,key,null,false) != null);
      }
    }
 catch (    Exception e1) {
      e1.printStackTrace();
    }
    return false;
  }
 else {
    boolean removed=booleanCall(CONCURRENT_MAP_REMOVE_ITEM,name,key,value,0,-1);
    if (removed) {
      backup(CONCURRENT_MAP_BACKUP_REMOVE);
    }
    return removed;
  }
}",0.9829443447037702
50022,"private void ensure(){
  factory.initialChecks();
  if (base == null) {
    base=(AtomicNumberReal)factory.getOrCreateProxyByName(name);
  }
}","private void ensure(){
  factory.initialChecks();
  if (base == null) {
    base=(AtomicNumber)factory.getOrCreateProxyByName(name);
  }
}",0.9857142857142858
50023,"/** 
 * Test for issue 157
 */
@Test(timeout=16000) public void testProxySerialization() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  Map map=h1.getMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  IQueue q=h1.getQueue(""String_Node_Str"");
  q.offer(""String_Node_Str"");
  MultiMap mm=h1.getMultiMap(""String_Node_Str"");
  mm.put(""String_Node_Str"",""String_Node_Str"");
  ILock lock=h1.getLock(""String_Node_Str"");
  lock.lock();
  ITopic topic=h1.getTopic(""String_Node_Str"");
  IdGenerator ig=h1.getIdGenerator(""String_Node_Str"");
  assertEquals(1,ig.newId());
  ISet set=h1.getSet(""String_Node_Str"");
  set.add(""String_Node_Str"");
  h2.getMap(""String_Node_Str"").put(""String_Node_Str"",map);
  h2.getMap(""String_Node_Str"").put(""String_Node_Str"",q);
  h2.getMap(""String_Node_Str"").put(""String_Node_Str"",mm);
  h2.getMap(""String_Node_Str"").put(""String_Node_Str"",lock);
  h2.getMap(""String_Node_Str"").put(""String_Node_Str"",topic);
  h2.getMap(""String_Node_Str"").put(""String_Node_Str"",ig);
  h2.getMap(""String_Node_Str"").put(""String_Node_Str"",set);
  Map m1=(Map)h1.getMap(""String_Node_Str"").get(""String_Node_Str"");
  Map m2=(Map)h2.getMap(""String_Node_Str"").get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",m1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",m2.get(""String_Node_Str""));
  IQueue q1=(IQueue)h1.getMap(""String_Node_Str"").get(""String_Node_Str"");
  IQueue q2=(IQueue)h2.getMap(""String_Node_Str"").get(""String_Node_Str"");
  assertEquals(1,q1.size());
  assertEquals(1,q2.size());
  assertEquals(""String_Node_Str"",q2.poll());
  MultiMap mm1=(MultiMap)h1.getMap(""String_Node_Str"").get(""String_Node_Str"");
  MultiMap mm2=(MultiMap)h2.getMap(""String_Node_Str"").get(""String_Node_Str"");
  assertTrue(mm1.get(""String_Node_Str"").contains(""String_Node_Str""));
  assertTrue(mm2.get(""String_Node_Str"").contains(""String_Node_Str""));
  ILock lock1=(ILock)h1.getMap(""String_Node_Str"").get(""String_Node_Str"");
  ILock lock2=(ILock)h2.getMap(""String_Node_Str"").get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",lock1.getLockObject());
  assertEquals(""String_Node_Str"",lock2.getLockObject());
  assertFalse(lock2.tryLock());
  ITopic topic1=(ITopic)h1.getMap(""String_Node_Str"").get(""String_Node_Str"");
  ITopic topic2=(ITopic)h2.getMap(""String_Node_Str"").get(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(2);
  topic1.addMessageListener(new MessageListener(){
    public void onMessage(    Object msg){
      assertEquals(""String_Node_Str"",msg);
      latch.countDown();
    }
  }
);
  topic2.addMessageListener(new MessageListener(){
    public void onMessage(    Object msg){
      assertEquals(""String_Node_Str"",msg);
      latch.countDown();
    }
  }
);
  topic.publish(""String_Node_Str"");
  assertTrue(latch.await(5,TimeUnit.SECONDS));
  IdGenerator ig1=(IdGenerator)h1.getMap(""String_Node_Str"").get(""String_Node_Str"");
  IdGenerator ig2=(IdGenerator)h2.getMap(""String_Node_Str"").get(""String_Node_Str"");
  assertEquals(2,ig1.newId());
  assertEquals(1000001,ig2.newId());
  ISet set1=(ISet)h1.getMap(""String_Node_Str"").get(""String_Node_Str"");
  ISet set2=(ISet)h2.getMap(""String_Node_Str"").get(""String_Node_Str"");
  assertTrue(set1.contains(""String_Node_Str""));
  assertTrue(set2.contains(""String_Node_Str""));
}","/** 
 * Test for issue 157
 */
@Test(timeout=16000) public void testProxySerialization() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  Map map=h1.getMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  IQueue q=h1.getQueue(""String_Node_Str"");
  q.offer(""String_Node_Str"");
  MultiMap mm=h1.getMultiMap(""String_Node_Str"");
  mm.put(""String_Node_Str"",""String_Node_Str"");
  ILock lock=h1.getLock(""String_Node_Str"");
  lock.lock();
  ITopic topic=h1.getTopic(""String_Node_Str"");
  IdGenerator ig=h1.getIdGenerator(""String_Node_Str"");
  AtomicNumber atomicNumber=h1.getAtomicNumber(""String_Node_Str"");
  atomicNumber.incrementAndGet();
  atomicNumber.incrementAndGet();
  assertEquals(2,atomicNumber.get());
  assertEquals(1,ig.newId());
  ISet set=h1.getSet(""String_Node_Str"");
  set.add(""String_Node_Str"");
  h2.getMap(""String_Node_Str"").put(""String_Node_Str"",map);
  h2.getMap(""String_Node_Str"").put(""String_Node_Str"",q);
  h2.getMap(""String_Node_Str"").put(""String_Node_Str"",mm);
  h2.getMap(""String_Node_Str"").put(""String_Node_Str"",lock);
  h2.getMap(""String_Node_Str"").put(""String_Node_Str"",topic);
  h2.getMap(""String_Node_Str"").put(""String_Node_Str"",ig);
  h2.getMap(""String_Node_Str"").put(""String_Node_Str"",set);
  h2.getMap(""String_Node_Str"").put(""String_Node_Str"",atomicNumber);
  Map m1=(Map)h1.getMap(""String_Node_Str"").get(""String_Node_Str"");
  Map m2=(Map)h2.getMap(""String_Node_Str"").get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",m1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",m2.get(""String_Node_Str""));
  IQueue q1=(IQueue)h1.getMap(""String_Node_Str"").get(""String_Node_Str"");
  IQueue q2=(IQueue)h2.getMap(""String_Node_Str"").get(""String_Node_Str"");
  assertEquals(1,q1.size());
  assertEquals(1,q2.size());
  assertEquals(""String_Node_Str"",q2.poll());
  MultiMap mm1=(MultiMap)h1.getMap(""String_Node_Str"").get(""String_Node_Str"");
  MultiMap mm2=(MultiMap)h2.getMap(""String_Node_Str"").get(""String_Node_Str"");
  assertTrue(mm1.get(""String_Node_Str"").contains(""String_Node_Str""));
  assertTrue(mm2.get(""String_Node_Str"").contains(""String_Node_Str""));
  ILock lock1=(ILock)h1.getMap(""String_Node_Str"").get(""String_Node_Str"");
  ILock lock2=(ILock)h2.getMap(""String_Node_Str"").get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",lock1.getLockObject());
  assertEquals(""String_Node_Str"",lock2.getLockObject());
  assertFalse(lock2.tryLock());
  ITopic topic1=(ITopic)h1.getMap(""String_Node_Str"").get(""String_Node_Str"");
  ITopic topic2=(ITopic)h2.getMap(""String_Node_Str"").get(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(2);
  topic1.addMessageListener(new MessageListener(){
    public void onMessage(    Object msg){
      assertEquals(""String_Node_Str"",msg);
      latch.countDown();
    }
  }
);
  topic2.addMessageListener(new MessageListener(){
    public void onMessage(    Object msg){
      assertEquals(""String_Node_Str"",msg);
      latch.countDown();
    }
  }
);
  topic.publish(""String_Node_Str"");
  assertTrue(latch.await(5,TimeUnit.SECONDS));
  IdGenerator ig1=(IdGenerator)h1.getMap(""String_Node_Str"").get(""String_Node_Str"");
  IdGenerator ig2=(IdGenerator)h2.getMap(""String_Node_Str"").get(""String_Node_Str"");
  assertEquals(2,ig1.newId());
  assertEquals(1000001,ig2.newId());
  ISet set1=(ISet)h1.getMap(""String_Node_Str"").get(""String_Node_Str"");
  ISet set2=(ISet)h2.getMap(""String_Node_Str"").get(""String_Node_Str"");
  assertTrue(set1.contains(""String_Node_Str""));
  assertTrue(set2.contains(""String_Node_Str""));
  AtomicNumber a1=(AtomicNumber)h1.getMap(""String_Node_Str"").get(""String_Node_Str"");
  AtomicNumber a2=(AtomicNumber)h2.getMap(""String_Node_Str"").get(""String_Node_Str"");
  assertEquals(2,a1.get());
  assertEquals(2,a2.get());
}",0.9352018870542528
50024,"public V get(long timeout,TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
  if (result != null) {
    return getResult();
  }
  setResult(remoteCall.getResponse(timeout,unit));
  return getResult();
}","public V get(long timeout,TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
  if (result != null) {
    return getResult();
  }
  processResult(remoteCall.getResponse(timeout,unit));
  return getResult();
}",0.978902953586498
50025,"protected Object getValue(Packet response){
  if (response.getValue() != null) {
    Object result=toObject(response.getValue());
    if (result instanceof ClientServiceException) {
      throw new RuntimeException(((ClientServiceException)result).getThrowable());
    }
    return result;
  }
  return null;
}","static Object getValue(Packet response){
  if (response.getValue() != null) {
    Object result=toObject(response.getValue());
    if (result instanceof ClientServiceException) {
      throw new RuntimeException(((ClientServiceException)result).getThrowable());
    }
    return result;
  }
  return null;
}",0.9756888168557536
50026,"@Test public void testMultiMapPutAndGet(){
  HazelcastClient hClient=getHazelcastClient();
  MultiMap<String,String> map=hClient.getMultiMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  Collection<String> values=map.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",values.iterator().next());
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  values=map.get(""String_Node_Str"");
  assertEquals(7,values.size());
}","@Test public void testMultiMapPutAndGet(){
  HazelcastClient hClient=getHazelcastClient();
  MultiMap<String,String> map=hClient.getMultiMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  Collection<String> values=map.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",values.iterator().next());
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  values=map.get(""String_Node_Str"");
  assertEquals(7,values.size());
  assertTrue(map.containsKey(""String_Node_Str""));
  assertFalse(map.containsKey(""String_Node_Str""));
}",0.9312457454050376
50027,"@Test public void testMultiMapRemoveEntries(){
  HazelcastClient hClient=getHazelcastClient();
  MultiMap<String,String> map=hClient.getMultiMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  boolean removed=map.remove(""String_Node_Str"",""String_Node_Str"");
  Assert.assertTrue(removed);
  assertEquals(6,map.size());
}","@Test public void testMultiMapRemoveEntries(){
  HazelcastClient hClient=getHazelcastClient();
  MultiMap<String,String> map=hClient.getMultiMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  boolean removed=map.remove(""String_Node_Str"",""String_Node_Str"");
  assertTrue(removed);
  assertEquals(6,map.size());
}",0.9944044764188648
50028,"@Test public void testMultiMapContainsEntry(){
  HazelcastClient hClient=getHazelcastClient();
  MultiMap<String,String> map=hClient.getMultiMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  Assert.assertTrue(map.containsEntry(""String_Node_Str"",""String_Node_Str""));
}","@Test public void testMultiMapContainsEntry(){
  HazelcastClient hClient=getHazelcastClient();
  MultiMap<String,String> map=hClient.getMultiMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertTrue(map.containsEntry(""String_Node_Str"",""String_Node_Str""));
}",0.9391304347826088
50029,"@Test public void testMultiMapContainsValue(){
  HazelcastClient hClient=getHazelcastClient();
  MultiMap<String,String> map=hClient.getMultiMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  Assert.assertTrue(map.containsValue(""String_Node_Str""));
}","@Test public void testMultiMapContainsValue(){
  HazelcastClient hClient=getHazelcastClient();
  MultiMap<String,String> map=hClient.getMultiMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertTrue(map.containsValue(""String_Node_Str""));
}",0.935064935064935
50030,"@Test public void testMultiMapContainsKey(){
  HazelcastClient hClient=getHazelcastClient();
  MultiMap<String,String> map=hClient.getMultiMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  Assert.assertTrue(map.containsKey(""String_Node_Str""));
}","@Test public void testMultiMapContainsKey(){
  HazelcastClient hClient=getHazelcastClient();
  MultiMap<String,String> map=hClient.getMultiMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertTrue(map.containsKey(""String_Node_Str""));
}",0.9340866290018832
50031,"CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.logger=concurrentMapManager.node.getLogger(CMap.class.getName());
  this.PARTITION_COUNT=concurrentMapManager.PARTITION_COUNT;
  this.blocks=concurrentMapManager.blocks;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  mapForQueue=name.startsWith(""String_Node_Str"");
  instanceType=ConcurrentMapManager.getInstanceType(name);
  MapConfig mapConfig=null;
  String mapConfigName=name.substring(2);
  if (isMultiMap() || mapConfigName.startsWith(""String_Node_Str"") || mapConfigName.startsWith(AS_LIST)|| mapConfigName.startsWith(AS_SET)) {
    mapConfig=new MapConfig();
  }
 else {
    mapConfig=node.getConfig().getMapConfig(mapConfigName);
  }
  this.mapIndexService=new MapIndexService(mapConfig.isValueIndexed());
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  evictionDelayMillis=mapConfig.getEvictionDelaySeconds() * 1000L;
  maxIdle=mapConfig.getMaxIdleSeconds() * 1000L;
  evictionPolicy=EvictionPolicy.valueOf(mapConfig.getEvictionPolicy());
  readBackupData=mapConfig.isReadBackupData();
  cacheValue=mapConfig.isCacheValue();
  if (evictionPolicy == EvictionPolicy.NONE) {
    maxSize=Integer.MAX_VALUE;
    evictionComparator=null;
  }
 else {
    maxSize=(mapConfig.getMaxSize() == 0) ? MapConfig.DEFAULT_MAX_SIZE : mapConfig.getMaxSize();
    if (evictionPolicy == EvictionPolicy.LRU) {
      evictionComparator=new ComparatorWrapper(LRU_COMPARATOR);
    }
 else {
      evictionComparator=new ComparatorWrapper(LFU_COMPARATOR);
    }
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100f;
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  MapStoreWrapper mapStoreWrapper=null;
  int writeDelaySeconds=-1;
  if (!node.isSuperClient() && mapStoreConfig != null && mapStoreConfig.isEnabled()) {
    try {
      Object storeInstance=mapStoreConfig.getImplementation();
      if (storeInstance == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeInstance=Serializer.classForName(node.getConfig().getClassLoader(),mapStoreClassName).newInstance();
      }
      mapStoreWrapper=new MapStoreWrapper(storeInstance,node.factory.getHazelcastInstanceProxy(),mapStoreConfig.getProperties(),mapConfigName);
    }
 catch (    Exception e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
    writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
  }
  writeDelayMillis=(writeDelaySeconds == -1) ? -1L : writeDelaySeconds * 1000L;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + writeDelaySeconds;
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  loader=(mapStoreWrapper == null || !mapStoreWrapper.isMapLoader()) ? null : mapStoreWrapper;
  store=(mapStoreWrapper == null || !mapStoreWrapper.isMapStore()) ? null : mapStoreWrapper;
  NearCacheConfig nearCacheConfig=mapConfig.getNearCacheConfig();
  if (nearCacheConfig == null) {
    mapNearCache=null;
  }
 else {
    MapNearCache mapNearCache=new MapNearCache(this,SortedHashMap.getOrderingTypeByName(nearCacheConfig.getEvictionPolicy()),nearCacheConfig.getMaxSize(),nearCacheConfig.getTimeToLiveSeconds() * 1000L,nearCacheConfig.getMaxIdleSeconds() * 1000L,nearCacheConfig.isInvalidateOnChange());
    final MapNearCache anotherMapNearCache=concurrentMapManager.mapCaches.putIfAbsent(name,mapNearCache);
    if (anotherMapNearCache != null) {
      mapNearCache=anotherMapNearCache;
    }
    this.mapNearCache=mapNearCache;
  }
  MergePolicy mergePolicyTemp=null;
  String mergePolicyName=mapConfig.getMergePolicy();
  if (mergePolicyName != null && !""String_Node_Str"".equalsIgnoreCase(mergePolicyName)) {
    MergePolicyConfig mergePolicyConfig=node.getConfig().getMergePolicyConfig(mapConfig.getMergePolicy());
    if (mergePolicyConfig != null) {
      mergePolicyTemp=mergePolicyConfig.getImplementation();
      if (mergePolicyTemp == null) {
        String mergeClassName=mergePolicyConfig.getClassName();
        try {
          mergePolicyTemp=(MergePolicy)Serializer.classForName(node.getConfig().getClassLoader(),mergeClassName).newInstance();
        }
 catch (        Exception e) {
          logger.log(Level.SEVERE,e.getMessage(),e);
        }
      }
    }
  }
  this.mergePolicy=mergePolicyTemp;
  this.creationTime=System.currentTimeMillis();
}","CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.logger=concurrentMapManager.node.getLogger(CMap.class.getName());
  this.PARTITION_COUNT=concurrentMapManager.PARTITION_COUNT;
  this.blocks=concurrentMapManager.blocks;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  mapForQueue=name.startsWith(""String_Node_Str"");
  instanceType=ConcurrentMapManager.getInstanceType(name);
  MapConfig mapConfig=null;
  String mapConfigName=name.substring(2);
  if (isMultiMap() || mapConfigName.startsWith(""String_Node_Str"") || mapConfigName.startsWith(AS_LIST)|| mapConfigName.startsWith(AS_SET)|| mapForQueue) {
    mapConfig=new MapConfig();
  }
 else {
    mapConfig=node.getConfig().getMapConfig(mapConfigName);
  }
  this.mapIndexService=new MapIndexService(mapConfig.isValueIndexed());
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  evictionDelayMillis=mapConfig.getEvictionDelaySeconds() * 1000L;
  maxIdle=mapConfig.getMaxIdleSeconds() * 1000L;
  evictionPolicy=EvictionPolicy.valueOf(mapConfig.getEvictionPolicy());
  readBackupData=mapConfig.isReadBackupData();
  cacheValue=mapConfig.isCacheValue();
  if (evictionPolicy == EvictionPolicy.NONE) {
    maxSize=Integer.MAX_VALUE;
    evictionComparator=null;
  }
 else {
    maxSize=(mapConfig.getMaxSize() == 0) ? MapConfig.DEFAULT_MAX_SIZE : mapConfig.getMaxSize();
    if (evictionPolicy == EvictionPolicy.LRU) {
      evictionComparator=new ComparatorWrapper(LRU_COMPARATOR);
    }
 else {
      evictionComparator=new ComparatorWrapper(LFU_COMPARATOR);
    }
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100f;
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  MapStoreWrapper mapStoreWrapper=null;
  int writeDelaySeconds=-1;
  if (!node.isSuperClient() && mapStoreConfig != null && mapStoreConfig.isEnabled()) {
    try {
      Object storeInstance=mapStoreConfig.getImplementation();
      if (storeInstance == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeInstance=Serializer.classForName(node.getConfig().getClassLoader(),mapStoreClassName).newInstance();
      }
      mapStoreWrapper=new MapStoreWrapper(storeInstance,node.factory.getHazelcastInstanceProxy(),mapStoreConfig.getProperties(),mapConfigName);
    }
 catch (    Exception e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
    writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
  }
  writeDelayMillis=(writeDelaySeconds == -1) ? -1L : writeDelaySeconds * 1000L;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + writeDelaySeconds;
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  loader=(mapStoreWrapper == null || !mapStoreWrapper.isMapLoader()) ? null : mapStoreWrapper;
  store=(mapStoreWrapper == null || !mapStoreWrapper.isMapStore()) ? null : mapStoreWrapper;
  NearCacheConfig nearCacheConfig=mapConfig.getNearCacheConfig();
  if (nearCacheConfig == null) {
    mapNearCache=null;
  }
 else {
    MapNearCache mapNearCache=new MapNearCache(this,SortedHashMap.getOrderingTypeByName(nearCacheConfig.getEvictionPolicy()),nearCacheConfig.getMaxSize(),nearCacheConfig.getTimeToLiveSeconds() * 1000L,nearCacheConfig.getMaxIdleSeconds() * 1000L,nearCacheConfig.isInvalidateOnChange());
    final MapNearCache anotherMapNearCache=concurrentMapManager.mapCaches.putIfAbsent(name,mapNearCache);
    if (anotherMapNearCache != null) {
      mapNearCache=anotherMapNearCache;
    }
    this.mapNearCache=mapNearCache;
  }
  MergePolicy mergePolicyTemp=null;
  String mergePolicyName=mapConfig.getMergePolicy();
  if (mergePolicyName != null && !""String_Node_Str"".equalsIgnoreCase(mergePolicyName)) {
    MergePolicyConfig mergePolicyConfig=node.getConfig().getMergePolicyConfig(mapConfig.getMergePolicy());
    if (mergePolicyConfig != null) {
      mergePolicyTemp=mergePolicyConfig.getImplementation();
      if (mergePolicyTemp == null) {
        String mergeClassName=mergePolicyConfig.getClassName();
        try {
          mergePolicyTemp=(MergePolicy)Serializer.classForName(node.getConfig().getClassLoader(),mergeClassName).newInstance();
        }
 catch (        Exception e) {
          logger.log(Level.SEVERE,e.getMessage(),e);
        }
      }
    }
  }
  this.mergePolicy=mergePolicyTemp;
  this.creationTime=System.currentTimeMillis();
}",0.9984499557130204
50032,"public void put(Request req){
  long now=System.currentTimeMillis();
  boolean sendEvictEvent=false;
  Record evictedRecord=null;
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req);
  if (record != null && !record.isValid(now)) {
    if (record.isEvictable()) {
      sendEvictEvent=true;
      evictedRecord=createNewRecord(record.getKeyData(),record.getValueData());
    }
    record.setValue(null);
    record.setMultiValues(null);
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (record != null && record.isActive() && record.isValid(now) && record.getValueData() != null) {
      req.clearForResponse();
      req.response=record.getValueData();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (record == null || !record.isActive() || !record.isValid(now) || record.getValueData() == null) {
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (record == null || !record.isActive() || !record.isValid(now)) {
      req.response=Boolean.FALSE;
      return;
    }
    MultiData multiData=(MultiData)toObject(req.value);
    if (multiData == null || multiData.size() != 2) {
      throw new RuntimeException(""String_Node_Str"" + multiData);
    }
    Data expectedOldValue=multiData.getData(0);
    req.value=multiData.getData(1);
    if (!expectedOldValue.equals(record.getValueData())) {
      req.response=Boolean.FALSE;
      return;
    }
  }
  Data oldValue=null;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    mapRecords.put(req.key,record);
  }
 else {
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValueData() : null;
    record.setValue(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0 && req.ttl < Long.MAX_VALUE) {
    record.setExpirationTime(req.ttl);
    ttlPerRecord=true;
  }
  if (sendEvictEvent) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_EVICTED,null,evictedRecord,req.caller);
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_ADDED,null,record,req.caller);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_UPDATED,oldValue,record,req.caller);
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateIndexes(record);
  markAsDirty(record);
  req.clearForResponse();
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
  if (mapForQueue) {
  }
}","public void put(Request req){
  long now=System.currentTimeMillis();
  boolean sendEvictEvent=false;
  Record evictedRecord=null;
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req);
  if (record != null && !record.isValid(now)) {
    if (record.isEvictable()) {
      sendEvictEvent=true;
      evictedRecord=createNewRecord(record.getKeyData(),record.getValueData());
    }
    record.setValue(null);
    record.setMultiValues(null);
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (record != null && record.isActive() && record.isValid(now) && record.getValueData() != null) {
      req.clearForResponse();
      req.response=record.getValueData();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (record == null || !record.isActive() || !record.isValid(now) || record.getValueData() == null) {
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (record == null || !record.isActive() || !record.isValid(now)) {
      req.response=Boolean.FALSE;
      return;
    }
    MultiData multiData=(MultiData)toObject(req.value);
    if (multiData == null || multiData.size() != 2) {
      throw new RuntimeException(""String_Node_Str"" + multiData);
    }
    Data expectedOldValue=multiData.getData(0);
    req.value=multiData.getData(1);
    if (!expectedOldValue.equals(record.getValueData())) {
      req.response=Boolean.FALSE;
      return;
    }
  }
  Data oldValue=null;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    mapRecords.put(req.key,record);
  }
 else {
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValueData() : null;
    record.setValue(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0 && req.ttl < Long.MAX_VALUE) {
    record.setExpirationTime(req.ttl);
    ttlPerRecord=true;
  }
  if (sendEvictEvent) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_EVICTED,null,evictedRecord,req.caller);
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_ADDED,null,record,req.caller);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_UPDATED,oldValue,record,req.caller);
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateIndexes(record);
  markAsDirty(record);
  req.clearForResponse();
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}",0.9954404523071312
50033,"public long addAndGet(long delta){
  ConcurrentMapManager.MAtomic a=newMAtomic(ClusterOperation.ATOMIC_NUMBER_ADD_AND_GET,delta);
  long result=a.doLongAtomic();
  a.backup(result - delta);
  return result;
}","public long addAndGet(long delta){
  ConcurrentMapManager.MAtomic a=newMAtomic(ClusterOperation.ATOMIC_NUMBER_ADD_AND_GET,delta);
  long result=a.doLongAtomic();
  a.backup(result);
  return result;
}",0.9803921568627452
50034,"private int dequeuePackets(){
  Packet packet=null;
  try {
    for (int i=0; i < PACKET_BULK_SIZE; i++) {
      checkPeriodics();
      packet=packetQueue.poll();
      if (packet == null) {
        return i;
      }
      processPacket(packet);
    }
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,""String_Node_Str"" + packet,e);
  }
  return PACKET_BULK_SIZE;
}","private int dequeuePackets() throws Throwable {
  Packet packet=null;
  try {
    for (int i=0; i < PACKET_BULK_SIZE; i++) {
      checkPeriodics();
      packet=packetQueue.poll();
      if (packet == null) {
        return i;
      }
      processPacket(packet);
    }
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,""String_Node_Str"" + packet,e);
    throw e;
  }
  return PACKET_BULK_SIZE;
}",0.96010296010296
50035,"private int dequeueProcessables(){
  Processable processable=null;
  try {
    for (int i=0; i < PROCESSABLE_BULK_SIZE; i++) {
      checkPeriodics();
      processable=processableQueue.poll();
      if (processable == null) {
        return i;
      }
      processProcessable(processable);
    }
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,""String_Node_Str"" + processable,e);
  }
  return PACKET_BULK_SIZE;
}","private int dequeueProcessables() throws Throwable {
  Processable processable=null;
  try {
    for (int i=0; i < PROCESSABLE_BULK_SIZE; i++) {
      checkPeriodics();
      processable=processableQueue.poll();
      if (processable == null) {
        return i;
      }
      processProcessable(processable);
    }
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,""String_Node_Str"" + processable,e);
    throw e;
  }
  return PACKET_BULK_SIZE;
}",0.9646522234891676
50036,"public boolean enqueueAndWait(final Processable processable,final int seconds){
  try {
    final CountDownLatch l=new CountDownLatch(1);
    enqueueAndReturn(new Processable(){
      public void process(){
        processable.process();
        l.countDown();
      }
    }
);
    return l.await(seconds,TimeUnit.SECONDS);
  }
 catch (  InterruptedException ignored) {
  }
  return false;
}","public boolean enqueueAndWait(final Processable processable,final int seconds){
  try {
    final CountDownLatch l=new CountDownLatch(1);
    enqueueAndReturn(new Processable(){
      public void process(){
        processable.process();
        l.countDown();
      }
    }
);
    node.checkNodeState();
    return l.await(seconds,TimeUnit.SECONDS);
  }
 catch (  InterruptedException ignored) {
  }
  return false;
}",0.9666254635352288
50037,"public Node(FactoryImpl factory,Config config){
  this.id=counter.incrementAndGet();
  this.threadGroup=new ThreadGroup(factory.getName());
  this.factory=factory;
  this.config=config;
  this.groupProperties=new GroupProperties(config);
  this.superClient=config.isSuperClient();
  this.localNodeType=(superClient) ? NodeType.SUPER_CLIENT : NodeType.MEMBER;
  String version=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  String build=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  if (""String_Node_Str"".equals(version) || ""String_Node_Str"".equals(build)) {
    try {
      InputStream inRuntimeProperties=Node.class.getClassLoader().getResourceAsStream(""String_Node_Str"");
      if (inRuntimeProperties != null) {
        Properties runtimeProperties=new Properties();
        runtimeProperties.load(inRuntimeProperties);
        version=runtimeProperties.getProperty(""String_Node_Str"");
        build=runtimeProperties.getProperty(""String_Node_Str"");
      }
    }
 catch (    Exception ignored) {
    }
  }
  int tmpBuildNumber=0;
  try {
    tmpBuildNumber=Integer.getInteger(""String_Node_Str"",-1);
    if (tmpBuildNumber == -1) {
      tmpBuildNumber=Integer.parseInt(build);
    }
  }
 catch (  Exception ignored) {
  }
  buildNumber=tmpBuildNumber;
  ServerSocketChannel serverSocketChannel;
  Address localAddress=null;
  try {
    final String preferIPv4Stack=System.getProperty(""String_Node_Str"");
    final String preferIPv6Address=System.getProperty(""String_Node_Str"");
    if (preferIPv6Address == null && preferIPv4Stack == null) {
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
    serverSocketChannel=ServerSocketChannel.open();
    AddressPicker addressPicker=new AddressPicker(this,serverSocketChannel);
    localAddress=addressPicker.pickAddress();
    localAddress.setThisAddress(true);
  }
 catch (  Throwable e) {
    throw new RuntimeException(e);
  }
  address=localAddress;
  localMember=new MemberImpl(address,true,localNodeType);
  packetPool=new NoneStrictObjectPool<Packet>(2000){
    @Override public Packet obtain(){
      return createNew();
    }
    @Override public boolean release(    Packet packet){
      return true;
    }
    @Override public void onObtain(    Packet packet){
    }
    @Override public void onRelease(    Packet packet){
    }
    public Packet createNew(){
      return new Packet();
    }
  }
;
  this.loggingService=new LoggingServiceImpl(config.getGroupConfig().getName(),localMember);
  this.logger=loggingService.getLogger(Node.class.getName());
  clusterImpl=new ClusterImpl(this,localMember);
  baseVariables=new NodeBaseVariables(address,localMember);
  clusterService=new ClusterService(this);
  clusterService.start();
  inSelector=new InSelector(this,serverSocketChannel);
  outSelector=new OutSelector(this);
  connectionManager=new ConnectionManager(this);
  clusterManager=new ClusterManager(this);
  executorManager=new ExecutorManager(this);
  clientService=new ClientService(this);
  concurrentMapManager=new ConcurrentMapManager(this);
  blockingQueueManager=new BlockingQueueManager(this);
  listenerManager=new ListenerManager(this);
  topicManager=new TopicManager(this);
  textCommandService=new TextCommandServiceImpl(this);
  clusterManager.addMember(false,localMember);
  ILogger systemLogger=getLogger(""String_Node_Str"");
  systemLogger.log(Level.INFO,""String_Node_Str"" + version + ""String_Node_Str""+ build+ ""String_Node_Str""+ address);
  systemLogger.log(Level.INFO,""String_Node_Str"");
  Join join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(join.getMulticastConfig().getMulticastPort()));
      multicastSocket.setTimeToLive(32);
      multicastSocket.setInterface(address.getInetAddress());
      multicastSocket.setReceiveBufferSize(1024);
      multicastSocket.setSendBufferSize(1024);
      multicastSocket.joinGroup(InetAddress.getByName(join.getMulticastConfig().getMulticastGroup()));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
  this.multicastService=mcService;
}","public Node(FactoryImpl factory,Config config){
  this.id=counter.incrementAndGet();
  this.threadGroup=new ThreadGroup(factory.getName());
  this.factory=factory;
  this.config=config;
  this.groupProperties=new GroupProperties(config);
  this.superClient=config.isSuperClient();
  this.localNodeType=(superClient) ? NodeType.SUPER_CLIENT : NodeType.MEMBER;
  String version=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  String build=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  if (""String_Node_Str"".equals(version) || ""String_Node_Str"".equals(build)) {
    try {
      InputStream inRuntimeProperties=Node.class.getClassLoader().getResourceAsStream(""String_Node_Str"");
      if (inRuntimeProperties != null) {
        Properties runtimeProperties=new Properties();
        runtimeProperties.load(inRuntimeProperties);
        version=runtimeProperties.getProperty(""String_Node_Str"");
        build=runtimeProperties.getProperty(""String_Node_Str"");
      }
    }
 catch (    Exception ignored) {
    }
  }
  int tmpBuildNumber=0;
  try {
    tmpBuildNumber=Integer.getInteger(""String_Node_Str"",-1);
    if (tmpBuildNumber == -1) {
      tmpBuildNumber=Integer.parseInt(build);
    }
  }
 catch (  Exception ignored) {
  }
  buildNumber=tmpBuildNumber;
  ServerSocketChannel serverSocketChannelTemp=null;
  Address localAddress=null;
  try {
    final String preferIPv4Stack=System.getProperty(""String_Node_Str"");
    final String preferIPv6Address=System.getProperty(""String_Node_Str"");
    if (preferIPv6Address == null && preferIPv4Stack == null) {
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
    serverSocketChannelTemp=ServerSocketChannel.open();
    AddressPicker addressPicker=new AddressPicker(this,serverSocketChannelTemp);
    localAddress=addressPicker.pickAddress();
    localAddress.setThisAddress(true);
  }
 catch (  Throwable e) {
    throw new RuntimeException(e);
  }
  serverSocketChannel=serverSocketChannelTemp;
  address=localAddress;
  localMember=new MemberImpl(address,true,localNodeType);
  packetPool=new NoneStrictObjectPool<Packet>(2000){
    @Override public Packet obtain(){
      return createNew();
    }
    @Override public boolean release(    Packet packet){
      return true;
    }
    @Override public void onObtain(    Packet packet){
    }
    @Override public void onRelease(    Packet packet){
    }
    public Packet createNew(){
      return new Packet();
    }
  }
;
  this.loggingService=new LoggingServiceImpl(config.getGroupConfig().getName(),localMember);
  this.logger=loggingService.getLogger(Node.class.getName());
  clusterImpl=new ClusterImpl(this,localMember);
  baseVariables=new NodeBaseVariables(address,localMember);
  clusterService=new ClusterService(this);
  clusterService.start();
  inSelector=new InSelector(this,serverSocketChannel);
  outSelector=new OutSelector(this);
  connectionManager=new ConnectionManager(this);
  clusterManager=new ClusterManager(this);
  executorManager=new ExecutorManager(this);
  clientService=new ClientService(this);
  concurrentMapManager=new ConcurrentMapManager(this);
  blockingQueueManager=new BlockingQueueManager(this);
  listenerManager=new ListenerManager(this);
  topicManager=new TopicManager(this);
  textCommandService=new TextCommandServiceImpl(this);
  clusterManager.addMember(false,localMember);
  ILogger systemLogger=getLogger(""String_Node_Str"");
  systemLogger.log(Level.INFO,""String_Node_Str"" + version + ""String_Node_Str""+ build+ ""String_Node_Str""+ address);
  systemLogger.log(Level.INFO,""String_Node_Str"");
  Join join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(join.getMulticastConfig().getMulticastPort()));
      multicastSocket.setTimeToLive(32);
      multicastSocket.setInterface(address.getInetAddress());
      multicastSocket.setReceiveBufferSize(1024);
      multicastSocket.setSendBufferSize(1024);
      multicastSocket.joinGroup(InetAddress.getByName(join.getMulticastConfig().getMulticastGroup()));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
  this.multicastService=mcService;
}",0.9929234851835472
50038,"void checkNodeState(){
  if (factory.restarted) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else   if (!isActive()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
}","public void checkNodeState(){
  if (factory.restarted) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else   if (!isActive()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
}",0.9826302729528535
50039,"public PartitionReal getPartitionReal(final int partitionId){
  PartitionReal partitionReal=mapRealPartitions.get(partitionId);
  if (partitionReal == null) {
    final BlockingQueue<PartitionReal> responseQ=ResponseQueueFactory.newResponseQueue();
    concurrentMapManager.enqueueAndReturn(new Processable(){
      public void process(){
        Block block=concurrentMapManager.partitionManager.getOrCreateBlock(partitionId);
        MemberImpl memberOwner=null;
        MemberImpl memberMigration=null;
        if (block.getOwner() != null) {
          if (concurrentMapManager.thisAddress.equals(block.getOwner())) {
            memberOwner=concurrentMapManager.thisMember;
          }
 else {
            memberOwner=concurrentMapManager.getMember(block.getOwner());
          }
        }
        if (block.getMigrationAddress() != null) {
          if (concurrentMapManager.thisAddress.equals(block.getMigrationAddress())) {
            memberMigration=concurrentMapManager.thisMember;
          }
 else {
            memberMigration=concurrentMapManager.getMember(block.getMigrationAddress());
          }
        }
        responseQ.offer(new PartitionReal(partitionId,memberOwner,memberMigration));
      }
    }
);
    try {
      partitionReal=responseQ.take();
      mapRealPartitions.put(partitionId,partitionReal);
      return partitionReal;
    }
 catch (    InterruptedException ignored) {
    }
  }
  return partitionReal;
}","public PartitionReal getPartitionReal(final int partitionId){
  PartitionReal partitionReal=mapRealPartitions.get(partitionId);
  if (partitionReal == null) {
    final BlockingQueue<PartitionReal> responseQ=ResponseQueueFactory.newResponseQueue();
    concurrentMapManager.enqueueAndReturn(new Processable(){
      public void process(){
        Block block=concurrentMapManager.partitionManager.getOrCreateBlock(partitionId);
        MemberImpl memberOwner=null;
        MemberImpl memberMigration=null;
        if (block.getOwner() != null) {
          if (concurrentMapManager.thisAddress.equals(block.getOwner())) {
            memberOwner=concurrentMapManager.thisMember;
          }
 else {
            memberOwner=concurrentMapManager.getMember(block.getOwner());
          }
        }
        if (block.getMigrationAddress() != null) {
          if (concurrentMapManager.thisAddress.equals(block.getMigrationAddress())) {
            memberMigration=concurrentMapManager.thisMember;
          }
 else {
            memberMigration=concurrentMapManager.getMember(block.getMigrationAddress());
          }
        }
        responseQ.offer(new PartitionReal(partitionId,memberOwner,memberMigration));
      }
    }
);
    try {
      while (partitionReal == null) {
        partitionReal=responseQ.poll(5,TimeUnit.SECONDS);
        if (partitionVersion == null) {
          concurrentMapManager.node.checkNodeState();
        }
      }
      mapRealPartitions.put(partitionId,partitionReal);
      return partitionReal;
    }
 catch (    InterruptedException ignored) {
    }
  }
  return partitionReal;
}",0.9430255402750491
50040,"public final void run(){
  try {
    while (live) {
      if (threadWatcher.incrementRunCount() % 10000 == 0) {
        publishUtilization();
      }
      processSelectionQueue();
      if (!live)       return;
      int selectedKeyCount;
      try {
        long startWait=System.nanoTime();
        selectedKeyCount=selector.select(waitTime);
        long now=System.nanoTime();
        threadWatcher.addWait((now - startWait),now);
        if (Thread.interrupted()) {
          node.handleInterruptedException(Thread.currentThread(),new RuntimeException());
          return;
        }
      }
 catch (      Throwable exp) {
        continue;
      }
      if (selectedKeyCount == 0) {
        continue;
      }
      final Set<SelectionKey> setSelectedKeys=selector.selectedKeys();
      final Iterator<SelectionKey> it=setSelectedKeys.iterator();
      while (it.hasNext()) {
        final SelectionKey sk=it.next();
        it.remove();
        try {
          sk.interestOps(sk.interestOps() & ~sk.readyOps());
          SelectionHandler selectionHandler=(SelectionHandler)sk.attachment();
          selectionHandler.handle();
        }
 catch (        CancelledKeyException e) {
        }
catch (        Throwable e) {
          handleSelectorException(e);
        }
      }
    }
  }
 catch (  Throwable e) {
    logger.log(Level.WARNING,""String_Node_Str"" + Thread.currentThread().getName(),e);
  }
 finally {
    try {
      logger.log(Level.FINE,""String_Node_Str"" + Thread.currentThread().getName());
      selector.close();
    }
 catch (    final Exception ignored) {
    }
  }
}","public final void run(){
  try {
    while (live) {
      if (threadWatcher.incrementRunCount() % 10000 == 0) {
        publishUtilization();
      }
      processSelectionQueue();
      if (!live)       return;
      int selectedKeyCount;
      try {
        long startWait=System.nanoTime();
        selectedKeyCount=selector.select(waitTime);
        long now=System.nanoTime();
        threadWatcher.addWait((now - startWait),now);
        if (Thread.interrupted()) {
          node.handleInterruptedException(Thread.currentThread(),new RuntimeException());
          return;
        }
      }
 catch (      Throwable exp) {
        continue;
      }
      if (selectedKeyCount == 0) {
        continue;
      }
      final Set<SelectionKey> setSelectedKeys=selector.selectedKeys();
      final Iterator<SelectionKey> it=setSelectedKeys.iterator();
      while (it.hasNext()) {
        final SelectionKey sk=it.next();
        it.remove();
        try {
          sk.interestOps(sk.interestOps() & ~sk.readyOps());
          SelectionHandler selectionHandler=(SelectionHandler)sk.attachment();
          selectionHandler.handle();
        }
 catch (        CancelledKeyException e) {
        }
catch (        Throwable e) {
          handleSelectorException(e);
        }
      }
    }
  }
 catch (  OutOfMemoryError e) {
    e.printStackTrace();
    node.onOutOfMemory();
  }
catch (  Throwable e) {
    logger.log(Level.WARNING,""String_Node_Str"" + Thread.currentThread().getName(),e);
  }
 finally {
    try {
      logger.log(Level.FINE,""String_Node_Str"" + Thread.currentThread().getName());
      selector.close();
    }
 catch (    final Exception ignored) {
    }
  }
}",0.9737163814180928
50041,"public Object get(String name,Object key,long timeout){
  this.keyObject=key;
  final ThreadContext tc=ThreadContext.get();
  TransactionImpl txn=tc.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (txn.has(name,key)) {
      return txn.get(name,key);
    }
  }
  final CMap cMap=maps.get(name);
  if (cMap != null) {
    nearCache=cMap.mapNearCache;
    if (nearCache != null) {
      Object value=nearCache.get(key);
      if (value != null) {
        return value;
      }
    }
    final Data dataKey=toData(key);
    Record ownedRecord=cMap.getOwnedRecord(dataKey);
    if (ownedRecord != null && ownedRecord.isActive() && ownedRecord.isValid()) {
      long version=ownedRecord.getVersion();
      Object result=null;
      if (tc.isClient()) {
        final Data valueData=ownedRecord.getValueData();
        if (valueData != null && valueData.size() > 0) {
          result=valueData;
        }
      }
 else {
        final Object value=ownedRecord.getValue();
        if (value != null) {
          result=value;
        }
      }
      if (result != null && ownedRecord.getVersion() == version) {
        ownedRecord.setLastAccessed();
        return result;
      }
    }
    if (cMap.readBackupData) {
      final Record record=cMap.mapRecords.get(dataKey);
      if (record != null && cMap.isBackup(record) && record.isActive() && record.isValid()) {
        final Data valueData=record.getValueData();
        if (valueData != null && valueData.size() > 0) {
          return tc.isClient() ? valueData : toObject(valueData);
        }
      }
    }
  }
  Object value=objectCall(CONCURRENT_MAP_GET,name,key,null,timeout,-1);
  if (value instanceof AddressAwareException) {
    rethrowException(request.operation,(AddressAwareException)value);
  }
  return value;
}","public Object get(String name,Object key,long timeout){
  this.keyObject=key;
  final ThreadContext tc=ThreadContext.get();
  TransactionImpl txn=tc.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (txn.has(name,key)) {
      return txn.get(name,key);
    }
  }
  final CMap cMap=maps.get(name);
  if (cMap != null) {
    MapNearCache nearCache=cMap.mapNearCache;
    if (nearCache != null) {
      Object value=nearCache.get(key);
      if (value != null) {
        return value;
      }
    }
    final Data dataKey=toData(key);
    Record ownedRecord=cMap.getOwnedRecord(dataKey);
    if (ownedRecord != null && ownedRecord.isActive() && ownedRecord.isValid()) {
      long version=ownedRecord.getVersion();
      Object result=null;
      if (tc.isClient()) {
        final Data valueData=ownedRecord.getValueData();
        if (valueData != null && valueData.size() > 0) {
          result=valueData;
        }
      }
 else {
        final Object value=ownedRecord.getValue();
        if (value != null) {
          result=value;
        }
      }
      if (result != null && ownedRecord.getVersion() == version) {
        ownedRecord.setLastAccessed();
        return result;
      }
    }
    if (cMap.readBackupData) {
      final Record record=cMap.mapRecords.get(dataKey);
      if (record != null && cMap.isBackup(record) && record.isActive() && record.isValid()) {
        final Data valueData=record.getValueData();
        if (valueData != null && valueData.size() > 0) {
          return tc.isClient() ? valueData : toObject(valueData);
        }
      }
    }
  }
  Object value=objectCall(CONCURRENT_MAP_GET,name,key,null,timeout,-1);
  if (value instanceof AddressAwareException) {
    rethrowException(request.operation,(AddressAwareException)value);
  }
  return value;
}",0.9964893329732648
50042,"public void shutdown(){
  logger.log(Level.FINE,""String_Node_Str"" + String.valueOf(active));
  if (isActive()) {
    long start=System.currentTimeMillis();
    joined=false;
    setActive(false);
    try {
      Runtime.getRuntime().removeShutdownHook(shutdownHookThread);
    }
 catch (    Throwable ignored) {
    }
    logger.log(Level.FINEST,""String_Node_Str"");
    clientService.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    inSelector.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    outSelector.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    clusterService.stop();
    logger.log(Level.FINEST,""String_Node_Str"");
    if (multicastService != null) {
      multicastService.stop();
    }
    logger.log(Level.FINEST,""String_Node_Str"");
    connectionManager.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    logger.log(Level.FINEST,""String_Node_Str"");
    executorManager.stop();
    textCommandService.stop();
    masterAddress=null;
    packetPool.clear();
    logger.log(Level.FINEST,""String_Node_Str"");
    int numThreads=threadGroup.activeCount();
    Thread[] threads=new Thread[numThreads * 2];
    numThreads=threadGroup.enumerate(threads,false);
    for (int i=0; i < numThreads; i++) {
      Thread thread=threads[i];
      logger.log(Level.FINEST,""String_Node_Str"" + thread.getName());
      thread.interrupt();
    }
    logger.log(Level.INFO,""String_Node_Str"" + (System.currentTimeMillis() - start) + ""String_Node_Str"");
  }
}","public void shutdown(){
  logger.log(Level.FINE,""String_Node_Str"" + String.valueOf(active));
  while (isActive() && concurrentMapManager.partitionManager.hasActiveBackupTask()) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
  }
  if (isActive()) {
    long start=System.currentTimeMillis();
    joined=false;
    setActive(false);
    try {
      Runtime.getRuntime().removeShutdownHook(shutdownHookThread);
    }
 catch (    Throwable ignored) {
    }
    logger.log(Level.FINEST,""String_Node_Str"");
    clientService.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    inSelector.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    outSelector.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    clusterService.stop();
    logger.log(Level.FINEST,""String_Node_Str"");
    if (multicastService != null) {
      multicastService.stop();
    }
    logger.log(Level.FINEST,""String_Node_Str"");
    connectionManager.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    logger.log(Level.FINEST,""String_Node_Str"");
    executorManager.stop();
    textCommandService.stop();
    masterAddress=null;
    packetPool.clear();
    logger.log(Level.FINEST,""String_Node_Str"");
    int numThreads=threadGroup.activeCount();
    Thread[] threads=new Thread[numThreads * 2];
    numThreads=threadGroup.enumerate(threads,false);
    for (int i=0; i < numThreads; i++) {
      Thread thread=threads[i];
      logger.log(Level.FINEST,""String_Node_Str"" + thread.getName());
      thread.interrupt();
    }
    logger.log(Level.INFO,""String_Node_Str"" + (System.currentTimeMillis() - start) + ""String_Node_Str"");
  }
}",0.9448621553884712
50043,"void backupIfNextOrPreviousChanged(boolean add){
  List<Record> lsOwnedRecords=new ArrayList<Record>(1000);
  Collection<CMap> cmaps=concurrentMapManager.maps.values();
  for (  final CMap cmap : cmaps) {
    boolean shouldBackup=false;
    if (cmap.backupCount > 0) {
      if (add) {
        shouldBackup=node.clusterManager.isNextChanged(cmap.backupCount);
      }
 else {
        shouldBackup=node.clusterManager.isNextChanged(cmap.backupCount) || node.clusterManager.isPreviousChanged(cmap.backupCount);
      }
    }
    if (shouldBackup) {
      for (      Record rec : cmap.mapRecords.values()) {
        if (rec.isActive()) {
          if (rec.getKeyData() == null || rec.getKeyData().size() == 0) {
            throw new RuntimeException(""String_Node_Str"" + rec.getKeyData());
          }
          lsOwnedRecords.add(rec);
        }
      }
    }
  }
  if (!add)   logger.log(Level.FINEST,thisAddress + ""String_Node_Str"" + lsOwnedRecords.size());
  for (  final Record rec : lsOwnedRecords) {
    parallelExecutorBackups.execute(new FallThroughRunnable(){
      public void doRun(){
        concurrentMapManager.backupRecord(rec);
      }
    }
);
  }
}","void backupIfNextOrPreviousChanged(boolean add){
  List<Record> lsOwnedRecords=new ArrayList<Record>(1000);
  Collection<CMap> cmaps=concurrentMapManager.maps.values();
  for (  final CMap cmap : cmaps) {
    boolean shouldBackup=false;
    if (cmap.backupCount > 0) {
      if (add) {
        shouldBackup=node.clusterManager.isNextChanged(cmap.backupCount);
      }
 else {
        shouldBackup=node.clusterManager.isNextChanged(cmap.backupCount) || node.clusterManager.isPreviousChanged(cmap.backupCount);
      }
    }
    if (shouldBackup) {
      for (      Record rec : cmap.mapRecords.values()) {
        if (rec.isActive()) {
          if (rec.getKeyData() == null || rec.getKeyData().size() == 0) {
            throw new RuntimeException(""String_Node_Str"" + rec.getKeyData());
          }
          lsOwnedRecords.add(rec);
        }
      }
    }
  }
  if (!add)   logger.log(Level.FINEST,thisAddress + ""String_Node_Str"" + lsOwnedRecords.size());
  backupTaskCount.addAndGet(lsOwnedRecords.size());
  for (  final Record rec : lsOwnedRecords) {
    parallelExecutorBackups.execute(new FallThroughRunnable(){
      public void doRun(){
        try {
          concurrentMapManager.backupRecord(rec);
        }
  finally {
          backupTaskCount.decrementAndGet();
        }
      }
    }
);
  }
}",0.9203396684189245
50044,"public void reset(){
  lsBlocksToMigrate.clear();
  for (int i=0; i < PARTITION_COUNT; i++) {
    blocks[i]=null;
  }
  partitionServiceImpl.reset();
  parallelExecutorBackups.shutdown();
  parallelExecutorMigration.shutdown();
}","public void reset(){
  lsBlocksToMigrate.clear();
  for (int i=0; i < PARTITION_COUNT; i++) {
    blocks[i]=null;
  }
  partitionServiceImpl.reset();
  parallelExecutorBackups.shutdown();
  parallelExecutorMigration.shutdown();
  backupTaskCount.set(0);
}",0.9462809917355371
50045,"public Values(Collection<Data> lsValues){
  super();
  this.lsValues=lsValues;
}","public Values(Collection<Data> values){
  super();
  if (values != null) {
    this.lsValues=new ArrayList<Data>(values.size());
    for (    Data data : values) {
      if (data != null) {
        lsValues.add(data);
      }
    }
  }
}",0.3028391167192429
50046,"Record toRecord(Request req){
  Record record=getRecord(req);
  if (record == null) {
    if (isMultiMap()) {
      record=createNewRecord(req.key,null);
      record.addValue(req.value);
    }
 else {
      record=createNewRecord(req.key,req.value);
    }
    mapRecords.put(req.key,record);
  }
 else {
    if (req.value != null) {
      if (isMultiMap()) {
        record.addValue(req.value);
      }
 else {
        record.setValue(req.value);
      }
    }
  }
  record.setIndexes(req.indexes,req.indexTypes);
  record.setCopyCount((int)req.longValue);
  if (req.lockCount >= 0) {
    DistributedLock lock=new DistributedLock(req.lockAddress,req.lockThreadId,req.lockCount);
    record.setLock(lock);
  }
  return record;
}","Record toRecord(Request req){
  Record record=getRecord(req);
  if (record == null) {
    if (isMultiMap()) {
      record=createNewRecord(req.key,null);
      if (req.value != null) {
        record.addValue(req.value);
      }
    }
 else {
      record=createNewRecord(req.key,req.value);
    }
    mapRecords.put(req.key,record);
  }
 else {
    if (req.value != null) {
      if (isMultiMap()) {
        record.addValue(req.value);
      }
 else {
        record.setValue(req.value);
      }
    }
  }
  record.setIndexes(req.indexes,req.indexTypes);
  record.setCopyCount((int)req.longValue);
  if (req.lockCount >= 0) {
    DistributedLock lock=new DistributedLock(req.lockAddress,req.lockThreadId,req.lockCount);
    record.setLock(lock);
  }
  return record;
}",0.9726118904475618
50047,"public boolean removeMulti(Request req){
  Record record=getRecord(req);
  if (record == null)   return false;
  boolean removed=false;
  if (req.value == null) {
    removed=true;
    markAsRemoved(record);
  }
 else {
    if (record.containsValue(req.value)) {
      if (record.getMultiValues() != null) {
        Iterator<Data> itValues=record.getMultiValues().iterator();
        while (itValues.hasNext()) {
          Data value=itValues.next();
          if (req.value.equals(value)) {
            itValues.remove();
            removed=true;
          }
        }
      }
    }
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  if (removed) {
    record.incrementVersion();
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_REMOVED,record.getKeyData(),null,req.value,record.getListeners(),req.caller);
    logger.log(Level.FINEST,record.getValueData() + ""String_Node_Str"" + record.getMultiValues());
  }
  req.version=record.getVersion();
  if (record.valueCount() == 0) {
    markAsRemoved(record);
  }
  return removed;
}","public boolean removeMulti(Request req){
  Record record=getRecord(req);
  if (record == null)   return false;
  boolean removed=false;
  if (req.value == null) {
    removed=true;
    markAsRemoved(record);
  }
 else {
    if (record.containsValue(req.value)) {
      if (record.getMultiValues() != null) {
        removed=record.getMultiValues().remove(req.value);
      }
    }
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  if (removed) {
    record.incrementVersion();
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_REMOVED,record.getKeyData(),null,req.value,record.getListeners(),req.caller);
    logger.log(Level.FINEST,record.getValueData() + ""String_Node_Str"" + record.getMultiValues());
  }
  req.version=record.getVersion();
  if (record.valueCount() == 0) {
    markAsRemoved(record);
  }
  return removed;
}",0.8479166666666667
50048,"public void addValue(Data value){
  if (getMultiValues() == null) {
    setMultiValues(new HashSet<Data>(2));
  }
  getMultiValues().add(value);
}","public void addValue(Data value){
  if (value != null) {
    if (getMultiValues() == null) {
      setMultiValues(new CopyOnWriteArraySet<Data>(){
        @Override public boolean add(        Data e){
          return e != null && super.add(e);
        }
      }
);
    }
    getMultiValues().add(value);
  }
}",0.6008771929824561
50049,"public byte[] toByteArray(Object obj){
  if (obj == null) {
    return null;
  }
  try {
    this.bbos.reset();
    toByte(this.bbos,obj);
    final byte[] result=this.bbos.toByteArray();
    if (this.bbos.size() > OUTPUT_STREAM_BUFFER_SIZE) {
      this.bbos.set(new byte[OUTPUT_STREAM_BUFFER_SIZE]);
    }
    return result;
  }
 catch (  final Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    throw new RuntimeException(e);
  }
}","public byte[] toByteArray(Object obj){
  if (obj == null) {
    return null;
  }
  try {
    this.bbos.reset();
    toByte(this.bbos,obj);
    final byte[] result=this.bbos.toByteArray();
    if (this.bbos.size() > OUTPUT_STREAM_BUFFER_SIZE) {
      this.bbos.set(new byte[OUTPUT_STREAM_BUFFER_SIZE]);
    }
    return result;
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    throw new RuntimeException(e);
  }
}",0.9932735426008968
50050,"public static final ObjectInputStream newObjectInputStream(final InputStream in) throws IOException {
  return new ObjectInputStream(in){
    @Override protected Class<?> resolveClass(    final ObjectStreamClass desc) throws ClassNotFoundException {
      return classForName(desc.getName());
    }
  }
;
}","public static ObjectInputStream newObjectInputStream(final InputStream in) throws IOException {
  return new ObjectInputStream(in){
    @Override protected Class<?> resolveClass(    final ObjectStreamClass desc) throws ClassNotFoundException {
      return classForName(desc.getName());
    }
  }
;
}",0.99009900990099
50051,"protected final void toByte(final FastByteArrayOutputStream bos,final Object object){
  if (object == null) {
    return;
  }
  try {
    TypeSerializer ts=(ds.isSuitable(object)) ? ds : cs;
    bos.writeByte(ts.getTypeId());
    ts.write(bos,object);
    bos.flush();
  }
 catch (  final Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    throw new RuntimeException(e);
  }
}","protected void toByte(final FastByteArrayOutputStream bos,final Object object){
  if (object == null) {
    return;
  }
  try {
    TypeSerializer ts=(ds.isSuitable(object)) ? ds : cs;
    bos.writeByte(ts.getTypeId());
    ts.write(bos,object);
    bos.flush();
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    throw new RuntimeException(e);
  }
}",0.9844155844155844
50052,"public MulticastService(Node node,MulticastSocket multicastSocket) throws Exception {
  this.node=node;
  Config config=node.getConfig();
  this.multicastSocket=multicastSocket;
  int bufferSize=1024;
  this.datagramPacketReceive=new DatagramPacket(new byte[bufferSize],bufferSize);
  this.datagramPacketSend=new DatagramPacket(new byte[bufferSize],bufferSize,InetAddress.getByName(config.getNetworkConfig().getJoin().getMulticastConfig().getMulticastGroup()),config.getNetworkConfig().getJoin().getMulticastConfig().getMulticastPort());
  running=true;
}","public MulticastService(Node node,MulticastSocket multicastSocket) throws Exception {
  this.node=node;
  Config config=node.getConfig();
  this.multicastSocket=multicastSocket;
  int bufferSize=1024 * 1024;
  this.datagramPacketReceive=new DatagramPacket(new byte[bufferSize],bufferSize);
  this.datagramPacketSend=new DatagramPacket(new byte[bufferSize],bufferSize,InetAddress.getByName(config.getNetworkConfig().getJoin().getMulticastConfig().getMulticastGroup()),config.getNetworkConfig().getJoin().getMulticastConfig().getMulticastPort());
  running=true;
}",0.9937332139659804
50053,"public Entries(String name,ClusterOperation operation){
  this.name=name;
  this.operation=operation;
  TransactionImpl txn=ThreadContext.get().getCallContext().getTransaction();
  this.checkValue=(InstanceType.MAP == getInstanceType(name)) && (operation == CONCURRENT_MAP_ITERATE_VALUES || operation == CONCURRENT_MAP_ITERATE_ENTRIES);
  if (txn != null) {
    List<Map.Entry> entriesUnderTxn=txn.newEntries(name);
    if (entriesUnderTxn != null) {
      lsKeyValues.addAll(entriesUnderTxn);
    }
  }
}","public Entries(String name,ClusterOperation operation,Predicate predicate){
  this.name=name;
  this.operation=operation;
  this.predicate=predicate;
  TransactionImpl txn=ThreadContext.get().getCallContext().getTransaction();
  this.checkValue=(InstanceType.MAP == getInstanceType(name)) && (operation == CONCURRENT_MAP_ITERATE_VALUES || operation == CONCURRENT_MAP_ITERATE_ENTRIES);
  if (txn != null) {
    List<Map.Entry> entriesUnderTxn=txn.newEntries(name);
    if (entriesUnderTxn != null) {
      if (predicate != null) {
        for (        Map.Entry entry : entriesUnderTxn) {
          if (predicate.apply((MapEntry)entry)) {
            lsKeyValues.add(entry);
          }
        }
      }
 else {
        lsKeyValues.addAll(entriesUnderTxn);
      }
    }
  }
}",0.7884465261514442
50054,"void onCall(){
  entries=new Entries(name,operation);
}","void onCall(){
  entries=new Entries(name,operation,predicate);
}",0.9166666666666666
50055,"public Set iterate(){
  Entries entries=new Entries(request.name,request.operation);
  Pairs pairs=(Pairs)getResultAsObject();
  entries.addEntries(pairs);
  return entries;
}","public Set iterate(){
  Entries entries=new Entries(name,CONCURRENT_MAP_ITERATE_KEYS,predicate);
  Pairs pairs=(Pairs)getResultAsObject();
  entries.addEntries(pairs);
  return entries;
}",0.850828729281768
50056,"public void addEntries(Pairs pairs){
  if (pairs == null)   return;
  if (pairs.getKeyValues() == null)   return;
  TransactionImpl txn=ThreadContext.get().getCallContext().getTransaction();
  for (  KeyValue entry : pairs.getKeyValues()) {
    if (txn != null) {
      Object key=entry.getKey();
      if (txn.has(name,key)) {
        Object value=txn.get(name,key);
        if (value != null) {
          lsKeyValues.add(createSimpleEntry(node.factory,name,key,value));
        }
      }
 else {
        entry.setName(node.factory,name);
        lsKeyValues.add(entry);
      }
    }
 else {
      entry.setName(node.factory,name);
      lsKeyValues.add(entry);
    }
  }
}","public void addEntries(Pairs pairs){
  if (pairs == null)   return;
  if (pairs.getKeyValues() == null)   return;
  TransactionImpl txn=ThreadContext.get().getCallContext().getTransaction();
  for (  KeyValue entry : pairs.getKeyValues()) {
    if (txn != null) {
      Object key=entry.getKey();
      if (txn.has(name,key)) {
        Object value=txn.get(name,key);
        if (value != null) {
          lsKeyValues.add(createSimpleMapEntry(node.factory,name,key,value));
        }
      }
 else {
        entry.setName(node.factory,name);
        lsKeyValues.add(entry);
      }
    }
 else {
      entry.setName(node.factory,name);
      lsKeyValues.add(entry);
    }
  }
}",0.9977827050997784
50057,"public MIterateLocal(String name,Predicate predicate){
  super(thisAddress,CONCURRENT_MAP_ITERATE_KEYS,name,predicate);
  doOp();
}","public MIterateLocal(String name,Predicate predicate){
  super(thisAddress,CONCURRENT_MAP_ITERATE_KEYS,name,predicate);
  this.name=name;
  this.predicate=predicate;
  doOp();
}",0.8506493506493507
50058,"public List<Map.Entry> newEntries(String name){
  List<Map.Entry> lsEntries=null;
  for (  TransactionRecord transactionRecord : transactionRecords) {
    if (transactionRecord.name.equals(name)) {
      if (!transactionRecord.removed) {
        if (transactionRecord.value != null) {
          if (transactionRecord.newRecord) {
            if (lsEntries == null) {
              lsEntries=new ArrayList<Map.Entry>(2);
            }
            lsEntries.add(BaseManager.createSimpleEntry(factory,name,transactionRecord.key,transactionRecord.value));
          }
        }
      }
    }
  }
  return lsEntries;
}","public List<Map.Entry> newEntries(String name){
  List<Map.Entry> lsEntries=null;
  for (  TransactionRecord transactionRecord : transactionRecords) {
    if (transactionRecord.name.equals(name)) {
      if (!transactionRecord.removed) {
        if (transactionRecord.value != null) {
          if (transactionRecord.newRecord) {
            if (lsEntries == null) {
              lsEntries=new ArrayList<Map.Entry>(2);
            }
            lsEntries.add(BaseManager.createSimpleMapEntry(factory,name,transactionRecord.key,transactionRecord.value));
          }
        }
      }
    }
  }
  return lsEntries;
}",0.997558991049634
50059,"public Set<MapEntry> filter(QueryContext queryContext){
  Set<MapEntry> results=null;
  for (  Predicate predicate : predicates) {
    if (predicate instanceof IndexAwarePredicate) {
      IndexAwarePredicate p=(IndexAwarePredicate)predicate;
      final Set<MapEntry> filter=p.filter(queryContext);
      if (and && (filter == null || filter.isEmpty()))       return null;
      if (results == null) {
        results=and ? filter : new HashSet<MapEntry>(filter);
      }
 else {
        if (and) {
          boolean direct=results.size() < filter.size();
          final Set<MapEntry> s1=direct ? results : filter;
          final Set<MapEntry> s2=direct ? filter : results;
          results=new HashSet<MapEntry>();
          for (final Iterator<MapEntry> it=s1.iterator(); it.hasNext(); ) {
            final MapEntry next=it.next();
            if (s2.contains(next)) {
              results.add(next);
            }
          }
          if (results.isEmpty())           return null;
        }
 else {
          results.addAll(filter);
        }
      }
    }
  }
  return results;
}","public Set<MapEntry> filter(QueryContext queryContext){
  Set<MapEntry> results=null;
  for (  Predicate predicate : predicates) {
    if (predicate instanceof IndexAwarePredicate) {
      IndexAwarePredicate p=(IndexAwarePredicate)predicate;
      final Set<MapEntry> filter=p.filter(queryContext);
      if (and && (filter == null || filter.isEmpty()))       return null;
      if (results == null) {
        if (and) {
          results=filter;
        }
 else         if (filter == null) {
          results=new HashSet<MapEntry>();
        }
 else {
          results=new HashSet<MapEntry>(filter);
        }
      }
 else {
        if (and) {
          boolean direct=results.size() < filter.size();
          final Set<MapEntry> s1=direct ? results : filter;
          final Set<MapEntry> s2=direct ? filter : results;
          results=new HashSet<MapEntry>();
          for (          MapEntry next : s1) {
            if (s2.contains(next)) {
              results.add(next);
            }
          }
          if (results.isEmpty())           return null;
        }
 else         if (filter != null) {
          results.addAll(filter);
        }
      }
    }
  }
  return results;
}",0.8481400437636761
50060,"@Test public void testEqual(){
  Object value=new QueryTest.Employee(""String_Node_Str"",34,true,10D);
  assertTrue(new SqlPredicate(""String_Node_Str"" + 20 + ""String_Node_Str""+ 40+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 20 + ""String_Node_Str""+ 34+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 34 + ""String_Node_Str""+ 35+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 34 + ""String_Node_Str""+ 35+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 40 + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",-33,true,10D))));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(Predicates.equal(new DummyExpression(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.equal(new DummyExpression(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.equal(new DummyExpression(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.equal(new DummyExpression(true),Boolean.TRUE).apply(null));
  assertTrue(Predicates.equal(new DummyExpression(Boolean.TRUE),true).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(Boolean.FALSE),true).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(15.23),15.22).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(15.23),15.22).apply(null));
  assertTrue(Predicates.equal(new DummyExpression(15.22),15.22).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(15),16).apply(null));
  assertTrue(Predicates.greaterThan(new DummyExpression(6),5).apply(null));
  assertFalse(Predicates.greaterThan(new DummyExpression(4),5).apply(null));
  assertFalse(Predicates.greaterThan(new DummyExpression(5),5).apply(null));
  assertTrue(Predicates.greaterEqual(new DummyExpression(5),5).apply(null));
  assertTrue(Predicates.lessThan(new DummyExpression(6),7).apply(null));
  assertFalse(Predicates.lessThan(new DummyExpression(4),3).apply(null));
  assertFalse(Predicates.lessThan(new DummyExpression(4),4).apply(null));
  assertTrue(Predicates.lessEqual(new DummyExpression(4),4).apply(null));
  assertTrue(Predicates.between(new DummyExpression(5),4,6).apply(null));
  assertTrue(Predicates.between(new DummyExpression(5),5,6).apply(null));
  assertFalse(Predicates.between(new DummyExpression(5),6,7).apply(null));
  assertTrue(Predicates.in(new DummyExpression(5),4,7,8,5).apply(null));
  assertTrue(Predicates.in(new DummyExpression(5),5,7,8).apply(null));
  assertFalse(Predicates.in(new DummyExpression(5),6,7,8).apply(null));
  assertFalse(Predicates.in(new DummyExpression(9),6,7,8).apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
}","@Test public void testEqual(){
  Object value=new QueryTest.Employee(""String_Node_Str"",34,true,10D);
  assertTrue(new SqlPredicate(""String_Node_Str"" + 20 + ""String_Node_Str""+ 40+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 20 + ""String_Node_Str""+ 34+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 34 + ""String_Node_Str""+ 35+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 34 + ""String_Node_Str""+ 35+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 40 + ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",-33,true,10D))));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(Predicates.equal(new DummyExpression(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.equal(new DummyExpression(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.equal(new DummyExpression(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.equal(new DummyExpression(true),Boolean.TRUE).apply(null));
  assertTrue(Predicates.equal(new DummyExpression(Boolean.TRUE),true).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(Boolean.FALSE),true).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(15.23),15.22).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(15.23),15.22).apply(null));
  assertTrue(Predicates.equal(new DummyExpression(15.22),15.22).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(15),16).apply(null));
  assertTrue(Predicates.greaterThan(new DummyExpression(6),5).apply(null));
  assertFalse(Predicates.greaterThan(new DummyExpression(4),5).apply(null));
  assertFalse(Predicates.greaterThan(new DummyExpression(5),5).apply(null));
  assertTrue(Predicates.greaterEqual(new DummyExpression(5),5).apply(null));
  assertTrue(Predicates.lessThan(new DummyExpression(6),7).apply(null));
  assertFalse(Predicates.lessThan(new DummyExpression(4),3).apply(null));
  assertFalse(Predicates.lessThan(new DummyExpression(4),4).apply(null));
  assertTrue(Predicates.lessEqual(new DummyExpression(4),4).apply(null));
  assertTrue(Predicates.between(new DummyExpression(5),4,6).apply(null));
  assertTrue(Predicates.between(new DummyExpression(5),5,6).apply(null));
  assertFalse(Predicates.between(new DummyExpression(5),6,7).apply(null));
  assertTrue(Predicates.in(new DummyExpression(5),4,7,8,5).apply(null));
  assertTrue(Predicates.in(new DummyExpression(5),5,7,8).apply(null));
  assertFalse(Predicates.in(new DummyExpression(5),6,7,8).apply(null));
  assertFalse(Predicates.in(new DummyExpression(9),6,7,8).apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
}",0.9924800250665832
50061,"public QueueConfig getQueueConfig(final String name){
  QueueConfig config;
  if ((config=lookupByPattern(mapQueueConfigs,name)) != null)   return config;
  config=mapQueueConfigs.get(""String_Node_Str"");
  if (config == null) {
    config=new QueueConfig();
    config.setName(""String_Node_Str"");
    mapQueueConfigs.put(""String_Node_Str"",config);
  }
  return config;
}","public QueueConfig getQueueConfig(final String name){
  QueueConfig config;
  if ((config=lookupByPattern(mapQueueConfigs,name)) != null)   return config;
  QueueConfig defConfig=mapQueueConfigs.get(""String_Node_Str"");
  if (defConfig == null) {
    defConfig=new QueueConfig();
    defConfig.setName(""String_Node_Str"");
    addQueueConfig(defConfig);
  }
  config=new QueueConfig(defConfig);
  config.setName(name);
  addQueueConfig(config);
  return config;
}",0.7220216606498195
50062,"public MapConfig getMapConfig(final String name){
  MapConfig config;
  if ((config=lookupByPattern(mapConfigs,name)) != null)   return config;
  config=mapConfigs.get(""String_Node_Str"");
  if (config == null) {
    config=new MapConfig();
    config.setName(""String_Node_Str"");
    mapConfigs.put(""String_Node_Str"",config);
  }
  return config;
}","public MapConfig getMapConfig(final String name){
  MapConfig config;
  if ((config=lookupByPattern(mapConfigs,name)) != null)   return config;
  MapConfig defConfig=mapConfigs.get(""String_Node_Str"");
  if (defConfig == null) {
    defConfig=new MapConfig();
    defConfig.setName(""String_Node_Str"");
    addMapConfig(defConfig);
  }
  config=new MapConfig(defConfig);
  config.setName(name);
  addMapConfig(config);
  return config;
}",0.7212276214833759
50063,"private static <T>T lookupByPattern(Map<String,T> map,String name){
  T t=name.indexOf('*') < 0 ? map.get(name) : null;
  if (t == null) {
    final Set<String> tNames=map.keySet();
    for (    final String pattern : tNames) {
      if (nameMatches(name,pattern)) {
        return map.get(pattern);
      }
    }
  }
  return t;
}","private static <T>T lookupByPattern(Map<String,T> map,String name){
  T t=map.get(name);
  if (t == null) {
    final Set<String> tNames=map.keySet();
    for (    final String pattern : tNames) {
      if (nameMatches(name,pattern)) {
        return map.get(pattern);
      }
    }
  }
  return t;
}",0.91283676703645
50064,"private void checkTopicConfigCompatible(final Config config){
  Set<String> topicConfigNames=new HashSet<String>(mapTopicConfigs.keySet());
  topicConfigNames.addAll(config.mapTopicConfigs.keySet());
  for (  final String name : topicConfigNames) {
    final TopicConfig thisTopicConfig=getTopicConfig(name);
    final TopicConfig thatTopicConfig=config.getTopicConfig(name);
    if (!thisTopicConfig.equals(thatTopicConfig)) {
      throw new RuntimeException(format(""String_Node_Str"",thisTopicConfig,thatTopicConfig));
    }
  }
}","private void checkTopicConfigCompatible(final Config config){
  Set<String> topicConfigNames=new HashSet<String>(mapTopicConfigs.keySet());
  topicConfigNames.addAll(config.mapTopicConfigs.keySet());
  for (  final String name : topicConfigNames) {
    final TopicConfig thisTopicConfig=lookupByPattern(mapTopicConfigs,name);
    final TopicConfig thatTopicConfig=lookupByPattern(config.mapTopicConfigs,name);
    if (thisTopicConfig != null && thatTopicConfig != null && !thisTopicConfig.equals(thatTopicConfig)) {
      throw new RuntimeException(format(""String_Node_Str"",thisTopicConfig,thatTopicConfig));
    }
  }
}",0.8715277777777778
50065,"public TopicConfig getTopicConfig(final String name){
  TopicConfig config;
  if ((config=lookupByPattern(mapTopicConfigs,name)) != null) {
    return config;
  }
  config=mapTopicConfigs.get(""String_Node_Str"");
  if (config == null) {
    config=new TopicConfig();
    config.setName(""String_Node_Str"");
    mapTopicConfigs.put(""String_Node_Str"",config);
  }
  return config;
}","public TopicConfig getTopicConfig(final String name){
  TopicConfig config;
  if ((config=lookupByPattern(mapTopicConfigs,name)) != null) {
    return config;
  }
  TopicConfig defConfig=mapTopicConfigs.get(""String_Node_Str"");
  if (defConfig == null) {
    defConfig=new TopicConfig();
    defConfig.setName(""String_Node_Str"");
    addTopicConfig(defConfig);
  }
  config=new TopicConfig(defConfig);
  config.setName(name);
  addTopicConfig(defConfig);
  return config;
}",0.7247058823529412
50066,"private void checkQueueConfigCompatible(final Config config){
  Set<String> queueConfigNames=new HashSet<String>(mapQueueConfigs.keySet());
  queueConfigNames.addAll(config.mapQueueConfigs.keySet());
  for (  final String name : queueConfigNames) {
    final QueueConfig thisQueueConfig=getQueueConfig(name);
    final QueueConfig thatQueueConfig=config.getQueueConfig(name);
    if (!thisQueueConfig.isCompatible(thatQueueConfig)) {
      throw new RuntimeException(format(""String_Node_Str"",thisQueueConfig,thatQueueConfig));
    }
  }
}","private void checkQueueConfigCompatible(final Config config){
  Set<String> queueConfigNames=new HashSet<String>(mapQueueConfigs.keySet());
  queueConfigNames.addAll(config.mapQueueConfigs.keySet());
  for (  final String name : queueConfigNames) {
    final QueueConfig thisQueueConfig=lookupByPattern(mapQueueConfigs,name);
    final QueueConfig thatQueueConfig=lookupByPattern(config.mapQueueConfigs,name);
    if (thisQueueConfig != null && thatQueueConfig != null && !thisQueueConfig.isCompatible(thatQueueConfig)) {
      throw new RuntimeException(format(""String_Node_Str"",thisQueueConfig,thatQueueConfig));
    }
  }
}",0.872852233676976
50067,"private void checkMapConfigCompatible(final Config config){
  Set<String> mapConfigNames=new HashSet<String>(mapConfigs.keySet());
  mapConfigNames.addAll(config.mapConfigs.keySet());
  for (  final String name : mapConfigNames) {
    final MapConfig thisMapConfig=getMapConfig(name);
    final MapConfig thatMapConfig=config.getMapConfig(name);
    if (!thisMapConfig.isCompatible(thatMapConfig)) {
      throw new RuntimeException(format(""String_Node_Str"",thisMapConfig,thatMapConfig));
    }
  }
}","private void checkMapConfigCompatible(final Config config){
  Set<String> mapConfigNames=new HashSet<String>(mapConfigs.keySet());
  mapConfigNames.addAll(config.mapConfigs.keySet());
  for (  final String name : mapConfigNames) {
    final MapConfig thisMapConfig=lookupByPattern(mapConfigs,name);
    final MapConfig thatMapConfig=lookupByPattern(config.mapConfigs,name);
    if (thisMapConfig != null && thatMapConfig != null && !thisMapConfig.isCompatible(thatMapConfig)) {
      throw new RuntimeException(format(""String_Node_Str"",thisMapConfig,thatMapConfig));
    }
  }
}",0.8794063079777366
50068,"public MapConfig(){
}","public MapConfig(MapConfig config){
  this.name=config.name;
  this.backupCount=config.backupCount;
  this.evictionPercentage=config.evictionPercentage;
  this.timeToLiveSeconds=config.timeToLiveSeconds;
  this.maxIdleSeconds=config.maxIdleSeconds;
  this.evictionDelaySeconds=config.evictionDelaySeconds;
  this.maxSize=config.maxSize;
  this.evictionPolicy=config.evictionPolicy;
  this.valueIndexed=config.valueIndexed;
  this.mapStoreConfig=config.mapStoreConfig;
  this.nearCacheConfig=config.nearCacheConfig;
  this.readBackupData=config.readBackupData;
  this.cacheValue=config.cacheValue;
  this.mergePolicy=config.mergePolicy;
}",0.0638297872340425
50069,"CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.logger=concurrentMapManager.node.getLogger(CMap.class.getName());
  this.PARTITION_COUNT=concurrentMapManager.PARTITION_COUNT;
  this.blocks=concurrentMapManager.blocks;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  MapConfig mapConfig=null;
  String mapConfigName=name.substring(2);
  if (mapConfigName.startsWith(""String_Node_Str"") || mapConfigName.startsWith(AS_LIST) || mapConfigName.startsWith(AS_SET)) {
    mapConfig=new MapConfig();
  }
 else {
    mapConfig=node.getConfig().getMapConfig(mapConfigName);
  }
  this.mapIndexService=new MapIndexService(mapConfig.isValueIndexed());
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  evictionDelayMillis=mapConfig.getEvictionDelaySeconds() * 1000L;
  maxIdle=mapConfig.getMaxIdleSeconds() * 1000L;
  evictionPolicy=EvictionPolicy.valueOf(mapConfig.getEvictionPolicy());
  readBackupData=mapConfig.isReadBackupData();
  cacheValue=mapConfig.isCacheValue();
  if (evictionPolicy == EvictionPolicy.NONE) {
    maxSize=Integer.MAX_VALUE;
    evictionComparator=null;
  }
 else {
    maxSize=(mapConfig.getMaxSize() == 0) ? MapConfig.DEFAULT_MAX_SIZE : mapConfig.getMaxSize();
    if (evictionPolicy == EvictionPolicy.LRU) {
      evictionComparator=new ComparatorWrapper(LRU_COMPARATOR);
    }
 else {
      evictionComparator=new ComparatorWrapper(LFU_COMPARATOR);
    }
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100f;
  instanceType=ConcurrentMapManager.getInstanceType(name);
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  MapStoreWrapper mapStoreWrapper=null;
  int writeDelaySeconds=-1;
  if (!node.isSuperClient() && mapStoreConfig != null && mapStoreConfig.isEnabled()) {
    try {
      Object storeInstance=mapStoreConfig.getImplementation();
      if (storeInstance == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeInstance=Serializer.classForName(node.getConfig().getClassLoader(),mapStoreClassName).newInstance();
      }
      mapStoreWrapper=new MapStoreWrapper(storeInstance,node.factory.getHazelcastInstanceProxy(),mapStoreConfig.getProperties(),mapConfigName);
    }
 catch (    Exception e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
    writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
  }
  writeDelayMillis=(writeDelaySeconds == -1) ? -1L : writeDelaySeconds * 1000L;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + writeDelaySeconds;
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  loader=(mapStoreWrapper == null || !mapStoreWrapper.isMapLoader()) ? null : mapStoreWrapper;
  store=(mapStoreWrapper == null || !mapStoreWrapper.isMapStore()) ? null : mapStoreWrapper;
  NearCacheConfig nearCacheConfig=mapConfig.getNearCacheConfig();
  if (nearCacheConfig == null) {
    mapNearCache=null;
  }
 else {
    MapNearCache mapNearCache=new MapNearCache(this,SortedHashMap.getOrderingTypeByName(nearCacheConfig.getEvictionPolicy()),nearCacheConfig.getMaxSize(),nearCacheConfig.getTimeToLiveSeconds() * 1000L,nearCacheConfig.getMaxIdleSeconds() * 1000L,nearCacheConfig.isInvalidateOnChange());
    final MapNearCache anotherMapNearCache=concurrentMapManager.mapCaches.putIfAbsent(name,mapNearCache);
    if (anotherMapNearCache != null) {
      mapNearCache=anotherMapNearCache;
    }
    this.mapNearCache=mapNearCache;
  }
  MergePolicy mergePolicyTemp=null;
  String mergePolicyName=mapConfig.getMergePolicy();
  if (mergePolicyName != null && !""String_Node_Str"".equalsIgnoreCase(mergePolicyName)) {
    MergePolicyConfig mergePolicyConfig=node.getConfig().getMergePolicyConfig(mapConfig.getMergePolicy());
    if (mergePolicyConfig != null) {
      mergePolicyTemp=mergePolicyConfig.getImplementation();
      if (mergePolicyTemp == null) {
        String mergeClassName=mergePolicyConfig.getClassName();
        try {
          mergePolicyTemp=(MergePolicy)Serializer.classForName(node.getConfig().getClassLoader(),mergeClassName).newInstance();
        }
 catch (        Exception e) {
          logger.log(Level.SEVERE,e.getMessage(),e);
        }
      }
    }
  }
  this.mergePolicy=mergePolicyTemp;
  this.creationTime=System.currentTimeMillis();
}","CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.logger=concurrentMapManager.node.getLogger(CMap.class.getName());
  this.PARTITION_COUNT=concurrentMapManager.PARTITION_COUNT;
  this.blocks=concurrentMapManager.blocks;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  instanceType=ConcurrentMapManager.getInstanceType(name);
  MapConfig mapConfig=null;
  String mapConfigName=name.substring(2);
  if (isMultiMap() || mapConfigName.startsWith(""String_Node_Str"") || mapConfigName.startsWith(AS_LIST)|| mapConfigName.startsWith(AS_SET)) {
    mapConfig=new MapConfig();
  }
 else {
    mapConfig=node.getConfig().getMapConfig(mapConfigName);
  }
  this.mapIndexService=new MapIndexService(mapConfig.isValueIndexed());
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  evictionDelayMillis=mapConfig.getEvictionDelaySeconds() * 1000L;
  maxIdle=mapConfig.getMaxIdleSeconds() * 1000L;
  evictionPolicy=EvictionPolicy.valueOf(mapConfig.getEvictionPolicy());
  readBackupData=mapConfig.isReadBackupData();
  cacheValue=mapConfig.isCacheValue();
  if (evictionPolicy == EvictionPolicy.NONE) {
    maxSize=Integer.MAX_VALUE;
    evictionComparator=null;
  }
 else {
    maxSize=(mapConfig.getMaxSize() == 0) ? MapConfig.DEFAULT_MAX_SIZE : mapConfig.getMaxSize();
    if (evictionPolicy == EvictionPolicy.LRU) {
      evictionComparator=new ComparatorWrapper(LRU_COMPARATOR);
    }
 else {
      evictionComparator=new ComparatorWrapper(LFU_COMPARATOR);
    }
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100f;
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  MapStoreWrapper mapStoreWrapper=null;
  int writeDelaySeconds=-1;
  if (!node.isSuperClient() && mapStoreConfig != null && mapStoreConfig.isEnabled()) {
    try {
      Object storeInstance=mapStoreConfig.getImplementation();
      if (storeInstance == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeInstance=Serializer.classForName(node.getConfig().getClassLoader(),mapStoreClassName).newInstance();
      }
      mapStoreWrapper=new MapStoreWrapper(storeInstance,node.factory.getHazelcastInstanceProxy(),mapStoreConfig.getProperties(),mapConfigName);
    }
 catch (    Exception e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
    writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
  }
  writeDelayMillis=(writeDelaySeconds == -1) ? -1L : writeDelaySeconds * 1000L;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + writeDelaySeconds;
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  loader=(mapStoreWrapper == null || !mapStoreWrapper.isMapLoader()) ? null : mapStoreWrapper;
  store=(mapStoreWrapper == null || !mapStoreWrapper.isMapStore()) ? null : mapStoreWrapper;
  NearCacheConfig nearCacheConfig=mapConfig.getNearCacheConfig();
  if (nearCacheConfig == null) {
    mapNearCache=null;
  }
 else {
    MapNearCache mapNearCache=new MapNearCache(this,SortedHashMap.getOrderingTypeByName(nearCacheConfig.getEvictionPolicy()),nearCacheConfig.getMaxSize(),nearCacheConfig.getTimeToLiveSeconds() * 1000L,nearCacheConfig.getMaxIdleSeconds() * 1000L,nearCacheConfig.isInvalidateOnChange());
    final MapNearCache anotherMapNearCache=concurrentMapManager.mapCaches.putIfAbsent(name,mapNearCache);
    if (anotherMapNearCache != null) {
      mapNearCache=anotherMapNearCache;
    }
    this.mapNearCache=mapNearCache;
  }
  MergePolicy mergePolicyTemp=null;
  String mergePolicyName=mapConfig.getMergePolicy();
  if (mergePolicyName != null && !""String_Node_Str"".equalsIgnoreCase(mergePolicyName)) {
    MergePolicyConfig mergePolicyConfig=node.getConfig().getMergePolicyConfig(mapConfig.getMergePolicy());
    if (mergePolicyConfig != null) {
      mergePolicyTemp=mergePolicyConfig.getImplementation();
      if (mergePolicyTemp == null) {
        String mergeClassName=mergePolicyConfig.getClassName();
        try {
          mergePolicyTemp=(MergePolicy)Serializer.classForName(node.getConfig().getClassLoader(),mergeClassName).newInstance();
        }
 catch (        Exception e) {
          logger.log(Level.SEVERE,e.getMessage(),e);
        }
      }
    }
  }
  this.mergePolicy=mergePolicyTemp;
  this.creationTime=System.currentTimeMillis();
}",0.984836571942042
50070,"public void writeData(DataOutput out) throws IOException {
  getGroupConfig().writeData(out);
  out.writeInt(port);
  boolean hasMapConfigs=mapConfigs != null && !mapConfigs.isEmpty();
  boolean hasMapExecutors=mapExecutors != null && !mapExecutors.isEmpty();
  boolean hasMapTopicConfigs=mapTopicConfigs != null && !mapTopicConfigs.isEmpty();
  boolean hasMapQueueConfigs=mapQueueConfigs != null && !mapQueueConfigs.isEmpty();
  boolean hasMapMergePolicyConfigs=mapMergePolicyConfigs != null && !mapMergePolicyConfigs.isEmpty();
  boolean hasProperties=properties != null && !properties.isEmpty();
  out.writeByte(ByteUtil.toByte(reuseAddress,portAutoIncrement,superClient));
  out.writeByte(ByteUtil.toByte(hasMapConfigs,hasMapExecutors,hasMapTopicConfigs,hasMapQueueConfigs,hasMapMergePolicyConfigs,hasProperties));
  networkConfig.writeData(out);
  executorConfig.writeData(out);
  if (hasMapConfigs) {
    out.writeInt(mapConfigs.size());
    for (    final Entry<String,MapConfig> entry : mapConfigs.entrySet()) {
      final String name=entry.getKey();
      final MapConfig mapConfig=entry.getValue();
      mapConfig.setName(name);
      mapConfig.writeData(out);
    }
  }
  if (hasMapExecutors) {
    out.writeInt(mapExecutors.size());
    for (    final Entry<String,ExecutorConfig> entry : mapExecutors.entrySet()) {
      final String name=entry.getKey();
      final ExecutorConfig executorConfig=entry.getValue();
      executorConfig.setName(name);
      executorConfig.writeData(out);
    }
  }
  if (hasMapTopicConfigs) {
    out.writeInt(mapTopicConfigs.size());
    for (    final Entry<String,TopicConfig> entry : mapTopicConfigs.entrySet()) {
      final String name=entry.getKey();
      final TopicConfig topicConfig=entry.getValue();
      topicConfig.setName(name);
      topicConfig.writeData(out);
    }
  }
  if (hasMapQueueConfigs) {
    out.writeInt(mapQueueConfigs.size());
    for (    final Entry<String,QueueConfig> entry : mapQueueConfigs.entrySet()) {
      final String name=entry.getKey();
      final QueueConfig queueConfig=entry.getValue();
      queueConfig.setName(name);
      queueConfig.writeData(out);
    }
  }
  if (hasMapMergePolicyConfigs) {
  }
  if (hasProperties) {
    out.writeInt(properties.size());
    for (    final Entry<Object,Object> entry : properties.entrySet()) {
      final String key=(String)entry.getKey();
      final String value=(String)entry.getValue();
      out.writeUTF(key);
      out.writeUTF(value);
    }
  }
}","public void writeData(DataOutput out) throws IOException {
  getGroupConfig().writeData(out);
  out.writeInt(port);
  boolean hasMapConfigs=mapConfigs != null && !mapConfigs.isEmpty();
  boolean hasMapExecutors=mapExecutors != null && !mapExecutors.isEmpty();
  boolean hasMapTopicConfigs=mapTopicConfigs != null && !mapTopicConfigs.isEmpty();
  boolean hasMapQueueConfigs=mapQueueConfigs != null && !mapQueueConfigs.isEmpty();
  boolean hasMapMergePolicyConfigs=mapMergePolicyConfigs != null && !mapMergePolicyConfigs.isEmpty();
  boolean hasProperties=properties != null && !properties.isEmpty();
  out.writeByte(ByteUtil.toByte(checkCompatibility,reuseAddress,portAutoIncrement,superClient));
  out.writeByte(ByteUtil.toByte(hasMapConfigs,hasMapExecutors,hasMapTopicConfigs,hasMapQueueConfigs,hasMapMergePolicyConfigs,hasProperties));
  networkConfig.writeData(out);
  executorConfig.writeData(out);
  if (hasMapConfigs) {
    out.writeInt(mapConfigs.size());
    for (    final Entry<String,MapConfig> entry : mapConfigs.entrySet()) {
      final String name=entry.getKey();
      final MapConfig mapConfig=entry.getValue();
      mapConfig.setName(name);
      mapConfig.writeData(out);
    }
  }
  if (hasMapExecutors) {
    out.writeInt(mapExecutors.size());
    for (    final Entry<String,ExecutorConfig> entry : mapExecutors.entrySet()) {
      final String name=entry.getKey();
      final ExecutorConfig executorConfig=entry.getValue();
      executorConfig.setName(name);
      executorConfig.writeData(out);
    }
  }
  if (hasMapTopicConfigs) {
    out.writeInt(mapTopicConfigs.size());
    for (    final Entry<String,TopicConfig> entry : mapTopicConfigs.entrySet()) {
      final String name=entry.getKey();
      final TopicConfig topicConfig=entry.getValue();
      topicConfig.setName(name);
      topicConfig.writeData(out);
    }
  }
  if (hasMapQueueConfigs) {
    out.writeInt(mapQueueConfigs.size());
    for (    final Entry<String,QueueConfig> entry : mapQueueConfigs.entrySet()) {
      final String name=entry.getKey();
      final QueueConfig queueConfig=entry.getValue();
      queueConfig.setName(name);
      queueConfig.writeData(out);
    }
  }
  if (hasMapMergePolicyConfigs) {
  }
  if (hasProperties) {
    out.writeInt(properties.size());
    for (    final Entry<Object,Object> entry : properties.entrySet()) {
      final String key=(String)entry.getKey();
      final String value=(String)entry.getValue();
      out.writeUTF(key);
      out.writeUTF(value);
    }
  }
}",0.9962037962037962
50071,"public void readData(DataInput in) throws IOException {
  groupConfig=new GroupConfig();
  groupConfig.readData(in);
  port=in.readInt();
  boolean[] b1=ByteUtil.fromByte(in.readByte());
  reuseAddress=b1[0];
  portAutoIncrement=b1[1];
  superClient=b1[2];
  boolean[] b2=ByteUtil.fromByte(in.readByte());
  boolean hasMapConfigs=b2[0];
  boolean hasMapExecutors=b2[1];
  boolean hasMapTopicConfigs=b2[2];
  boolean hasMapQueueConfigs=b2[3];
  boolean hasMapMergePolicyConfigs=b2[4];
  boolean hasProperties=b2[5];
  networkConfig=new NetworkConfig();
  networkConfig.readData(in);
  executorConfig=new ExecutorConfig();
  executorConfig.readData(in);
  if (hasMapConfigs) {
    int size=in.readInt();
    mapConfigs=new ConcurrentHashMap<String,MapConfig>(size);
    for (int i=0; i < size; i++) {
      final MapConfig mapConfig=new MapConfig();
      mapConfig.readData(in);
      mapConfigs.put(mapConfig.getName(),mapConfig);
    }
  }
  if (hasMapExecutors) {
    int size=in.readInt();
    mapExecutors=new ConcurrentHashMap<String,ExecutorConfig>(size);
    for (int i=0; i < size; i++) {
      final ExecutorConfig executorConfig=new ExecutorConfig();
      executorConfig.readData(in);
      mapExecutors.put(executorConfig.getName(),executorConfig);
    }
  }
  if (hasMapTopicConfigs) {
    int size=in.readInt();
    mapTopicConfigs=new ConcurrentHashMap<String,TopicConfig>(size);
    for (int i=0; i < size; i++) {
      final TopicConfig topicConfig=new TopicConfig();
      topicConfig.readData(in);
      mapTopicConfigs.put(topicConfig.getName(),topicConfig);
    }
  }
  if (hasMapQueueConfigs) {
    int size=in.readInt();
    mapQueueConfigs=new ConcurrentHashMap<String,QueueConfig>(size);
    for (int i=0; i < size; i++) {
      final QueueConfig queueConfig=new QueueConfig();
      queueConfig.readData(in);
      mapQueueConfigs.put(queueConfig.getName(),queueConfig);
    }
  }
  if (hasMapMergePolicyConfigs) {
  }
  if (hasProperties) {
    int size=in.readInt();
    properties=new Properties();
    for (int i=0; i < size; i++) {
      final String name=in.readUTF();
      final String value=in.readUTF();
      properties.put(name,value);
    }
  }
}","public void readData(DataInput in) throws IOException {
  groupConfig=new GroupConfig();
  groupConfig.readData(in);
  port=in.readInt();
  boolean[] b1=ByteUtil.fromByte(in.readByte());
  checkCompatibility=b1[0];
  reuseAddress=b1[1];
  portAutoIncrement=b1[2];
  superClient=b1[3];
  boolean[] b2=ByteUtil.fromByte(in.readByte());
  boolean hasMapConfigs=b2[0];
  boolean hasMapExecutors=b2[1];
  boolean hasMapTopicConfigs=b2[2];
  boolean hasMapQueueConfigs=b2[3];
  boolean hasMapMergePolicyConfigs=b2[4];
  boolean hasProperties=b2[5];
  networkConfig=new NetworkConfig();
  networkConfig.readData(in);
  executorConfig=new ExecutorConfig();
  executorConfig.readData(in);
  if (hasMapConfigs) {
    int size=in.readInt();
    mapConfigs=new ConcurrentHashMap<String,MapConfig>(size);
    for (int i=0; i < size; i++) {
      final MapConfig mapConfig=new MapConfig();
      mapConfig.readData(in);
      mapConfigs.put(mapConfig.getName(),mapConfig);
    }
  }
  if (hasMapExecutors) {
    int size=in.readInt();
    mapExecutors=new ConcurrentHashMap<String,ExecutorConfig>(size);
    for (int i=0; i < size; i++) {
      final ExecutorConfig executorConfig=new ExecutorConfig();
      executorConfig.readData(in);
      mapExecutors.put(executorConfig.getName(),executorConfig);
    }
  }
  if (hasMapTopicConfigs) {
    int size=in.readInt();
    mapTopicConfigs=new ConcurrentHashMap<String,TopicConfig>(size);
    for (int i=0; i < size; i++) {
      final TopicConfig topicConfig=new TopicConfig();
      topicConfig.readData(in);
      mapTopicConfigs.put(topicConfig.getName(),topicConfig);
    }
  }
  if (hasMapQueueConfigs) {
    int size=in.readInt();
    mapQueueConfigs=new ConcurrentHashMap<String,QueueConfig>(size);
    for (int i=0; i < size; i++) {
      final QueueConfig queueConfig=new QueueConfig();
      queueConfig.readData(in);
      mapQueueConfigs.put(queueConfig.getName(),queueConfig);
    }
  }
  if (hasMapMergePolicyConfigs) {
  }
  if (hasProperties) {
    int size=in.readInt();
    properties=new Properties();
    for (int i=0; i < size; i++) {
      final String name=in.readUTF();
      final String value=in.readUTF();
      properties.put(name,value);
    }
  }
}",0.977262391996362
50072,"public void checkCompatibility(final Config config){
  if (config == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!this.groupConfig.equals(config.getGroupConfig())) {
    throw new RuntimeException(format(""String_Node_Str"",this.groupConfig,config.getGroupConfig()));
  }
  checkMapConfigCompatible(config);
  checkQueueConfigCompatible(config);
  checkTopicConfigCompatible(config);
}","public void checkCompatibility(final Config config){
  if (config == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!this.groupConfig.equals(config.getGroupConfig())) {
    throw new RuntimeException(format(""String_Node_Str"",this.groupConfig,config.getGroupConfig()));
  }
  if (checkCompatibility) {
    checkMapConfigCompatible(config);
    checkQueueConfigCompatible(config);
    checkTopicConfigCompatible(config);
  }
}",0.9563218390804598
50073,"@Override public String toString(){
  return ""String_Node_Str"" + this.groupConfig + ""String_Node_Str""+ this.port+ ""String_Node_Str""+ this.superClient+ ""String_Node_Str""+ this.reuseAddress+ ""String_Node_Str""+ this.portAutoIncrement+ ""String_Node_Str""+ this.properties+ ""String_Node_Str""+ this.networkConfig+ ""String_Node_Str""+ this.mapConfigs+ ""String_Node_Str""+ this.mapMergePolicyConfigs+ ""String_Node_Str""+ this.executorConfig+ ""String_Node_Str""+ this.mapExecutors+ ""String_Node_Str""+ this.mapTopicConfigs+ ""String_Node_Str""+ this.mapQueueConfigs+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + this.groupConfig + ""String_Node_Str""+ this.port+ ""String_Node_Str""+ this.superClient+ ""String_Node_Str""+ this.reuseAddress+ ""String_Node_Str""+ this.checkCompatibility+ ""String_Node_Str""+ this.portAutoIncrement+ ""String_Node_Str""+ this.properties+ ""String_Node_Str""+ this.networkConfig+ ""String_Node_Str""+ this.mapConfigs+ ""String_Node_Str""+ this.mapMergePolicyConfigs+ ""String_Node_Str""+ this.executorConfig+ ""String_Node_Str""+ this.mapExecutors+ ""String_Node_Str""+ this.mapTopicConfigs+ ""String_Node_Str""+ this.mapQueueConfigs+ ""String_Node_Str"";
}",0.9628378378378378
50074,"void enqueueEvent(int eventType,String name,Data eventKey,Data eventValue,Address from){
  try {
    Member member=getMember(from);
    if (member == null) {
      member=new MemberImpl(from,thisAddress.equals(from));
    }
    final EventTask eventTask=new EventTask(member,eventType,name,eventKey,eventValue);
    int hash;
    if (eventKey != null) {
      hash=eventKey.hashCode();
    }
 else {
      hash=hashTwo(from.hashCode(),name.hashCode());
    }
    node.executorManager.getEventExecutorService().executeOrderedRunnable(hash,eventTask);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","void enqueueEvent(int eventType,String name,Data key,Data value,Address from){
  try {
    Member member=getMember(from);
    if (member == null) {
      member=new MemberImpl(from,thisAddress.equals(from));
    }
    Data newValue=value;
    Data oldValue=null;
    if (value != null && getInstanceType(name).isMap()) {
      Keys keys=(Keys)toObject(value);
      Collection<Data> values=keys.getKeys();
      if (values != null) {
        Iterator<Data> it=values.iterator();
        if (it.hasNext()) {
          newValue=it.next();
        }
        if (it.hasNext()) {
          oldValue=it.next();
        }
      }
    }
    final DataAwareEntryEvent dataAwareEntryEvent=new DataAwareEntryEvent(member,eventType,name,key,newValue,oldValue);
    int hash;
    if (key != null) {
      hash=key.hashCode();
    }
 else {
      hash=hashTwo(from.hashCode(),name.hashCode());
    }
    node.executorManager.getEventExecutorService().executeOrderedRunnable(hash,new Runnable(){
      public void run(){
        try {
          node.listenerManager.callListeners(dataAwareEntryEvent);
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.4714131607335491
50075,"public void run(){
  try {
    node.listenerManager.callListeners(EventTask.this);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void run(){
  try {
    node.listenerManager.callListeners(dataAwareEntryEvent);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9204152249134948
50076,"void fireMapEvent(final Map<Address,Boolean> mapListeners,final String name,final int eventType,final Data key,final Data oldValue,final Data value,Map<Address,Boolean> keyListeners,Address callerAddress){
  if (keyListeners == null && (mapListeners == null || mapListeners.size() == 0)) {
    return;
  }
  try {
    Map<Address,Boolean> mapTargetListeners=null;
    if (keyListeners != null) {
      mapTargetListeners=new HashMap<Address,Boolean>(keyListeners);
    }
    if (mapListeners != null && mapListeners.size() > 0) {
      if (mapTargetListeners == null) {
        mapTargetListeners=new HashMap<Address,Boolean>(mapListeners);
      }
 else {
        final Set<Map.Entry<Address,Boolean>> entries=mapListeners.entrySet();
        for (        final Map.Entry<Address,Boolean> entry : entries) {
          if (mapTargetListeners.containsKey(entry.getKey())) {
            if (entry.getValue()) {
              mapTargetListeners.put(entry.getKey(),entry.getValue());
            }
          }
 else           mapTargetListeners.put(entry.getKey(),entry.getValue());
        }
      }
    }
    if (mapTargetListeners == null || mapTargetListeners.size() == 0) {
      return;
    }
    Data packetValue=oldValue != null ? toData(new Keys(Arrays.asList(value,oldValue))) : value;
    sendEvents(eventType,name,key,packetValue,mapTargetListeners,callerAddress);
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
}","void fireMapEvent(final Map<Address,Boolean> mapListeners,final String name,final int eventType,final Data key,final Data oldValue,final Data value,Map<Address,Boolean> keyListeners,Address callerAddress){
  if (keyListeners == null && (mapListeners == null || mapListeners.size() == 0)) {
    return;
  }
  try {
    Map<Address,Boolean> mapTargetListeners=null;
    if (keyListeners != null) {
      mapTargetListeners=new HashMap<Address,Boolean>(keyListeners);
    }
    if (mapListeners != null && mapListeners.size() > 0) {
      if (mapTargetListeners == null) {
        mapTargetListeners=new HashMap<Address,Boolean>(mapListeners);
      }
 else {
        final Set<Map.Entry<Address,Boolean>> entries=mapListeners.entrySet();
        for (        final Map.Entry<Address,Boolean> entry : entries) {
          if (mapTargetListeners.containsKey(entry.getKey())) {
            if (entry.getValue()) {
              mapTargetListeners.put(entry.getKey(),entry.getValue());
            }
          }
 else           mapTargetListeners.put(entry.getKey(),entry.getValue());
        }
      }
    }
    if (mapTargetListeners == null || mapTargetListeners.size() == 0) {
      return;
    }
    Data packetValue=value;
    if (value != null && getInstanceType(name).isMap()) {
      Keys keys=new Keys();
      keys.addKey(value);
      if (oldValue != null) {
        keys.addKey(oldValue);
      }
      packetValue=toData(keys);
    }
    sendEvents(eventType,name,key,packetValue,mapTargetListeners,callerAddress);
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
}",0.9167217448777264
50077,"public Object getKey(){
  if (key == null && dataKey != null) {
    key=toObject(dataKey);
  }
  return key;
}","public Object getKey(){
  return key;
}",0.5234899328859061
50078,"public Object getValue(){
  if (value == null) {
    if (dataValue != null) {
      fillValues();
    }
 else     if (collection) {
      value=key;
    }
  }
  return value;
}","public Object getValue(){
  return value;
}",0.3926940639269406
50079,"Packet createEntryEventPacket(EntryEvent event){
  Packet packet=new Packet();
  BaseManager.EventTask eventTask=(BaseManager.EventTask)event;
  packet.set(event.getName(),ClusterOperation.EVENT,eventTask.getDataKey(),eventTask.getDataValue());
  packet.longValue=event.getEventType().getType();
  return packet;
}","Packet createEntryEventPacket(EntryEvent event){
  Packet packet=new Packet();
  DataAwareEntryEvent dataAwareEntryEvent=(DataAwareEntryEvent)event;
  packet.set(event.getName(),ClusterOperation.EVENT,dataAwareEntryEvent.getKeyData(),dataAwareEntryEvent.getNewValueData());
  packet.longValue=event.getEventType().getType();
  return packet;
}",0.6971080669710806
50080,"void callListeners(EventTask event){
  for (  ListenerItem listenerItem : listeners) {
    if (listenerItem.listens(event)) {
      callListener(listenerItem,event);
    }
  }
}","void callListeners(DataAwareEntryEvent dataAwareEntryEvent){
  for (  ListenerItem listenerItem : listeners) {
    if (listenerItem.listens(dataAwareEntryEvent)) {
      callListener(listenerItem,dataAwareEntryEvent);
    }
  }
}",0.8078817733990148
50081,"public boolean listens(EventTask event){
  String name=event.getName();
  return this.name.equals(name) && (this.key == null || event.getKey().equals(this.key));
}","public boolean listens(DataAwareEntryEvent dataAwareEntryEvent){
  String name=dataAwareEntryEvent.getName();
  return this.name.equals(name) && (this.key == null || dataAwareEntryEvent.getKey().equals(this.key));
}",0.7936507936507936
50082,"void syncForDead(MemberImpl deadMember,Block block){
  Address deadAddress=deadMember.getAddress();
  if (deadAddress.equals(block.getOwner())) {
    MemberImpl member=concurrentMapManager.getNextMemberBeforeSync(deadAddress,true,1);
    if (member == null) {
      if (!concurrentMapManager.isSuperClient()) {
        block.setOwner(thisAddress);
      }
 else {
        block.setOwner(null);
      }
    }
 else {
      if (!deadAddress.equals(member.getAddress()) && !concurrentMapManager.isSuperClient()) {
        block.setOwner(member.getAddress());
      }
 else {
        block.setOwner(null);
      }
    }
    if (!block.isMigrating()) {
      Member currentOwner=(block.getOwner() == null) ? null : concurrentMapManager.getMember(block.getOwner());
      if (currentOwner != null) {
        MigrationEvent migrationEvent=new MigrationEvent(concurrentMapManager.node,block.getBlockId(),deadMember,currentOwner);
        partitionServiceImpl.doFireMigrationEvent(true,migrationEvent);
        partitionServiceImpl.doFireMigrationEvent(false,migrationEvent);
      }
    }
  }
  if (block.isMigrating()) {
    if (deadAddress.equals(block.getMigrationAddress())) {
      MemberImpl member=concurrentMapManager.getNextMemberBeforeSync(deadAddress,true,1);
      if (member == null) {
        if (!concurrentMapManager.isSuperClient()) {
          block.setMigrationAddress(thisAddress);
        }
 else {
          block.setMigrationAddress(null);
        }
      }
 else {
        if (!deadAddress.equals(member.getAddress())) {
          block.setMigrationAddress(member.getAddress());
        }
 else {
          block.setMigrationAddress(null);
        }
      }
    }
  }
  if (block.isMigrating() && block.getMigrationAddress().equals(block.getOwner())) {
    block.setMigrationAddress(null);
    Member currentOwner=(block.getOwner() == null) ? null : concurrentMapManager.getMember(block.getOwner());
    MigrationEvent migrationEvent=new MigrationEvent(concurrentMapManager.node,block.getBlockId(),deadMember,currentOwner);
    partitionServiceImpl.doFireMigrationEvent(true,migrationEvent);
    partitionServiceImpl.doFireMigrationEvent(false,migrationEvent);
  }
  partitionServiceImpl.reset();
}","void syncForDead(MemberImpl deadMember,Block block){
  Address deadAddress=deadMember.getAddress();
  if (deadAddress.equals(block.getOwner())) {
    MemberImpl member=concurrentMapManager.getNextMemberBeforeSync(deadAddress,true,1);
    if (member == null) {
      if (!concurrentMapManager.isSuperClient()) {
        block.setOwner(thisAddress);
      }
 else {
        block.setOwner(null);
      }
    }
 else {
      if (!deadAddress.equals(member.getAddress())) {
        block.setOwner(member.getAddress());
      }
 else {
        block.setOwner(null);
      }
    }
    if (!block.isMigrating()) {
      Member currentOwner=(block.getOwner() == null) ? null : concurrentMapManager.getMember(block.getOwner());
      if (currentOwner != null) {
        MigrationEvent migrationEvent=new MigrationEvent(concurrentMapManager.node,block.getBlockId(),deadMember,currentOwner);
        partitionServiceImpl.doFireMigrationEvent(true,migrationEvent);
        partitionServiceImpl.doFireMigrationEvent(false,migrationEvent);
      }
    }
  }
  if (block.isMigrating()) {
    if (deadAddress.equals(block.getMigrationAddress())) {
      MemberImpl member=concurrentMapManager.getNextMemberBeforeSync(deadAddress,true,1);
      if (member == null) {
        if (!concurrentMapManager.isSuperClient()) {
          block.setMigrationAddress(thisAddress);
        }
 else {
          block.setMigrationAddress(null);
        }
      }
 else {
        if (!deadAddress.equals(member.getAddress())) {
          block.setMigrationAddress(member.getAddress());
        }
 else {
          block.setMigrationAddress(null);
        }
      }
    }
  }
  if (block.isMigrating() && block.getMigrationAddress().equals(block.getOwner())) {
    block.setMigrationAddress(null);
    Member currentOwner=(block.getOwner() == null) ? null : concurrentMapManager.getMember(block.getOwner());
    MigrationEvent migrationEvent=new MigrationEvent(concurrentMapManager.node,block.getBlockId(),deadMember,currentOwner);
    partitionServiceImpl.doFireMigrationEvent(true,migrationEvent);
    partitionServiceImpl.doFireMigrationEvent(false,migrationEvent);
  }
  partitionServiceImpl.reset();
}",0.2735354456348302
50083,"public void setExpirationTime(long ttl){
  if (ttl <= 0 || ttl == Long.MAX_VALUE) {
    expirationTime=Long.MAX_VALUE;
  }
 else {
    expirationTime=getCreationTime() + ttl;
  }
}","public void setExpirationTime(long ttl){
  if (ttl <= 0 || ttl == Long.MAX_VALUE) {
    expirationTime=Long.MAX_VALUE;
  }
 else {
    long age=(System.currentTimeMillis() - getCreationTime());
    expirationTime=getCreationTime() + age + ttl;
  }
}",0.8391608391608392
50084,"public Collection<V> values(Predicate predicate){
  Set<V> result=new HashSet<V>();
  Set<Map.Entry<K,V>> entries=super.entrySet();
  for (  Map.Entry<K,V> entry : entries) {
    if (predicate.apply((MapEntry)entry)) {
      result.add(entry.getValue());
    }
  }
  return result;
}","public Collection<V> values(Predicate predicate){
  Set<V> result=new HashSet<V>();
  Set<Map.Entry<K,V>> entries=super.entrySet();
  for (  Map.Entry<K,V> entry : entries) {
    if (apply(predicate,entry)) {
      result.add(entry.getValue());
    }
  }
  return result;
}",0.9244604316546764
50085,"public Set<K> keySet(Predicate predicate){
  Set<K> result=new HashSet<K>();
  Set<Map.Entry<K,V>> entries=super.entrySet();
  for (  Map.Entry<K,V> entry : entries) {
    if (predicate.apply((MapEntry)entry)) {
      result.add(entry.getKey());
    }
  }
  return result;
}","public Set<K> keySet(Predicate predicate){
  Set<K> result=new HashSet<K>();
  Set<Map.Entry<K,V>> entries=super.entrySet();
  for (  Map.Entry<K,V> entry : entries) {
    if (apply(predicate,entry)) {
      result.add(entry.getKey());
    }
  }
  return result;
}",0.9219330855018588
50086,"public Set<Entry<K,V>> entrySet(Predicate predicate){
  Set<Map.Entry<K,V>> result=new HashSet<Map.Entry<K,V>>();
  Set<Map.Entry<K,V>> entries=super.entrySet();
  for (  Map.Entry<K,V> entry : entries) {
    if (predicate.apply((MapEntry)entry)) {
      result.add(entry);
    }
  }
  return result;
}","public Set<Entry<K,V>> entrySet(Predicate predicate){
  Set<Map.Entry<K,V>> result=new HashSet<Map.Entry<K,V>>();
  Set<Map.Entry<K,V>> entries=super.entrySet();
  for (  Map.Entry<K,V> entry : entries) {
    if (apply(predicate,entry)) {
      result.add(entry);
    }
  }
  return result;
}",0.9292929292929292
50087,"@Ignore @Test public void issue387(){
  IMap cache=ReplicatedMapFactory.getMap(""String_Node_Str"");
  ExampleObject object1=new ExampleObject(""String_Node_Str"",""String_Node_Str"");
  cache.put(object1.getId(),object1);
  EntryObject e=new PredicateBuilder().getEntryObject();
  Predicate predicate=e.get(""String_Node_Str"").equal(""String_Node_Str"");
  Collection<Object> queryResultCollection=cache.values(predicate);
}","@Test public void issue387(){
  IMap cache=ReplicatedMapFactory.getMap(""String_Node_Str"");
  ExampleObject object1=new ExampleObject(""String_Node_Str"",""String_Node_Str"");
  cache.put(object1.getId(),object1);
  EntryObject e=new PredicateBuilder().getEntryObject();
  Predicate predicate=e.get(""String_Node_Str"").equal(""String_Node_Str"");
  Collection<Object> queryResultCollection=cache.values(predicate);
}",0.9902912621359224
50088,"public V put(K key,V value,long ttl,TimeUnit timeunit){
  throw new UnsupportedOperationException();
}","public V put(K key,V value,long ttl,TimeUnit timeunit){
  check(key);
  check(value);
  return (V)proxyHelper.doOp(ClusterOperation.CONCURRENT_MAP_PUT,key,value,ttl,timeunit);
}",0.5949820788530465
50089,"public boolean tryPut(K key,V value,long timeout,TimeUnit timeunit){
  throw new UnsupportedOperationException();
}","public boolean tryPut(K key,V value,long timeout,TimeUnit timeunit){
  check(key);
  check(value);
  return (Boolean)proxyHelper.doOp(ClusterOperation.CONCURRENT_MAP_TRY_PUT,key,value,timeout,timeunit);
}",0.4890282131661442
50090,"protected Object doOp(ClusterOperation operation,Object key,Object value){
  Packet request=prepareRequest(operation,key,value);
  Packet response=callAndGetResult(request);
  return getValue(response);
}","public Object doOp(ClusterOperation operation,Object key,Object value,long ttl,TimeUnit timeunit){
  Packet request=prepareRequest(operation,key,value,ttl,timeunit);
  Packet response=callAndGetResult(request);
  return getValue(response);
}",0.4674157303370786
50091,"protected Packet prepareRequest(ClusterOperation operation,Object key,Object value){
  byte[] k=null;
  byte[] v=null;
  if (key != null) {
    k=toByte(key);
  }
  if (value != null) {
    v=toByte(value);
  }
  return createRequestPacket(operation,k,v);
}","protected Packet prepareRequest(ClusterOperation operation,Object key,Object value){
  return prepareRequest(operation,key,value,0,null);
}",0.6212121212121212
50092,"public Packet createRequestPacket(ClusterOperation operation,byte[] key,byte[] value){
  Packet request=createRequestPacket();
  request.setOperation(operation);
  request.setKey(key);
  request.setValue(value);
  return request;
}","private Packet createRequestPacket(ClusterOperation operation,byte[] key,byte[] value,long ttl,TimeUnit timeunit){
  Packet request=createRequestPacket();
  request.setOperation(operation);
  request.setKey(key);
  request.setValue(value);
  if (ttl > 0 && timeunit != null) {
    request.setTimeout(timeunit.toMillis(ttl));
  }
  return request;
}",0.7253886010362695
50093,"public abstract Data processMapOp(IMap<Object,Object> map,Data key,Data value);","protected abstract Data processMapOp(IMap<Object,Object> map,Data keyData,Data valueData,long ttl);",0.8426966292134831
50094,"public ClientService(Node node){
  this.node=node;
  this.logger=node.getLogger(this.getClass().getName());
  node.getClusterImpl().addMembershipListener(new ClientServiceMembershipListener());
  clientOperationHandlers[CONCURRENT_MAP_PUT.getValue()]=new MapPutHandler();
  clientOperationHandlers[CONCURRENT_MAP_PUT_MULTI.getValue()]=new MapPutMultiHandler();
  clientOperationHandlers[CONCURRENT_MAP_PUT_IF_ABSENT.getValue()]=new MapPutIfAbsentHandler();
  clientOperationHandlers[CONCURRENT_MAP_GET.getValue()]=new MapGetHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE.getValue()]=new MapRemoveHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE_IF_SAME.getValue()]=new MapRemoveIfSameHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE_MULTI.getValue()]=new MapRemoveMultiHandler();
  clientOperationHandlers[CONCURRENT_MAP_EVICT.getValue()]=new MapEvictHandler();
  clientOperationHandlers[CONCURRENT_MAP_REPLACE_IF_NOT_NULL.getValue()]=new MapReplaceIfNotNullHandler();
  clientOperationHandlers[CONCURRENT_MAP_REPLACE_IF_SAME.getValue()]=new MapReplaceIfSameHandler();
  clientOperationHandlers[CONCURRENT_MAP_SIZE.getValue()]=new MapSizeHandler();
  clientOperationHandlers[CONCURRENT_MAP_GET_MAP_ENTRY.getValue()]=new GetMapEntryHandler();
  clientOperationHandlers[CONCURRENT_MAP_LOCK.getValue()]=new MapLockHandler();
  clientOperationHandlers[CONCURRENT_MAP_UNLOCK.getValue()]=new MapUnlockHandler();
  clientOperationHandlers[CONCURRENT_MAP_LOCK_MAP.getValue()]=new MapLockMapHandler();
  clientOperationHandlers[CONCURRENT_MAP_UNLOCK_MAP.getValue()]=new MapUnlockMapHandler();
  clientOperationHandlers[CONCURRENT_MAP_CONTAINS.getValue()]=new MapContainsHandler();
  clientOperationHandlers[CONCURRENT_MAP_CONTAINS_VALUE.getValue()]=new MapContainsValueHandler();
  clientOperationHandlers[CONCURRENT_MAP_ADD_TO_LIST.getValue()]=new ListAddHandler();
  clientOperationHandlers[CONCURRENT_MAP_ADD_TO_SET.getValue()]=new SetAddHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE_ITEM.getValue()]=new MapItemRemoveHandler();
  clientOperationHandlers[CONCURRENT_MAP_ITERATE_KEYS.getValue()]=new MapIterateKeysHandler();
  clientOperationHandlers[CONCURRENT_MAP_ITERATE_ENTRIES.getValue()]=new MapIterateEntriesHandler();
  clientOperationHandlers[CONCURRENT_MAP_VALUE_COUNT.getValue()]=new MapValueCountHandler();
  clientOperationHandlers[BLOCKING_QUEUE_OFFER.getValue()]=new QueueOfferHandler();
  clientOperationHandlers[BLOCKING_QUEUE_POLL.getValue()]=new QueuePollHandler();
  clientOperationHandlers[BLOCKING_QUEUE_REMOVE.getValue()]=new QueueRemoveHandler();
  clientOperationHandlers[BLOCKING_QUEUE_PEEK.getValue()]=new QueuePeekHandler();
  clientOperationHandlers[BLOCKING_QUEUE_SIZE.getValue()]=new QueueSizeHandler();
  clientOperationHandlers[BLOCKING_QUEUE_PUBLISH.getValue()]=new QueuePublishHandler();
  clientOperationHandlers[BLOCKING_QUEUE_RAMAINING_CAPACITY.getValue()]=new QueueRemainingCapacityHandler();
  clientOperationHandlers[BLOCKING_QUEUE_ENTRIES.getValue()]=new QueueEntriesHandler();
  clientOperationHandlers[TRANSACTION_BEGIN.getValue()]=new TransactionBeginHandler();
  clientOperationHandlers[TRANSACTION_COMMIT.getValue()]=new TransactionCommitHandler();
  clientOperationHandlers[TRANSACTION_ROLLBACK.getValue()]=new TransactionRollbackHandler();
  clientOperationHandlers[ADD_LISTENER.getValue()]=new AddListenerHandler();
  clientOperationHandlers[REMOVE_LISTENER.getValue()]=new RemoveListenerHandler();
  clientOperationHandlers[REMOTELY_PROCESS.getValue()]=new RemotelyProcessHandler();
  clientOperationHandlers[DESTROY.getValue()]=new DestroyHandler();
  clientOperationHandlers[GET_ID.getValue()]=new GetIdHandler();
  clientOperationHandlers[ADD_INDEX.getValue()]=new AddIndexHandler();
  clientOperationHandlers[NEW_ID.getValue()]=new NewIdHandler();
  clientOperationHandlers[EXECUTE.getValue()]=new ExecutorServiceHandler();
  clientOperationHandlers[GET_INSTANCES.getValue()]=new GetInstancesHandler();
  clientOperationHandlers[GET_MEMBERS.getValue()]=new GetMembersHandler();
  clientOperationHandlers[GET_CLUSTER_TIME.getValue()]=new GetClusterTimeHandler();
  clientOperationHandlers[CLIENT_AUTHENTICATE.getValue()]=new ClientAuthenticateHandler();
  clientOperationHandlers[CLIENT_ADD_INSTANCE_LISTENER.getValue()]=new ClientAddInstanceListenerHandler();
  clientOperationHandlers[CLIENT_GET_PARTITIONS.getValue()]=new GetPartitionsHandler();
  clientOperationHandlers[ATOMIC_NUMBER_GET_AND_SET.getValue()]=new AtomicOperationHandler();
  clientOperationHandlers[ATOMIC_NUMBER_GET_AND_ADD.getValue()]=new AtomicOperationHandler();
  clientOperationHandlers[ATOMIC_NUMBER_COMPARE_AND_SET.getValue()]=new AtomicOperationHandler();
  clientOperationHandlers[ATOMIC_NUMBER_ADD_AND_GET.getValue()]=new AtomicOperationHandler();
  node.connectionManager.addConnectionListener(this);
}","public ClientService(Node node){
  this.node=node;
  this.logger=node.getLogger(this.getClass().getName());
  node.getClusterImpl().addMembershipListener(new ClientServiceMembershipListener());
  clientOperationHandlers[CONCURRENT_MAP_PUT.getValue()]=new MapPutHandler();
  clientOperationHandlers[CONCURRENT_MAP_PUT_MULTI.getValue()]=new MapPutMultiHandler();
  clientOperationHandlers[CONCURRENT_MAP_PUT_IF_ABSENT.getValue()]=new MapPutIfAbsentHandler();
  clientOperationHandlers[CONCURRENT_MAP_TRY_PUT.getValue()]=new MapTryPutHandler();
  clientOperationHandlers[CONCURRENT_MAP_GET.getValue()]=new MapGetHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE.getValue()]=new MapRemoveHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE_IF_SAME.getValue()]=new MapRemoveIfSameHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE_MULTI.getValue()]=new MapRemoveMultiHandler();
  clientOperationHandlers[CONCURRENT_MAP_EVICT.getValue()]=new MapEvictHandler();
  clientOperationHandlers[CONCURRENT_MAP_REPLACE_IF_NOT_NULL.getValue()]=new MapReplaceIfNotNullHandler();
  clientOperationHandlers[CONCURRENT_MAP_REPLACE_IF_SAME.getValue()]=new MapReplaceIfSameHandler();
  clientOperationHandlers[CONCURRENT_MAP_SIZE.getValue()]=new MapSizeHandler();
  clientOperationHandlers[CONCURRENT_MAP_GET_MAP_ENTRY.getValue()]=new GetMapEntryHandler();
  clientOperationHandlers[CONCURRENT_MAP_LOCK.getValue()]=new MapLockHandler();
  clientOperationHandlers[CONCURRENT_MAP_UNLOCK.getValue()]=new MapUnlockHandler();
  clientOperationHandlers[CONCURRENT_MAP_LOCK_MAP.getValue()]=new MapLockMapHandler();
  clientOperationHandlers[CONCURRENT_MAP_UNLOCK_MAP.getValue()]=new MapUnlockMapHandler();
  clientOperationHandlers[CONCURRENT_MAP_CONTAINS.getValue()]=new MapContainsHandler();
  clientOperationHandlers[CONCURRENT_MAP_CONTAINS_VALUE.getValue()]=new MapContainsValueHandler();
  clientOperationHandlers[CONCURRENT_MAP_ADD_TO_LIST.getValue()]=new ListAddHandler();
  clientOperationHandlers[CONCURRENT_MAP_ADD_TO_SET.getValue()]=new SetAddHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE_ITEM.getValue()]=new MapItemRemoveHandler();
  clientOperationHandlers[CONCURRENT_MAP_ITERATE_KEYS.getValue()]=new MapIterateKeysHandler();
  clientOperationHandlers[CONCURRENT_MAP_ITERATE_ENTRIES.getValue()]=new MapIterateEntriesHandler();
  clientOperationHandlers[CONCURRENT_MAP_VALUE_COUNT.getValue()]=new MapValueCountHandler();
  clientOperationHandlers[BLOCKING_QUEUE_OFFER.getValue()]=new QueueOfferHandler();
  clientOperationHandlers[BLOCKING_QUEUE_POLL.getValue()]=new QueuePollHandler();
  clientOperationHandlers[BLOCKING_QUEUE_REMOVE.getValue()]=new QueueRemoveHandler();
  clientOperationHandlers[BLOCKING_QUEUE_PEEK.getValue()]=new QueuePeekHandler();
  clientOperationHandlers[BLOCKING_QUEUE_SIZE.getValue()]=new QueueSizeHandler();
  clientOperationHandlers[BLOCKING_QUEUE_PUBLISH.getValue()]=new QueuePublishHandler();
  clientOperationHandlers[BLOCKING_QUEUE_RAMAINING_CAPACITY.getValue()]=new QueueRemainingCapacityHandler();
  clientOperationHandlers[BLOCKING_QUEUE_ENTRIES.getValue()]=new QueueEntriesHandler();
  clientOperationHandlers[TRANSACTION_BEGIN.getValue()]=new TransactionBeginHandler();
  clientOperationHandlers[TRANSACTION_COMMIT.getValue()]=new TransactionCommitHandler();
  clientOperationHandlers[TRANSACTION_ROLLBACK.getValue()]=new TransactionRollbackHandler();
  clientOperationHandlers[ADD_LISTENER.getValue()]=new AddListenerHandler();
  clientOperationHandlers[REMOVE_LISTENER.getValue()]=new RemoveListenerHandler();
  clientOperationHandlers[REMOTELY_PROCESS.getValue()]=new RemotelyProcessHandler();
  clientOperationHandlers[DESTROY.getValue()]=new DestroyHandler();
  clientOperationHandlers[GET_ID.getValue()]=new GetIdHandler();
  clientOperationHandlers[ADD_INDEX.getValue()]=new AddIndexHandler();
  clientOperationHandlers[NEW_ID.getValue()]=new NewIdHandler();
  clientOperationHandlers[EXECUTE.getValue()]=new ExecutorServiceHandler();
  clientOperationHandlers[GET_INSTANCES.getValue()]=new GetInstancesHandler();
  clientOperationHandlers[GET_MEMBERS.getValue()]=new GetMembersHandler();
  clientOperationHandlers[GET_CLUSTER_TIME.getValue()]=new GetClusterTimeHandler();
  clientOperationHandlers[CLIENT_AUTHENTICATE.getValue()]=new ClientAuthenticateHandler();
  clientOperationHandlers[CLIENT_ADD_INSTANCE_LISTENER.getValue()]=new ClientAddInstanceListenerHandler();
  clientOperationHandlers[CLIENT_GET_PARTITIONS.getValue()]=new GetPartitionsHandler();
  clientOperationHandlers[ATOMIC_NUMBER_GET_AND_SET.getValue()]=new AtomicOperationHandler();
  clientOperationHandlers[ATOMIC_NUMBER_GET_AND_ADD.getValue()]=new AtomicOperationHandler();
  clientOperationHandlers[ATOMIC_NUMBER_COMPARE_AND_SET.getValue()]=new AtomicOperationHandler();
  clientOperationHandlers[ATOMIC_NUMBER_ADD_AND_GET.getValue()]=new AtomicOperationHandler();
  node.connectionManager.addConnectionListener(this);
}",0.991359154213683
50095,"@Test public void testRun() throws Exception {
  final AtomicInteger counter=new AtomicInteger(0);
  final ClientRunnable clientRunnable=new ClientRunnable(){
    @Override protected void customRun() throws InterruptedException {
      counter.incrementAndGet();
    }
  }
;
  final CountDownLatch latch=new CountDownLatch(1);
  final CountDownLatch waitLatch=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      try {
        waitLatch.countDown();
        Thread.sleep(100);
        clientRunnable.running=false;
synchronized (clientRunnable.monitor) {
          clientRunnable.monitor.wait();
        }
        latch.countDown();
      }
 catch (      InterruptedException e) {
      }
    }
  }
).start();
  clientRunnable.run();
  waitLatch.countDown();
  assertTrue(counter.get() > 1);
  assertTrue(""String_Node_Str"",latch.await(25,TimeUnit.SECONDS));
}","@Test public void testRun() throws Exception {
  final AtomicInteger counter=new AtomicInteger(0);
  final ClientRunnable clientRunnable=new ClientRunnable(){
    @Override protected void customRun() throws InterruptedException {
      counter.incrementAndGet();
    }
  }
;
  final CountDownLatch latch=new CountDownLatch(1);
  final CountDownLatch waitLatch=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      try {
        waitLatch.countDown();
        Thread.sleep(100);
        clientRunnable.running=false;
synchronized (clientRunnable.monitor) {
          clientRunnable.monitor.wait();
        }
        latch.countDown();
      }
 catch (      InterruptedException e) {
      }
    }
  }
).start();
  clientRunnable.run();
  assertTrue(waitLatch.await(10,TimeUnit.SECONDS));
  assertTrue(counter.get() > 1);
  assertTrue(""String_Node_Str"",latch.await(10,TimeUnit.SECONDS));
}",0.8850638534147696
50096,"public void run(){
  Collection<MemberInfo> lsMemberInfos=membersUpdate.getMemberInfos();
  List<Address> newMemberList=new ArrayList<Address>(lsMemberInfos.size());
  for (  final MemberInfo memberInfo : lsMemberInfos) {
    newMemberList.add(memberInfo.address);
  }
  List<AsyncRemotelyBooleanCallable> calls=new ArrayList<AsyncRemotelyBooleanCallable>(lsMemberInfos.size());
  for (  final Address target : newMemberList) {
    if (!thisAddress.equals(target)) {
      AsyncRemotelyBooleanCallable rrp=new AsyncRemotelyBooleanCallable();
      rrp.executeProcess(target,membersUpdate);
      calls.add(rrp);
    }
  }
  for (  AsyncRemotelyBooleanCallable call : calls) {
    if (!call.getResultAsBoolean()) {
      newMemberList.remove(call.getTarget());
    }
  }
  calls.clear();
  for (  final Address target : newMemberList) {
    AsyncRemotelyBooleanCallable call=new AsyncRemotelyBooleanCallable();
    call.executeProcess(target,new SyncProcess());
    calls.add(call);
  }
  for (  AsyncRemotelyBooleanCallable call : calls) {
    if (!call.getResultAsBoolean()) {
      newMemberList.remove(call.getTarget());
    }
  }
  calls.clear();
  AbstractRemotelyCallable<Boolean> connCheckCallable=new ConnectionCheckCall();
  for (  final Address target : newMemberList) {
    AsyncRemotelyBooleanCallable call=new AsyncRemotelyBooleanCallable();
    call.executeProcess(target,connCheckCallable);
    calls.add(call);
  }
  for (  AsyncRemotelyBooleanCallable call : calls) {
    if (!call.getResultAsBoolean()) {
      newMemberList.remove(call.getTarget());
    }
  }
}","public void run(){
  checkScheduledActions();
}",0.0417947141979102
50097,"public void destroy(String name){
  mapQueues.remove(name);
}","public void destroy(){
  lsBlocks.clear();
  mapListeners.clear();
  for (  ScheduledPollAction scheduledPollAction : lsScheduledPollActions) {
    scheduledPollAction.setValid(false);
  }
  lsScheduledPollActions.clear();
  for (  ScheduledOfferAction scheduledOfferAction : lsScheduledOfferActions) {
    scheduledOfferAction.setValid(false);
  }
  lsScheduledOfferActions.clear();
}",0.116591928251121
50098,"void reset(){
  if (locallyOwnedMap != null) {
    locallyOwnedMap.reset();
  }
  if (mapNearCache != null) {
    mapNearCache.reset();
  }
  mapRecords.clear();
  mapIndexService.clear();
  if (store != null && store instanceof MapStoreWrapper) {
    try {
      ((MapStoreWrapper)store).destroy();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","void reset(){
  for (  Record record : mapRecords.values()) {
    if (record.hasScheduledAction()) {
      List<ScheduledAction> lsScheduledActions=record.getScheduledActions();
      if (lsScheduledActions != null) {
        for (        ScheduledAction scheduledAction : lsScheduledActions) {
          scheduledAction.setValid(false);
        }
      }
    }
  }
  if (locallyOwnedMap != null) {
    locallyOwnedMap.reset();
  }
  if (mapNearCache != null) {
    mapNearCache.reset();
  }
  mapRecordEntries.clear();
  mapRecords.clear();
  mapIndexService.clear();
  if (store != null && store instanceof MapStoreWrapper) {
    try {
      ((MapStoreWrapper)store).destroy();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}",0.661319073083779
50099,"public void own(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  Record record=toRecord(req);
  if (req.ttl <= 0 || req.timeout <= 0) {
    record.setInvalid();
  }
 else {
    record.setExpirationTime(req.ttl);
    record.setMaxIdle(req.timeout);
  }
  markAsActive(record);
  if (store != null && writeDelayMillis > 0) {
    markAsDirty(record);
  }
  if (req.value != null) {
    updateIndexes(record);
  }
  record.setVersion(req.version);
}","public void own(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  if (req.value == null) {
    if (isSet() || isList()) {
      req.value=new Data();
    }
  }
  Record record=toRecord(req);
  if (req.ttl <= 0 || req.timeout <= 0) {
    record.setInvalid();
  }
 else {
    record.setExpirationTime(req.ttl);
    record.setMaxIdle(req.timeout);
  }
  markAsActive(record);
  if (store != null && writeDelayMillis > 0) {
    markAsDirty(record);
  }
  if (req.value != null) {
    updateIndexes(record);
  }
  record.setVersion(req.version);
}",0.9162303664921466
50100,"public void destroy(String name){
  maps.remove(name);
}","public void destroy(String name){
  CMap cmap=maps.remove(name);
  if (cmap != null) {
    cmap.reset();
  }
  mapLocallyOwnedMaps.remove(name);
  mapCaches.remove(name);
}",0.4912280701754385
50101,"public void stop(){
  if (!started)   return;
  parallelExecutorService.shutdown();
  Collection<NamedExecutorService> executors=mapExecutors.values();
  for (  NamedExecutorService namedExecutorService : executors) {
    namedExecutorService.stop();
  }
  threadPoolExecutor.shutdownNow();
  try {
    threadPoolExecutor.awaitTermination(3,TimeUnit.SECONDS);
  }
 catch (  InterruptedException ignored) {
  }
  started=false;
}","public void stop(){
  if (!started)   return;
  Collection<NamedExecutorService> executors=mapExecutors.values();
  for (  NamedExecutorService namedExecutorService : executors) {
    namedExecutorService.stop();
  }
  parallelExecutorService.shutdown();
  try {
    threadPoolExecutor.shutdownNow();
    threadPoolExecutor.awaitTermination(5,TimeUnit.SECONDS);
  }
 catch (  InterruptedException ignored) {
  }
  started=false;
}",0.8857808857808858
50102,"void syncForDead(MemberImpl deadMember,Block block){
  Address deadAddress=deadMember.getAddress();
  if (deadAddress.equals(block.getOwner())) {
    MemberImpl member=concurrentMapManager.getNextMemberBeforeSync(deadAddress,true,1);
    if (member == null) {
      if (!concurrentMapManager.isSuperClient()) {
        block.setOwner(thisAddress);
      }
 else {
        block.setOwner(null);
      }
    }
 else {
      if (!deadAddress.equals(member.getAddress()) && !concurrentMapManager.isSuperClient()) {
        block.setOwner(member.getAddress());
      }
 else {
        block.setOwner(null);
      }
    }
    if (!block.isMigrating()) {
      Member currentOwner=(block.getOwner() == null) ? null : concurrentMapManager.getMember(block.getOwner());
      if (currentOwner != null) {
        MigrationEvent migrationEvent=new MigrationEvent(concurrentMapManager.node,block.getBlockId(),deadMember,currentOwner);
        partitionServiceImpl.doFireMigrationEvent(true,migrationEvent);
        partitionServiceImpl.doFireMigrationEvent(false,migrationEvent);
      }
    }
  }
  if (block.isMigrating()) {
    if (deadAddress.equals(block.getMigrationAddress())) {
      MemberImpl member=concurrentMapManager.getNextMemberBeforeSync(deadAddress,true,1);
      if (member == null) {
        if (!concurrentMapManager.isSuperClient()) {
          block.setMigrationAddress(thisAddress);
        }
 else {
          block.setMigrationAddress(null);
        }
      }
 else {
        if (!deadAddress.equals(member.getAddress())) {
          block.setMigrationAddress(member.getAddress());
        }
 else {
          block.setMigrationAddress(null);
        }
      }
    }
  }
  if (block.isMigrating() && block.getMigrationAddress().equals(block.getOwner())) {
    block.setMigrationAddress(null);
  }
  partitionServiceImpl.reset();
}","void syncForDead(MemberImpl deadMember,Block block){
  Address deadAddress=deadMember.getAddress();
  if (deadAddress.equals(block.getOwner())) {
    MemberImpl member=concurrentMapManager.getNextMemberBeforeSync(deadAddress,true,1);
    if (member == null) {
      if (!concurrentMapManager.isSuperClient()) {
        block.setOwner(thisAddress);
      }
 else {
        block.setOwner(null);
      }
    }
 else {
      if (!deadAddress.equals(member.getAddress()) && !concurrentMapManager.isSuperClient()) {
        block.setOwner(member.getAddress());
      }
 else {
        block.setOwner(null);
      }
    }
    if (!block.isMigrating()) {
      Member currentOwner=(block.getOwner() == null) ? null : concurrentMapManager.getMember(block.getOwner());
      if (currentOwner != null) {
        MigrationEvent migrationEvent=new MigrationEvent(concurrentMapManager.node,block.getBlockId(),deadMember,currentOwner);
        partitionServiceImpl.doFireMigrationEvent(true,migrationEvent);
        partitionServiceImpl.doFireMigrationEvent(false,migrationEvent);
      }
    }
  }
  if (block.isMigrating()) {
    if (deadAddress.equals(block.getMigrationAddress())) {
      MemberImpl member=concurrentMapManager.getNextMemberBeforeSync(deadAddress,true,1);
      if (member == null) {
        if (!concurrentMapManager.isSuperClient()) {
          block.setMigrationAddress(thisAddress);
        }
 else {
          block.setMigrationAddress(null);
        }
      }
 else {
        if (!deadAddress.equals(member.getAddress())) {
          block.setMigrationAddress(member.getAddress());
        }
 else {
          block.setMigrationAddress(null);
        }
      }
    }
  }
  if (block.isMigrating() && block.getMigrationAddress().equals(block.getOwner())) {
    block.setMigrationAddress(null);
    Member currentOwner=(block.getOwner() == null) ? null : concurrentMapManager.getMember(block.getOwner());
    MigrationEvent migrationEvent=new MigrationEvent(concurrentMapManager.node,block.getBlockId(),deadMember,currentOwner);
    partitionServiceImpl.doFireMigrationEvent(true,migrationEvent);
    partitionServiceImpl.doFireMigrationEvent(false,migrationEvent);
  }
  partitionServiceImpl.reset();
}",0.9085531180675376
50103,"public void reset(){
  lsBlocksToMigrate.clear();
  for (int i=0; i < PARTITION_COUNT; i++) {
    blocks[i]=null;
  }
  partitionServiceImpl.reset();
}","public void reset(){
  lsBlocksToMigrate.clear();
  for (int i=0; i < PARTITION_COUNT; i++) {
    blocks[i]=null;
  }
  partitionServiceImpl.reset();
  parallelExecutorBackups.shutdown();
  parallelExecutorMigration.shutdown();
}",0.7947368421052632
50104,"public void run(){
  searchForOtherClusters();
  lastRun=System.currentTimeMillis();
  inProgress=false;
}","public void run(){
  if (node.isMaster() && node.joined() && node.isActive()) {
    long now=System.currentTimeMillis();
    if (!inProgress && (now - lastRun > NEXT_RUN_DELAY_MILLIS) && node.clusterManager.shouldTryMerge()) {
      inProgress=true;
      node.executorManager.executeNow(new FallThroughRunnable(){
        @Override public void doRun(){
          searchForOtherClusters();
          lastRun=System.currentTimeMillis();
          inProgress=false;
        }
      }
);
    }
  }
}",0.2358803986710963
50105,"public ParallelExecutor newParallelExecutor(int concurrencyLevel){
  if (concurrencyLevel > 0 && concurrencyLevel < Integer.MAX_VALUE) {
    return new ParallelExecutorImpl(concurrencyLevel);
  }
 else {
    return new FullyParallelExecutorImpl();
  }
}","public ParallelExecutor newParallelExecutor(int concurrencyLevel){
  ParallelExecutor parallelExecutor=null;
  if (concurrencyLevel > 0 && concurrencyLevel < Integer.MAX_VALUE) {
    parallelExecutor=new ParallelExecutorImpl(concurrencyLevel);
  }
 else {
    parallelExecutor=new FullyParallelExecutorImpl();
  }
  lsParallelExecutors.add(parallelExecutor);
  return parallelExecutor;
}",0.746875
50106,"/** 
 * only ServiceThread should call
 */
private static void putString(ByteBuffer bb,String str){
  if (str == null) {
    bb.putInt(0);
  }
 else {
    byte[] bytes=mapStringByteCache.get(str);
    if (bytes == null) {
      bytes=str.getBytes();
      if (mapStringByteCache.size() >= 10000) {
        mapStringByteCache.clear();
        throw new RuntimeException(""String_Node_Str"");
      }
      mapStringByteCache.put(str,bytes);
    }
    bb.putInt(bytes.length);
    bb.put(bytes);
  }
}","/** 
 * only ServiceThread should call
 */
private static void putString(ByteBuffer bb,String str){
  if (str == null) {
    bb.putInt(0);
  }
 else {
    byte[] bytes=mapStringByteCache.get(str);
    if (bytes == null) {
      bytes=str.getBytes();
      if (mapStringByteCache.size() >= 10000) {
        mapStringByteCache.clear();
      }
      mapStringByteCache.put(str,bytes);
    }
    bb.putInt(bytes.length);
    bb.put(bytes);
  }
}",0.7582534611288605
50107,"public ThreadStats publish(){
  long now=System.nanoTime();
  totalTime+=(now - start);
  long totalRun=totalTime - totalWait;
  int utilizationPercentage=(int)((totalRun * 100L) / totalTime);
  ThreadStats threadStats=new ThreadStats(utilizationPercentage,runCount,waitCount);
  start=now;
  totalTime=0;
  totalWait=0;
  return threadStats;
}","public ThreadStats publish(){
  long now=System.nanoTime();
  totalTime+=(now - start);
  long totalRun=totalTime - totalWait;
  int utilizationPercentage=(totalTime <= 0 || runCount <= 0) ? 0 : (int)((totalRun * 100L) / totalTime);
  ThreadStats threadStats=new ThreadStats(utilizationPercentage,runCount,waitCount);
  start=now;
  totalTime=0;
  totalWait=0;
  return threadStats;
}",0.945054945054945
50108,"public void handleMap(final org.w3c.dom.Node node) throws Exception {
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getTextContent(attName);
  final MapConfig mapConfig=new MapConfig();
  mapConfig.setName(name);
  for (  org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {
    final String nodeName=cleanNodeName(n.getNodeName());
    final String value=getTextContent(n).trim();
    if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setBackupCount(getIntegerValue(""String_Node_Str"",value,MapConfig.DEFAULT_BACKUP_COUNT));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setEvictionPolicy(value);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setMaxSize(getIntegerValue(""String_Node_Str"",value,MapConfig.DEFAULT_MAX_SIZE));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setEvictionPercentage(getIntegerValue(""String_Node_Str"",value,MapConfig.DEFAULT_EVICTION_PERCENTAGE));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setEvictionDelaySeconds(getIntegerValue(""String_Node_Str"",value,MapConfig.DEFAULT_EVICTION_DELAY_SECONDS));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setTimeToLiveSeconds(getIntegerValue(""String_Node_Str"",value,MapConfig.DEFAULT_TTL_SECONDS));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setMaxIdleSeconds(getIntegerValue(""String_Node_Str"",value,MapConfig.DEFAULT_MAX_IDLE_SECONDS));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      MapStoreConfig mapStoreConfig=createMapStoreConfig(n);
      mapConfig.setMapStoreConfig(mapStoreConfig);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleViaReflection(n,mapConfig,new NearCacheConfig());
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setMergePolicy(value);
    }
  }
  this.config.getMapConfigs().put(name,mapConfig);
}","public void handleMap(final org.w3c.dom.Node node) throws Exception {
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getTextContent(attName);
  final MapConfig mapConfig=new MapConfig();
  mapConfig.setName(name);
  for (  org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {
    final String nodeName=cleanNodeName(n.getNodeName());
    final String value=getTextContent(n).trim();
    if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setBackupCount(getIntegerValue(""String_Node_Str"",value,MapConfig.DEFAULT_BACKUP_COUNT));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setEvictionPolicy(value);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setMaxSize(getIntegerValue(""String_Node_Str"",value,MapConfig.DEFAULT_MAX_SIZE));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setEvictionPercentage(getIntegerValue(""String_Node_Str"",value,MapConfig.DEFAULT_EVICTION_PERCENTAGE));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setEvictionDelaySeconds(getIntegerValue(""String_Node_Str"",value,MapConfig.DEFAULT_EVICTION_DELAY_SECONDS));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setTimeToLiveSeconds(getIntegerValue(""String_Node_Str"",value,MapConfig.DEFAULT_TTL_SECONDS));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setMaxIdleSeconds(getIntegerValue(""String_Node_Str"",value,MapConfig.DEFAULT_MAX_IDLE_SECONDS));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      MapStoreConfig mapStoreConfig=createMapStoreConfig(n);
      mapConfig.setMapStoreConfig(mapStoreConfig);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleViaReflection(n,mapConfig,new NearCacheConfig());
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      mapConfig.setMergePolicy(value);
    }
  }
  this.config.addMapConfig(mapConfig);
}",0.9949773982923156
50109,"public void handleQueue(final org.w3c.dom.Node node){
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getTextContent(attName);
  final QueueConfig qConfig=new QueueConfig();
  qConfig.setName(name);
  for (  org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {
    final String nodeName=cleanNodeName(n.getNodeName());
    final String value=getTextContent(n).trim();
    if (""String_Node_Str"".equals(nodeName)) {
      qConfig.setMaxSizePerJVM(getIntegerValue(""String_Node_Str"",value,QueueConfig.DEFAULT_MAX_SIZE_PER_JVM));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      qConfig.setTimeToLiveSeconds(getIntegerValue(""String_Node_Str"",value,QueueConfig.DEFAULT_TTL_SECONDS));
    }
  }
  this.config.getQConfigs().put(name,qConfig);
}","public void handleQueue(final org.w3c.dom.Node node){
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getTextContent(attName);
  final QueueConfig qConfig=new QueueConfig();
  qConfig.setName(name);
  for (  org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {
    final String nodeName=cleanNodeName(n.getNodeName());
    final String value=getTextContent(n).trim();
    if (""String_Node_Str"".equals(nodeName)) {
      qConfig.setMaxSizePerJVM(getIntegerValue(""String_Node_Str"",value,QueueConfig.DEFAULT_MAX_SIZE_PER_JVM));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      qConfig.setTimeToLiveSeconds(getIntegerValue(""String_Node_Str"",value,QueueConfig.DEFAULT_TTL_SECONDS));
    }
  }
  this.config.addQueueConfig(qConfig);
}",0.9777227722772276
50110,"public void handleTopic(final org.w3c.dom.Node node){
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getTextContent(attName);
  final TopicConfig tConfig=new TopicConfig();
  tConfig.setName(name);
  for (  org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {
    final String value=getTextContent(n).trim();
    if (cleanNodeName(n.getNodeName()).equals(""String_Node_Str"")) {
      tConfig.setGlobalOrderingEnabled(checkTrue(value));
    }
  }
  config.getTopicConfigs().put(name,tConfig);
}","public void handleTopic(final org.w3c.dom.Node node){
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getTextContent(attName);
  final TopicConfig tConfig=new TopicConfig();
  tConfig.setName(name);
  for (  org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {
    final String value=getTextContent(n).trim();
    if (cleanNodeName(n.getNodeName()).equals(""String_Node_Str"")) {
      tConfig.setGlobalOrderingEnabled(checkTrue(value));
    }
  }
  config.addTopicConfig(tConfig);
}",0.9817518248175182
50111,"final void handleBackup(Packet packet){
  try {
    String name=packet.name;
    int blockId=packet.blockId;
    Q q=getQ(name);
    if (packet.operation == ClusterOperation.BLOCKING_QUEUE_BACKUP_ADD) {
      Data data=packet.getValueData();
      q.doBackup(true,data,blockId,(int)packet.longValue);
    }
 else     if (packet.operation == ClusterOperation.BLOCKING_QUEUE_BACKUP_REMOVE) {
      q.doBackup(false,null,blockId,(int)packet.longValue);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    releasePacket(packet);
  }
}","final void handleBackup(Packet packet){
  try {
    String name=packet.name;
    int blockId=packet.blockId;
    Q q=getQ(name);
    if (packet.operation == ClusterOperation.BLOCKING_QUEUE_BACKUP_ADD) {
      Data data=packet.getValueData();
      q.doBackup(true,data,blockId,(int)packet.longValue);
    }
 else     if (packet.operation == ClusterOperation.BLOCKING_QUEUE_BACKUP_REMOVE) {
      q.doBackup(false,null,blockId,(int)packet.longValue);
    }
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + packet.longValue);
    e.printStackTrace();
  }
 finally {
    releasePacket(packet);
  }
}",0.935374149659864
50112,"boolean sendBackup(boolean add,Address caller,Data data,int blockId,int addIndex){
  if (zeroBackup)   return true;
  if (addIndex == -1)   throw new RuntimeException(""String_Node_Str"");
  if (lsMembers.size() > 1) {
    MemberImpl memberBackup=getNextMemberAfter(thisAddress,true,1);
    if (memberBackup == null) {
      return true;
    }
    ClusterOperation operation=ClusterOperation.BLOCKING_QUEUE_BACKUP_REMOVE;
    if (add) {
      operation=ClusterOperation.BLOCKING_QUEUE_BACKUP_ADD;
    }
    Packet packet=obtainPacket(name,null,data,operation,0);
    packet.blockId=blockId;
    packet.longValue=addIndex;
    boolean sent=send(packet,memberBackup.getAddress());
    if (!sent) {
      releasePacket(packet);
    }
    return sent;
  }
 else {
    return true;
  }
}","boolean sendBackup(boolean add,Address caller,Data data,int blockId,int addIndex){
  if (zeroBackup)   return true;
  if (addIndex == -1)   throw new RuntimeException(""String_Node_Str"");
  if (lsMembers.size() > 1) {
    MemberImpl memberBackup=getNextMemberAfter(thisAddress,true,1);
    if (memberBackup == null) {
      return true;
    }
    ClusterOperation operation=ClusterOperation.BLOCKING_QUEUE_BACKUP_REMOVE;
    if (add) {
      operation=ClusterOperation.BLOCKING_QUEUE_BACKUP_ADD;
    }
    Packet packet=obtainPacket(name,null,data,operation,0);
    packet.blockId=blockId;
    if (addIndex >= 1000) {
      throw new RuntimeException(""String_Node_Str"" + addIndex);
    }
    packet.longValue=addIndex;
    boolean sent=send(packet,memberBackup.getAddress());
    if (!sent) {
      releasePacket(packet);
    }
    return sent;
  }
 else {
    return true;
  }
}",0.9408926417370326
50113,"boolean evict(Request req){
  Record record=getRecord(req.key);
  long now=System.currentTimeMillis();
  if (record != null && record.isActive() && record.valueCount() > 0) {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_EVICTED,record.getKey(),null,record.getValue(),record.getListeners(),req.caller);
    record.incrementVersion();
    markAsRemoved(record);
    req.clearForResponse();
    req.version=record.getVersion();
    req.longValue=record.getCopyCount();
    lastEvictionTime=now;
    return true;
  }
  return false;
}","boolean evict(Request req){
  Record record=getRecord(req.key);
  long now=System.currentTimeMillis();
  if (record != null && record.isActive() && record.valueCount() > 0) {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_EVICTED,record.getKey(),null,record.getValue(),record.getListeners(),req.caller);
    record.incrementVersion();
    markAsRemoved(record);
    record.setDirty(false);
    req.clearForResponse();
    req.version=record.getVersion();
    req.longValue=record.getCopyCount();
    lastEvictionTime=now;
    return true;
  }
  return false;
}",0.976897689768977
50114,"@Test public void testRun() throws Exception {
  final AtomicInteger counter=new AtomicInteger(0);
  final ClientRunnable clientRunnable=new ClientRunnable(){
    @Override protected void customRun() throws InterruptedException {
      counter.incrementAndGet();
    }
  }
;
  final CountDownLatch latch=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      try {
        Thread.sleep(50);
        clientRunnable.running=false;
synchronized (clientRunnable.monitor) {
          clientRunnable.monitor.wait();
        }
        latch.countDown();
      }
 catch (      InterruptedException e) {
      }
    }
  }
).start();
  clientRunnable.run();
  assertTrue(counter.get() > 1);
  assertTrue(""String_Node_Str"",latch.await(25,TimeUnit.SECONDS));
}","@Test public void testRun() throws Exception {
  final AtomicInteger counter=new AtomicInteger(0);
  final ClientRunnable clientRunnable=new ClientRunnable(){
    @Override protected void customRun() throws InterruptedException {
      counter.incrementAndGet();
    }
  }
;
  final CountDownLatch latch=new CountDownLatch(1);
  final CountDownLatch waitLatch=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      try {
        waitLatch.countDown();
        Thread.sleep(100);
        clientRunnable.running=false;
synchronized (clientRunnable.monitor) {
          clientRunnable.monitor.wait();
        }
        latch.countDown();
      }
 catch (      InterruptedException e) {
      }
    }
  }
).start();
  clientRunnable.run();
  waitLatch.countDown();
  assertTrue(counter.get() > 1);
  assertTrue(""String_Node_Str"",latch.await(25,TimeUnit.SECONDS));
}",0.9307645996387718
50115,"public FactoryImpl(String name,Config config){
  this.name=name;
  node=new Node(this,config);
  globalProxies=new MProxyImpl(Prefix.MAP + ""String_Node_Str"",this);
  logger=node.getLogger(FactoryImpl.class.getName());
  lifecycleService=new LifecycleServiceImpl(FactoryImpl.this);
  transactionFactory=new TransactionFactory(this);
  hazelcastInstanceProxy=new HazelcastInstanceProxy(this);
  locksMapProxy=new MProxyImpl(Prefix.MAP + ""String_Node_Str"",this);
  idGeneratorMapProxy=new MProxyImpl(Prefix.MAP + ""String_Node_Str"",this);
  memberStatsMultimapProxy=new MultiMapProxy(Prefix.MULTIMAP + MemberStatePublisher.STATS_MULTIMAP_NAME,this);
  memberStatsTopicProxy=new TopicProxyImpl(Prefix.TOPIC + MemberStatePublisher.STATS_TOPIC_NAME,this);
  lifecycleService.fireLifecycleEvent(STARTING);
  node.start();
  memberStatePublisher=new MemberStatePublisher(memberStatsTopicProxy,memberStatsMultimapProxy,node);
  globalProxies.addEntryListener(new EntryListener(){
    public void entryAdded(    EntryEvent event){
      final ProxyKey proxyKey=(ProxyKey)event.getKey();
      if (!proxies.containsKey(proxyKey)) {
        logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
        node.clusterService.enqueueAndReturn(new Processable(){
          public void process(){
            createProxy(proxyKey);
          }
        }
);
      }
    }
    public void entryRemoved(    EntryEvent event){
      final ProxyKey proxyKey=(ProxyKey)event.getKey();
      if (proxies.containsKey(proxyKey)) {
        logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
        node.clusterService.enqueueAndReturn(new Processable(){
          public void process(){
            destroyProxy(proxyKey);
          }
        }
);
      }
    }
    public void entryUpdated(    EntryEvent event){
      logger.log(Level.FINEST,""String_Node_Str"" + event.getKey());
    }
    public void entryEvicted(    EntryEvent event){
      logger.log(Level.FINEST,""String_Node_Str"" + event.getKey());
    }
  }
,false);
  if (node.getClusterImpl().getMembers().size() > 1) {
    Set<ProxyKey> proxyKeys=globalProxies.allKeys();
    for (    final ProxyKey proxyKey : proxyKeys) {
      if (!proxies.containsKey(proxyKey)) {
        node.clusterService.enqueueAndReturn(new Processable(){
          public void process(){
            createProxy(proxyKey);
          }
        }
);
      }
    }
  }
  managementService=new ManagementService(this);
  managementService.register();
}","public FactoryImpl(String name,Config config){
  this.name=name;
  node=new Node(this,config);
  globalProxies=new MProxyImpl(Prefix.MAP + ""String_Node_Str"",this);
  logger=node.getLogger(FactoryImpl.class.getName());
  lifecycleService=new LifecycleServiceImpl(FactoryImpl.this);
  transactionFactory=new TransactionFactory(this);
  hazelcastInstanceProxy=new HazelcastInstanceProxy(this);
  locksMapProxy=new MProxyImpl(Prefix.MAP + ""String_Node_Str"",this);
  idGeneratorMapProxy=new MProxyImpl(Prefix.MAP + ""String_Node_Str"",this);
  memberStatsMultimapProxy=new MultiMapProxy(Prefix.MULTIMAP + MemberStatePublisher.STATS_MULTIMAP_NAME,this);
  memberStatsTopicProxy=new TopicProxyImpl(Prefix.TOPIC + MemberStatePublisher.STATS_TOPIC_NAME,this);
  lifecycleService.fireLifecycleEvent(STARTING);
  node.start();
  memberStatePublisher=new MemberStatePublisher(memberStatsTopicProxy,memberStatsMultimapProxy,node);
  globalProxies.addEntryListener(new EntryListener(){
    public void entryAdded(    EntryEvent event){
      if (node.localMember.equals(event.getMember())) {
        return;
      }
      final ProxyKey proxyKey=(ProxyKey)event.getKey();
      if (!proxies.containsKey(proxyKey)) {
        logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
        node.clusterService.enqueueAndReturn(new Processable(){
          public void process(){
            createProxy(proxyKey);
          }
        }
);
      }
    }
    public void entryRemoved(    EntryEvent event){
      if (node.localMember.equals(event.getMember())) {
        return;
      }
      final ProxyKey proxyKey=(ProxyKey)event.getKey();
      logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
      node.clusterService.enqueueAndReturn(new Processable(){
        public void process(){
          destroyProxy(proxyKey);
        }
      }
);
    }
    public void entryUpdated(    EntryEvent event){
      logger.log(Level.FINEST,""String_Node_Str"" + event.getKey());
    }
    public void entryEvicted(    EntryEvent event){
      logger.log(Level.FINEST,""String_Node_Str"" + event.getKey());
    }
  }
,false);
  if (node.getClusterImpl().getMembers().size() > 1) {
    Set<ProxyKey> proxyKeys=globalProxies.allKeys();
    for (    final ProxyKey proxyKey : proxyKeys) {
      if (!proxies.containsKey(proxyKey)) {
        node.clusterService.enqueueAndReturn(new Processable(){
          public void process(){
            createProxy(proxyKey);
          }
        }
);
      }
    }
  }
  managementService=new ManagementService(this);
  managementService.register();
}",0.9556218905472637
50116,"public void entryRemoved(EntryEvent event){
  final ProxyKey proxyKey=(ProxyKey)event.getKey();
  if (proxies.containsKey(proxyKey)) {
    logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
    node.clusterService.enqueueAndReturn(new Processable(){
      public void process(){
        destroyProxy(proxyKey);
      }
    }
);
  }
}","public void entryRemoved(EntryEvent event){
  if (node.localMember.equals(event.getMember())) {
    return;
  }
  final ProxyKey proxyKey=(ProxyKey)event.getKey();
  logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
  node.clusterService.enqueueAndReturn(new Processable(){
    public void process(){
      destroyProxy(proxyKey);
    }
  }
);
}",0.8151382823871907
50117,"public void entryAdded(EntryEvent event){
  final ProxyKey proxyKey=(ProxyKey)event.getKey();
  if (!proxies.containsKey(proxyKey)) {
    logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
    node.clusterService.enqueueAndReturn(new Processable(){
      public void process(){
        createProxy(proxyKey);
      }
    }
);
  }
}","public void entryAdded(EntryEvent event){
  if (node.localMember.equals(event.getMember())) {
    return;
  }
  final ProxyKey proxyKey=(ProxyKey)event.getKey();
  if (!proxies.containsKey(proxyKey)) {
    logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
    node.clusterService.enqueueAndReturn(new Processable(){
      public void process(){
        createProxy(proxyKey);
      }
    }
);
  }
}",0.907859078590786
50118,"private Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout,long ttl){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=toObject(oldValue);
      }
      txn.attachPutOp(name,key,value,0,ttl,(oldObject == null));
      return threadContext.isClient() ? oldValue : oldObject;
    }
 else {
      if (operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
        Object existingValue=txn.get(name,key);
        if (existingValue != null) {
          return existingValue;
        }
      }
      return txn.attachPutOp(name,key,value,false);
    }
  }
 else {
    setLocal(operation,name,key,value,timeout,ttl);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    if (operation == CONCURRENT_MAP_TRY_PUT) {
      request.setBooleanRequest();
      doOp();
      Boolean returnObject=getResultAsBoolean();
      if (returnObject) {
        backup(CONCURRENT_MAP_BACKUP_PUT);
      }
      return returnObject;
    }
 else {
      request.setObjectRequest();
      doOp();
      Object returnObject=getResultAsObject();
      if (operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL && returnObject == null) {
        return null;
      }
      if (returnObject instanceof AddressAwareException) {
        rethrowException(operation,(AddressAwareException)returnObject);
      }
      request.longValue=Long.MIN_VALUE;
      backup(CONCURRENT_MAP_BACKUP_PUT);
      return returnObject;
    }
  }
}","private Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout,long ttl){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=toObject(oldValue);
      }
      if (operation == ClusterOperation.CONCURRENT_MAP_PUT_IF_ABSENT && oldObject != null) {
        txn.attachPutOp(name,key,oldObject,0,ttl,false);
      }
 else {
        txn.attachPutOp(name,key,value,0,ttl,(oldObject == null));
      }
      return threadContext.isClient() ? oldValue : oldObject;
    }
 else {
      if (operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
        Object existingValue=txn.get(name,key);
        if (existingValue != null) {
          return existingValue;
        }
      }
      return txn.attachPutOp(name,key,value,false);
    }
  }
 else {
    setLocal(operation,name,key,value,timeout,ttl);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    if (operation == CONCURRENT_MAP_TRY_PUT) {
      request.setBooleanRequest();
      doOp();
      Boolean returnObject=getResultAsBoolean();
      if (returnObject) {
        backup(CONCURRENT_MAP_BACKUP_PUT);
      }
      return returnObject;
    }
 else {
      request.setObjectRequest();
      doOp();
      Object returnObject=getResultAsObject();
      if (operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL && returnObject == null) {
        return null;
      }
      if (returnObject instanceof AddressAwareException) {
        rethrowException(operation,(AddressAwareException)returnObject);
      }
      request.longValue=Long.MIN_VALUE;
      backup(CONCURRENT_MAP_BACKUP_PUT);
      return returnObject;
    }
  }
}",0.4928324270884824
50119,"public int getDistanceFrom(Member member){
  if (member.localMember()) {
    return 0;
  }
  Integer distance=distances.get(member);
  if (distance != null) {
    return distance;
  }
  Set<Member> currentMembers=members.get();
  int size=currentMembers.size();
  Member localMember=getLocalMember();
  int index=0;
  int toIndex=getIndexOf(localMember,currentMembers);
  for (  Member m : currentMembers) {
    if (!m.equals(localMember)) {
      distance=((toIndex - index) + size) % size;
      distances.put(m,distance);
    }
    index++;
  }
  Integer d=distances.get(member);
  return (d == null) ? -1 : d;
}","public int getDistanceFrom(Member member){
  if (member.localMember()) {
    return 0;
  }
  Integer distance=distances.get(member);
  if (distance != null) {
    return distance;
  }
  calculateDistances();
  Integer d=distances.get(member);
  return (d == null) ? -1 : d;
}",0.5707865168539326
50120,"public void reset(){
  clusterMembers.clear();
  distances.clear();
  members.set(null);
  this.setMembers(Arrays.asList((MemberImpl)localMember.get()));
}","public void reset(){
  clusterMembers.clear();
  distancesWithoutSuper.clear();
  distances.clear();
  members.set(null);
  this.setMembers(Arrays.asList((MemberImpl)localMember.get()));
}",0.9037900874635568
50121,"public void setMembers(List<MemberImpl> lsMembers){
  Set<Member> setNew=new LinkedHashSet<Member>(lsMembers.size());
  ArrayList<Runnable> notifications=new ArrayList<Runnable>();
  for (  MemberImpl member : lsMembers) {
    if (member != null) {
      final MemberImpl dummy=new MemberImpl(member.getAddress(),member.localMember(),member.getNodeType());
      Member clusterMember=clusterMembers.get(dummy);
      if (clusterMember == null) {
        clusterMember=dummy;
        if (listeners.size() > 0) {
          notifications.add(new Runnable(){
            public void run(){
              MembershipEvent membershipEvent=new MembershipEvent(ClusterImpl.this,dummy,MembershipEvent.MEMBER_ADDED);
              for (              MembershipListener listener : listeners) {
                listener.memberAdded(membershipEvent);
              }
            }
          }
);
        }
      }
      if (clusterMember.localMember()) {
        localMember.set(clusterMember);
      }
      setNew.add(clusterMember);
    }
  }
  if (listeners.size() > 0) {
    Set<Member> it=clusterMembers.keySet();
    for (    final Member member : it) {
      if (!setNew.contains(member)) {
        notifications.add(new Runnable(){
          public void run(){
            MembershipEvent membershipEvent=new MembershipEvent(ClusterImpl.this,member,MembershipEvent.MEMBER_REMOVED);
            for (            MembershipListener listener : listeners) {
              listener.memberRemoved(membershipEvent);
            }
          }
        }
);
      }
    }
  }
  clusterMembers.clear();
  for (  Member member : setNew) {
    clusterMembers.put(member,member);
  }
  members.set(Collections.unmodifiableSet(setNew));
  distances.clear();
  for (  Runnable notification : notifications) {
    node.executorManager.getEventExecutorService().execute(notification);
  }
}","public void setMembers(List<MemberImpl> lsMembers){
  Set<Member> setNew=new LinkedHashSet<Member>(lsMembers.size());
  ArrayList<Runnable> notifications=new ArrayList<Runnable>();
  for (  MemberImpl member : lsMembers) {
    if (member != null) {
      final MemberImpl dummy=new MemberImpl(member.getAddress(),member.localMember(),member.getNodeType());
      Member clusterMember=clusterMembers.get(dummy);
      if (clusterMember == null) {
        clusterMember=dummy;
        if (listeners.size() > 0) {
          notifications.add(new Runnable(){
            public void run(){
              MembershipEvent membershipEvent=new MembershipEvent(ClusterImpl.this,dummy,MembershipEvent.MEMBER_ADDED);
              for (              MembershipListener listener : listeners) {
                listener.memberAdded(membershipEvent);
              }
            }
          }
);
        }
      }
      if (clusterMember.localMember()) {
        localMember.set(clusterMember);
      }
      setNew.add(clusterMember);
    }
  }
  if (listeners.size() > 0) {
    Set<Member> it=clusterMembers.keySet();
    for (    final Member member : it) {
      if (!setNew.contains(member)) {
        notifications.add(new Runnable(){
          public void run(){
            MembershipEvent membershipEvent=new MembershipEvent(ClusterImpl.this,member,MembershipEvent.MEMBER_REMOVED);
            for (            MembershipListener listener : listeners) {
              listener.memberRemoved(membershipEvent);
            }
          }
        }
);
      }
    }
  }
  clusterMembers.clear();
  for (  Member member : setNew) {
    clusterMembers.put(member,member);
  }
  members.set(Collections.unmodifiableSet(setNew));
  distances.clear();
  distancesWithoutSuper.clear();
  for (  Runnable notification : notifications) {
    node.executorManager.getEventExecutorService().execute(notification);
  }
}",0.991239713299708
50122,"protected MemberImpl getNextMemberAfter(final List<MemberImpl> lsMembers,final Address address,final boolean skipSuperClient,final int distance){
  final int size=lsMembers.size();
  if (size <= 1)   return null;
  int indexOfMember=-1;
  for (int i=0; i < size; i++) {
    final MemberImpl member=lsMembers.get(i);
    if (member.getAddress().equals(address)) {
      indexOfMember=i;
    }
  }
  if (indexOfMember == -1)   return null;
  int foundDistance=0;
  for (int i=1; i < size; i++) {
    final MemberImpl member=lsMembers.get((indexOfMember + i) % size);
    if (!(skipSuperClient && member.isSuperClient())) {
      foundDistance++;
    }
    if (foundDistance == distance)     return member;
  }
  return null;
}","protected MemberImpl getNextMemberAfter(final List<MemberImpl> lsMembers,final Address address,final boolean skipSuperClient,final int distance){
  final int size=lsMembers.size();
  if (size <= 1)   return null;
  int indexOfMember=-1;
  for (int i=0; i < size; i++) {
    final MemberImpl member=lsMembers.get(i);
    if (member.getAddress().equals(address)) {
      indexOfMember=i;
    }
  }
  if (indexOfMember == -1)   return null;
  int foundDistance=0;
  for (int i=indexOfMember; i < size + indexOfMember; i++) {
    final MemberImpl member=lsMembers.get((1 + i) % size);
    if (!(skipSuperClient && member.isSuperClient())) {
      foundDistance++;
    }
    if (foundDistance == distance) {
      return member;
    }
  }
  return null;
}",0.9199457259158752
50123,"LocalMapStatsImpl getLocalMapStats(){
  LocalMapStatsImpl localMapStats=new LocalMapStatsImpl();
  long now=System.currentTimeMillis();
  int ownedEntryCount=0;
  int backupEntryCount=0;
  int markedAsRemovedEntryCount=0;
  int ownedEntryMemoryCost=0;
  int backupEntryMemoryCost=0;
  int markedAsRemovedMemoryCost=0;
  int hits=0;
  int lockedEntryCount=0;
  int lockWaitCount=0;
  ClusterImpl clusterImpl=node.getClusterImpl();
  final Collection<Record> records=mapRecords.values();
  final PartitionServiceImpl partitionService=concurrentMapManager.partitionManager.partitionServiceImpl;
  for (  Record record : records) {
    if (!record.isActive() || !record.isValid(now)) {
      markedAsRemovedEntryCount++;
      markedAsRemovedMemoryCost+=record.getCost();
    }
 else {
      PartitionServiceImpl.PartitionProxy partition=partitionService.getPartition(record.getBlockId());
      Member owner=partition.getOwner();
      if (owner != null && !partition.isMigrating()) {
        boolean owned=owner.localMember();
        if (owned) {
          ownedEntryCount+=record.valueCount();
          ownedEntryMemoryCost+=record.getCost();
          localMapStats.setLastAccessTime(record.getLastAccessTime());
          localMapStats.setLastUpdateTime(record.getLastUpdateTime());
          hits+=record.getHits();
          if (record.isLocked()) {
            lockedEntryCount++;
            lockWaitCount+=record.getScheduledActionCount();
          }
        }
 else {
          Member ownerEventual=partition.getEventualOwner();
          boolean backup=false;
          if (ownerEventual != null && !owner.localMember()) {
            int distance=node.getClusterImpl().getDistanceFrom(ownerEventual);
            backup=(distance != -1 && distance <= getBackupCount());
          }
          if (backup && !shouldPurgeRecord(record,now)) {
            backupEntryCount+=record.valueCount();
            backupEntryMemoryCost+=record.getCost();
          }
 else {
            markedAsRemovedEntryCount++;
            markedAsRemovedMemoryCost+=record.getCost();
          }
        }
      }
    }
  }
  localMapStats.setMarkedAsRemovedEntryCount(zeroOrPositive(markedAsRemovedEntryCount));
  localMapStats.setMarkedAsRemovedMemoryCost(zeroOrPositive(markedAsRemovedMemoryCost));
  localMapStats.setLockWaitCount(zeroOrPositive(lockWaitCount));
  localMapStats.setLockedEntryCount(zeroOrPositive(lockedEntryCount));
  localMapStats.setHits(zeroOrPositive(hits));
  localMapStats.setOwnedEntryCount(zeroOrPositive(ownedEntryCount));
  localMapStats.setBackupEntryCount(zeroOrPositive(backupEntryCount));
  localMapStats.setOwnedEntryMemoryCost(zeroOrPositive(ownedEntryMemoryCost));
  localMapStats.setBackupEntryMemoryCost(zeroOrPositive(backupEntryMemoryCost));
  localMapStats.setLastEvictionTime(zeroOrPositive(clusterImpl.getClusterTimeFor(lastEvictionTime)));
  localMapStats.setCreationTime(zeroOrPositive(clusterImpl.getClusterTimeFor(creationTime)));
  return localMapStats;
}","LocalMapStatsImpl getLocalMapStats(){
  LocalMapStatsImpl localMapStats=new LocalMapStatsImpl();
  long now=System.currentTimeMillis();
  int ownedEntryCount=0;
  int backupEntryCount=0;
  int markedAsRemovedEntryCount=0;
  int ownedEntryMemoryCost=0;
  int backupEntryMemoryCost=0;
  int markedAsRemovedMemoryCost=0;
  int hits=0;
  int lockedEntryCount=0;
  int lockWaitCount=0;
  ClusterImpl clusterImpl=node.getClusterImpl();
  final Collection<Record> records=mapRecords.values();
  final PartitionServiceImpl partitionService=concurrentMapManager.partitionManager.partitionServiceImpl;
  for (  Record record : records) {
    if (!record.isActive() || !record.isValid(now)) {
      markedAsRemovedEntryCount++;
      markedAsRemovedMemoryCost+=record.getCost();
    }
 else {
      PartitionServiceImpl.PartitionProxy partition=partitionService.getPartition(record.getBlockId());
      Member owner=partition.getOwner();
      if (owner != null && !partition.isMigrating()) {
        boolean owned=owner.localMember();
        if (owned) {
          ownedEntryCount+=record.valueCount();
          ownedEntryMemoryCost+=record.getCost();
          localMapStats.setLastAccessTime(record.getLastAccessTime());
          localMapStats.setLastUpdateTime(record.getLastUpdateTime());
          hits+=record.getHits();
          if (record.isLocked()) {
            lockedEntryCount++;
            lockWaitCount+=record.getScheduledActionCount();
          }
        }
 else {
          Member ownerEventual=partition.getEventualOwner();
          boolean backup=false;
          if (ownerEventual != null && !owner.localMember()) {
            int distance=node.getClusterImpl().getDistanceFrom(ownerEventual,true);
            backup=(distance != -1 && distance <= getBackupCount());
          }
          if (backup && !shouldPurgeRecord(record,now)) {
            backupEntryCount+=record.valueCount();
            backupEntryMemoryCost+=record.getCost();
          }
 else {
            markedAsRemovedEntryCount++;
            markedAsRemovedMemoryCost+=record.getCost();
          }
        }
      }
    }
  }
  localMapStats.setMarkedAsRemovedEntryCount(zeroOrPositive(markedAsRemovedEntryCount));
  localMapStats.setMarkedAsRemovedMemoryCost(zeroOrPositive(markedAsRemovedMemoryCost));
  localMapStats.setLockWaitCount(zeroOrPositive(lockWaitCount));
  localMapStats.setLockedEntryCount(zeroOrPositive(lockedEntryCount));
  localMapStats.setHits(zeroOrPositive(hits));
  localMapStats.setOwnedEntryCount(zeroOrPositive(ownedEntryCount));
  localMapStats.setBackupEntryCount(zeroOrPositive(backupEntryCount));
  localMapStats.setOwnedEntryMemoryCost(zeroOrPositive(ownedEntryMemoryCost));
  localMapStats.setBackupEntryMemoryCost(zeroOrPositive(backupEntryMemoryCost));
  localMapStats.setLastEvictionTime(zeroOrPositive(clusterImpl.getClusterTimeFor(lastEvictionTime)));
  localMapStats.setCreationTime(zeroOrPositive(clusterImpl.getClusterTimeFor(creationTime)));
  return localMapStats;
}",0.9991662497915624
50124,"void startCleanup(boolean forced){
  final long now=System.currentTimeMillis();
  if (locallyOwnedMap != null) {
    locallyOwnedMap.evict(now);
  }
  if (mapNearCache != null) {
    mapNearCache.evict(now,false);
  }
  final Set<Record> recordsDirty=new HashSet<Record>();
  final Set<Record> recordsUnknown=new HashSet<Record>();
  final Set<Record> recordsToPurge=new HashSet<Record>();
  final Set<Record> recordsToEvict=new HashSet<Record>();
  final Set<Record> sortedRecords=new TreeSet<Record>(new ComparatorWrapper(evictionComparator));
  final Collection<Record> records=mapRecords.values();
  final int clusterMemberSize=node.getClusterImpl().getMembers().size();
  final int memberCount=(clusterMemberSize == 0) ? 1 : clusterMemberSize;
  final int maxSizePerJVM=maxSize / memberCount;
  final boolean evictionAware=evictionComparator != null && maxSizePerJVM > 0;
  final PartitionServiceImpl partitionService=concurrentMapManager.partitionManager.partitionServiceImpl;
  int recordsStillOwned=0;
  int backupPurgeCount=0;
  for (  Record record : records) {
    PartitionServiceImpl.PartitionProxy partition=partitionService.getPartition(record.getBlockId());
    Member owner=partition.getOwner();
    if (owner != null && !partition.isMigrating()) {
      boolean owned=owner.localMember();
      if (owned) {
        if (store != null && writeDelayMillis > 0 && record.isDirty()) {
          if (now > record.getWriteTime()) {
            recordsDirty.add(record);
            record.setDirty(false);
          }
        }
 else         if (shouldPurgeRecord(record,now)) {
          recordsToPurge.add(record);
        }
 else         if (record.isActive() && !record.isValid(now)) {
          recordsToEvict.add(record);
        }
 else         if (evictionAware && record.isActive() && record.isEvictable()) {
          sortedRecords.add(record);
          recordsStillOwned++;
        }
 else {
          recordsStillOwned++;
        }
      }
 else {
        Member ownerEventual=partition.getEventualOwner();
        boolean backup=false;
        if (ownerEventual != null && owner != null && !owner.localMember()) {
          int distance=node.getClusterImpl().getDistanceFrom(ownerEventual);
          backup=(distance != -1 && distance <= getBackupCount());
        }
        if (backup) {
          if (shouldPurgeRecord(record,now)) {
            recordsToPurge.add(record);
            backupPurgeCount++;
          }
        }
 else {
          recordsUnknown.add(record);
        }
      }
    }
  }
  if (evictionAware && ((forced) ? maxSizePerJVM <= recordsStillOwned : maxSizePerJVM < recordsStillOwned)) {
    int numberOfRecordsToEvict=(int)(recordsStillOwned * evictionRate);
    int evictedCount=0;
    for (    Record record : sortedRecords) {
      if (record.isActive() && record.isEvictable()) {
        recordsToEvict.add(record);
        if (++evictedCount >= numberOfRecordsToEvict) {
          break;
        }
      }
    }
  }
  Level levelLog=(concurrentMapManager.LOG_STATE) ? Level.INFO : Level.FINEST;
  logger.log(levelLog,name + ""String_Node_Str"" + ""String_Node_Str""+ recordsDirty.size()+ ""String_Node_Str""+ recordsToPurge.size()+ ""String_Node_Str""+ recordsToEvict.size()+ ""String_Node_Str""+ recordsUnknown.size()+ ""String_Node_Str""+ recordsStillOwned+ ""String_Node_Str""+ backupPurgeCount);
  executeStoreUpdate(recordsDirty);
  executeEviction(recordsToEvict);
  executePurge(recordsToPurge);
  executePurgeUnknowns(recordsUnknown);
}","void startCleanup(boolean forced){
  final long now=System.currentTimeMillis();
  if (locallyOwnedMap != null) {
    locallyOwnedMap.evict(now);
  }
  if (mapNearCache != null) {
    mapNearCache.evict(now,false);
  }
  final Set<Record> recordsDirty=new HashSet<Record>();
  final Set<Record> recordsUnknown=new HashSet<Record>();
  final Set<Record> recordsToPurge=new HashSet<Record>();
  final Set<Record> recordsToEvict=new HashSet<Record>();
  final Set<Record> sortedRecords=new TreeSet<Record>(new ComparatorWrapper(evictionComparator));
  final Collection<Record> records=mapRecords.values();
  final int clusterMemberSize=node.getClusterImpl().getMembers().size();
  final int memberCount=(clusterMemberSize == 0) ? 1 : clusterMemberSize;
  final int maxSizePerJVM=maxSize / memberCount;
  final boolean evictionAware=evictionComparator != null && maxSizePerJVM > 0;
  final PartitionServiceImpl partitionService=concurrentMapManager.partitionManager.partitionServiceImpl;
  int recordsStillOwned=0;
  int backupPurgeCount=0;
  for (  Record record : records) {
    PartitionServiceImpl.PartitionProxy partition=partitionService.getPartition(record.getBlockId());
    Member owner=partition.getOwner();
    if (owner != null && !partition.isMigrating()) {
      boolean owned=owner.localMember();
      if (owned) {
        if (store != null && writeDelayMillis > 0 && record.isDirty()) {
          if (now > record.getWriteTime()) {
            recordsDirty.add(record);
            record.setDirty(false);
          }
        }
 else         if (shouldPurgeRecord(record,now)) {
          recordsToPurge.add(record);
        }
 else         if (record.isActive() && !record.isValid(now)) {
          recordsToEvict.add(record);
        }
 else         if (evictionAware && record.isActive() && record.isEvictable()) {
          sortedRecords.add(record);
          recordsStillOwned++;
        }
 else {
          recordsStillOwned++;
        }
      }
 else {
        Member ownerEventual=partition.getEventualOwner();
        boolean backup=false;
        if (ownerEventual != null && owner != null && !owner.localMember()) {
          int distance=node.getClusterImpl().getDistanceFrom(ownerEventual,true);
          backup=(distance != -1 && distance <= getBackupCount());
        }
        if (backup) {
          if (shouldPurgeRecord(record,now)) {
            recordsToPurge.add(record);
            backupPurgeCount++;
          }
        }
 else {
          recordsUnknown.add(record);
        }
      }
    }
  }
  if (evictionAware && ((forced) ? maxSizePerJVM <= recordsStillOwned : maxSizePerJVM < recordsStillOwned)) {
    int numberOfRecordsToEvict=(int)(recordsStillOwned * evictionRate);
    int evictedCount=0;
    for (    Record record : sortedRecords) {
      if (record.isActive() && record.isEvictable()) {
        recordsToEvict.add(record);
        if (++evictedCount >= numberOfRecordsToEvict) {
          break;
        }
      }
    }
  }
  Level levelLog=(concurrentMapManager.LOG_STATE) ? Level.INFO : Level.FINEST;
  logger.log(levelLog,name + ""String_Node_Str"" + ""String_Node_Str""+ recordsDirty.size()+ ""String_Node_Str""+ recordsToPurge.size()+ ""String_Node_Str""+ recordsToEvict.size()+ ""String_Node_Str""+ recordsUnknown.size()+ ""String_Node_Str""+ recordsStillOwned+ ""String_Node_Str""+ backupPurgeCount);
  executeStoreUpdate(recordsDirty);
  executeEviction(recordsToEvict);
  executePurge(recordsToPurge);
  executePurgeUnknowns(recordsUnknown);
}",0.9992839753687528
50125,"@Before @After public void init() throws Exception {
  Hazelcast.shutdownAll();
}","@Before @After public void init() throws Exception {
  System.setProperty(GroupProperties.PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  Hazelcast.shutdownAll();
}",0.6506024096385542
50126,"@Test @Ignore public void issue395BackupProblemWithBCount2(){
  Config config=new Config();
  config.getMapConfig(""String_Node_Str"").setBackupCount(2);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  IMap map1=h1.getMap(""String_Node_Str"");
  IMap map2=h2.getMap(""String_Node_Str"");
  for (int i=0; i < 1000; i++) {
    map1.put(i,i);
  }
  assertEquals(map1.getLocalMapStats().getOwnedEntryCount(),map2.getLocalMapStats().getBackupEntryCount());
  assertEquals(map2.getLocalMapStats().getOwnedEntryCount(),map1.getLocalMapStats().getBackupEntryCount());
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  IMap map3=h3.getMap(""String_Node_Str"");
  assertEquals(map1.getLocalMapStats().getOwnedEntryCount() + map3.getLocalMapStats().getOwnedEntryCount(),map2.getLocalMapStats().getBackupEntryCount());
  assertEquals(map2.getLocalMapStats().getOwnedEntryCount() + map3.getLocalMapStats().getOwnedEntryCount(),map1.getLocalMapStats().getBackupEntryCount());
  assertEquals(map1.getLocalMapStats().getOwnedEntryCount() + map2.getLocalMapStats().getOwnedEntryCount(),map3.getLocalMapStats().getBackupEntryCount());
  h1.getLifecycleService().shutdown();
  h2.getLifecycleService().shutdown();
  h3.getLifecycleService().shutdown();
}","@Test @Ignore public void issue395BackupProblemWithBCount2(){
  Config config=new Config();
  config.getMapConfig(""String_Node_Str"").setBackupCount(2);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  IMap map1=h1.getMap(""String_Node_Str"");
  IMap map2=h2.getMap(""String_Node_Str"");
  for (int i=0; i < 1000; i++) {
    map1.put(i,i);
  }
  assertEquals(map1.getLocalMapStats().getOwnedEntryCount(),map2.getLocalMapStats().getBackupEntryCount());
  assertEquals(map2.getLocalMapStats().getOwnedEntryCount(),map1.getLocalMapStats().getBackupEntryCount());
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  IMap map3=h3.getMap(""String_Node_Str"");
  assertEquals(map1.getLocalMapStats().getOwnedEntryCount() + map3.getLocalMapStats().getOwnedEntryCount(),map2.getLocalMapStats().getBackupEntryCount());
  assertEquals(map2.getLocalMapStats().getOwnedEntryCount() + map3.getLocalMapStats().getOwnedEntryCount(),map1.getLocalMapStats().getBackupEntryCount());
  assertEquals(map1.getLocalMapStats().getOwnedEntryCount() + map2.getLocalMapStats().getOwnedEntryCount(),map3.getLocalMapStats().getBackupEntryCount());
}",0.9537000395726156
50127,"@Test(timeout=160000) public void testBackupCount() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  IMap map1=h1.getMap(""String_Node_Str"");
  IMap map2=h2.getMap(""String_Node_Str"");
  for (int i=0; i < 10000; i++) {
    map1.put(i,i);
  }
  assertEquals(map1.getLocalMapStats().getBackupEntryCount(),map2.getLocalMapStats().getOwnedEntryCount());
  assertEquals(map2.getLocalMapStats().getBackupEntryCount(),map1.getLocalMapStats().getOwnedEntryCount());
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(null);
  IMap map3=h3.getMap(""String_Node_Str"");
  sleep(12000);
  assertEquals(map2.getLocalMapStats().getBackupEntryCount(),map1.getLocalMapStats().getOwnedEntryCount());
  assertEquals(map1.getLocalMapStats().getBackupEntryCount(),map3.getLocalMapStats().getOwnedEntryCount());
  assertEquals(map3.getLocalMapStats().getBackupEntryCount(),map2.getLocalMapStats().getOwnedEntryCount());
}","@Test(timeout=160000) public void testBackupCount() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  IMap map1=h1.getMap(""String_Node_Str"");
  IMap map2=h2.getMap(""String_Node_Str"");
  for (int i=0; i < 10000; i++) {
    map1.put(i,i);
  }
  assertEquals(map1.getLocalMapStats().getBackupEntryCount(),map2.getLocalMapStats().getOwnedEntryCount());
  assertEquals(map2.getLocalMapStats().getBackupEntryCount(),map1.getLocalMapStats().getOwnedEntryCount());
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(null);
  IMap map3=h3.getMap(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  h2.getPartitionService().addMigrationListener(new MigrationListener(){
    public void migrationStarted(    MigrationEvent migrationEvent){
    }
    public void migrationCompleted(    MigrationEvent migrationEvent){
      latch.countDown();
    }
  }
);
  latch.await();
  assertEquals(map2.getLocalMapStats().getBackupEntryCount(),map1.getLocalMapStats().getOwnedEntryCount());
  assertEquals(map1.getLocalMapStats().getBackupEntryCount(),map3.getLocalMapStats().getOwnedEntryCount());
  assertEquals(map3.getLocalMapStats().getBackupEntryCount(),map2.getLocalMapStats().getOwnedEntryCount());
}",0.8581375108790252
50128,"public void doBackup(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  if (req.operation == CONCURRENT_MAP_BACKUP_PUT) {
    Record record=toRecord(req);
    markAsActive(record);
    record.setVersion(req.version);
    if (req.indexes != null) {
      if (req.indexTypes == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      if (req.indexes.length != req.indexTypes.length) {
        throw new RuntimeException(""String_Node_Str"");
      }
      record.setIndexes(req.indexes,req.indexTypes);
    }
    if (req.ttl > 0 && req.ttl < Long.MAX_VALUE) {
      record.setExpirationTime(req.ttl);
      ttlPerRecord=true;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (record.isActive()) {
        if (record.getCopyCount() > 0) {
          record.decrementCopyCount();
        }
        markAsRemoved(record);
      }
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_LOCK) {
    Record rec=toRecord(req);
    if (rec.getVersion() == 0) {
      rec.setVersion(req.version);
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_ADD) {
    add(req,true);
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE_MULTI) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (req.value == null) {
        markAsRemoved(record);
      }
 else {
        if (record.containsValue(req.value)) {
          if (record.getMultiValues() != null) {
            Iterator<Data> itValues=record.getMultiValues().iterator();
            while (itValues.hasNext()) {
              Data value=itValues.next();
              if (req.value.equals(value)) {
                itValues.remove();
              }
            }
          }
        }
        if (record.valueCount() == 0) {
          markAsRemoved(record);
        }
      }
    }
  }
 else {
    logger.log(Level.SEVERE,""String_Node_Str"" + req.operation);
  }
}","public void doBackup(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  if (req.operation == CONCURRENT_MAP_BACKUP_PUT) {
    Record record=toRecord(req);
    markAsActive(record);
    record.setVersion(req.version);
    if (req.indexes != null) {
      if (req.indexTypes == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      if (req.indexes.length != req.indexTypes.length) {
        throw new RuntimeException(""String_Node_Str"");
      }
      record.setIndexes(req.indexes,req.indexTypes);
    }
    if (req.ttl > 0 && req.ttl < Long.MAX_VALUE) {
      record.setExpirationTime(req.ttl);
      ttlPerRecord=true;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (record.isActive()) {
        if (record.getCopyCount() > 0) {
          record.decrementCopyCount();
        }
        markAsRemoved(record);
      }
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_LOCK) {
    Record rec=toRecord(req);
    if (rec.getVersion() == 0) {
      rec.setVersion(req.version);
    }
    if (rec.getLockCount() == 0 && rec.valueCount() == 0) {
      markAsRemoved(rec);
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_ADD) {
    add(req,true);
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE_MULTI) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (req.value == null) {
        markAsRemoved(record);
      }
 else {
        if (record.containsValue(req.value)) {
          if (record.getMultiValues() != null) {
            Iterator<Data> itValues=record.getMultiValues().iterator();
            while (itValues.hasNext()) {
              Data value=itValues.next();
              if (req.value.equals(value)) {
                itValues.remove();
              }
            }
          }
        }
        if (record.valueCount() == 0) {
          markAsRemoved(record);
        }
      }
    }
  }
 else {
    logger.log(Level.SEVERE,""String_Node_Str"" + req.operation);
  }
}",0.9779904306220096
50129,"private Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout,long ttl){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=toObject(oldValue);
      }
      txn.attachPutOp(name,key,value,0,ttl,(oldObject == null));
      return threadContext.isClient() ? oldValue : oldObject;
    }
 else {
      if (operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
        Object existingValue=txn.get(name,key);
        if (existingValue != null) {
          return existingValue;
        }
      }
      return txn.attachPutOp(name,key,value,false);
    }
  }
 else {
    setLocal(operation,name,key,value,timeout,ttl);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    if (operation == CONCURRENT_MAP_TRY_PUT) {
      request.setBooleanRequest();
      doOp();
      Boolean returnObject=getResultAsBoolean();
      if (returnObject) {
        backup(CONCURRENT_MAP_BACKUP_PUT);
      }
      return returnObject;
    }
 else {
      request.setObjectRequest();
      doOp();
      Object returnObject=getResultAsObject();
      if (returnObject instanceof AddressAwareException) {
        rethrowException(operation,(AddressAwareException)returnObject);
      }
      request.longValue=Long.MIN_VALUE;
      backup(CONCURRENT_MAP_BACKUP_PUT);
      return returnObject;
    }
  }
}","private Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout,long ttl){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=toObject(oldValue);
      }
      txn.attachPutOp(name,key,value,0,ttl,(oldObject == null));
      return threadContext.isClient() ? oldValue : oldObject;
    }
 else {
      if (operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
        Object existingValue=txn.get(name,key);
        if (existingValue != null) {
          return existingValue;
        }
      }
      return txn.attachPutOp(name,key,value,false);
    }
  }
 else {
    setLocal(operation,name,key,value,timeout,ttl);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    if (operation == CONCURRENT_MAP_TRY_PUT) {
      request.setBooleanRequest();
      doOp();
      Boolean returnObject=getResultAsBoolean();
      if (returnObject) {
        backup(CONCURRENT_MAP_BACKUP_PUT);
      }
      return returnObject;
    }
 else {
      request.setObjectRequest();
      doOp();
      Object returnObject=getResultAsObject();
      if (operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL && returnObject == null) {
        return null;
      }
      if (returnObject instanceof AddressAwareException) {
        rethrowException(operation,(AddressAwareException)returnObject);
      }
      request.longValue=Long.MIN_VALUE;
      backup(CONCURRENT_MAP_BACKUP_PUT);
      return returnObject;
    }
  }
}",0.8727369542066028
50130,"void backupIfNextOrPreviousChanged(boolean add){
  boolean shouldBackup=false;
  if (add) {
    shouldBackup=node.clusterManager.isNextChanged();
  }
 else {
    shouldBackup=node.clusterManager.isNextChanged() || node.clusterManager.isPreviousChanged();
  }
  if (shouldBackup) {
    List<Record> lsOwnedRecords=new ArrayList<Record>(1000);
    Collection<CMap> cmaps=concurrentMapManager.maps.values();
    for (    final CMap cmap : cmaps) {
      for (      Record rec : cmap.mapRecords.values()) {
        if (rec.isActive()) {
          if (rec.getKey() == null || rec.getKey().size() == 0) {
            throw new RuntimeException(""String_Node_Str"" + rec.getKey());
          }
          lsOwnedRecords.add(rec);
        }
      }
    }
    if (!add)     logger.log(Level.FINEST,thisAddress + ""String_Node_Str"" + lsOwnedRecords.size());
    for (    final Record rec : lsOwnedRecords) {
      parallelExecutorBackups.execute(new FallThroughRunnable(){
        public void doRun(){
          concurrentMapManager.backupRecord(rec);
        }
      }
);
    }
  }
}","void backupIfNextOrPreviousChanged(boolean add){
  List<Record> lsOwnedRecords=new ArrayList<Record>(1000);
  Collection<CMap> cmaps=concurrentMapManager.maps.values();
  for (  final CMap cmap : cmaps) {
    boolean shouldBackup=false;
    if (cmap.backupCount > 0) {
      if (add) {
        shouldBackup=node.clusterManager.isNextChanged(cmap.backupCount);
      }
 else {
        shouldBackup=node.clusterManager.isNextChanged(cmap.backupCount) || node.clusterManager.isPreviousChanged(cmap.backupCount);
      }
    }
    if (shouldBackup) {
      for (      Record rec : cmap.mapRecords.values()) {
        if (rec.isActive()) {
          if (rec.getKey() == null || rec.getKey().size() == 0) {
            throw new RuntimeException(""String_Node_Str"" + rec.getKey());
          }
          lsOwnedRecords.add(rec);
        }
      }
    }
  }
  if (!add)   logger.log(Level.FINEST,thisAddress + ""String_Node_Str"" + lsOwnedRecords.size());
  for (  final Record rec : lsOwnedRecords) {
    parallelExecutorBackups.execute(new FallThroughRunnable(){
      public void doRun(){
        concurrentMapManager.backupRecord(rec);
      }
    }
);
  }
}",0.7182718271827183
50131,"public void setLastUpdated(){
  setLastUpdateTime(System.currentTimeMillis());
}","public void setLastUpdated(){
  setLastUpdateTime(System.currentTimeMillis());
  if (expirationTime != Long.MAX_VALUE && expirationTime > 0) {
    long ttl=expirationTime - getCreationTime();
    updateExpirationTime(ttl);
  }
}",0.5194805194805194
50132,"@Ignore @Test public void issue386(){
  IMap<Object,Object> map=Hazelcast.getMap(""String_Node_Str"");
  int maxLoopCount=10000000;
  for (int count=0; count < maxLoopCount; count++) {
    if (count % 10000 == 0) {
      System.out.println(""String_Node_Str"" + count);
    }
    String o=Integer.toString(count);
    map.lock(o);
    try {
    }
  finally {
      map.unlock(o);
    }
  }
}","@Ignore @Test public void issue386(){
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  IMap map=h1.getMap(""String_Node_Str"");
  int maxLoopCount=10000000;
  for (int count=0; count < maxLoopCount; count++) {
    if (count % 10000 == 0) {
      System.out.println(""String_Node_Str"" + count);
    }
    String o=Integer.toString(count);
    map.lock(o);
    try {
    }
  finally {
      map.unlock(o);
    }
  }
}",0.8806888068880688
50133,"@Test public void testTTL() throws Exception {
  Config config=new XmlConfigBuilder().build();
  FactoryImpl mockFactory=mock(FactoryImpl.class);
  Node node=new Node(mockFactory,config);
  node.serviceThread=Thread.currentThread();
  CMap cmap=new CMap(node.concurrentMapManager,""String_Node_Str"");
  Object key=""String_Node_Str"";
  Object value=""String_Node_Str"";
  Data dKey=toData(key);
  Data dValue=toData(value);
  Request reqPut=newPutRequest(dKey,dValue);
  reqPut.ttl=3000;
  cmap.put(reqPut);
  assertTrue(cmap.mapRecords.containsKey(toData(key)));
  Data actualValue=cmap.get(newGetRequest(dKey));
  assertThat(toObject(actualValue),equalTo(value));
  assertEquals(1,cmap.mapRecords.size());
  Record record=cmap.getRecord(dKey);
  assertNotNull(record);
  assertTrue(record.isActive());
  assertTrue(record.isValid());
  assertEquals(1,cmap.size());
  assertNotNull(cmap.locallyOwnedMap);
  assertNotNull(cmap.get(newGetRequest(dKey)));
  assertEquals(dValue,cmap.get(newGetRequest(dKey)));
  assertEquals(value,cmap.locallyOwnedMap.get(key));
  assertEquals(1,cmap.locallyOwnedMap.mapCache.size());
  Thread.sleep(5000);
  cmap.locallyOwnedMap.evict(System.currentTimeMillis());
  assertEquals(0,cmap.locallyOwnedMap.mapCache.size());
  assertEquals(OBJECT_REDO,cmap.locallyOwnedMap.get(key));
  assertEquals(0,cmap.size());
  assertTrue(cmap.evict(newEvictRequest(dKey)));
  assertTrue(cmap.shouldPurgeRecord(record,System.currentTimeMillis() + 10000));
  cmap.removeAndPurgeRecord(record);
  assertEquals(0,cmap.mapRecords.size());
}","@Test public void testTTL() throws Exception {
  Config config=new Config();
  FactoryImpl mockFactory=mock(FactoryImpl.class);
  Node node=new Node(mockFactory,config);
  node.serviceThread=Thread.currentThread();
  CMap cmap=new CMap(node.concurrentMapManager,""String_Node_Str"");
  Object key=""String_Node_Str"";
  Object value=""String_Node_Str"";
  Data dKey=toData(key);
  Data dValue=toData(value);
  Request reqPut=newPutRequest(dKey,dValue);
  reqPut.ttl=3000;
  cmap.put(reqPut);
  assertTrue(cmap.mapRecords.containsKey(toData(key)));
  Data actualValue=cmap.get(newGetRequest(dKey));
  assertThat(toObject(actualValue),equalTo(value));
  assertEquals(1,cmap.mapRecords.size());
  Record record=cmap.getRecord(dKey);
  assertNotNull(record);
  assertTrue(record.isActive());
  assertTrue(record.isValid());
  assertEquals(1,cmap.size());
  assertNotNull(cmap.locallyOwnedMap);
  assertNotNull(cmap.get(newGetRequest(dKey)));
  assertEquals(dValue,cmap.get(newGetRequest(dKey)));
  assertEquals(value,cmap.locallyOwnedMap.get(key));
  assertEquals(1,cmap.locallyOwnedMap.mapCache.size());
  assertTrue(record.getRemainingTTL() > 1000);
  Thread.sleep(1000);
  assertTrue(record.getRemainingTTL() < 2001);
  cmap.put(newPutRequest(dKey,dValue));
  assertTrue(record.getRemainingTTL() > 2001);
  assertTrue(record.isActive());
  assertTrue(record.isValid());
  Thread.sleep(1000);
  assertTrue(record.getRemainingTTL() < 2001);
  cmap.put(newPutRequest(dKey,dValue));
  assertTrue(record.getRemainingTTL() > 2001);
  assertTrue(record.isActive());
  assertTrue(record.isValid());
  Thread.sleep(5000);
  cmap.locallyOwnedMap.evict(System.currentTimeMillis());
  assertEquals(0,cmap.locallyOwnedMap.mapCache.size());
  assertEquals(OBJECT_REDO,cmap.locallyOwnedMap.get(key));
  assertEquals(0,cmap.size());
  assertTrue(cmap.evict(newEvictRequest(dKey)));
  assertTrue(cmap.shouldPurgeRecord(record,System.currentTimeMillis() + 10000));
  cmap.removeAndPurgeRecord(record);
  assertEquals(0,cmap.mapRecords.size());
}",0.8579434015130288
50134,"@Test public void issue390NoBackupWhenSuperClient() throws InterruptedException {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  IMap map1=h1.getMap(""String_Node_Str"");
  for (int i=0; i < 200; i++) {
    map1.put(i,new byte[1000]);
  }
  Config scconfig=new Config();
  scconfig.setSuperClient(true);
  HazelcastInstance sc=Hazelcast.newHazelcastInstance(scconfig);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  IMap map2=h2.getMap(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(2);
  h2.getPartitionService().addMigrationListener(new MigrationListener(){
    public void migrationStarted(    MigrationEvent migrationEvent){
    }
    public void migrationCompleted(    MigrationEvent migrationEvent){
      latch.countDown();
    }
  }
);
  latch.await();
  assertEquals(map2.getLocalMapStats().getOwnedEntryCount(),map1.getLocalMapStats().getBackupEntryCount());
  assertEquals(map1.getLocalMapStats().getOwnedEntryCount(),map2.getLocalMapStats().getBackupEntryCount());
}","@Test public void issue390NoBackupWhenSuperClient() throws InterruptedException {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  IMap map1=h1.getMap(""String_Node_Str"");
  for (int i=0; i < 200; i++) {
    map1.put(i,new byte[1000]);
  }
  Config scconfig=new Config();
  scconfig.setSuperClient(true);
  HazelcastInstance sc=Hazelcast.newHazelcastInstance(scconfig);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  IMap map2=h2.getMap(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(2);
  h2.getPartitionService().addMigrationListener(new MigrationListener(){
    public void migrationStarted(    MigrationEvent migrationEvent){
    }
    public void migrationCompleted(    MigrationEvent migrationEvent){
      latch.countDown();
    }
  }
);
  latch.await();
  System.out.println(map1.getLocalMapStats());
  System.out.println(map2.getLocalMapStats());
  assertEquals(map2.getLocalMapStats().getOwnedEntryCount(),map1.getLocalMapStats().getBackupEntryCount());
  assertEquals(map1.getLocalMapStats().getOwnedEntryCount(),map2.getLocalMapStats().getBackupEntryCount());
}",0.9563197026022304
50135,"public void put(Request req){
  long now=System.currentTimeMillis();
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req.key);
  if (record != null && !record.isValid(now)) {
    record.setValue(null);
    record.setMultiValues(null);
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (record != null && record.isActive() && record.isValid(now) && record.getValue() != null) {
      req.clearForResponse();
      req.response=record.getValue();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (record == null || !record.isActive() || !record.isValid(now) || record.getValue() == null) {
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (record == null || !record.isActive() || !record.isValid(now)) {
      req.response=Boolean.FALSE;
      return;
    }
    MultiData multiData=(MultiData)toObject(req.value);
    if (multiData == null || multiData.size() != 2) {
      throw new RuntimeException(""String_Node_Str"" + multiData);
    }
    Data expectedOldValue=multiData.getData(0);
    req.value=multiData.getData(1);
    if (!record.getValue().equals(expectedOldValue)) {
      req.response=Boolean.FALSE;
      return;
    }
  }
  Data oldValue=null;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    mapRecords.put(req.key,record);
  }
 else {
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValue() : null;
    record.setValue(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0) {
    record.setExpirationTime(req.ttl);
    ttlPerRecord=true;
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_ADDED,record,req.caller);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_UPDATED,oldValue,record,req.caller);
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateIndexes(record);
  markAsDirty(record);
  req.clearForResponse();
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}","public void put(Request req){
  long now=System.currentTimeMillis();
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req.key);
  if (record != null && !record.isValid(now)) {
    record.setValue(null);
    record.setMultiValues(null);
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (record != null && record.isActive() && record.isValid(now) && record.getValue() != null) {
      req.clearForResponse();
      req.response=record.getValue();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (record == null || !record.isActive() || !record.isValid(now) || record.getValue() == null) {
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (record == null || !record.isActive() || !record.isValid(now)) {
      req.response=Boolean.FALSE;
      return;
    }
    MultiData multiData=(MultiData)toObject(req.value);
    if (multiData == null || multiData.size() != 2) {
      throw new RuntimeException(""String_Node_Str"" + multiData);
    }
    Data expectedOldValue=multiData.getData(0);
    req.value=multiData.getData(1);
    if (!record.getValue().equals(expectedOldValue)) {
      req.response=Boolean.FALSE;
      return;
    }
  }
  Data oldValue=null;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    mapRecords.put(req.key,record);
  }
 else {
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValue() : null;
    record.setValue(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0 && req.ttl < Long.MAX_VALUE) {
    record.setExpirationTime(req.ttl);
    ttlPerRecord=true;
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_ADDED,record,req.caller);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_UPDATED,oldValue,record,req.caller);
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateIndexes(record);
  markAsDirty(record);
  req.clearForResponse();
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}",0.9941002949852508
50136,"void reset(){
  if (locallyOwnedMap != null) {
    locallyOwnedMap.reset();
  }
  if (mapNearCache != null) {
    mapNearCache.reset();
  }
  mapRecords.clear();
  mapIndexService.clear();
}","void reset(){
  if (locallyOwnedMap != null) {
    locallyOwnedMap.reset();
  }
  if (mapNearCache != null) {
    mapNearCache.reset();
  }
  mapRecords.clear();
  mapIndexService.clear();
  if (store != null && store instanceof MapStoreWrapper) {
    try {
      ((MapStoreWrapper)store).destroy();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}",0.6737967914438503
50137,"public void own(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=toRecord(req);
  if (req.ttl <= 0 || req.timeout <= 0) {
    record.setInvalid();
  }
 else {
    record.setExpirationTime(req.ttl);
    record.setMaxIdle(req.timeout);
  }
  markAsActive(record);
  if (store != null && writeDelayMillis > 0) {
    markAsDirty(record);
  }
  updateIndexes(record);
  record.setVersion(req.version);
}","public void own(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  Record record=toRecord(req);
  if (req.ttl <= 0 || req.timeout <= 0) {
    record.setInvalid();
  }
 else {
    record.setExpirationTime(req.ttl);
    record.setMaxIdle(req.timeout);
  }
  markAsActive(record);
  if (store != null && writeDelayMillis > 0) {
    markAsDirty(record);
  }
  if (req.value != null) {
    updateIndexes(record);
  }
  record.setVersion(req.version);
}",0.9162011173184358
50138,"public void doBackup(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  if (req.operation == CONCURRENT_MAP_BACKUP_PUT) {
    Record record=toRecord(req);
    markAsActive(record);
    record.setVersion(req.version);
    if (req.indexes != null) {
      if (req.indexTypes == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      if (req.indexes.length != req.indexTypes.length) {
        throw new RuntimeException(""String_Node_Str"");
      }
      record.setIndexes(req.indexes,req.indexTypes);
    }
    if (req.ttl > 0) {
      record.setExpirationTime(req.ttl);
      ttlPerRecord=true;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (record.isActive()) {
        if (record.getCopyCount() > 0) {
          record.decrementCopyCount();
        }
        markAsRemoved(record);
      }
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_LOCK) {
    Record rec=toRecord(req);
    if (rec.getVersion() == 0) {
      rec.setVersion(req.version);
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_ADD) {
    add(req,true);
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE_MULTI) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (req.value == null) {
        markAsRemoved(record);
      }
 else {
        if (record.containsValue(req.value)) {
          if (record.getMultiValues() != null) {
            Iterator<Data> itValues=record.getMultiValues().iterator();
            while (itValues.hasNext()) {
              Data value=itValues.next();
              if (req.value.equals(value)) {
                itValues.remove();
              }
            }
          }
        }
        if (record.valueCount() == 0) {
          markAsRemoved(record);
        }
      }
    }
  }
 else {
    logger.log(Level.SEVERE,""String_Node_Str"" + req.operation);
  }
}","public void doBackup(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  if (req.operation == CONCURRENT_MAP_BACKUP_PUT) {
    Record record=toRecord(req);
    markAsActive(record);
    record.setVersion(req.version);
    if (req.indexes != null) {
      if (req.indexTypes == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      if (req.indexes.length != req.indexTypes.length) {
        throw new RuntimeException(""String_Node_Str"");
      }
      record.setIndexes(req.indexes,req.indexTypes);
    }
    if (req.ttl > 0 && req.ttl < Long.MAX_VALUE) {
      record.setExpirationTime(req.ttl);
      ttlPerRecord=true;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (record.isActive()) {
        if (record.getCopyCount() > 0) {
          record.decrementCopyCount();
        }
        markAsRemoved(record);
      }
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_LOCK) {
    Record rec=toRecord(req);
    if (rec.getVersion() == 0) {
      rec.setVersion(req.version);
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_ADD) {
    add(req,true);
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE_MULTI) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (req.value == null) {
        markAsRemoved(record);
      }
 else {
        if (record.containsValue(req.value)) {
          if (record.getMultiValues() != null) {
            Iterator<Data> itValues=record.getMultiValues().iterator();
            while (itValues.hasNext()) {
              Data value=itValues.next();
              if (req.value.equals(value)) {
                itValues.remove();
              }
            }
          }
        }
        if (record.valueCount() == 0) {
          markAsRemoved(record);
        }
      }
    }
  }
 else {
    logger.log(Level.SEVERE,""String_Node_Str"" + req.operation);
  }
}",0.993103448275862
50139,"private Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout,long ttl){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=toObject(oldValue);
      }
      txn.attachPutOp(name,key,value,(oldObject == null));
      return threadContext.isClient() ? oldValue : oldObject;
    }
 else {
      return txn.attachPutOp(name,key,value,false);
    }
  }
 else {
    setLocal(operation,name,key,value,timeout,ttl);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    if (operation == CONCURRENT_MAP_TRY_PUT) {
      request.setBooleanRequest();
      doOp();
      Boolean returnObject=getResultAsBoolean();
      if (returnObject) {
        backup(CONCURRENT_MAP_BACKUP_PUT);
      }
      return returnObject;
    }
 else {
      request.setObjectRequest();
      doOp();
      Object returnObject=getResultAsObject();
      if (returnObject instanceof AddressAwareException) {
        rethrowException(operation,(AddressAwareException)returnObject);
      }
      request.longValue=Long.MIN_VALUE;
      backup(CONCURRENT_MAP_BACKUP_PUT);
      return returnObject;
    }
  }
}","private Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout,long ttl){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=toObject(oldValue);
      }
      txn.attachPutOp(name,key,value,0,ttl,(oldObject == null));
      return threadContext.isClient() ? oldValue : oldObject;
    }
 else {
      if (operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
        Object existingValue=txn.get(name,key);
        if (existingValue != null) {
          return existingValue;
        }
      }
      return txn.attachPutOp(name,key,value,false);
    }
  }
 else {
    setLocal(operation,name,key,value,timeout,ttl);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    if (operation == CONCURRENT_MAP_TRY_PUT) {
      request.setBooleanRequest();
      doOp();
      Boolean returnObject=getResultAsBoolean();
      if (returnObject) {
        backup(CONCURRENT_MAP_BACKUP_PUT);
      }
      return returnObject;
    }
 else {
      request.setObjectRequest();
      doOp();
      Object returnObject=getResultAsObject();
      if (returnObject instanceof AddressAwareException) {
        rethrowException(operation,(AddressAwareException)returnObject);
      }
      request.longValue=Long.MIN_VALUE;
      backup(CONCURRENT_MAP_BACKUP_PUT);
      return returnObject;
    }
  }
}",0.943122460824144
50140,"public void restart(){
synchronized (lifecycleLock) {
    fireLifecycleEvent(RESTARTING);
    paused.set(true);
    List<Record> lsOwnedRecords=new ArrayList<Record>();
    for (    CMap cmap : node.concurrentMapManager.getCMaps().values()) {
      if (cmap.isUserMap()) {
        lsOwnedRecords.addAll(cmap.getMapIndexService().getOwnedRecords());
      }
    }
    node.connectionManager.onRestart();
    node.clusterManager.onRestart();
    node.concurrentMapManager.onRestart();
    node.rejoin();
    final CountDownLatch latch=new CountDownLatch(lsOwnedRecords.size());
    final ParallelExecutor executor=node.executorManager.newParallelExecutor(16);
    for (    final Record ownedRecord : lsOwnedRecords) {
      executor.execute(new Runnable(){
        public void run(){
          try {
            ConcurrentMapManager.MPut mput=node.concurrentMapManager.new MPut();
            mput.merge(ownedRecord);
            latch.countDown();
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
        }
      }
);
    }
    try {
      latch.await(60,TimeUnit.SECONDS);
    }
 catch (    InterruptedException ignored) {
    }
    logger.log(Level.INFO,node.getThisAddress() + ""String_Node_Str"");
    paused.set(false);
    fireLifecycleEvent(RESTARTED);
  }
}","public void restart(){
synchronized (lifecycleLock) {
    fireLifecycleEvent(RESTARTING);
    paused.set(true);
    List<Record> lsOwnedRecords=new ArrayList<Record>();
    for (    CMap cmap : node.concurrentMapManager.getCMaps().values()) {
      if (cmap.isUserMap()) {
        lsOwnedRecords.addAll(cmap.getMapIndexService().getOwnedRecords());
      }
    }
    node.connectionManager.onRestart();
    node.clusterManager.onRestart();
    node.concurrentMapManager.onRestart();
    node.rejoin();
    final CountDownLatch latch=new CountDownLatch(lsOwnedRecords.size());
    final ParallelExecutor executor=node.executorManager.newParallelExecutor(16);
    for (    final Record ownedRecord : lsOwnedRecords) {
      executor.execute(new Runnable(){
        public void run(){
          try {
            ConcurrentMapManager.MPut mput=node.concurrentMapManager.new MPut();
            mput.merge(ownedRecord);
            latch.countDown();
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
        }
      }
);
    }
    try {
      latch.await(60,TimeUnit.SECONDS);
    }
 catch (    InterruptedException ignored) {
    }
    paused.set(false);
    fireLifecycleEvent(RESTARTED);
  }
}",0.972397476340694
50141,"public Object attachPutOp(String name,Object key,Object value,long timeout,boolean newRecord){
  Instance.InstanceType instanceType=ConcurrentMapManager.getInstanceType(name);
  Object matchValue=(instanceType.isMultiMap()) ? value : null;
  TransactionRecord rec=findTransactionRecord(name,key,matchValue);
  if (rec == null) {
    rec=new TransactionRecord(name,key,value,newRecord);
    rec.timeout=timeout;
    transactionRecords.add(rec);
    return null;
  }
 else {
    Object old=rec.value;
    rec.value=value;
    rec.removed=false;
    return old;
  }
}","public Object attachPutOp(String name,Object key,Object value,long timeout,long ttl,boolean newRecord){
  Instance.InstanceType instanceType=ConcurrentMapManager.getInstanceType(name);
  Object matchValue=(instanceType.isMultiMap()) ? value : null;
  TransactionRecord rec=findTransactionRecord(name,key,matchValue);
  if (rec == null) {
    rec=new TransactionRecord(name,key,value,newRecord);
    rec.timeout=timeout;
    rec.ttl=ttl;
    transactionRecords.add(rec);
    return null;
  }
 else {
    Object old=rec.value;
    rec.value=value;
    rec.removed=false;
    return old;
  }
}",0.977469670710572
50142,"public void commitMap(){
  if (removed) {
    if (instanceType.isSet()) {
      ConcurrentMapManager.MRemoveItem mRemoveItem=factory.node.concurrentMapManager.new MRemoveItem();
      mRemoveItem.removeItem(name,key);
    }
 else     if (!newRecord) {
      if (instanceType.isMap()) {
        factory.node.concurrentMapManager.new MRemove().remove(name,key,-1);
      }
 else       if (instanceType.isMultiMap()) {
        factory.node.concurrentMapManager.new MRemoveMulti().remove(name,key,value);
      }
    }
 else {
      factory.node.concurrentMapManager.new MLock().unlock(name,key,-1);
    }
  }
 else {
    if (instanceType.isList()) {
      int count=(Integer)value;
      for (int i=0; i < count; i++) {
        factory.node.concurrentMapManager.new MAdd().addToList(name,key);
      }
    }
 else     if (instanceType.isMultiMap()) {
      factory.node.concurrentMapManager.new MPutMulti().put(name,key,value);
    }
 else {
      factory.node.concurrentMapManager.new MPut().put(name,key,value,-1,-1);
    }
  }
}","public void commitMap(){
  if (removed) {
    if (instanceType.isSet()) {
      ConcurrentMapManager.MRemoveItem mRemoveItem=factory.node.concurrentMapManager.new MRemoveItem();
      mRemoveItem.removeItem(name,key);
    }
 else     if (!newRecord) {
      if (instanceType.isMap()) {
        factory.node.concurrentMapManager.new MRemove().remove(name,key,-1);
      }
 else       if (instanceType.isMultiMap()) {
        factory.node.concurrentMapManager.new MRemoveMulti().remove(name,key,value);
      }
    }
 else {
      factory.node.concurrentMapManager.new MLock().unlock(name,key,-1);
    }
  }
 else {
    if (instanceType.isList()) {
      int count=(Integer)value;
      for (int i=0; i < count; i++) {
        factory.node.concurrentMapManager.new MAdd().addToList(name,key);
      }
    }
 else     if (instanceType.isMultiMap()) {
      factory.node.concurrentMapManager.new MPutMulti().put(name,key,value);
    }
 else {
      factory.node.concurrentMapManager.new MPut().put(name,key,value,-1,ttl);
    }
  }
}",0.997569275644142
50143,"public void mergeOne(Record record,Data valueData){
  DataRecordEntry dataRecordEntry=new DataRecordEntry(record,valueData);
  request.setFromRecord(record);
  request.operation=CONCURRENT_MAP_MERGE;
  request.value=toData(dataRecordEntry);
  request.setBooleanRequest();
  doOp();
  Boolean returnObject=getResultAsBoolean();
  if (returnObject) {
    request.value=valueData;
    backup(CONCURRENT_MAP_BACKUP_PUT);
  }
}","public void mergeOne(Record record,Data valueData){
  DataRecordEntry dataRecordEntry=new DataRecordEntry(record,valueData);
  request.setFromRecord(record);
  request.operation=CONCURRENT_MAP_MERGE;
  request.value=toData(dataRecordEntry.getValue());
  request.setBooleanRequest();
  doOp();
  Boolean returnObject=getResultAsBoolean();
  if (returnObject) {
    request.value=valueData;
    backup(CONCURRENT_MAP_BACKUP_PUT);
  }
}",0.9871345029239766
50144,"@Override public void entryAdded(EntryEvent event){
  events2.add(event);
}","@Override public void entryAdded(EntryEvent event){
  events.add(event);
}",0.9932885906040269
50145,"public void addListener(String name,Object listener,Object key,boolean includeValue,Instance.InstanceType instanceType){
  boolean remotelyRegister=true;
  for (  ListenerItem listenerItem : listeners) {
    if (remotelyRegister) {
      if (listenerItem.listener == listener) {
        if (listenerItem.name.equals(name)) {
          if (key == null) {
            if (listenerItem.key == null) {
              if (!includeValue || listenerItem.includeValue == includeValue) {
                remotelyRegister=false;
              }
            }
          }
 else {
            if (listenerItem.key != null) {
              if (listenerItem.key.equals(key)) {
                if (!includeValue || listenerItem.includeValue == includeValue) {
                  remotelyRegister=false;
                }
              }
            }
          }
        }
      }
    }
  }
  if (remotelyRegister) {
    registerListener(name,key,true,includeValue);
  }
  ListenerItem listenerItem=new ListenerItem(name,key,listener,includeValue,instanceType);
  listeners.add(listenerItem);
}","public void addListener(String name,Object listener,Object key,boolean includeValue,Instance.InstanceType instanceType){
  boolean remotelyRegister=true;
  for (  ListenerItem listenerItem : listeners) {
    if (!remotelyRegister) {
      break;
    }
    if (listenerItem.name.equals(name)) {
      if (key == null) {
        if (listenerItem.key == null && (!includeValue || listenerItem.includeValue == includeValue)) {
          remotelyRegister=false;
        }
      }
 else       if (listenerItem.key != null) {
        if (listenerItem.key.equals(key) && (!includeValue || listenerItem.includeValue == includeValue)) {
          remotelyRegister=false;
        }
      }
    }
  }
  if (remotelyRegister) {
    registerListener(name,key,true,includeValue);
  }
  ListenerItem listenerItem=new ListenerItem(name,key,listener,includeValue,instanceType);
  listeners.add(listenerItem);
}",0.5657694261046217
50146,"private void callListener(ListenerItem listenerItem,EntryEvent event){
  Object listener=listenerItem.listener;
  EntryEventType entryEventType=event.getEventType();
  if (listenerItem.instanceType == Instance.InstanceType.MAP) {
    if (!listenerItem.name.startsWith(""String_Node_Str"")) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof MProxy) {
        MProxy mProxy=(MProxy)proxy;
        mProxy.getMapOperationStats().incrementReceivedEvents();
      }
    }
  }
switch (listenerItem.instanceType) {
case MAP:
case MULTIMAP:
    EntryListener entryListener=(EntryListener)listener;
switch (entryEventType) {
case ADDED:
    entryListener.entryAdded(event);
  break;
case REMOVED:
entryListener.entryRemoved(event);
break;
case UPDATED:
entryListener.entryUpdated(event);
break;
case EVICTED:
entryListener.entryEvicted(event);
break;
}
break;
case SET:
case LIST:
ItemListener itemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
itemListener.itemAdded(event.getKey());
break;
case REMOVED:
itemListener.itemRemoved(event.getKey());
break;
}
break;
case TOPIC:
MessageListener messageListener=(MessageListener)listener;
messageListener.onMessage(event.getValue());
break;
case QUEUE:
ItemListener queueItemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
queueItemListener.itemAdded(event.getValue());
break;
case REMOVED:
queueItemListener.itemRemoved(event.getValue());
break;
}
break;
}
}","private void callListener(final ListenerItem listenerItem,final EntryEvent event){
  final Object listener=listenerItem.listener;
  final EntryEventType entryEventType=event.getEventType();
  if (listenerItem.instanceType == Instance.InstanceType.MAP) {
    if (!listenerItem.name.startsWith(""String_Node_Str"")) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof MProxy) {
        MProxy mProxy=(MProxy)proxy;
        mProxy.getMapOperationStats().incrementReceivedEvents();
      }
    }
  }
  final EntryEvent event2=listenerItem.includeValue ? event : (event.getValue() != null ? new EntryEvent(event.getSource(),event.getMember(),event.getEventType().getType(),event.getKey(),null,null) : event);
switch (listenerItem.instanceType) {
case MAP:
case MULTIMAP:
    EntryListener entryListener=(EntryListener)listener;
switch (entryEventType) {
case ADDED:
    entryListener.entryAdded(event2);
  break;
case REMOVED:
entryListener.entryRemoved(event2);
break;
case UPDATED:
entryListener.entryUpdated(event2);
break;
case EVICTED:
entryListener.entryEvicted(event2);
break;
}
break;
case SET:
case LIST:
ItemListener itemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
itemListener.itemAdded(event2.getKey());
break;
case REMOVED:
itemListener.itemRemoved(event2.getKey());
break;
}
break;
case TOPIC:
MessageListener messageListener=(MessageListener)listener;
messageListener.onMessage(event2.getValue());
break;
case QUEUE:
ItemListener queueItemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
queueItemListener.itemAdded(event2.getValue());
break;
case REMOVED:
queueItemListener.itemRemoved(event2.getValue());
break;
}
break;
}
}",0.9253638897491484
50147,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + id + ""String_Node_Str""+ (request != null ? request.getOperation() + ""String_Node_Str"" + request.getName()+ ""String_Node_Str""+ (hasResponse() ? ""String_Node_Str"" : ""String_Node_Str"")+ Serializer.toObject(request.getKey())+ ""String_Node_Str""+ Serializer.toObject(request.getValue()) : null);
}","@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + id + ""String_Node_Str""+ (request != null ? request.getOperation() : null);
}",0.5996275605214153
50148,"public static HazelcastInstanceProxy newHazelcastInstanceProxy(Config config){
  FactoryImpl factory=null;
  try {
synchronized (factoryLock) {
      if (config == null) {
        config=new XmlConfigBuilder().build();
      }
      int classLoaderHash=FactoryImpl.class.getClassLoader().hashCode();
      String name=""String_Node_Str"" + classLoaderHash + ""String_Node_Str""+ nextFactoryId+++ ""String_Node_Str""+ config.getGroupConfig().getName();
      factory=new FactoryImpl(name,config);
      FactoryImpl old=factories.put(name,factory);
      if (old != null) {
        factory.logger.log(Level.SEVERE,""String_Node_Str"" + name + ""String_Node_Str"");
        throw new RuntimeException();
      }
    }
    boolean firstMember=(factory.node.getClusterImpl().getMembers().iterator().next().localMember());
    int initialWaitSeconds=factory.node.groupProperties.INITIAL_WAIT_SECONDS.getInteger();
    if (initialWaitSeconds > 0) {
      try {
        Thread.sleep(initialWaitSeconds * 1000);
        if (firstMember) {
          final ConcurrentMapManager concurrentMapManager=factory.node.concurrentMapManager;
          concurrentMapManager.enqueueAndReturn(new Processable(){
            public void process(){
              concurrentMapManager.partitionManager.quickBlockRearrangement();
            }
          }
);
        }
 else {
          Thread.sleep(4 * 1000);
        }
      }
 catch (      InterruptedException ignored) {
      }
    }
    factory.lifecycleService.fireLifecycleEvent(STARTED);
    return factory.hazelcastInstanceProxy;
  }
 catch (  Throwable t) {
    if (factory != null) {
      factory.logger.log(Level.SEVERE,t.getMessage(),t);
    }
    throw new RuntimeException(t);
  }
}","public static HazelcastInstanceProxy newHazelcastInstanceProxy(Config config){
  FactoryImpl factory=null;
  try {
synchronized (factoryLock) {
      if (config == null) {
        config=new XmlConfigBuilder().build();
      }
      String name=""String_Node_Str"" + nextFactoryId++ + ""String_Node_Str""+ config.getGroupConfig().getName();
      factory=new FactoryImpl(name,config);
      FactoryImpl old=factories.put(name,factory);
      if (old != null) {
        factory.logger.log(Level.SEVERE,""String_Node_Str"" + name + ""String_Node_Str"");
        throw new RuntimeException();
      }
    }
    boolean firstMember=(factory.node.getClusterImpl().getMembers().iterator().next().localMember());
    int initialWaitSeconds=factory.node.groupProperties.INITIAL_WAIT_SECONDS.getInteger();
    if (initialWaitSeconds > 0) {
      try {
        Thread.sleep(initialWaitSeconds * 1000);
        if (firstMember) {
          final ConcurrentMapManager concurrentMapManager=factory.node.concurrentMapManager;
          concurrentMapManager.enqueueAndReturn(new Processable(){
            public void process(){
              concurrentMapManager.partitionManager.quickBlockRearrangement();
            }
          }
);
        }
 else {
          Thread.sleep(4 * 1000);
        }
      }
 catch (      InterruptedException ignored) {
      }
    }
    factory.lifecycleService.fireLifecycleEvent(STARTED);
    return factory.hazelcastInstanceProxy;
  }
 catch (  Throwable t) {
    if (factory != null) {
      factory.logger.log(Level.SEVERE,t.getMessage(),t);
    }
    throw new RuntimeException(t);
  }
}",0.966536026529997
50149,"public Collection<Instance> getInstances(){
  final int totalSize=proxies.size();
  List<Instance> lsProxies=new ArrayList<Instance>(totalSize);
  lsProxies.addAll(proxies.values());
  return lsProxies;
}","public Collection<Instance> getInstances(){
  return new ArrayList<Instance>(proxies.values());
}",0.6112956810631229
50150,"public ClusterMBean(ManagementService service){
  super(service.instance,service);
  this.config=service.instance.getConfig();
  this.cluster=service.instance.getCluster();
  clusterObjectNames=new ObjectNameSpec(getManagedObject().getName());
}","public ClusterMBean(ManagementService service,String name){
  super(service.instance,service);
  this.name=name;
  this.config=service.instance.getConfig();
  this.cluster=service.instance.getCluster();
  clusterObjectNames=new ObjectNameSpec(name);
}",0.875
50151,"@Override public ObjectNameSpec getNameSpec(){
  return new ObjectNameSpec(""String_Node_Str"",getManagedObject().getName());
}","@Override public ObjectNameSpec getNameSpec(){
  return new ObjectNameSpec(""String_Node_Str"",name);
}",0.8938053097345132
50152,"/** 
 * Unregister a cluster instance.
 */
public synchronized void unregister(){
  if (!started) {
    return;
  }
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(ObjectNameSpec.getClusterNameFilter(instance.getName()),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"",e);
  }
  counter.decrementAndGet();
}","/** 
 * Unregister a cluster instance.
 */
public synchronized void unregister(){
  if (!started) {
    return;
  }
  MBeanServer mbs=mBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(ObjectNameSpec.getClusterNameFilter(this.name),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"",e);
  }
  counter.decrementAndGet();
}",0.9444444444444444
50153,"/** 
 * Stop the management service
 */
public synchronized static void shutdown(){
  if (counter.get() > 0) {
    return;
  }
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(new ObjectName(ObjectNameSpec.NAME_DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"",e);
  }
  if (statCollectors != null) {
    statCollectors.shutdownNow();
    statCollectors=null;
  }
}","/** 
 * Stop the management service
 */
public synchronized static void shutdown(){
  if (counter.get() > 0) {
    return;
  }
  MBeanServer mbs=mBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(new ObjectName(ObjectNameSpec.NAME_DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"",e);
  }
  if (statCollectors != null) {
    statCollectors.shutdownNow();
    statCollectors=null;
  }
}",0.9746109746109746
50154,"/** 
 * Register all the MBeans.
 */
public synchronized void register(){
  if (!started) {
    start();
  }
  if (!started) {
    return;
  }
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  try {
    ClusterMBean clusterMBean=new ClusterMBean(this);
    mbs.registerMBean(clusterMBean,clusterMBean.getObjectName());
    DataMBean dataMBean=new DataMBean(this);
    dataMBean.setParentName(clusterMBean.getRootName());
    mbs.registerMBean(dataMBean,dataMBean.getObjectName());
  }
 catch (  Exception e) {
    logger.log(Level.WARNING,""String_Node_Str"",e);
    return;
  }
  counter.incrementAndGet();
}","/** 
 * Register all the MBeans.
 */
public synchronized void register(){
  if (!started) {
    start();
  }
  if (!started) {
    return;
  }
  MBeanServer mbs=mBeanServer();
  try {
    nameLookup();
    ClusterMBean clusterMBean=new ClusterMBean(this,this.name);
    mbs.registerMBean(clusterMBean,clusterMBean.getObjectName());
    DataMBean dataMBean=new DataMBean(this);
    dataMBean.setParentName(clusterMBean.getRootName());
    mbs.registerMBean(dataMBean,dataMBean.getObjectName());
  }
 catch (  Exception e) {
    logger.log(Level.WARNING,""String_Node_Str"",e);
    return;
  }
  counter.incrementAndGet();
}",0.9250604351329572
50155,"/** 
 * Test multiple Future.get() invokation
 */
@Test public void isTwoGetFromFuture() throws Exception {
  Callable<String> task=new ExecutorServiceTest.BasicTestTask();
  ExecutorService executor=getExecutorService();
  Future<String> future=executor.submit(task);
  String s1=future.get();
  assertEquals(ExecutorServiceTest.BasicTestTask.RESULT,s1);
  assertTrue(future.isDone());
  String s2=future.get();
  assertEquals(ExecutorServiceTest.BasicTestTask.RESULT,s2);
  assertTrue(future.isDone());
  String s3=future.get();
  assertEquals(ExecutorServiceTest.BasicTestTask.RESULT,s3);
  assertTrue(future.isDone());
  String s4=future.get();
  assertEquals(ExecutorServiceTest.BasicTestTask.RESULT,s4);
  assertTrue(future.isDone());
}","/** 
 * Test multiple Future.get() invocation
 */
@Test public void isTwoGetFromFuture() throws Exception {
  Callable<String> task=new ExecutorServiceTest.BasicTestTask();
  ExecutorService executor=getExecutorService();
  Future<String> future=executor.submit(task);
  String s1=future.get();
  assertEquals(ExecutorServiceTest.BasicTestTask.RESULT,s1);
  assertTrue(future.isDone());
  String s2=future.get();
  assertEquals(ExecutorServiceTest.BasicTestTask.RESULT,s2);
  assertTrue(future.isDone());
  String s3=future.get();
  assertEquals(ExecutorServiceTest.BasicTestTask.RESULT,s3);
  assertTrue(future.isDone());
  String s4=future.get();
  assertEquals(ExecutorServiceTest.BasicTestTask.RESULT,s4);
  assertTrue(future.isDone());
}",0.9986522911051212
50156,"/** 
 * Test for the issue 129. Repeadetly runs tasks and checkTime for isDone() status after get().
 */
@Test public void isDoneMethod_issue129() throws Exception {
  ExecutorService executor=getExecutorService();
  for (int i=0; i < COUNT; i++) {
    Callable<String> task1=new BasicTestTask();
    Callable<String> task2=new BasicTestTask();
    Future<?> future1=executor.submit(task1);
    Future<?> future2=executor.submit(task2);
    assertEquals(future2.get(),BasicTestTask.RESULT);
    assertTrue(future2.isDone());
    assertEquals(future1.get(),BasicTestTask.RESULT);
    assertTrue(future1.isDone());
  }
}","/** 
 * Test for the issue 129. Repeatedly runs tasks and checkTime for isDone() status after get().
 */
@Test public void isDoneMethod_issue129() throws Exception {
  ExecutorService executor=getExecutorService();
  for (int i=0; i < COUNT; i++) {
    Callable<String> task1=new BasicTestTask();
    Callable<String> task2=new BasicTestTask();
    Future<?> future1=executor.submit(task1);
    Future<?> future2=executor.submit(task2);
    assertEquals(future2.get(),BasicTestTask.RESULT);
    assertTrue(future2.isDone());
    assertEquals(future1.get(),BasicTestTask.RESULT);
    assertTrue(future1.isDone());
  }
}",0.9967637540453076
50157,"public static HazelcastInstanceProxy newHazelcastInstanceProxy(Config config){
  FactoryImpl factory=null;
  try {
synchronized (factoryLock) {
      if (config == null) {
        config=new XmlConfigBuilder().build();
      }
      String name=""String_Node_Str"" + nextFactoryId++ + ""String_Node_Str""+ config.getGroupConfig().getName();
      factory=new FactoryImpl(name,config);
      FactoryImpl old=factories.put(name,factory);
      if (old != null) {
        factory.logger.log(Level.SEVERE,""String_Node_Str"" + name + ""String_Node_Str"");
        throw new RuntimeException();
      }
    }
    boolean firstMember=(factory.node.getClusterImpl().getMembers().iterator().next().localMember());
    int initialWaitSeconds=factory.node.groupProperties.INITIAL_WAIT_SECONDS.getInteger();
    if (initialWaitSeconds > 0) {
      try {
        Thread.sleep(initialWaitSeconds * 1000);
        if (firstMember) {
          final ConcurrentMapManager concurrentMapManager=factory.node.concurrentMapManager;
          concurrentMapManager.enqueueAndReturn(new Processable(){
            public void process(){
              concurrentMapManager.partitionManager.quickBlockRearrangement();
            }
          }
);
        }
 else {
          Thread.sleep(4 * 1000);
        }
      }
 catch (      InterruptedException ignored) {
      }
    }
    factory.lifecycleService.fireLifecycleEvent(STARTED);
    return factory.hazelcastInstanceProxy;
  }
 catch (  Throwable t) {
    if (factory != null) {
      factory.logger.log(Level.SEVERE,t.getMessage(),t);
    }
    throw new RuntimeException(t);
  }
}","public static HazelcastInstanceProxy newHazelcastInstanceProxy(Config config){
  FactoryImpl factory=null;
  try {
synchronized (factoryLock) {
      if (config == null) {
        config=new XmlConfigBuilder().build();
      }
      int classLoaderHash=FactoryImpl.class.getClassLoader().hashCode();
      String name=""String_Node_Str"" + classLoaderHash + ""String_Node_Str""+ nextFactoryId+++ ""String_Node_Str""+ config.getGroupConfig().getName();
      factory=new FactoryImpl(name,config);
      FactoryImpl old=factories.put(name,factory);
      if (old != null) {
        factory.logger.log(Level.SEVERE,""String_Node_Str"" + name + ""String_Node_Str"");
        throw new RuntimeException();
      }
    }
    boolean firstMember=(factory.node.getClusterImpl().getMembers().iterator().next().localMember());
    int initialWaitSeconds=factory.node.groupProperties.INITIAL_WAIT_SECONDS.getInteger();
    if (initialWaitSeconds > 0) {
      try {
        Thread.sleep(initialWaitSeconds * 1000);
        if (firstMember) {
          final ConcurrentMapManager concurrentMapManager=factory.node.concurrentMapManager;
          concurrentMapManager.enqueueAndReturn(new Processable(){
            public void process(){
              concurrentMapManager.partitionManager.quickBlockRearrangement();
            }
          }
);
        }
 else {
          Thread.sleep(4 * 1000);
        }
      }
 catch (      InterruptedException ignored) {
      }
    }
    factory.lifecycleService.fireLifecycleEvent(STARTED);
    return factory.hazelcastInstanceProxy;
  }
 catch (  Throwable t) {
    if (factory != null) {
      factory.logger.log(Level.SEVERE,t.getMessage(),t);
    }
    throw new RuntimeException(t);
  }
}",0.966536026529997
50158,"BlockingQueueManager(Node node){
  super(node);
  BLOCK_SIZE=node.groupProperties.BLOCKING_QUEUE_BLOCK_SIZE.getInteger();
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_POLL,new PacketProcessor(){
    public void process(    Packet packet){
      try {
        handlePoll(packet);
      }
 catch (      Throwable t) {
        Request req=Request.copy(packet);
        printState(req,false,packet.conn.getEndPoint(),1);
        t.printStackTrace();
      }
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_OFFER,new PacketProcessor(){
    public void process(    Packet packet){
      handleOffer(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_BACKUP_ADD,new PacketProcessor(){
    public void process(    Packet packet){
      handleBackup(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_BACKUP_REMOVE,new PacketProcessor(){
    public void process(    Packet packet){
      handleBackup(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_SIZE,new PacketProcessor(){
    public void process(    Packet packet){
      handleSize(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_PEEK,new PacketProcessor(){
    public void process(    Packet packet){
      handlePoll(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_READ,new PacketProcessor(){
    public void process(    Packet packet){
      handleRead(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_REMOVE,new PacketProcessor(){
    public void process(    Packet packet){
      handleRemove(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_TXN_BACKUP_POLL,new PacketProcessor(){
    public void process(    Packet packet){
      handleTxnBackupPoll(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_TXN_COMMIT,new PacketProcessor(){
    public void process(    Packet packet){
      handleTxnCommit(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_ADD_BLOCK,new PacketProcessor(){
    public void process(    Packet packet){
      handleAddBlock(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_REMOVE_BLOCK,new PacketProcessor(){
    public void process(    Packet packet){
      handleRemoveBlock(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_FULL_BLOCK,new PacketProcessor(){
    public void process(    Packet packet){
      handleFullBlock(packet);
    }
  }
);
}","BlockingQueueManager(Node node){
  super(node);
  BLOCK_SIZE=node.groupProperties.BLOCKING_QUEUE_BLOCK_SIZE.getInteger();
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_POLL,new PacketProcessor(){
    public void process(    Packet packet){
      try {
        handlePoll(packet);
      }
 catch (      Throwable t) {
        Request req=Request.copy(packet);
        printState(req,false,packet.conn.getEndPoint(),1);
        t.printStackTrace();
      }
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_OFFER,new PacketProcessor(){
    public void process(    Packet packet){
      handleOffer(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_OFFER_FIRST,new PacketProcessor(){
    public void process(    Packet packet){
      handleOfferFirst(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_BACKUP_ADD,new PacketProcessor(){
    public void process(    Packet packet){
      handleBackup(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_BACKUP_REMOVE,new PacketProcessor(){
    public void process(    Packet packet){
      handleBackup(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_SIZE,new PacketProcessor(){
    public void process(    Packet packet){
      handleSize(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_PEEK,new PacketProcessor(){
    public void process(    Packet packet){
      handlePoll(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_READ,new PacketProcessor(){
    public void process(    Packet packet){
      handleRead(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_REMOVE,new PacketProcessor(){
    public void process(    Packet packet){
      handleRemove(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_TXN_BACKUP_POLL,new PacketProcessor(){
    public void process(    Packet packet){
      handleTxnBackupPoll(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_TXN_COMMIT,new PacketProcessor(){
    public void process(    Packet packet){
      handleTxnCommit(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_ADD_BLOCK,new PacketProcessor(){
    public void process(    Packet packet){
      handleAddBlock(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_REMOVE_BLOCK,new PacketProcessor(){
    public void process(    Packet packet){
      handleRemoveBlock(packet);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_QUEUE_FULL_BLOCK,new PacketProcessor(){
    public void process(    Packet packet){
      handleFullBlock(packet);
    }
  }
);
}",0.9658899020601148
50159,"int offer(Request req){
  if (req.value == null) {
    throw new RuntimeException(""String_Node_Str"" + req.local);
  }
  if (req.value.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.local);
  }
  try {
    int addIndex=blCurrentPut.add(req.value);
    doFireEntryEvent(true,req.value,req.caller);
    sendBackup(true,req.caller,req.value,blCurrentPut.blockId,addIndex);
    req.longValue=addIndex;
    if (blCurrentPut.isFull()) {
      fireBlockFullEvent(blCurrentPut);
      blCurrentPut=null;
      setCurrentPut();
    }
    return addIndex;
  }
  finally {
    boolean consumed=false;
    while (!consumed && lsScheduledPollActions.size() > 0) {
      ScheduledAction pollAction=lsScheduledPollActions.remove(0);
      if (!pollAction.expired()) {
        consumed=pollAction.consume();
        node.clusterManager.deregisterScheduledAction(pollAction);
      }
    }
  }
}","int offer(Request req,boolean first){
  if (req.value == null) {
    throw new RuntimeException(""String_Node_Str"" + req.local);
  }
  if (req.value.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.local);
  }
  try {
    int addIndex=(first) ? blCurrentTake.addFirst(req.value) : blCurrentPut.add(req.value);
    doFireEntryEvent(true,req.value,req.caller);
    sendBackup(true,req.caller,req.value,blCurrentPut.blockId,addIndex);
    req.longValue=addIndex;
    if (blCurrentPut.isFull()) {
      fireBlockFullEvent(blCurrentPut);
      blCurrentPut=null;
      setCurrentPut();
    }
    return addIndex;
  }
  finally {
    boolean consumed=false;
    while (!consumed && lsScheduledPollActions.size() > 0) {
      ScheduledAction pollAction=lsScheduledPollActions.remove(0);
      if (!pollAction.expired()) {
        consumed=pollAction.consume();
        node.clusterManager.deregisterScheduledAction(pollAction);
      }
    }
  }
}",0.967741935483871
50160,"@Override public boolean consume(){
  valid=rightPutTarget(request.blockId);
  if (valid) {
    offer(request);
    request.response=Boolean.TRUE;
    returnScheduledAsBoolean(request);
    return true;
  }
 else {
    request.response=OBJECT_REDO;
    returnResponse(request);
    return false;
  }
}","@Override public boolean consume(){
  valid=rightPutTarget(request.blockId);
  if (valid) {
    offer(request,false);
    request.response=Boolean.TRUE;
    returnScheduledAsBoolean(request);
    return true;
  }
 else {
    request.response=OBJECT_REDO;
    returnResponse(request);
    return false;
  }
}",0.9901315789473684
50161,"void doOffer(Request req){
  if (req.value == null) {
    throw new RuntimeException(""String_Node_Str"" + req.local);
  }
  if (req.value.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.local);
  }
  Q q=getQ(req.name);
  if (q.blCurrentPut == null) {
    q.setCurrentPut();
  }
  if (q.quickSize() >= q.maxSizePerJVM) {
    if (req.hasEnoughTimeToSchedule()) {
      req.scheduled=true;
      final Request reqScheduled=(req.local) ? req : req.hardCopy();
      if (reqScheduled.local) {
        if (reqScheduled.attachment == null) {
          throw new RuntimeException(""String_Node_Str"");
        }
      }
      q.scheduleOffer(reqScheduled);
    }
 else {
      req.response=Boolean.FALSE;
    }
    return;
  }
  q.offer(req);
  req.response=Boolean.TRUE;
}","void doOffer(Request req){
  if (req.value == null) {
    throw new RuntimeException(""String_Node_Str"" + req.local);
  }
  if (req.value.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.local);
  }
  Q q=getQ(req.name);
  if (q.blCurrentPut == null) {
    q.setCurrentPut();
  }
  if (q.quickSize() >= q.maxSizePerJVM) {
    if (req.hasEnoughTimeToSchedule()) {
      req.scheduled=true;
      final Request reqScheduled=(req.local) ? req : req.hardCopy();
      if (reqScheduled.local) {
        if (reqScheduled.attachment == null) {
          throw new RuntimeException(""String_Node_Str"");
        }
      }
      q.scheduleOffer(reqScheduled);
    }
 else {
      req.response=Boolean.FALSE;
    }
    return;
  }
  q.offer(req,false);
  req.response=Boolean.TRUE;
}",0.9961928934010152
50162,"public void commitQueue(){
  if (removed) {
    commitPoll();
  }
 else {
    offerAgain();
  }
}","public void commitQueue(){
  if (removed) {
    commitPoll();
  }
 else {
    offerAgain(false);
  }
}",0.9748743718592964
50163,"private void offerAgain(){
  Offer offer=factory.node.blockingQueueManager.new Offer();
  try {
    boolean offered=offer.offer(name,value,timeout,false);
    if (!offered) {
      throw new RuntimeException(""String_Node_Str"" + timeout + ""String_Node_Str"");
    }
  }
 catch (  InterruptedException ignored) {
  }
}","private void offerAgain(boolean first){
  Offer offer=null;
  if (first) {
    offer=factory.node.blockingQueueManager.new OfferFirst();
  }
 else {
    offer=factory.node.blockingQueueManager.new Offer();
  }
  try {
    boolean offered=offer.offer(name,value,timeout,false);
    if (!offered) {
      throw new RuntimeException(""String_Node_Str"" + timeout + ""String_Node_Str"");
    }
  }
 catch (  InterruptedException ignored) {
  }
}",0.8377659574468085
50164,"public void rollbackQueue(){
  if (removed) {
    offerAgain();
  }
}","public void rollbackQueue(){
  if (removed) {
    offerAgain(true);
  }
}",0.971830985915493
50165,"public void onClick(ClickEvent clickEvent){
  hazelcastMonitor.onValueChangeHandler.handle(token);
}","public void onClick(ClickEvent clickEvent){
  hazelcastMonitor.onValueChangeHandler.handle(config);
}",0.965174129353234
50166,"private Anchor createLink(String name,final String token){
  Anchor anchor=new Anchor(name);
  anchor.addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent clickEvent){
      hazelcastMonitor.onValueChangeHandler.handle(token);
    }
  }
);
  return anchor;
}","private Anchor createLink(String name,final ConfigLink config){
  Anchor anchor=new Anchor(name);
  anchor.addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent clickEvent){
      hazelcastMonitor.onValueChangeHandler.handle(config);
    }
  }
);
  return anchor;
}",0.9293286219081272
50167,"public Anchor getInstanceLink(InstanceType type,String name){
  final String token=""String_Node_Str"" + clusterId + ""String_Node_Str""+ ((type == null) ? ""String_Node_Str"" : type)+ ""String_Node_Str""+ name;
  Anchor anchor=createLink(name,token);
  return anchor;
}","public Anchor getInstanceLink(InstanceType type,String name){
  ConfigLink config=new ConfigLink();
  config.setClusterId(clusterId);
  config.setType(type == null ? ""String_Node_Str"" : type.toString());
  config.setName(name);
  Anchor anchor=createLink(name,config);
  return anchor;
}",0.5027322404371585
50168,"private Tree addTreeItems(ClusterView cv){
  Tree tree=new Tree();
  memberTreeItem=addTreeItem(tree,""String_Node_Str"",cv.getMembers(),clusterId,null);
  itemMap.put(InstanceType.MAP,new InstanceWidgets(InstanceType.MAP,addTreeItem(tree,""String_Node_Str"",cv.getMaps(),clusterId,InstanceType.MAP)));
  itemMap.put(InstanceType.QUEUE,new InstanceWidgets(InstanceType.QUEUE,addTreeItem(tree,""String_Node_Str"",cv.getQs(),clusterId,InstanceType.QUEUE)));
  itemMap.put(InstanceType.LIST,new InstanceWidgets(InstanceType.LIST,addTreeItem(tree,""String_Node_Str"",cv.getLists(),clusterId,InstanceType.LIST)));
  itemMap.put(InstanceType.SET,new InstanceWidgets(InstanceType.SET,addTreeItem(tree,""String_Node_Str"",cv.getSets(),clusterId,InstanceType.SET)));
  itemMap.put(InstanceType.TOPIC,new InstanceWidgets(InstanceType.TOPIC,addTreeItem(tree,""String_Node_Str"",cv.getTopics(),clusterId,InstanceType.TOPIC)));
  itemMap.put(InstanceType.MULTIMAP,new InstanceWidgets(InstanceType.MULTIMAP,addTreeItem(tree,""String_Node_Str"",cv.getMultiMaps(),clusterId,InstanceType.MULTIMAP)));
  itemMap.put(InstanceType.LOCK,new InstanceWidgets(InstanceType.LOCK,addTreeItem(tree,""String_Node_Str"",cv.getLocks(),clusterId,InstanceType.LOCK)));
  TreeItem treeItem=new TreeItem(""String_Node_Str"");
  Anchor anchor=createLink(""String_Node_Str"",""String_Node_Str"" + clusterId + ""String_Node_Str"");
  treeItem.addItem(anchor);
  tree.addItem(treeItem);
  return tree;
}","private Tree addTreeItems(ClusterView cv){
  Tree tree=new Tree();
  memberTreeItem=addTreeItem(tree,""String_Node_Str"",cv.getMembers(),clusterId,null);
  itemMap.put(InstanceType.MAP,new InstanceWidgets(InstanceType.MAP,addTreeItem(tree,""String_Node_Str"",cv.getMaps(),clusterId,InstanceType.MAP)));
  itemMap.put(InstanceType.QUEUE,new InstanceWidgets(InstanceType.QUEUE,addTreeItem(tree,""String_Node_Str"",cv.getQs(),clusterId,InstanceType.QUEUE)));
  itemMap.put(InstanceType.LIST,new InstanceWidgets(InstanceType.LIST,addTreeItem(tree,""String_Node_Str"",cv.getLists(),clusterId,InstanceType.LIST)));
  itemMap.put(InstanceType.SET,new InstanceWidgets(InstanceType.SET,addTreeItem(tree,""String_Node_Str"",cv.getSets(),clusterId,InstanceType.SET)));
  itemMap.put(InstanceType.TOPIC,new InstanceWidgets(InstanceType.TOPIC,addTreeItem(tree,""String_Node_Str"",cv.getTopics(),clusterId,InstanceType.TOPIC)));
  itemMap.put(InstanceType.MULTIMAP,new InstanceWidgets(InstanceType.MULTIMAP,addTreeItem(tree,""String_Node_Str"",cv.getMultiMaps(),clusterId,InstanceType.MULTIMAP)));
  itemMap.put(InstanceType.LOCK,new InstanceWidgets(InstanceType.LOCK,addTreeItem(tree,""String_Node_Str"",cv.getLocks(),clusterId,InstanceType.LOCK)));
  TreeItem treeItem=new TreeItem(""String_Node_Str"");
  ConfigLink config=new ConfigLink();
  config.setClusterId(clusterId);
  config.setType(""String_Node_Str"");
  Anchor anchor=createLink(""String_Node_Str"",config);
  treeItem.addItem(anchor);
  tree.addItem(treeItem);
  return tree;
}",0.9443690637720488
50169,"public void onValueChange(final ValueChangeEvent event){
  String token=event.getValue().toString();
  onValueChangeHandler.handle(token);
}","public void onValueChange(final ValueChangeEvent event){
  ConfigLink config=(ConfigLink)event.getValue();
  onValueChangeHandler.handle(config);
}",0.8222996515679443
50170,"public void handle(ChangeEvent e){
  InstanceStatistics event=(InstanceStatistics)e;
  if (super.name == null || !super.name.equals(event.getName())) {
    return;
  }
  VerticalPanel vPanel=(VerticalPanel)disclosurePanel.getContent();
  Label label=(Label)vPanel.getWidget(0);
  label.setText(""String_Node_Str"" + event.getSize() + ""String_Node_Str""+ event.getTotalOPS());
  if (vPanel.getWidgetCount() < 2) {
    HorizontalPanel horizontalPanel=new HorizontalPanel();
    horizontalPanel.add(createAbsPanelWithImage());
    horizontalPanel.add(createAbsPanelWithImage());
    horizontalPanel.setBorderWidth(0);
    vPanel.add(horizontalPanel);
  }
  HorizontalPanel horizontalPanel=(HorizontalPanel)vPanel.getWidget(1);
  Image sizeChart=(Image)((AbsolutePanel)horizontalPanel.getWidget(0)).getWidget(0);
  sizeChart.setUrl(getServletName() + ""String_Node_Str"" + name+ ""String_Node_Str""+ Math.random() * 10);
  Image opsChart=(Image)((AbsolutePanel)horizontalPanel.getWidget(1)).getWidget(0);
  opsChart.setUrl(getServletName() + ""String_Node_Str"" + name+ ""String_Node_Str""+ Math.random() * 10);
}","public void handle(ChangeEvent e){
  InstanceStatistics event=(InstanceStatistics)e;
  if (super.name == null || !super.name.equals(event.getName())) {
    return;
  }
  VerticalPanel vPanel=(VerticalPanel)disclosurePanel.getContent();
  Label label=(Label)vPanel.getWidget(0);
  label.setText(""String_Node_Str"" + event.getSize() + ""String_Node_Str""+ event.getTotalOPS());
  if (vPanel.getWidgetCount() < 2) {
    HorizontalPanel horizontalPanel=new HorizontalPanel();
    horizontalPanel.add(createAbsPanelWithImage());
    horizontalPanel.add(createAbsPanelWithImage());
    horizontalPanel.setBorderWidth(0);
    vPanel.add(horizontalPanel);
  }
  HorizontalPanel horizontalPanel=(HorizontalPanel)vPanel.getWidget(1);
  Image sizeChart=(Image)((AbsolutePanel)horizontalPanel.getWidget(0)).getWidget(0);
  String encodeName=URL.encodeComponent(name);
  sizeChart.setUrl(getServletName() + ""String_Node_Str"" + encodeName+ ""String_Node_Str""+ Math.random() * 10);
  Image opsChart=(Image)((AbsolutePanel)horizontalPanel.getWidget(1)).getWidget(0);
  opsChart.setUrl(getServletName() + ""String_Node_Str"" + encodeName+ ""String_Node_Str""+ Math.random() * 10);
}",0.9720620842572062
50171,"public void handle(String token){
  Map<String,String> map=parseParamString(token);
  String name=map.get(""String_Node_Str"");
  int clusterId=Integer.valueOf(map.get(""String_Node_Str""));
  String type=map.get(""String_Node_Str"");
  hazelcastMonitor.closeClusterAddPanel();
  deRegisterAllActivePanels();
  ClusterWidgets clusterWidgets=hazelcastMonitor.getMapClusterWidgets().get(clusterId);
  PageBuilder pageBuilder=mapPageBuilders.get(type);
  pageBuilder.buildPage(clusterWidgets,name,new RegisterEventCallBack(hazelcastMonitor),servicesFactory);
}","public void handle(ConfigLink intanceLink){
  hazelcastMonitor.closeClusterAddPanel();
  deRegisterAllActivePanels();
  ClusterWidgets clusterWidgets=hazelcastMonitor.getMapClusterWidgets().get(intanceLink.getClusterId());
  PageBuilder pageBuilder=mapPageBuilders.get(intanceLink.getType());
  pageBuilder.buildPage(clusterWidgets,intanceLink.getName(),new RegisterEventCallBack(hazelcastMonitor),servicesFactory);
}",0.2024793388429752
50172,"@Test public void testMapPage() throws Exception {
  HazelcastServiceAsync hazelcastService=mock(HazelcastServiceAsync.class);
  ServicesFactory servicesFactory=mock(ServicesFactory.class);
  when(servicesFactory.getHazelcastService()).thenReturn(hazelcastService);
  HazelcastMonitor hazelcastMonitor=mock(HazelcastMonitor.class);
  Map<Integer,ClusterWidgets> mapOfCLusterWidgets=new HashMap<Integer,ClusterWidgets>();
  ClusterWidgets clusterWidgets=mock(ClusterWidgets.class);
  mapOfCLusterWidgets.put(0,clusterWidgets);
  when(hazelcastMonitor.getMapClusterWidgets()).thenReturn(mapOfCLusterWidgets);
  OnValueChangeHandler handler=new OnValueChangeHandler(servicesFactory,hazelcastMonitor);
  String token=""String_Node_Str"";
  handler.mapPageBuilders.clear();
  PageBuilder pageBuilder=mock(PageBuilder.class);
  handler.mapPageBuilders.put(""String_Node_Str"",pageBuilder);
  handler.handle(token);
  verify(pageBuilder,times(1)).buildPage(eq(clusterWidgets),eq(""String_Node_Str""),any(AsyncCallback.class),eq(servicesFactory));
  verify(clusterWidgets,times(1)).deRegisterAll();
}","@Test public void testMapPage() throws Exception {
  HazelcastServiceAsync hazelcastService=mock(HazelcastServiceAsync.class);
  ServicesFactory servicesFactory=mock(ServicesFactory.class);
  when(servicesFactory.getHazelcastService()).thenReturn(hazelcastService);
  HazelcastMonitor hazelcastMonitor=mock(HazelcastMonitor.class);
  Map<Integer,ClusterWidgets> mapOfCLusterWidgets=new HashMap<Integer,ClusterWidgets>();
  ClusterWidgets clusterWidgets=mock(ClusterWidgets.class);
  mapOfCLusterWidgets.put(0,clusterWidgets);
  when(hazelcastMonitor.getMapClusterWidgets()).thenReturn(mapOfCLusterWidgets);
  OnValueChangeHandler handler=new OnValueChangeHandler(servicesFactory,hazelcastMonitor);
  ConfigLink configLink=new ConfigLink();
  configLink.setClusterId(0);
  configLink.setType(""String_Node_Str"");
  configLink.setName(""String_Node_Str"");
  handler.mapPageBuilders.clear();
  PageBuilder pageBuilder=mock(PageBuilder.class);
  handler.mapPageBuilders.put(""String_Node_Str"",pageBuilder);
  handler.handle(configLink);
  verify(pageBuilder,times(1)).buildPage(eq(clusterWidgets),eq(""String_Node_Str""),any(AsyncCallback.class),eq(servicesFactory));
  verify(clusterWidgets,times(1)).deRegisterAll();
}",0.9325206791467132
50173,"void destroyInstanceClusterWide(String name,Object key){
  final ProxyKey proxyKey=new ProxyKey(name,key);
  if (proxies.containsKey(proxyKey)) {
    if (name.equals(""String_Node_Str"")) {
      locksMapProxy.remove(key);
    }
 else     if (name.startsWith(Prefix.IDGEN)) {
      idGeneratorMapProxy.remove(name);
    }
    globalProxies.remove(proxyKey);
    final BlockingQueue<Object> result=ResponseQueueFactory.newResponseQueue();
    node.clusterService.enqueueAndReturn(new Processable(){
      public void process(){
        try {
          destroyProxy(proxyKey);
          result.put(Boolean.TRUE);
        }
 catch (        Exception e) {
        }
      }
    }
);
    try {
      result.take();
    }
 catch (    InterruptedException e) {
    }
  }
}","void destroyInstanceClusterWide(String name,Object key){
  final ProxyKey proxyKey=new ProxyKey(name,key);
  if (proxies.containsKey(proxyKey)) {
    if (name.equals(""String_Node_Str"")) {
      locksMapProxy.remove(key);
    }
 else     if (name.startsWith(Prefix.IDGEN)) {
      idGeneratorMapProxy.remove(name);
    }
    globalProxies.remove(proxyKey);
    node.clusterService.enqueueAndWait(new Processable(){
      public void process(){
        try {
          destroyProxy(proxyKey);
        }
 catch (        Exception e) {
        }
      }
    }
,5);
  }
 else {
    logger.log(Level.WARNING,""String_Node_Str"" + name);
  }
}",0.7172512526843235
50174,"/** 
 * Detaches this member from the cluster first and then restarts it as a new member.
 * @see #getLifecycleService()
 * @deprecated as of version 1.9
 */
public static void restart(){
synchronized (initLock) {
    if (defaultInstance != null) {
    }
 else {
      getDefaultInstance();
    }
  }
}","/** 
 * Detaches this member from the cluster first and then restarts it as a new member.
 * @see #getLifecycleService()
 * @deprecated as of version 1.9
 */
public static void restart(){
synchronized (initLock) {
    if (defaultInstance.get() != null) {
      getLifecycleService().restart();
    }
 else {
      getDefaultInstance();
    }
  }
}",0.930662557781202
50175,"/** 
 * Detaches this member from the cluster. It doesn't shutdown the entire cluster, it shuts down this local member only.
 * @see #getLifecycleService()
 * @deprecated as of version 1.9
 */
public static void shutdown(){
synchronized (initLock) {
    if (defaultInstance != null) {
      getDefaultInstance().shutdown();
      defaultInstance.set(null);
    }
  }
}","/** 
 * Detaches this member from the cluster. It doesn't shutdown the entire cluster, it shuts down this local member only.
 * @see #getLifecycleService()
 * @deprecated as of version 1.9
 */
public static void shutdown(){
synchronized (initLock) {
    if (defaultInstance.get() != null) {
      getDefaultInstance().shutdown();
      defaultInstance.set(null);
    }
  }
}",0.9919137466307276
50176,"long doLongAtomic(){
  setLocal(op,""String_Node_Str"",nameAsKey,null,0,0);
  request.longValue=value;
  doOp();
  Object returnObject=getResultAsObject();
  if (returnObject instanceof AddressAwareException) {
    rethrowException(op,(AddressAwareException)returnObject);
  }
  return (Long)returnObject;
}","long doLongAtomic(){
  setLocal(op,""String_Node_Str"",nameAsKey,null,0,0);
  request.longValue=value;
  doOp();
  Object returnObject=getResultAsObject();
  return (Long)returnObject;
}",0.7525562372188139
50177,"private Object txnalReplaceIfSame(ClusterOperation operation,String name,Object key,Object newValue,Object expectedValue,long timeout){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=toObject(oldValue);
      }
      if (oldObject == null) {
        return Boolean.FALSE;
      }
 else {
        if (expectedValue.equals(oldValue)) {
          txn.attachPutOp(name,key,newValue,false);
          return Boolean.TRUE;
        }
 else {
          return Boolean.FALSE;
        }
      }
    }
 else {
      if (expectedValue.equals(txn.get(name,key))) {
        txn.attachPutOp(name,key,newValue,false);
        return Boolean.TRUE;
      }
 else {
        return Boolean.FALSE;
      }
    }
  }
 else {
    Data dataExpected=toData(expectedValue);
    Data dataNew=toData(newValue);
    setLocal(operation,name,key,new MultiData(dataExpected,dataNew),timeout,-1);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : dataNew.hashCode();
    setIndexValues(request,newValue);
    request.setBooleanRequest();
    doOp();
    Object returnObject=getResultAsBoolean();
    if (returnObject instanceof AddressAwareException) {
      rethrowException(operation,(AddressAwareException)returnObject);
    }
    if (!Boolean.FALSE.equals(returnObject)) {
      request.value=dataNew;
      backup(CONCURRENT_MAP_BACKUP_PUT);
    }
    return returnObject;
  }
}","private Object txnalReplaceIfSame(ClusterOperation operation,String name,Object key,Object newValue,Object expectedValue,long timeout){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=toObject(oldValue);
      }
      if (oldObject == null) {
        return Boolean.FALSE;
      }
 else {
        if (expectedValue.equals(oldValue)) {
          txn.attachPutOp(name,key,newValue,false);
          return Boolean.TRUE;
        }
 else {
          return Boolean.FALSE;
        }
      }
    }
 else {
      if (expectedValue.equals(txn.get(name,key))) {
        txn.attachPutOp(name,key,newValue,false);
        return Boolean.TRUE;
      }
 else {
        return Boolean.FALSE;
      }
    }
  }
 else {
    Data dataExpected=toData(expectedValue);
    Data dataNew=toData(newValue);
    setLocal(operation,name,key,new MultiData(dataExpected,dataNew),timeout,-1);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : dataNew.hashCode();
    setIndexValues(request,newValue);
    request.setBooleanRequest();
    doOp();
    Object returnObject=getResultAsBoolean();
    if (!Boolean.FALSE.equals(returnObject)) {
      request.value=dataNew;
      backup(CONCURRENT_MAP_BACKUP_PUT);
    }
    return returnObject;
  }
}",0.9614277489925158
50178,"public Q(String name){
  QueueConfig qconfig=node.getConfig().getQueueConfig(name.substring(Prefix.QUEUE.length()));
  maxSizePerJVM=(qconfig.getMaxSizePerJVM() == 0) ? QueueConfig.DEFAULT_MAX_SIZE_PER_JVM : qconfig.getMaxSizePerJVM();
  maxAge=(qconfig.getTimeToLiveSeconds() == 0) ? QueueConfig.DEFAULT_TTL_SECONDS : TimeUnit.SECONDS.toMillis(qconfig.getTimeToLiveSeconds());
  logger.log(Level.FINEST,name + ""String_Node_Str"" + maxSizePerJVM);
  logger.log(Level.FINEST,name + ""String_Node_Str"" + maxAge);
  this.name=name;
  final int blocksLimit=10;
  lsBlocks=new ArrayList<Block>(blocksLimit);
  Address master=getMasterAddress();
  if (master == null) {
    throw new IllegalStateException(""String_Node_Str"" + master);
  }
  if (master.isThisAddress()) {
    Block block=createBlock(master,0);
    addBlock(block);
    sendAddBlockMessageToOthers(block,-1,null,true);
    for (int i=1; i < blocksLimit; i++) {
      int blockId=i;
      Address target=nextTarget();
      block=createBlock(target,blockId);
      addBlock(block);
      sendAddBlockMessageToOthers(block,-1,null,true);
    }
  }
}","public Q(String name){
  QueueConfig qconfig=node.getConfig().getQueueConfig(name.substring(Prefix.QUEUE.length()));
  maxSizePerJVM=(qconfig.getMaxSizePerJVM() == 0) ? Integer.MAX_VALUE : qconfig.getMaxSizePerJVM();
  maxAge=(qconfig.getTimeToLiveSeconds() == 0) ? QueueConfig.DEFAULT_TTL_SECONDS : TimeUnit.SECONDS.toMillis(qconfig.getTimeToLiveSeconds());
  logger.log(Level.FINEST,name + ""String_Node_Str"" + maxSizePerJVM);
  logger.log(Level.FINEST,name + ""String_Node_Str"" + maxAge);
  this.name=name;
  final int blocksLimit=10;
  lsBlocks=new ArrayList<Block>(blocksLimit);
  Address master=getMasterAddress();
  if (master == null) {
    throw new IllegalStateException(""String_Node_Str"" + master);
  }
  if (master.isThisAddress()) {
    Block block=createBlock(master,0);
    addBlock(block);
    sendAddBlockMessageToOthers(block,-1,null,true);
    for (int i=1; i < blocksLimit; i++) {
      int blockId=i;
      Address target=nextTarget();
      block=createBlock(target,blockId);
      addBlock(block);
      sendAddBlockMessageToOthers(block,-1,null,true);
    }
  }
}",0.9803563270899954
50179,"public Q(String name){
  QueueConfig qconfig=node.getConfig().getQueueConfig(name.substring(Prefix.QUEUE.length()));
  maxSizePerJVM=(qconfig.getMaxSizePerJVM() == 0) ? Integer.MAX_VALUE : qconfig.getMaxSizePerJVM();
  maxAge=(qconfig.getTimeToLiveSeconds() == 0) ? QueueConfig.DEFAULT_TTL_SECONDS : TimeUnit.SECONDS.toMillis(qconfig.getTimeToLiveSeconds());
  logger.log(Level.FINEST,name + ""String_Node_Str"" + maxSizePerJVM);
  logger.log(Level.FINEST,name + ""String_Node_Str"" + maxAge);
  this.name=name;
  final int blocksLimit=10;
  lsBlocks=new ArrayList<Block>(blocksLimit);
  Address master=getMasterAddress();
  if (master == null) {
    throw new IllegalStateException(""String_Node_Str"" + master);
  }
  if (master.isThisAddress()) {
    Block block=createBlock(master,0);
    addBlock(block);
    sendAddBlockMessageToOthers(block,-1,null,true);
    for (int i=1; i < blocksLimit; i++) {
      int blockId=i;
      Address target=nextTarget();
      block=createBlock(target,blockId);
      addBlock(block);
      sendAddBlockMessageToOthers(block,-1,null,true);
    }
  }
}","public Q(String name){
  QueueConfig qconfig=node.getConfig().getQueueConfig(name.substring(Prefix.QUEUE.length()));
  maxSizePerJVM=(qconfig.getMaxSizePerJVM() == 0) ? Integer.MAX_VALUE : qconfig.getMaxSizePerJVM();
  maxAge=(qconfig.getTimeToLiveSeconds() == 0) ? Integer.MAX_VALUE : TimeUnit.SECONDS.toMillis(qconfig.getTimeToLiveSeconds());
  logger.log(Level.FINEST,name + ""String_Node_Str"" + maxSizePerJVM);
  logger.log(Level.FINEST,name + ""String_Node_Str"" + maxAge);
  this.name=name;
  final int blocksLimit=10;
  lsBlocks=new ArrayList<Block>(blocksLimit);
  Address master=getMasterAddress();
  if (master == null) {
    throw new IllegalStateException(""String_Node_Str"" + master);
  }
  if (master.isThisAddress()) {
    Block block=createBlock(master,0);
    addBlock(block);
    sendAddBlockMessageToOthers(block,-1,null,true);
    for (int i=1; i < blocksLimit; i++) {
      int blockId=i;
      Address target=nextTarget();
      block=createBlock(target,blockId);
      addBlock(block);
      sendAddBlockMessageToOthers(block,-1,null,true);
    }
  }
}",0.9684601113172542
50180,"void reset(){
  if (locallyOwnedMap != null) {
    locallyOwnedMap.reset();
  }
  mapRecords.clear();
  mapIndexService.clear();
}","void reset(){
  if (locallyOwnedMap != null) {
    locallyOwnedMap.reset();
  }
  if (mapNearCache != null) {
    mapNearCache.reset();
  }
  mapRecords.clear();
  mapIndexService.clear();
}",0.8125
50181,"public Object get(String name,Object key,long timeout){
  this.key=key;
  final ThreadContext tc=ThreadContext.get();
  TransactionImpl txn=tc.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (txn.has(name,key)) {
      return txn.get(name,key);
    }
  }
  nearCache=mapCaches.get(name);
  if (nearCache != null) {
    Object value=nearCache.get(key);
    if (value != null) {
      return value;
    }
  }
  LocallyOwnedMap locallyOwnedMap=mapLocallyOwnedMaps.get(name);
  if (locallyOwnedMap != null) {
    Object value=locallyOwnedMap.get(key);
    if (value != OBJECT_REDO) {
      return value;
    }
  }
  final CMap cMap=maps.get(name);
  if (cMap != null && cMap.useBackupData) {
    final Data dataKey=toData(key);
    final Record record=cMap.mapRecords.get(dataKey);
    if (record != null && record.isActive() && record.isValid()) {
      final Data valueData=record.getValue();
      if (valueData != null) {
        return toObject(valueData);
      }
    }
  }
  Object value=objectCall(CONCURRENT_MAP_GET,name,key,null,timeout,-1);
  if (value instanceof AddressAwareException) {
    rethrowException(request.operation,(AddressAwareException)value);
  }
  return value;
}","public Object get(String name,Object key,long timeout){
  this.keyObject=key;
  final ThreadContext tc=ThreadContext.get();
  TransactionImpl txn=tc.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (txn.has(name,key)) {
      return txn.get(name,key);
    }
  }
  nearCache=mapCaches.get(name);
  if (nearCache != null) {
    Object value=nearCache.get(key);
    if (value != null) {
      return value;
    }
  }
  LocallyOwnedMap locallyOwnedMap=mapLocallyOwnedMaps.get(name);
  if (locallyOwnedMap != null) {
    Object value=locallyOwnedMap.get(key);
    if (value != OBJECT_REDO) {
      return value;
    }
  }
  final CMap cMap=maps.get(name);
  if (cMap != null && cMap.useBackupData) {
    final Data dataKey=toData(key);
    final Record record=cMap.mapRecords.get(dataKey);
    if (record != null && record.isActive() && record.isValid()) {
      final Data valueData=record.getValue();
      if (valueData != null) {
        return toObject(valueData);
      }
    }
  }
  Object value=objectCall(CONCURRENT_MAP_GET,name,key,null,timeout,-1);
  if (value instanceof AddressAwareException) {
    rethrowException(request.operation,(AddressAwareException)value);
  }
  return value;
}",0.9976133651551312
50182,"@Override protected void setResult(Object obj){
  if (obj != null && obj == Boolean.TRUE) {
    if (nearCache != null) {
      nearCache.setContainsKey(key,request.key);
    }
  }
  super.setResult(obj);
}","@Override protected void setResult(Object obj){
  if (obj != null && obj == Boolean.TRUE) {
    if (nearCache != null) {
      nearCache.setContainsKey(keyObject,request.key);
    }
  }
  super.setResult(obj);
}",0.9855769230769232
50183,"public boolean containsKey(String name,Object key){
  this.key=key;
  this.nearCache=mapCaches.get(name);
  Data dataKey=toData(key);
  if (nearCache != null) {
    if (nearCache.containsKey(key)) {
      return true;
    }
 else     if (nearCache.getMaxSize() == Integer.MAX_VALUE) {
      return false;
    }
  }
  final CMap cMap=maps.get(name);
  if (cMap != null && cMap.useBackupData) {
    final Record record=cMap.mapRecords.get(dataKey);
    if (record != null && record.isActive() && record.isValid() && record.getValue() != null) {
      return true;
    }
  }
  return booleanCall(CONCURRENT_MAP_CONTAINS,name,dataKey,null,0,-1);
}","public boolean containsKey(String name,Object key){
  this.keyObject=key;
  this.nearCache=mapCaches.get(name);
  Data dataKey=toData(key);
  if (nearCache != null) {
    if (nearCache.containsKey(key)) {
      return true;
    }
 else     if (nearCache.getMaxSize() == Integer.MAX_VALUE) {
      return false;
    }
  }
  final CMap cMap=maps.get(name);
  if (cMap != null && cMap.useBackupData) {
    final Record record=cMap.mapRecords.get(dataKey);
    if (record != null && record.isActive() && record.isValid() && record.getValue() != null) {
      return true;
    }
  }
  return booleanCall(CONCURRENT_MAP_CONTAINS,name,dataKey,null,0,-1);
}",0.9953560371517028
50184,"private CacheEntry(Object key,Data keyData,Data valueData){
  if (key == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (keyData == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (valueData == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  this.key=key;
  this.keyData=keyData;
  this.valueData=valueData;
  this.createTime=System.currentTimeMillis();
  touch(createTime);
}","private CacheEntry(Object key,Data keyData,Data valueData){
  if (key == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (keyData == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  this.key=key;
  this.keyData=keyData;
  this.valueData=valueData;
  this.createTime=System.currentTimeMillis();
  touch(createTime);
}",0.5869297163995068
50185,"public void put(Object key,Data keyData,Data value){
  checkThread();
  if (cache.size() != sortedMap.size()) {
    throw new IllegalStateException(""String_Node_Str"" + cache.size() + ""String_Node_Str""+ sortedMap.size());
  }
  if (cache.size() + 1 >= maxSize) {
    startEviction();
  }
  if (cache.size() + 1 >= maxSize) {
    return;
  }
  if (!sortedMap.containsKey(keyData)) {
    sortedMap.put(keyData,key);
    cache.put(key,new CacheEntry(key,keyData,value));
  }
}","public void put(Object key,Data keyData,Data value){
  checkThread();
  if (cache.size() != sortedMap.size()) {
    throw new IllegalStateException(""String_Node_Str"" + cache.size() + ""String_Node_Str""+ sortedMap.size());
  }
  if (cache.size() + 1 >= maxSize) {
    startEviction();
  }
  if (cache.size() + 1 >= maxSize) {
    return;
  }
  if (!sortedMap.containsKey(keyData)) {
    sortedMap.put(keyData,key);
  }
  CacheEntry cacheEntry=cache.get(key);
  if (cacheEntry == null) {
    cacheEntry=new CacheEntry(key,keyData,value);
  }
 else {
    cacheEntry.setValue(value);
  }
  cache.put(key,cacheEntry);
}",0.8387096774193549
50186,"private void postJoin(){
  if (!isMaster()) {
    Set<Member> members=null;
    boolean allConnected=false;
    int checkCount=0;
    while (checkCount++ < 10 && !allConnected) {
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException ignored) {
      }
      members=clusterImpl.getMembers();
      allConnected=true;
      for (      Member member : members) {
        MemberImpl memberImpl=(MemberImpl)member;
        if (!memberImpl.localMember() && connectionManager.getConnection(memberImpl.getAddress()) == null) {
          allConnected=false;
        }
      }
    }
    if (!allConnected) {
      logger.log(Level.WARNING,""String_Node_Str"" + checkCount + ""String_Node_Str"");
      logger.log(Level.WARNING,""String_Node_Str"");
      try {
        Thread.sleep(10000);
      }
 catch (      InterruptedException e) {
        shutdown();
      }
      rejoin();
    }
 else {
      clusterManager.finalizeJoin();
      clusterManager.enqueueAndWait(new Processable(){
        public void process(){
          if (baseVariables.lsMembers.size() == 1) {
            final StringBuilder sb=new StringBuilder();
            sb.append(""String_Node_Str"");
            sb.append(clusterManager);
            logger.log(Level.INFO,sb.toString());
          }
        }
      }
,5);
    }
  }
}","private void postJoin(){
  if (!isMaster()) {
    Set<Member> members=null;
    boolean allConnected=false;
    int checkCount=0;
    while (checkCount++ < 10 && !allConnected) {
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException ignored) {
      }
      members=clusterImpl.getMembers();
      allConnected=true;
      for (      Member member : members) {
        MemberImpl memberImpl=(MemberImpl)member;
        if (!memberImpl.localMember() && connectionManager.getConnection(memberImpl.getAddress()) == null) {
          allConnected=false;
        }
      }
    }
    if (!allConnected) {
      logger.log(Level.WARNING,""String_Node_Str"" + checkCount + ""String_Node_Str"");
      logger.log(Level.WARNING,""String_Node_Str"");
      try {
        Thread.sleep(10000);
      }
 catch (      InterruptedException e) {
        shutdown();
      }
      rejoin();
      return;
    }
 else {
      clusterManager.finalizeJoin();
    }
  }
  clusterManager.enqueueAndWait(new Processable(){
    public void process(){
      if (baseVariables.lsMembers.size() == 1) {
        final StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(clusterManager);
        logger.log(Level.INFO,sb.toString());
      }
    }
  }
,5);
}",0.9678407350689128
50187,"@Test public void testIdle() throws Exception {
  Config config=new XmlConfigBuilder().build();
  MapConfig mapConfig=config.getMapConfig(""String_Node_Str"");
  mapConfig.setMaxIdleSeconds(3);
  mapConfig.setEvictionDelaySeconds(10);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  Map map=h1.getMap(""String_Node_Str"");
  map.put(1,1);
  assertEquals(1,map.get(1));
  sleep(2000);
  assertEquals(1,map.get(1));
  sleep(2000);
  assertEquals(1,map.get(1));
  sleep(4000);
  assertNull(map.get(1));
  assertEquals(0,map.size());
}","@Test public void testIdle() throws Exception {
  Config config=new Config();
  MapConfig mapConfig=config.getMapConfig(""String_Node_Str"");
  mapConfig.setMaxIdleSeconds(3);
  mapConfig.setEvictionDelaySeconds(10);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  Map map=h1.getMap(""String_Node_Str"");
  map.put(1,1);
  assertEquals(1,map.get(1));
  sleep(2000);
  assertEquals(1,map.get(1));
  sleep(2000);
  assertEquals(1,map.get(1));
  sleep(4000);
  assertNull(map.get(1));
  assertEquals(0,map.size());
}",0.97196261682243
50188,"@Test(timeout=60000) public void testTcpIpWithDifferentBuildNumber() throws Exception {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  Config c=new XmlConfigBuilder().build();
  c.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);
  c.getNetworkConfig().getJoin().getTcpIpConfig().setEnabled(true);
  c.getNetworkConfig().getInterfaces().setEnabled(true);
  c.getNetworkConfig().getJoin().getTcpIpConfig().addAddress(new Address(""String_Node_Str"",5701));
  c.getNetworkConfig().getInterfaces().addInterface(""String_Node_Str"");
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(c);
  assertEquals(1,h1.getCluster().getMembers().size());
  h1.getMap(""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",h1.getMap(""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str""));
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(c);
  assertEquals(1,h1.getCluster().getMembers().size());
  assertEquals(1,h2.getCluster().getMembers().size());
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
}","@Test(timeout=60000) public void testTcpIpWithDifferentBuildNumber() throws Exception {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  Config c=new Config();
  c.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);
  c.getNetworkConfig().getJoin().getTcpIpConfig().setEnabled(true);
  c.getNetworkConfig().getInterfaces().setEnabled(true);
  c.getNetworkConfig().getJoin().getTcpIpConfig().addAddress(new Address(""String_Node_Str"",5701));
  c.getNetworkConfig().getInterfaces().addInterface(""String_Node_Str"");
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(c);
  assertEquals(1,h1.getCluster().getMembers().size());
  h1.getMap(""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",h1.getMap(""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str""));
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(c);
  assertEquals(1,h1.getCluster().getMembers().size());
  assertEquals(1,h2.getCluster().getMembers().size());
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
}",0.9867021276595744
50189,"@Test public void testSuperBeingMaster() throws Exception {
  Config config=new XmlConfigBuilder().build();
  config.setSuperClient(true);
  final HazelcastInstance hSuper=Hazelcast.newHazelcastInstance(config);
  final HazelcastInstance hSuper2=Hazelcast.newHazelcastInstance(config);
  sleep(11000);
  HazelcastInstance hNormal=Hazelcast.newHazelcastInstance(null);
  Map map=hSuper.getMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",hNormal.getMap(""String_Node_Str"").get(""String_Node_Str""));
  sleep(10000);
  assertEquals(""String_Node_Str"",hNormal.getMap(""String_Node_Str"").get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
}","@Test public void testSuperBeingMaster() throws Exception {
  Config config=new Config();
  config.setSuperClient(true);
  final HazelcastInstance hSuper=Hazelcast.newHazelcastInstance(config);
  final HazelcastInstance hSuper2=Hazelcast.newHazelcastInstance(config);
  sleep(11000);
  HazelcastInstance hNormal=Hazelcast.newHazelcastInstance(null);
  Map map=hSuper.getMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",hNormal.getMap(""String_Node_Str"").get(""String_Node_Str""));
  sleep(10000);
  assertEquals(""String_Node_Str"",hNormal.getMap(""String_Node_Str"").get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
}",0.9873949579831932
50190,"public Partition getPartition(Object key){
  return null;
}","public Partition getPartition(Object key){
  return (Partition)proxyHelper.doOp(ClusterOperation.CLIENT_GET_PARTITIONS,key,null);
}",0.6210526315789474
50191,"@Override protected void doParse(Element element,ParserContext parserContext,BeanDefinitionBuilder builder){
  super.doParse(element,parserContext,builder);
  XmlConfigBuilder util=new XmlConfigBuilder();
  Config config=util.build();
  try {
    for (    org.w3c.dom.Node node : new IterableNodeList(element.getChildNodes())) {
      final String nodeName=util.cleanNodeName(node.getNodeName());
      if (""String_Node_Str"".equals(nodeName)) {
        util.handleNetwork(node);
      }
 else       if (""String_Node_Str"".equals(nodeName)) {
        util.handleGroup(node);
      }
 else       if (""String_Node_Str"".equals(nodeName)) {
        util.handleProperties(node,config.getProperties());
      }
 else       if (""String_Node_Str"".equals(nodeName)) {
        util.handleExecutor(node);
      }
 else       if (""String_Node_Str"".equals(nodeName)) {
        util.handleQueue(node);
      }
 else       if (""String_Node_Str"".equals(nodeName)) {
        util.handleMap(node);
      }
 else       if (""String_Node_Str"".equals(nodeName)) {
        util.handleTopic(node);
      }
 else       if (""String_Node_Str"".equals(nodeName)) {
        util.handleMergePolicies(node);
      }
    }
  }
 catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"" + e.getMessage(),e);
  }
  builder.addPropertyValue(""String_Node_Str"",config.getNetworkConfig());
  builder.addPropertyValue(""String_Node_Str"",config.getGroupConfig());
  builder.addPropertyValue(""String_Node_Str"",config.getProperties());
  builder.addPropertyValue(""String_Node_Str"",config.getExecutorConfigMap());
  builder.addPropertyValue(""String_Node_Str"",config.getMapConfigs());
  builder.addPropertyValue(""String_Node_Str"",config.getQConfigs());
}","@Override protected void doParse(Element element,ParserContext parserContext,BeanDefinitionBuilder builder){
  super.doParse(element,parserContext,builder);
  XmlConfigBuilder util=new XmlConfigBuilder();
  Config config=util.build(element);
  builder.addPropertyValue(""String_Node_Str"",config.getPort());
  builder.addPropertyValue(""String_Node_Str"",config.isPortAutoIncrement());
  builder.addPropertyValue(""String_Node_Str"",config.isReuseAddress());
  builder.addPropertyValue(""String_Node_Str"",config.isSuperClient());
  builder.addPropertyValue(""String_Node_Str"",config.getNetworkConfig());
  builder.addPropertyValue(""String_Node_Str"",config.getGroupConfig());
  builder.addPropertyValue(""String_Node_Str"",config.getProperties());
  builder.addPropertyValue(""String_Node_Str"",config.getExecutorConfigMap());
  builder.addPropertyValue(""String_Node_Str"",config.getMapConfigs());
  builder.addPropertyValue(""String_Node_Str"",config.getQConfigs());
}",0.2866741321388578
50192,"@Test public void testNetworkConfig(){
  NetworkConfig networkConfig=config.getNetworkConfig();
  assertNotNull(networkConfig);
  assertFalse(networkConfig.getJoin().getMulticastConfig().isEnabled());
  TcpIpConfig tcp=networkConfig.getJoin().getTcpIpConfig();
  assertNotNull(tcp);
  assertTrue(tcp.isEnabled());
  assertTrue(networkConfig.getSymmetricEncryptionConfig().isEnabled());
}","@Test public void testNetworkConfig(){
  NetworkConfig networkConfig=config.getNetworkConfig();
  assertNotNull(networkConfig);
  assertEquals(5800,config.getPort());
  assertFalse(config.isPortAutoIncrement());
  assertFalse(networkConfig.getJoin().getMulticastConfig().isEnabled());
  TcpIpConfig tcp=networkConfig.getJoin().getTcpIpConfig();
  assertNotNull(tcp);
  assertTrue(tcp.isEnabled());
  assertTrue(networkConfig.getSymmetricEncryptionConfig().isEnabled());
  final List<String> members=tcp.getMembers();
  assertEquals(members.toString(),2,members.size());
  assertEquals(""String_Node_Str"",members.get(0));
  assertEquals(""String_Node_Str"",members.get(1));
}",0.7315689981096408
50193,"private static long getLongValueByType(Object value){
  if (value == null)   return Long.MAX_VALUE;
  if (value instanceof Double) {
    return Double.doubleToLongBits((Double)value);
  }
 else   if (value instanceof Float) {
    return Float.floatToIntBits((Float)value);
  }
 else   if (value instanceof Number) {
    return ((Number)value).longValue();
  }
 else   if (value instanceof Boolean) {
    return (Boolean.TRUE.equals(value)) ? 1 : -1;
  }
 else   if (value instanceof String) {
    String str=(String)value;
    if (str.length() == 0) {
      return 0;
    }
 else {
      return str.charAt(0);
    }
  }
 else {
    return value.hashCode();
  }
}","private static long getLongValueByType(Object value){
  if (value == null)   return Long.MAX_VALUE;
  if (value instanceof Double) {
    return Double.doubleToLongBits((Double)value);
  }
 else   if (value instanceof Float) {
    return Float.floatToIntBits((Float)value);
  }
 else   if (value instanceof Number) {
    return ((Number)value).longValue();
  }
 else   if (value instanceof Boolean) {
    return (Boolean.TRUE.equals(value)) ? 1 : -1;
  }
 else   if (value instanceof String) {
    return value.hashCode();
  }
 else {
    return value.hashCode();
  }
}",0.8552845528455284
50194,"long getLongValue(Object value){
  if (value == null)   return Long.MIN_VALUE;
  int valueType=getIndexType(value.getClass());
  if (valueType != returnType) {
    if (value instanceof String) {
      String str=(String)value;
      if (returnType == TYPE_INT) {
        value=Integer.valueOf(str);
      }
 else       if (returnType == TYPE_LONG) {
        value=Long.valueOf(str);
      }
 else       if (returnType == TYPE_BOOLEAN) {
        value=Boolean.valueOf(str);
      }
 else       if (returnType == TYPE_DOUBLE) {
        value=Double.valueOf(str);
      }
 else       if (returnType == TYPE_FLOAT) {
        value=Float.valueOf(str);
      }
 else       if (returnType == TYPE_BYTE) {
        value=Byte.valueOf(str);
      }
 else       if (returnType == TYPE_CLASS) {
        value=Character.valueOf(str.charAt(0));
      }
    }
  }
  return getLongValueByType(value);
}","long getLongValue(Object value){
  if (value == null)   return Long.MIN_VALUE;
  int valueType=getIndexType(value.getClass());
  if (valueType != returnType) {
    if (value instanceof String) {
      String str=(String)value;
      if (returnType == TYPE_INT) {
        value=Integer.valueOf(str);
      }
 else       if (returnType == TYPE_LONG) {
        value=Long.valueOf(str);
      }
 else       if (returnType == TYPE_BOOLEAN) {
        value=Boolean.valueOf(str);
      }
 else       if (returnType == TYPE_DOUBLE) {
        value=Double.valueOf(str);
      }
 else       if (returnType == TYPE_FLOAT) {
        value=Float.valueOf(str);
      }
 else       if (returnType == TYPE_BYTE) {
        value=Byte.valueOf(str);
      }
 else       if (returnType == TYPE_CLASS) {
        value=str.hashCode();
      }
    }
  }
  return getLongValueByType(value);
}",0.976054732041049
50195,"public InPredicate(Expression first,Object... second){
  this.first=first;
  this.values=second;
}","public InPredicate(Expression first,Object... second){
  this.first=first;
  this.inValues=new HashSet(second.length);
  for (  Object o : second) {
    inValues.add(o);
  }
  this.inValueArray=second;
}",0.5913621262458472
50196,"public static Object getRealObject(Object type,String value){
  Object result=null;
  if (type instanceof Boolean) {
    result=""String_Node_Str"".equalsIgnoreCase(value) ? true : false;
  }
 else   if (type instanceof Integer) {
    result=Integer.valueOf(value);
  }
 else   if (type instanceof Double) {
    result=Double.valueOf(value);
  }
 else   if (type instanceof Float) {
    result=Float.valueOf(value);
  }
 else   if (type instanceof Byte) {
    result=Byte.valueOf(value);
  }
 else   if (type instanceof Long) {
    result=Long.valueOf(value);
  }
 else {
    System.out.println(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"" + type.getClass() + ""String_Node_Str""+ value);
  }
  return result;
}","public static Object getRealObject(Object type,String value){
  Object result=null;
  if (type instanceof Boolean) {
    result=""String_Node_Str"".equalsIgnoreCase(value) ? true : false;
  }
 else   if (type instanceof Integer) {
    result=Integer.valueOf(value);
  }
 else   if (type instanceof Double) {
    result=Double.valueOf(value);
  }
 else   if (type instanceof Float) {
    result=Float.valueOf(value);
  }
 else   if (type instanceof Byte) {
    result=Byte.valueOf(value);
  }
 else   if (type instanceof Long) {
    result=Long.valueOf(value);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + type.getClass() + ""String_Node_Str""+ value);
  }
  return result;
}",0.8639887244538408
50197,"public Object objectCall(final ClusterOperation operation,final String name,final Object key,final Object value,final long timeout,final long ttl){
  setLocal(operation,name,key,value,timeout,ttl);
  request.setObjectRequest();
  return objectCall();
}","public Object objectCall(final ClusterOperation operation,final String name,final Object key,final Object value,final long timeout,final long ttl){
  setLocal(operation,name,key,value,timeout,ttl);
  return objectCall();
}",0.9367088607594936
50198,"public int compare(MapEntry o1,MapEntry o2){
  int result=comparator.compare(o1,o2);
  if (result == 0) {
    Record r1=(Record)o1;
    Record r2=(Record)o2;
    return (r1.getId() > r2.getId()) ? 1 : -1;
  }
 else {
    return result;
  }
}","public int compare(MapEntry o1,MapEntry o2){
  int result=comparator.compare(o1,o2);
  if (result == 0) {
    Record r1=(Record)o1;
    Record r2=(Record)o2;
    return r1.getId().compareTo(r2.getId());
  }
 else {
    return result;
  }
}",0.95
50199,"void setIndexValues(Request request,Object value){
  CMap cmap=getMap(request.name);
  if (cmap != null) {
    long[] indexes=cmap.getMapIndexService().getIndexValues(value);
    if (indexes != null) {
      byte[] indexTypes=cmap.getMapIndexService().getIndexTypes();
      request.setIndexes(indexes,indexTypes);
      for (      byte b : indexTypes) {
        if (b == -1) {
          throw new RuntimeException(""String_Node_Str"" + b);
        }
      }
    }
  }
}","void setIndexValues(Request request,Object value){
  CMap cmap=getMap(request.name);
  if (cmap != null) {
    Long[] indexes=cmap.getMapIndexService().getIndexValues(value);
    if (indexes != null) {
      byte[] indexTypes=cmap.getMapIndexService().getIndexTypes();
      request.setIndexes(indexes,indexTypes);
      for (      byte b : indexTypes) {
        if (b == -1) {
          throw new RuntimeException(""String_Node_Str"" + b);
        }
      }
    }
  }
}",0.997863247863248
50200,"public void setIndexes(long[] indexes,byte[] indexTypes){
  if (indexes != null) {
    this.getOptionalInfo().indexes=indexes;
    this.getOptionalInfo().indexTypes=indexTypes;
  }
}","public void setIndexes(Long[] indexes,byte[] indexTypes){
  if (indexes != null) {
    this.getOptionalInfo().indexes=indexes;
    this.getOptionalInfo().indexTypes=indexTypes;
  }
}",0.9945054945054944
50201,"public long getId(){
  return id;
}","public Long getId(){
  return id;
}",0.9714285714285714
50202,"@Override public int hashCode(){
  return (int)(id ^ (id >>> 32));
}","@Override public int hashCode(){
  return id.hashCode();
}",0.7777777777777778
50203,"public Record(CMap cmap,int blockId,Data key,Data value,long ttl,long maxIdleMillis,long id){
  super();
  this.id=id;
  this.cmap=cmap;
  this.blockId=(short)blockId;
  this.key=key;
  this.value=value;
  this.setCreationTime(System.currentTimeMillis());
  this.setExpirationTime(ttl);
  this.maxIdleMillis=(maxIdleMillis == 0) ? Long.MAX_VALUE : maxIdleMillis;
  this.setVersion(0);
}","public Record(CMap cmap,int blockId,Data key,Data value,long ttl,long maxIdleMillis,Long id){
  super();
  this.id=id;
  this.cmap=cmap;
  this.blockId=(short)blockId;
  this.key=key;
  this.value=value;
  this.setCreationTime(System.currentTimeMillis());
  this.setExpirationTime(ttl);
  this.maxIdleMillis=(maxIdleMillis == 0) ? Long.MAX_VALUE : maxIdleMillis;
  this.setVersion(0);
}",0.9974093264248703
50204,"public long[] getIndexes(){
  if (optionalInfo == null)   return null;
  return getOptionalInfo().indexes;
}","public Long[] getIndexes(){
  if (optionalInfo == null)   return null;
  return getOptionalInfo().indexes;
}",0.9907407407407408
50205,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  Record record=(Record)o;
  return (record.getId() == getId());
}","@Override public boolean equals(Object o){
  if (this == o)   return true;
  if ((o instanceof Record))   return false;
  Record record=(Record)o;
  return record.getId().equals(getId());
}",0.8447837150127226
50206,"public void setIndexes(long[] newIndexes,byte[] indexTypes){
  this.indexes=newIndexes;
  this.indexTypes=indexTypes;
  if (indexes.length != indexTypes.length) {
    throw new RuntimeException(""String_Node_Str"" + indexes.length + ""String_Node_Str""+ indexTypes.length);
  }
}","public void setIndexes(Long[] newIndexes,byte[] indexTypes){
  this.indexes=newIndexes;
  this.indexTypes=indexTypes;
  if (indexes.length != indexTypes.length) {
    throw new RuntimeException(""String_Node_Str"" + indexes.length + ""String_Node_Str""+ indexTypes.length);
  }
}",0.9963636363636365
50207,"public void readData(DataInput in) throws IOException {
  long now=System.currentTimeMillis();
  cost=in.readLong();
  expirationTime=in.readLong() + now;
  lastAccessTime=in.readLong() + now;
  lastUpdateTime=in.readLong() + now;
  creationTime=in.readLong() + now;
  version=in.readLong();
  hits=in.readInt();
  name=in.readUTF();
  keyData=new Data();
  keyData.readData(in);
  valueData=new Data();
  valueData.readData(in);
  byte indexCount=in.readByte();
  if (indexCount > 0) {
    indexes=new long[indexCount];
    indexTypes=new byte[indexCount];
    for (byte i=0; i < indexCount; i++) {
      indexes[i]=in.readLong();
      indexTypes[i]=in.readByte();
    }
  }
}","public void readData(DataInput in) throws IOException {
  long now=System.currentTimeMillis();
  cost=in.readLong();
  expirationTime=in.readLong() + now;
  lastAccessTime=in.readLong() + now;
  lastUpdateTime=in.readLong() + now;
  creationTime=in.readLong() + now;
  version=in.readLong();
  hits=in.readInt();
  name=in.readUTF();
  keyData=new Data();
  keyData.readData(in);
  valueData=new Data();
  valueData.readData(in);
  byte indexCount=in.readByte();
  if (indexCount > 0) {
    indexes=new Long[indexCount];
    indexTypes=new byte[indexCount];
    for (byte i=0; i < indexCount; i++) {
      indexes[i]=in.readLong();
      indexTypes[i]=in.readByte();
    }
  }
}",0.9985250737463128
50208,"public long extractLongValue(Object value){
  Object extractedValue=expression.getValue(value);
  if (extractedValue == null) {
    return Long.MAX_VALUE;
  }
 else {
    if (!checkedStrength) {
      if (extractedValue instanceof Boolean || extractedValue instanceof Number) {
        strong=true;
      }
      checkedStrength=true;
    }
    return getLongValueByType(extractedValue);
  }
}","public Long extractLongValue(Object value){
  Object extractedValue=expression.getValue(value);
  if (extractedValue == null) {
    return Long.MAX_VALUE;
  }
 else {
    if (!checkedStrength) {
      if (extractedValue instanceof Boolean || extractedValue instanceof Number) {
        strong=true;
      }
      checkedStrength=true;
    }
    return getLongValueByType(extractedValue);
  }
}",0.9974554707379136
50209,"public Set<MapEntry> getSubRecords(boolean equal,boolean lessThan,long searchedValue){
  MultiResultSet results=new MultiResultSet(recordValues);
  indexStore.getSubRecords(results,equal,lessThan,searchedValue);
  return results;
}","public Set<MapEntry> getSubRecords(boolean equal,boolean lessThan,Long searchedValue){
  MultiResultSet results=new MultiResultSet(recordValues);
  indexStore.getSubRecords(results,equal,lessThan,searchedValue);
  return results;
}",0.9956709956709956
50210,"private void removeRecordIndex(long oldValue,long recordId){
  recordValues.remove(recordId);
  indexStore.removeRecordIndex(oldValue,recordId);
}","private void removeRecordIndex(Long oldValue,Long recordId){
  recordValues.remove(recordId);
  indexStore.removeRecordIndex(oldValue,recordId);
}",0.9863013698630136
50211,"private void newRecordIndex(long newValue,Record record){
  long recordId=record.getId();
  indexStore.newRecordIndex(newValue,record);
  recordValues.put(recordId,newValue);
}","private void newRecordIndex(Long newValue,Record record){
  Long recordId=record.getId();
  indexStore.newRecordIndex(newValue,record);
  recordValues.put(recordId,newValue);
}",0.9886363636363636
50212,"public void index(long newValue,Record record){
  if (expression != null && returnType == -1) {
    returnType=record.getIndexTypes()[attributeIndex];
  }
  final long recordId=record.getId();
  Long oldValue=recordValues.get(recordId);
  if (record.isActive()) {
    if (oldValue == null) {
      newRecordIndex(newValue,record);
    }
 else     if (!oldValue.equals(newValue)) {
      removeRecordIndex(oldValue,recordId);
      newRecordIndex(newValue,record);
    }
  }
 else {
    if (oldValue != null) {
      removeRecordIndex(oldValue,recordId);
    }
    recordValues.remove(recordId);
  }
}","public void index(Long newValue,Record record){
  if (expression != null && returnType == -1) {
    returnType=record.getIndexTypes()[attributeIndex];
  }
  final Long recordId=record.getId();
  Long oldValue=recordValues.get(recordId);
  if (record.isActive()) {
    if (oldValue == null) {
      newRecordIndex(newValue,record);
    }
 else     if (!oldValue.equals(newValue)) {
      removeRecordIndex(oldValue,recordId);
      newRecordIndex(newValue,record);
    }
  }
 else {
    if (oldValue != null) {
      removeRecordIndex(oldValue,recordId);
    }
    recordValues.remove(recordId);
  }
}",0.9966666666666668
50213,"public Set<MapEntry> getRecords(long value){
  return indexStore.getRecords(value);
}","public Set<MapEntry> getRecords(Long value){
  return indexStore.getRecords(value);
}",0.9882352941176472
50214,"public Set<MapEntry> getSubRecordsBetween(long from,long to){
  MultiResultSet results=new MultiResultSet(recordValues);
  indexStore.getSubRecordsBetween(results,from,to);
  return results;
}","public Set<MapEntry> getSubRecordsBetween(Long from,Long to){
  MultiResultSet results=new MultiResultSet(recordValues);
  indexStore.getSubRecordsBetween(results,from,to);
  return results;
}",0.9895833333333334
50215,"void getSubRecords(MultiResultSet results,boolean equal,boolean lessThan,long searchedValue);","void getSubRecords(MultiResultSet results,boolean equal,boolean lessThan,Long searchedValue);",0.989247311827957
50216,"void removeRecordIndex(long oldValue,long recordId);","void removeRecordIndex(Long oldValue,Long recordId);",0.9615384615384616
50217,"void newRecordIndex(long newValue,Record record);","void newRecordIndex(Long newValue,Record record);",0.979591836734694
50218,"void getRecords(MultiResultSet results,long[] values);","void getRecords(MultiResultSet results,Long[] values);",0.9814814814814816
50219,"void getSubRecordsBetween(MultiResultSet results,long from,long to);","void getSubRecordsBetween(MultiResultSet results,Long from,Long to);",0.9705882352941176
50220,"public long[] getIndexValues(Object value){
  if (hasIndexedAttributes) {
    int indexCount=mapIndexes.size();
    long[] newIndexes=new long[indexCount];
    if (value instanceof Data) {
      value=toObject((Data)value);
    }
    Collection<Index> indexes=mapIndexes.values();
    for (    Index index : indexes) {
      int attributedIndex=index.getAttributeIndex();
      newIndexes[attributedIndex]=index.extractLongValue(value);
    }
    if (indexTypes == null || indexTypes.length != indexCount) {
synchronized (indexTypesLock) {
        if (indexTypes == null || indexTypes.length != indexCount) {
          indexTypes=new byte[indexCount];
          for (          Index index : indexes) {
            int attributedIndex=index.getAttributeIndex();
            indexTypes[attributedIndex]=index.getIndexType();
          }
        }
      }
    }
    return newIndexes;
  }
  return null;
}","public Long[] getIndexValues(Object value){
  if (hasIndexedAttributes) {
    int indexCount=mapIndexes.size();
    Long[] newIndexes=new Long[indexCount];
    if (value instanceof Data) {
      value=toObject((Data)value);
    }
    Collection<Index> indexes=mapIndexes.values();
    for (    Index index : indexes) {
      int attributedIndex=index.getAttributeIndex();
      newIndexes[attributedIndex]=index.extractLongValue(value);
    }
    if (indexTypes == null || indexTypes.length != indexCount) {
synchronized (indexTypesLock) {
        if (indexTypes == null || indexTypes.length != indexCount) {
          indexTypes=new byte[indexCount];
          for (          Index index : indexes) {
            int attributedIndex=index.getAttributeIndex();
            indexTypes[attributedIndex]=index.getIndexType();
          }
        }
      }
    }
    return newIndexes;
  }
  return null;
}",0.9966740576496674
50221,"public void index(Record record){
  final long recordId=record.getId();
  if (record.isActive()) {
    final Record anotherRecord=records.putIfAbsent(recordId,record);
    if (anotherRecord != null) {
      record=anotherRecord;
    }
  }
 else {
    remove(record);
  }
  int newValueIndex=-1;
  if (record.isActive() && record.getValue() != null) {
    newValueIndex=record.getValue().hashCode();
  }
  if (indexValue != null) {
    indexValue.index(newValueIndex,record);
  }
  long[] indexValues=record.getIndexes();
  byte[] indexTypes=record.getIndexTypes();
  if (indexValues != null && hasIndexedAttributes) {
    if (indexTypes == null || indexValues.length != indexTypes.length) {
      throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(indexTypes));
    }
    Collection<Index> indexes=mapIndexes.values();
    for (    Index index : indexes) {
      if (indexValues.length > index.getAttributeIndex()) {
        long newValue=indexValues[index.getAttributeIndex()];
        index.index(newValue,record);
      }
    }
  }
}","public void index(Record record){
  final Long recordId=record.getId();
  if (record.isActive()) {
    final Record anotherRecord=records.putIfAbsent(recordId,record);
    if (anotherRecord != null) {
      record=anotherRecord;
    }
  }
 else {
    remove(record);
  }
  Long newValueIndex=-1L;
  if (record.isActive() && record.getValue() != null) {
    newValueIndex=(long)record.getValue().hashCode();
  }
  if (indexValue != null) {
    indexValue.index(newValueIndex,record);
  }
  Long[] indexValues=record.getIndexes();
  byte[] indexTypes=record.getIndexTypes();
  if (indexValues != null && hasIndexedAttributes) {
    if (indexTypes == null || indexValues.length != indexTypes.length) {
      throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(indexTypes));
    }
    Collection<Index> indexes=mapIndexes.values();
    for (    Index index : indexes) {
      if (indexValues.length > index.getAttributeIndex()) {
        Long newValue=indexValues[index.getAttributeIndex()];
        index.index(newValue,record);
      }
    }
  }
}",0.9905660377358492
50222,"public boolean containsValue(Data value){
  if (indexValue != null) {
    Set<MapEntry> results=indexValue.getRecords(value.hashCode());
    if (results == null || results.size() == 0)     return false;
    for (    MapEntry entry : results) {
      Record record=(Record)entry;
      if (record.containsValue(value)) {
        return true;
      }
    }
  }
 else {
    for (    Record record : records.values()) {
      if (record.containsValue(value)) {
        return true;
      }
    }
  }
  return false;
}","public boolean containsValue(Data value){
  if (indexValue != null) {
    Set<MapEntry> results=indexValue.getRecords((long)value.hashCode());
    if (results == null || results.size() == 0)     return false;
    for (    MapEntry entry : results) {
      Record record=(Record)entry;
      if (record.containsValue(value)) {
        return true;
      }
    }
  }
 else {
    for (    Record record : records.values()) {
      if (record.containsValue(value)) {
        return true;
      }
    }
  }
  return false;
}",0.994186046511628
50223,"public void getSubRecords(MultiResultSet results,boolean equal,boolean lessThan,long searchedValue){
  Set<Long> values=(lessThan) ? sortedSet.headSet(searchedValue) : sortedSet.tailSet(searchedValue);
  for (  Long value : values) {
    if (lessThan || equal || !value.equals(searchedValue)) {
      ConcurrentMap<Long,Record> records=mapRecords.get(value);
      if (records != null) {
        results.addResultSet(value,records.values());
      }
    }
  }
  if (lessThan && equal) {
    ConcurrentMap<Long,Record> records=mapRecords.get(searchedValue);
    if (records != null) {
      results.addResultSet(searchedValue,records.values());
    }
  }
}","public void getSubRecords(MultiResultSet results,boolean equal,boolean lessThan,Long searchedValue){
  Set<Long> values=(lessThan) ? sortedSet.headSet(searchedValue) : sortedSet.tailSet(searchedValue);
  for (  Long value : values) {
    if (lessThan || equal || !value.equals(searchedValue)) {
      ConcurrentMap<Long,Record> records=mapRecords.get(value);
      if (records != null) {
        results.addResultSet(value,records.values());
      }
    }
  }
  if (lessThan && equal) {
    ConcurrentMap<Long,Record> records=mapRecords.get(searchedValue);
    if (records != null) {
      results.addResultSet(searchedValue,records.values());
    }
  }
}",0.998473282442748
50224,"public void removeRecordIndex(long oldValue,long recordId){
  ConcurrentMap<Long,Record> records=mapRecords.get(oldValue);
  if (records != null) {
    records.remove(recordId);
    if (records.size() == 0) {
      mapRecords.remove(oldValue);
      sortedSet.remove(oldValue);
    }
  }
}","public void removeRecordIndex(Long oldValue,Long recordId){
  ConcurrentMap<Long,Record> records=mapRecords.get(oldValue);
  if (records != null) {
    records.remove(recordId);
    if (records.size() == 0) {
      mapRecords.remove(oldValue);
      sortedSet.remove(oldValue);
    }
  }
}",0.9930795847750864
50225,"public void newRecordIndex(long newValue,Record record){
  long recordId=record.getId();
  ConcurrentMap<Long,Record> records=mapRecords.get(newValue);
  if (records == null) {
    records=new ConcurrentHashMap<Long,Record>(1,0.75f,1);
    mapRecords.put(newValue,records);
    sortedSet.add(newValue);
  }
  records.put(recordId,record);
}","public void newRecordIndex(Long newValue,Record record){
  long recordId=record.getId();
  ConcurrentMap<Long,Record> records=mapRecords.get(newValue);
  if (records == null) {
    records=new ConcurrentHashMap<Long,Record>(1,0.75f,1);
    mapRecords.put(newValue,records);
    sortedSet.add(newValue);
  }
  records.put(recordId,record);
}",0.9970588235294118
50226,"public void getRecords(MultiResultSet results,long[] values){
  for (  Long value : values) {
    ConcurrentMap<Long,Record> records=mapRecords.get(value);
    if (records != null) {
      results.addResultSet(value,records.values());
    }
  }
}","public void getRecords(MultiResultSet results,Long[] values){
  for (  Long value : values) {
    ConcurrentMap<Long,Record> records=mapRecords.get(value);
    if (records != null) {
      results.addResultSet(value,records.values());
    }
  }
}",0.9959349593495936
50227,"public void getSubRecordsBetween(MultiResultSet results,long from,long to){
  Set<Long> values=sortedSet.subSet(from,to);
  for (  Long value : values) {
    ConcurrentMap<Long,Record> records=mapRecords.get(value);
    if (records != null) {
      results.addResultSet(value,records.values());
    }
  }
  ConcurrentMap<Long,Record> records=mapRecords.get(to);
  if (records != null) {
    results.addResultSet(to,records.values());
  }
}","public void getSubRecordsBetween(MultiResultSet results,Long from,Long to){
  Set<Long> values=sortedSet.subSet(from,to);
  for (  Long value : values) {
    ConcurrentMap<Long,Record> records=mapRecords.get(value);
    if (records != null) {
      results.addResultSet(value,records.values());
    }
  }
  ConcurrentMap<Long,Record> records=mapRecords.get(to);
  if (records != null) {
    results.addResultSet(to,records.values());
  }
}",0.9954441913439636
50228,"public final void heartBeater(){
  if (!node.joined() || !node.isActive())   return;
  long now=System.currentTimeMillis();
  if (isMaster()) {
    List<Address> lsDeadAddresses=null;
    for (    MemberImpl memberImpl : lsMembers) {
      final Address address=memberImpl.getAddress();
      if (!thisAddress.equals(address)) {
        try {
          Connection conn=node.connectionManager.getConnection(address);
          if (conn != null && conn.live()) {
            if ((now - memberImpl.getLastRead()) >= (MAX_NO_HEARTBEAT_MILLIS)) {
              conn=null;
              if (lsDeadAddresses == null) {
                lsDeadAddresses=new ArrayList<Address>();
              }
              logger.log(Level.WARNING,""String_Node_Str"" + address + ""String_Node_Str"");
              lsDeadAddresses.add(address);
            }
          }
          if (conn != null && conn.live()) {
            if ((now - memberImpl.getLastWrite()) > 500) {
              Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
              sendOrReleasePacket(packet,conn);
            }
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
          logger.log(Level.SEVERE,e.getMessage(),e);
        }
      }
    }
    if (lsDeadAddresses != null) {
      for (      Address address : lsDeadAddresses) {
        logger.log(Level.FINEST,""String_Node_Str"" + address);
        doRemoveAddress(address);
        sendRemoveMemberToOthers(address);
      }
    }
  }
 else {
    if (getMasterAddress() != null) {
      MemberImpl masterMember=getMember(getMasterAddress());
      boolean removed=false;
      if (masterMember != null) {
        if ((now - masterMember.getLastRead()) >= (MAX_NO_HEARTBEAT_MILLIS)) {
          logger.log(Level.FINEST,""String_Node_Str"");
          doRemoveAddress(getMasterAddress());
          removed=true;
        }
      }
      if (!removed) {
        Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
        Connection connMaster=node.connectionManager.getOrConnect(getMasterAddress());
        sendOrReleasePacket(packet,connMaster);
      }
    }
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember()) {
        Address address=member.getAddress();
        if (shouldConnectTo(address)) {
          Connection conn=node.connectionManager.getOrConnect(address);
          if (conn != null) {
            Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
            sendOrReleasePacket(packet,conn);
          }
 else {
            logger.log(Level.FINEST,""String_Node_Str"" + address + ""String_Node_Str"");
          }
        }
 else {
          Connection conn=node.connectionManager.getConnection(address);
          if (conn != null && conn.live()) {
            if ((now - member.getLastWrite()) > 500) {
              Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
              sendOrReleasePacket(packet,conn);
            }
          }
 else {
            logger.log(Level.FINEST,""String_Node_Str"" + address);
          }
        }
      }
    }
  }
}","public final void heartBeater(){
  if (!node.joined() || !node.isActive())   return;
  long now=System.currentTimeMillis();
  if (isMaster()) {
    List<Address> lsDeadAddresses=null;
    for (    MemberImpl memberImpl : lsMembers) {
      final Address address=memberImpl.getAddress();
      if (!thisAddress.equals(address)) {
        try {
          Connection conn=node.connectionManager.getConnection(address);
          if (conn != null && conn.live()) {
            if ((now - memberImpl.getLastRead()) >= (MAX_NO_HEARTBEAT_MILLIS)) {
              conn=null;
              if (lsDeadAddresses == null) {
                lsDeadAddresses=new ArrayList<Address>();
              }
              logger.log(Level.WARNING,""String_Node_Str"" + address + ""String_Node_Str"");
              lsDeadAddresses.add(address);
            }
            if ((now - memberImpl.getLastWrite()) > 500) {
              Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
              sendOrReleasePacket(packet,conn);
            }
          }
 else           if (conn == null && (now - memberImpl.getLastRead()) > 5000) {
            logMissingConnection(address);
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
          logger.log(Level.SEVERE,e.getMessage(),e);
        }
      }
    }
    if (lsDeadAddresses != null) {
      for (      Address address : lsDeadAddresses) {
        logger.log(Level.FINEST,""String_Node_Str"" + address);
        doRemoveAddress(address);
        sendRemoveMemberToOthers(address);
      }
    }
  }
 else {
    if (getMasterAddress() != null) {
      MemberImpl masterMember=getMember(getMasterAddress());
      boolean removed=false;
      if (masterMember != null) {
        if ((now - masterMember.getLastRead()) >= (MAX_NO_HEARTBEAT_MILLIS)) {
          logger.log(Level.FINEST,""String_Node_Str"");
          doRemoveAddress(getMasterAddress());
          removed=true;
        }
      }
      if (!removed) {
        Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
        Connection connMaster=node.connectionManager.getOrConnect(getMasterAddress());
        sendOrReleasePacket(packet,connMaster);
      }
    }
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember()) {
        Address address=member.getAddress();
        if (shouldConnectTo(address)) {
          Connection conn=node.connectionManager.getOrConnect(address);
          if (conn != null) {
            Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
            sendOrReleasePacket(packet,conn);
          }
 else {
            logger.log(Level.FINEST,""String_Node_Str"" + address + ""String_Node_Str"");
          }
        }
 else {
          Connection conn=node.connectionManager.getConnection(address);
          if (conn != null && conn.live()) {
            if ((now - member.getLastWrite()) > 500) {
              Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
              sendOrReleasePacket(packet,conn);
            }
          }
 else {
            logger.log(Level.FINEST,""String_Node_Str"" + address);
            if (conn == null && (now - member.getLastRead()) > 5000) {
              logMissingConnection(address);
            }
          }
        }
      }
    }
  }
}",0.9511935532917744
50229,"public ClusterManager(final Node node){
  super(node);
  WAIT_MILLIS_BEFORE_JOIN=node.groupProperties.WAIT_SECONDS_BEFORE_JOIN.getInteger() * 1000L;
  MAX_NO_HEARTBEAT_MILLIS=node.groupProperties.MAX_NO_HEARTBEAT_SECONDS.getInteger() * 1000L;
  node.clusterService.registerPeriodicRunnable(new SplitBrainHandler(node));
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      heartBeater();
    }
  }
);
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      checkScheduledActions();
    }
  }
);
  node.connectionManager.addConnectionListener(this);
  registerPacketProcessor(ClusterOperation.RESPONSE,new PacketProcessor(){
    public void process(    Packet packet){
      handleResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.HEARTBEAT,new PacketProcessor(){
    public void process(    Packet packet){
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.JOIN_CHECK,new PacketProcessor(){
    public void process(    Packet packet){
      Connection conn=packet.conn;
      Request request=Request.copy(packet);
      JoinInfo joinInfo=(JoinInfo)toObject(request.value);
      request.clearForResponse();
      if (joinInfo != null && node.joined() && node.isActive() && node.validateJoinRequest(joinInfo)) {
        request.response=toData(node.createJoinInfo());
      }
      returnResponse(request,conn);
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS_AND_RESPOND,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      sendResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_BOOLEAN,new PacketProcessor(){
    public void process(    Packet packet){
      Boolean result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable<Boolean>)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=Boolean.FALSE;
      }
      if (result == Boolean.TRUE) {
        sendResponse(packet);
      }
 else {
        sendResponseFailure(packet);
      }
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_OBJECT,new PacketProcessor(){
    public void process(    Packet packet){
      Object result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=null;
      }
      if (result != null) {
        Data value;
        if (result instanceof Data) {
          value=(Data)result;
        }
 else {
          value=toData(result);
        }
        packet.setValue(value);
      }
      sendResponse(packet);
    }
  }
);
}","public ClusterManager(final Node node){
  super(node);
  WAIT_MILLIS_BEFORE_JOIN=node.groupProperties.WAIT_SECONDS_BEFORE_JOIN.getInteger() * 1000L;
  MAX_NO_HEARTBEAT_MILLIS=node.groupProperties.MAX_NO_HEARTBEAT_SECONDS.getInteger() * 1000L;
  node.clusterService.registerPeriodicRunnable(new SplitBrainHandler(node));
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      heartBeater();
    }
  }
);
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      checkScheduledActions();
    }
  }
);
  node.connectionManager.addConnectionListener(this);
  registerPacketProcessor(ClusterOperation.RESPONSE,new PacketProcessor(){
    public void process(    Packet packet){
      handleResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.HEARTBEAT,new PacketProcessor(){
    public void process(    Packet packet){
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.LOG,new PacketProcessor(){
    public void process(    Packet packet){
      logger.log(Level.parse(packet.name),toObject(packet.getValueData()).toString());
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.JOIN_CHECK,new PacketProcessor(){
    public void process(    Packet packet){
      Connection conn=packet.conn;
      Request request=Request.copy(packet);
      JoinInfo joinInfo=(JoinInfo)toObject(request.value);
      request.clearForResponse();
      if (joinInfo != null && node.joined() && node.isActive() && node.validateJoinRequest(joinInfo)) {
        request.response=toData(node.createJoinInfo());
      }
      returnResponse(request,conn);
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS_AND_RESPOND,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      sendResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_BOOLEAN,new PacketProcessor(){
    public void process(    Packet packet){
      Boolean result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable<Boolean>)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=Boolean.FALSE;
      }
      if (result == Boolean.TRUE) {
        sendResponse(packet);
      }
 else {
        sendResponseFailure(packet);
      }
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_OBJECT,new PacketProcessor(){
    public void process(    Packet packet){
      Object result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=null;
      }
      if (result != null) {
        Data value;
        if (result instanceof Data) {
          value=(Data)result;
        }
 else {
          value=toData(result);
        }
        packet.setValue(value);
      }
      sendResponse(packet);
    }
  }
);
}",0.9686330192332516
50230,"public int compare(MapEntry o1,MapEntry o2){
  int result=comparator.compare(o1,o2);
  if (result == 0) {
    Record r1=(Record)o1;
    Record r2=(Record)o2;
    return r1.getId().compareTo(r2.getId());
  }
 else {
    return result;
  }
}","public int compare(MapEntry o1,MapEntry o2){
  int result=comparator.compare(o1,o2);
  if (result == 0) {
    Record r1=(Record)o1;
    Record r2=(Record)o2;
    return (r1.getId() > r2.getId()) ? 1 : -1;
  }
 else {
    return result;
  }
}",0.95
50231,"public void run(){
  long now=System.currentTimeMillis();
  if (now > nextMigrationMillis) {
    nextMigrationMillis=now + MIGRATION_INTERVAL_MILLIS;
    if (!concurrentMapManager.isMaster())     return;
    if (concurrentMapManager.getMembers().size() < 2)     return;
    if (now > timeToInitiateMigration) {
      initiateMigration();
    }
  }
}","public void run(){
  long now=System.currentTimeMillis();
  if (now > nextMigrationMillis) {
    if (migrationStartTime != 0) {
      logger.log(Level.WARNING,""String_Node_Str"" + ((now - migrationStartTime) / 1000) + ""String_Node_Str"");
      for (      Block block : blocks) {
        logger.log(Level.WARNING,block == null ? ""String_Node_Str"" : block.toString());
      }
    }
    nextMigrationMillis=now + MIGRATION_INTERVAL_MILLIS;
    if (!concurrentMapManager.isMaster())     return;
    if (concurrentMapManager.getMembers().size() < 2)     return;
    if (now > timeToInitiateMigration) {
      initiateMigration();
    }
  }
}",0.7086294416243655
50232,"void fireMigrationEvent(final boolean started,Block block){
  final MemberImpl memberOwner=concurrentMapManager.getMember(block.getOwner());
  final MemberImpl memberMigration=concurrentMapManager.getMember(block.getMigrationAddress());
  final MigrationEvent migrationEvent=new MigrationEvent(concurrentMapManager.node,block.getBlockId(),memberOwner,memberMigration);
  partitionServiceImpl.doFireMigrationEvent(started,migrationEvent);
}","void fireMigrationEvent(final boolean started,Block block){
  if (node.isMaster()) {
    if (started) {
      migrationStartTime=System.currentTimeMillis();
    }
 else {
      migrationStartTime=0;
    }
  }
  final MemberImpl memberOwner=concurrentMapManager.getMember(block.getOwner());
  final MemberImpl memberMigration=concurrentMapManager.getMember(block.getMigrationAddress());
  final MigrationEvent migrationEvent=new MigrationEvent(concurrentMapManager.node,block.getBlockId(),memberOwner,memberMigration);
  partitionServiceImpl.doFireMigrationEvent(started,migrationEvent);
}",0.8549172346640701
50233,"void getRecords(MultiResultSet results,Long[] values);","void getRecords(MultiResultSet results,Set<Long> values);",0.9369369369369368
50234,"public static Object getRealObject(Object type,String value){
  Object result=null;
  if (type instanceof Boolean) {
    result=""String_Node_Str"".equalsIgnoreCase(value) ? true : false;
  }
 else   if (type instanceof Integer) {
    result=Integer.valueOf(value);
  }
 else   if (type instanceof Double) {
    result=Double.valueOf(value);
  }
 else   if (type instanceof Float) {
    result=Float.valueOf(value);
  }
 else   if (type instanceof Byte) {
    result=Byte.valueOf(value);
  }
 else   if (type instanceof Long) {
    result=Long.valueOf(value);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + type.getClass() + ""String_Node_Str""+ value);
  }
  return result;
}","public static Object getRealObject(Object type,String value){
  Object result=null;
  if (type instanceof Boolean) {
    result=""String_Node_Str"".equalsIgnoreCase(value) ? true : false;
  }
 else   if (type instanceof Integer) {
    result=Integer.valueOf(value);
  }
 else   if (type instanceof Double) {
    result=Double.valueOf(value);
  }
 else   if (type instanceof Float) {
    result=Float.valueOf(value);
  }
 else   if (type instanceof Byte) {
    result=Byte.valueOf(value);
  }
 else   if (type instanceof Long) {
    result=Long.valueOf(value);
  }
 else {
    System.out.println(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"" + type.getClass() + ""String_Node_Str""+ value);
  }
  return result;
}",0.9696969696969696
50235,"public void getRecords(MultiResultSet results,Long[] values){
  for (  Long value : values) {
    ConcurrentMap<Long,Record> records=mapRecords.get(value);
    if (records != null) {
      results.addResultSet(value,records.values());
    }
  }
}","public void getRecords(MultiResultSet results,Set<Long> values){
  for (  Long value : values) {
    ConcurrentMap<Long,Record> records=mapRecords.get(value);
    if (records != null) {
      results.addResultSet(value,records.values());
    }
  }
}",0.985858585858586
50236,"public void getRecords(MultiResultSet results,Long[] values){
  for (  Long value : values) {
    ConcurrentMap<Long,Record> records=mapRecords.get(value);
    if (records != null) {
      results.addResultSet(value,records.values());
    }
  }
}","public void getRecords(MultiResultSet results,Set<Long> values){
  for (  Long value : values) {
    ConcurrentMap<Long,Record> records=mapRecords.get(value);
    if (records != null) {
      results.addResultSet(value,records.values());
    }
  }
}",0.985858585858586
50237,"void handleJoinRequest(JoinRequest joinRequest){
  logger.log(Level.FINEST,joinInProgress + ""String_Node_Str"" + joinRequest);
  if (getMember(joinRequest.address) != null) {
    return;
  }
  Connection conn=joinRequest.getConnection();
  if (node.validateJoinRequest(joinRequest)) {
    if (!node.getConfig().getNetworkConfig().getJoin().getMulticastConfig().isEnabled()) {
      if (node.isActive() && node.joined() && node.getMasterAddress() != null && !isMaster()) {
        sendProcessableTo(new Master(node.getMasterAddress()),conn);
      }
    }
    if (isMaster() && node.joined() && node.isActive()) {
      if (joinRequest.to != null && !joinRequest.to.equals(thisAddress)) {
        sendProcessableTo(new Master(node.getMasterAddress()),conn);
        return;
      }
      if (!joinInProgress) {
        MemberInfo newMemberInfo=new MemberInfo(joinRequest.address,joinRequest.nodeType);
        if (setJoins.add(newMemberInfo)) {
          sendProcessableTo(new Master(node.getMasterAddress()),conn);
          timeToStartJoin=System.currentTimeMillis() + WAIT_MILLIS_BEFORE_JOIN;
        }
 else {
          if (System.currentTimeMillis() > timeToStartJoin) {
            startJoin();
          }
        }
      }
    }
  }
 else {
    conn.close();
  }
}","void handleJoinRequest(JoinRequest joinRequest){
  logger.log(Level.FINEST,joinInProgress + ""String_Node_Str"" + joinRequest);
  if (getMember(joinRequest.address) != null) {
    return;
  }
  Connection conn=joinRequest.getConnection();
  final boolean validateJoinRequest=node.validateJoinRequest(joinRequest);
  if (validateJoinRequest) {
    if (!node.getConfig().getNetworkConfig().getJoin().getMulticastConfig().isEnabled()) {
      if (node.isActive() && node.joined() && node.getMasterAddress() != null && !isMaster()) {
        sendProcessableTo(new Master(node.getMasterAddress()),conn);
      }
    }
    if (isMaster() && node.joined() && node.isActive()) {
      if (joinRequest.to != null && !joinRequest.to.equals(thisAddress)) {
        sendProcessableTo(new Master(node.getMasterAddress()),conn);
        return;
      }
      if (!joinInProgress) {
        MemberInfo newMemberInfo=new MemberInfo(joinRequest.address,joinRequest.nodeType);
        if (setJoins.add(newMemberInfo)) {
          sendProcessableTo(new Master(node.getMasterAddress()),conn);
          timeToStartJoin=System.currentTimeMillis() + WAIT_MILLIS_BEFORE_JOIN;
        }
 else {
          if (System.currentTimeMillis() > timeToStartJoin) {
            startJoin();
          }
        }
      }
    }
  }
 else {
    conn.close();
  }
}",0.9711205236811706
50238,"public JoinInfo(boolean request,Address address,String groupName,String groupPassword,NodeType type,byte packetVersion,int buildNumber,int memberCount){
  super(address,groupName,groupPassword,type,packetVersion,buildNumber);
  this.setRequest(request);
  this.memberCount=memberCount;
}","public JoinInfo(boolean request,Address address,Config config,NodeType type,byte packetVersion,int buildNumber,int memberCount){
  super(address,config,type,packetVersion,buildNumber);
  this.request=request;
  this.memberCount=memberCount;
}",0.8506616257088847
50239,"@Override public void readData(DataInput dis) throws IOException {
  super.readData(dis);
  setRequest(dis.readBoolean());
  memberCount=dis.readInt();
}","@Override public void readData(DataInput dis) throws IOException {
  super.readData(dis);
  this.request=dis.readBoolean();
  memberCount=dis.readInt();
}",0.9641693811074918
50240,"public void writeToPacket(DatagramPacket packet){
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(bos);
  try {
    writeData(dos);
    packet.setData(bos.toByteArray());
    packet.setLength(bos.size());
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void writeToPacket(DatagramPacket packet){
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(bos);
  try {
    writeData(dos);
    dos.flush();
    packet.setData(bos.toByteArray());
    packet.setLength(bos.size());
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9740458015267176
50241,"public JoinInfo copy(boolean newRequest,Address newAddress){
  return new JoinInfo(newRequest,newAddress,groupName,groupPassword,nodeType,packetVersion,buildNumber,memberCount);
}","public JoinInfo copy(boolean newRequest,Address newAddress){
  return new JoinInfo(newRequest,newAddress,config,nodeType,packetVersion,buildNumber,memberCount);
}",0.9208211143695014
50242,"@Override public void readData(DataInput in) throws IOException {
  boolean hasTo=in.readBoolean();
  if (hasTo) {
    to=new Address();
    to.readData(in);
  }
  address=new Address();
  address.readData(in);
  nodeType=NodeType.create(in.readInt());
  groupName=in.readUTF();
  groupPassword=in.readUTF();
  packetVersion=in.readByte();
  buildNumber=in.readInt();
}","@Override public void readData(DataInput in) throws IOException {
  packetVersion=in.readByte();
  buildNumber=in.readInt();
  boolean hasTo=in.readBoolean();
  if (hasTo) {
    to=new Address();
    to.readData(in);
  }
  address=new Address();
  address.readData(in);
  nodeType=NodeType.create(in.readInt());
  config=new Config();
  config.readData(in);
}",0.3461538461538461
50243,"@Override public String toString(){
  return new StringBuilder(128).append(""String_Node_Str"").append(""String_Node_Str"").append(nodeType).append(""String_Node_Str"").append(address).append(""String_Node_Str"").append(groupName).append('\'').append(""String_Node_Str"").append(groupPassword).append('\'').append(""String_Node_Str"").append(buildNumber).append('\'').append(""String_Node_Str"").append(packetVersion).append('\'').append('}').toString();
}","@Override public String toString(){
  return new StringBuilder(128).append(""String_Node_Str"").append(""String_Node_Str"").append(nodeType).append(""String_Node_Str"").append(address).append(""String_Node_Str"").append(buildNumber).append('\'').append(""String_Node_Str"").append(packetVersion).append('\'').append(""String_Node_Str"").append(config).append('\'').append('}').toString();
}",0.7902439024390244
50244,"public JoinRequest(Address to,Address address,String groupName,String groupPassword,NodeType type,byte packetVersion,int buildNumber){
  super();
  this.to=to;
  this.address=address;
  this.groupName=groupName;
  this.groupPassword=groupPassword;
  this.nodeType=type;
  this.packetVersion=packetVersion;
  this.buildNumber=buildNumber;
}","public JoinRequest(Address to,Address address,Config config,NodeType type,byte packetVersion,int buildNumber){
  super();
  this.to=to;
  this.address=address;
  this.config=config;
  this.nodeType=type;
  this.packetVersion=packetVersion;
  this.buildNumber=buildNumber;
}",0.5294117647058824
50245,"@Override public void writeData(DataOutput out) throws IOException {
  boolean hasTo=(to != null);
  out.writeBoolean(hasTo);
  if (hasTo) {
    to.writeData(out);
  }
  address.writeData(out);
  out.writeInt(nodeType.getValue());
  out.writeUTF(groupName);
  out.writeUTF(groupPassword);
  out.writeByte(packetVersion);
  out.writeInt(buildNumber);
}","@Override public void writeData(DataOutput out) throws IOException {
  out.writeByte(packetVersion);
  out.writeInt(buildNumber);
  boolean hasTo=(to != null);
  out.writeBoolean(hasTo);
  if (hasTo) {
    to.writeData(out);
  }
  address.writeData(out);
  out.writeInt(nodeType.getValue());
  config.writeData(out);
}",0.7115097159940209
50246,"public void addEntryListener(EntryListener<K,V> listener,K key,boolean includeValue){
  check(listener);
  if (proxyHelper.getHazelcastClient().getListenerManager().getEntryListenerManager().noEntryListenerRegistered(key,name)) {
    Packet request=proxyHelper.createRequestPacket(ClusterOperation.ADD_LISTENER,toByte(key),null);
    request.setLongValue(includeValue ? 1 : 0);
    Call c=proxyHelper.createCall(request);
    proxyHelper.getHazelcastClient().getListenerManager().addListenerCall(c);
    proxyHelper.doCall(c);
  }
  proxyHelper.getHazelcastClient().getListenerManager().getEntryListenerManager().registerEntryListener(name,key,listener);
}","public void addEntryListener(EntryListener<K,V> listener,K key,boolean includeValue){
  check(listener);
  Boolean noEntryListenerRegistered=proxyHelper.getHazelcastClient().getListenerManager().getEntryListenerManager().noEntryListenerRegistered(key,name,includeValue);
  if (noEntryListenerRegistered == null) {
    proxyHelper.doOp(ClusterOperation.REMOVE_LISTENER,key,null);
    noEntryListenerRegistered=Boolean.TRUE;
  }
  if (noEntryListenerRegistered) {
    Packet request=proxyHelper.createRequestPacket(ClusterOperation.ADD_LISTENER,toByte(key),null);
    request.setLongValue(includeValue ? 1 : 0);
    Call c=proxyHelper.createCall(request);
    proxyHelper.getHazelcastClient().getListenerManager().addListenerCall(c);
    proxyHelper.doCall(c);
  }
  proxyHelper.getHazelcastClient().getListenerManager().getEntryListenerManager().registerEntryListener(name,key,includeValue,listener);
}",0.7219010918432883
50247,"public void addEntryListener(EntryListener<K,V> listener,K key,boolean includeValue){
  check(listener);
  if (client.getListenerManager().getEntryListenerManager().noEntryListenerRegistered(key,name)) {
    Packet request=proxyHelper.createRequestPacket(ClusterOperation.ADD_LISTENER,toByte(key),null);
    request.setLongValue(includeValue ? 1 : 0);
    Call c=proxyHelper.createCall(request);
    client.getListenerManager().addListenerCall(c);
    proxyHelper.doCall(c);
  }
  client.getListenerManager().getEntryListenerManager().registerEntryListener(name,key,listener);
}","public void addEntryListener(EntryListener<K,V> listener,K key,boolean includeValue){
  check(listener);
  Boolean noEntryListenerRegistered=client.getListenerManager().getEntryListenerManager().noEntryListenerRegistered(key,name,includeValue);
  if (noEntryListenerRegistered == null) {
    proxyHelper.doOp(ClusterOperation.REMOVE_LISTENER,key,null);
    noEntryListenerRegistered=Boolean.TRUE;
  }
  if (noEntryListenerRegistered.booleanValue()) {
    Packet request=proxyHelper.createRequestPacket(ClusterOperation.ADD_LISTENER,toByte(key),null);
    request.setLongValue(includeValue ? 1 : 0);
    Call c=proxyHelper.createCall(request);
    client.getListenerManager().addListenerCall(c);
    proxyHelper.doCall(c);
  }
  client.getListenerManager().getEntryListenerManager().registerEntryListener(name,key,includeValue,listener);
}",0.7005649717514124
50248,"public synchronized void registerEntryListener(String name,Object key,EntryListener<?,?> entryListener){
  if (!entryListeners.containsKey(name)) {
    entryListeners.put(name,new HashMap<Object,List<EntryListener<?,?>>>());
  }
  if (!entryListeners.get(name).containsKey(key)) {
    entryListeners.get(name).put(key,new CopyOnWriteArrayList<EntryListener<?,?>>());
  }
  entryListeners.get(name).get(key).add(entryListener);
}","public synchronized void registerEntryListener(String name,Object key,boolean includeValue,EntryListener<?,?> entryListener){
  Map<Object,List<EntryListenerHolder>> map=entryListeners.get(name);
  if (map == null) {
    map=new HashMap<Object,List<EntryListenerHolder>>();
    final Map<Object,List<EntryListenerHolder>> map2=entryListeners.putIfAbsent(name,map);
    if (map2 != null) {
      map=map2;
    }
  }
  if (!map.containsKey(key)) {
    map.put(key,new CopyOnWriteArrayList<EntryListenerHolder>());
  }
  map.get(key).add(new EntryListenerHolder(entryListener,includeValue));
}",0.3654223968565815
50249,"private void notifyEntryListeners(EntryEvent event,Collection<EntryListener<?,?>> collection){
  if (collection == null) {
    return;
  }
switch (event.getEventType()) {
case ADDED:
    for (    EntryListener<?,?> entryListener : collection) {
      entryListener.entryAdded(event);
    }
  break;
case UPDATED:
for (EntryListener<?,?> entryListener : collection) {
  entryListener.entryUpdated(event);
}
break;
case REMOVED:
for (EntryListener<?,?> entryListener : collection) {
entryListener.entryRemoved(event);
}
break;
case EVICTED:
for (EntryListener<?,?> entryListener : collection) {
entryListener.entryEvicted(event);
}
break;
}
}","private void notifyEntryListeners(EntryEvent event,Collection<EntryListenerHolder> collection){
  if (collection == null) {
    return;
  }
  EntryEvent eventNoValue=event.getValue() != null ? new EntryEvent(event.getSource(),event.getMember(),event.getEventType().getType(),event.getKey(),null,null) : event;
switch (event.getEventType()) {
case ADDED:
    for (    EntryListenerHolder holder : collection) {
      holder.listener.entryAdded(holder.includeValue ? event : eventNoValue);
    }
  break;
case UPDATED:
for (EntryListenerHolder holder : collection) {
  holder.listener.entryUpdated(holder.includeValue ? event : eventNoValue);
}
break;
case REMOVED:
for (EntryListenerHolder holder : collection) {
holder.listener.entryRemoved(holder.includeValue ? event : eventNoValue);
}
break;
case EVICTED:
for (EntryListenerHolder holder : collection) {
holder.listener.entryEvicted(holder.includeValue ? event : eventNoValue);
}
break;
}
}",0.5078963992419456
50250,"public synchronized boolean noEntryListenerRegistered(Object key,String name){
  return !(entryListeners.get(name) != null && entryListeners.get(name).get(key) != null && entryListeners.get(name).get(key).size() > 0);
}","public synchronized Boolean noEntryListenerRegistered(Object key,String name,boolean includeValue){
  final Map<Object,List<EntryListenerHolder>> map=entryListeners.get(name);
  if (map == null || map.get(key) == null) {
    return Boolean.TRUE;
  }
  for (  final EntryListenerHolder holder : map.get(key)) {
    if (holder.includeValue == includeValue) {
      return Boolean.FALSE;
    }
 else     if (includeValue) {
      return null;
    }
  }
  return Boolean.TRUE;
}",0.3492063492063492
50251,"public synchronized void removeEntryListener(String name,Object key,EntryListener<?,?> entryListener){
  Map<Object,List<EntryListener<?,?>>> m=entryListeners.get(name);
  if (m != null) {
    List<EntryListener<?,?>> list=m.get(key);
    if (list != null) {
      list.remove(entryListener);
      if (m.get(key).size() == 0) {
        m.remove(key);
      }
    }
    if (m.size() == 0) {
      entryListeners.remove(name);
    }
  }
}","public synchronized void removeEntryListener(String name,Object key,EntryListener<?,?> entryListener){
  Map<Object,List<EntryListenerHolder>> m=entryListeners.get(name);
  if (m != null) {
    List<EntryListenerHolder> list=m.get(key);
    if (list != null) {
      for (final Iterator<EntryListenerHolder> it=list.iterator(); it.hasNext(); ) {
        final EntryListenerHolder entryListenerHolder=it.next();
        if (entryListenerHolder.listener.equals(entryListener)) {
          list.remove(entryListenerHolder);
        }
      }
      if (m.get(key).isEmpty()) {
        m.remove(key);
      }
    }
    if (m.isEmpty()) {
      entryListeners.remove(name);
    }
  }
}",0.7222222222222222
50252,"public <E,V>void registerItemListener(String name,final ItemListener<E> itemListener){
  EntryListener<E,V> e=new EntryListener<E,V>(){
    public void entryAdded(    EntryEvent<E,V> event){
      itemListener.itemAdded((E)event.getKey());
    }
    public void entryEvicted(    EntryEvent<E,V> event){
    }
    public void entryRemoved(    EntryEvent<E,V> event){
      itemListener.itemRemoved((E)event.getKey());
    }
    public void entryUpdated(    EntryEvent<E,V> event){
    }
  }
;
  entryListenerManager.registerEntryListener(name,null,e);
  itemListener2EntryListener.put(itemListener,e);
}","public <E,V>void registerItemListener(String name,final ItemListener<E> itemListener){
  EntryListener<E,V> e=new EntryListener<E,V>(){
    public void entryAdded(    EntryEvent<E,V> event){
      itemListener.itemAdded((E)event.getKey());
    }
    public void entryEvicted(    EntryEvent<E,V> event){
    }
    public void entryRemoved(    EntryEvent<E,V> event){
      itemListener.itemRemoved((E)event.getKey());
    }
    public void entryUpdated(    EntryEvent<E,V> event){
    }
  }
;
  entryListenerManager.registerEntryListener(name,null,false,e);
  itemListener2EntryListener.put(itemListener,e);
}",0.9950413223140496
50253,"public synchronized boolean shouldExecuteOnDisconnect(Connection connection){
  if (lastDisconnectedConnectionId >= connection.getVersion()) {
    return false;
  }
  lastDisconnectedConnectionId=connection.getVersion();
  return true;
}","public synchronized boolean shouldExecuteOnDisconnect(Connection connection){
  if (connection == null || lastDisconnectedConnectionId >= connection.getVersion()) {
    return false;
  }
  lastDisconnectedConnectionId=connection.getVersion();
  return true;
}",0.9556451612903226
50254,"public Connection getConnection() throws IOException {
  if (currentConnection == null) {
synchronized (this) {
      if (currentConnection == null) {
        Connection connection=searchForAvailableConnection();
        if (connection != null) {
          logger.log(Level.FINE,""String_Node_Str"" + connection);
          bindConnection(connection);
          currentConnection=connection;
        }
      }
    }
  }
  return currentConnection;
}","public Connection getConnection() throws IOException {
  if (currentConnection == null) {
    boolean restored=false;
synchronized (this) {
      if (currentConnection == null) {
        Connection connection=searchForAvailableConnection();
        if (connection != null) {
          logger.log(Level.FINE,""String_Node_Str"" + connection);
          bindConnection(connection);
          currentConnection=connection;
        }
        restored=currentConnection != null;
      }
    }
    if (restored) {
      notifyConnectionIsRestored();
    }
  }
  return currentConnection;
}",0.8190661478599222
50255,"public ConnectionManager(final HazelcastClient client,InetSocketAddress address){
  this.client=client;
  this.clusterMembers.add(address);
}","public ConnectionManager(final HazelcastClient client,LifecycleServiceClientImpl lifecycleService,InetSocketAddress address){
  this.client=client;
  this.lifecycleService=lifecycleService;
  this.clusterMembers.add(address);
}",0.7663043478260869
50256,"public Connection getAliveConnection(){
  if (currentConnection == null) {
synchronized (this) {
      int attempt=0;
      while (currentConnection == null) {
        Connection connection=searchForAvailableConnection();
        if (connection != null) {
          logger.log(Level.FINE,""String_Node_Str"" + connection);
          currentConnection=connection;
        }
 else {
          if (attempt >= RECONNECTION_ATTEMPTS_LIMIT) {
            break;
          }
          attempt++;
          logger.log(Level.INFO,format(""String_Node_Str"" + ""String_Node_Str"",RECONNECTION_TIMEOUT,attempt,RECONNECTION_ATTEMPTS_LIMIT));
          try {
            Thread.sleep(RECONNECTION_TIMEOUT);
          }
 catch (          InterruptedException e) {
            break;
          }
        }
      }
    }
  }
  return currentConnection;
}","public Connection getAliveConnection(){
  if (currentConnection == null) {
synchronized (this) {
      currentConnection=lookForAliveConnection();
    }
  }
  return currentConnection;
}",0.3398821218074656
50257,"public synchronized void destroyConnection(Connection connection){
  if (currentConnection != null && currentConnection.getVersion() == connection.getVersion()) {
    logger.log(Level.WARNING,""String_Node_Str"" + currentConnection + ""String_Node_Str"");
    currentConnection=null;
  }
}","public void destroyConnection(Connection connection){
  boolean lost=false;
synchronized (this) {
    if (currentConnection != null && currentConnection.getVersion() == connection.getVersion()) {
      logger.log(Level.WARNING,""String_Node_Str"" + currentConnection + ""String_Node_Str"");
      currentConnection=null;
      lost=true;
    }
  }
  if (lost) {
    lifecycleService.fireLifecycleEvent(CLIENT_CONNECTION_LOST);
  }
}",0.6704067321178121
50258,"protected boolean restoredConnection(Connection oldConnection,Connection newConnection){
  final boolean isOldConnectionNull=oldConnection == null;
  final long oldConnectionId=oldConnection == null ? -1 : oldConnection.getVersion();
  return restoredConnection(newConnection,isOldConnectionNull,oldConnectionId);
}","protected boolean restoredConnection(Connection oldConnection,Connection newConnection){
  final long oldConnectionId=oldConnection == null ? -1 : oldConnection.getVersion();
  return restoredConnection(newConnection,oldConnectionId);
}",0.8566243194192378
50259,"public void interruptWaitingCalls(){
  Collection<Call> calls=callMap.values();
  for (  Call call : calls) {
    call.setResponse(new NoMemberAvailableException());
  }
  calls.clear();
  new Thread(new Runnable(){
    public void run(){
      client.shutdown();
    }
  }
).start();
}","public void interruptWaitingCalls(){
  final Collection<Call> values=callMap.values();
  for (Iterator<Call> it=values.iterator(); it.hasNext(); ) {
    Call call=it.next();
    call.setResponse(new NoMemberAvailableException());
    it.remove();
  }
}",0.550185873605948
50260,"protected void customRun(){
  Packet packet;
  try {
    Connection oldConnection=connection;
    connection=client.connectionManager.getConnection();
    if (restoredConnection(oldConnection,connection)) {
      redoUnfinishedCalls(oldConnection);
    }
    if (connection == null) {
      interruptWaitingCalls();
      Thread.sleep(50);
    }
 else {
      packet=reader.readPacket(connection);
      logger.log(Level.FINEST,""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
      Call call=callMap.remove(packet.getCallId());
      if (call != null) {
        call.setResponse(packet);
      }
 else {
        if (packet.getOperation().equals(ClusterOperation.EVENT)) {
          client.getListenerManager().enqueue(packet);
        }
        if (packet.getCallId() != -1) {
          logger.log(Level.SEVERE,""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
        }
      }
    }
  }
 catch (  RuntimeException re) {
    throw re;
  }
catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"" + e.toString());
    client.connectionManager.destroyConnection(connection);
  }
}","protected void customRun(){
  Packet packet;
  try {
    Connection oldConnection=connection;
    connection=client.connectionManager.getConnection();
    if (oldConnection != null && restoredConnection(oldConnection,connection)) {
      redoUnfinishedCalls(oldConnection);
    }
    if (connection == null) {
      interruptWaitingCalls();
      Thread.sleep(50);
    }
 else {
      packet=reader.readPacket(connection);
      logger.log(Level.FINEST,""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
      Call call=callMap.remove(packet.getCallId());
      if (call != null) {
        call.setResponse(packet);
      }
 else {
        if (packet.getOperation().equals(ClusterOperation.EVENT)) {
          client.getListenerManager().enqueue(packet);
        }
        if (packet.getCallId() != -1) {
          logger.log(Level.SEVERE,""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
        }
      }
    }
  }
 catch (  RuntimeException re) {
    throw re;
  }
catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"" + e.toString());
    client.connectionManager.destroyConnection(connection);
  }
}",0.9893390191897654
50261,"public boolean resume(){
synchronized (lifecycleLock) {
    if (paused.get()) {
      fireLifecycleEvent(new LifecycleEvent(LifecycleEvent.LifecycleState.RESUMING));
    }
 else {
      return false;
    }
    paused.set(false);
    fireLifecycleEvent(new LifecycleEvent(LifecycleEvent.LifecycleState.RESUMED));
    return true;
  }
}","public boolean resume(){
synchronized (lifecycleLock) {
    if (paused.get()) {
      fireLifecycleEvent(RESUMING);
    }
 else {
      return false;
    }
    paused.set(false);
    fireLifecycleEvent(RESUMED);
    return true;
  }
}",0.7394366197183099
50262,"public void fireLifecycleEvent(LifecycleEvent lifecycleEvent){
  logger.log(Level.INFO,""String_Node_Str"" + lifecycleEvent.getState());
  for (  LifecycleListener lifecycleListener : lsLifecycleListeners) {
    lifecycleListener.stateChanged(lifecycleEvent);
  }
}","public void fireLifecycleEvent(final LifecycleEvent event){
  logger.log(Level.INFO,""String_Node_Str"" + event.getState());
  for (  LifecycleListener lifecycleListener : lsLifecycleListeners) {
    lifecycleListener.stateChanged(event);
  }
}",0.9227722772277228
50263,"public boolean pause(){
synchronized (lifecycleLock) {
    if (!paused.get()) {
      fireLifecycleEvent(new LifecycleEvent(LifecycleEvent.LifecycleState.PAUSING));
    }
 else {
      return false;
    }
    paused.set(true);
    fireLifecycleEvent(new LifecycleEvent(LifecycleEvent.LifecycleState.PAUSED));
    return true;
  }
}","public boolean pause(){
synchronized (lifecycleLock) {
    if (!paused.get()) {
      fireLifecycleEvent(PAUSING);
    }
 else {
      return false;
    }
    paused.set(true);
    fireLifecycleEvent(PAUSED);
    return true;
  }
}",0.7366548042704626
50264,"public void shutdown(){
synchronized (lifecycleLock) {
    long begin=System.currentTimeMillis();
    fireLifecycleEvent(new LifecycleEvent(LifecycleEvent.LifecycleState.SHUTTING_DOWN));
    hazelcastClient.doShutdown();
    running.set(false);
    long time=System.currentTimeMillis() - begin;
    logger.log(Level.FINE,""String_Node_Str"" + time + ""String_Node_Str"");
    fireLifecycleEvent(new LifecycleEvent(LifecycleEvent.LifecycleState.SHUTDOWN));
  }
}","public void shutdown(){
synchronized (lifecycleLock) {
    long begin=System.currentTimeMillis();
    fireLifecycleEvent(SHUTTING_DOWN);
    hazelcastClient.doShutdown();
    running.set(false);
    long time=System.currentTimeMillis() - begin;
    logger.log(Level.FINE,""String_Node_Str"" + time + ""String_Node_Str"");
    fireLifecycleEvent(SHUTDOWN);
  }
}",0.8771498771498771
50265,"public Connection lookForAliveConnection(){
  final int attemptsLimit=client.getProperties().getInteger(ClientPropertyName.RECONNECTION_ATTEMPTS_LIMIT);
  final int reconnectionTimeout=client.getProperties().getInteger(ClientPropertyName.RECONNECTION_TIMEOUT);
  boolean restored=false;
  int attempt=0;
  while (currentConnection == null) {
synchronized (this) {
      if (currentConnection == null) {
        currentConnection=searchForAvailableConnection();
        restored=currentConnection != null;
      }
    }
    if (currentConnection != null) {
      logger.log(Level.FINE,""String_Node_Str"" + currentConnection);
      break;
    }
    if (attempt >= attemptsLimit) {
      break;
    }
    attempt++;
    logger.log(Level.INFO,format(""String_Node_Str"" + ""String_Node_Str"",reconnectionTimeout,attempt,attemptsLimit));
    try {
      Thread.sleep(reconnectionTimeout);
    }
 catch (    InterruptedException e) {
      break;
    }
  }
  if (restored) {
    notifyConnectionIsRestored();
  }
  return currentConnection;
}","private Connection lookForAliveConnection(final int attemptsLimit,final int reconnectionTimeout){
  boolean restored=false;
  int attempt=0;
  while (currentConnection == null) {
synchronized (this) {
      if (currentConnection == null) {
        currentConnection=searchForAvailableConnection();
        restored=currentConnection != null;
      }
    }
    if (currentConnection != null) {
      logger.log(Level.FINE,""String_Node_Str"" + currentConnection);
      break;
    }
    if (attempt >= attemptsLimit) {
      break;
    }
    attempt++;
    logger.log(Level.INFO,format(""String_Node_Str"" + ""String_Node_Str"",reconnectionTimeout,attempt,attemptsLimit));
    try {
      Thread.sleep(reconnectionTimeout);
    }
 catch (    InterruptedException e) {
      break;
    }
  }
  if (restored) {
    notifyConnectionIsRestored();
  }
  return currentConnection;
}",0.8521830615465544
50266,"public InRunnable(HazelcastClient client,Map<Long,Call> calls,PacketReader reader){
  super(client,calls);
  this.reader=reader;
}","public InRunnable(HazelcastClient client,OutRunnable outRunnable,Map<Long,Call> calls,PacketReader reader){
  super(client,calls);
  this.outRunnable=outRunnable;
  this.reader=reader;
}",0.8227848101265823
50267,"protected void customRun(){
  Packet packet;
  try {
    Connection oldConnection=connection;
    connection=client.connectionManager.getConnection();
    if (oldConnection != null && restoredConnection(oldConnection,connection)) {
      redoUnfinishedCalls(oldConnection);
    }
    if (connection == null) {
      interruptWaitingCalls();
      Thread.sleep(50);
    }
 else {
      packet=reader.readPacket(connection);
      logger.log(Level.FINEST,""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
      Call call=callMap.remove(packet.getCallId());
      if (call != null) {
        call.setResponse(packet);
      }
 else {
        if (packet.getOperation().equals(ClusterOperation.EVENT)) {
          client.getListenerManager().enqueue(packet);
        }
        if (packet.getCallId() != -1) {
          logger.log(Level.SEVERE,""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
        }
      }
    }
  }
 catch (  RuntimeException re) {
    throw re;
  }
catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"" + e.toString());
    client.connectionManager.destroyConnection(connection);
  }
}","protected void customRun(){
  Packet packet;
  try {
    Connection oldConnection=connection;
    connection=client.connectionManager.getConnection();
    if (oldConnection != null && restoredConnection(oldConnection,connection)) {
      redoUnfinishedCalls(oldConnection);
    }
    if (connection == null) {
      outRunnable.clusterIsDown();
      Thread.sleep(50);
    }
 else {
      packet=reader.readPacket(connection);
      logger.log(Level.FINEST,""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
      Call call=callMap.remove(packet.getCallId());
      if (call != null) {
        call.setResponse(packet);
      }
 else {
        if (packet.getOperation().equals(ClusterOperation.EVENT)) {
          client.getListenerManager().enqueue(packet);
        }
        if (packet.getCallId() != -1) {
          logger.log(Level.SEVERE,""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
        }
      }
    }
  }
 catch (  RuntimeException re) {
    throw re;
  }
catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"" + e.toString());
    client.connectionManager.destroyConnection(connection);
  }
}",0.9806234203875316
50268,"private void clusterIsDown(){
  interruptWaitingCalls();
  if (!reconnection) {
    reconnection=true;
    final Thread thread=new Thread(new Runnable(){
      public void run(){
        try {
          final Connection c=client.getConnectionManager().lookForAliveConnection();
          final Connection oldConnection=connection;
          connection=c;
          if (connection == null) {
            if (reconnection) {
              reconnection=false;
              interruptWaitingCallsAndShutdown();
            }
          }
 else           if (restoredConnection(oldConnection,connection)) {
            resubscribe(oldConnection);
          }
        }
  finally {
          reconnection=false;
        }
      }
    }
);
    thread.setName(""String_Node_Str"");
    thread.setDaemon(true);
    thread.start();
  }
}","void clusterIsDown(){
  interruptWaitingCalls();
  if (!reconnection) {
    reconnection=true;
    final Thread thread=new Thread(new Runnable(){
      public void run(){
        try {
          if (client.getConnectionManager().lookForAliveConnection() == null) {
            if (reconnection) {
              interruptWaitingCallsAndShutdown();
            }
          }
 else {
            try {
              queue.put(RECONNECT_CALL);
            }
 catch (            InterruptedException e) {
            }
          }
        }
  finally {
          reconnection=false;
        }
      }
    }
);
    thread.setName(""String_Node_Str"");
    thread.setDaemon(true);
    thread.start();
  }
}",0.740302432610125
50269,"protected void customRun() throws InterruptedException {
  Call call=queue.poll(100,TimeUnit.MILLISECONDS);
  try {
    if (call == null)     return;
    int count=0;
    while (call != null) {
      callMap.put(call.getId(),call);
      Connection oldConnection=connection;
      connection=client.getConnectionManager().getConnection();
      if (restoredConnection(oldConnection,connection)) {
        resubscribe(call,oldConnection);
      }
 else       if (connection != null) {
        logger.log(Level.FINEST,""String_Node_Str"" + call);
        writer.write(connection,call.getRequest());
      }
 else {
        clusterIsDown();
      }
      call=null;
      if (count++ < 24) {
        call=queue.poll();
      }
    }
    if (connection != null) {
      writer.flush(connection);
    }
  }
 catch (  Throwable io) {
    logger.log(Level.FINE,""String_Node_Str"" + io.getMessage());
    io.printStackTrace();
    enQueue(call);
    client.getConnectionManager().destroyConnection(connection);
  }
}","protected void customRun() throws InterruptedException {
  Call call=queue.poll(100,TimeUnit.MILLISECONDS);
  try {
    if (call == null)     return;
    int count=0;
    while (call != null) {
      if (call != RECONNECT_CALL) {
        callMap.put(call.getId(),call);
      }
      Connection oldConnection=connection;
      connection=client.getConnectionManager().getConnection();
      if (restoredConnection(oldConnection,connection)) {
        resubscribe(call,oldConnection);
      }
 else       if (connection != null) {
        if (call != RECONNECT_CALL) {
          logger.log(Level.FINEST,""String_Node_Str"" + call);
          writer.write(connection,call.getRequest());
        }
      }
 else {
        clusterIsDown();
      }
      call=null;
      if (count++ < 24) {
        call=queue.poll();
      }
    }
    if (connection != null) {
      writer.flush(connection);
    }
  }
 catch (  Throwable io) {
    logger.log(Level.FINE,""String_Node_Str"" + io.getMessage());
    io.printStackTrace();
    enQueue(call);
    client.getConnectionManager().destroyConnection(connection);
  }
}",0.9535104364326376
50270,"private void resubscribe(Connection oldConnection){
  queue.addAll(client.getListenerManager().getListenerCalls());
  if (oldConnection != null) {
    onDisconnect(oldConnection);
  }
}","private void resubscribe(Call call,Connection oldConnection){
  final BlockingQueue<Call> temp=new LinkedBlockingQueue<Call>();
  temp.add(call);
  queue.drainTo(temp);
  queue.addAll(client.getListenerManager().getListenerCalls());
  temp.drainTo(queue);
  onDisconnect(oldConnection);
}",0.6342494714587738
50271,"public void run(){
  try {
    final Connection c=client.getConnectionManager().lookForAliveConnection();
    final Connection oldConnection=connection;
    connection=c;
    if (connection == null) {
      if (reconnection) {
        reconnection=false;
        interruptWaitingCallsAndShutdown();
      }
    }
 else     if (restoredConnection(oldConnection,connection)) {
      resubscribe(oldConnection);
    }
  }
  finally {
    reconnection=false;
  }
}","public void run(){
  try {
    if (client.getConnectionManager().lookForAliveConnection() == null) {
      if (reconnection) {
        interruptWaitingCallsAndShutdown();
      }
    }
 else {
      try {
        queue.put(RECONNECT_CALL);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  finally {
    reconnection=false;
  }
}",0.5997521685254027
50272,"private void joinWithMulticast(){
  int tryCount=0;
  while (!joined) {
    try {
      logger.log(Level.FINEST,""String_Node_Str"" + masterAddress);
      if (masterAddress == null) {
        masterAddress=findMaster();
        if (masterAddress == null || masterAddress.equals(address)) {
          TcpIpConfig tcpIpConfig=config.getNetworkConfig().getJoin().getTcpIpConfig();
          if (tcpIpConfig != null && tcpIpConfig.isEnabled()) {
            masterAddress=null;
            logger.log(Level.FINEST,""String_Node_Str"");
            joinWithTCP();
          }
 else {
            setAsMaster();
          }
          return;
        }
      }
      if (tryCount++ > 20) {
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + tryCount);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + address);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + masterAddress);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + connectionManager.getConnection(masterAddress));
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        logger.log(Level.WARNING,sb.toString());
        tryCount=0;
      }
      if (!masterAddress.equals(address)) {
        connectAndSendJoinRequest(masterAddress);
      }
 else {
        masterAddress=null;
        tryCount=0;
      }
      Thread.sleep(500L);
    }
 catch (    final Exception e) {
      logger.log(Level.FINEST,""String_Node_Str"",e);
    }
  }
}","private void joinWithMulticast(){
  int tryCount=0;
  while (!joined) {
    try {
      logger.log(Level.FINEST,""String_Node_Str"" + masterAddress);
      masterAddress=null;
      masterAddress=findMaster();
      if (masterAddress == null) {
        if (masterAddress == null || masterAddress.equals(address)) {
          TcpIpConfig tcpIpConfig=config.getNetworkConfig().getJoin().getTcpIpConfig();
          if (tcpIpConfig != null && tcpIpConfig.isEnabled()) {
            masterAddress=null;
            logger.log(Level.FINEST,""String_Node_Str"");
            joinWithTCP();
          }
 else {
            setAsMaster();
          }
          return;
        }
      }
      if (tryCount++ > 20) {
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + tryCount);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + address);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + masterAddress);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + connectionManager.getConnection(masterAddress));
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        logger.log(Level.WARNING,sb.toString());
        tryCount=0;
      }
      if (!masterAddress.equals(address)) {
        connectAndSendJoinRequest(masterAddress);
      }
 else {
        masterAddress=null;
        tryCount=0;
      }
      Thread.sleep(500L);
    }
 catch (    final Exception e) {
      logger.log(Level.FINEST,""String_Node_Str"",e);
    }
  }
}",0.9709267110841914
50273,"public void addInstanceListener(InstanceListener listener){
  check(listener);
  if (client.getListenerManager().getInstanceListenerManager().noInstanceListenerRegistered()) {
    Packet request=proxyHelper.createRequestPacket(ClusterOperation.CLIENT_ADD_INSTANCE_LISTENER,null,null);
    Call c=proxyHelper.createCall(request);
    client.getListenerManager().addListenerCall(c);
    proxyHelper.doCall(c);
  }
  client.getListenerManager().getInstanceListenerManager().registerInstanceListener(listener);
}","public void addInstanceListener(InstanceListener listener){
  check(listener);
  if (instanceListenerManager().noInstanceListenerRegistered()) {
    Call c=instanceListenerManager().createNewAddListenerCall(proxyHelper);
    proxyHelper.doCall(c);
  }
  instanceListenerManager().registerInstanceListener(listener);
}",0.3612121212121212
50274,"public void removeInstanceListener(InstanceListener instanceListener){
  check(instanceListener);
  client.getListenerManager().getInstanceListenerManager().removeInstanceListener(instanceListener);
}","public void removeInstanceListener(InstanceListener instanceListener){
  check(instanceListener);
  instanceListenerManager().removeInstanceListener(instanceListener);
}",0.9159891598915988
50275,"public synchronized void removeItemListener(ItemListener<E> listener){
  check(listener);
  proxyHelper.getHazelcastClient().getListenerManager().getItemListenerManager().removeItemListener(name,listener);
  Packet request=proxyHelper.createRequestPacket(ClusterOperation.REMOVE_LISTENER,null,null);
  Call c=proxyHelper.createCall(request);
  proxyHelper.doCall(c);
}","public synchronized void removeItemListener(ItemListener<E> listener){
  check(listener);
  itemListenerManager().removeItemListener(name,listener);
  Packet request=proxyHelper.createRequestPacket(ClusterOperation.REMOVE_LISTENER,null,null);
  Call c=proxyHelper.createCall(request);
  proxyHelper.doCall(c);
}",0.4594992636229749
50276,"public synchronized void addItemListener(ItemListener<E> listener,boolean includeValue){
  check(listener);
  Packet request=proxyHelper.createRequestPacket(ClusterOperation.ADD_LISTENER,null,null);
  request.setLongValue(includeValue ? 1 : 0);
  Call c=proxyHelper.createCall(request);
  proxyHelper.getHazelcastClient().getListenerManager().addListenerCall(c);
  proxyHelper.getHazelcastClient().getListenerManager().getItemListenerManager().registerItemListener(name,listener);
  proxyHelper.doCall(c);
}","public synchronized void addItemListener(ItemListener<E> listener,boolean includeValue){
  check(listener);
  Call c=itemListenerManager().createNewAddListenerCall(proxyHelper,includeValue);
  itemListenerManager().registerItemListener(name,listener);
  proxyHelper.doCall(c);
}",0.3745222929936305
50277,"protected boolean restoredConnection(Connection oldConnection,Connection newConnection){
  long oldConnectionId=-1;
  boolean isOldConnectionNull=(oldConnection == null);
  if (!isOldConnectionNull) {
    oldConnectionId=oldConnection.getVersion();
  }
  return restoredConnection(newConnection,isOldConnectionNull,oldConnectionId);
}","protected boolean restoredConnection(Connection oldConnection,Connection newConnection){
  final boolean isOldConnectionNull=oldConnection == null;
  final long oldConnectionId=oldConnection == null ? -1 : oldConnection.getVersion();
  return restoredConnection(newConnection,isOldConnectionNull,oldConnectionId);
}",0.687211093990755
50278,"protected void customRun(){
  Packet packet;
  try {
    Connection oldConnection=connection;
    connection=client.connectionManager.getConnection();
    if (restoredConnection(oldConnection,connection)) {
      onDisconnect(oldConnection);
    }
    if (connection == null) {
      interruptWaitingCalls();
      Thread.sleep(50);
    }
 else {
      packet=reader.readPacket(connection);
      logger.log(Level.FINEST,""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
      Call call=callMap.remove(packet.getCallId());
      if (call != null) {
        call.setResponse(packet);
      }
 else {
        if (packet.getOperation().equals(ClusterOperation.EVENT)) {
          client.getListenerManager().enqueue(packet);
        }
        if (packet.getCallId() != -1) {
          logger.log(Level.SEVERE,""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
        }
      }
    }
  }
 catch (  RuntimeException re) {
    throw re;
  }
catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"" + e.toString());
    client.connectionManager.destroyConnection(connection);
  }
}","protected void customRun(){
  Packet packet;
  try {
    Connection oldConnection=connection;
    connection=client.connectionManager.getConnection();
    if (restoredConnection(oldConnection,connection)) {
      redoUnfinishedCalls(oldConnection);
    }
    if (connection == null) {
      interruptWaitingCalls();
      Thread.sleep(50);
    }
 else {
      packet=reader.readPacket(connection);
      logger.log(Level.FINEST,""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
      Call call=callMap.remove(packet.getCallId());
      if (call != null) {
        call.setResponse(packet);
      }
 else {
        if (packet.getOperation().equals(ClusterOperation.EVENT)) {
          client.getListenerManager().enqueue(packet);
        }
        if (packet.getCallId() != -1) {
          logger.log(Level.SEVERE,""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
        }
      }
    }
  }
 catch (  RuntimeException re) {
    throw re;
  }
catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"" + e.toString());
    client.connectionManager.destroyConnection(connection);
  }
}",0.9865974924340684
50279,"public String getName(){
  return name.substring(2);
}","public String getName(){
  return name.substring(Prefix.MAP.length());
}",0.8412698412698413
50280,"public void removeEntryListener(EntryListener<K,V> listener,K key){
  check(listener);
  check(key);
  proxyHelper.doOp(ClusterOperation.REMOVE_LISTENER,key,null);
  proxyHelper.getHazelcastClient().getListenerManager().getEntryListenerManager().removeEntryListener(name,key,listener);
}","public void removeEntryListener(EntryListener<K,V> listener,K key){
  check(listener);
  check(key);
  proxyHelper.doOp(ClusterOperation.REMOVE_LISTENER,key,null);
  listenerManager().removeEntryListener(name,key,listener);
}",0.8125
50281,"public void addEntryListener(EntryListener<K,V> listener,K key,boolean includeValue){
  check(listener);
  Boolean noEntryListenerRegistered=proxyHelper.getHazelcastClient().getListenerManager().getEntryListenerManager().noEntryListenerRegistered(key,name,includeValue);
  if (noEntryListenerRegistered == null) {
    proxyHelper.doOp(ClusterOperation.REMOVE_LISTENER,key,null);
    noEntryListenerRegistered=Boolean.TRUE;
  }
  if (noEntryListenerRegistered) {
    Packet request=proxyHelper.createRequestPacket(ClusterOperation.ADD_LISTENER,toByte(key),null);
    request.setLongValue(includeValue ? 1 : 0);
    Call c=proxyHelper.createCall(request);
    proxyHelper.getHazelcastClient().getListenerManager().addListenerCall(c);
    proxyHelper.doCall(c);
  }
  proxyHelper.getHazelcastClient().getListenerManager().getEntryListenerManager().registerEntryListener(name,key,includeValue,listener);
}","public void addEntryListener(EntryListener<K,V> listener,K key,boolean includeValue){
  check(listener);
  Boolean noEntryListenerRegistered=listenerManager().noEntryListenerRegistered(key,name,includeValue);
  if (noEntryListenerRegistered == null) {
    proxyHelper.doOp(ClusterOperation.REMOVE_LISTENER,key,null);
    noEntryListenerRegistered=Boolean.TRUE;
  }
  if (noEntryListenerRegistered) {
    Call c=listenerManager().createNewAddListenerCall(proxyHelper,key,includeValue);
    proxyHelper.doCall(c);
  }
  listenerManager().registerEntryListener(name,key,includeValue,listener);
}",0.5693235097119893
50282,"@Override public boolean equals(Object o){
  if (o instanceof IMap && o != null) {
    return getName().equals(((IMap)o).getName());
  }
 else {
    return false;
  }
}","@Override public boolean equals(Object o){
  if (o instanceof IMap) {
    return getName().equals(((IMap)o).getName());
  }
  return false;
}",0.912621359223301
50283,"public String getName(){
  return name.substring(4);
}","public String getName(){
  return name.substring(Prefix.MULTIMAP.length());
}",0.8091603053435115
50284,"public void removeEntryListener(EntryListener<K,V> listener,K key){
  check(listener);
  check(key);
  proxyHelper.doOp(ClusterOperation.REMOVE_LISTENER,key,null);
  client.getListenerManager().getEntryListenerManager().removeEntryListener(name,key,listener);
}","public void removeEntryListener(EntryListener<K,V> listener,K key){
  check(listener);
  check(key);
  proxyHelper.doOp(ClusterOperation.REMOVE_LISTENER,key,null);
  entryListenerManager().removeEntryListener(name,key,listener);
}",0.8472505091649695
50285,"public void addEntryListener(EntryListener<K,V> listener,K key,boolean includeValue){
  check(listener);
  Boolean noEntryListenerRegistered=client.getListenerManager().getEntryListenerManager().noEntryListenerRegistered(key,name,includeValue);
  if (noEntryListenerRegistered == null) {
    proxyHelper.doOp(ClusterOperation.REMOVE_LISTENER,key,null);
    noEntryListenerRegistered=Boolean.TRUE;
  }
  if (noEntryListenerRegistered.booleanValue()) {
    Packet request=proxyHelper.createRequestPacket(ClusterOperation.ADD_LISTENER,toByte(key),null);
    request.setLongValue(includeValue ? 1 : 0);
    Call c=proxyHelper.createCall(request);
    client.getListenerManager().addListenerCall(c);
    proxyHelper.doCall(c);
  }
  client.getListenerManager().getEntryListenerManager().registerEntryListener(name,key,includeValue,listener);
}","public void addEntryListener(EntryListener<K,V> listener,K key,boolean includeValue){
  check(listener);
  Boolean noEntryListenerRegistered=entryListenerManager().noEntryListenerRegistered(key,name,includeValue);
  if (noEntryListenerRegistered == null) {
    proxyHelper.doOp(ClusterOperation.REMOVE_LISTENER,key,null);
    noEntryListenerRegistered=Boolean.TRUE;
  }
  if (noEntryListenerRegistered.booleanValue()) {
    Call c=entryListenerManager().createNewAddListenerCall(proxyHelper,key,includeValue);
    proxyHelper.doCall(c);
  }
  entryListenerManager().registerEntryListener(name,key,includeValue,listener);
}",0.6068493150684932
50286,"@Override public boolean equals(Object o){
  if (o instanceof MultiMap && o != null) {
    return getName().equals(((MultiMap)o).getName());
  }
 else {
    return false;
  }
}","@Override public boolean equals(Object o){
  if (o instanceof MultiMap) {
    return getName().equals(((MultiMap)o).getName());
  }
  return false;
}",0.916923076923077
50287,"protected void customRun() throws InterruptedException {
  Call call=queue.poll(100,TimeUnit.MILLISECONDS);
  try {
    if (call == null)     return;
    int count=0;
    while (call != null) {
      callMap.put(call.getId(),call);
      Connection oldConnection=connection;
      connection=client.getConnectionManager().getConnection();
      if (restoredConnection(oldConnection,connection)) {
        redoUnfinishedCalls(call,oldConnection);
      }
 else       if (connection != null) {
        logger.log(Level.FINEST,""String_Node_Str"" + call);
        writer.write(connection,call.getRequest());
      }
 else {
        interruptWaitingCalls();
      }
      call=null;
      if (count++ < 24) {
        call=queue.poll();
      }
    }
    if (connection != null) {
      writer.flush(connection);
    }
  }
 catch (  Throwable io) {
    logger.log(Level.FINE,""String_Node_Str"" + io.getMessage());
    io.printStackTrace();
    enQueue(call);
    client.getConnectionManager().destroyConnection(connection);
  }
}","protected void customRun() throws InterruptedException {
  Call call=queue.poll(100,TimeUnit.MILLISECONDS);
  try {
    if (call == null)     return;
    int count=0;
    while (call != null) {
      callMap.put(call.getId(),call);
      Connection oldConnection=connection;
      connection=client.getConnectionManager().getConnection();
      if (restoredConnection(oldConnection,connection)) {
        resubscribe(call,oldConnection);
      }
 else       if (connection != null) {
        logger.log(Level.FINEST,""String_Node_Str"" + call);
        writer.write(connection,call.getRequest());
      }
 else {
        interruptWaitingCalls();
      }
      call=null;
      if (count++ < 24) {
        call=queue.poll();
      }
    }
    if (connection != null) {
      writer.flush(connection);
    }
  }
 catch (  Throwable io) {
    logger.log(Level.FINE,""String_Node_Str"" + io.getMessage());
    io.printStackTrace();
    enQueue(call);
    client.getConnectionManager().destroyConnection(connection);
  }
}",0.9872173058013766
50288,"public String getName(){
  return name.substring(2);
}","public String getName(){
  return name.substring(Prefix.TOPIC.length());
}",0.828125
50289,"public synchronized void addMessageListener(MessageListener messageListener){
  check(messageListener);
  boolean shouldCall=proxyHelper.getHazelcastClient().getListenerManager().getMessageListenerManager().noMessageListenerRegistered(name);
  proxyHelper.getHazelcastClient().getListenerManager().getMessageListenerManager().registerMessageListener(name,messageListener);
  if (shouldCall) {
    doAddListenerCall(messageListener);
  }
}","public synchronized void addMessageListener(MessageListener messageListener){
  check(messageListener);
  boolean shouldCall=messageListenerManager().noMessageListenerRegistered(name);
  messageListenerManager().registerMessageListener(name,messageListener);
  if (shouldCall) {
    doAddListenerCall(messageListener);
  }
}",0.3543307086614173
50290,"private void doAddListenerCall(MessageListener messageListener){
  Packet request=proxyHelper.prepareRequest(ClusterOperation.ADD_LISTENER,null,null);
  Call c=proxyHelper.createCall(request);
  proxyHelper.getHazelcastClient().getListenerManager().addListenerCall(c);
  proxyHelper.doCall(c);
}","private void doAddListenerCall(MessageListener messageListener){
  Call c=messageListenerManager().createNewAddListenerCall(proxyHelper);
  proxyHelper.doCall(c);
}",0.6143790849673203
50291,"public synchronized void removeMessageListener(MessageListener messageListener){
  check(messageListener);
  proxyHelper.getHazelcastClient().getListenerManager().getMessageListenerManager().removeMessageListener(name,messageListener);
  if (proxyHelper.getHazelcastClient().getListenerManager().getMessageListenerManager().noMessageListenerRegistered(name)) {
    proxyHelper.doOp(ClusterOperation.REMOVE_LISTENER,null,null);
  }
}","public synchronized void removeMessageListener(MessageListener messageListener){
  check(messageListener);
  messageListenerManager().removeMessageListener(name,messageListener);
  if (messageListenerManager().noMessageListenerRegistered(name)) {
    proxyHelper.doOp(ClusterOperation.REMOVE_LISTENER,null,null);
  }
}",0.7813333333333333
50292,"@Override public boolean equals(Object o){
  if (o instanceof ITopic && o != null) {
    return getName().equals(((ITopic)o).getName());
  }
 else {
    return false;
  }
}","@Override public boolean equals(Object o){
  if (o instanceof ITopic) {
    return getName().equals(((ITopic)o).getName());
  }
  return false;
}",0.9148264984227128
50293,"public void readData(DataInput in) throws IOException {
  int size=in.readInt();
  keys=new ArrayList<K>();
  for (int i=0; i < size; i++) {
    int length=in.readInt();
    byte[] data=new byte[length];
    in.readFully(data);
    K obj=(K)toObject(data);
    keys.add(obj);
  }
}","public void readData(DataInput in) throws IOException {
  int size=in.readInt();
  keys=new ArrayList<K>(size);
  for (int i=0; i < size; i++) {
    int length=in.readInt();
    byte[] data=new byte[length];
    in.readFully(data);
    K obj=(K)toObject(data);
    keys.add(obj);
  }
}",0.9929328621908128
50294,"@Test public void testRun() throws Exception {
  final AtomicInteger counter=new AtomicInteger(0);
  final ClientRunnable clientRunnable=new ClientRunnable(){
    @Override protected void customRun() throws InterruptedException {
      counter.incrementAndGet();
    }
  }
;
  final CountDownLatch latch=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      try {
        Thread.sleep(10);
        clientRunnable.running=false;
synchronized (clientRunnable.monitor) {
          clientRunnable.monitor.wait();
        }
        latch.countDown();
      }
 catch (      InterruptedException e) {
      }
    }
  }
).start();
  clientRunnable.run();
  assertTrue(counter.get() > 1);
  assertTrue(""String_Node_Str"",latch.await(5,TimeUnit.SECONDS));
}","@Test public void testRun() throws Exception {
  final AtomicInteger counter=new AtomicInteger(0);
  final ClientRunnable clientRunnable=new ClientRunnable(){
    @Override protected void customRun() throws InterruptedException {
      counter.incrementAndGet();
    }
  }
;
  final CountDownLatch latch=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      try {
        Thread.sleep(50);
        clientRunnable.running=false;
synchronized (clientRunnable.monitor) {
          clientRunnable.monitor.wait();
        }
        latch.countDown();
      }
 catch (      InterruptedException e) {
      }
    }
  }
).start();
  clientRunnable.run();
  assertTrue(counter.get() > 1);
  assertTrue(""String_Node_Str"",latch.await(25,TimeUnit.SECONDS));
}",0.9980607627666452
50295,"@Test(expected=UnsupportedOperationException.class) public void testToArrayWithArgument() throws Exception {
  EntryHolder entryHolder=mock(EntryHolder.class);
  Set set=new HashSet();
  ValueCollection valueCollection=new ValueCollection(entryHolder,set);
  valueCollection.toArray(null);
}","@Test(expected=NullPointerException.class) public void testToArrayWithArgument() throws Exception {
  EntryHolder entryHolder=mock(EntryHolder.class);
  Set set=new HashSet();
  ValueCollection valueCollection=new ValueCollection(entryHolder,set);
  valueCollection.toArray(null);
}",0.9458987783595112
50296,"public CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.logger=concurrentMapManager.node.getLogger(CMap.class.getName());
  this.PARTITION_COUNT=concurrentMapManager.PARTITION_COUNT;
  this.blocks=concurrentMapManager.blocks;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  MapConfig mapConfig=null;
  String mapConfigName=name.substring(2);
  if (mapConfigName.startsWith(""String_Node_Str"") || mapConfigName.startsWith(AS_LIST) || mapConfigName.startsWith(AS_SET)) {
    mapConfig=new MapConfig();
  }
 else {
    mapConfig=node.getConfig().getMapConfig(mapConfigName);
  }
  this.mapIndexService=new MapIndexService(mapConfig.isValueIndexed());
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  evictionDelayMillis=mapConfig.getEvictionDelaySeconds() * 1000L;
  maxIdle=mapConfig.getMaxIdleSeconds() * 1000L;
  evictionPolicy=EvictionPolicy.valueOf(mapConfig.getEvictionPolicy());
  useBackupData=mapConfig.isUseBackupData();
  if (evictionPolicy == EvictionPolicy.NONE) {
    maxSize=Integer.MAX_VALUE;
    evictionComparator=null;
  }
 else {
    maxSize=(mapConfig.getMaxSize() == 0) ? MapConfig.DEFAULT_MAX_SIZE : mapConfig.getMaxSize();
    if (evictionPolicy == EvictionPolicy.LRU) {
      evictionComparator=LRU_COMPARATOR;
    }
 else {
      evictionComparator=LFU_COMPARATOR;
    }
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100f;
  instanceType=ConcurrentMapManager.getInstanceType(name);
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  MapStoreWrapper mapStoreWrapper=null;
  int writeDelaySeconds=-1;
  if (!node.isSuperClient() && mapStoreConfig != null && mapStoreConfig.isEnabled()) {
    try {
      Object storeInstance=mapStoreConfig.getImplementation();
      if (storeInstance == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeInstance=Serializer.classForName(node.getConfig().getClassLoader(),mapStoreClassName).newInstance();
      }
      mapStoreWrapper=new MapStoreWrapper(storeInstance,node.factory.getHazelcastInstanceProxy(),mapStoreConfig.getProperties(),mapConfigName);
    }
 catch (    Exception e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
    writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
  }
  if (!node.isSuperClient() && evictionPolicy == EvictionPolicy.NONE && instanceType == Instance.InstanceType.MAP) {
    locallyOwnedMap=new LocallyOwnedMap();
    concurrentMapManager.mapLocallyOwnedMaps.put(name,locallyOwnedMap);
  }
 else {
    locallyOwnedMap=null;
  }
  writeDelayMillis=(writeDelaySeconds == -1) ? -1L : writeDelaySeconds * 1000L;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + writeDelaySeconds;
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  loader=(mapStoreWrapper == null || !mapStoreWrapper.isMapLoader()) ? null : mapStoreWrapper;
  store=(mapStoreWrapper == null || !mapStoreWrapper.isMapStore()) ? null : mapStoreWrapper;
  NearCacheConfig nearCacheConfig=mapConfig.getNearCacheConfig();
  if (nearCacheConfig == null) {
    mapNearCache=null;
  }
 else {
    mapNearCache=new MapNearCache(this,SortedHashMap.getOrderingTypeByName(nearCacheConfig.getEvictionPolicy()),nearCacheConfig.getMaxSize(),nearCacheConfig.getTimeToLiveSeconds() * 1000L,nearCacheConfig.getMaxIdleSeconds() * 1000L,nearCacheConfig.isInvalidateOnChange());
    concurrentMapManager.mapCaches.put(name,mapNearCache);
  }
  MergePolicy mergePolicyTemp=null;
  String mergePolicyName=mapConfig.getMergePolicy();
  if (mergePolicyName != null && !""String_Node_Str"".equalsIgnoreCase(mergePolicyName)) {
    MergePolicyConfig mergePolicyConfig=node.getConfig().getMergePolicyConfig(mapConfig.getMergePolicy());
    if (mergePolicyConfig != null) {
      mergePolicyTemp=mergePolicyConfig.getImplementation();
      if (mergePolicyTemp == null) {
        String mergeClassName=mergePolicyConfig.getClassName();
        try {
          mergePolicyTemp=(MergePolicy)Serializer.classForName(node.getConfig().getClassLoader(),mergeClassName).newInstance();
        }
 catch (        Exception e) {
          logger.log(Level.SEVERE,e.getMessage(),e);
        }
      }
    }
  }
  this.mergePolicy=mergePolicyTemp;
  this.creationTime=System.currentTimeMillis();
}","CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.logger=concurrentMapManager.node.getLogger(CMap.class.getName());
  this.PARTITION_COUNT=concurrentMapManager.PARTITION_COUNT;
  this.blocks=concurrentMapManager.blocks;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  MapConfig mapConfig=null;
  String mapConfigName=name.substring(2);
  if (mapConfigName.startsWith(""String_Node_Str"") || mapConfigName.startsWith(AS_LIST) || mapConfigName.startsWith(AS_SET)) {
    mapConfig=new MapConfig();
  }
 else {
    mapConfig=node.getConfig().getMapConfig(mapConfigName);
  }
  this.mapIndexService=new MapIndexService(mapConfig.isValueIndexed());
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  evictionDelayMillis=mapConfig.getEvictionDelaySeconds() * 1000L;
  maxIdle=mapConfig.getMaxIdleSeconds() * 1000L;
  evictionPolicy=EvictionPolicy.valueOf(mapConfig.getEvictionPolicy());
  useBackupData=mapConfig.isUseBackupData();
  if (evictionPolicy == EvictionPolicy.NONE) {
    maxSize=Integer.MAX_VALUE;
    evictionComparator=null;
  }
 else {
    maxSize=(mapConfig.getMaxSize() == 0) ? MapConfig.DEFAULT_MAX_SIZE : mapConfig.getMaxSize();
    if (evictionPolicy == EvictionPolicy.LRU) {
      evictionComparator=LRU_COMPARATOR;
    }
 else {
      evictionComparator=LFU_COMPARATOR;
    }
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100f;
  instanceType=ConcurrentMapManager.getInstanceType(name);
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  MapStoreWrapper mapStoreWrapper=null;
  int writeDelaySeconds=-1;
  if (!node.isSuperClient() && mapStoreConfig != null && mapStoreConfig.isEnabled()) {
    try {
      Object storeInstance=mapStoreConfig.getImplementation();
      if (storeInstance == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeInstance=Serializer.classForName(node.getConfig().getClassLoader(),mapStoreClassName).newInstance();
      }
      mapStoreWrapper=new MapStoreWrapper(storeInstance,node.factory.getHazelcastInstanceProxy(),mapStoreConfig.getProperties(),mapConfigName);
    }
 catch (    Exception e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
    writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
  }
  if (!node.isSuperClient() && evictionPolicy == EvictionPolicy.NONE && instanceType == Instance.InstanceType.MAP) {
    LocallyOwnedMap locallyOwnedMap=new LocallyOwnedMap();
    LocallyOwnedMap anotherLocallyOwnedMap=concurrentMapManager.mapLocallyOwnedMaps.putIfAbsent(name,locallyOwnedMap);
    if (anotherLocallyOwnedMap != null) {
      locallyOwnedMap=anotherLocallyOwnedMap;
    }
    this.locallyOwnedMap=locallyOwnedMap;
  }
 else {
    locallyOwnedMap=null;
  }
  writeDelayMillis=(writeDelaySeconds == -1) ? -1L : writeDelaySeconds * 1000L;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + writeDelaySeconds;
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  loader=(mapStoreWrapper == null || !mapStoreWrapper.isMapLoader()) ? null : mapStoreWrapper;
  store=(mapStoreWrapper == null || !mapStoreWrapper.isMapStore()) ? null : mapStoreWrapper;
  NearCacheConfig nearCacheConfig=mapConfig.getNearCacheConfig();
  if (nearCacheConfig == null) {
    mapNearCache=null;
  }
 else {
    MapNearCache mapNearCache=new MapNearCache(this,SortedHashMap.getOrderingTypeByName(nearCacheConfig.getEvictionPolicy()),nearCacheConfig.getMaxSize(),nearCacheConfig.getTimeToLiveSeconds() * 1000L,nearCacheConfig.getMaxIdleSeconds() * 1000L,nearCacheConfig.isInvalidateOnChange());
    final MapNearCache anotherMapNearCache=concurrentMapManager.mapCaches.putIfAbsent(name,mapNearCache);
    if (anotherMapNearCache != null) {
      mapNearCache=anotherMapNearCache;
    }
    this.mapNearCache=mapNearCache;
  }
  MergePolicy mergePolicyTemp=null;
  String mergePolicyName=mapConfig.getMergePolicy();
  if (mergePolicyName != null && !""String_Node_Str"".equalsIgnoreCase(mergePolicyName)) {
    MergePolicyConfig mergePolicyConfig=node.getConfig().getMergePolicyConfig(mapConfig.getMergePolicy());
    if (mergePolicyConfig != null) {
      mergePolicyTemp=mergePolicyConfig.getImplementation();
      if (mergePolicyTemp == null) {
        String mergeClassName=mergePolicyConfig.getClassName();
        try {
          mergePolicyTemp=(MergePolicy)Serializer.classForName(node.getConfig().getClassLoader(),mergeClassName).newInstance();
        }
 catch (        Exception e) {
          logger.log(Level.SEVERE,e.getMessage(),e);
        }
      }
    }
  }
  this.mergePolicy=mergePolicyTemp;
  this.creationTime=System.currentTimeMillis();
}",0.9471303973296004
50297,"public CMap getOrCreateMap(String name){
  checkServiceThread();
  CMap map=maps.get(name);
  if (map == null) {
    map=new CMap(this,name);
    maps.put(name,map);
  }
  return map;
}","public CMap getOrCreateMap(String name){
  checkServiceThread();
  CMap map=maps.get(name);
  if (map == null) {
    map=new CMap(this,name);
    CMap anotherMap=maps.putIfAbsent(name,map);
    if (anotherMap != null) {
      map=anotherMap;
    }
  }
  return map;
}",0.7654867256637168
50298,"@Test public void testIssue290() throws Exception {
  String mapName=""String_Node_Str"";
  Config config=new XmlConfigBuilder().build();
  MapConfig mapConfig=new MapConfig();
  mapConfig.setName(mapName);
  mapConfig.setTimeToLiveSeconds(1);
  config.getMapConfigs().put(mapName,mapConfig);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  try {
    IMap<Object,Object> m1=h1.getMap(mapName);
    m1.put(1,1);
    assertEquals(1,m1.get(1));
    assertEquals(1,m1.get(1));
    Thread.sleep(2500);
    assertEquals(null,m1.get(1));
    m1.put(1,1);
    assertEquals(1,m1.get(1));
  }
  finally {
    h1.getLifecycleService().shutdown();
  }
}","@Test public void testIssue290() throws Exception {
  String mapName=""String_Node_Str"";
  Config config=new XmlConfigBuilder().build();
  MapConfig mapConfig=new MapConfig();
  mapConfig.setName(mapName);
  mapConfig.setTimeToLiveSeconds(1);
  config.getMapConfigs().put(mapName,mapConfig);
  config.setGroupConfig(new GroupConfig(""String_Node_Str"",""String_Node_Str""));
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  assertEquals(1,h1.getCluster().getMembers().size());
  try {
    IMap<Object,Object> m1=h1.getMap(mapName);
    m1.put(1,1);
    assertEquals(1,m1.get(1));
    assertEquals(1,m1.get(1));
    Thread.sleep(1050);
    assertEquals(null,m1.get(1));
    m1.put(1,1);
    assertEquals(1,m1.get(1));
  }
  finally {
    h1.getLifecycleService().shutdown();
  }
}",0.9045643153526972
50299,"@Test(expected=NullPointerException.class) public void testToArrayWithArgument() throws Exception {
  EntryHolder entryHolder=mock(EntryHolder.class);
  Set set=new HashSet();
  ValueCollection valueCollection=new ValueCollection(entryHolder,set);
  valueCollection.toArray(null);
}","@Test public void testToArrayWithArgument(){
  EntryHolder entryHolder=mock(EntryHolder.class);
  Set set=new HashSet();
  set.add(new MapEntry(""String_Node_Str"",""String_Node_Str""));
  set.add(new MapEntry(""String_Node_Str"",""String_Node_Str""));
  set.add(new MapEntry(""String_Node_Str"",""String_Node_Str""));
  ValueCollection valueCollection=new ValueCollection(entryHolder,set);
{
    final Object[] values=valueCollection.toArray();
    Arrays.sort(values);
    assertArrayEquals(new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},values);
  }
{
    final String[] values=(String[])valueCollection.toArray(new String[3]);
    Arrays.sort(values);
    assertArrayEquals(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},values);
  }
{
    final String[] values=(String[])valueCollection.toArray(new String[2]);
    Arrays.sort(values);
    assertArrayEquals(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},values);
  }
{
    final String[] values=(String[])valueCollection.toArray(new String[5]);
    Arrays.sort(values,0,3);
    assertArrayEquals(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null},values);
  }
}",0.0392687880839539
50300,"public void sendJoinRequest(Address toAddress){
  if (toAddress == null) {
    toAddress=node.getMasterAddress();
  }
  sendProcessableTo(new JoinRequest(thisAddress,node.getConfig().getGroupConfig().getName(),node.getConfig().getGroupConfig().getPassword(),node.getLocalNodeType(),Packet.PACKET_VERSION,node.getBuildNumber()),toAddress);
}","public void sendJoinRequest(Address toAddress){
  if (toAddress == null) {
    toAddress=node.getMasterAddress();
  }
  sendProcessableTo(node.createJoinInfo(),toAddress);
}",0.631578947368421
50301,"void handleJoinRequest(JoinRequest joinRequest){
  logger.log(Level.FINEST,joinInProgress + ""String_Node_Str"" + joinRequest);
  if (getMember(joinRequest.address) != null)   return;
  Connection conn=joinRequest.getConnection();
  if (node.validateJoinRequest(joinRequest)) {
    if (!node.getConfig().getNetworkConfig().getJoin().getMulticastConfig().isEnabled()) {
      if (node.isActive() && node.joined() && node.getMasterAddress() != null && !isMaster()) {
        sendProcessableTo(new Master(node.getMasterAddress()),conn);
      }
    }
    if (isMaster() && node.joined() && node.isActive()) {
      if (joinRequest.to != null && !joinRequest.to.equals(thisAddress)) {
        sendProcessableTo(new Master(node.getMasterAddress()),conn);
        return;
      }
      if (!joinInProgress) {
        MemberInfo newMemberInfo=new MemberInfo(joinRequest.address,joinRequest.nodeType);
        if (setJoins.add(newMemberInfo)) {
          sendProcessableTo(new Master(node.getMasterAddress()),conn);
          timeToStartJoin=System.currentTimeMillis() + WAIT_MILLIS_BEFORE_JOIN;
        }
 else {
          if (System.currentTimeMillis() > timeToStartJoin) {
            startJoin();
          }
        }
      }
    }
  }
 else {
    conn.close();
  }
}","void handleJoinRequest(JoinRequest joinRequest){
  logger.log(Level.FINEST,joinInProgress + ""String_Node_Str"" + joinRequest);
  if (getMember(joinRequest.address) != null) {
    return;
  }
  Connection conn=joinRequest.getConnection();
  if (node.validateJoinRequest(joinRequest)) {
    if (!node.getConfig().getNetworkConfig().getJoin().getMulticastConfig().isEnabled()) {
      if (node.isActive() && node.joined() && node.getMasterAddress() != null && !isMaster()) {
        sendProcessableTo(new Master(node.getMasterAddress()),conn);
      }
    }
    if (isMaster() && node.joined() && node.isActive()) {
      if (joinRequest.to != null && !joinRequest.to.equals(thisAddress)) {
        sendProcessableTo(new Master(node.getMasterAddress()),conn);
        return;
      }
      if (!joinInProgress) {
        MemberInfo newMemberInfo=new MemberInfo(joinRequest.address,joinRequest.nodeType);
        if (setJoins.add(newMemberInfo)) {
          sendProcessableTo(new Master(node.getMasterAddress()),conn);
          timeToStartJoin=System.currentTimeMillis() + WAIT_MILLIS_BEFORE_JOIN;
        }
 else {
          if (System.currentTimeMillis() > timeToStartJoin) {
            startJoin();
          }
        }
      }
    }
  }
 else {
    conn.close();
  }
}",0.9968404423380728
50302,"@Override public void readData(DataInput dis) throws IOException {
  setRequest(dis.readBoolean());
  address=new Address();
  address.readData(dis);
  groupName=dis.readUTF();
  groupPassword=dis.readUTF();
  packetVersion=dis.readByte();
  buildNumber=dis.readInt();
  memberCount=dis.readInt();
}","@Override public void readData(DataInput dis) throws IOException {
  super.readData(dis);
  setRequest(dis.readBoolean());
  memberCount=dis.readInt();
}",0.5752212389380531
50303,"@Override public void writeData(DataOutput out) throws IOException {
  try {
    out.writeBoolean(isRequest());
    address.writeData(out);
    out.writeUTF(groupName);
    out.writeUTF(groupPassword);
    out.writeByte(Packet.PACKET_VERSION);
    out.writeInt(buildNumber);
    out.writeInt(memberCount);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","@Override public void writeData(DataOutput out) throws IOException {
  try {
    super.writeData(out);
    out.writeBoolean(isRequest());
    out.writeInt(memberCount);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.6398659966499163
50304,"private void joinViaPossibleMembers(){
  try {
    failedConnections.clear();
    final Collection<Address> colPossibleAddresses=getPossibleMembers();
    colPossibleAddresses.remove(address);
    for (    final Address possibleAddress : colPossibleAddresses) {
      logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
      connectionManager.getOrConnect(possibleAddress);
    }
    boolean found=false;
    int numberOfSeconds=0;
    final int connectionTimeoutSeconds=config.getNetworkConfig().getJoin().getTcpIpConfig().getConnectionTimeoutSeconds();
    while (!found && numberOfSeconds < connectionTimeoutSeconds) {
      colPossibleAddresses.removeAll(failedConnections);
      if (colPossibleAddresses.size() == 0) {
        break;
      }
      Thread.sleep(1000L);
      numberOfSeconds++;
      int numberOfJoinReq=0;
      logger.log(Level.FINE,""String_Node_Str"");
      for (      Address possibleAddress : colPossibleAddresses) {
        logger.log(Level.FINEST,""String_Node_Str"" + numberOfJoinReq + ""String_Node_Str""+ possibleAddress);
        final Connection conn=connectionManager.getOrConnect(possibleAddress);
        if (conn != null && numberOfJoinReq < 5) {
          found=true;
          logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
          clusterManager.sendJoinRequest(possibleAddress);
          numberOfJoinReq++;
        }
 else {
          logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
        }
      }
    }
    logger.log(Level.FINEST,""String_Node_Str"" + found);
    if (!found) {
      logger.log(Level.FINEST,""String_Node_Str"");
      setAsMaster();
    }
 else {
      while (!joined) {
        int numberOfJoinReq=0;
        colPossibleAddresses.removeAll(failedConnections);
        for (        Address possibleAddress : colPossibleAddresses) {
          final Connection conn=connectionManager.getOrConnect(possibleAddress);
          if (conn != null && numberOfJoinReq < 5) {
            logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
            clusterManager.sendJoinRequest(possibleAddress);
            numberOfJoinReq++;
          }
 else {
            logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress + ""String_Node_Str"");
          }
        }
        int maxTryCount=3;
        for (        Address possibleAddress : colPossibleAddresses) {
          if (address.hashCode() > possibleAddress.hashCode()) {
            maxTryCount=6;
            break;
          }
 else           if (address.hashCode() == possibleAddress.hashCode()) {
            maxTryCount=3 + ((int)(Math.random() * 10));
            break;
          }
        }
        int tryCount=0;
        while (tryCount++ < maxTryCount && (masterAddress == null)) {
          Thread.sleep(1000L);
        }
        if (masterAddress == null) {
          boolean masterCandidate=true;
          for (          Address address : colPossibleAddresses) {
            if (this.address.hashCode() > address.hashCode()) {
              masterCandidate=false;
            }
          }
          if (masterCandidate) {
            logger.log(Level.FINEST,""String_Node_Str"");
            setAsMaster();
          }
        }
      }
    }
    colPossibleAddresses.clear();
    failedConnections.clear();
  }
 catch (  Exception e) {
    e.printStackTrace();
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
}","private void joinViaPossibleMembers(){
  try {
    failedConnections.clear();
    final Collection<Address> colPossibleAddresses=getPossibleMembers();
    colPossibleAddresses.remove(address);
    for (    final Address possibleAddress : colPossibleAddresses) {
      logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
      connectionManager.getOrConnect(possibleAddress);
    }
    boolean found=false;
    int numberOfSeconds=0;
    final int connectionTimeoutSeconds=config.getNetworkConfig().getJoin().getTcpIpConfig().getConnectionTimeoutSeconds();
    while (!found && numberOfSeconds < connectionTimeoutSeconds) {
      colPossibleAddresses.removeAll(failedConnections);
      if (colPossibleAddresses.size() == 0) {
        break;
      }
      Thread.sleep(1000L);
      numberOfSeconds++;
      int numberOfJoinReq=0;
      logger.log(Level.FINEST,""String_Node_Str"");
      for (      Address possibleAddress : colPossibleAddresses) {
        logger.log(Level.FINEST,""String_Node_Str"" + numberOfJoinReq + ""String_Node_Str""+ possibleAddress);
        final Connection conn=connectionManager.getOrConnect(possibleAddress);
        if (conn != null && numberOfJoinReq < 5) {
          found=true;
          logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
          clusterManager.sendJoinRequest(possibleAddress);
          numberOfJoinReq++;
        }
 else {
          logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
        }
      }
    }
    logger.log(Level.FINEST,""String_Node_Str"" + found);
    if (!found) {
      logger.log(Level.FINEST,""String_Node_Str"");
      setAsMaster();
    }
 else {
      while (!joined) {
        int maxTryCount=3;
        for (        Address possibleAddress : colPossibleAddresses) {
          if (address.hashCode() > possibleAddress.hashCode()) {
            maxTryCount=6;
            break;
          }
 else           if (address.hashCode() == possibleAddress.hashCode()) {
            maxTryCount=3 + ((int)(Math.random() * 10));
            break;
          }
        }
        int tryCount=0;
        while (tryCount++ < maxTryCount && (masterAddress == null)) {
          connectAndSendJoinRequest(colPossibleAddresses);
          Thread.sleep(1000L);
        }
        while (masterAddress != null && !joined) {
          Thread.sleep(1000L);
          clusterManager.sendJoinRequest(masterAddress);
        }
        if (masterAddress == null) {
          boolean masterCandidate=true;
          for (          Address address : colPossibleAddresses) {
            if (this.address.hashCode() > address.hashCode()) {
              masterCandidate=false;
            }
          }
          if (masterCandidate) {
            logger.log(Level.FINEST,""String_Node_Str"");
            setAsMaster();
          }
        }
      }
    }
    colPossibleAddresses.clear();
    failedConnections.clear();
  }
 catch (  Exception e) {
    e.printStackTrace();
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
}",0.7384567224917827
50305,"void setAsMaster(){
  logger.log(Level.FINE,""String_Node_Str"");
  masterAddress=address;
  logger.log(Level.FINEST,""String_Node_Str"");
  clusterManager.addMember(address,getLocalNodeType());
  clusterImpl.setMembers(baseVariables.lsMembers);
  unlock();
}","void setAsMaster(){
  logger.log(Level.FINEST,""String_Node_Str"");
  masterAddress=address;
  logger.log(Level.FINEST,""String_Node_Str"");
  clusterManager.addMember(address,getLocalNodeType());
  clusterImpl.setMembers(baseVariables.lsMembers);
  unlock();
}",0.99609375
50306,"private void connectAndSendJoinRequest(Address masterAddress) throws Exception {
  if (masterAddress == null || masterAddress.equals(address)) {
    throw new IllegalArgumentException();
  }
  Connection conn=connectionManager.getOrConnect(masterAddress);
  logger.log(Level.FINEST,""String_Node_Str"" + conn);
  if (conn != null) {
    clusterManager.sendJoinRequest(masterAddress);
  }
}","private void connectAndSendJoinRequest(Collection<Address> colPossibleAddresses){
  int numberOfJoinReq=0;
  colPossibleAddresses.removeAll(failedConnections);
  for (  Address possibleAddress : colPossibleAddresses) {
    final Connection conn=connectionManager.getOrConnect(possibleAddress);
    if (conn != null && numberOfJoinReq < 5) {
      logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
      clusterManager.sendJoinRequest(possibleAddress);
      numberOfJoinReq++;
    }
 else {
      logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress + ""String_Node_Str"");
    }
  }
}",0.38422649140546
50307,"/** 
 * Adds an index to this map based on the provided expression.
 * @param expression The expression for the index.
 * @param ordered   <tt>true</tt> if index should be ordered,<tt>false</tt> otherwise.
 */
void addIndex(Expression<?> expression,boolean ordered);","/** 
 * Adds an index to this map based on the provided expression.
 * @param expression The expression for the index.
 * @param ordered    <tt>true</tt> if index should be ordered,<tt>false</tt> otherwise.
 */
void addIndex(Expression<?> expression,boolean ordered);",0.99812382739212
50308,"public Object waitAndGetResult(){
  while (true) {
    try {
      Object obj=responses.poll(5,TimeUnit.SECONDS);
      if (obj != null) {
        return obj;
      }
      node.checkNodeState();
    }
 catch (    InterruptedException e) {
      if (node.factory.restarted) {
        throw new RuntimeException();
      }
 else {
        throw new RuntimeInterruptedException();
      }
    }
  }
}","public Object waitAndGetResult(){
  while (true) {
    try {
      Object obj=responses.poll(5,TimeUnit.SECONDS);
      if (obj != null) {
        return obj;
      }
      node.checkNodeState();
    }
 catch (    InterruptedException e) {
      handleInterruptedException();
    }
  }
}",0.7678832116788321
50309,"protected Object getRedoAwareResult(){
  Object result=waitAndGetResult();
  if (result == OBJECT_REDO) {
    request.redoCount++;
    if (request.redoCount > 19 && (request.redoCount % 10 == 0)) {
      final CountDownLatch l=new CountDownLatch(1);
      final Request reqCopy=request.hardCopy();
      reqCopy.redoCount=request.redoCount;
      final Address targetCopy=getTarget();
      enqueueAndReturn(new Processable(){
        public void process(){
          StringBuffer sb=new StringBuffer();
          Connection targetConnection=null;
          MemberImpl targetMember=null;
          Object key=toObject(reqCopy.key);
          Block block=(reqCopy.key == null) ? null : node.concurrentMapManager.getOrCreateBlock(reqCopy.key);
          if (targetCopy != null) {
            targetMember=getMember(targetCopy);
            targetConnection=node.connectionManager.getConnection(targetCopy);
            if (targetMember != null) {
              if (!lsMembers.contains(targetMember)) {
                logger.log(Level.SEVERE,targetMember + ""String_Node_Str"");
              }
            }
          }
          sb.append(""String_Node_Str"" + reqCopy.callId + ""String_Node_Str""+ reqCopy.operation+ ""String_Node_Str"");
          sb.append(""String_Node_Str"");
          sb.append(""String_Node_Str"" + thisAddress + ""String_Node_Str""+ targetCopy);
          sb.append(""String_Node_Str"");
          sb.append(""String_Node_Str"" + targetMember + ""String_Node_Str""+ targetConnection+ ""String_Node_Str""+ block);
          sb.append(""String_Node_Str"");
          sb.append(key + ""String_Node_Str"" + reqCopy.redoCount+ ""String_Node_Str""+ reqCopy.name);
          logger.log(Level.INFO,sb.toString());
          l.countDown();
        }
      }
);
      try {
        l.await();
      }
 catch (      InterruptedException e) {
      }
    }
    try {
      Thread.sleep(redoWaitMillis);
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
    beforeRedo();
    doOp();
    return getResult();
  }
  return result;
}","protected Object getRedoAwareResult(){
  Object result=waitAndGetResult();
  if (Thread.interrupted()) {
    handleInterruptedException();
  }
  if (result == OBJECT_REDO) {
    request.redoCount++;
    if (request.redoCount > 19 && (request.redoCount % 10 == 0)) {
      final CountDownLatch l=new CountDownLatch(1);
      final Request reqCopy=request.hardCopy();
      reqCopy.redoCount=request.redoCount;
      final Address targetCopy=getTarget();
      enqueueAndReturn(new Processable(){
        public void process(){
          StringBuffer sb=new StringBuffer();
          Connection targetConnection=null;
          MemberImpl targetMember=null;
          Object key=toObject(reqCopy.key);
          Block block=(reqCopy.key == null) ? null : node.concurrentMapManager.getOrCreateBlock(reqCopy.key);
          if (targetCopy != null) {
            targetMember=getMember(targetCopy);
            targetConnection=node.connectionManager.getConnection(targetCopy);
            if (targetMember != null) {
              if (!lsMembers.contains(targetMember)) {
                logger.log(Level.SEVERE,targetMember + ""String_Node_Str"");
              }
            }
          }
          sb.append(""String_Node_Str"" + reqCopy.callId + ""String_Node_Str""+ reqCopy.operation+ ""String_Node_Str"");
          sb.append(""String_Node_Str"");
          sb.append(""String_Node_Str"" + thisAddress + ""String_Node_Str""+ targetCopy);
          sb.append(""String_Node_Str"");
          sb.append(""String_Node_Str"" + targetMember + ""String_Node_Str""+ targetConnection+ ""String_Node_Str""+ block);
          sb.append(""String_Node_Str"");
          sb.append(key + ""String_Node_Str"" + reqCopy.redoCount+ ""String_Node_Str""+ reqCopy.name);
          logger.log(Level.INFO,sb.toString());
          l.countDown();
        }
      }
);
      try {
        l.await();
      }
 catch (      InterruptedException e) {
        handleInterruptedException();
      }
    }
    try {
      Thread.sleep(redoWaitMillis);
    }
 catch (    InterruptedException e) {
      handleInterruptedException();
    }
    beforeRedo();
    doOp();
    return getResult();
  }
  return result;
}",0.966975528629128
50310,"public void readData(DataInput in) throws IOException {
  address=new Address();
  address.readData(in);
  nodeType=NodeType.create(in.readInt());
}","public void readData(DataInput in) throws IOException {
  address=new Address();
  address.readData(in);
  nodeType=NodeType.create(in.readInt());
  this.lastRead=System.currentTimeMillis();
}",0.8705882352941177
50311,"@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(address.getHost());
  sb.append(""String_Node_Str"");
  sb.append(address.getPort());
  sb.append(""String_Node_Str"");
  if (localMember) {
    sb.append(""String_Node_Str"");
  }
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(address.getHost());
  sb.append(""String_Node_Str"");
  sb.append(address.getPort());
  sb.append(""String_Node_Str"");
  if (localMember) {
    sb.append(""String_Node_Str"");
  }
  if (nodeType == NodeType.SUPER_CLIENT) {
    sb.append(""String_Node_Str"");
  }
  return sb.toString();
}",0.8827785817655571
50312,"public Node(FactoryImpl factory,Config config){
  this.threadGroup=new ThreadGroup(factory.getName());
  this.factory=factory;
  this.config=config;
  this.groupProperties=new GroupProperties(config);
  this.superClient=config.isSuperClient();
  this.localNodeType=(superClient) ? NodeType.SUPER_CLIENT : NodeType.MEMBER;
  String version=""String_Node_Str"";
  String build=""String_Node_Str"";
  try {
    InputStream inRuntimeProperties=Node.class.getClassLoader().getResourceAsStream(""String_Node_Str"");
    if (inRuntimeProperties != null) {
      Properties runtimeProperties=new Properties();
      runtimeProperties.load(inRuntimeProperties);
      version=runtimeProperties.getProperty(""String_Node_Str"");
      build=runtimeProperties.getProperty(""String_Node_Str"");
    }
  }
 catch (  Exception ignored) {
  }
  int tmpBuildNumber=0;
  try {
    tmpBuildNumber=Integer.getInteger(""String_Node_Str"",-1);
    if (tmpBuildNumber == -1) {
      tmpBuildNumber=Integer.parseInt(build);
    }
  }
 catch (  Exception ignored) {
  }
  buildNumber=tmpBuildNumber;
  ServerSocketChannel serverSocketChannel;
  Address localAddress=null;
  try {
    final String preferIPv4Stack=System.getProperty(""String_Node_Str"");
    final String preferIPv6Address=System.getProperty(""String_Node_Str"");
    if (preferIPv6Address == null && preferIPv4Stack == null) {
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
    serverSocketChannel=ServerSocketChannel.open();
    AddressPicker addressPicker=new AddressPicker(this,serverSocketChannel);
    localAddress=addressPicker.pickAddress();
    localAddress.setThisAddress(true);
  }
 catch (  Throwable e) {
    throw new RuntimeException(e);
  }
  address=localAddress;
  localMember=new MemberImpl(address,true,localNodeType);
  packetPool=new NoneStrictObjectPool<Packet>(2000){
    @Override public void onRelease(    Packet packet){
      if (packet.released) {
        throw new RuntimeException(""String_Node_Str"");
      }
      packet.released=true;
    }
    @Override public void onObtain(    Packet packet){
      packet.reset();
      packet.released=false;
    }
    public Packet createNew(){
      return new Packet();
    }
  }
;
  clusterImpl=new ClusterImpl(this,localMember);
  baseVariables=new NodeBaseVariables(address,localMember);
  this.loggingService=new LoggingServiceImpl(config.getGroupConfig().getName(),localMember);
  this.logger=loggingService.getLogger(Node.class.getName());
  clusterService=new ClusterService(this);
  clusterService.start();
  inSelector=new InSelector(this,serverSocketChannel);
  outSelector=new OutSelector(this);
  connectionManager=new ConnectionManager(this);
  clientService=new ClientService(this);
  clusterManager=new ClusterManager(this);
  executorManager=new ExecutorManager(this);
  concurrentMapManager=new ConcurrentMapManager(this);
  blockingQueueManager=new BlockingQueueManager(this);
  listenerManager=new ListenerManager(this);
  topicManager=new TopicManager(this);
  clusterService.enqueueAndReturn(new Processable(){
    public void process(){
      clusterManager.addMember(getThisAddress(),NodeType.MEMBER);
    }
  }
);
  textCommandService=new TextCommandServiceImpl(this);
  ILogger systemLogger=getLogger(""String_Node_Str"");
  systemLogger.log(Level.INFO,""String_Node_Str"" + version + ""String_Node_Str""+ build+ ""String_Node_Str""+ address);
  systemLogger.log(Level.INFO,""String_Node_Str"");
  Join join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(join.getMulticastConfig().getMulticastPort()));
      multicastSocket.setTimeToLive(32);
      multicastSocket.setInterface(address.getInetAddress());
      multicastSocket.setReceiveBufferSize(1024);
      multicastSocket.setSendBufferSize(1024);
      multicastSocket.joinGroup(InetAddress.getByName(join.getMulticastConfig().getMulticastGroup()));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
  this.multicastService=mcService;
}","public Node(FactoryImpl factory,Config config){
  this.threadGroup=new ThreadGroup(factory.getName());
  this.factory=factory;
  this.config=config;
  this.groupProperties=new GroupProperties(config);
  this.superClient=config.isSuperClient();
  this.localNodeType=(superClient) ? NodeType.SUPER_CLIENT : NodeType.MEMBER;
  String version=""String_Node_Str"";
  String build=""String_Node_Str"";
  try {
    InputStream inRuntimeProperties=Node.class.getClassLoader().getResourceAsStream(""String_Node_Str"");
    if (inRuntimeProperties != null) {
      Properties runtimeProperties=new Properties();
      runtimeProperties.load(inRuntimeProperties);
      version=runtimeProperties.getProperty(""String_Node_Str"");
      build=runtimeProperties.getProperty(""String_Node_Str"");
    }
  }
 catch (  Exception ignored) {
  }
  int tmpBuildNumber=0;
  try {
    tmpBuildNumber=Integer.getInteger(""String_Node_Str"",-1);
    if (tmpBuildNumber == -1) {
      tmpBuildNumber=Integer.parseInt(build);
    }
  }
 catch (  Exception ignored) {
  }
  buildNumber=tmpBuildNumber;
  ServerSocketChannel serverSocketChannel;
  Address localAddress=null;
  try {
    final String preferIPv4Stack=System.getProperty(""String_Node_Str"");
    final String preferIPv6Address=System.getProperty(""String_Node_Str"");
    if (preferIPv6Address == null && preferIPv4Stack == null) {
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
    serverSocketChannel=ServerSocketChannel.open();
    AddressPicker addressPicker=new AddressPicker(this,serverSocketChannel);
    localAddress=addressPicker.pickAddress();
    localAddress.setThisAddress(true);
  }
 catch (  Throwable e) {
    throw new RuntimeException(e);
  }
  address=localAddress;
  localMember=new MemberImpl(address,true,localNodeType);
  packetPool=new NoneStrictObjectPool<Packet>(2000){
    @Override public void onRelease(    Packet packet){
      if (packet.released) {
        throw new RuntimeException(""String_Node_Str"");
      }
      packet.released=true;
    }
    @Override public void onObtain(    Packet packet){
      packet.reset();
      packet.released=false;
    }
    public Packet createNew(){
      return new Packet();
    }
  }
;
  clusterImpl=new ClusterImpl(this,localMember);
  baseVariables=new NodeBaseVariables(address,localMember);
  this.loggingService=new LoggingServiceImpl(config.getGroupConfig().getName(),localMember);
  this.logger=loggingService.getLogger(Node.class.getName());
  clusterService=new ClusterService(this);
  clusterService.start();
  inSelector=new InSelector(this,serverSocketChannel);
  outSelector=new OutSelector(this);
  connectionManager=new ConnectionManager(this);
  clientService=new ClientService(this);
  clusterManager=new ClusterManager(this);
  executorManager=new ExecutorManager(this);
  concurrentMapManager=new ConcurrentMapManager(this);
  blockingQueueManager=new BlockingQueueManager(this);
  listenerManager=new ListenerManager(this);
  topicManager=new TopicManager(this);
  clusterService.enqueueAndReturn(new Processable(){
    public void process(){
      clusterManager.addMember(getThisAddress(),localNodeType);
    }
  }
);
  textCommandService=new TextCommandServiceImpl(this);
  ILogger systemLogger=getLogger(""String_Node_Str"");
  systemLogger.log(Level.INFO,""String_Node_Str"" + version + ""String_Node_Str""+ build+ ""String_Node_Str""+ address);
  systemLogger.log(Level.INFO,""String_Node_Str"");
  Join join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(join.getMulticastConfig().getMulticastPort()));
      multicastSocket.setTimeToLive(32);
      multicastSocket.setInterface(address.getInetAddress());
      multicastSocket.setReceiveBufferSize(1024);
      multicastSocket.setSendBufferSize(1024);
      multicastSocket.joinGroup(InetAddress.getByName(join.getMulticastConfig().getMulticastGroup()));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
  this.multicastService=mcService;
}",0.9986372927549398
50313,"public void process(){
  clusterManager.addMember(getThisAddress(),NodeType.MEMBER);
}","public void process(){
  clusterManager.addMember(getThisAddress(),localNodeType);
}",0.9294117647058824
50314,"@Test(timeout=40000) public void testSuperClientPartitionOwnership() throws Exception {
  Config configSuperClient=new Config();
  configSuperClient.setSuperClient(true);
  HazelcastInstance hNormal=Hazelcast.newHazelcastInstance(new Config());
  final HazelcastInstance hSuper=Hazelcast.newHazelcastInstance(configSuperClient);
  Map map=hSuper.getMap(""String_Node_Str"");
  assertNull(map.put(""String_Node_Str"",""String_Node_Str""));
  Set<Partition> partitions2=hSuper.getPartitionService().getPartitions();
  for (  Partition partition : partitions2) {
    assertEquals(partition.getOwner(),hNormal.getCluster().getLocalMember());
  }
  hNormal.shutdown();
  Thread.sleep(3000);
  Set<Partition> partitions=hSuper.getPartitionService().getPartitions();
  for (  Partition partition : partitions) {
    assertNull(partition.getOwner());
  }
  hNormal=Hazelcast.newHazelcastInstance(new Config());
  partitions=hSuper.getPartitionService().getPartitions();
  for (  Partition partition : partitions) {
    assertEquals(hNormal.getCluster().getLocalMember(),partition.getOwner());
  }
  assertNull(map.put(""String_Node_Str"",""String_Node_Str""));
  hSuper.shutdown();
  partitions=hNormal.getPartitionService().getPartitions();
  for (  Partition partition : partitions) {
    assertEquals(hNormal.getCluster().getLocalMember(),partition.getOwner());
  }
  assertEquals(""String_Node_Str"",hNormal.getMap(""String_Node_Str"").get(""String_Node_Str""));
}","@Test(timeout=40000) public void testSuperClientPartitionOwnership() throws Exception {
  Config configSuperClient=new Config();
  configSuperClient.setSuperClient(true);
  HazelcastInstance hNormal=Hazelcast.newHazelcastInstance(new Config());
  final HazelcastInstance hSuper=Hazelcast.newHazelcastInstance(configSuperClient);
  IMap mapSuper=hSuper.getMap(""String_Node_Str"");
  IMap mapNormal=hNormal.getMap(""String_Node_Str"");
  for (int i=0; i < 1000; i++) {
    mapNormal.put(""String_Node_Str"" + i,""String_Node_Str"" + i);
  }
  for (int i=1000; i < 2000; i++) {
    mapSuper.put(""String_Node_Str"" + i,""String_Node_Str"" + i);
  }
  Set<Partition> partitions2=hSuper.getPartitionService().getPartitions();
  for (  Partition partition : partitions2) {
    assertEquals(partition.getOwner(),hNormal.getCluster().getLocalMember());
  }
  assertEquals(2000,mapNormal.size());
  assertEquals(2000,mapSuper.size());
  assertEquals(0,mapSuper.getLocalMapStats().getOwnedEntryCount());
  assertEquals(0,mapSuper.getLocalMapStats().getBackupEntryCount());
  assertEquals(2000,mapNormal.getLocalMapStats().getOwnedEntryCount());
  assertEquals(0,mapNormal.getLocalMapStats().getBackupEntryCount());
  hNormal.shutdown();
  Thread.sleep(3000);
  Set<Partition> partitions=hSuper.getPartitionService().getPartitions();
  for (  Partition partition : partitions) {
    assertNull(partition.getOwner());
  }
  hNormal=Hazelcast.newHazelcastInstance(new Config());
  partitions=hSuper.getPartitionService().getPartitions();
  for (  Partition partition : partitions) {
    assertEquals(hNormal.getCluster().getLocalMember(),partition.getOwner());
  }
  assertNull(mapSuper.put(""String_Node_Str"",""String_Node_Str""));
  hSuper.shutdown();
  partitions=hNormal.getPartitionService().getPartitions();
  for (  Partition partition : partitions) {
    assertEquals(hNormal.getCluster().getLocalMember(),partition.getOwner());
  }
  assertEquals(""String_Node_Str"",hNormal.getMap(""String_Node_Str"").get(""String_Node_Str""));
}",0.8246884960880904
50315,"@Override public void init(HazelcastInstance hazelcastInstance,Properties properties,String mapName){
  this.hazelcastInstance=hazelcastInstance;
  this.properties=properties;
  this.mapName=mapName;
  initCount.incrementAndGet();
}","public void init(HazelcastInstance hazelcastInstance,Properties properties,String mapName){
  this.hazelcastInstance=hazelcastInstance;
  this.properties=properties;
  this.mapName=mapName;
  initCount.incrementAndGet();
}",0.9779735682819384
50316,"@Test public void testOneMemberWriteThrough() throws Exception {
  TestMapStore testMapStore=new TestMapStore(1,1,1);
  Config config=newConfig(testMapStore,0);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  Employee employee=new Employee(""String_Node_Str"",25,true,100.00);
  testMapStore.insert(""String_Node_Str"",employee);
  IMap map=h1.getMap(""String_Node_Str"");
  map.addIndex(""String_Node_Str"",false);
  assertEquals(0,map.size());
  assertEquals(employee,map.get(""String_Node_Str""));
  assertEquals(employee,testMapStore.getStore().get(""String_Node_Str""));
  assertEquals(1,map.size());
  Collection values=map.values(new SqlPredicate(""String_Node_Str""));
  assertEquals(1,values.size());
  assertEquals(employee,values.iterator().next());
}","@Test public void testOneMemberWriteThrough() throws Exception {
  TestMapStore testMapStore=new TestMapStore(1,1,1);
  Config config=newConfig(testMapStore,0);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  Employee employee=new Employee(""String_Node_Str"",25,true,100.00);
  testMapStore.insert(""String_Node_Str"",employee);
  IMap map=h1.getMap(""String_Node_Str"");
  map.addIndex(""String_Node_Str"",false);
  assertEquals(0,map.size());
  assertEquals(employee,map.get(""String_Node_Str""));
  assertEquals(employee,testMapStore.getStore().get(""String_Node_Str""));
  assertEquals(1,map.size());
  Collection values=map.values(new SqlPredicate(""String_Node_Str""));
  assertEquals(1,values.size());
  assertEquals(employee,values.iterator().next());
  map.remove(""String_Node_Str"");
  map.put(""String_Node_Str"",employee,1,TimeUnit.SECONDS);
  Thread.sleep(2000);
  assertEquals(employee,testMapStore.getStore().get(""String_Node_Str""));
  assertEquals(employee,map.get(""String_Node_Str""));
}",0.8648954211418881
50317,"public ClusterManager(final Node node){
  super(node);
  WAIT_MILLIS_BEFORE_JOIN=node.groupProperties.WAIT_SECONDS_BEFORE_JOIN.getInteger() * 1000L;
  MAX_NO_HEARTBEAT_MILLIS=node.groupProperties.MAX_NO_HEARTBEAT_SECONDS.getInteger() * 1000L;
  node.clusterService.registerPeriodicRunnable(new SplitBrainHandler(node));
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      heartBeater();
    }
  }
);
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      checkScheduledActions();
    }
  }
);
  node.connectionManager.addConnectionListener(this);
  registerPacketProcessor(ClusterOperation.RESPONSE,new PacketProcessor(){
    public void process(    Packet packet){
      handleResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.HEARTBEAT,new PacketProcessor(){
    public void process(    Packet packet){
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS_AND_RESPOND,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      sendResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_BOOLEAN,new PacketProcessor(){
    public void process(    Packet packet){
      Boolean result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable<Boolean>)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=Boolean.FALSE;
      }
      if (result == Boolean.TRUE) {
        sendResponse(packet);
      }
 else {
        sendResponseFailure(packet);
      }
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_OBJECT,new PacketProcessor(){
    public void process(    Packet packet){
      Object result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=null;
      }
      if (result != null) {
        Data value;
        if (result instanceof Data) {
          value=(Data)result;
        }
 else {
          value=toData(result);
        }
        packet.setValue(value);
      }
      sendResponse(packet);
    }
  }
);
}","public ClusterManager(final Node node){
  super(node);
  WAIT_MILLIS_BEFORE_JOIN=node.groupProperties.WAIT_SECONDS_BEFORE_JOIN.getInteger() * 1000L;
  MAX_NO_HEARTBEAT_MILLIS=node.groupProperties.MAX_NO_HEARTBEAT_SECONDS.getInteger() * 1000L;
  node.clusterService.registerPeriodicRunnable(new SplitBrainHandler(node));
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      heartBeater();
    }
  }
);
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      checkScheduledActions();
    }
  }
);
  node.connectionManager.addConnectionListener(this);
  registerPacketProcessor(ClusterOperation.RESPONSE,new PacketProcessor(){
    public void process(    Packet packet){
      handleResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.HEARTBEAT,new PacketProcessor(){
    public void process(    Packet packet){
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.JOIN_CHECK,new PacketProcessor(){
    public void process(    Packet packet){
      Connection conn=packet.conn;
      Request request=Request.copy(packet);
      JoinInfo joinInfo=(JoinInfo)toObject(request.value);
      request.clearForResponse();
      if (joinInfo != null && node.joined() && node.isActive() && node.validateJoinRequest(joinInfo)) {
        request.response=toData(node.createJoinInfo());
      }
      returnResponse(request,conn);
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS_AND_RESPOND,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      sendResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_BOOLEAN,new PacketProcessor(){
    public void process(    Packet packet){
      Boolean result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable<Boolean>)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=Boolean.FALSE;
      }
      if (result == Boolean.TRUE) {
        sendResponse(packet);
      }
 else {
        sendResponseFailure(packet);
      }
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_OBJECT,new PacketProcessor(){
    public void process(    Packet packet){
      Object result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=null;
      }
      if (result != null) {
        Data value;
        if (result instanceof Data) {
          value=(Data)result;
        }
 else {
          value=toData(result);
        }
        packet.setValue(value);
      }
      sendResponse(packet);
    }
  }
);
}",0.9226130653266332
50318,"public void readFromPacket(DatagramPacket packet){
  ByteArrayInputStream bis=new ByteArrayInputStream(packet.getData(),0,packet.getLength());
  DataInputStream dis=new DataInputStream(bis);
  try {
    setRequest(dis.readBoolean());
    address=new Address();
    address.readData(dis);
    groupName=dis.readUTF();
    groupPassword=dis.readUTF();
    packetVersion=dis.readByte();
    buildNumber=dis.readInt();
    memberCount=dis.readInt();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void readFromPacket(DatagramPacket packet){
  ByteArrayInputStream bis=new ByteArrayInputStream(packet.getData(),0,packet.getLength());
  DataInputStream dis=new DataInputStream(bis);
  try {
    readData(dis);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.6793893129770993
50319,"public void writeToPacket(DatagramPacket packet){
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(bos);
  try {
    dos.writeBoolean(isRequest());
    address.writeData(dos);
    dos.writeUTF(groupName);
    dos.writeUTF(groupPassword);
    dos.writeByte(Packet.PACKET_VERSION);
    dos.writeInt(buildNumber);
    dos.writeInt(memberCount);
    packet.setData(bos.toByteArray());
    packet.setLength(bos.size());
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void writeToPacket(DatagramPacket packet){
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(bos);
  try {
    writeData(dos);
    packet.setData(bos.toByteArray());
    packet.setLength(bos.size());
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.7296340023612751
50320,"public GroupProperties(Config config){
  REDO_WAIT_MILLIS=new GroupProperty(config,PROP_REDO_WAIT_MILLIS,""String_Node_Str"");
  SOCKET_BIND_ANY=new GroupProperty(config,PROP_SOCKET_BIND_ANY,""String_Node_Str"");
  SHUTDOWNHOOK_ENABLED=new GroupProperty(config,PROP_SHUTDOWNHOOK_ENABLED,""String_Node_Str"");
  WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_NO_HEARTBEAT_SECONDS=new GroupProperty(config,PROP_MAX_NO_HEARTBEAT_SECONDS,""String_Node_Str"");
  INITIAL_WAIT_SECONDS=new GroupProperty(config,PROP_INITIAL_WAIT_SECONDS,""String_Node_Str"");
  RESTART_ON_MAX_IDLE=new GroupProperty(config,PROP_RESTART_ON_MAX_IDLE,""String_Node_Str"");
  CONCURRENT_MAP_PARTITION_COUNT=new GroupProperty(config,PROP_CONCURRENT_MAP_PARTITION_COUNT,""String_Node_Str"");
  BLOCKING_QUEUE_BLOCK_SIZE=new GroupProperty(config,PROP_BLOCKING_QUEUE_BLOCK_SIZE,""String_Node_Str"");
  REMOVE_DELAY_SECONDS=new GroupProperty(config,PROP_REMOVE_DELAY_SECONDS,""String_Node_Str"");
  CLEANUP_DELAY_SECONDS=new GroupProperty(config,PROP_CLEANUP_DELAY_SECONDS,""String_Node_Str"");
  EXECUTOR_QUERY_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_QUERY_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_EVENT_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_EVENT_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_MIGRATION_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_MIGRATION_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_CLIENT_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_CLIENT_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_STORE_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_STORE_THREAD_COUNT,""String_Node_Str"");
  LOG_STATE=new GroupProperty(config,PROP_LOG_STATE,""String_Node_Str"");
}","public GroupProperties(Config config){
  MERGE_FIRST_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_FIRST_RUN_DELAY_SECONDS,""String_Node_Str"");
  MERGE_NEXT_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_NEXT_RUN_DELAY_SECONDS,""String_Node_Str"");
  REDO_WAIT_MILLIS=new GroupProperty(config,PROP_REDO_WAIT_MILLIS,""String_Node_Str"");
  SOCKET_BIND_ANY=new GroupProperty(config,PROP_SOCKET_BIND_ANY,""String_Node_Str"");
  SHUTDOWNHOOK_ENABLED=new GroupProperty(config,PROP_SHUTDOWNHOOK_ENABLED,""String_Node_Str"");
  WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_NO_HEARTBEAT_SECONDS=new GroupProperty(config,PROP_MAX_NO_HEARTBEAT_SECONDS,""String_Node_Str"");
  INITIAL_WAIT_SECONDS=new GroupProperty(config,PROP_INITIAL_WAIT_SECONDS,""String_Node_Str"");
  RESTART_ON_MAX_IDLE=new GroupProperty(config,PROP_RESTART_ON_MAX_IDLE,""String_Node_Str"");
  CONCURRENT_MAP_PARTITION_COUNT=new GroupProperty(config,PROP_CONCURRENT_MAP_PARTITION_COUNT,""String_Node_Str"");
  BLOCKING_QUEUE_BLOCK_SIZE=new GroupProperty(config,PROP_BLOCKING_QUEUE_BLOCK_SIZE,""String_Node_Str"");
  REMOVE_DELAY_SECONDS=new GroupProperty(config,PROP_REMOVE_DELAY_SECONDS,""String_Node_Str"");
  CLEANUP_DELAY_SECONDS=new GroupProperty(config,PROP_CLEANUP_DELAY_SECONDS,""String_Node_Str"");
  EXECUTOR_QUERY_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_QUERY_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_EVENT_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_EVENT_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_MIGRATION_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_MIGRATION_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_CLIENT_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_CLIENT_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_STORE_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_STORE_THREAD_COUNT,""String_Node_Str"");
  LOG_STATE=new GroupProperty(config,PROP_LOG_STATE,""String_Node_Str"");
}",0.9395095367847413
50321,"public boolean resume(){
synchronized (lifecycleLock) {
    if (paused.get()) {
      fireLifecycleEvent(new LifecycleEvent(LifecycleEvent.LifecycleState.RESTARTING));
    }
 else {
      return false;
    }
    paused.set(false);
    fireLifecycleEvent(new LifecycleEvent(LifecycleEvent.LifecycleState.RESTARTED));
    return true;
  }
}","public boolean resume(){
synchronized (lifecycleLock) {
    if (paused.get()) {
      fireLifecycleEvent(new LifecycleEvent(LifecycleEvent.LifecycleState.RESUMING));
    }
 else {
      return false;
    }
    paused.set(false);
    fireLifecycleEvent(new LifecycleEvent(LifecycleEvent.LifecycleState.RESUMED));
    return true;
  }
}",0.9821428571428572
50322,"private void joinWithMulticast(){
  int tryCount=0;
  while (!joined) {
    try {
      logger.log(Level.FINEST,""String_Node_Str"" + masterAddress);
      if (masterAddress == null) {
        masterAddress=findMaster();
        if (masterAddress == null || masterAddress.equals(address)) {
          TcpIpConfig tcpIpConfig=config.getNetworkConfig().getJoin().getTcpIpConfig();
          if (tcpIpConfig != null && tcpIpConfig.isEnabled()) {
            masterAddress=null;
            logger.log(Level.FINEST,""String_Node_Str"");
            joinWithTCP();
          }
 else {
            setAsMaster();
          }
          return;
        }
      }
      if (tryCount++ > 20) {
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + tryCount);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + address);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + masterAddress);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + connectionManager.getConnection(masterAddress));
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        logger.log(Level.WARNING,sb.toString());
        tryCount=0;
      }
      if (!masterAddress.equals(address)) {
        connectAndSendJoinRequest(masterAddress);
      }
 else {
        masterAddress=null;
        tryCount=0;
      }
      Thread.sleep(500);
    }
 catch (    final Exception e) {
      logger.log(Level.FINEST,""String_Node_Str"",e);
    }
  }
}","private void joinWithMulticast(){
  int tryCount=0;
  while (!joined) {
    try {
      logger.log(Level.FINEST,""String_Node_Str"" + masterAddress);
      if (masterAddress == null) {
        masterAddress=findMaster();
        if (masterAddress == null || masterAddress.equals(address)) {
          TcpIpConfig tcpIpConfig=config.getNetworkConfig().getJoin().getTcpIpConfig();
          if (tcpIpConfig != null && tcpIpConfig.isEnabled()) {
            masterAddress=null;
            logger.log(Level.FINEST,""String_Node_Str"");
            joinWithTCP();
          }
 else {
            setAsMaster();
          }
          return;
        }
      }
      if (tryCount++ > 20) {
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + tryCount);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + address);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + masterAddress);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + connectionManager.getConnection(masterAddress));
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        logger.log(Level.WARNING,sb.toString());
        tryCount=0;
      }
      if (!masterAddress.equals(address)) {
        connectAndSendJoinRequest(masterAddress);
      }
 else {
        masterAddress=null;
        tryCount=0;
      }
      Thread.sleep(500L);
    }
 catch (    final Exception e) {
      logger.log(Level.FINEST,""String_Node_Str"",e);
    }
  }
}",0.9996948428440648
50323,"private void joinViaPossibleMembers(){
  try {
    failedConnections.clear();
    final Collection<Address> colPossibleAddresses=getPossibleMembers();
    colPossibleAddresses.remove(address);
    for (    final Address possibleAddress : colPossibleAddresses) {
      logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
      connectionManager.getOrConnect(possibleAddress);
    }
    boolean found=false;
    int numberOfSeconds=0;
    final int connectionTimeoutSeconds=config.getNetworkConfig().getJoin().getTcpIpConfig().getConnectionTimeoutSeconds();
    while (!found && numberOfSeconds < connectionTimeoutSeconds) {
      colPossibleAddresses.removeAll(failedConnections);
      if (colPossibleAddresses.size() == 0) {
        break;
      }
      Thread.sleep(1000);
      numberOfSeconds++;
      int numberOfJoinReq=0;
      logger.log(Level.FINE,""String_Node_Str"");
      for (      Address possibleAddress : colPossibleAddresses) {
        logger.log(Level.FINEST,""String_Node_Str"" + numberOfJoinReq + ""String_Node_Str""+ possibleAddress);
        final Connection conn=connectionManager.getOrConnect(possibleAddress);
        if (conn != null && numberOfJoinReq < 5) {
          found=true;
          logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
          clusterManager.sendJoinRequest(possibleAddress);
          numberOfJoinReq++;
        }
 else {
          logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
        }
      }
    }
    logger.log(Level.FINEST,""String_Node_Str"" + found);
    if (!found) {
      logger.log(Level.FINEST,""String_Node_Str"");
      setAsMaster();
    }
 else {
      while (!joined) {
        int numberOfJoinReq=0;
        colPossibleAddresses.removeAll(failedConnections);
        for (        Address possibleAddress : colPossibleAddresses) {
          final Connection conn=connectionManager.getOrConnect(possibleAddress);
          if (conn != null && numberOfJoinReq < 5) {
            logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
            clusterManager.sendJoinRequest(possibleAddress);
            numberOfJoinReq++;
          }
 else {
            logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress + ""String_Node_Str"");
          }
        }
        Thread.sleep(2000);
        if (masterAddress == null) {
          boolean masterCandidate=true;
          for (          Address address : colPossibleAddresses) {
            if (this.address.hashCode() > address.hashCode()) {
              masterCandidate=false;
            }
          }
          if (masterCandidate) {
            logger.log(Level.FINEST,""String_Node_Str"");
            setAsMaster();
          }
        }
      }
    }
    colPossibleAddresses.clear();
    failedConnections.clear();
  }
 catch (  Exception e) {
    e.printStackTrace();
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
}","private void joinViaPossibleMembers(){
  try {
    failedConnections.clear();
    final Collection<Address> colPossibleAddresses=getPossibleMembers();
    colPossibleAddresses.remove(address);
    for (    final Address possibleAddress : colPossibleAddresses) {
      logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
      connectionManager.getOrConnect(possibleAddress);
    }
    boolean found=false;
    int numberOfSeconds=0;
    final int connectionTimeoutSeconds=config.getNetworkConfig().getJoin().getTcpIpConfig().getConnectionTimeoutSeconds();
    while (!found && numberOfSeconds < connectionTimeoutSeconds) {
      colPossibleAddresses.removeAll(failedConnections);
      if (colPossibleAddresses.size() == 0) {
        break;
      }
      Thread.sleep(1000L);
      numberOfSeconds++;
      int numberOfJoinReq=0;
      logger.log(Level.FINE,""String_Node_Str"");
      for (      Address possibleAddress : colPossibleAddresses) {
        logger.log(Level.FINEST,""String_Node_Str"" + numberOfJoinReq + ""String_Node_Str""+ possibleAddress);
        final Connection conn=connectionManager.getOrConnect(possibleAddress);
        if (conn != null && numberOfJoinReq < 5) {
          found=true;
          logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
          clusterManager.sendJoinRequest(possibleAddress);
          numberOfJoinReq++;
        }
 else {
          logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
        }
      }
    }
    logger.log(Level.FINEST,""String_Node_Str"" + found);
    if (!found) {
      logger.log(Level.FINEST,""String_Node_Str"");
      setAsMaster();
    }
 else {
      while (!joined) {
        int numberOfJoinReq=0;
        colPossibleAddresses.removeAll(failedConnections);
        for (        Address possibleAddress : colPossibleAddresses) {
          final Connection conn=connectionManager.getOrConnect(possibleAddress);
          if (conn != null && numberOfJoinReq < 5) {
            logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress);
            clusterManager.sendJoinRequest(possibleAddress);
            numberOfJoinReq++;
          }
 else {
            logger.log(Level.FINEST,""String_Node_Str"" + possibleAddress + ""String_Node_Str"");
          }
        }
        long sleepTime=3000L;
        for (        Address possibleAddress : colPossibleAddresses) {
          if (address.hashCode() > possibleAddress.hashCode()) {
            sleepTime=6000L;
            break;
          }
 else           if (address.hashCode() == possibleAddress.hashCode()) {
            sleepTime=3000L + ((int)(Math.random() * 10) * 1000L);
            break;
          }
        }
        Thread.sleep(sleepTime);
        if (masterAddress == null) {
          boolean masterCandidate=true;
          for (          Address address : colPossibleAddresses) {
            if (this.address.hashCode() > address.hashCode()) {
              masterCandidate=false;
            }
          }
          if (masterCandidate) {
            logger.log(Level.FINEST,""String_Node_Str"");
            setAsMaster();
          }
        }
      }
    }
    colPossibleAddresses.clear();
    failedConnections.clear();
  }
 catch (  Exception e) {
    e.printStackTrace();
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
}",0.9292407108239096
50324,"private void joinViaRequiredMember(){
  try {
    final Address requiredAddress=getAddressFor(config.getNetworkConfig().getJoin().getTcpIpConfig().getRequiredMember());
    logger.log(Level.FINEST,""String_Node_Str"" + requiredAddress);
    if (requiredAddress == null) {
      throw new RuntimeException(""String_Node_Str"" + config.getNetworkConfig().getJoin().getTcpIpConfig().getRequiredMember());
    }
    if (requiredAddress.equals(address)) {
      setAsMaster();
      return;
    }
    connectionManager.getOrConnect(requiredAddress);
    Connection conn=null;
    while (conn == null) {
      conn=connectionManager.getOrConnect(requiredAddress);
      Thread.sleep(1000);
    }
    while (!joined) {
      final Connection connection=connectionManager.getOrConnect(requiredAddress);
      if (connection == null) {
        joinViaRequiredMember();
      }
      logger.log(Level.FINEST,""String_Node_Str"" + requiredAddress);
      clusterManager.sendJoinRequest(requiredAddress);
      Thread.sleep(2000);
    }
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
}","private void joinViaRequiredMember(){
  try {
    final Address requiredAddress=getAddressFor(config.getNetworkConfig().getJoin().getTcpIpConfig().getRequiredMember());
    logger.log(Level.FINEST,""String_Node_Str"" + requiredAddress);
    if (requiredAddress == null) {
      throw new RuntimeException(""String_Node_Str"" + config.getNetworkConfig().getJoin().getTcpIpConfig().getRequiredMember());
    }
    if (requiredAddress.equals(address)) {
      setAsMaster();
      return;
    }
    connectionManager.getOrConnect(requiredAddress);
    Connection conn=null;
    while (conn == null) {
      conn=connectionManager.getOrConnect(requiredAddress);
      Thread.sleep(2000L);
    }
    while (!joined) {
      final Connection connection=connectionManager.getOrConnect(requiredAddress);
      if (connection == null) {
        joinViaRequiredMember();
      }
      logger.log(Level.FINEST,""String_Node_Str"" + requiredAddress);
      clusterManager.sendJoinRequest(requiredAddress);
      Thread.sleep(3000L);
    }
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
}",0.9972350230414746
50325,"JoinInfo createJoinInfo(){
  return new JoinInfo(true,address,config.getGroupConfig().getName(),config.getGroupConfig().getPassword(),getLocalNodeType(),Packet.PACKET_VERSION,buildNumber,clusterImpl.getMembers().size());
}","public JoinInfo createJoinInfo(){
  return new JoinInfo(true,address,config.getGroupConfig().getName(),config.getGroupConfig().getPassword(),getLocalNodeType(),Packet.PACKET_VERSION,buildNumber,clusterImpl.getMembers().size());
}",0.984478935698448
50326,"public void start(String[] args) throws Exception {
  if (lineReader == null) {
    lineReader=new DefaultLineReader();
  }
  while (true) {
    print(""String_Node_Str"" + namespace + ""String_Node_Str"");
    try {
      final String command=lineReader.readLine();
      handleCommand(command);
    }
 catch (    Throwable e) {
      e.printStackTrace();
    }
  }
}","public void start(String[] args) throws Exception {
  if (lineReader == null) {
    lineReader=new DefaultLineReader();
  }
  running=true;
  while (running) {
    print(""String_Node_Str"" + namespace + ""String_Node_Str"");
    try {
      final String command=lineReader.readLine();
      handleCommand(command);
    }
 catch (    Throwable e) {
      e.printStackTrace();
    }
  }
}",0.963855421686747
50327,"public void connectionRemoved(Connection connection){
  if (connection.equals(this.conn)) {
    for (    Integer threadId : locks.keySet()) {
      ThreadContext.get().setCallContext(getCallContext(threadId));
      Map<IMap,List<Data>> mapOfLocks=locks.get(threadId);
      for (      IMap map : mapOfLocks.keySet()) {
        List<Data> list=mapOfLocks.get(map);
        for (        Data key : list) {
          map.unlock(key);
        }
      }
    }
    for (    IMap map : listeningMaps) {
      map.removeEntryListener(this);
    }
    for (    Map.Entry e : listeningKeysOfMaps) {
      IMap m=(IMap)e.getValue();
      m.removeEntryListener(this,e.getKey());
    }
    for (    ITopic topic : messageListeners.keySet()) {
      topic.removeMessageListener(messageListeners.get(topic));
    }
  }
}","public void connectionRemoved(Connection connection){
  if (connection.equals(this.conn)) {
    for (    Integer threadId : locks.keySet()) {
      ThreadContext.get().setCallContext(getCallContext(threadId));
      Map<IMap,List<Data>> mapOfLocks=locks.get(threadId);
      for (      IMap map : mapOfLocks.keySet()) {
        List<Data> list=mapOfLocks.get(map);
        for (        Data key : list) {
          map.unlock(key);
        }
      }
    }
    for (    IMap map : listeningMaps) {
      map.removeEntryListener(this);
    }
    for (    Map.Entry e : listeningKeysOfMaps) {
      IMap m=(IMap)e.getKey();
      m.removeEntryListener(this,e.getValue());
    }
    for (    ITopic topic : messageListeners.keySet()) {
      topic.removeMessageListener(messageListeners.get(topic));
    }
  }
}",0.8042131350681536
50328,"/** 
 * if a client is listening for both key and the entire map, then we should make sure that we don't send two separate events. One is enough. so check if we already sent one. <p/> called by executor service threads
 * @param event
 */
private void processEvent(EntryEvent event){
  final Object key=event.getKey();
  Map<Object,EntryEvent> eventProcessedLog=getEventProcessedLog(event.getName());
  if (eventProcessedLog.get(key) != null && eventProcessedLog.get(key) == event) {
    return;
  }
  eventProcessedLog.put(key,event);
  Packet packet=createEntryEventPacket(event);
  sendPacket(packet);
}","/** 
 * if a client is listening for both key and the entire map, then we should make sure that we don't send two separate events. One is enough. so check if we already sent one. <p/> called by executor service threads
 * @param event
 */
private void processEvent(EntryEvent event){
  Packet packet=createEntryEventPacket(event);
  sendPacket(packet);
}",0.6229166666666667
50329,"public void addThisAsListener(IMap map,Data key,boolean includeValue){
  if (key == null) {
    map.addEntryListener(this,includeValue);
    listeningMaps.add(map);
  }
 else {
    Object keyAsObject=toObject(key);
    map.addEntryListener(this,keyAsObject,includeValue);
    listeningKeysOfMaps.add(new Entry(keyAsObject,map));
  }
}","public synchronized void addThisAsListener(IMap map,Data key,boolean includeValue){
  if (!listeningMaps.contains(map) && !(listeningKeyExist(map,key))) {
    map.addEntryListener(this,includeValue);
  }
  if (key == null) {
    listeningMaps.add(map);
  }
 else {
    listeningKeysOfMaps.add(new Entry(map,key));
  }
}",0.557427258805513
50330,"public void addIndex(String attribute,boolean ordered){
  proxyHelper.doOp(ClusterOperation.ADD_INDEX,attribute,ordered);
}","public void addIndex(Expression<?> expression,boolean ordered){
  proxyHelper.doOp(ClusterOperation.ADD_INDEX,expression,ordered);
}",0.8313725490196079
50331,"/** 
 * Adds an index to this map for the specified entries so that queries can run faster. <p/> Let's say your map values are Employee objects. <pre> public class Employee implements Serializable { private boolean active = false; private int age; private String name = null; // other fields. <p/> // getters setter <p/> } </pre> <p/> If you are querying your values mostly based on age and active then you should consider indexing these fields. <pre> IMap imap = Hazelcast.getMap(""employees""); imap.addIndex(""age"", true);        // ordered, since we have ranged queries for this field imap.addIndex(""active"", false);    // not ordered, because boolean field cannot have range </pre> <p/> Index attribute should either have a getter method or be public. You should also make sure to add the indexes before adding entries to this map.
 * @param attribute attribute of value
 * @param ordered   <tt>true</tt> if index should be ordered,<tt>false</tt> otherwise.
 */
void addIndex(String attribute,boolean ordered);","/** 
 * Adds an index to this map based on the provided expression.
 * @param expression The expression for the index.
 * @param ordered   <tt>true</tt> if index should be ordered,<tt>false</tt> otherwise.
 */
void addIndex(Expression<?> expression,boolean ordered);",0.0782472613458529
50332,"public void addIndex(final String attribute,final boolean ordered){
  final CountDownLatch latch=new CountDownLatch(1);
  concurrentMapManager.enqueueAndReturn(new Processable(){
    public void process(){
      AddMapIndex addMapIndexProcess=new AddMapIndex(name,Predicates.get(attribute),ordered);
      concurrentMapManager.sendProcessableToAll(addMapIndexProcess,true);
      latch.countDown();
    }
  }
);
  try {
    latch.await();
  }
 catch (  InterruptedException ignored) {
  }
}","public void addIndex(final Expression expression,final boolean ordered){
  final CountDownLatch latch=new CountDownLatch(1);
  concurrentMapManager.enqueueAndReturn(new Processable(){
    public void process(){
      AddMapIndex addMapIndexProcess=new AddMapIndex(name,expression,ordered);
      concurrentMapManager.sendProcessableToAll(addMapIndexProcess,true);
      latch.countDown();
    }
  }
);
  try {
    latch.await();
  }
 catch (  InterruptedException ignored) {
  }
}",0.5298969072164949
50333,"public void process(){
  AddMapIndex addMapIndexProcess=new AddMapIndex(name,Predicates.get(attribute),ordered);
  concurrentMapManager.sendProcessableToAll(addMapIndexProcess,true);
  latch.countDown();
}","public void process(){
  AddMapIndex addMapIndexProcess=new AddMapIndex(name,expression,ordered);
  concurrentMapManager.sendProcessableToAll(addMapIndexProcess,true);
  latch.countDown();
}",0.9265822784810128
50334,"public void addIndex(String attribute,boolean ordered){
  distributedMap.addIndex(attribute,ordered);
}","public void addIndex(Expression<?> expression,boolean ordered){
  distributedMap.addIndex(expression,ordered);
}",0.8
50335,"public Address pickAddress() throws Exception {
  String currentAddress=null;
  try {
    final Config config=node.getConfig();
    final String localAddress=System.getProperty(""String_Node_Str"");
    if (localAddress != null) {
      currentAddress=InetAddress.getByName(localAddress.trim()).getHostAddress();
    }
    if (currentAddress == null) {
      final Set<String> interfaces=new HashSet<String>();
      if (config.getNetworkConfig().getJoin().getTcpIpConfig().isEnabled()) {
        Collection<Address> possibleAddresses=node.getPossibleMembers();
        for (        Address possibleAddress : possibleAddresses) {
          interfaces.add(possibleAddress.getHost());
        }
      }
      if (config.getNetworkConfig().getInterfaces().isEnabled()) {
        interfaces.addAll(config.getNetworkConfig().getInterfaces().getInterfaces());
      }
      if (interfaces.contains(""String_Node_Str"") || interfaces.contains(""String_Node_Str"")) {
        currentAddress=""String_Node_Str"";
      }
 else {
        final Enumeration<NetworkInterface> enums=NetworkInterface.getNetworkInterfaces();
        interfaces:         while (enums.hasMoreElements()) {
          final NetworkInterface ni=enums.nextElement();
          final Enumeration<InetAddress> e=ni.getInetAddresses();
          while (e.hasMoreElements()) {
            final InetAddress inetAddress=e.nextElement();
            if (inetAddress instanceof Inet4Address) {
              final String address=inetAddress.getHostAddress();
              if (matchAddress(address,interfaces)) {
                currentAddress=address;
                break interfaces;
              }
 else {
                if (!inetAddress.isLoopbackAddress()) {
                  currentAddress=address;
                  break interfaces;
                }
              }
            }
          }
        }
        if (config.getNetworkConfig().getInterfaces().isEnabled() && currentAddress == null) {
          String msg=""String_Node_Str"";
          msg+=""String_Node_Str"";
          logger.log(Level.SEVERE,msg);
          throw new RuntimeException(msg);
        }
      }
    }
    if (currentAddress == null) {
      currentAddress=""String_Node_Str"";
    }
    final InetAddress inetAddress=InetAddress.getByName(currentAddress);
    final boolean reuseAddress=config.isReuseAddress();
    ServerSocket serverSocket=serverSocketChannel.socket();
    serverSocket.setReuseAddress(reuseAddress);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        boolean bindAny=node.getGroupProperties().SOCKET_BIND_ANY.getBoolean();
        if (bindAny) {
          isa=new InetSocketAddress(port);
        }
 else {
          isa=new InetSocketAddress(inetAddress,port);
        }
        serverSocket.bind(isa,100);
        break;
      }
 catch (      final Exception e) {
        if (config.isPortAutoIncrement()) {
          serverSocket=serverSocketChannel.socket();
          serverSocket.setReuseAddress(reuseAddress);
          port++;
        }
 else {
          String msg=""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str"";
          logger.log(Level.SEVERE,msg);
          throw e;
        }
      }
    }
    serverSocketChannel.configureBlocking(false);
    return new Address(currentAddress,port);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
}","public Address pickAddress() throws Exception {
  String currentAddress=null;
  try {
    final Config config=node.getConfig();
    final String localAddress=System.getProperty(""String_Node_Str"");
    if (localAddress != null) {
      currentAddress=InetAddress.getByName(localAddress.trim()).getHostAddress();
    }
    if (currentAddress == null) {
      final Set<String> interfaces=new HashSet<String>();
      if (config.getNetworkConfig().getJoin().getTcpIpConfig().isEnabled()) {
        Collection<Address> possibleAddresses=node.getPossibleMembers();
        for (        Address possibleAddress : possibleAddresses) {
          interfaces.add(possibleAddress.getHost());
        }
      }
      if (config.getNetworkConfig().getInterfaces().isEnabled()) {
        interfaces.addAll(config.getNetworkConfig().getInterfaces().getInterfaces());
      }
      if (interfaces.contains(""String_Node_Str"") || interfaces.contains(""String_Node_Str"")) {
        currentAddress=""String_Node_Str"";
      }
 else {
        if (interfaces.size() > 0) {
          final Enumeration<NetworkInterface> enums=NetworkInterface.getNetworkInterfaces();
          interfaces:           while (enums.hasMoreElements()) {
            final NetworkInterface ni=enums.nextElement();
            final Enumeration<InetAddress> e=ni.getInetAddresses();
            while (e.hasMoreElements()) {
              final InetAddress inetAddress=e.nextElement();
              if (inetAddress instanceof Inet4Address) {
                final String address=inetAddress.getHostAddress();
                if (matchAddress(address,interfaces)) {
                  currentAddress=address;
                  break interfaces;
                }
              }
            }
          }
        }
        if (currentAddress == null) {
          if (config.getNetworkConfig().getInterfaces().isEnabled()) {
            String msg=""String_Node_Str"";
            msg+=""String_Node_Str"";
            logger.log(Level.SEVERE,msg);
            throw new RuntimeException(msg);
          }
 else {
            final Enumeration<NetworkInterface> enums=NetworkInterface.getNetworkInterfaces();
            interfaces:             while (enums.hasMoreElements()) {
              final NetworkInterface ni=enums.nextElement();
              final Enumeration<InetAddress> e=ni.getInetAddresses();
              while (e.hasMoreElements()) {
                final InetAddress inetAddress=e.nextElement();
                if (inetAddress instanceof Inet4Address) {
                  if (!inetAddress.isLoopbackAddress()) {
                    currentAddress=inetAddress.getHostAddress();
                    break interfaces;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (currentAddress == null) {
      currentAddress=""String_Node_Str"";
    }
    final InetAddress inetAddress=InetAddress.getByName(currentAddress);
    final boolean reuseAddress=config.isReuseAddress();
    ServerSocket serverSocket=serverSocketChannel.socket();
    serverSocket.setReuseAddress(reuseAddress);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        boolean bindAny=node.getGroupProperties().SOCKET_BIND_ANY.getBoolean();
        if (bindAny) {
          isa=new InetSocketAddress(port);
        }
 else {
          isa=new InetSocketAddress(inetAddress,port);
        }
        serverSocket.bind(isa,100);
        break;
      }
 catch (      final Exception e) {
        if (config.isPortAutoIncrement()) {
          serverSocket=serverSocketChannel.socket();
          serverSocket.setReuseAddress(reuseAddress);
          port++;
        }
 else {
          String msg=""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str"";
          logger.log(Level.SEVERE,msg);
          throw e;
        }
      }
    }
    serverSocketChannel.configureBlocking(false);
    return new Address(currentAddress,port);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
}",0.8509383378016085
50336,"void doPublish(String name,Object msg){
  Data dataMsg=null;
  try {
    dataMsg=ThreadContext.get().toData(msg);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  enqueueAndReturn(new TopicPublishProcess(name,dataMsg));
}","void doPublish(String name,Object msg){
  Data dataMsg=null;
  try {
    dataMsg=toData(msg);
  }
 catch (  Exception e) {
    throw new IllegalArgumentException(e);
  }
  enqueueAndReturn(new TopicPublishProcess(name,dataMsg));
}",0.5627705627705628
50337,"protected boolean shouldExecuteAsync(Request request){
  CMap cmap=getOrCreateMap(request.name);
  return (cmap.writeDelayMillis == 0);
}","protected boolean shouldExecuteAsync(Request request){
  CMap cmap=getOrCreateMap(request.name);
  if (request.operation == CONCURRENT_MAP_GET) {
    return cmap.loader != null;
  }
 else   return cmap.writeDelayMillis == 0 && cmap.store != null;
}",0.6753246753246753
50338,"protected void schedule(Request request){
  final CMap cmap=getOrCreateMap(request.name);
  final Record record=ensureRecord(request);
  request.scheduled=true;
  ScheduledAction scheduledAction=new ScheduledAction(request){
    @Override public boolean consume(){
      handle(request);
      return true;
    }
    @Override public void onExpire(){
      onNoTimeToSchedule(request);
    }
    @Override public void onMigrate(){
      request.response=OBJECT_REDO;
      returnResponse(request);
    }
  }
;
  record.addScheduledAction(scheduledAction);
  node.clusterManager.registerScheduledAction(scheduledAction);
}","protected void schedule(Request request){
  final Record record=ensureRecord(request);
  request.scheduled=true;
  ScheduledAction scheduledAction=new ScheduledAction(request){
    @Override public boolean consume(){
      handle(request);
      return true;
    }
    @Override public void onExpire(){
      onNoTimeToSchedule(request);
    }
    @Override public void onMigrate(){
      request.response=OBJECT_REDO;
      returnResponse(request);
    }
  }
;
  record.addScheduledAction(scheduledAction);
  node.clusterManager.registerScheduledAction(scheduledAction);
}",0.9597989949748744
50339,"public void setMembers(List<MemberImpl> lsMembers){
  Set<Member> setNew=new LinkedHashSet<Member>(lsMembers.size());
  ArrayList<Runnable> notifications=new ArrayList<Runnable>();
  for (  MemberImpl member : lsMembers) {
    final MemberImpl dummy=new MemberImpl(member.getAddress(),member.localMember(),member.getNodeType());
    Member clusterMember=clusterMembers.get(dummy);
    if (clusterMember == null) {
      clusterMember=dummy;
      if (listeners.size() > 0) {
        notifications.add(new Runnable(){
          public void run(){
            MembershipEvent membershipEvent=new MembershipEvent(ClusterImpl.this,dummy,MembershipEvent.MEMBER_ADDED);
            for (            MembershipListener listener : listeners) {
              listener.memberAdded(membershipEvent);
            }
          }
        }
);
      }
    }
    if (clusterMember.localMember()) {
      localMember.set(clusterMember);
    }
    setNew.add(clusterMember);
  }
  if (listeners.size() > 0) {
    Set<Member> it=clusterMembers.keySet();
    for (    final Member member : it) {
      if (!setNew.contains(member)) {
        notifications.add(new Runnable(){
          public void run(){
            MembershipEvent membershipEvent=new MembershipEvent(ClusterImpl.this,member,MembershipEvent.MEMBER_REMOVED);
            for (            MembershipListener listener : listeners) {
              listener.memberRemoved(membershipEvent);
            }
          }
        }
);
      }
    }
  }
  clusterMembers.clear();
  for (  Member member : setNew) {
    clusterMembers.put(member,member);
  }
  members.set(setNew);
  distances.clear();
  for (  Runnable notification : notifications) {
    node.executorManager.getEventExecutorService().execute(notification);
  }
}","public void setMembers(List<MemberImpl> lsMembers){
  Set<Member> setNew=new LinkedHashSet<Member>(lsMembers.size());
  ArrayList<Runnable> notifications=new ArrayList<Runnable>();
  for (  MemberImpl member : lsMembers) {
    if (member != null) {
      final MemberImpl dummy=new MemberImpl(member.getAddress(),member.localMember(),member.getNodeType());
      Member clusterMember=clusterMembers.get(dummy);
      if (clusterMember == null) {
        clusterMember=dummy;
        if (listeners.size() > 0) {
          notifications.add(new Runnable(){
            public void run(){
              MembershipEvent membershipEvent=new MembershipEvent(ClusterImpl.this,dummy,MembershipEvent.MEMBER_ADDED);
              for (              MembershipListener listener : listeners) {
                listener.memberAdded(membershipEvent);
              }
            }
          }
);
        }
      }
      if (clusterMember.localMember()) {
        localMember.set(clusterMember);
      }
      setNew.add(clusterMember);
    }
  }
  if (listeners.size() > 0) {
    Set<Member> it=clusterMembers.keySet();
    for (    final Member member : it) {
      if (!setNew.contains(member)) {
        notifications.add(new Runnable(){
          public void run(){
            MembershipEvent membershipEvent=new MembershipEvent(ClusterImpl.this,member,MembershipEvent.MEMBER_REMOVED);
            for (            MembershipListener listener : listeners) {
              listener.memberRemoved(membershipEvent);
            }
          }
        }
);
      }
    }
  }
  clusterMembers.clear();
  for (  Member member : setNew) {
    clusterMembers.put(member,member);
  }
  members.set(setNew);
  distances.clear();
  for (  Runnable notification : notifications) {
    node.executorManager.getEventExecutorService().execute(notification);
  }
}",0.9772475027746949
50340,"public Address pickAddress() throws Exception {
  String currentAddress=null;
  try {
    final Config config=node.getConfig();
    final String localAddress=System.getProperty(""String_Node_Str"");
    if (localAddress != null) {
      currentAddress=InetAddress.getByName(localAddress.trim()).getHostAddress();
    }
    if (currentAddress == null) {
      final Enumeration<NetworkInterface> enums=NetworkInterface.getNetworkInterfaces();
      interfaces:       while (enums.hasMoreElements()) {
        final NetworkInterface ni=enums.nextElement();
        final Enumeration<InetAddress> e=ni.getInetAddresses();
        while (e.hasMoreElements()) {
          final InetAddress inetAddress=e.nextElement();
          if (inetAddress instanceof Inet4Address) {
            final String address=inetAddress.getHostAddress();
            final Collection<String> interfaces=config.getNetworkConfig().getInterfaces().getInterfaces();
            if (config.getNetworkConfig().getInterfaces().isEnabled()) {
              if (matchAddress(address,interfaces)) {
                currentAddress=address;
                break interfaces;
              }
            }
 else {
              if (!inetAddress.isLoopbackAddress()) {
                currentAddress=address;
                break interfaces;
              }
            }
          }
        }
      }
      if (config.getNetworkConfig().getInterfaces().isEnabled() && currentAddress == null) {
        String msg=""String_Node_Str"";
        msg+=""String_Node_Str"";
        logger.log(Level.SEVERE,msg);
        throw new RuntimeException(msg);
      }
    }
    if (currentAddress == null) {
      currentAddress=""String_Node_Str"";
    }
    final InetAddress inetAddress=InetAddress.getByName(currentAddress);
    final boolean reuseAddress=config.isReuseAddress();
    ServerSocket serverSocket=serverSocketChannel.socket();
    serverSocket.setReuseAddress(reuseAddress);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        boolean bindAny=node.getGroupProperties().SOCKET_BIND_ANY.getBoolean();
        if (bindAny) {
          isa=new InetSocketAddress(port);
        }
 else {
          isa=new InetSocketAddress(inetAddress,port);
        }
        serverSocket.bind(isa,100);
        break;
      }
 catch (      final Exception e) {
        if (config.isPortAutoIncrement()) {
          serverSocket=serverSocketChannel.socket();
          serverSocket.setReuseAddress(reuseAddress);
          port++;
        }
 else {
          String msg=""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str"";
          logger.log(Level.SEVERE,msg);
          throw e;
        }
      }
    }
    serverSocketChannel.configureBlocking(false);
    return new Address(currentAddress,port);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
}","public Address pickAddress() throws Exception {
  String currentAddress=null;
  try {
    final Config config=node.getConfig();
    final String localAddress=System.getProperty(""String_Node_Str"");
    if (localAddress != null) {
      currentAddress=InetAddress.getByName(localAddress.trim()).getHostAddress();
    }
    if (currentAddress == null) {
      final Set<String> interfaces=new HashSet<String>();
      if (config.getNetworkConfig().getJoin().getTcpIpConfig().isEnabled()) {
        Collection<Address> possibleAddresses=node.getPossibleMembers();
        for (        Address possibleAddress : possibleAddresses) {
          interfaces.add(possibleAddress.getHost());
        }
      }
      if (config.getNetworkConfig().getInterfaces().isEnabled()) {
        interfaces.addAll(config.getNetworkConfig().getInterfaces().getInterfaces());
      }
      if (interfaces.contains(""String_Node_Str"")) {
        currentAddress=""String_Node_Str"";
      }
 else {
        final Enumeration<NetworkInterface> enums=NetworkInterface.getNetworkInterfaces();
        interfaces:         while (enums.hasMoreElements()) {
          final NetworkInterface ni=enums.nextElement();
          final Enumeration<InetAddress> e=ni.getInetAddresses();
          while (e.hasMoreElements()) {
            final InetAddress inetAddress=e.nextElement();
            if (inetAddress instanceof Inet4Address) {
              final String address=inetAddress.getHostAddress();
              if (matchAddress(address,interfaces)) {
                currentAddress=address;
                break interfaces;
              }
 else {
                if (!inetAddress.isLoopbackAddress()) {
                  currentAddress=address;
                  break interfaces;
                }
              }
            }
          }
        }
        if (config.getNetworkConfig().getInterfaces().isEnabled() && currentAddress == null) {
          String msg=""String_Node_Str"";
          msg+=""String_Node_Str"";
          logger.log(Level.SEVERE,msg);
          throw new RuntimeException(msg);
        }
      }
    }
    if (currentAddress == null) {
      currentAddress=""String_Node_Str"";
    }
    final InetAddress inetAddress=InetAddress.getByName(currentAddress);
    final boolean reuseAddress=config.isReuseAddress();
    ServerSocket serverSocket=serverSocketChannel.socket();
    serverSocket.setReuseAddress(reuseAddress);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        boolean bindAny=node.getGroupProperties().SOCKET_BIND_ANY.getBoolean();
        if (bindAny) {
          isa=new InetSocketAddress(port);
        }
 else {
          isa=new InetSocketAddress(inetAddress,port);
        }
        serverSocket.bind(isa,100);
        break;
      }
 catch (      final Exception e) {
        if (config.isPortAutoIncrement()) {
          serverSocket=serverSocketChannel.socket();
          serverSocket.setReuseAddress(reuseAddress);
          port++;
        }
 else {
          String msg=""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str"";
          logger.log(Level.SEVERE,msg);
          throw e;
        }
      }
    }
    serverSocketChannel.configureBlocking(false);
    return new Address(currentAddress,port);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
}",0.7537205952952473
50341,"private Collection<Address> getPossibleMembers(){
  Join join=config.getNetworkConfig().getJoin();
  final List<String> lsJoinMembers=join.getTcpIpConfig().getMembers();
  final Set<Address> setPossibleAddresses=new HashSet<Address>();
  for (  final String lsJoinMember : lsJoinMembers) {
    String host=lsJoinMember;
    int port=config.getPort();
    final int indexColon=host.indexOf(':');
    if (indexColon >= 0) {
      port=Integer.parseInt(host.substring(indexColon + 1));
      host=host.substring(0,indexColon);
    }
    final boolean ip=isIP(host);
    try {
      if (ip) {
        for (        final Address addrs : getPossibleIpAddresses(host,port,indexColon >= 0)) {
          if (!addrs.equals(getThisAddress())) {
            if (setPossibleAddresses.add(addrs)) {
              logger.log(Level.FINEST,""String_Node_Str"" + addrs);
            }
          }
        }
      }
 else {
        final InetAddress[] allAddresses=InetAddress.getAllByName(host);
        for (        final InetAddress inetAddress : allAddresses) {
          boolean shouldCheck=true;
          Address addrs;
          Interfaces interfaces=config.getNetworkConfig().getInterfaces();
          if (interfaces.isEnabled()) {
            addrs=new Address(inetAddress.getAddress(),port);
            shouldCheck=AddressPicker.matchAddress(addrs.getHost(),interfaces.getInterfaces());
          }
          if (indexColon < 0) {
            if (shouldCheck) {
              for (int i=-2; i < 3; i++) {
                final Address addressProper=new Address(inetAddress.getAddress(),port + i);
                if (!addressProper.equals(getThisAddress())) {
                  if (setPossibleAddresses.add(addressProper)) {
                    logger.log(Level.FINEST,""String_Node_Str"" + addressProper);
                  }
                }
              }
            }
          }
 else {
            final Address addressProper=new Address(inetAddress.getAddress(),port);
            if (!addressProper.equals(getThisAddress())) {
              if (setPossibleAddresses.add(addressProper)) {
                logger.log(Level.FINEST,""String_Node_Str"" + addressProper);
              }
            }
          }
        }
      }
    }
 catch (    final Exception e) {
      e.printStackTrace();
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
  }
  setPossibleAddresses.addAll(config.getNetworkConfig().getJoin().getTcpIpConfig().getAddresses());
  return setPossibleAddresses;
}","Collection<Address> getPossibleMembers(){
  Join join=config.getNetworkConfig().getJoin();
  final List<String> lsJoinMembers=join.getTcpIpConfig().getMembers();
  final Set<Address> setPossibleAddresses=new HashSet<Address>();
  for (  final String lsJoinMember : lsJoinMembers) {
    String host=lsJoinMember;
    int port=config.getPort();
    final int indexColon=host.indexOf(':');
    if (indexColon >= 0) {
      port=Integer.parseInt(host.substring(indexColon + 1));
      host=host.substring(0,indexColon);
    }
    final boolean ip=isIP(host);
    try {
      if (ip) {
        for (        final Address addrs : getPossibleIpAddresses(host,port,indexColon >= 0)) {
          if (!addrs.equals(getThisAddress())) {
            if (setPossibleAddresses.add(addrs)) {
              logger.log(Level.FINEST,""String_Node_Str"" + addrs);
            }
          }
        }
      }
 else {
        final InetAddress[] allAddresses=InetAddress.getAllByName(host);
        for (        final InetAddress inetAddress : allAddresses) {
          boolean shouldCheck=true;
          Address addrs;
          Interfaces interfaces=config.getNetworkConfig().getInterfaces();
          if (interfaces.isEnabled()) {
            addrs=new Address(inetAddress.getAddress(),port);
            shouldCheck=AddressPicker.matchAddress(addrs.getHost(),interfaces.getInterfaces());
          }
          if (indexColon < 0) {
            if (shouldCheck) {
              for (int i=-2; i < 3; i++) {
                final Address addressProper=new Address(inetAddress.getAddress(),port + i);
                if (!addressProper.equals(getThisAddress())) {
                  if (setPossibleAddresses.add(addressProper)) {
                    logger.log(Level.FINEST,""String_Node_Str"" + addressProper);
                  }
                }
              }
            }
          }
 else {
            final Address addressProper=new Address(inetAddress.getAddress(),port);
            if (!addressProper.equals(getThisAddress())) {
              if (setPossibleAddresses.add(addressProper)) {
                logger.log(Level.FINEST,""String_Node_Str"" + addressProper);
              }
            }
          }
        }
      }
    }
 catch (    final Exception e) {
      e.printStackTrace();
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
  }
  setPossibleAddresses.addAll(config.getNetworkConfig().getJoin().getTcpIpConfig().getAddresses());
  return setPossibleAddresses;
}",0.9983857949959644
50342,"public void entryAdded(EntryEvent<Integer,DataSerializableUser> entryEvent){
  DataSerializableUser u=entryEvent.getValue();
  assertEquals(user.getName(),u.getName());
  assertEquals(user.getFamilyName(),u.getFamilyName());
  assertEquals(user.getAge(),u.getAge());
  assertEquals(user.getAddress().getAddress(),u.getAddress().getAddress());
  cdl.countDown();
}","public void entryAdded(EntryEvent entryEvent){
}",0.2335766423357664
50343,"public void connectionRemoved(Connection connection){
  if (connection.equals(this.conn)) {
    for (    Integer threadId : locks.keySet()) {
      ThreadContext.get().setCallContext(getCallContext(threadId));
      Map<IMap,List<Data>> mapOfLocks=locks.get(threadId);
      for (      IMap map : mapOfLocks.keySet()) {
        List<Data> list=mapOfLocks.get(map);
        for (        Data key : list) {
          map.unlock(key);
        }
      }
    }
  }
}","public void connectionRemoved(Connection connection){
  if (connection.equals(this.conn)) {
    for (    Integer threadId : locks.keySet()) {
      ThreadContext.get().setCallContext(getCallContext(threadId));
      Map<IMap,List<Data>> mapOfLocks=locks.get(threadId);
      for (      IMap map : mapOfLocks.keySet()) {
        List<Data> list=mapOfLocks.get(map);
        for (        Data key : list) {
          map.unlock(key);
        }
      }
    }
    for (    IMap map : listeningMaps) {
      map.removeEntryListener(this);
    }
    for (    Map.Entry e : listeningKeysOfMaps) {
      IMap m=(IMap)e.getValue();
      m.removeEntryListener(this,e.getKey());
    }
    for (    ITopic topic : messageListeners.keySet()) {
      topic.removeMessageListener(messageListeners.get(topic));
    }
  }
}",0.7271293375394322
50344,"public void addThisAsListener(IMap map,Data key,boolean includeValue){
  if (key == null) {
    map.addEntryListener(this,includeValue);
  }
 else {
    map.addEntryListener(this,toObject(key),includeValue);
  }
}","public void addThisAsListener(IMap map,Data key,boolean includeValue){
  if (key == null) {
    map.addEntryListener(this,includeValue);
    listeningMaps.add(map);
  }
 else {
    Object keyAsObject=toObject(key);
    map.addEntryListener(this,keyAsObject,includeValue);
    listeningKeysOfMaps.add(new Entry(keyAsObject,map));
  }
}",0.7312614259597806
50345,"public void innerSetException(Throwable throwable){
  innerDone();
  exception=throwable;
  setException(throwable);
}","public void innerSetException(Throwable throwable,boolean done){
  if (done) {
    innerDone();
  }
  exception=throwable;
  setException(throwable);
}",0.8773234200743495
50346,"public Object doGetResult(long timeoutMillis) throws InterruptedException {
  Object result=(timeoutMillis == -1) ? getResult() : getResult(timeoutMillis,TimeUnit.MILLISECONDS);
  if (result == null) {
    result=new TimeoutException();
  }
  if (result == OBJECT_NULL) {
    result=null;
  }
 else {
    if (result instanceof Data) {
      final Data data=(Data)result;
      if (data.size() == 0) {
        result=null;
      }
 else {
        result=toObjectWithConfigClassLoader(data);
      }
    }
  }
  afterGettingResult(request);
  return result;
}","public Object doGetResult(long timeoutMillis) throws InterruptedException {
  Object result=(timeoutMillis == -1) ? getResult() : getResult(timeoutMillis,TimeUnit.MILLISECONDS);
  if (result == null) {
    result=OBJECT_NO_RESPONSE;
  }
  if (result == OBJECT_NULL) {
    result=null;
  }
 else {
    if (result instanceof Data) {
      final Data data=(Data)result;
      if (data.size() == 0) {
        result=null;
      }
 else {
        result=toObjectWithConfigClassLoader(data);
      }
    }
  }
  afterGettingResult(request);
  return result;
}",0.9675675675675676
50347,"public void get(long time,TimeUnit unit) throws InterruptedException {
  try {
    Object result=doGetResult((time == -1) ? -1 : unit.toMillis(time));
    if (result instanceof CancellationException) {
      innerFutureTask.innerSetCancelled();
    }
 else     if (result == OBJECT_MEMBER_LEFT) {
      innerFutureTask.innerSetMemberLeft(member);
    }
 else     if (result instanceof Throwable) {
      innerFutureTask.innerSetException((Throwable)result);
    }
 else {
      innerFutureTask.innerSet(result);
    }
  }
 catch (  Exception e) {
    innerFutureTask.innerSetException(e);
  }
 finally {
    if (singleTask) {
      innerFutureTask.innerDone();
    }
  }
}","public void get(long time,TimeUnit unit) throws InterruptedException {
  Object result=null;
  boolean done=true;
  try {
    result=doGetResult((time == -1) ? -1 : unit.toMillis(time));
    if (result == OBJECT_NO_RESPONSE) {
      done=false;
      innerFutureTask.innerSetException(new TimeoutException(),false);
    }
 else     if (result instanceof CancellationException) {
      innerFutureTask.innerSetCancelled();
    }
 else     if (result == OBJECT_MEMBER_LEFT) {
      innerFutureTask.innerSetMemberLeft(member);
    }
 else     if (result instanceof Throwable) {
      innerFutureTask.innerSetException((Throwable)result,true);
    }
 else {
      innerFutureTask.innerSet(result);
    }
  }
 catch (  Exception e) {
    innerFutureTask.innerSetException(e,done);
  }
 finally {
    if (singleTask && done) {
      innerFutureTask.innerDone();
    }
  }
}",0.7225471085120208
50348,"void doGet(long timeoutMillis){
  long remainingMillis=timeoutMillis;
  try {
    for (    MemberCall memberCall : lsMemberCalls) {
      long now=System.currentTimeMillis();
      if (timeoutMillis == -1) {
        memberCall.get();
      }
 else {
        if (remainingMillis < 0) {
          innerFutureTask.innerSetException(new TimeoutException());
          return;
        }
        memberCall.get(remainingMillis,TimeUnit.MILLISECONDS);
      }
      remainingMillis-=(System.currentTimeMillis() - now);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    innerFutureTask.innerSetException(e);
  }
 finally {
    innerFutureTask.innerDone();
  }
}","void doGet(long timeoutMillis){
  boolean done=true;
  long remainingMillis=timeoutMillis;
  try {
    for (    MemberCall memberCall : lsMemberCalls) {
      long now=System.currentTimeMillis();
      if (timeoutMillis == -1) {
        memberCall.get();
      }
 else {
        if (remainingMillis < 0) {
          done=false;
          innerFutureTask.innerSetException(new TimeoutException(),done);
          return;
        }
        memberCall.get(remainingMillis,TimeUnit.MILLISECONDS);
      }
      remainingMillis-=(System.currentTimeMillis() - now);
    }
  }
 catch (  Exception e) {
    innerFutureTask.innerSetException(e,done);
  }
 finally {
    if (done) {
      innerFutureTask.innerDone();
    }
  }
}",0.922077922077922
50349,void innerSetException(Throwable throwable);,"void innerSetException(Throwable throwable,boolean done);",0.8712871287128713
50350,"@Test public void testCancellationAwareTask(){
  CancellationAwareTask task=new CancellationAwareTask();
  ExecutorService executor=Hazelcast.getExecutorService();
  Future future=executor.submit(task);
  assertTrue(future.cancel(true));
  assertTrue(future.isCancelled());
  try {
    future.get();
    fail(""String_Node_Str"");
  }
 catch (  CancellationException e) {
  }
catch (  Exception e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
}","@Test public void testCancellationAwareTask(){
  CancellationAwareTask task=new CancellationAwareTask(10000);
  ExecutorService executor=Hazelcast.getExecutorService();
  Future future=executor.submit(task);
  try {
    future.get(2,TimeUnit.SECONDS);
  }
 catch (  TimeoutException expected) {
  }
catch (  Exception e) {
    fail(""String_Node_Str"");
  }
  assertFalse(future.isDone());
  assertTrue(future.cancel(true));
  assertTrue(future.isCancelled());
  try {
    future.get();
    fail(""String_Node_Str"");
  }
 catch (  CancellationException e) {
  }
catch (  Exception e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
}",0.5761772853185596
50351,"boolean evict(Request req){
  Record record=getRecord(req.key);
  if (record != null && record.isEvictable()) {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_EVICTED,record.getKey(),record.getValue(),record.getMapListeners(),req.caller);
    record.incrementVersion();
    markAsRemoved(record);
    req.clearForResponse();
    req.version=record.getVersion();
    req.longValue=record.getCopyCount();
    lastEvictionTime=System.currentTimeMillis();
    return true;
  }
  return false;
}","boolean evict(Request req){
  Record record=getRecord(req.key);
  if (record != null) {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_EVICTED,record.getKey(),record.getValue(),record.getMapListeners(),req.caller);
    record.incrementVersion();
    markAsRemoved(record);
    req.clearForResponse();
    req.version=record.getVersion();
    req.longValue=record.getCopyCount();
    lastEvictionTime=System.currentTimeMillis();
    return true;
  }
  return false;
}",0.9776951672862454
50352,"public void run(){
  if (keysToDeleteSize > 0) {
    if (keysToDeleteSize == 1) {
      Data key=keysToDelete.iterator().next();
      store.delete(toObject(key));
    }
 else {
      Collection realKeys=new HashSet();
      for (      Data key : keysToDelete) {
        realKeys.add(toObject(key));
      }
      store.deleteAll(realKeys);
    }
  }
  if (entriesToStoreSize > 0) {
    Object keyFirst=null;
    Object valueFirst=null;
    Set<Map.Entry<Data,Data>> entries=entriesToStore.entrySet();
    Map realEntries=new HashMap();
    for (    Map.Entry<Data,Data> entry : entries) {
      Object key=toObject(entry.getKey());
      Object value=toObject(entry.getValue());
      realEntries.put(key,value);
      if (keyFirst == null) {
        keyFirst=key;
        valueFirst=value;
      }
    }
    if (entriesToStoreSize == 1) {
      store.store(keyFirst,valueFirst);
    }
 else {
      store.storeAll(realEntries);
    }
  }
}","public void run(){
  try {
    Set<Object> keysToDelete=new HashSet<Object>();
    Map<Object,Object> updates=new HashMap<Object,Object>();
    for (    Record dirtyRecord : dirtyRecords) {
      dirtyRecord.setDirty(false);
      if (!dirtyRecord.isActive()) {
        keysToDelete.add(dirtyRecord.getRecordEntry().getKey());
      }
 else {
        Map.Entry entry=dirtyRecord.getRecordEntry();
        updates.put(entry.getKey(),entry.getValue());
      }
    }
    if (keysToDelete.size() == 1) {
      store.delete(keysToDelete.iterator().next());
    }
 else     if (keysToDelete.size() > 1) {
      store.deleteAll(keysToDelete);
    }
    if (updates.size() == 1) {
      Map.Entry entry=updates.entrySet().iterator().next();
      store.store(entry.getKey(),entry.getValue());
    }
 else     if (updates.size() > 1) {
      store.storeAll(updates);
    }
  }
 catch (  Exception e) {
    for (    Record dirtyRecord : dirtyRecords) {
      dirtyRecord.setDirty(true);
    }
  }
}",0.2093264248704663
50353,"public void put(Request req){
  long now=System.currentTimeMillis();
  if (mapRecords.size() >= maxSize) {
  }
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req.key);
  if (record != null && !record.isValid(now)) {
    record.setValue(null);
    record.setMultiValues(null);
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (record != null && record.isActive() && record.isValid(now) && record.getValue() != null) {
      req.clearForResponse();
      req.response=record.getValue();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (record == null || !record.isActive() || !record.isValid(now) || record.getValue() == null) {
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (record == null || !record.isActive() || !record.isValid(now)) {
      req.response=Boolean.FALSE;
      return;
    }
    MultiData multiData=(MultiData)toObject(req.value);
    if (multiData == null || multiData.size() != 2) {
      throw new RuntimeException(""String_Node_Str"" + multiData);
    }
    Data expectedOldValue=multiData.getData(0);
    req.value=multiData.getData(1);
    if (!record.getValue().equals(expectedOldValue)) {
      req.response=Boolean.FALSE;
      return;
    }
  }
  Data oldValue=null;
  Op op=UPDATE;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    mapRecords.put(req.key,record);
    op=CREATE;
  }
 else {
    if (!record.isActive()) {
      op=CREATE;
    }
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValue() : null;
    record.setValue(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0) {
    record.setExpirationTime(req.ttl);
    ttlPerRecord=true;
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_ADDED,record,req.caller);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_UPDATED,record,req.caller);
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateIndexes(record);
  markAsDirty(record);
  req.clearForResponse();
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}","public void put(Request req){
  long now=System.currentTimeMillis();
  if (mapRecords.size() >= maxSize) {
  }
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req.key);
  if (record != null && !record.isValid(now)) {
    record.setValue(null);
    record.setMultiValues(null);
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (record != null && record.isActive() && record.isValid(now) && record.getValue() != null) {
      req.clearForResponse();
      req.response=record.getValue();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (record == null || !record.isActive() || !record.isValid(now) || record.getValue() == null) {
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (record == null || !record.isActive() || !record.isValid(now)) {
      req.response=Boolean.FALSE;
      return;
    }
    MultiData multiData=(MultiData)toObject(req.value);
    if (multiData == null || multiData.size() != 2) {
      throw new RuntimeException(""String_Node_Str"" + multiData);
    }
    Data expectedOldValue=multiData.getData(0);
    req.value=multiData.getData(1);
    if (!record.getValue().equals(expectedOldValue)) {
      req.response=Boolean.FALSE;
      return;
    }
  }
  Data oldValue=null;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    mapRecords.put(req.key,record);
  }
 else {
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValue() : null;
    record.setValue(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0) {
    record.setExpirationTime(req.ttl);
    ttlPerRecord=true;
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_ADDED,record,req.caller);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_UPDATED,record,req.caller);
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateIndexes(record);
  markAsDirty(record);
  req.clearForResponse();
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}",0.9827444535743632
50354,"private void executeStoreUpdate(final Map<Data,Data> entriesToStore,final Collection<Data> keysToDelete){
  final int entriesToStoreSize=entriesToStore.size();
  final int keysToDeleteSize=keysToDelete.size();
  if (entriesToStoreSize > 0 || keysToDeleteSize > 0) {
    concurrentMapManager.node.executorManager.executeStoreTask(new Runnable(){
      public void run(){
        if (keysToDeleteSize > 0) {
          if (keysToDeleteSize == 1) {
            Data key=keysToDelete.iterator().next();
            store.delete(toObject(key));
          }
 else {
            Collection realKeys=new HashSet();
            for (            Data key : keysToDelete) {
              realKeys.add(toObject(key));
            }
            store.deleteAll(realKeys);
          }
        }
        if (entriesToStoreSize > 0) {
          Object keyFirst=null;
          Object valueFirst=null;
          Set<Map.Entry<Data,Data>> entries=entriesToStore.entrySet();
          Map realEntries=new HashMap();
          for (          Map.Entry<Data,Data> entry : entries) {
            Object key=toObject(entry.getKey());
            Object value=toObject(entry.getValue());
            realEntries.put(key,value);
            if (keyFirst == null) {
              keyFirst=key;
              valueFirst=value;
            }
          }
          if (entriesToStoreSize == 1) {
            store.store(keyFirst,valueFirst);
          }
 else {
            store.storeAll(realEntries);
          }
        }
      }
    }
);
  }
}","private void executeStoreUpdate(final Set<Record> dirtyRecords){
  if (dirtyRecords.size() > 0) {
    concurrentMapManager.node.executorManager.executeStoreTask(new Runnable(){
      public void run(){
        try {
          Set<Object> keysToDelete=new HashSet<Object>();
          Map<Object,Object> updates=new HashMap<Object,Object>();
          for (          Record dirtyRecord : dirtyRecords) {
            dirtyRecord.setDirty(false);
            if (!dirtyRecord.isActive()) {
              keysToDelete.add(dirtyRecord.getRecordEntry().getKey());
            }
 else {
              Map.Entry entry=dirtyRecord.getRecordEntry();
              updates.put(entry.getKey(),entry.getValue());
            }
          }
          if (keysToDelete.size() == 1) {
            store.delete(keysToDelete.iterator().next());
          }
 else           if (keysToDelete.size() > 1) {
            store.deleteAll(keysToDelete);
          }
          if (updates.size() == 1) {
            Map.Entry entry=updates.entrySet().iterator().next();
            store.store(entry.getKey(),entry.getValue());
          }
 else           if (updates.size() > 1) {
            store.storeAll(updates);
          }
        }
 catch (        Exception e) {
          for (          Record dirtyRecord : dirtyRecords) {
            dirtyRecord.setDirty(true);
          }
        }
      }
    }
);
  }
}",0.2434662998624484
50355,"void startCleanup(){
  final long now=System.currentTimeMillis();
  if (locallyOwnedMap != null) {
    locallyOwnedMap.evict(now);
  }
  if (mapNearCache != null) {
    mapNearCache.evict(now,false);
  }
  final Map<Data,Data> entriesToStore=new HashMap<Data,Data>();
  final Collection<Data> keysToDelete=new HashSet<Data>();
  final Set<Record> recordsUnknown=new HashSet<Record>();
  final Set<Record> recordsToPurge=new HashSet<Record>();
  final Set<Record> recordsToEvict=new HashSet<Record>();
  final Set<Record> sortedRecords=new TreeSet<Record>(evictionComparator);
  final Collection<Record> records=mapRecords.values();
  final int clusterMemberSize=node.getClusterImpl().getMembers().size();
  final int memberCount=(clusterMemberSize == 0) ? 1 : clusterMemberSize;
  final int maxSizePerJVM=maxSize / memberCount;
  final boolean evictionAware=evictionComparator != null && maxSizePerJVM > 0;
  final PartitionServiceImpl partitionService=concurrentMapManager.partitionManager.partitionServiceImpl;
  int recordsStillOwned=0;
  int backupPurgeCount=0;
  for (  Record record : records) {
    PartitionServiceImpl.PartitionProxy partition=partitionService.getPartition(record.getBlockId());
    Member owner=partition.getOwner();
    if (owner != null && !partition.isMigrating()) {
      boolean owned=owner.localMember();
      if (owned) {
        if (store != null && record.isDirty()) {
          if (now > record.getWriteTime()) {
            if (record.getValue() != null) {
              entriesToStore.put(record.getKey(),record.getValue());
            }
 else {
              keysToDelete.add(record.getKey());
            }
            record.setDirty(false);
          }
        }
 else         if (shouldPurgeRecord(record,now)) {
          recordsToPurge.add(record);
        }
 else         if (record.isActive() && !record.isValid(now)) {
          recordsToEvict.add(record);
        }
 else         if (evictionAware && record.isActive() && record.isEvictable()) {
          sortedRecords.add(record);
          recordsStillOwned++;
        }
 else {
          recordsStillOwned++;
        }
      }
 else {
        Member ownerEventual=partition.getEventualOwner();
        boolean backup=false;
        if (ownerEventual != null && owner != null && !owner.localMember()) {
          int distance=node.getClusterImpl().getDistanceFrom(ownerEventual);
          backup=(distance != -1 && distance <= getBackupCount());
        }
        if (backup) {
          if (shouldPurgeRecord(record,now)) {
            recordsToPurge.add(record);
            backupPurgeCount++;
          }
        }
 else {
          recordsUnknown.add(record);
        }
      }
    }
  }
  if (evictionAware && maxSizePerJVM < recordsStillOwned) {
    int numberOfRecordsToEvict=(int)(recordsStillOwned * evictionRate);
    int evictedCount=0;
    for (    Record record : sortedRecords) {
      if (record.isActive() && record.isEvictable()) {
        recordsToEvict.add(record);
        if (++evictedCount >= numberOfRecordsToEvict) {
          break;
        }
      }
    }
  }
  Level levelLog=(concurrentMapManager.LOG_STATE) ? Level.INFO : Level.FINEST;
  logger.log(levelLog,name + ""String_Node_Str"" + ""String_Node_Str""+ entriesToStore.size()+ ""String_Node_Str""+ keysToDelete.size()+ ""String_Node_Str""+ recordsToPurge.size()+ ""String_Node_Str""+ recordsToEvict.size()+ ""String_Node_Str""+ recordsUnknown.size()+ ""String_Node_Str""+ recordsStillOwned+ ""String_Node_Str""+ backupPurgeCount);
  executeStoreUpdate(entriesToStore,keysToDelete);
  executeEviction(recordsToEvict);
  executePurge(recordsToPurge);
  executePurgeUnknowns(recordsUnknown);
}","void startCleanup(){
  final long now=System.currentTimeMillis();
  if (locallyOwnedMap != null) {
    locallyOwnedMap.evict(now);
  }
  if (mapNearCache != null) {
    mapNearCache.evict(now,false);
  }
  final Set<Record> recordsDirty=new HashSet<Record>();
  final Set<Record> recordsUnknown=new HashSet<Record>();
  final Set<Record> recordsToPurge=new HashSet<Record>();
  final Set<Record> recordsToEvict=new HashSet<Record>();
  final Set<Record> sortedRecords=new TreeSet<Record>(evictionComparator);
  final Collection<Record> records=mapRecords.values();
  final int clusterMemberSize=node.getClusterImpl().getMembers().size();
  final int memberCount=(clusterMemberSize == 0) ? 1 : clusterMemberSize;
  final int maxSizePerJVM=maxSize / memberCount;
  final boolean evictionAware=evictionComparator != null && maxSizePerJVM > 0;
  final PartitionServiceImpl partitionService=concurrentMapManager.partitionManager.partitionServiceImpl;
  int recordsStillOwned=0;
  int backupPurgeCount=0;
  for (  Record record : records) {
    PartitionServiceImpl.PartitionProxy partition=partitionService.getPartition(record.getBlockId());
    Member owner=partition.getOwner();
    if (owner != null && !partition.isMigrating()) {
      boolean owned=owner.localMember();
      if (owned) {
        if (store != null && record.isDirty()) {
          if (now > record.getWriteTime()) {
            recordsDirty.add(record);
          }
        }
 else         if (shouldPurgeRecord(record,now)) {
          recordsToPurge.add(record);
        }
 else         if (record.isActive() && !record.isValid(now)) {
          recordsToEvict.add(record);
        }
 else         if (evictionAware && record.isActive() && record.isEvictable()) {
          sortedRecords.add(record);
          recordsStillOwned++;
        }
 else {
          recordsStillOwned++;
        }
      }
 else {
        Member ownerEventual=partition.getEventualOwner();
        boolean backup=false;
        if (ownerEventual != null && owner != null && !owner.localMember()) {
          int distance=node.getClusterImpl().getDistanceFrom(ownerEventual);
          backup=(distance != -1 && distance <= getBackupCount());
        }
        if (backup) {
          if (shouldPurgeRecord(record,now)) {
            recordsToPurge.add(record);
            backupPurgeCount++;
          }
        }
 else {
          recordsUnknown.add(record);
        }
      }
    }
  }
  if (evictionAware && maxSizePerJVM < recordsStillOwned) {
    int numberOfRecordsToEvict=(int)(recordsStillOwned * evictionRate);
    int evictedCount=0;
    for (    Record record : sortedRecords) {
      if (record.isActive() && record.isEvictable()) {
        recordsToEvict.add(record);
        if (++evictedCount >= numberOfRecordsToEvict) {
          break;
        }
      }
    }
  }
  Level levelLog=(concurrentMapManager.LOG_STATE) ? Level.INFO : Level.FINEST;
  logger.log(levelLog,name + ""String_Node_Str"" + ""String_Node_Str""+ recordsDirty.size()+ ""String_Node_Str""+ recordsToPurge.size()+ ""String_Node_Str""+ recordsToEvict.size()+ ""String_Node_Str""+ recordsUnknown.size()+ ""String_Node_Str""+ recordsStillOwned+ ""String_Node_Str""+ backupPurgeCount);
  executeStoreUpdate(recordsDirty);
  executeEviction(recordsToEvict);
  executePurge(recordsToPurge);
  executePurgeUnknowns(recordsUnknown);
}",0.8956459671663097
50356,"public Map loadAll(Collection keys){
  try {
    if (shouldFail.get()) {
      throw new RuntimeException();
    }
 else {
      Map results=new HashMap();
      for (      Object key : keys) {
        Object value=db.get(key);
        if (value != null) {
          results.put(key,value);
        }
      }
      return results;
    }
  }
  finally {
    loadAlls.incrementAndGet();
  }
}","public Map loadAll(Collection keys){
  try {
    if (shouldFail.get()) {
      throw new RuntimeException();
    }
 else {
      Map results=new HashMap();
      for (      Object key : keys) {
        Object value=db.get(key);
        if (value != null) {
          results.put(key,value);
        }
      }
      return results;
    }
  }
  finally {
    loadAlls.incrementAndGet();
    notifyListeners();
  }
}",0.9638854296388544
50357,"public void delete(Object key){
  try {
    if (shouldFail.get()) {
      throw new RuntimeException();
    }
 else {
      db.remove(key);
    }
  }
  finally {
    deletes.incrementAndGet();
  }
}","public void delete(Object key){
  try {
    if (shouldFail.get()) {
      throw new RuntimeException();
    }
 else {
      db.remove(key);
    }
  }
  finally {
    deletes.incrementAndGet();
    notifyListeners();
  }
}",0.9307875894988068
50358,"public void storeAll(Map map){
  try {
    if (shouldFail.get()) {
      throw new RuntimeException();
    }
 else {
      db.putAll(map);
    }
  }
  finally {
    storeAlls.incrementAndGet();
  }
}","public void storeAll(Map map){
  try {
    if (shouldFail.get()) {
      throw new RuntimeException();
    }
 else {
      db.putAll(map);
    }
  }
  finally {
    storeAlls.incrementAndGet();
    notifyListeners();
  }
}",0.9311163895486936
50359,"public void deleteAll(Collection keys){
  try {
    if (shouldFail.get()) {
      throw new RuntimeException();
    }
 else {
      for (      Object key : keys) {
        db.remove(key);
      }
    }
  }
  finally {
    deleteAlls.incrementAndGet();
  }
}","public void deleteAll(Collection keys){
  try {
    if (shouldFail.get()) {
      throw new RuntimeException();
    }
 else {
      for (      Object key : keys) {
        db.remove(key);
      }
    }
  }
  finally {
    deleteAlls.incrementAndGet();
    notifyListeners();
  }
}",0.9459962756052142
50360,"public void store(Object key,Object value){
  try {
    if (shouldFail.get()) {
      throw new RuntimeException();
    }
 else {
      db.put(key,value);
    }
  }
  finally {
    stores.incrementAndGet();
  }
}","public void store(Object key,Object value){
  try {
    if (shouldFail.get()) {
      throw new RuntimeException();
    }
 else {
      db.put(key,value);
    }
  }
  finally {
    stores.incrementAndGet();
    notifyListeners();
  }
}",0.9351230425055927
50361,"public void evict(long now){
  if (now - lastEvictionTime > 10000) {
    lastEvictionTime=now;
    Set<Map.Entry<Object,Record>> entries=mapCache.entrySet();
    List<Object> lsKeysToRemove=new ArrayList<Object>();
    for (    Map.Entry<Object,Record> entry : entries) {
      Object key=entry.getKey();
      Record record=entry.getValue();
      if (!record.isActive() || !record.isValid(now)) {
        lsKeysToRemove.add(key);
      }
    }
    for (    Object key : lsKeysToRemove) {
      mapCache.remove(key);
    }
  }
}","public void evict(long now){
  if (now - lastEvictionTime > 10000) {
    lastEvictionTime=now;
    Set<Map.Entry<Object,Record>> entries=mapCache.entrySet();
    List<Object> lsKeysToRemove=new ArrayList<Object>();
    for (    Map.Entry<Object,Record> entry : entries) {
      Object key=entry.getKey();
      Record record=entry.getValue();
      if (record == null || !record.isActive() || !record.isValid(now)) {
        lsKeysToRemove.add(key);
      }
    }
    for (    Object key : lsKeysToRemove) {
      mapCache.remove(key);
    }
  }
}",0.949814126394052
50362,"public void own(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=toRecord(req);
  if (req.ttl <= 0 || req.timeout <= 0) {
    record.setInvalid();
  }
 else {
    record.setExpirationTime(req.ttl);
    record.setMaxIdle(req.timeout);
  }
  markAsActive(record);
  markAsDirty(record);
  updateIndexes(record);
  record.setVersion(req.version);
}","public void own(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=toRecord(req);
  if (req.ttl <= 0 || req.timeout <= 0) {
    record.setInvalid();
  }
 else {
    record.setExpirationTime(req.ttl);
    record.setMaxIdle(req.timeout);
  }
  markAsActive(record);
  if (store != null && writeDelayMillis > 0) {
    markAsDirty(record);
  }
  updateIndexes(record);
  record.setVersion(req.version);
}",0.9492822966507176
50363,"public void instanceCreated(InstanceEvent event){
  assertEquals(InstanceEventType.CREATED,event.getEventType());
  IMap<Integer,Integer> map=(IMap<Integer,Integer>)event.getInstance();
  assertEquals(instance.getName(),map.getName());
  assertEquals(1,map.size());
  createdLatch.countDown();
}","public void instanceCreated(InstanceEvent event){
  assertEquals(InstanceEventType.CREATED,event.getEventType());
  IMap<Integer,Integer> map=(IMap<Integer,Integer>)event.getInstance();
  assertEquals(instance.getName(),map.getName());
  createdLatch.countDown();
}",0.9464285714285714
50364,"@Test public void addInstanceListener() throws InterruptedException {
  final CountDownLatch destroyedLatch=new CountDownLatch(1);
  final CountDownLatch createdLatch=new CountDownLatch(1);
  final IMap<Integer,Integer> instance=getHazelcastClient().getMap(""String_Node_Str"");
  InstanceListener listener=new InstanceListener(){
    public void instanceDestroyed(    InstanceEvent event){
      assertEquals(InstanceEventType.DESTROYED,event.getEventType());
      assertEquals(instance,event.getInstance());
      destroyedLatch.countDown();
    }
    public void instanceCreated(    InstanceEvent event){
      assertEquals(InstanceEventType.CREATED,event.getEventType());
      IMap<Integer,Integer> map=(IMap<Integer,Integer>)event.getInstance();
      assertEquals(instance.getName(),map.getName());
      assertEquals(1,map.size());
      createdLatch.countDown();
    }
  }
;
  getHazelcastClient().addInstanceListener(listener);
  instance.put(1,1);
  assertEquals(1,instance.size());
  assertTrue(createdLatch.await(2,TimeUnit.SECONDS));
  instance.destroy();
  assertTrue(destroyedLatch.await(2,TimeUnit.SECONDS));
  getHazelcastClient().removeInstanceListener(listener);
}","@Test public void addInstanceListener() throws InterruptedException {
  final CountDownLatch destroyedLatch=new CountDownLatch(1);
  final CountDownLatch createdLatch=new CountDownLatch(1);
  final IMap<Integer,Integer> instance=getHazelcastClient().getMap(""String_Node_Str"");
  InstanceListener listener=new InstanceListener(){
    public void instanceDestroyed(    InstanceEvent event){
      assertEquals(InstanceEventType.DESTROYED,event.getEventType());
      assertEquals(instance,event.getInstance());
      destroyedLatch.countDown();
    }
    public void instanceCreated(    InstanceEvent event){
      assertEquals(InstanceEventType.CREATED,event.getEventType());
      IMap<Integer,Integer> map=(IMap<Integer,Integer>)event.getInstance();
      assertEquals(instance.getName(),map.getName());
      createdLatch.countDown();
    }
  }
;
  getHazelcastClient().addInstanceListener(listener);
  instance.put(1,1);
  assertEquals(1,instance.size());
  assertTrue(createdLatch.await(10,TimeUnit.SECONDS));
  instance.destroy();
  assertTrue(destroyedLatch.await(10,TimeUnit.SECONDS));
  getHazelcastClient().removeInstanceListener(listener);
}",0.9828620394173092
50365,"public ClusterManager(final Node node){
  super(node);
  WAIT_MILLIS_BEFORE_JOIN=node.groupProperties.WAIT_SECONDS_BEFORE_JOIN.getInteger() * 1000L;
  MAX_NO_HEARTBEAT_MILLIS=node.groupProperties.MAX_NO_HEARTBEAT_SECONDS.getInteger() * 1000L;
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      heartBeater();
    }
  }
);
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      checkScheduledActions();
    }
  }
);
  node.connectionManager.addConnectionListener(this);
  registerPacketProcessor(ClusterOperation.RESPONSE,new PacketProcessor(){
    public void process(    Packet packet){
      handleResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.HEARTBEAT,new PacketProcessor(){
    public void process(    Packet packet){
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS_AND_RESPOND,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      sendResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_BOOLEAN,new PacketProcessor(){
    public void process(    Packet packet){
      Boolean result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable<Boolean>)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=Boolean.FALSE;
      }
      if (result == Boolean.TRUE) {
        sendResponse(packet);
      }
 else {
        sendResponseFailure(packet);
      }
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_OBJECT,new PacketProcessor(){
    public void process(    Packet packet){
      Object result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=null;
      }
      if (result != null) {
        Data value;
        if (result instanceof Data) {
          value=(Data)result;
        }
 else {
          value=toData(result);
        }
        packet.setValue(value);
      }
      sendResponse(packet);
    }
  }
);
}","public ClusterManager(final Node node){
  super(node);
  WAIT_MILLIS_BEFORE_JOIN=node.groupProperties.WAIT_SECONDS_BEFORE_JOIN.getInteger() * 1000L;
  MAX_NO_HEARTBEAT_MILLIS=node.groupProperties.MAX_NO_HEARTBEAT_SECONDS.getInteger() * 1000L;
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      heartBeater();
    }
  }
);
  node.clusterService.registerPeriodicRunnable(new MemberStatsPublisher());
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      checkScheduledActions();
    }
  }
);
  node.connectionManager.addConnectionListener(this);
  registerPacketProcessor(ClusterOperation.RESPONSE,new PacketProcessor(){
    public void process(    Packet packet){
      handleResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.HEARTBEAT,new PacketProcessor(){
    public void process(    Packet packet){
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS_AND_RESPOND,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      sendResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_BOOLEAN,new PacketProcessor(){
    public void process(    Packet packet){
      Boolean result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable<Boolean>)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=Boolean.FALSE;
      }
      if (result == Boolean.TRUE) {
        sendResponse(packet);
      }
 else {
        sendResponseFailure(packet);
      }
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_OBJECT,new PacketProcessor(){
    public void process(    Packet packet){
      Object result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=null;
      }
      if (result != null) {
        Data value;
        if (result instanceof Data) {
          value=(Data)result;
        }
 else {
          value=toData(result);
        }
        packet.setValue(value);
      }
      sendResponse(packet);
    }
  }
);
}",0.9880277252678008
50366,"boolean sendBackup(boolean add,Address caller,Data data,int blockId,int addIndex){
  if (zeroBackup)   return true;
  if (addIndex == -1)   throw new RuntimeException(""String_Node_Str"");
  if (lsMembers.size() > 1) {
    if (getNextMemberAfter(thisAddress,true,1).getAddress().equals(caller)) {
      return true;
    }
    ClusterOperation operation=ClusterOperation.BLOCKING_QUEUE_BACKUP_REMOVE;
    if (add) {
      operation=ClusterOperation.BLOCKING_QUEUE_BACKUP_ADD;
    }
    Packet packet=obtainPacket(name,null,data,operation,0);
    packet.blockId=blockId;
    packet.longValue=addIndex;
    boolean sent=send(packet,getNextMemberAfter(thisAddress,true,1).getAddress());
    if (!sent) {
      releasePacket(packet);
    }
    return sent;
  }
 else {
    return true;
  }
}","boolean sendBackup(boolean add,Address caller,Data data,int blockId,int addIndex){
  if (zeroBackup)   return true;
  if (addIndex == -1)   throw new RuntimeException(""String_Node_Str"");
  if (lsMembers.size() > 1) {
    MemberImpl memberBackup=getNextMemberAfter(thisAddress,true,1);
    if (memberBackup == null || memberBackup.getAddress().equals(caller)) {
      return true;
    }
    ClusterOperation operation=ClusterOperation.BLOCKING_QUEUE_BACKUP_REMOVE;
    if (add) {
      operation=ClusterOperation.BLOCKING_QUEUE_BACKUP_ADD;
    }
    Packet packet=obtainPacket(name,null,data,operation,0);
    packet.blockId=blockId;
    packet.longValue=addIndex;
    boolean sent=send(packet,memberBackup.getAddress());
    if (!sent) {
      releasePacket(packet);
    }
    return sent;
  }
 else {
    return true;
  }
}",0.9228855721393034
50367,"LocalMapStatsImpl getLocalMapStats(){
  LocalMapStatsImpl localMapStats=new LocalMapStatsImpl();
  long now=System.currentTimeMillis();
  int ownedEntryCount=0;
  int backupEntryCount=0;
  int markedAsRemovedEntryCount=0;
  int ownedEntryMemoryCost=0;
  int backupEntryMemoryCost=0;
  int markedAsRemovedMemoryCost=0;
  int hits=0;
  int lockedEntryCount=0;
  int lockWaitCount=0;
  ClusterImpl clusterImpl=node.getClusterImpl();
  final Collection<Record> records=mapRecords.values();
  final PartitionServiceImpl partitionService=concurrentMapManager.partitionManager.partitionServiceImpl;
  for (  Record record : records) {
    if (!record.isActive() || !record.isValid(now)) {
      markedAsRemovedEntryCount++;
      markedAsRemovedMemoryCost+=record.getCost();
    }
 else {
      PartitionServiceImpl.PartitionProxy partition=partitionService.getPartition(record.getBlockId());
      Member owner=partition.getOwner();
      if (owner != null && !partition.isMigrating()) {
        boolean owned=owner.localMember();
        if (owned) {
          ownedEntryCount+=record.valueCount();
          ownedEntryMemoryCost+=record.getCost();
          localMapStats.setLastAccessTime(record.getLastAccessTime());
          localMapStats.setLastUpdateTime(record.getLastUpdateTime());
          hits+=record.getHits();
          if (record.isLocked()) {
            lockedEntryCount++;
            lockWaitCount+=record.getScheduledActionCount();
          }
        }
 else {
          Member ownerEventual=partition.getEventualOwner();
          boolean backup=false;
          if (ownerEventual != null && !owner.localMember()) {
            int distance=node.getClusterImpl().getDistanceFrom(ownerEventual);
            backup=(distance != -1 && distance <= getBackupCount());
          }
          if (backup && !shouldPurgeRecord(record,now)) {
            backupEntryCount+=record.valueCount();
            backupEntryMemoryCost+=record.getCost();
          }
 else {
            markedAsRemovedEntryCount++;
            markedAsRemovedMemoryCost+=record.getCost();
          }
        }
      }
    }
  }
  localMapStats.setMarkedAsRemovedEntryCount(markedAsRemovedEntryCount);
  localMapStats.setMarkedAsRemovedMemoryCost(markedAsRemovedMemoryCost);
  localMapStats.setLockWaitCount(lockWaitCount);
  localMapStats.setLockedEntryCount(lockedEntryCount);
  localMapStats.setHits(hits);
  localMapStats.setOwnedEntryCount(ownedEntryCount);
  localMapStats.setBackupEntryCount(backupEntryCount);
  localMapStats.setOwnedEntryMemoryCost(ownedEntryMemoryCost);
  localMapStats.setBackupEntryMemoryCost(backupEntryMemoryCost);
  localMapStats.setLastEvictionTime(clusterImpl.getClusterTimeFor(lastEvictionTime));
  localMapStats.setCreationTime(clusterImpl.getClusterTimeFor(creationTime));
  return localMapStats;
}","LocalMapStatsImpl getLocalMapStats(){
  LocalMapStatsImpl localMapStats=new LocalMapStatsImpl();
  long now=System.currentTimeMillis();
  int ownedEntryCount=0;
  int backupEntryCount=0;
  int markedAsRemovedEntryCount=0;
  int ownedEntryMemoryCost=0;
  int backupEntryMemoryCost=0;
  int markedAsRemovedMemoryCost=0;
  int hits=0;
  int lockedEntryCount=0;
  int lockWaitCount=0;
  ClusterImpl clusterImpl=node.getClusterImpl();
  final Collection<Record> records=mapRecords.values();
  final PartitionServiceImpl partitionService=concurrentMapManager.partitionManager.partitionServiceImpl;
  for (  Record record : records) {
    if (!record.isActive() || !record.isValid(now)) {
      markedAsRemovedEntryCount++;
      markedAsRemovedMemoryCost+=record.getCost();
    }
 else {
      PartitionServiceImpl.PartitionProxy partition=partitionService.getPartition(record.getBlockId());
      Member owner=partition.getOwner();
      if (owner != null && !partition.isMigrating()) {
        boolean owned=owner.localMember();
        if (owned) {
          ownedEntryCount+=record.valueCount();
          ownedEntryMemoryCost+=record.getCost();
          localMapStats.setLastAccessTime(record.getLastAccessTime());
          localMapStats.setLastUpdateTime(record.getLastUpdateTime());
          hits+=record.getHits();
          if (record.isLocked()) {
            lockedEntryCount++;
            lockWaitCount+=record.getScheduledActionCount();
          }
        }
 else {
          Member ownerEventual=partition.getEventualOwner();
          boolean backup=false;
          if (ownerEventual != null && !owner.localMember()) {
            int distance=node.getClusterImpl().getDistanceFrom(ownerEventual);
            backup=(distance != -1 && distance <= getBackupCount());
          }
          if (backup && !shouldPurgeRecord(record,now)) {
            backupEntryCount+=record.valueCount();
            backupEntryMemoryCost+=record.getCost();
          }
 else {
            markedAsRemovedEntryCount++;
            markedAsRemovedMemoryCost+=record.getCost();
          }
        }
      }
    }
  }
  localMapStats.setMarkedAsRemovedEntryCount(zeroOrPositive(markedAsRemovedEntryCount));
  localMapStats.setMarkedAsRemovedMemoryCost(zeroOrPositive(markedAsRemovedMemoryCost));
  localMapStats.setLockWaitCount(zeroOrPositive(lockWaitCount));
  localMapStats.setLockedEntryCount(zeroOrPositive(lockedEntryCount));
  localMapStats.setHits(zeroOrPositive(hits));
  localMapStats.setOwnedEntryCount(zeroOrPositive(ownedEntryCount));
  localMapStats.setBackupEntryCount(zeroOrPositive(backupEntryCount));
  localMapStats.setOwnedEntryMemoryCost(zeroOrPositive(ownedEntryMemoryCost));
  localMapStats.setBackupEntryMemoryCost(zeroOrPositive(backupEntryMemoryCost));
  localMapStats.setLastEvictionTime(zeroOrPositive(clusterImpl.getClusterTimeFor(lastEvictionTime)));
  localMapStats.setCreationTime(zeroOrPositive(clusterImpl.getClusterTimeFor(creationTime)));
  return localMapStats;
}",0.9642365887207704
50368,abstract void doRun();,public abstract void doRun();,0.8627450980392157
50369,"@Test public void testTTLAndMemoryLeak2() throws Exception {
  Runtime.getRuntime().gc();
  long initialUsedMemory=getUsedMemoryAsMB();
  Config config=new XmlConfigBuilder().build();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h4=Hazelcast.newHazelcastInstance(config);
  IMap map1=h1.getMap(""String_Node_Str"");
  final int size=20000;
  for (int i=0; i < size; i++) {
    map1.put(i,new byte[10000],10,TimeUnit.SECONDS);
  }
  long usedMemoryStart=getUsedMemoryAsMB();
  assertTrue(usedMemoryStart > 300);
  sleep(50000);
  Runtime.getRuntime().gc();
  sleep(5000);
  long usedMemoryEnd=getUsedMemoryAsMB();
  assertTrue(initialUsedMemory + ""String_Node_Str"" + usedMemoryEnd,(usedMemoryEnd - initialUsedMemory) < 50);
}","@Test public void testTTLAndMemoryLeak2() throws Exception {
  Runtime.getRuntime().gc();
  long initialUsedMemory=getUsedMemoryAsMB();
  Config config=new XmlConfigBuilder().build();
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h4=Hazelcast.newHazelcastInstance(config);
  IMap map1=h1.getMap(""String_Node_Str"");
  final int size=20000;
  for (int i=0; i < size; i++) {
    map1.put(i,new byte[10000],10,TimeUnit.SECONDS);
  }
  long usedMemoryStart=getUsedMemoryAsMB();
  assertTrue(""String_Node_Str"" + usedMemoryStart,usedMemoryStart > 300);
  sleep(50000);
  Runtime.getRuntime().gc();
  sleep(5000);
  long usedMemoryEnd=getUsedMemoryAsMB();
  assertTrue(initialUsedMemory + ""String_Node_Str"" + usedMemoryEnd,(usedMemoryEnd - initialUsedMemory) < 50);
}",0.8042035398230089
50370,"@Test public void testMaxIdleAndMemoryLeak() throws Exception {
  Runtime.getRuntime().gc();
  long initialUsedMemory=getUsedMemoryAsMB();
  Config config=new XmlConfigBuilder().build();
  MapConfig mapConfig=config.getMapConfig(""String_Node_Str"");
  mapConfig.setMaxIdleSeconds(5);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h4=Hazelcast.newHazelcastInstance(config);
  IMap map1=h1.getMap(""String_Node_Str"");
  final int size=20000;
  for (int i=0; i < size; i++) {
    map1.put(i,new byte[10000]);
  }
  long usedMemoryStart=getUsedMemoryAsMB();
  assertTrue(usedMemoryStart > 300);
  sleep(50000);
  Runtime.getRuntime().gc();
  sleep(5000);
  long usedMemoryEnd=getUsedMemoryAsMB();
  assertTrue(initialUsedMemory + ""String_Node_Str"" + usedMemoryEnd,(usedMemoryEnd - initialUsedMemory) < 50);
}","@Test public void testMaxIdleAndMemoryLeak() throws Exception {
  Runtime.getRuntime().gc();
  long initialUsedMemory=getUsedMemoryAsMB();
  Config config=new XmlConfigBuilder().build();
  MapConfig mapConfig=config.getMapConfig(""String_Node_Str"");
  mapConfig.setMaxIdleSeconds(5);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h4=Hazelcast.newHazelcastInstance(config);
  IMap map1=h1.getMap(""String_Node_Str"");
  final int size=20000;
  for (int i=0; i < size; i++) {
    map1.put(i,new byte[10000]);
  }
  long usedMemoryStart=getUsedMemoryAsMB();
  assertTrue(""String_Node_Str"" + usedMemoryStart,usedMemoryStart > 300);
  sleep(50000);
  Runtime.getRuntime().gc();
  sleep(5000);
  long usedMemoryEnd=getUsedMemoryAsMB();
  assertTrue(initialUsedMemory + ""String_Node_Str"" + usedMemoryEnd,(usedMemoryEnd - initialUsedMemory) < 50);
}",0.8199389623601221
50371,"public void addThisAsListener(IMap map,Data key,boolean includeValue){
  if (key == null) {
    map.addEntryListener(this,includeValue);
  }
 else {
    map.addEntryListener(this,key,includeValue);
  }
}","public void addThisAsListener(IMap map,Data key,boolean includeValue){
  if (key == null) {
    map.addEntryListener(this,includeValue);
  }
 else {
    map.addEntryListener(this,toObject(key),includeValue);
  }
}",0.9759615384615384
50372,"public boolean hasNext(){
  next=null;
  if (txnOffers != null) {
    boolean hasInTxn=txnOffers.hasNext();
    hasNextCalled=true;
    if (hasInTxn) {
      next=txnOffers.next();
      return true;
    }
 else {
      txnOffers=null;
    }
  }
  while (next == null) {
    boolean canRead=setNextBlock();
    if (!canRead)     return false;
    Read read=new Read();
    next=read.read(name,currentBlockId,currentIndex);
    if (next == null) {
      currentIndex=-1;
    }
 else {
      currentIndex=read.readIndex;
      currentIndex++;
    }
  }
  hasNextCalled=true;
  return true;
}","public boolean hasNext(){
  next=null;
  if (txnOffers != null) {
    boolean hasInTxn=txnOffers.hasNext();
    hasNextCalled=true;
    if (hasInTxn) {
      next=txnOffers.next();
      return true;
    }
 else {
      txnOffers=null;
    }
  }
  while (next == null) {
    boolean canRead=setNextBlock();
    if (!canRead)     return false;
    Read read=new Read();
    next=read.read(name,currentBlockId,currentIndex);
    if (next == null) {
      currentIndex=-1;
    }
 else {
      currentIndex=read.readIndex;
      nextBlockId=currentBlockId;
      nextIndex=currentIndex;
      currentIndex++;
    }
  }
  hasNextCalled=true;
  return true;
}",0.9484702093397746
50373,"public void flush(Connection connection) throws IOException {
  DataOutputStream dos=connection.getOutputStream();
  dos.flush();
}","public void flush(Connection connection) throws IOException {
  if (connection != null) {
    DataOutputStream dos=connection.getOutputStream();
    dos.flush();
  }
}",0.8791946308724832
50374,"public void write(Connection connection,Packet request) throws IOException {
  if (!connection.headersWritten) {
    connection.getOutputStream().write(""String_Node_Str"".getBytes());
    connection.headersWritten=true;
    connection.getOutputStream().flush();
  }
  DataOutputStream dos=connection.getOutputStream();
  request.writeTo(dos);
}","public void write(Connection connection,Packet request) throws IOException {
  if (connection != null) {
    if (!connection.headersWritten) {
      connection.getOutputStream().write(""String_Node_Str"".getBytes());
      connection.headersWritten=true;
      connection.getOutputStream().flush();
    }
    DataOutputStream dos=connection.getOutputStream();
    request.writeTo(dos);
  }
}",0.9371584699453552
50375,"public void put(Request req){
  long now=System.currentTimeMillis();
  if (mapRecords.size() >= maxSize) {
  }
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req.key);
  if (record != null && !record.isValid(now)) {
    markAsRemoved(record);
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (record != null && record.isActive() && record.isValid(now) && record.getValue() != null) {
      req.clearForResponse();
      req.response=record.getValue();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (record == null || !record.isActive() || !record.isValid(now) || record.getValue() == null) {
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (record == null || !record.isActive() || !record.isValid(now)) {
      req.response=Boolean.FALSE;
      return;
    }
    MultiData multiData=(MultiData)toObject(req.value);
    if (multiData == null || multiData.size() != 2) {
      throw new RuntimeException(""String_Node_Str"" + multiData);
    }
    Data expectedOldValue=multiData.getData(0);
    req.value=multiData.getData(1);
    if (!record.getValue().equals(expectedOldValue)) {
      req.response=Boolean.FALSE;
      return;
    }
  }
  Data oldValue=null;
  Op op=UPDATE;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    mapRecords.put(req.key,record);
    op=CREATE;
  }
 else {
    if (!record.isActive()) {
      op=CREATE;
    }
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValue() : null;
    record.setValue(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0) {
    record.setExpirationTime(req.ttl);
    ttlPerRecord=true;
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_ADDED,record);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_UPDATED,record);
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateStats(op,record,true,oldValue);
  updateIndexes(record);
  markAsDirty(record);
  req.clearForResponse();
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}","public void put(Request req){
  long now=System.currentTimeMillis();
  if (mapRecords.size() >= maxSize) {
  }
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req.key);
  if (record != null && !record.isValid(now)) {
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (record != null && record.isActive() && record.isValid(now) && record.getValue() != null) {
      req.clearForResponse();
      req.response=record.getValue();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (record == null || !record.isActive() || !record.isValid(now) || record.getValue() == null) {
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (record == null || !record.isActive() || !record.isValid(now)) {
      req.response=Boolean.FALSE;
      return;
    }
    MultiData multiData=(MultiData)toObject(req.value);
    if (multiData == null || multiData.size() != 2) {
      throw new RuntimeException(""String_Node_Str"" + multiData);
    }
    Data expectedOldValue=multiData.getData(0);
    req.value=multiData.getData(1);
    if (!record.getValue().equals(expectedOldValue)) {
      req.response=Boolean.FALSE;
      return;
    }
  }
  Data oldValue=null;
  Op op=UPDATE;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    mapRecords.put(req.key,record);
    op=CREATE;
  }
 else {
    if (!record.isActive()) {
      op=CREATE;
    }
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValue() : null;
    record.setValue(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0) {
    record.setExpirationTime(req.ttl);
    ttlPerRecord=true;
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_ADDED,record);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_UPDATED,record);
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateStats(op,record,true,oldValue);
  updateIndexes(record);
  markAsDirty(record);
  req.clearForResponse();
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}",0.9944841675178754
50376,"void resetLocalMapStats(Map<Address,Integer> distances){
  long now=System.currentTimeMillis();
  int ownedEntryCount=0;
  int backupEntryCount=0;
  int markedAsRemovedEntryCount=0;
  int ownedEntryMemoryCost=0;
  int backupEntryMemoryCost=0;
  int markedAsRemovedMemoryCost=0;
  int hits=0;
  int lockedEntryCount=0;
  int lockWaitCount=0;
  ClusterImpl clusterImpl=node.getClusterImpl();
  for (  Record record : mapRecords.values()) {
    if (!record.isActive() || !record.isValid(now)) {
      markedAsRemovedEntryCount++;
      markedAsRemovedMemoryCost+=record.getCost();
    }
 else {
      Block block=concurrentMapManager.getOrCreateBlock(record.getBlockId());
      boolean owned=thisAddress.equals(block.getOwner());
      if (owned) {
        ownedEntryCount+=record.valueCount();
        ownedEntryMemoryCost+=record.getCost();
        localMapStats.setLastAccessTime(record.getLastAccessTime());
        localMapStats.setLastUpdateTime(record.getLastUpdateTime());
        hits+=record.getHits();
        if (record.isLocked()) {
          lockedEntryCount++;
          lockWaitCount+=record.getScheduledActionCount();
        }
      }
 else {
        boolean unknown=false;
        Address eventualOwner=(block.isMigrating()) ? block.getMigrationAddress() : block.getOwner();
        if (!thisAddress.equals(eventualOwner)) {
          Integer distance=distances.get(eventualOwner);
          if (distance != null && distance > getBackupCount()) {
            unknown=true;
          }
        }
        if (unknown) {
          markedAsRemovedEntryCount++;
          markedAsRemovedMemoryCost+=record.getCost();
          markAsRemoved(record);
        }
 else {
          backupEntryCount+=record.valueCount();
          backupEntryMemoryCost+=record.getCost();
        }
      }
    }
  }
  localMapStats.setMarkedAsRemovedEntryCount(markedAsRemovedEntryCount);
  localMapStats.setMarkedAsRemovedMemoryCost(markedAsRemovedMemoryCost);
  localMapStats.setLockWaitCount(lockWaitCount);
  localMapStats.setLockedEntryCount(lockedEntryCount);
  localMapStats.setHits(hits);
  localMapStats.setOwnedEntryCount(ownedEntryCount);
  localMapStats.setBackupEntryCount(backupEntryCount);
  localMapStats.setOwnedEntryMemoryCost(ownedEntryMemoryCost);
  localMapStats.setBackupEntryMemoryCost(backupEntryMemoryCost);
  localMapStats.setLastEvictionTime(clusterImpl.getClusterTimeFor(lastEvictionTime));
  localMapStats.setCreationTime(clusterImpl.getClusterTimeFor(creationTime));
}","void resetLocalMapStats(Map<Address,Integer> distances){
  long now=System.currentTimeMillis();
  int ownedEntryCount=0;
  int backupEntryCount=0;
  int markedAsRemovedEntryCount=0;
  int ownedEntryMemoryCost=0;
  int backupEntryMemoryCost=0;
  int markedAsRemovedMemoryCost=0;
  int hits=0;
  int lockedEntryCount=0;
  int lockWaitCount=0;
  ClusterImpl clusterImpl=node.getClusterImpl();
  for (  Record record : mapRecords.values()) {
    Block block=concurrentMapManager.getOrCreateBlock(record.getBlockId());
    boolean owned=thisAddress.equals(block.getOwner());
    if (owned) {
      if (!record.isActive() || !record.isValid(now)) {
        markedAsRemovedEntryCount++;
        markedAsRemovedMemoryCost+=record.getCost();
      }
 else {
        ownedEntryCount+=record.valueCount();
        ownedEntryMemoryCost+=record.getCost();
        localMapStats.setLastAccessTime(record.getLastAccessTime());
        localMapStats.setLastUpdateTime(record.getLastUpdateTime());
        hits+=record.getHits();
        if (record.isLocked()) {
          lockedEntryCount++;
          lockWaitCount+=record.getScheduledActionCount();
        }
      }
    }
 else {
      boolean unknown=false;
      Address eventualOwner=(block.isMigrating()) ? block.getMigrationAddress() : block.getOwner();
      if (!thisAddress.equals(eventualOwner)) {
        Integer distance=distances.get(eventualOwner);
        if (distance != null && distance > getBackupCount()) {
          unknown=true;
        }
      }
      backupEntryCount+=record.valueCount();
      backupEntryMemoryCost+=record.getCost();
    }
  }
  localMapStats.setMarkedAsRemovedEntryCount(markedAsRemovedEntryCount);
  localMapStats.setMarkedAsRemovedMemoryCost(markedAsRemovedMemoryCost);
  localMapStats.setLockWaitCount(lockWaitCount);
  localMapStats.setLockedEntryCount(lockedEntryCount);
  localMapStats.setHits(hits);
  localMapStats.setOwnedEntryCount(ownedEntryCount);
  localMapStats.setBackupEntryCount(backupEntryCount);
  localMapStats.setOwnedEntryMemoryCost(ownedEntryMemoryCost);
  localMapStats.setBackupEntryMemoryCost(backupEntryMemoryCost);
  localMapStats.setLastEvictionTime(clusterImpl.getClusterTimeFor(lastEvictionTime));
  localMapStats.setCreationTime(clusterImpl.getClusterTimeFor(creationTime));
}",0.3687735454164922
50377,"public LocalMapStatsImpl getLocalMapStats(){
  ClusterImpl clusterImpl=node.getClusterImpl();
  LocalMapStatsImpl stats=new LocalMapStatsImpl();
  stats.setLockWaitCount(localMapStats.getLockWaitCount());
  stats.setLockedEntryCount(localMapStats.getLockedEntryCount());
  stats.setHits(localMapStats.getHits());
  stats.setOwnedEntryCount(localMapStats.getOwnedEntryCount());
  stats.setBackupEntryCount(localMapStats.getBackupEntryCount());
  stats.setOwnedEntryMemoryCost(localMapStats.getOwnedEntryMemoryCost());
  stats.setBackupEntryMemoryCost(localMapStats.getBackupEntryMemoryCost());
  stats.setLastEvictionTime(clusterImpl.getClusterTimeFor(lastEvictionTime));
  stats.setCreationTime(clusterImpl.getClusterTimeFor(creationTime));
  stats.setLastAccessTime(clusterImpl.getClusterTimeFor(localMapStats.getLastAccessTime()));
  stats.setLastUpdateTime(clusterImpl.getClusterTimeFor(localMapStats.getLastUpdateTime()));
  return stats;
}","public LocalMapStatsImpl getLocalMapStats(){
  LocalMapStatsImpl stats=new LocalMapStatsImpl();
  createStats(stats);
  return stats;
}",0.2279888785912882
50378,"public LocalMapStatsImpl getLocalMapStats(String name){
  final CMap cmap=getMap(name);
  if (cmap == null) {
    return new LocalMapStatsImpl();
  }
  int tryCount=0;
  while (tryCount++ < 10 && partitionManager.partitionServiceImpl.isMigrating()) {
    try {
      Thread.sleep(500);
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
  }
  final BlockingQueue responseQ=ResponseQueueFactory.newResponseQueue();
  enqueueAndReturn(new Processable(){
    public void process(){
      responseQ.offer(cmap.getLocalMapStats());
    }
  }
);
  try {
    return (LocalMapStatsImpl)responseQ.take();
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
}","public LocalMapStatsImpl getLocalMapStats(String name){
  final CMap cmap=getMap(name);
  if (cmap == null) {
    return new LocalMapStatsImpl();
  }
  return cmap.getLocalMapStats();
}",0.4124860646599777
50379,"public FactoryImpl(String name,Config config){
  this.name=name;
  node=new Node(this,config);
  final ILogger logger=node.getLogger(FactoryImpl.class.getName());
  transactionFactory=new TransactionFactory(this);
  hazelcastInstanceProxy=new HazelcastInstanceProxy(this);
  node.start();
  locksMapProxy=new MProxyImpl(""String_Node_Str"",this);
  idGeneratorMapProxy=new MProxyImpl(""String_Node_Str"",this);
  globalProxies=new MProxyImpl(""String_Node_Str"",this);
  globalProxies.addEntryListener(new EntryListener(){
    public void entryAdded(    EntryEvent event){
      final ProxyKey proxyKey=(ProxyKey)event.getKey();
      if (!proxies.containsKey(proxyKey)) {
        logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
        node.clusterService.enqueueAndReturn(new Processable(){
          public void process(){
            createProxy(proxyKey);
          }
        }
);
      }
    }
    public void entryRemoved(    EntryEvent event){
      final ProxyKey proxyKey=(ProxyKey)event.getKey();
      if (proxies.containsKey(proxyKey)) {
        logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
        node.clusterService.enqueueAndReturn(new Processable(){
          public void process(){
            destroyProxy(proxyKey);
          }
        }
);
      }
    }
    public void entryUpdated(    EntryEvent event){
      logger.log(Level.FINEST,""String_Node_Str"" + event.getKey());
    }
    public void entryEvicted(    EntryEvent event){
      logger.log(Level.FINEST,""String_Node_Str"" + event.getKey());
    }
  }
,false);
  if (node.getClusterImpl().getMembers().size() > 1) {
    Set<ProxyKey> proxyKeys=globalProxies.allKeys();
    for (    final ProxyKey proxyKey : proxyKeys) {
      if (!proxies.containsKey(proxyKey)) {
        node.clusterService.enqueueAndReturn(new Processable(){
          public void process(){
            createProxy(proxyKey);
          }
        }
);
      }
    }
  }
}","public FactoryImpl(String name,Config config){
  this.name=name;
  node=new Node(this,config);
  globalProxies=new MProxyImpl(""String_Node_Str"",this);
  final ILogger logger=node.getLogger(FactoryImpl.class.getName());
  transactionFactory=new TransactionFactory(this);
  hazelcastInstanceProxy=new HazelcastInstanceProxy(this);
  locksMapProxy=new MProxyImpl(""String_Node_Str"",this);
  idGeneratorMapProxy=new MProxyImpl(""String_Node_Str"",this);
  node.start();
  globalProxies.addEntryListener(new EntryListener(){
    public void entryAdded(    EntryEvent event){
      final ProxyKey proxyKey=(ProxyKey)event.getKey();
      if (!proxies.containsKey(proxyKey)) {
        logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
        node.clusterService.enqueueAndReturn(new Processable(){
          public void process(){
            createProxy(proxyKey);
          }
        }
);
      }
    }
    public void entryRemoved(    EntryEvent event){
      final ProxyKey proxyKey=(ProxyKey)event.getKey();
      if (proxies.containsKey(proxyKey)) {
        logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
        node.clusterService.enqueueAndReturn(new Processable(){
          public void process(){
            destroyProxy(proxyKey);
          }
        }
);
      }
    }
    public void entryUpdated(    EntryEvent event){
      logger.log(Level.FINEST,""String_Node_Str"" + event.getKey());
    }
    public void entryEvicted(    EntryEvent event){
      logger.log(Level.FINEST,""String_Node_Str"" + event.getKey());
    }
  }
,false);
  if (node.getClusterImpl().getMembers().size() > 1) {
    Set<ProxyKey> proxyKeys=globalProxies.allKeys();
    for (    final ProxyKey proxyKey : proxyKeys) {
      if (!proxies.containsKey(proxyKey)) {
        node.clusterService.enqueueAndReturn(new Processable(){
          public void process(){
            createProxy(proxyKey);
          }
        }
);
      }
    }
  }
}",0.9652849740932644
50380,"public Node(FactoryImpl factory,Config config){
  this.threadGroup=new ThreadGroup(factory.getName());
  this.factory=factory;
  this.config=config;
  this.groupProperties=new GroupProperties(config);
  this.superClient=config.isSuperClient();
  this.localNodeType=(superClient) ? NodeType.SUPER_CLIENT : NodeType.MEMBER;
  String version=""String_Node_Str"";
  String build=""String_Node_Str"";
  try {
    InputStream inRuntimeProperties=Node.class.getClassLoader().getResourceAsStream(""String_Node_Str"");
    if (inRuntimeProperties != null) {
      Properties runtimeProperties=new Properties();
      runtimeProperties.load(inRuntimeProperties);
      version=runtimeProperties.getProperty(""String_Node_Str"");
      build=runtimeProperties.getProperty(""String_Node_Str"");
    }
  }
 catch (  Exception ignored) {
  }
  int tmpBuildNumber=0;
  try {
    tmpBuildNumber=Integer.getInteger(""String_Node_Str"",-1);
    if (tmpBuildNumber == -1) {
      tmpBuildNumber=Integer.parseInt(build);
    }
  }
 catch (  Exception ignored) {
  }
  buildNumber=tmpBuildNumber;
  ServerSocketChannel serverSocketChannel;
  Address localAddress=null;
  try {
    final String preferIPv4Stack=System.getProperty(""String_Node_Str"");
    final String preferIPv6Address=System.getProperty(""String_Node_Str"");
    if (preferIPv6Address == null && preferIPv4Stack == null) {
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
    serverSocketChannel=ServerSocketChannel.open();
    AddressPicker addressPicker=new AddressPicker(this,serverSocketChannel);
    localAddress=addressPicker.pickAddress();
    localAddress.setThisAddress(true);
  }
 catch (  Throwable e) {
    throw new RuntimeException(e);
  }
  address=localAddress;
  localMember=new MemberImpl(address,true,localNodeType);
  packetPool=new NoneStrictObjectPool<Packet>(2000){
    @Override public void onRelease(    Packet packet){
      if (packet.released) {
        throw new RuntimeException(""String_Node_Str"");
      }
      packet.released=true;
    }
    @Override public void onObtain(    Packet packet){
      packet.reset();
      packet.released=false;
    }
    public Packet createNew(){
      return new Packet();
    }
  }
;
  clusterImpl=new ClusterImpl(this,localMember);
  baseVariables=new NodeBaseVariables(address,localMember);
  this.loggingService=new LoggingServiceImpl(config.getGroupConfig().getName(),localMember);
  this.logger=loggingService.getLogger(Node.class.getName());
  clusterService=new ClusterService(this);
  clusterService.start();
  inSelector=new InSelector(this,serverSocketChannel);
  outSelector=new OutSelector(this);
  connectionManager=new ConnectionManager(this);
  clientService=new ClientService(this);
  clusterManager=new ClusterManager(this);
  executorManager=new ExecutorManager(this);
  concurrentMapManager=new ConcurrentMapManager(this);
  blockingQueueManager=new BlockingQueueManager(this);
  listenerManager=new ListenerManager(this);
  topicManager=new TopicManager(this);
  clusterManager.addMember(localMember);
  textCommandService=new TextCommandServiceImpl(this);
  ILogger systemLogger=getLogger(""String_Node_Str"");
  systemLogger.log(Level.INFO,""String_Node_Str"" + version + ""String_Node_Str""+ build+ ""String_Node_Str""+ address);
  systemLogger.log(Level.INFO,""String_Node_Str"");
  Join join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(join.getMulticastConfig().getMulticastPort()));
      multicastSocket.setTimeToLive(32);
      multicastSocket.setInterface(address.getInetAddress());
      multicastSocket.setReceiveBufferSize(1024);
      multicastSocket.setSendBufferSize(1024);
      multicastSocket.joinGroup(InetAddress.getByName(join.getMulticastConfig().getMulticastGroup()));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
  this.multicastService=mcService;
}","public Node(FactoryImpl factory,Config config){
  this.threadGroup=new ThreadGroup(factory.getName());
  this.factory=factory;
  this.config=config;
  this.groupProperties=new GroupProperties(config);
  this.superClient=config.isSuperClient();
  this.localNodeType=(superClient) ? NodeType.SUPER_CLIENT : NodeType.MEMBER;
  String version=""String_Node_Str"";
  String build=""String_Node_Str"";
  try {
    InputStream inRuntimeProperties=Node.class.getClassLoader().getResourceAsStream(""String_Node_Str"");
    if (inRuntimeProperties != null) {
      Properties runtimeProperties=new Properties();
      runtimeProperties.load(inRuntimeProperties);
      version=runtimeProperties.getProperty(""String_Node_Str"");
      build=runtimeProperties.getProperty(""String_Node_Str"");
    }
  }
 catch (  Exception ignored) {
  }
  int tmpBuildNumber=0;
  try {
    tmpBuildNumber=Integer.getInteger(""String_Node_Str"",-1);
    if (tmpBuildNumber == -1) {
      tmpBuildNumber=Integer.parseInt(build);
    }
  }
 catch (  Exception ignored) {
  }
  buildNumber=tmpBuildNumber;
  ServerSocketChannel serverSocketChannel;
  Address localAddress=null;
  try {
    final String preferIPv4Stack=System.getProperty(""String_Node_Str"");
    final String preferIPv6Address=System.getProperty(""String_Node_Str"");
    if (preferIPv6Address == null && preferIPv4Stack == null) {
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
    serverSocketChannel=ServerSocketChannel.open();
    AddressPicker addressPicker=new AddressPicker(this,serverSocketChannel);
    localAddress=addressPicker.pickAddress();
    localAddress.setThisAddress(true);
  }
 catch (  Throwable e) {
    throw new RuntimeException(e);
  }
  address=localAddress;
  localMember=new MemberImpl(address,true,localNodeType);
  packetPool=new NoneStrictObjectPool<Packet>(2000){
    @Override public void onRelease(    Packet packet){
      if (packet.released) {
        throw new RuntimeException(""String_Node_Str"");
      }
      packet.released=true;
    }
    @Override public void onObtain(    Packet packet){
      packet.reset();
      packet.released=false;
    }
    public Packet createNew(){
      return new Packet();
    }
  }
;
  clusterImpl=new ClusterImpl(this,localMember);
  baseVariables=new NodeBaseVariables(address,localMember);
  this.loggingService=new LoggingServiceImpl(config.getGroupConfig().getName(),localMember);
  this.logger=loggingService.getLogger(Node.class.getName());
  clusterService=new ClusterService(this);
  clusterService.start();
  inSelector=new InSelector(this,serverSocketChannel);
  outSelector=new OutSelector(this);
  connectionManager=new ConnectionManager(this);
  clientService=new ClientService(this);
  clusterManager=new ClusterManager(this);
  executorManager=new ExecutorManager(this);
  concurrentMapManager=new ConcurrentMapManager(this);
  blockingQueueManager=new BlockingQueueManager(this);
  listenerManager=new ListenerManager(this);
  topicManager=new TopicManager(this);
  clusterService.enqueueAndReturn(new Processable(){
    public void process(){
      clusterManager.addMember(getThisAddress(),NodeType.MEMBER);
    }
  }
);
  textCommandService=new TextCommandServiceImpl(this);
  ILogger systemLogger=getLogger(""String_Node_Str"");
  systemLogger.log(Level.INFO,""String_Node_Str"" + version + ""String_Node_Str""+ build+ ""String_Node_Str""+ address);
  systemLogger.log(Level.INFO,""String_Node_Str"");
  Join join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(join.getMulticastConfig().getMulticastPort()));
      multicastSocket.setTimeToLive(32);
      multicastSocket.setInterface(address.getInetAddress());
      multicastSocket.setReceiveBufferSize(1024);
      multicastSocket.setSendBufferSize(1024);
      multicastSocket.joinGroup(InetAddress.getByName(join.getMulticastConfig().getMulticastGroup()));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
  this.multicastService=mcService;
}",0.9838558727187646
50381,"public static Object readObject(DataInput in) throws IOException {
  byte type=in.readByte();
  if (type == 0) {
    return null;
  }
 else   if (type == 1) {
    return in.readLong();
  }
 else   if (type == 2) {
    return in.readInt();
  }
 else   if (type == 3) {
    return in.readUTF();
  }
 else   if (type == 4) {
    return in.readDouble();
  }
 else   if (type == 5) {
    return in.readFloat();
  }
 else   if (type == 6) {
    return in.readBoolean();
  }
 else   if (type == 7) {
    DataSerializable ds;
    try {
      ds=(DataSerializable)Serializer.classForName(in.readUTF()).newInstance();
    }
 catch (    Throwable e) {
      throw new IOException(e.getMessage());
    }
    ds.readData(in);
    return ds;
  }
 else   if (type == 8) {
    return new Date(in.readLong());
  }
 else   if (type == 9) {
    int len=in.readInt();
    byte[] buf=new byte[len];
    in.readFully(buf);
    ObjectInputStream oin=Serializer.newObjectInputStream(new ByteArrayInputStream(buf));
    try {
      return oin.readObject();
    }
 catch (    ClassNotFoundException e) {
      e.printStackTrace();
    }
    oin.close();
  }
 else {
    throw new IOException(""String_Node_Str"" + type);
  }
  return null;
}","public static Object readObject(DataInput in) throws IOException {
  byte type=in.readByte();
  if (type == 0) {
    return null;
  }
 else   if (type == 1) {
    return in.readLong();
  }
 else   if (type == 2) {
    return in.readInt();
  }
 else   if (type == 3) {
    return in.readUTF();
  }
 else   if (type == 4) {
    return in.readDouble();
  }
 else   if (type == 5) {
    return in.readFloat();
  }
 else   if (type == 6) {
    return in.readBoolean();
  }
 else   if (type == 7) {
    DataSerializable ds;
    try {
      String className=in.readUTF();
      ds=(DataSerializable)Serializer.newInstance(Serializer.classForName(className));
    }
 catch (    Throwable e) {
      throw new IOException(e.getMessage());
    }
    ds.readData(in);
    return ds;
  }
 else   if (type == 8) {
    return new Date(in.readLong());
  }
 else   if (type == 9) {
    int len=in.readInt();
    byte[] buf=new byte[len];
    in.readFully(buf);
    ObjectInputStream oin=Serializer.newObjectInputStream(new ByteArrayInputStream(buf));
    try {
      return oin.readObject();
    }
 catch (    ClassNotFoundException e) {
      e.printStackTrace();
    }
    oin.close();
  }
 else {
    throw new IOException(""String_Node_Str"" + type);
  }
  return null;
}",0.9489878542510122
50382,"void markAsActive(Record record){
  if (!record.isActive()) {
    record.setActive();
    record.setCreationTime(System.currentTimeMillis());
  }
}","void markAsActive(Record record){
  long now=System.currentTimeMillis();
  if (!record.isActive() || !record.isValid(now)) {
    record.setActive();
    record.setCreationTime(now);
    record.setExpirationTime(ttl);
  }
}",0.3794037940379404
50383,"public void stop(){
  if (!started)   return;
  parallelExecutorService.shutdown();
  Collection<NamedExecutorService> executors=mapExecutors.values();
  for (  NamedExecutorService namedExecutorService : executors) {
    namedExecutorService.stop();
  }
  started=false;
}","public void stop(){
  if (!started)   return;
  parallelExecutorService.shutdown();
  Collection<NamedExecutorService> executors=mapExecutors.values();
  for (  NamedExecutorService namedExecutorService : executors) {
    namedExecutorService.stop();
  }
  threadPoolExecutor.shutdownNow();
  try {
    threadPoolExecutor.awaitTermination(3,TimeUnit.SECONDS);
  }
 catch (  InterruptedException ignored) {
  }
  started=false;
}",0.7788873038516405
50384,"public void process(){
  Block block=concurrentMapManager.blocks[partitionId];
  if (block == null) {
    block=concurrentMapManager.getOrCreateBlock(partitionId);
  }
  MemberImpl memberOwner=null;
  if (block.getOwner() != null) {
    if (concurrentMapManager.thisAddress.equals(block.getOwner())) {
      memberOwner=concurrentMapManager.thisMember;
    }
 else {
      memberOwner=concurrentMapManager.getMember(block.getOwner());
    }
  }
  responseQ.offer(new PartitionReal(block.getBlockId(),memberOwner,null));
}","public void process(){
  Block block=concurrentMapManager.blocks[partitionId];
  if (block == null) {
    block=concurrentMapManager.getOrCreateBlock(partitionId);
  }
  MemberImpl memberOwner=null;
  if (block.getOwner() != null) {
    if (concurrentMapManager.thisAddress.equals(block.getOwner())) {
      memberOwner=concurrentMapManager.thisMember;
    }
 else {
      memberOwner=concurrentMapManager.getMember(block.getOwner());
    }
  }
  responseQ.offer(new PartitionReal(partitionId,memberOwner,null));
}",0.9758454106280192
50385,"public PartitionProxy getPartition(final int partitionId){
  PartitionProxy partition=mapPartitions.get(partitionId);
  if (partition != null && partition.getOwner() != null)   return partition;
  final BlockingQueue<PartitionReal> responseQ=ResponseQueueFactory.newResponseQueue();
  concurrentMapManager.enqueueAndReturn(new Processable(){
    public void process(){
      Block block=concurrentMapManager.blocks[partitionId];
      if (block == null) {
        block=concurrentMapManager.getOrCreateBlock(partitionId);
      }
      MemberImpl memberOwner=null;
      if (block.getOwner() != null) {
        if (concurrentMapManager.thisAddress.equals(block.getOwner())) {
          memberOwner=concurrentMapManager.thisMember;
        }
 else {
          memberOwner=concurrentMapManager.getMember(block.getOwner());
        }
      }
      responseQ.offer(new PartitionReal(block.getBlockId(),memberOwner,null));
    }
  }
);
  partition=new PartitionProxy(partitionId);
  try {
    PartitionReal partitionReal=responseQ.take();
    mapRealPartitions.put(partitionId,partitionReal);
    PartitionProxy oldPartitionProxy=mapPartitions.putIfAbsent(partitionId,partition);
    if (oldPartitionProxy != null) {
      return oldPartitionProxy;
    }
  }
 catch (  InterruptedException ignored) {
  }
  return partition;
}","public PartitionProxy getPartition(final int partitionId){
  PartitionProxy partition=mapPartitions.get(partitionId);
  if (partition != null && partition.getOwner() != null)   return partition;
  final BlockingQueue<PartitionReal> responseQ=ResponseQueueFactory.newResponseQueue();
  concurrentMapManager.enqueueAndReturn(new Processable(){
    public void process(){
      Block block=concurrentMapManager.blocks[partitionId];
      if (block == null) {
        block=concurrentMapManager.getOrCreateBlock(partitionId);
      }
      MemberImpl memberOwner=null;
      if (block.getOwner() != null) {
        if (concurrentMapManager.thisAddress.equals(block.getOwner())) {
          memberOwner=concurrentMapManager.thisMember;
        }
 else {
          memberOwner=concurrentMapManager.getMember(block.getOwner());
        }
      }
      responseQ.offer(new PartitionReal(partitionId,memberOwner,null));
    }
  }
);
  partition=new PartitionProxy(partitionId);
  try {
    PartitionReal partitionReal=responseQ.take();
    mapRealPartitions.put(partitionId,partitionReal);
    PartitionProxy oldPartitionProxy=mapPartitions.putIfAbsent(partitionId,partition);
    if (oldPartitionProxy != null) {
      return oldPartitionProxy;
    }
  }
 catch (  InterruptedException ignored) {
  }
  return partition;
}",0.9905123339658444
50386,"Map<Address,List<Block>> getCurrentMemberBlocks(){
  Map<Address,List<Block>> addressBlocks=new HashMap<Address,List<Block>>();
  List<MemberImpl> lsMembers=concurrentMapManager.getMembers();
  for (  MemberImpl member : lsMembers) {
    if (!member.isSuperClient()) {
      addressBlocks.put(member.getAddress(),new ArrayList<Block>());
    }
  }
  if (addressBlocks.size() > 0) {
    for (    Block blockReal : blocks) {
      if (blockReal != null && !blockReal.isMigrating()) {
        List<Block> ownedBlocks=addressBlocks.get(blockReal.getOwner());
        ownedBlocks.add(new Block(blockReal));
      }
    }
  }
  return addressBlocks;
}","Map<Address,List<Block>> getCurrentMemberBlocks(){
  Map<Address,List<Block>> addressBlocks=new HashMap<Address,List<Block>>();
  List<MemberImpl> lsMembers=concurrentMapManager.getMembers();
  for (  MemberImpl member : lsMembers) {
    if (!member.isSuperClient()) {
      addressBlocks.put(member.getAddress(),new ArrayList<Block>());
    }
  }
  if (addressBlocks.size() > 0) {
    for (    Block blockReal : blocks) {
      if (blockReal != null && !blockReal.isMigrating()) {
        List<Block> ownedBlocks=addressBlocks.get(blockReal.getOwner());
        if (ownedBlocks != null) {
          ownedBlocks.add(new Block(blockReal));
        }
      }
    }
  }
  return addressBlocks;
}",0.9543754674644728
50387,"public Object waitAndGetResult(){
  while (true) {
    try {
      Object obj=responses.poll(5,TimeUnit.SECONDS);
      if (obj != null) {
        return obj;
      }
 else       if (node.factory.restarted) {
        throw new RuntimeException();
      }
 else       if (!node.isActive()) {
        throw new IllegalStateException(""String_Node_Str"");
      }
    }
 catch (    InterruptedException e) {
      if (node.factory.restarted) {
        throw new RuntimeException();
      }
 else {
        throw new RuntimeInterruptedException();
      }
    }
  }
}","public Object waitAndGetResult(){
  while (true) {
    try {
      Object obj=responses.poll(5,TimeUnit.SECONDS);
      if (obj != null) {
        return obj;
      }
      node.checkNodeState();
    }
 catch (    InterruptedException e) {
      if (node.factory.restarted) {
        throw new RuntimeException();
      }
 else {
        throw new RuntimeInterruptedException();
      }
    }
  }
}",0.4546402502606882
50388,"T call(){
  try {
    if (!node.isActive()) {
      throw new RuntimeException();
    }
    onCall();
    TargetAwareOp localCall=createNewTargetAwareOp(thisAddress);
    localCall.doOp();
    Object result=localCall.getResultAsObject();
    if (result == OBJECT_REDO) {
      onRedo();
      Thread.sleep(1000);
      return call();
    }
    if (onResponse(result)) {
      Set<Member> members=node.getClusterImpl().getMembers();
      List<TargetAwareOp> lsCalls=new ArrayList<TargetAwareOp>();
      for (      Member member : members) {
        if (!member.localMember()) {
          MemberImpl cMember=(MemberImpl)member;
          TargetAwareOp targetAwareOp=createNewTargetAwareOp(cMember.getAddress());
          targetAwareOp.doOp();
          lsCalls.add(targetAwareOp);
        }
      }
      for (      TargetAwareOp call : lsCalls) {
        result=call.getResultAsObject();
        if (result == OBJECT_REDO) {
          onRedo();
          Thread.sleep(1000);
          return call();
        }
 else {
          if (!onResponse(result)) {
            break;
          }
        }
      }
      onComplete();
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  return (T)returnResult();
}","T call(){
  try {
    node.checkNodeState();
    onCall();
    TargetAwareOp localCall=createNewTargetAwareOp(thisAddress);
    localCall.doOp();
    Object result=localCall.getResultAsObject();
    if (result == OBJECT_REDO) {
      onRedo();
      Thread.sleep(1000);
      return call();
    }
    if (onResponse(result)) {
      Set<Member> members=node.getClusterImpl().getMembers();
      List<TargetAwareOp> lsCalls=new ArrayList<TargetAwareOp>();
      for (      Member member : members) {
        if (!member.localMember()) {
          MemberImpl cMember=(MemberImpl)member;
          TargetAwareOp targetAwareOp=createNewTargetAwareOp(cMember.getAddress());
          targetAwareOp.doOp();
          lsCalls.add(targetAwareOp);
        }
      }
      for (      TargetAwareOp call : lsCalls) {
        result=call.getResultAsObject();
        if (result == OBJECT_REDO) {
          onRedo();
          Thread.sleep(1000);
          return call();
        }
 else {
          if (!onResponse(result)) {
            break;
          }
        }
      }
      onComplete();
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  return (T)returnResult();
}",0.969224456298728
50389,"public EntryObject key(){
  Expression expression=new Expression(){
    public Object getValue(    Object obj){
      MapEntry entry=(MapEntry)obj;
      return entry.getKey();
    }
  }
;
  qb.exp=expression;
  return this;
}","public EntryObject key(){
  Expression expression=new EntryKeyObject();
  qb.exp=expression;
  return this;
}",0.6208955223880597
50390,"@Override public String toString(){
  return ""String_Node_Str"" + getSource() + ""String_Node_Str""+ getKey()+ ""String_Node_Str""+ getValue()+ ""String_Node_Str""+ entryEventType;
}","@Override public String toString(){
  return ""String_Node_Str"" + getSource() + ""String_Node_Str""+ getKey()+ ""String_Node_Str""+ getValue()+ ""String_Node_Str""+ entryEventType+ ""String_Node_Str""+ member;
}",0.9283819628647216
50391,"void enqueueEvent(final int eventType,final String name,final Data eventKey,final Data eventValue,final Address from){
  Member member=getMember(from);
  if (member == null) {
    member=new MemberImpl(from,thisAddress.equals(from));
  }
  final EventTask eventTask=new EventTask(member,eventType,name,eventKey,eventValue);
  int hash;
  if (eventKey != null) {
    hash=eventKey.hashCode();
  }
 else {
    hash=hashTwo(from.hashCode(),name.hashCode());
  }
  node.executorManager.getEventExecutorService().executeOrderedRunnable(hash,eventTask);
}","void enqueueEvent(int eventType,String name,Data eventKey,Data eventValue,Address from){
  try {
    Member member=getMember(from);
    if (member == null) {
      member=new MemberImpl(from,thisAddress.equals(from));
    }
    final EventTask eventTask=new EventTask(member,eventType,name,eventKey,eventValue);
    int hash;
    if (eventKey != null) {
      hash=eventKey.hashCode();
    }
 else {
      hash=hashTwo(from.hashCode(),name.hashCode());
    }
    node.executorManager.getEventExecutorService().executeOrderedRunnable(hash,eventTask);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.8791018998272885
50392,"public EventTask(final Member from,final int eventType,final String name,final Data dataKey,final Data dataValue){
  super(name,from,eventType,null,null);
  this.dataKey=dataKey;
  this.dataValue=dataValue;
}","public EventTask(Member from,int eventType,String name,Data dataKey,Data dataValue){
  super(name,from,eventType,null,null);
  this.dataKey=dataKey;
  this.dataValue=dataValue;
}",0.922279792746114
50393,"public void run(){
  try {
    node.listenerManager.callListeners(this);
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
}","public void run(){
  try {
    node.listenerManager.callListeners(EventTask.this);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9428571428571428
50394,"void fireMapEvent(final Map<Address,Boolean> mapListeners,final String name,final int eventType,final Data key,final Data value,Map<Address,Boolean> keyListeners){
  try {
    Map<Address,Boolean> mapTargetListeners=null;
    if (keyListeners != null) {
      mapTargetListeners=new HashMap<Address,Boolean>(keyListeners);
    }
    if (mapListeners != null && mapListeners.size() > 0) {
      if (mapTargetListeners == null) {
        mapTargetListeners=new HashMap<Address,Boolean>(mapListeners);
      }
 else {
        final Set<Map.Entry<Address,Boolean>> entries=mapListeners.entrySet();
        for (        final Map.Entry<Address,Boolean> entry : entries) {
          if (mapTargetListeners.containsKey(entry.getKey())) {
            if (entry.getValue()) {
              mapTargetListeners.put(entry.getKey(),entry.getValue());
            }
          }
 else           mapTargetListeners.put(entry.getKey(),entry.getValue());
        }
      }
    }
    if (mapTargetListeners == null || mapTargetListeners.size() == 0) {
      return;
    }
    sendEvents(eventType,name,key,value,mapTargetListeners);
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
}","void fireMapEvent(final Map<Address,Boolean> mapListeners,final String name,final int eventType,final Data key,final Data value,Map<Address,Boolean> keyListeners,Address callerAddress){
  try {
    Map<Address,Boolean> mapTargetListeners=null;
    if (keyListeners != null) {
      mapTargetListeners=new HashMap<Address,Boolean>(keyListeners);
    }
    if (mapListeners != null && mapListeners.size() > 0) {
      if (mapTargetListeners == null) {
        mapTargetListeners=new HashMap<Address,Boolean>(mapListeners);
      }
 else {
        final Set<Map.Entry<Address,Boolean>> entries=mapListeners.entrySet();
        for (        final Map.Entry<Address,Boolean> entry : entries) {
          if (mapTargetListeners.containsKey(entry.getKey())) {
            if (entry.getValue()) {
              mapTargetListeners.put(entry.getKey(),entry.getValue());
            }
          }
 else           mapTargetListeners.put(entry.getKey(),entry.getValue());
        }
      }
    }
    if (mapTargetListeners == null || mapTargetListeners.size() == 0) {
      return;
    }
    sendEvents(eventType,name,key,value,mapTargetListeners,callerAddress);
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
}",0.9849624060150376
50395,"public void sendEvents(final int eventType,final String name,final Data key,final Data value,final Map<Address,Boolean> mapListeners){
  if (mapListeners != null) {
    final Set<Map.Entry<Address,Boolean>> listeners=mapListeners.entrySet();
    for (    final Map.Entry<Address,Boolean> listener : listeners) {
      final Address address=listener.getKey();
      final boolean includeValue=listener.getValue();
      if (address.isThisAddress()) {
        enqueueEvent(eventType,name,key,(includeValue) ? value : null,address);
      }
 else {
        final Packet packet=obtainPacket();
        packet.set(name,ClusterOperation.EVENT,key,(includeValue) ? value : null);
        packet.longValue=eventType;
        final boolean sent=send(packet,address);
        if (!sent)         releasePacket(packet);
      }
    }
  }
}","public void sendEvents(int eventType,String name,Data key,Data value,Map<Address,Boolean> mapListeners,Address callerAddress){
  if (mapListeners != null) {
    final Set<Map.Entry<Address,Boolean>> listeners=mapListeners.entrySet();
    for (    final Map.Entry<Address,Boolean> listener : listeners) {
      final Address toAddress=listener.getKey();
      final boolean includeValue=listener.getValue();
      if (toAddress.isThisAddress()) {
        enqueueEvent(eventType,name,key,(includeValue) ? value : null,callerAddress);
      }
 else {
        final Packet packet=obtainPacket();
        packet.set(name,ClusterOperation.EVENT,key,(includeValue) ? value : null);
        packet.lockAddress=callerAddress;
        packet.longValue=eventType;
        final boolean sent=send(packet,toAddress);
        if (!sent)         releasePacket(packet);
      }
    }
  }
}",0.9329411764705884
50396,"int offer(Request req){
  if (req.value == null) {
    throw new RuntimeException(""String_Node_Str"" + req.local);
  }
  if (req.value.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.local);
  }
  try {
    int addIndex=blCurrentPut.add(req.value);
    doFireEntryEvent(true,req.value);
    sendBackup(true,req.caller,req.value,blCurrentPut.blockId,addIndex);
    req.longValue=addIndex;
    if (blCurrentPut.isFull()) {
      fireBlockFullEvent(blCurrentPut);
      blCurrentPut=null;
      setCurrentPut();
    }
    return addIndex;
  }
  finally {
    boolean consumed=false;
    while (!consumed && lsScheduledPollActions.size() > 0) {
      ScheduledAction pollAction=lsScheduledPollActions.remove(0);
      if (!pollAction.expired()) {
        consumed=pollAction.consume();
        node.clusterManager.deregisterScheduledAction(pollAction);
      }
    }
  }
}","int offer(Request req){
  if (req.value == null) {
    throw new RuntimeException(""String_Node_Str"" + req.local);
  }
  if (req.value.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.local);
  }
  try {
    int addIndex=blCurrentPut.add(req.value);
    doFireEntryEvent(true,req.value,req.caller);
    sendBackup(true,req.caller,req.value,blCurrentPut.blockId,addIndex);
    req.longValue=addIndex;
    if (blCurrentPut.isFull()) {
      fireBlockFullEvent(blCurrentPut);
      blCurrentPut=null;
      setCurrentPut();
    }
    return addIndex;
  }
  finally {
    boolean consumed=false;
    while (!consumed && lsScheduledPollActions.size() > 0) {
      ScheduledAction pollAction=lsScheduledPollActions.remove(0);
      if (!pollAction.expired()) {
        consumed=pollAction.consume();
        node.clusterManager.deregisterScheduledAction(pollAction);
      }
    }
  }
}",0.9938513135830072
50397,"final void handleBackup(Packet packet){
  try {
    String name=packet.name;
    int blockId=packet.blockId;
    Q q=getQ(name);
    if (packet.operation == ClusterOperation.BLOCKING_QUEUE_BACKUP_ADD) {
      Data data=packet.getValueData();
      q.doBackup(true,data,blockId,(int)packet.longValue);
    }
 else     if (packet.operation == ClusterOperation.BLOCKING_QUEUE_BACKUP_REMOVE) {
      q.doBackup(false,null,blockId,0);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    releasePacket(packet);
  }
}","final void handleBackup(Packet packet){
  try {
    String name=packet.name;
    int blockId=packet.blockId;
    Q q=getQ(name);
    if (packet.operation == ClusterOperation.BLOCKING_QUEUE_BACKUP_ADD) {
      Data data=packet.getValueData();
      q.doBackup(true,data,blockId,(int)packet.longValue);
    }
 else     if (packet.operation == ClusterOperation.BLOCKING_QUEUE_BACKUP_REMOVE) {
      q.doBackup(false,null,blockId,(int)packet.longValue);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    releasePacket(packet);
  }
}",0.979890310786106
50398,"@Override public void handleNoneRedoResponse(Packet packet){
  if (request.operation == ClusterOperation.BLOCKING_QUEUE_POLL && packet.responseType == Constants.ResponseTypes.RESPONSE_SUCCESS) {
    if (!zeroBackup) {
      if (getPreviousMemberBefore(thisAddress,true,1).getAddress().equals(packet.conn.getEndPoint())) {
        if (packet.getValueData() != null) {
          Q q=getQ(packet.name);
          q.doBackup(false,null,request.blockId,(int)request.longValue);
        }
      }
    }
  }
  super.handleNoneRedoResponse(packet);
}","@Override public void handleNoneRedoResponse(Packet packet){
  if (request.operation == ClusterOperation.BLOCKING_QUEUE_POLL && packet.responseType == Constants.ResponseTypes.RESPONSE_SUCCESS) {
    if (!zeroBackup) {
      if (getPreviousMemberBefore(thisAddress,true,1).getAddress().equals(packet.conn.getEndPoint())) {
        if (packet.getValueData() != null) {
          Q q=getQ(packet.name);
          q.doBackup(false,null,request.blockId,(int)packet.longValue);
        }
      }
    }
  }
  super.handleNoneRedoResponse(packet);
}",0.989843028624192
50399,"final void handlePoll(Packet packet){
  if (rightRemotePollTarget(packet)) {
    Request request=Request.copy(packet);
    doPoll(request);
    if (!request.scheduled) {
      Data oldValue=(Data)request.response;
      if (oldValue != null && oldValue.size() > 0) {
        packet.setValue(oldValue);
      }
      sendResponse(packet);
    }
 else {
      releasePacket(packet);
    }
  }
}","final void handlePoll(Packet packet){
  if (rightRemotePollTarget(packet)) {
    Request request=Request.copy(packet);
    doPoll(request);
    packet.longValue=request.longValue;
    if (!request.scheduled) {
      Data oldValue=(Data)request.response;
      if (oldValue != null && oldValue.size() > 0) {
        packet.setValue(oldValue);
      }
      sendResponse(packet);
    }
 else {
      releasePacket(packet);
    }
  }
}",0.9514563106796116
50400,"public Data poll(Request request){
  try {
    setCurrentTake();
    QData qdata=blCurrentTake.remove();
    int removeIndex=blCurrentTake.removeIndex - 1;
    request.longValue=removeIndex;
    Data value=(qdata == null) ? null : qdata.data;
    if (request.txnId != -1) {
      MemberImpl backup=null;
      if (request.caller.equals(thisAddress)) {
        backup=getNextMemberAfter(thisAddress,true,1);
      }
 else {
        backup=getNextMemberAfter(request.caller,true,1);
      }
      if (backup != null) {
        if (backup.getAddress().equals(thisAddress)) {
          doTxnBackupPoll(request.txnId,value);
        }
 else {
          sendTxnBackup(backup.getAddress(),value,request.txnId);
        }
      }
    }
    doFireEntryEvent(false,value);
    sendBackup(false,request.caller,null,blCurrentTake.blockId,removeIndex);
    if (!blCurrentTake.containsValidItem() && blCurrentTake.isFull()) {
      fireBlockRemoveEvent(blCurrentTake);
      blCurrentTake=null;
    }
    return value;
  }
 catch (  Throwable t) {
    t.printStackTrace();
    return null;
  }
 finally {
    boolean consumed=false;
    while (!consumed && lsScheduledOfferActions.size() > 0) {
      ScheduledOfferAction offerAction=lsScheduledOfferActions.remove(0);
      if (!offerAction.expired()) {
        consumed=offerAction.consume();
        node.clusterManager.deregisterScheduledAction(offerAction);
      }
    }
  }
}","public Data poll(Request request){
  try {
    setCurrentTake();
    QData qdata=blCurrentTake.remove();
    int removeIndex=blCurrentTake.removeIndex - 1;
    request.longValue=removeIndex;
    Data value=(qdata == null) ? null : qdata.data;
    if (request.txnId != -1) {
      MemberImpl backup=null;
      if (request.caller.equals(thisAddress)) {
        backup=getNextMemberAfter(thisAddress,true,1);
      }
 else {
        backup=getNextMemberAfter(request.caller,true,1);
      }
      if (backup != null) {
        if (backup.getAddress().equals(thisAddress)) {
          doTxnBackupPoll(request.txnId,value);
        }
 else {
          sendTxnBackup(backup.getAddress(),value,request.txnId);
        }
      }
    }
    doFireEntryEvent(false,value,request.caller);
    sendBackup(false,request.caller,null,blCurrentTake.blockId,removeIndex);
    if (!blCurrentTake.containsValidItem() && blCurrentTake.isFull()) {
      fireBlockRemoveEvent(blCurrentTake);
      blCurrentTake=null;
    }
    return value;
  }
 catch (  Throwable t) {
    t.printStackTrace();
    return null;
  }
 finally {
    boolean consumed=false;
    while (!consumed && lsScheduledOfferActions.size() > 0) {
      ScheduledOfferAction offerAction=lsScheduledOfferActions.remove(0);
      if (!offerAction.expired()) {
        consumed=offerAction.consume();
        node.clusterManager.deregisterScheduledAction(offerAction);
      }
    }
  }
}",0.994738688179586
50401,"void doFireEntryEvent(boolean add,Data value){
  if (mapListeners.size() == 0)   return;
  if (add) {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,value);
  }
 else {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_REMOVED,value);
  }
}","void doFireEntryEvent(boolean add,Data value,Address callerAddress){
  if (mapListeners.size() == 0)   return;
  if (add) {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,value,callerAddress);
  }
 else {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_REMOVED,value,callerAddress);
  }
}",0.9094202898550724
50402,"public void put(Request req){
  long now=System.currentTimeMillis();
  if (mapRecords.size() >= maxSize) {
  }
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req.key);
  if (record != null && !record.isValid(now)) {
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (record != null && record.isActive() && record.isValid(now) && record.getValue() != null) {
      req.clearForResponse();
      req.response=record.getValue();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (record == null || !record.isActive() || !record.isValid(now) || record.getValue() == null) {
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (record == null || !record.isActive() || !record.isValid(now)) {
      req.response=Boolean.FALSE;
      return;
    }
    MultiData multiData=(MultiData)toObject(req.value);
    if (multiData == null || multiData.size() != 2) {
      throw new RuntimeException(""String_Node_Str"" + multiData);
    }
    Data expectedOldValue=multiData.getData(0);
    req.value=multiData.getData(1);
    if (!record.getValue().equals(expectedOldValue)) {
      req.response=Boolean.FALSE;
      return;
    }
  }
  Data oldValue=null;
  Op op=UPDATE;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    mapRecords.put(req.key,record);
    op=CREATE;
  }
 else {
    if (!record.isActive()) {
      op=CREATE;
    }
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValue() : null;
    record.setValue(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0) {
    record.setExpirationTime(req.ttl);
    ttlPerRecord=true;
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_ADDED,record);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_UPDATED,record);
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateStats(op,record,true,oldValue);
  updateIndexes(record);
  markAsDirty(record);
  req.clearForResponse();
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}","public void put(Request req){
  long now=System.currentTimeMillis();
  if (mapRecords.size() >= maxSize) {
  }
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req.key);
  if (record != null && !record.isValid(now)) {
    record.setValue(null);
    record.setMultiValues(null);
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (record != null && record.isActive() && record.isValid(now) && record.getValue() != null) {
      req.clearForResponse();
      req.response=record.getValue();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (record == null || !record.isActive() || !record.isValid(now) || record.getValue() == null) {
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (record == null || !record.isActive() || !record.isValid(now)) {
      req.response=Boolean.FALSE;
      return;
    }
    MultiData multiData=(MultiData)toObject(req.value);
    if (multiData == null || multiData.size() != 2) {
      throw new RuntimeException(""String_Node_Str"" + multiData);
    }
    Data expectedOldValue=multiData.getData(0);
    req.value=multiData.getData(1);
    if (!record.getValue().equals(expectedOldValue)) {
      req.response=Boolean.FALSE;
      return;
    }
  }
  Data oldValue=null;
  Op op=UPDATE;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    mapRecords.put(req.key,record);
    op=CREATE;
  }
 else {
    if (!record.isActive()) {
      op=CREATE;
    }
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValue() : null;
    record.setValue(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0) {
    record.setExpirationTime(req.ttl);
    ttlPerRecord=true;
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_ADDED,record,req.caller);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_UPDATED,record,req.caller);
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateStats(op,record,true,oldValue);
  updateIndexes(record);
  markAsDirty(record);
  req.clearForResponse();
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}",0.9834343434343434
50403,"public boolean putMulti(Request req){
  Record record=getRecord(req.key);
  boolean added=true;
  if (record == null) {
    record=toRecord(req);
  }
 else {
    if (!record.isActive()) {
      markAsActive(record);
    }
    if (record.containsValue(req.value)) {
      added=false;
    }
  }
  if (added) {
    Data value=req.value;
    updateIndexes(record);
    record.addValue(value);
    record.incrementVersion();
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_ADDED,record.getKey(),value,record.getMapListeners());
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  logger.log(Level.FINEST,record.getValue() + ""String_Node_Str"" + record.getMultiValues());
  req.clearForResponse();
  req.version=record.getVersion();
  return added;
}","public boolean putMulti(Request req){
  Record record=getRecord(req.key);
  boolean added=true;
  if (record == null) {
    record=toRecord(req);
  }
 else {
    if (!record.isActive()) {
      markAsActive(record);
    }
    if (record.containsValue(req.value)) {
      added=false;
    }
  }
  if (added) {
    Data value=req.value;
    updateIndexes(record);
    record.addValue(value);
    record.incrementVersion();
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_ADDED,record.getKey(),value,record.getMapListeners(),req.caller);
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  logger.log(Level.FINEST,record.getValue() + ""String_Node_Str"" + record.getMultiValues());
  req.clearForResponse();
  req.version=record.getVersion();
  return added;
}",0.9929622520793346
50404,"boolean evict(Request req){
  Record record=getRecord(req.key);
  if (record != null && record.isEvictable()) {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_EVICTED,record.getKey(),record.getValue(),record.getMapListeners());
    record.incrementVersion();
    updateStats(REMOVE,record,true,null);
    markAsRemoved(record);
    req.clearForResponse();
    req.version=record.getVersion();
    req.longValue=record.getCopyCount();
    lastEvictionTime=System.currentTimeMillis();
    return true;
  }
  return false;
}","boolean evict(Request req){
  Record record=getRecord(req.key);
  if (record != null && record.isEvictable()) {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_EVICTED,record.getKey(),record.getValue(),record.getMapListeners(),req.caller);
    record.incrementVersion();
    updateStats(REMOVE,record,true,null);
    markAsRemoved(record);
    req.clearForResponse();
    req.version=record.getVersion();
    req.longValue=record.getCopyCount();
    lastEvictionTime=System.currentTimeMillis();
    return true;
  }
  return false;
}",0.990622335890878
50405,"public boolean removeMulti(Request req){
  Record record=getRecord(req.key);
  if (record == null)   return false;
  boolean removed=false;
  if (req.value == null) {
    removed=true;
    markAsRemoved(record);
  }
 else {
    if (record.containsValue(req.value)) {
      if (record.getMultiValues() != null) {
        Iterator<Data> itValues=record.getMultiValues().iterator();
        while (itValues.hasNext()) {
          Data value=itValues.next();
          if (req.value.equals(value)) {
            itValues.remove();
            removed=true;
          }
        }
      }
    }
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  if (removed) {
    record.incrementVersion();
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_REMOVED,record.getKey(),req.value,record.getMapListeners());
    logger.log(Level.FINEST,record.getValue() + ""String_Node_Str"" + record.getMultiValues());
  }
  req.version=record.getVersion();
  if (record.valueCount() == 0) {
    markAsRemoved(record);
  }
  return removed;
}","public boolean removeMulti(Request req){
  Record record=getRecord(req.key);
  if (record == null)   return false;
  boolean removed=false;
  if (req.value == null) {
    removed=true;
    markAsRemoved(record);
  }
 else {
    if (record.containsValue(req.value)) {
      if (record.getMultiValues() != null) {
        Iterator<Data> itValues=record.getMultiValues().iterator();
        while (itValues.hasNext()) {
          Data value=itValues.next();
          if (req.value.equals(value)) {
            itValues.remove();
            removed=true;
          }
        }
      }
    }
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  if (removed) {
    record.incrementVersion();
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_REMOVED,record.getKey(),req.value,record.getMapListeners(),req.caller);
    logger.log(Level.FINEST,record.getValue() + ""String_Node_Str"" + record.getMultiValues());
  }
  req.version=record.getVersion();
  if (record.valueCount() == 0) {
    markAsRemoved(record);
  }
  return removed;
}",0.9947643979057592
50406,"public boolean removeItem(Request req){
  Record record=mapRecords.get(req.key);
  if (record == null) {
    return false;
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  boolean removed=false;
  if (record.getCopyCount() > 0) {
    record.decrementCopyCount();
    removed=true;
  }
 else   if (record.getValue() != null) {
    removed=true;
  }
 else   if (record.getMultiValues() != null) {
    removed=true;
  }
  if (removed) {
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_REMOVED,record);
    record.incrementVersion();
  }
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  markAsRemoved(record);
  return true;
}","public boolean removeItem(Request req){
  Record record=mapRecords.get(req.key);
  if (record == null) {
    return false;
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  boolean removed=false;
  if (record.getCopyCount() > 0) {
    record.decrementCopyCount();
    removed=true;
  }
 else   if (record.getValue() != null) {
    removed=true;
  }
 else   if (record.getMultiValues() != null) {
    removed=true;
  }
  if (removed) {
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_REMOVED,record,req.caller);
    record.incrementVersion();
  }
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  markAsRemoved(record);
  return true;
}",0.9920232052211748
50407,"public void doBackup(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  if (req.operation == CONCURRENT_MAP_BACKUP_PUT) {
    Record record=toRecordAndStats(req,false);
    if (!record.isActive()) {
      record.setActive();
      record.setCreationTime(System.currentTimeMillis());
    }
    record.setVersion(req.version);
    if (req.indexes != null) {
      if (req.indexTypes == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      if (req.indexes.length != req.indexTypes.length) {
        throw new RuntimeException(""String_Node_Str"");
      }
      record.setIndexes(req.indexes,req.indexTypes);
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (record.isActive()) {
        updateStats(REMOVE,record,false,null);
        if (record.getCopyCount() > 0) {
          record.decrementCopyCount();
        }
        markAsRemoved(record);
      }
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_LOCK) {
    Record rec=toRecord(req);
    if (rec.getVersion() == 0) {
      rec.setVersion(req.version);
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_ADD) {
    add(req,true);
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE_MULTI) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (req.value == null) {
        markAsRemoved(record);
      }
 else {
        if (record.containsValue(req.value)) {
          if (record.getMultiValues() != null) {
            Iterator<Data> itValues=record.getMultiValues().iterator();
            while (itValues.hasNext()) {
              Data value=itValues.next();
              if (req.value.equals(value)) {
                itValues.remove();
              }
            }
          }
        }
        if (record.valueCount() == 0) {
          markAsRemoved(record);
        }
      }
    }
  }
 else {
    logger.log(Level.SEVERE,""String_Node_Str"" + req.operation);
  }
}","public void doBackup(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  if (req.operation == CONCURRENT_MAP_BACKUP_PUT) {
    Record record=toRecordAndStats(req,false);
    markAsActive(record);
    record.setVersion(req.version);
    if (req.indexes != null) {
      if (req.indexTypes == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      if (req.indexes.length != req.indexTypes.length) {
        throw new RuntimeException(""String_Node_Str"");
      }
      record.setIndexes(req.indexes,req.indexTypes);
    }
    if (req.ttl > 0) {
      record.setExpirationTime(req.ttl);
      ttlPerRecord=true;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (record.isActive()) {
        updateStats(REMOVE,record,false,null);
        if (record.getCopyCount() > 0) {
          record.decrementCopyCount();
        }
        markAsRemoved(record);
      }
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_LOCK) {
    Record rec=toRecord(req);
    if (rec.getVersion() == 0) {
      rec.setVersion(req.version);
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_ADD) {
    add(req,true);
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE_MULTI) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (req.value == null) {
        markAsRemoved(record);
      }
 else {
        if (record.containsValue(req.value)) {
          if (record.getMultiValues() != null) {
            Iterator<Data> itValues=record.getMultiValues().iterator();
            while (itValues.hasNext()) {
              Data value=itValues.next();
              if (req.value.equals(value)) {
                itValues.remove();
              }
            }
          }
        }
        if (record.valueCount() == 0) {
          markAsRemoved(record);
        }
      }
    }
  }
 else {
    logger.log(Level.SEVERE,""String_Node_Str"" + req.operation);
  }
}",0.9477486154587046
50408,"private Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout,long ttl){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=toObject(oldValue);
      }
      txn.attachPutOp(name,key,value,(oldObject == null));
      return threadContext.isClient() ? oldValue : oldObject;
    }
 else {
      return txn.attachPutOp(name,key,value,false);
    }
  }
 else {
    setLocal(operation,name,key,value,timeout,ttl);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    if (operation == CONCURRENT_MAP_TRY_PUT) {
      request.setBooleanRequest();
      doOp();
      Boolean returnObject=getResultAsBoolean();
      if (returnObject) {
        backup(CONCURRENT_MAP_BACKUP_PUT);
      }
      return returnObject;
    }
 else {
      request.setObjectRequest();
      doOp();
      Object returnObject=getResultAsObject();
      if (returnObject instanceof AddressAwareException) {
        rethrowException(operation,(AddressAwareException)returnObject);
      }
      backup(CONCURRENT_MAP_BACKUP_PUT);
      return returnObject;
    }
  }
}","private Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout,long ttl){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=toObject(oldValue);
      }
      txn.attachPutOp(name,key,value,(oldObject == null));
      return threadContext.isClient() ? oldValue : oldObject;
    }
 else {
      return txn.attachPutOp(name,key,value,false);
    }
  }
 else {
    setLocal(operation,name,key,value,timeout,ttl);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    if (operation == CONCURRENT_MAP_TRY_PUT) {
      request.setBooleanRequest();
      doOp();
      Boolean returnObject=getResultAsBoolean();
      if (returnObject) {
        backup(CONCURRENT_MAP_BACKUP_PUT);
      }
      return returnObject;
    }
 else {
      request.setObjectRequest();
      doOp();
      Object returnObject=getResultAsObject();
      if (returnObject instanceof AddressAwareException) {
        rethrowException(operation,(AddressAwareException)returnObject);
      }
      request.longValue=request.ttl;
      backup(CONCURRENT_MAP_BACKUP_PUT);
      return returnObject;
    }
  }
}",0.9884627377611476
50409,"void fireMapEvent(final Map<Address,Boolean> mapListeners,final String name,final int eventType,final Record record){
  checkServiceThread();
  fireMapEvent(mapListeners,name,eventType,record.getKey(),record.getValue(),record.getMapListeners());
}","void fireMapEvent(final Map<Address,Boolean> mapListeners,final String name,final int eventType,final Record record,Address callerAddress){
  checkServiceThread();
  fireMapEvent(mapListeners,name,eventType,record.getKey(),record.getValue(),record.getMapListeners(),callerAddress);
}",0.9320754716981132
50410,"private void handleEvent(Packet packet){
  int eventType=(int)packet.longValue;
  Data key=packet.getKeyData();
  Data value=packet.getValueData();
  String name=packet.name;
  Address from=packet.conn.getEndPoint();
  releasePacket(packet);
  enqueueEvent(eventType,name,key,value,from);
}","private void handleEvent(Packet packet){
  int eventType=(int)packet.longValue;
  Data key=packet.getKeyData();
  Data value=packet.getValueData();
  String name=packet.name;
  Address from=packet.lockAddress;
  releasePacket(packet);
  enqueueEvent(eventType,name,key,value,from);
}",0.8237347294938918
50411,"void syncForDead(MemberImpl deadMember,Block block){
  Address deadAddress=deadMember.getAddress();
  if (deadAddress.equals(block.getOwner())) {
    MemberImpl member=concurrentMapManager.getNextMemberBeforeSync(deadAddress,true,1);
    if (member == null) {
      if (!concurrentMapManager.isSuperClient()) {
        block.setOwner(thisAddress);
      }
 else {
        block.setOwner(null);
      }
    }
 else {
      if (!deadAddress.equals(member.getAddress())) {
        block.setOwner(member.getAddress());
      }
 else {
        block.setOwner(null);
      }
    }
    if (!block.isMigrating()) {
      Member currentOwner=(block.getOwner() == null) ? null : concurrentMapManager.getMember(block.getOwner());
      if (currentOwner != null) {
        MigrationEvent migrationEvent=new MigrationEvent(concurrentMapManager.node,block.getBlockId(),deadMember,currentOwner);
        partitionServiceImpl.doFireMigrationEvent(true,migrationEvent);
        partitionServiceImpl.doFireMigrationEvent(false,migrationEvent);
      }
    }
  }
  if (block.isMigrating()) {
    if (deadAddress.equals(block.getMigrationAddress())) {
      MemberImpl member=concurrentMapManager.getNextMemberBeforeSync(deadAddress,true,1);
      if (member == null) {
        if (!concurrentMapManager.isSuperClient()) {
          block.setMigrationAddress(thisAddress);
        }
 else {
          block.setMigrationAddress(null);
        }
      }
 else {
        if (!deadAddress.equals(member.getAddress())) {
          block.setMigrationAddress(member.getAddress());
        }
 else {
          block.setMigrationAddress(null);
        }
      }
    }
  }
  for (  Block b : blocks) {
    if (b != null && b.isMigrating() && b.getMigrationAddress().equals(b.getOwner())) {
      b.setMigrationAddress(null);
    }
  }
}","void syncForDead(MemberImpl deadMember,Block block){
  Address deadAddress=deadMember.getAddress();
  if (deadAddress.equals(block.getOwner())) {
    MemberImpl member=concurrentMapManager.getNextMemberBeforeSync(deadAddress,true,1);
    if (member == null) {
      if (!concurrentMapManager.isSuperClient()) {
        block.setOwner(thisAddress);
      }
 else {
        block.setOwner(null);
      }
    }
 else {
      if (!deadAddress.equals(member.getAddress()) && !concurrentMapManager.isSuperClient()) {
        block.setOwner(member.getAddress());
      }
 else {
        block.setOwner(null);
      }
    }
    if (!block.isMigrating()) {
      Member currentOwner=(block.getOwner() == null) ? null : concurrentMapManager.getMember(block.getOwner());
      if (currentOwner != null) {
        MigrationEvent migrationEvent=new MigrationEvent(concurrentMapManager.node,block.getBlockId(),deadMember,currentOwner);
        partitionServiceImpl.doFireMigrationEvent(true,migrationEvent);
        partitionServiceImpl.doFireMigrationEvent(false,migrationEvent);
      }
    }
  }
  if (block.isMigrating()) {
    if (deadAddress.equals(block.getMigrationAddress())) {
      MemberImpl member=concurrentMapManager.getNextMemberBeforeSync(deadAddress,true,1);
      if (member == null) {
        if (!concurrentMapManager.isSuperClient()) {
          block.setMigrationAddress(thisAddress);
        }
 else {
          block.setMigrationAddress(null);
        }
      }
 else {
        if (!deadAddress.equals(member.getAddress())) {
          block.setMigrationAddress(member.getAddress());
        }
 else {
          block.setMigrationAddress(null);
        }
      }
    }
  }
  if (block.isMigrating() && block.getMigrationAddress().equals(block.getOwner())) {
    block.setMigrationAddress(null);
  }
  partitionServiceImpl.reset();
}",0.9520416552480132
50412,"public void publish(final Data msg){
  topicManager.fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,msg);
}","public void publish(final Data msg){
  topicManager.fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,msg,thisAddress);
}",0.9491525423728814
50413,"public NoMemberAvailableException(){
  super(""String_Node_Str"");
}","public NoMemberAvailableException(String message){
  super(message);
}",0.75
50414,"public void enQueue(Call call){
  try {
    logger.log(Level.FINEST,""String_Node_Str"" + call);
    queue.put(call);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","public void enQueue(Call call){
  try {
    if (running == false) {
      throw new NoMemberAvailableException(""String_Node_Str"" + ""String_Node_Str"");
    }
    logger.log(Level.FINEST,""String_Node_Str"" + call);
    queue.put(call);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}",0.7607361963190185
50415,"public boolean containsAll(Collection<?> arg0){
  for (Iterator<?> iterator=arg0.iterator(); iterator.hasNext(); ) {
    Object object=iterator.next();
    if (!contains(object)) {
      return false;
    }
  }
  return true;
}","public boolean containsAll(Collection<?> arg0){
  for (  Object object : arg0) {
    if (!contains(object)) {
      return false;
    }
  }
  return true;
}",0.7728459530026109
50416,"public boolean isEmpty(){
  return proxy.size() == 0;
}","public boolean isEmpty(){
  return entrySet.size() == 0;
}",0.9203539823008848
50417,"public boolean contains(Object arg0){
  return proxy.containsValue(arg0);
}","public boolean contains(Object arg0){
  for (  Entry<K,V> anEntrySet : entrySet) {
    Object object=anEntrySet.getValue();
    if (object.equals(arg0)) {
      return true;
    }
  }
  return false;
}",0.3768115942028985
50418,"public int size(){
  return proxy.size();
}","public int size(){
  return entrySet.size();
}",0.898876404494382
50419,"public <T>Future<T> submit(Runnable task,T result){
  if (!active)   throw new RejectedExecutionException(""String_Node_Str"" + name + ""String_Node_Str"");
  DistributedTask dtask;
  if (task instanceof DistributedTask) {
    dtask=(DistributedTask)task;
  }
 else {
    dtask=new DistributedTask(task,result);
  }
  node.executorManager.call(name,dtask);
  return dtask;
}","public <T>Future<T> submit(Runnable task,T result){
  if (!active)   throw new RejectedExecutionException(""String_Node_Str"" + name + ""String_Node_Str"");
  ThreadContext.get().setCurrentFactory(node.factory);
  DistributedTask dtask;
  if (task instanceof DistributedTask) {
    dtask=(DistributedTask)task;
  }
 else {
    dtask=new DistributedTask(task,result);
  }
  node.executorManager.call(name,dtask);
  return dtask;
}",0.9308176100628932
50420,"public void doFunctionalSQLQueryTest(IMap imap){
  imap.put(""String_Node_Str"",new Employee(""String_Node_Str"",33,false,14.56));
  imap.put(""String_Node_Str"",new Employee(""String_Node_Str"",23,true,15.00));
  for (int i=3; i < 103; i++) {
    imap.put(String.valueOf(i),new Employee(""String_Node_Str"" + i,i % 60,((i % 2) == 1),Double.valueOf(i)));
  }
  Set<Map.Entry> entries=imap.entrySet();
  assertEquals(102,entries.size());
  int itCount=0;
  for (  Map.Entry entry : entries) {
    Employee c=(Employee)entry.getValue();
    itCount++;
  }
  assertEquals(102,itCount);
  entries=imap.entrySet(new SqlPredicate(""String_Node_Str""));
  assertEquals(3,entries.size());
  for (  Map.Entry entry : entries) {
    Employee c=(Employee)entry.getValue();
    assertEquals(c.getAge(),23);
    assertTrue(c.isActive());
  }
  imap.remove(""String_Node_Str"");
  entries=imap.entrySet(new SqlPredicate(""String_Node_Str""));
  assertEquals(2,entries.size());
  for (  Map.Entry entry : entries) {
    Employee c=(Employee)entry.getValue();
    assertEquals(c.getAge(),23);
    assertTrue(c.isActive());
  }
}","public void doFunctionalSQLQueryTest(IMap imap){
  imap.put(""String_Node_Str"",new Employee(""String_Node_Str"",33,false,14.56));
  imap.put(""String_Node_Str"",new Employee(""String_Node_Str"",23,true,15.00));
  for (int i=3; i < 103; i++) {
    imap.put(String.valueOf(i),new Employee(""String_Node_Str"" + i,i % 60,((i % 2) == 1),Double.valueOf(i)));
  }
  Set<Map.Entry> entries=imap.entrySet();
  assertEquals(102,entries.size());
  int itCount=0;
  for (  Map.Entry entry : entries) {
    Employee c=(Employee)entry.getValue();
    itCount++;
  }
  assertEquals(102,itCount);
  entries=imap.entrySet(new SqlPredicate(""String_Node_Str""));
  assertEquals(3,entries.size());
  for (  Map.Entry entry : entries) {
    Employee c=(Employee)entry.getValue();
    assertEquals(c.getAge(),23);
    assertTrue(c.isActive());
  }
  imap.remove(""String_Node_Str"");
  entries=imap.entrySet(new SqlPredicate(""String_Node_Str""));
  assertEquals(2,entries.size());
  for (  Map.Entry entry : entries) {
    Employee c=(Employee)entry.getValue();
    assertEquals(c.getAge(),23);
    assertTrue(c.isActive());
  }
  entries=imap.entrySet(new SqlPredicate(""String_Node_Str""));
  for (  Map.Entry entry : entries) {
    Employee c=(Employee)entry.getValue();
    assertTrue(c.isActive());
  }
}",0.9252849303503587
50421,"public static void writeObject(DataOutput out,Object obj) throws IOException {
  if (obj == null) {
    out.writeByte(0);
  }
 else   if (obj instanceof Long) {
    out.writeByte(1);
    out.writeLong((Long)obj);
  }
 else   if (obj instanceof Integer) {
    out.writeByte(2);
    out.writeInt((Integer)obj);
  }
 else   if (obj instanceof String) {
    out.writeByte(3);
    out.writeUTF((String)obj);
  }
 else   if (obj instanceof Double) {
    out.writeByte(4);
    out.writeDouble((Double)obj);
  }
 else   if (obj instanceof Float) {
    out.writeByte(5);
    out.writeDouble((Float)obj);
  }
 else   if (obj instanceof Boolean) {
    out.writeByte(6);
    out.writeBoolean((Boolean)obj);
  }
 else   if (obj instanceof DataSerializable) {
    out.writeByte(7);
    out.writeUTF(obj.getClass().getName());
    ((DataSerializable)obj).writeData(out);
  }
 else   if (obj instanceof Date) {
    out.writeByte(8);
    out.writeLong(((Date)obj).getTime());
  }
 else {
    out.writeByte(9);
    ByteArrayOutputStream bos=new ByteArrayOutputStream();
    ObjectOutputStream oos=new ObjectOutputStream(bos);
    oos.writeObject(obj);
    oos.close();
    byte[] buf=bos.toByteArray();
    out.writeInt(buf.length);
    out.write(buf);
  }
}","public static void writeObject(DataOutput out,Object obj) throws IOException {
  if (obj == null) {
    out.writeByte(0);
  }
 else   if (obj instanceof Long) {
    out.writeByte(1);
    out.writeLong((Long)obj);
  }
 else   if (obj instanceof Integer) {
    out.writeByte(2);
    out.writeInt((Integer)obj);
  }
 else   if (obj instanceof String) {
    out.writeByte(3);
    out.writeUTF((String)obj);
  }
 else   if (obj instanceof Double) {
    out.writeByte(4);
    out.writeDouble((Double)obj);
  }
 else   if (obj instanceof Float) {
    out.writeByte(5);
    out.writeFloat((Float)obj);
  }
 else   if (obj instanceof Boolean) {
    out.writeByte(6);
    out.writeBoolean((Boolean)obj);
  }
 else   if (obj instanceof DataSerializable) {
    out.writeByte(7);
    out.writeUTF(obj.getClass().getName());
    ((DataSerializable)obj).writeData(out);
  }
 else   if (obj instanceof Date) {
    out.writeByte(8);
    out.writeLong(((Date)obj).getTime());
  }
 else {
    out.writeByte(9);
    ByteArrayOutputStream bos=new ByteArrayOutputStream();
    ObjectOutputStream oos=new ObjectOutputStream(bos);
    oos.writeObject(obj);
    oos.close();
    byte[] buf=bos.toByteArray();
    out.writeInt(buf.length);
    out.write(buf);
  }
}",0.9955627269060104
50422,"public static Object readObject(DataInput in) throws IOException {
  byte type=in.readByte();
  if (type == 0) {
    return null;
  }
 else   if (type == 1) {
    return in.readInt();
  }
 else   if (type == 2) {
    return in.readInt();
  }
 else   if (type == 3) {
    return in.readUTF();
  }
 else   if (type == 4) {
    return in.readDouble();
  }
 else   if (type == 5) {
    return in.readFloat();
  }
 else   if (type == 6) {
    return in.readBoolean();
  }
 else   if (type == 7) {
    DataSerializable ds;
    try {
      ds=(DataSerializable)Serializer.classForName(in.readUTF()).newInstance();
    }
 catch (    Throwable e) {
      throw new IOException(e.getMessage());
    }
    ds.readData(in);
    return ds;
  }
 else   if (type == 8) {
    return new Date(in.readLong());
  }
 else   if (type == 9) {
    int len=in.readInt();
    byte[] buf=new byte[len];
    in.readFully(buf);
    ObjectInputStream oin=Serializer.newObjectInputStream(new ByteArrayInputStream(buf));
    try {
      return oin.readObject();
    }
 catch (    ClassNotFoundException e) {
      e.printStackTrace();
    }
    oin.close();
  }
 else {
    throw new IOException(""String_Node_Str"" + type);
  }
  return null;
}","public static Object readObject(DataInput in) throws IOException {
  byte type=in.readByte();
  if (type == 0) {
    return null;
  }
 else   if (type == 1) {
    return in.readLong();
  }
 else   if (type == 2) {
    return in.readInt();
  }
 else   if (type == 3) {
    return in.readUTF();
  }
 else   if (type == 4) {
    return in.readDouble();
  }
 else   if (type == 5) {
    return in.readFloat();
  }
 else   if (type == 6) {
    return in.readBoolean();
  }
 else   if (type == 7) {
    DataSerializable ds;
    try {
      ds=(DataSerializable)Serializer.classForName(in.readUTF()).newInstance();
    }
 catch (    Throwable e) {
      throw new IOException(e.getMessage());
    }
    ds.readData(in);
    return ds;
  }
 else   if (type == 8) {
    return new Date(in.readLong());
  }
 else   if (type == 9) {
    int len=in.readInt();
    byte[] buf=new byte[len];
    in.readFully(buf);
    ObjectInputStream oin=Serializer.newObjectInputStream(new ByteArrayInputStream(buf));
    try {
      return oin.readObject();
    }
 catch (    ClassNotFoundException e) {
      e.printStackTrace();
    }
    oin.close();
  }
 else {
    throw new IOException(""String_Node_Str"" + type);
  }
  return null;
}",0.9971134020618556
50423,"void reArrangeBlocks(){
  if (concurrentMapManager.isMaster()) {
    Map<Address,List<Block>> addressBlocks=getCurrentMemberBlocks();
    if (addressBlocks.size() == 0) {
      return;
    }
    List<Block> lsBlocksToRedistribute=new ArrayList<Block>();
    int aveBlockOwnCount=PARTITION_COUNT / (addressBlocks.size());
    int membersWithMorePartitionsThanAvarage=PARTITION_COUNT - addressBlocks.keySet().size() * aveBlockOwnCount;
    for (    Address address : addressBlocks.keySet()) {
      List<Block> blocks=addressBlocks.get(address);
      if (membersWithMorePartitionsThanAvarage != 0 && blocks.size() == aveBlockOwnCount + 1) {
        membersWithMorePartitionsThanAvarage--;
        continue;
      }
      int diff=(blocks.size() - aveBlockOwnCount);
      for (int i=0; i < diff; i++) {
        Block block=blocks.remove(0);
        lsBlocksToRedistribute.add(block);
      }
    }
    lsBlocksToMigrate.clear();
    for (    Address address : addressBlocks.keySet()) {
      List<Block> blocks=addressBlocks.get(address);
      int count=blocks.size();
      while (count < aveBlockOwnCount && lsBlocksToRedistribute.size() > 0) {
        Block blockToMigrate=lsBlocksToRedistribute.remove(0);
        addBlockToMigrate(blockToMigrate,address);
        count++;
      }
    }
    lsBlocksToRedistribute.removeAll(lsBlocksToMigrate);
    for (    Address address : addressBlocks.keySet()) {
      if (lsBlocksToRedistribute.size() == 0) {
        break;
      }
      if (addressBlocks.get(address).size() != aveBlockOwnCount + 1) {
        Block blockToMigrate=lsBlocksToRedistribute.remove(0);
        addBlockToMigrate(blockToMigrate,address);
      }
    }
    Collections.shuffle(lsBlocksToMigrate);
  }
}","void reArrangeBlocks(){
  if (concurrentMapManager.isMaster()) {
    Map<Address,List<Block>> addressBlocks=getCurrentMemberBlocks();
    if (addressBlocks.size() == 0) {
      return;
    }
    List<Block> lsBlocksToRedistribute=new ArrayList<Block>();
    int aveBlockOwnCount=PARTITION_COUNT / (addressBlocks.size());
    int membersWithMorePartitionsThanAverage=PARTITION_COUNT - addressBlocks.keySet().size() * aveBlockOwnCount;
    for (    Address address : addressBlocks.keySet()) {
      List<Block> blocks=addressBlocks.get(address);
      if (membersWithMorePartitionsThanAverage != 0 && blocks.size() == aveBlockOwnCount + 1) {
        membersWithMorePartitionsThanAverage--;
        continue;
      }
      int diff=(blocks.size() - aveBlockOwnCount);
      for (int i=0; i < diff; i++) {
        Block block=blocks.remove(0);
        lsBlocksToRedistribute.add(block);
      }
    }
    lsBlocksToMigrate.clear();
    for (    Address address : addressBlocks.keySet()) {
      List<Block> blocks=addressBlocks.get(address);
      int count=blocks.size();
      while (count < aveBlockOwnCount && lsBlocksToRedistribute.size() > 0) {
        Block blockToMigrate=lsBlocksToRedistribute.remove(0);
        addBlockToMigrate(blockToMigrate,address);
        count++;
      }
    }
    lsBlocksToRedistribute.removeAll(lsBlocksToMigrate);
    for (    Address address : addressBlocks.keySet()) {
      if (lsBlocksToRedistribute.size() == 0) {
        break;
      }
      if (addressBlocks.get(address).size() != aveBlockOwnCount + 1) {
        Block blockToMigrate=lsBlocksToRedistribute.remove(0);
        addBlockToMigrate(blockToMigrate,address);
      }
    }
    Collections.shuffle(lsBlocksToMigrate);
  }
}",0.9982608695652174
50424,"void initiateMigration(){
  boolean hasMigrating=false;
  for (int i=0; i < PARTITION_COUNT; i++) {
    Block block=blocks[i];
    if (block == null) {
      block=concurrentMapManager.getOrCreateBlock(i);
      block.setOwner(thisAddress);
    }
    if (block.isMigrating()) {
      hasMigrating=true;
    }
  }
  if (!hasMigrating && lsBlocksToMigrate.size() == 0) {
    reArrangeBlocks();
  }
  if (!hasMigrating && lsBlocksToMigrate.size() > 0) {
    Block block=lsBlocksToMigrate.remove(0);
    sendBlocks(block);
  }
 else {
    sendBlocks(null);
  }
}","void initiateMigration(){
  boolean hasMigrating=false;
  for (int i=0; i < PARTITION_COUNT; i++) {
    Block block=blocks[i];
    if (block == null) {
      block=concurrentMapManager.getOrCreateBlock(i);
    }
    if (block.isMigrating()) {
      hasMigrating=true;
    }
  }
  if (!hasMigrating && lsBlocksToMigrate.size() == 0) {
    reArrangeBlocks();
  }
  if (!hasMigrating && lsBlocksToMigrate.size() > 0) {
    Block block=lsBlocksToMigrate.remove(0);
    sendBlocks(block);
  }
 else {
    sendBlocks(null);
  }
}",0.967622571692877
50425,"void migrateBlock(final Block blockInfo){
  Block blockReal=blocks[blockInfo.getBlockId()];
  if (!thisAddress.equals(blockInfo.getOwner())) {
    throw new RuntimeException(""String_Node_Str"" + blockInfo);
  }
  if (!blockInfo.isMigrating()) {
    throw new RuntimeException(""String_Node_Str"" + blockInfo);
  }
  if (blockInfo.getOwner().equals(blockInfo.getMigrationAddress())) {
    throw new RuntimeException(""String_Node_Str"" + blockInfo);
  }
  if (!node.isActive() || node.factory.restarted) {
    return;
  }
  if (concurrentMapManager.isSuperClient()) {
    return;
  }
  if (blockReal.isMigrationStarted())   return;
  blockReal.setMigrationStarted(true);
  blockReal.setOwner(blockInfo.getOwner());
  blockReal.setMigrationAddress(blockInfo.getMigrationAddress());
  logger.log(Level.FINEST,""String_Node_Str"" + blockInfo);
  List<Record> lsRecordsToMigrate=new ArrayList<Record>(1000);
  Collection<CMap> cmaps=concurrentMapManager.maps.values();
  for (  final CMap cmap : cmaps) {
    if (cmap.locallyOwnedMap != null) {
      cmap.locallyOwnedMap.reset();
    }
    for (    Record rec : cmap.mapRecords.values()) {
      if (rec.isActive() && concurrentMapManager.isOwned(rec)) {
        if (rec.getKey() == null || rec.getKey().size() == 0) {
          throw new RuntimeException(""String_Node_Str"" + rec.getKey());
        }
        if (rec.getBlockId() == blockInfo.getBlockId()) {
          Record recordCopy=rec.copy();
          lsRecordsToMigrate.add(recordCopy);
          cmap.markAsRemoved(rec);
        }
      }
    }
  }
  logger.log(Level.FINEST,""String_Node_Str"" + lsRecordsToMigrate.size() + ""String_Node_Str""+ blockInfo);
  final CountDownLatch latch=new CountDownLatch(lsRecordsToMigrate.size());
  for (  final Record rec : lsRecordsToMigrate) {
    final CMap cmap=concurrentMapManager.getMap(rec.getName());
    parallelExecutorMigration.execute(new FallThroughRunnable(){
      public void doRun(){
        try {
          concurrentMapManager.migrateRecord(cmap,rec);
        }
  finally {
          latch.countDown();
        }
      }
    }
);
  }
  parallelExecutorMigration.execute(new FallThroughRunnable(){
    public void doRun(){
      try {
        logger.log(Level.FINEST,""String_Node_Str"" + blockInfo + ""String_Node_Str"");
        latch.await(10,TimeUnit.SECONDS);
        concurrentMapManager.enqueueAndReturn(new Processable(){
          public void process(){
            blockInfo.setOwner(blockInfo.getMigrationAddress());
            blockInfo.setMigrationAddress(null);
            completeMigration(blockInfo.getBlockId());
            sendCompletionInfo(blockInfo);
          }
        }
);
      }
 catch (      InterruptedException ignored) {
      }
    }
  }
);
}","void migrateBlock(final Block blockInfo){
  Block blockReal=blocks[blockInfo.getBlockId()];
  if (!thisAddress.equals(blockInfo.getOwner())) {
    throw new RuntimeException(""String_Node_Str"" + blockInfo);
  }
  if (!blockInfo.isMigrating()) {
    throw new RuntimeException(""String_Node_Str"" + blockInfo);
  }
  if (blockInfo.getOwner().equals(blockInfo.getMigrationAddress())) {
    throw new RuntimeException(""String_Node_Str"" + blockInfo);
  }
  if (!node.isActive() || node.factory.restarted) {
    return;
  }
  if (concurrentMapManager.isSuperClient()) {
    return;
  }
  if (blockReal.isMigrationStarted())   return;
  blockReal.setMigrationStarted(true);
  blockReal.setOwner(blockInfo.getOwner());
  blockReal.setMigrationAddress(blockInfo.getMigrationAddress());
  logger.log(Level.FINEST,""String_Node_Str"" + blockInfo);
  List<Record> lsRecordsToMigrate=new ArrayList<Record>(1000);
  Collection<CMap> cmaps=concurrentMapManager.maps.values();
  for (  final CMap cmap : cmaps) {
    if (cmap.locallyOwnedMap != null) {
      cmap.locallyOwnedMap.reset();
    }
    for (    Record rec : cmap.mapRecords.values()) {
      if (rec.isActive() && concurrentMapManager.isOwned(rec)) {
        if (rec.getKey() == null || rec.getKey().size() == 0) {
          throw new RuntimeException(""String_Node_Str"" + rec.getKey());
        }
        if (rec.getBlockId() == blockInfo.getBlockId()) {
          Record recordCopy=rec.copy();
          lsRecordsToMigrate.add(recordCopy);
          cmap.markAsRemoved(rec);
        }
      }
    }
  }
  logger.log(Level.FINEST,""String_Node_Str"" + lsRecordsToMigrate.size() + ""String_Node_Str""+ blockInfo);
  final CountDownLatch latch=new CountDownLatch(lsRecordsToMigrate.size());
  for (  final Record rec : lsRecordsToMigrate) {
    final CMap cmap=concurrentMapManager.getMap(rec.getName());
    parallelExecutorMigration.execute(new FallThroughRunnable(){
      public void doRun(){
        try {
          concurrentMapManager.migrateRecord(cmap,rec);
        }
  finally {
          latch.countDown();
        }
      }
    }
);
  }
  parallelExecutorMigration.execute(new FallThroughRunnable(){
    public void doRun(){
      try {
        logger.log(Level.FINEST,""String_Node_Str"" + blockInfo + ""String_Node_Str"");
        latch.await(10,TimeUnit.SECONDS);
      }
 catch (      InterruptedException ignored) {
      }
 finally {
        concurrentMapManager.enqueueAndReturn(new Processable(){
          public void process(){
            blockInfo.setOwner(blockInfo.getMigrationAddress());
            blockInfo.setMigrationAddress(null);
            completeMigration(blockInfo.getBlockId());
            sendCompletionInfo(blockInfo);
          }
        }
);
      }
    }
  }
);
}",0.9756633119853614
50426,"public void doRun(){
  try {
    logger.log(Level.FINEST,""String_Node_Str"" + blockInfo + ""String_Node_Str"");
    latch.await(10,TimeUnit.SECONDS);
    concurrentMapManager.enqueueAndReturn(new Processable(){
      public void process(){
        blockInfo.setOwner(blockInfo.getMigrationAddress());
        blockInfo.setMigrationAddress(null);
        completeMigration(blockInfo.getBlockId());
        sendCompletionInfo(blockInfo);
      }
    }
);
  }
 catch (  InterruptedException ignored) {
  }
}","public void doRun(){
  try {
    logger.log(Level.FINEST,""String_Node_Str"" + blockInfo + ""String_Node_Str"");
    latch.await(10,TimeUnit.SECONDS);
  }
 catch (  InterruptedException ignored) {
  }
 finally {
    concurrentMapManager.enqueueAndReturn(new Processable(){
      public void process(){
        blockInfo.setOwner(blockInfo.getMigrationAddress());
        blockInfo.setMigrationAddress(null);
        completeMigration(blockInfo.getBlockId());
        sendCompletionInfo(blockInfo);
      }
    }
);
  }
}",0.8947885939036382
50427,"Map<Address,List<Block>> getCurrentMemberBlocks(){
  Map<Address,List<Block>> addressBlocks=new HashMap<Address,List<Block>>();
  List<MemberImpl> lsMembers=concurrentMapManager.getMembers();
  for (  MemberImpl member : lsMembers) {
    if (!member.isSuperClient()) {
      addressBlocks.put(member.getAddress(),new ArrayList<Block>());
    }
  }
  for (  Block blockReal : blocks) {
    if (!blockReal.isMigrating()) {
      List<Block> ownedBlocks=addressBlocks.get(blockReal.getOwner());
      ownedBlocks.add(new Block(blockReal));
    }
  }
  return addressBlocks;
}","Map<Address,List<Block>> getCurrentMemberBlocks(){
  Map<Address,List<Block>> addressBlocks=new HashMap<Address,List<Block>>();
  List<MemberImpl> lsMembers=concurrentMapManager.getMembers();
  for (  MemberImpl member : lsMembers) {
    if (!member.isSuperClient()) {
      addressBlocks.put(member.getAddress(),new ArrayList<Block>());
    }
  }
  if (addressBlocks.size() > 0) {
    for (    Block blockReal : blocks) {
      if (blockReal != null && !blockReal.isMigrating()) {
        List<Block> ownedBlocks=addressBlocks.get(blockReal.getOwner());
        ownedBlocks.add(new Block(blockReal));
      }
    }
  }
  return addressBlocks;
}",0.933442892358258
50428,"void backupIfNextOrPreviousChanged(boolean add){
  boolean shouldBackup=false;
  if (add && node.clusterManager.isNextChanged()) {
    shouldBackup=true;
  }
 else   if (!add && node.clusterManager.isPreviousChanged()) {
    shouldBackup=true;
  }
  if (shouldBackup) {
    List<Record> lsOwnedRecords=new ArrayList<Record>(1000);
    Collection<CMap> cmaps=concurrentMapManager.maps.values();
    for (    final CMap cmap : cmaps) {
      for (      Record rec : cmap.mapRecords.values()) {
        if (rec.isActive()) {
          if (rec.getKey() == null || rec.getKey().size() == 0) {
            throw new RuntimeException(""String_Node_Str"" + rec.getKey());
          }
          lsOwnedRecords.add(rec);
        }
      }
    }
    for (    final Record rec : lsOwnedRecords) {
      parallelExecutorBackups.execute(new FallThroughRunnable(){
        public void doRun(){
          concurrentMapManager.backupRecord(rec);
        }
      }
);
    }
  }
}","void backupIfNextOrPreviousChanged(boolean add){
  boolean shouldBackup=node.clusterManager.isNextChanged();
  if (shouldBackup) {
    List<Record> lsOwnedRecords=new ArrayList<Record>(1000);
    Collection<CMap> cmaps=concurrentMapManager.maps.values();
    for (    final CMap cmap : cmaps) {
      for (      Record rec : cmap.mapRecords.values()) {
        if (rec.isActive()) {
          if (rec.getKey() == null || rec.getKey().size() == 0) {
            throw new RuntimeException(""String_Node_Str"" + rec.getKey());
          }
          lsOwnedRecords.add(rec);
        }
      }
    }
    if (!add)     logger.log(Level.INFO,thisAddress + ""String_Node_Str"" + lsOwnedRecords.size());
    for (    final Record rec : lsOwnedRecords) {
      parallelExecutorBackups.execute(new FallThroughRunnable(){
        public void doRun(){
          concurrentMapManager.backupRecord(rec);
        }
      }
);
    }
  }
}",0.8460309003729355
50429,"void quickBlockRearrangement(){
  if (!concurrentMapManager.isMaster())   return;
  createAllBlocks();
  Map<Address,List<Block>> addressBlocks=getCurrentMemberBlocks();
  if (addressBlocks.size() == 0) {
    return;
  }
  List<Block> lsEmptyBlocks=new ArrayList<Block>();
  for (  Block blockReal : blocks) {
    if (!blockReal.isMigrating() && thisAddress.equals(blockReal.getOwner())) {
      if (isBlockEmpty(blockReal.getBlockId())) {
        lsEmptyBlocks.add(blockReal);
      }
    }
  }
  int aveBlockOwnCount=PARTITION_COUNT / (addressBlocks.size());
  for (  Address address : addressBlocks.keySet()) {
    List<Block> blocks=addressBlocks.get(address);
    int diff=(aveBlockOwnCount - blocks.size());
    for (int i=0; i < diff && lsEmptyBlocks.size() > 0; i++) {
      Block block=lsEmptyBlocks.remove(0);
      block.setOwner(address);
    }
  }
  if (lsEmptyBlocks.size() > 0) {
    for (    Address address : addressBlocks.keySet()) {
      if (lsEmptyBlocks.size() == 0) {
        break;
      }
      Block ownableBlock=lsEmptyBlocks.remove(0);
      ownableBlock.setOwner(address);
    }
  }
  sendBlocks(null);
}","void quickBlockRearrangement(){
  if (!concurrentMapManager.isMaster())   return;
  createAllBlocks();
  Map<Address,List<Block>> addressBlocks=getCurrentMemberBlocks();
  if (addressBlocks.size() == 0) {
    return;
  }
  List<Block> lsEmptyBlocks=new ArrayList<Block>();
  for (  Block blockReal : blocks) {
    if (!blockReal.isMigrating() && thisAddress.equals(blockReal.getOwner())) {
      if (isBlockEmpty(blockReal.getBlockId())) {
        lsEmptyBlocks.add(blockReal);
      }
    }
  }
  int aveBlockOwnCount=PARTITION_COUNT / (addressBlocks.size());
  for (  Address address : addressBlocks.keySet()) {
    List<Block> blocks=addressBlocks.get(address);
    int diff=(aveBlockOwnCount - blocks.size());
    for (int i=0; i < diff && lsEmptyBlocks.size() > 0; i++) {
      Block block=lsEmptyBlocks.remove(0);
      block.setOwner(address);
    }
  }
  if (lsEmptyBlocks.size() > 0) {
    for (    Address address : addressBlocks.keySet()) {
      if (lsEmptyBlocks.size() == 0) {
        break;
      }
      Block ownableBlock=lsEmptyBlocks.remove(0);
      ownableBlock.setOwner(address);
    }
  }
  sendBlocks(null);
  partitionServiceImpl.reset();
}",0.9860748476936466
50430,"void fireScheduledActions(Record record){
  concurrentMapManager.checkServiceThread();
  if (record.getLockCount() == 0) {
    record.clearLock();
    if (record.getScheduledActions() != null) {
      while (record.getScheduledActions().size() > 0) {
        ScheduledAction sa=record.getScheduledActions().remove(0);
        node.clusterManager.deregisterScheduledAction(sa);
        if (!sa.expired()) {
          sa.consume();
          if (record.isLocked()) {
            return;
          }
        }
      }
    }
  }
}","void fireScheduledActions(Record record){
  concurrentMapManager.checkServiceThread();
  if (record.getLockCount() == 0) {
    record.clearLock();
    if (record.getScheduledActions() != null) {
      while (record.getScheduledActions().size() > 0) {
        ScheduledAction sa=record.getScheduledActions().remove(0);
        node.clusterManager.deregisterScheduledAction(sa);
        if (!sa.expired()) {
          sa.consume();
          if (record.isLocked()) {
            return;
          }
        }
 else {
          sa.onExpire();
        }
      }
    }
  }
}",0.9278538812785389
50431,"public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  beforeCall();
  try {
    return method.invoke(mproxyReal,args);
  }
 catch (  Throwable e) {
    if (factory.restarted) {
      return invoke(proxy,method,args);
    }
 else {
      throw (RuntimeException)e;
    }
  }
 finally {
    afterCall();
  }
}","public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  beforeCall();
  try {
    return method.invoke(mproxyReal,args);
  }
 catch (  Throwable e) {
    if (factory.restarted) {
      return invoke(proxy,method,args);
    }
 else     if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
 else {
      throw new RuntimeException(e);
    }
  }
 finally {
    afterCall();
  }
}",0.8403141361256544
50432,"private void joinWithMulticast(){
  int tryCount=0;
  while (!joined) {
    try {
      logger.log(Level.FINEST,""String_Node_Str"" + masterAddress);
      if (masterAddress == null) {
        masterAddress=findMaster();
        if (masterAddress == null || masterAddress.equals(address)) {
          TcpIpConfig tcpIpConfig=config.getNetworkConfig().getJoin().getTcpIpConfig();
          if (tcpIpConfig != null && tcpIpConfig.isEnabled()) {
            masterAddress=null;
            logger.log(Level.FINEST,""String_Node_Str"");
            joinWithTCP();
          }
 else {
            setAsMaster();
          }
          return;
        }
      }
      if (tryCount++ > 20) {
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + tryCount);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + masterAddress);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + connectionManager.getConnection(masterAddress));
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        logger.log(Level.WARNING,sb.toString());
        tryCount=0;
      }
      if (!masterAddress.equals(address)) {
        connectAndSendJoinRequest(masterAddress);
      }
 else {
        masterAddress=null;
        tryCount=0;
      }
      Thread.sleep(500);
    }
 catch (    final Exception e) {
      logger.log(Level.FINEST,""String_Node_Str"",e);
    }
  }
}","private void joinWithMulticast(){
  int tryCount=0;
  while (!joined) {
    try {
      logger.log(Level.FINEST,""String_Node_Str"" + masterAddress);
      if (masterAddress == null) {
        masterAddress=findMaster();
        if (masterAddress == null || masterAddress.equals(address)) {
          TcpIpConfig tcpIpConfig=config.getNetworkConfig().getJoin().getTcpIpConfig();
          if (tcpIpConfig != null && tcpIpConfig.isEnabled()) {
            masterAddress=null;
            logger.log(Level.FINEST,""String_Node_Str"");
            joinWithTCP();
          }
 else {
            setAsMaster();
          }
          return;
        }
      }
      if (tryCount++ > 20) {
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + tryCount);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + address);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + masterAddress);
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"" + connectionManager.getConnection(masterAddress));
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        logger.log(Level.WARNING,sb.toString());
        tryCount=0;
      }
      if (!masterAddress.equals(address)) {
        connectAndSendJoinRequest(masterAddress);
      }
 else {
        masterAddress=null;
        tryCount=0;
      }
      Thread.sleep(500);
    }
 catch (    final Exception e) {
      logger.log(Level.FINEST,""String_Node_Str"",e);
    }
  }
}",0.9730407523510972
50433,"public Record(CMap cmap,int blockId,Data key,Data value,long ttl,long maxIdleMillis,long id){
  super();
  this.id=id;
  this.cmap=cmap;
  this.blockId=blockId;
  this.key=key;
  this.value=value;
  this.setCreationTime(System.currentTimeMillis());
  this.setExpirationTime(ttl);
  this.maxIdleMillis=(maxIdleMillis == 0) ? Long.MAX_VALUE : maxIdleMillis;
  this.setVersion(0);
}","public Record(CMap cmap,int blockId,Data key,Data value,long ttl,long maxIdleMillis,long id){
  super();
  this.id=id;
  this.cmap=cmap;
  this.blockId=(short)blockId;
  this.key=key;
  this.value=value;
  this.setCreationTime(System.currentTimeMillis());
  this.setExpirationTime(ttl);
  this.maxIdleMillis=(maxIdleMillis == 0) ? Long.MAX_VALUE : maxIdleMillis;
  this.setVersion(0);
}",0.9908496732026144
50434,"public Object invoke(final Object o,final Method method,final Object[] objects) throws Throwable {
  final String name=method.getName();
  final BlockingQueue<Object> resultQ=ResponseQueueFactory.newResponseQueue();
  if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    es.execute(new Runnable(){
      public void run(){
        try {
          Transaction txn=Hazelcast.getTransaction();
          if (name.equals(""String_Node_Str"")) {
            txn.begin();
          }
 else           if (name.equals(""String_Node_Str"")) {
            txn.commit();
          }
 else           if (name.equals(""String_Node_Str"")) {
            txn.rollback();
          }
          resultQ.put(NULL_OBJECT);
        }
 catch (        Exception e) {
          try {
            resultQ.put(e);
          }
 catch (          InterruptedException ignored) {
          }
        }
      }
    }
);
  }
 else {
    es.execute(new Runnable(){
      public void run(){
        try {
          Object result=method.invoke(target,objects);
          resultQ.put((result == null) ? NULL_OBJECT : result);
        }
 catch (        Exception e) {
          try {
            resultQ.put(e);
          }
 catch (          InterruptedException ignored) {
          }
        }
      }
    }
);
  }
  Object result=resultQ.poll(5,TimeUnit.SECONDS);
  if (result == null)   throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str"");
  if (name.equals(""String_Node_Str"")) {
    es.shutdown();
  }
  if (result instanceof Throwable) {
    throw ((Throwable)result);
  }
  return (result == NULL_OBJECT) ? null : result;
}","public Object invoke(final Object o,final Method method,final Object[] args) throws Throwable {
  final String name=method.getName();
  final BlockingQueue<Object> resultQ=ResponseQueueFactory.newResponseQueue();
  if (name.equals(""String_Node_Str"")) {
    return invokeAsync(args);
  }
 else   if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    es.execute(new Runnable(){
      public void run(){
        try {
          Transaction txn=Hazelcast.getTransaction();
          if (name.equals(""String_Node_Str"")) {
            txn.begin();
          }
 else           if (name.equals(""String_Node_Str"")) {
            txn.commit();
          }
 else           if (name.equals(""String_Node_Str"")) {
            txn.rollback();
          }
          resultQ.put(NULL_OBJECT);
        }
 catch (        Exception e) {
          try {
            resultQ.put(e);
          }
 catch (          InterruptedException ignored) {
          }
        }
      }
    }
);
  }
 else {
    es.execute(new Runnable(){
      public void run(){
        try {
          Object result=method.invoke(target,args);
          resultQ.put((result == null) ? NULL_OBJECT : result);
        }
 catch (        Exception e) {
          try {
            resultQ.put(e);
          }
 catch (          InterruptedException ignored) {
          }
        }
      }
    }
);
  }
  Object result=resultQ.poll(5,TimeUnit.SECONDS);
  if (result == null)   throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str"");
  if (name.equals(""String_Node_Str"")) {
    es.shutdown();
  }
  if (result instanceof Throwable) {
    throw ((Throwable)result);
  }
  return (result == NULL_OBJECT) ? null : result;
}",0.9712272460364064
50435,"public void run(){
  try {
    Object result=method.invoke(target,objects);
    resultQ.put((result == null) ? NULL_OBJECT : result);
  }
 catch (  Exception e) {
    try {
      resultQ.put(e);
    }
 catch (    InterruptedException ignored) {
    }
  }
}","public void run(){
  try {
    Object result=method.invoke(target,args);
    resultQ.put((result == null) ? NULL_OBJECT : result);
  }
 catch (  Exception e) {
    try {
      resultQ.put(e);
    }
 catch (    InterruptedException ignored) {
    }
  }
}",0.9823182711198428
50436,"@Test public void testTryLock(){
  Hazelcast.getMap(""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"");
  TransactionalMap txnMap=newTransactionalMapProxy(""String_Node_Str"");
  TransactionalMap txnMap2=newTransactionalMapProxy(""String_Node_Str"");
  txnMap.lock(""String_Node_Str"");
  long start=System.currentTimeMillis();
  assertFalse(txnMap2.tryLock(""String_Node_Str"",2,TimeUnit.SECONDS));
  long end=System.currentTimeMillis();
  long took=(end - start);
  assertTrue((took > 1000) ? (took < 4000) : false);
  assertFalse(txnMap2.tryLock(""String_Node_Str""));
  txnMap.unlock(""String_Node_Str"");
  assertTrue(txnMap2.tryLock(""String_Node_Str"",2,TimeUnit.SECONDS));
}","@Test public void testTryLock(){
  Hazelcast.getMap(""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"");
  TransactionalMap txnMap=newTransactionalMapProxy(""String_Node_Str"");
  TransactionalMap txnMap2=newTransactionalMapProxy(""String_Node_Str"");
  txnMap.lock(""String_Node_Str"");
  long start=System.currentTimeMillis();
  assertFalse(txnMap2.tryLock(""String_Node_Str"",2,TimeUnit.SECONDS));
  long end=System.currentTimeMillis();
  long took=(end - start);
  System.out.println(""String_Node_Str"" + took);
  assertTrue((took > 1000) ? (took < 4000) : false);
  assertFalse(txnMap2.tryLock(""String_Node_Str""));
  txnMap.unlock(""String_Node_Str"");
  assertTrue(txnMap2.tryLock(""String_Node_Str"",2,TimeUnit.SECONDS));
}",0.9657631954350928
50437,"public ClusterManager(final Node node){
  super(node);
  WAIT_MILLIS_BEFORE_JOIN=node.groupProperties.WAIT_SECONDS_BEFORE_JOIN.getInteger() * 1000L;
  MAX_NO_HEARTBEAT_MILLIS=node.groupProperties.MAX_NO_HEARTBEAT_SECONDS.getInteger() * 1000L;
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      heartBeater();
    }
  }
);
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      checkScheduledActions();
    }
  }
);
  node.connectionManager.addConnectionListener(this);
  registerPacketProcessor(ClusterOperation.RESPONSE,new PacketProcessor(){
    public void process(    Packet packet){
      handleResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.HEARTBEAT,new PacketProcessor(){
    public void process(    Packet packet){
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS_AND_RESPOND,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.value;
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      sendResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.value;
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_BOOLEAN,new PacketProcessor(){
    public void process(    Packet packet){
      Boolean result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.value;
        callable=(AbstractRemotelyCallable<Boolean>)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=Boolean.FALSE;
      }
      if (result == Boolean.TRUE) {
        sendResponse(packet);
      }
 else {
        sendResponseFailure(packet);
      }
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_OBJECT,new PacketProcessor(){
    public void process(    Packet packet){
      Object result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.value;
        callable=(AbstractRemotelyCallable)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=null;
      }
      if (result != null) {
        Data value;
        if (result instanceof Data) {
          value=(Data)result;
        }
 else {
          value=toData(result);
        }
        packet.value=value;
      }
      sendResponse(packet);
    }
  }
);
}","public ClusterManager(final Node node){
  super(node);
  WAIT_MILLIS_BEFORE_JOIN=node.groupProperties.WAIT_SECONDS_BEFORE_JOIN.getInteger() * 1000L;
  MAX_NO_HEARTBEAT_MILLIS=node.groupProperties.MAX_NO_HEARTBEAT_SECONDS.getInteger() * 1000L;
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      heartBeater();
    }
  }
);
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      checkScheduledActions();
    }
  }
);
  node.connectionManager.addConnectionListener(this);
  registerPacketProcessor(ClusterOperation.RESPONSE,new PacketProcessor(){
    public void process(    Packet packet){
      handleResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.HEARTBEAT,new PacketProcessor(){
    public void process(    Packet packet){
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS_AND_RESPOND,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      sendResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_BOOLEAN,new PacketProcessor(){
    public void process(    Packet packet){
      Boolean result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable<Boolean>)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=Boolean.FALSE;
      }
      if (result == Boolean.TRUE) {
        sendResponse(packet);
      }
 else {
        sendResponseFailure(packet);
      }
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_OBJECT,new PacketProcessor(){
    public void process(    Packet packet){
      Object result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=null;
      }
      if (result != null) {
        Data value;
        if (result instanceof Data) {
          value=(Data)result;
        }
 else {
          value=toData(result);
        }
        packet.setValue(value);
      }
      sendResponse(packet);
    }
  }
);
}",0.9852374839537869
50438,"private void handleCommand(String command){
  if (echo) {
    if (Thread.currentThread().getName().toLowerCase().indexOf(""String_Node_Str"") < 0)     System.out.println(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ command);
 else     System.out.println(command);
  }
  if (command == null || command.startsWith(""String_Node_Str""))   return;
  command=command.trim();
  if (command == null || command.length() == 0) {
    return;
  }
  String first=command;
  int spaceIndex=command.indexOf(' ');
  String[] argsSplit=command.split(""String_Node_Str"");
  String[] args=new String[argsSplit.length];
  for (int i=0; i < argsSplit.length; i++) {
    args[i]=argsSplit[i].trim();
  }
  if (spaceIndex != -1) {
    first=args[0];
  }
  if (command.startsWith(""String_Node_Str"")) {
    handleHelp(command);
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    int repeat=Integer.parseInt(first.substring(1));
    long t0=System.currentTimeMillis();
    for (int i=0; i < repeat; i++) {
      handleCommand(command.substring(first.length()).replaceAll(""String_Node_Str"",""String_Node_Str"" + i));
    }
    System.out.println(""String_Node_Str"" + repeat * 1000 / (System.currentTimeMillis() - t0));
    return;
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    final int fork=Integer.parseInt(first.substring(1));
    ExecutorService pool=Executors.newFixedThreadPool(fork);
    final String threadCommand=command.substring(first.length());
    for (int i=0; i < fork; i++) {
      final int threadID=i;
      pool.submit(new Runnable(){
        public void run(){
          String command=threadCommand;
          String[] threadArgs=command.replaceAll(""String_Node_Str"",""String_Node_Str"" + threadID).trim().split(""String_Node_Str"");
          if (""String_Node_Str"".equals(threadArgs[0]) || ""String_Node_Str"".equals(threadArgs[0])) {
            if (threadArgs.length < 4) {
              command+=""String_Node_Str"" + Integer.parseInt(threadArgs[1]) * threadID;
            }
          }
          handleCommand(command);
        }
      }
);
    }
    pool.shutdown();
    try {
      pool.awaitTermination(60 * 60,TimeUnit.SECONDS);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (first.startsWith(""String_Node_Str"")) {
    if (first.length() == 1) {
      System.out.println(""String_Node_Str"");
      return;
    }
    File f=new File(first.substring(1));
    System.out.println(""String_Node_Str"" + f.getAbsolutePath());
    if (f.exists()) {
      try {
        BufferedReader br=new BufferedReader(new FileReader(f));
        String l=br.readLine();
        while (l != null) {
          handleCommand(l);
          l=br.readLine();
        }
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else {
      System.out.println(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
 else   if (command.indexOf(';') != -1) {
    StringTokenizer st=new StringTokenizer(command,""String_Node_Str"");
    while (st.hasMoreTokens()) {
      handleCommand(st.nextToken());
    }
    return;
  }
 else   if (""String_Node_Str"".equals(first)) {
    silent=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    hazelcast.restart();
  }
 else   if (""String_Node_Str"".equals(first)) {
    hazelcast.shutdown();
  }
 else   if (""String_Node_Str"".equals(first)) {
    echo=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    if (args.length > 1) {
      namespace=args[1];
      queue=hazelcast.getQueue(namespace);
      topic=hazelcast.getTopic(namespace);
      map=hazelcast.getMap(namespace);
      set=hazelcast.getSet(namespace);
      list=hazelcast.getList(namespace);
    }
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.out.println(hazelcast.getCluster().getLocalMember());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.out.println(hazelcast.getCluster());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.gc();
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().maxMemory() / 1024 / 1024 + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + ""String_Node_Str"" + (int)(Runtime.getRuntime().freeMemory() * 100 / Runtime.getRuntime().maxMemory()) + ""String_Node_Str"");
    long total=Runtime.getRuntime().totalMemory();
    long free=Runtime.getRuntime().freeMemory();
    System.out.println(""String_Node_Str"" + ((total - free) / 1024 / 1024) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().availableProcessors());
    System.out.println(""String_Node_Str"" + ManagementFactory.getOperatingSystemMXBean().getArch() + ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getName()+ ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getVersion());
    System.out.println(""String_Node_Str"" + ManagementFactory.getRuntimeMXBean().getVmVendor() + ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmName()+ ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmVersion());
  }
 else   if (first.indexOf(""String_Node_Str"") != -1 && first.indexOf(""String_Node_Str"") == -1) {
    handleLock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleSize(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleClear(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleDestroy(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleIterator(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleContains(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handStats(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleTopicPublish(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOffer(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPoll(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPeek(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQCapacity(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOfferMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPollMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemove(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAddMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemoveMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapReplace(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutIfAbsent(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPut(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGet(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapGetMapEntry(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapEvict(args);
  }
 else   if (first.equals(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemoveMany(args);
  }
 else   if (command.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapLocalKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapValues();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapEntries();
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapLock(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapTryLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleAddListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleRemoveListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleListAddMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListContains(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    execute(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handlePartitions(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().begin();
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().commit();
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().rollback();
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnKey(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMembers(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLongTaskOnOtherMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLong(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleInstances(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    System.exit(0);
  }
 else {
    print(""String_Node_Str"");
  }
}","private void handleCommand(String command){
  if (echo) {
    if (Thread.currentThread().getName().toLowerCase().indexOf(""String_Node_Str"") < 0)     System.out.println(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ command);
 else     System.out.println(command);
  }
  if (command == null || command.startsWith(""String_Node_Str""))   return;
  command=command.trim();
  if (command == null || command.length() == 0) {
    return;
  }
  String first=command;
  int spaceIndex=command.indexOf(' ');
  String[] argsSplit=command.split(""String_Node_Str"");
  String[] args=new String[argsSplit.length];
  for (int i=0; i < argsSplit.length; i++) {
    args[i]=argsSplit[i].trim();
  }
  if (spaceIndex != -1) {
    first=args[0];
  }
  if (command.startsWith(""String_Node_Str"")) {
    handleHelp(command);
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    int repeat=Integer.parseInt(first.substring(1));
    long t0=System.currentTimeMillis();
    for (int i=0; i < repeat; i++) {
      handleCommand(command.substring(first.length()).replaceAll(""String_Node_Str"",""String_Node_Str"" + i));
    }
    System.out.println(""String_Node_Str"" + repeat * 1000 / (System.currentTimeMillis() - t0));
    return;
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    final int fork=Integer.parseInt(first.substring(1));
    ExecutorService pool=Executors.newFixedThreadPool(fork);
    final String threadCommand=command.substring(first.length());
    for (int i=0; i < fork; i++) {
      final int threadID=i;
      pool.submit(new Runnable(){
        public void run(){
          String command=threadCommand;
          String[] threadArgs=command.replaceAll(""String_Node_Str"",""String_Node_Str"" + threadID).trim().split(""String_Node_Str"");
          if (""String_Node_Str"".equals(threadArgs[0]) || ""String_Node_Str"".equals(threadArgs[0])) {
            if (threadArgs.length < 4) {
              command+=""String_Node_Str"" + Integer.parseInt(threadArgs[1]) * threadID;
            }
          }
          handleCommand(command);
        }
      }
);
    }
    pool.shutdown();
    try {
      pool.awaitTermination(60 * 60,TimeUnit.SECONDS);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (first.startsWith(""String_Node_Str"")) {
    if (first.length() == 1) {
      System.out.println(""String_Node_Str"");
      return;
    }
    File f=new File(first.substring(1));
    System.out.println(""String_Node_Str"" + f.getAbsolutePath());
    if (f.exists()) {
      try {
        BufferedReader br=new BufferedReader(new FileReader(f));
        String l=br.readLine();
        while (l != null) {
          handleCommand(l);
          l=br.readLine();
        }
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else {
      System.out.println(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
 else   if (command.indexOf(';') != -1) {
    StringTokenizer st=new StringTokenizer(command,""String_Node_Str"");
    while (st.hasMoreTokens()) {
      handleCommand(st.nextToken());
    }
    return;
  }
 else   if (""String_Node_Str"".equals(first)) {
    silent=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    hazelcast.restart();
  }
 else   if (""String_Node_Str"".equals(first)) {
    hazelcast.shutdown();
  }
 else   if (""String_Node_Str"".equals(first)) {
    echo=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    if (args.length > 1) {
      namespace=args[1];
      queue=hazelcast.getQueue(namespace);
      topic=hazelcast.getTopic(namespace);
      map=hazelcast.getMap(namespace);
      set=hazelcast.getSet(namespace);
      list=hazelcast.getList(namespace);
    }
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.out.println(hazelcast.getCluster().getLocalMember());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.out.println(hazelcast.getCluster());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.gc();
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().maxMemory() / 1024 / 1024 + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + ""String_Node_Str"" + (int)(Runtime.getRuntime().freeMemory() * 100 / Runtime.getRuntime().maxMemory()) + ""String_Node_Str"");
    long total=Runtime.getRuntime().totalMemory();
    long free=Runtime.getRuntime().freeMemory();
    System.out.println(""String_Node_Str"" + ((total - free) / 1024 / 1024) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().availableProcessors());
    System.out.println(""String_Node_Str"" + ManagementFactory.getOperatingSystemMXBean().getArch() + ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getName()+ ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getVersion());
    System.out.println(""String_Node_Str"" + ManagementFactory.getRuntimeMXBean().getVmVendor() + ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmName()+ ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmVersion());
  }
 else   if (first.indexOf(""String_Node_Str"") != -1 && first.indexOf(""String_Node_Str"") == -1) {
    handleLock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleSize(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleClear(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleDestroy(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleIterator(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleContains(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handStats(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleTopicPublish(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOffer(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQTake(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPoll(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPeek(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQCapacity(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOfferMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPollMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemove(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAddMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemoveMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapReplace(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutIfAbsent(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPut(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGet(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapGetMapEntry(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapEvict(args);
  }
 else   if (first.equals(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemoveMany(args);
  }
 else   if (command.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapLocalKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapValues();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapEntries();
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapLock(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapTryLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleAddListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleRemoveListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleListAddMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListContains(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    execute(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handlePartitions(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().begin();
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().commit();
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().rollback();
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnKey(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMembers(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLongTaskOnOtherMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLong(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleInstances(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    System.exit(0);
  }
 else {
    print(""String_Node_Str"");
  }
}",0.9962592255585886
50439,"public void returnScheduledAsSuccess(final Request request){
  if (request.local) {
    final TargetAwareOp targetAwareOp=(TargetAwareOp)request.attachment;
    targetAwareOp.setResult(request.response);
  }
 else {
    final Packet packet=obtainPacket();
    request.setPacket(packet);
    final Object result=request.response;
    if (result != null) {
      if (result instanceof Data) {
        final Data data=(Data)result;
        if (data.size() > 0) {
          packet.value=data;
        }
      }
    }
    sendResponse(packet,request.caller);
  }
}","public void returnScheduledAsSuccess(final Request request){
  if (request.local) {
    final TargetAwareOp targetAwareOp=(TargetAwareOp)request.attachment;
    targetAwareOp.setResult(request.response);
  }
 else {
    final Packet packet=obtainPacket();
    request.setPacket(packet);
    final Object result=request.response;
    if (result != null) {
      if (result instanceof Data) {
        final Data data=(Data)result;
        if (data.size() > 0) {
          packet.setValue(data);
        }
      }
    }
    sendResponse(packet,request.caller);
  }
}",0.9786096256684492
50440,"private void handleObjectNoneRedoResponse(final Packet packet){
  if (packet.responseType == Constants.ResponseTypes.RESPONSE_SUCCESS) {
    final Data oldValue=packet.value;
    if (oldValue == null || oldValue.size() == 0) {
      setResult(OBJECT_NULL);
    }
 else {
      setResult(oldValue);
    }
  }
 else {
    throw new RuntimeException(request.operation + ""String_Node_Str"" + packet.responseType);
  }
}","private void handleObjectNoneRedoResponse(final Packet packet){
  if (packet.responseType == Constants.ResponseTypes.RESPONSE_SUCCESS) {
    final Data oldValue=packet.getValueData();
    if (oldValue == null || oldValue.size() == 0) {
      setResult(OBJECT_NULL);
    }
 else {
      setResult(oldValue);
    }
  }
 else {
    throw new RuntimeException(request.operation + ""String_Node_Str"" + packet.responseType);
  }
}",0.977299880525687
50441,"public boolean returnResponse(Request request,Connection conn){
  if (request.local) {
    final TargetAwareOp targetAwareOp=(TargetAwareOp)request.attachment;
    targetAwareOp.setResult(request.response);
  }
 else {
    Packet packet=obtainPacket();
    request.setPacket(packet);
    packet.operation=ClusterOperation.RESPONSE;
    packet.responseType=RESPONSE_SUCCESS;
    packet.longValue=request.longValue;
    if (request.value != null) {
      packet.value=request.value;
    }
    if (request.response == OBJECT_REDO) {
      packet.lockAddress=null;
      packet.responseType=RESPONSE_REDO;
    }
 else     if (request.response != null) {
      if (request.response instanceof Boolean) {
        if (request.response == Boolean.FALSE) {
          packet.responseType=RESPONSE_FAILURE;
        }
      }
 else       if (request.response instanceof Long) {
        packet.longValue=(Long)request.response;
      }
 else {
        Data data;
        if (request.response instanceof Data) {
          data=(Data)request.response;
        }
 else {
          data=toData(request.response);
        }
        if (data != null && data.size() > 0) {
          packet.value=data;
        }
      }
    }
    if (conn != null) {
      conn.getWriteHandler().enqueuePacket(packet);
    }
 else {
      return sendResponse(packet,request.caller);
    }
  }
  return true;
}","public boolean returnResponse(Request request,Connection conn){
  if (request.local) {
    final TargetAwareOp targetAwareOp=(TargetAwareOp)request.attachment;
    targetAwareOp.setResult(request.response);
  }
 else {
    Packet packet=obtainPacket();
    request.setPacket(packet);
    packet.operation=ClusterOperation.RESPONSE;
    packet.responseType=RESPONSE_SUCCESS;
    packet.longValue=request.longValue;
    if (request.value != null) {
      packet.setValue(request.value);
    }
    if (request.response == OBJECT_REDO) {
      packet.lockAddress=null;
      packet.responseType=RESPONSE_REDO;
    }
 else     if (request.response != null) {
      if (request.response instanceof Boolean) {
        if (request.response == Boolean.FALSE) {
          packet.responseType=RESPONSE_FAILURE;
        }
      }
 else       if (request.response instanceof Long) {
        packet.longValue=(Long)request.response;
      }
 else {
        Data data;
        if (request.response instanceof Data) {
          data=(Data)request.response;
        }
 else {
          data=toData(request.response);
        }
        if (data != null && data.size() > 0) {
          packet.setValue(data);
        }
      }
    }
    if (conn != null) {
      conn.getWriteHandler().enqueuePacket(packet);
    }
 else {
      return sendResponse(packet,request.caller);
    }
  }
  return true;
}",0.9825581395348836
50442,"public void sendEvents(final int eventType,final String name,final Data key,final Data value,final Map<Address,Boolean> mapListeners){
  if (mapListeners != null) {
    final Set<Map.Entry<Address,Boolean>> listeners=mapListeners.entrySet();
    for (    final Map.Entry<Address,Boolean> listener : listeners) {
      final Address address=listener.getKey();
      final boolean includeValue=listener.getValue();
      if (address.isThisAddress()) {
        try {
          enqueueEvent(eventType,name,key,(includeValue) ? value : null,address);
        }
 catch (        final Exception e) {
          e.printStackTrace();
        }
      }
 else {
        final Packet packet=obtainPacket();
        packet.set(name,ClusterOperation.EVENT,key,(includeValue) ? value : null);
        packet.longValue=eventType;
        final boolean sent=send(packet,address);
        if (!sent)         releasePacket(packet);
      }
    }
  }
}","public void sendEvents(final int eventType,final String name,final Data key,final Data value,final Map<Address,Boolean> mapListeners){
  if (mapListeners != null) {
    final Set<Map.Entry<Address,Boolean>> listeners=mapListeners.entrySet();
    for (    final Map.Entry<Address,Boolean> listener : listeners) {
      final Address address=listener.getKey();
      final boolean includeValue=listener.getValue();
      if (address.isThisAddress()) {
        enqueueEvent(eventType,name,key,(includeValue) ? value : null,address);
      }
 else {
        final Packet packet=obtainPacket();
        packet.set(name,ClusterOperation.EVENT,key,(includeValue) ? value : null);
        packet.longValue=eventType;
        final boolean sent=send(packet,address);
        if (!sent)         releasePacket(packet);
      }
    }
  }
}",0.9408418657565416
50443,"public synchronized void destroyConnection(Connection connection){
  if (currentConnection != null && currentConnection.getVersion() == connection.getVersion()) {
    logger.warning(""String_Node_Str"" + currentConnection + ""String_Node_Str"");
    currentConnection=null;
  }
}","public synchronized void destroyConnection(Connection connection,boolean gracefully){
  if (currentConnection != null && currentConnection.getVersion() == connection.getVersion()) {
    Level level=gracefully ? Level.INFO : Level.WARNING;
    logger.log(level,""String_Node_Str"" + currentConnection + ""String_Node_Str"");
    currentConnection=null;
  }
}",0.8312101910828026
50444,"protected void customRun(){
  Packet packet;
  try {
    Connection oldConnection=connection;
    connection=client.connectionManager.getConnection();
    if (restoredConnection(oldConnection,connection)) {
      onDisconnect(oldConnection);
    }
    if (connection == null) {
      interruptWaitingCalls();
      Thread.sleep(50);
    }
 else {
      packet=reader.readPacket(connection);
      Call call=callMap.remove(packet.getCallId());
      if (call != null) {
        call.setResponse(packet);
      }
 else {
        if (packet.getOperation().equals(ClusterOperation.EVENT)) {
          client.getListenerManager().enqueue(packet);
        }
        if (packet.getCallId() == -1) {
        }
 else {
          throw new RuntimeException(""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
        }
      }
    }
  }
 catch (  RuntimeException re) {
    throw re;
  }
catch (  Exception e) {
    logger.finest(""String_Node_Str"" + e.toString());
    client.connectionManager.destroyConnection(connection);
  }
}","protected void customRun(){
  Packet packet;
  try {
    Connection oldConnection=connection;
    connection=client.connectionManager.getConnection();
    if (restoredConnection(oldConnection,connection)) {
      onDisconnect(oldConnection);
    }
    if (connection == null) {
      interruptWaitingCalls();
      Thread.sleep(50);
    }
 else {
      packet=reader.readPacket(connection);
      Call call=callMap.remove(packet.getCallId());
      if (call != null) {
        call.setResponse(packet);
      }
 else {
        if (packet.getOperation().equals(ClusterOperation.EVENT)) {
          client.getListenerManager().enqueue(packet);
        }
        if (packet.getCallId() == -1) {
        }
 else {
          throw new RuntimeException(""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
        }
      }
    }
  }
 catch (  RuntimeException re) {
    throw re;
  }
catch (  Exception e) {
    logger.finest(""String_Node_Str"" + e.toString());
    boolean gracefully=!running;
    client.connectionManager.destroyConnection(connection,gracefully);
  }
}",0.9720670391061452
50445,"protected void customRun() throws InterruptedException {
  Call call=null;
  try {
    call=queue.poll(100,TimeUnit.MILLISECONDS);
    if (call == null) {
      return;
    }
    callMap.put(call.getId(),call);
    Connection oldConnection=connection;
    connection=client.getConnectionManager().getConnection();
    if (restoredConnection(oldConnection,connection)) {
      redoUnfinishedCalls(call,oldConnection);
    }
 else     if (connection != null) {
      writer.write(connection,call.getRequest());
    }
 else {
      interruptWaitingCalls();
    }
  }
 catch (  InterruptedException e) {
    throw e;
  }
catch (  Throwable io) {
    logger.finest(""String_Node_Str"" + io.getMessage());
    enQueue(call);
    client.getConnectionManager().destroyConnection(connection);
  }
}","protected void customRun() throws InterruptedException {
  Call call=null;
  try {
    call=queue.poll(100,TimeUnit.MILLISECONDS);
    if (call == null) {
      return;
    }
    callMap.put(call.getId(),call);
    Connection oldConnection=connection;
    connection=client.getConnectionManager().getConnection();
    if (restoredConnection(oldConnection,connection)) {
      redoUnfinishedCalls(call,oldConnection);
    }
 else     if (connection != null) {
      writer.write(connection,call.getRequest());
    }
 else {
      interruptWaitingCalls();
    }
  }
 catch (  InterruptedException e) {
    throw e;
  }
catch (  Throwable io) {
    logger.finest(""String_Node_Str"" + io.getMessage());
    enQueue(call);
    boolean gracefully=!running;
    client.getConnectionManager().destroyConnection(connection,gracefully);
  }
}",0.9728059332509272
50446,"void doFireMigrationEvent(final boolean started,final MigrationEvent migrationEvent){
  if (migrationEvent == null)   throw new RuntimeException(""String_Node_Str"" + migrationEvent);
  Member owner=(started) ? migrationEvent.getOldOwner() : migrationEvent.getNewOwner();
  Member migrationMember=(started) ? migrationEvent.getNewOwner() : null;
  final PartitionReal partitionReal=new PartitionReal(migrationEvent.getPartitionId(),owner,migrationMember);
  mapRealPartitions.put(partitionReal.getPartitionId(),partitionReal);
  for (  final MigrationListener migrationListener : lsMigrationListeners) {
    concurrentMapManager.executeLocally(new Runnable(){
      public void run(){
        if (started) {
          migrationListener.migrationStarted(migrationEvent);
        }
 else {
          migrationListener.migrationCompleted(migrationEvent);
        }
      }
    }
);
  }
}","void doFireMigrationEvent(final boolean started,final MigrationEvent migrationEvent){
  partitionVersion.incrementAndGet();
  if (migrationEvent == null)   throw new RuntimeException(""String_Node_Str"" + migrationEvent);
  Member owner=(started) ? migrationEvent.getOldOwner() : migrationEvent.getNewOwner();
  Member migrationMember=(started) ? migrationEvent.getNewOwner() : null;
  final PartitionReal partitionReal=new PartitionReal(migrationEvent.getPartitionId(),owner,migrationMember);
  mapRealPartitions.put(partitionReal.getPartitionId(),partitionReal);
  for (  final MigrationListener migrationListener : lsMigrationListeners) {
    concurrentMapManager.executeLocally(new Runnable(){
      public void run(){
        if (started) {
          migrationListener.migrationStarted(migrationEvent);
        }
 else {
          migrationListener.migrationCompleted(migrationEvent);
        }
      }
    }
);
  }
}",0.978912319644839
50447,"public CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.logger=concurrentMapManager.node.getLogger(CMap.class.getName());
  this.PARTITION_COUNT=concurrentMapManager.PARTITION_COUNT;
  this.blocks=concurrentMapManager.blocks;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  MapConfig mapConfig=null;
  String mapConfigName=name.substring(2);
  if (mapConfigName.startsWith(""String_Node_Str"") || mapConfigName.startsWith(""String_Node_Str"") || mapConfigName.startsWith(""String_Node_Str"")) {
    mapConfig=new MapConfig();
  }
 else {
    mapConfig=node.getConfig().getMapConfig(mapConfigName);
  }
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  evictionDelayMillis=mapConfig.getEvictionDelaySeconds() * 1000L;
  maxIdle=mapConfig.getMaxIdleSeconds() * 1000L;
  evictionPolicy=EvictionPolicy.valueOf(mapConfig.getEvictionPolicy());
  if (evictionPolicy == EvictionPolicy.NONE) {
    maxSize=Integer.MAX_VALUE;
    evictionComparator=null;
  }
 else {
    maxSize=(mapConfig.getMaxSize() == 0) ? MapConfig.DEFAULT_MAX_SIZE : mapConfig.getMaxSize();
    if (evictionPolicy == EvictionPolicy.LRU) {
      evictionComparator=LRU_COMPARATOR;
    }
 else {
      evictionComparator=LFU_COMPARATOR;
    }
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100f;
  instanceType=ConcurrentMapManager.getInstanceType(name);
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  MapStore storeTemp=null;
  MapLoader loaderTemp=null;
  int writeDelaySeconds=-1;
  if (mapStoreConfig != null && mapStoreConfig.isEnabled()) {
    try {
      Object storeInstance=mapStoreConfig.getImplementation();
      if (storeInstance == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeInstance=Serializer.classForName(node.getConfig().getClassLoader(),mapStoreClassName).newInstance();
      }
      if (storeInstance instanceof MapLoader) {
        loaderTemp=(MapLoader)storeInstance;
      }
      if (storeInstance instanceof MapStore) {
        storeTemp=(MapStore)storeInstance;
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
  }
  loader=loaderTemp;
  store=storeTemp;
  writeDelayMillis=(writeDelaySeconds == -1) ? -1L : writeDelaySeconds * 1000L;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + writeDelaySeconds;
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  if (evictionPolicy == EvictionPolicy.NONE && instanceType == Instance.InstanceType.MAP) {
    locallyOwnedMap=new LocallyOwnedMap(localMapStats);
    concurrentMapManager.mapLocallyOwnedMaps.put(name,locallyOwnedMap);
  }
 else {
    locallyOwnedMap=null;
  }
  NearCacheConfig nearCacheConfig=mapConfig.getNearCacheConfig();
  if (nearCacheConfig == null) {
    mapNearCache=null;
  }
 else {
    mapNearCache=new MapNearCache(this,SortedHashMap.getOrderingTypeByName(mapConfig.getEvictionPolicy()),nearCacheConfig.getMaxSize(),nearCacheConfig.getTimeToLiveSeconds() * 1000L,nearCacheConfig.getMaxIdleSeconds() * 1000L,nearCacheConfig.isInvalidateOnChange());
    concurrentMapManager.mapCaches.put(name,mapNearCache);
  }
  this.creationTime=System.currentTimeMillis();
}","public CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.logger=concurrentMapManager.node.getLogger(CMap.class.getName());
  this.PARTITION_COUNT=concurrentMapManager.PARTITION_COUNT;
  this.blocks=concurrentMapManager.blocks;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  MapConfig mapConfig=null;
  String mapConfigName=name.substring(2);
  if (mapConfigName.startsWith(""String_Node_Str"") || mapConfigName.startsWith(""String_Node_Str"") || mapConfigName.startsWith(""String_Node_Str"")) {
    mapConfig=new MapConfig();
  }
 else {
    mapConfig=node.getConfig().getMapConfig(mapConfigName);
  }
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  evictionDelayMillis=mapConfig.getEvictionDelaySeconds() * 1000L;
  maxIdle=mapConfig.getMaxIdleSeconds() * 1000L;
  evictionPolicy=EvictionPolicy.valueOf(mapConfig.getEvictionPolicy());
  if (evictionPolicy == EvictionPolicy.NONE) {
    maxSize=Integer.MAX_VALUE;
    evictionComparator=null;
  }
 else {
    maxSize=(mapConfig.getMaxSize() == 0) ? MapConfig.DEFAULT_MAX_SIZE : mapConfig.getMaxSize();
    if (evictionPolicy == EvictionPolicy.LRU) {
      evictionComparator=LRU_COMPARATOR;
    }
 else {
      evictionComparator=LFU_COMPARATOR;
    }
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100f;
  instanceType=ConcurrentMapManager.getInstanceType(name);
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  MapStore storeTemp=null;
  MapLoader loaderTemp=null;
  int writeDelaySeconds=-1;
  if (!node.isSuperClient() && mapStoreConfig != null && mapStoreConfig.isEnabled()) {
    try {
      Object storeInstance=mapStoreConfig.getImplementation();
      if (storeInstance == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeInstance=Serializer.classForName(node.getConfig().getClassLoader(),mapStoreClassName).newInstance();
      }
      if (storeInstance instanceof MapLoader) {
        loaderTemp=(MapLoader)storeInstance;
      }
      if (storeInstance instanceof MapStore) {
        storeTemp=(MapStore)storeInstance;
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
  }
  if (!node.isSuperClient() && evictionPolicy == EvictionPolicy.NONE && instanceType == Instance.InstanceType.MAP) {
    locallyOwnedMap=new LocallyOwnedMap(localMapStats);
    concurrentMapManager.mapLocallyOwnedMaps.put(name,locallyOwnedMap);
  }
 else {
    locallyOwnedMap=null;
  }
  writeDelayMillis=(writeDelaySeconds == -1) ? -1L : writeDelaySeconds * 1000L;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + writeDelaySeconds;
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  loader=loaderTemp;
  store=storeTemp;
  NearCacheConfig nearCacheConfig=mapConfig.getNearCacheConfig();
  if (nearCacheConfig == null) {
    mapNearCache=null;
  }
 else {
    mapNearCache=new MapNearCache(this,SortedHashMap.getOrderingTypeByName(mapConfig.getEvictionPolicy()),nearCacheConfig.getMaxSize(),nearCacheConfig.getTimeToLiveSeconds() * 1000L,nearCacheConfig.getMaxIdleSeconds() * 1000L,nearCacheConfig.isInvalidateOnChange());
    concurrentMapManager.mapCaches.put(name,mapNearCache);
  }
  this.creationTime=System.currentTimeMillis();
}",0.9089595375722545
50448,"public static void main(String[] args){
  if (args != null && args.length > 0) {
    for (    String arg : args) {
      arg=arg.trim();
      if (arg.startsWith(""String_Node_Str"")) {
        THREAD_COUNT=Integer.parseInt(arg.substring(1));
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        ENTRY_COUNT=Integer.parseInt(arg.substring(1));
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        VALUE_SIZE=Integer.parseInt(arg.substring(1));
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        GET_PERCENTAGE=Integer.parseInt(arg.substring(1));
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        PUT_PERCENTAGE=Integer.parseInt(arg.substring(1));
      }
    }
  }
 else {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + THREAD_COUNT);
  System.out.println(""String_Node_Str"" + ENTRY_COUNT);
  System.out.println(""String_Node_Str"" + VALUE_SIZE);
  System.out.println(""String_Node_Str"" + GET_PERCENTAGE);
  System.out.println(""String_Node_Str"" + PUT_PERCENTAGE);
  System.out.println(""String_Node_Str"" + (100 - (PUT_PERCENTAGE + GET_PERCENTAGE)));
  ExecutorService es=Executors.newFixedThreadPool(THREAD_COUNT);
  for (int i=0; i < THREAD_COUNT; i++) {
    es.submit(new Runnable(){
      public void run(){
        IMap<String,byte[]> map=Hazelcast.getMap(""String_Node_Str"");
        while (true) {
          int key=(int)(Math.random() * ENTRY_COUNT);
          int operation=((int)(Math.random() * 100));
          if (operation < GET_PERCENTAGE) {
            map.get(String.valueOf(key));
          }
 else           if (operation < GET_PERCENTAGE + PUT_PERCENTAGE) {
            map.put(String.valueOf(key),new byte[VALUE_SIZE]);
          }
 else {
            map.remove(String.valueOf(key));
          }
        }
      }
    }
);
  }
  Executors.newSingleThreadExecutor().submit(new Runnable(){
    public void run(){
      while (true) {
        try {
          Thread.sleep(STATS_SECONDS * 1000);
          System.out.println(""String_Node_Str"" + Hazelcast.getCluster().getMembers().size());
          IMap<String,byte[]> map=Hazelcast.getMap(""String_Node_Str"");
          MapOperationStats mapOpStats=map.getLocalMapStats().getOperationStats();
          long period=((mapOpStats.getPeriodEnd() - mapOpStats.getPeriodStart()) / 1000);
          if (period == 0) {
            continue;
          }
          System.out.println(mapOpStats);
          System.out.println(""String_Node_Str"" + mapOpStats.total() / period);
        }
 catch (        Exception ignored) {
        }
      }
    }
  }
);
}","public static void main(String[] args){
  if (args != null && args.length > 0) {
    for (    String arg : args) {
      arg=arg.trim();
      if (arg.startsWith(""String_Node_Str"")) {
        THREAD_COUNT=Integer.parseInt(arg.substring(1));
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        ENTRY_COUNT=Integer.parseInt(arg.substring(1));
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        VALUE_SIZE=Integer.parseInt(arg.substring(1));
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        GET_PERCENTAGE=Integer.parseInt(arg.substring(1));
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        PUT_PERCENTAGE=Integer.parseInt(arg.substring(1));
      }
    }
  }
 else {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + THREAD_COUNT);
  System.out.println(""String_Node_Str"" + ENTRY_COUNT);
  System.out.println(""String_Node_Str"" + VALUE_SIZE);
  System.out.println(""String_Node_Str"" + GET_PERCENTAGE);
  System.out.println(""String_Node_Str"" + PUT_PERCENTAGE);
  System.out.println(""String_Node_Str"" + (100 - (PUT_PERCENTAGE + GET_PERCENTAGE)));
  ExecutorService es=Executors.newFixedThreadPool(THREAD_COUNT);
  for (int i=0; i < THREAD_COUNT; i++) {
    es.submit(new Runnable(){
      public void run(){
        IMap<String,byte[]> map=Hazelcast.getMap(""String_Node_Str"");
        while (true) {
          int key=(int)(Math.random() * ENTRY_COUNT);
          int operation=((int)(Math.random() * 100));
          if (operation < GET_PERCENTAGE) {
            map.get(String.valueOf(key));
          }
 else           if (operation < GET_PERCENTAGE + PUT_PERCENTAGE) {
            map.put(String.valueOf(key),new byte[VALUE_SIZE]);
          }
 else {
            map.remove(String.valueOf(key));
          }
        }
      }
    }
);
  }
  Executors.newSingleThreadExecutor().submit(new Runnable(){
    public void run(){
      while (true) {
        try {
          Thread.sleep(STATS_SECONDS * 1000);
          System.out.println(""String_Node_Str"" + Hazelcast.getCluster().getMembers().size());
          IMap<String,byte[]> map=Hazelcast.getMap(""String_Node_Str"");
          MapOperationStats mapOpStats=map.getLocalMapStats().getOperationStats();
          long period=((mapOpStats.getPeriodEnd() - mapOpStats.getPeriodStart()) / 1000);
          if (period == 0) {
            continue;
          }
          System.out.println(mapOpStats);
          System.out.println(""String_Node_Str"" + mapOpStats.total() / period);
        }
 catch (        InterruptedException ignored) {
          return;
        }
      }
    }
  }
);
}",0.9947416137805984
50449,"public void run(){
  while (true) {
    try {
      Thread.sleep(STATS_SECONDS * 1000);
      System.out.println(""String_Node_Str"" + Hazelcast.getCluster().getMembers().size());
      IMap<String,byte[]> map=Hazelcast.getMap(""String_Node_Str"");
      MapOperationStats mapOpStats=map.getLocalMapStats().getOperationStats();
      long period=((mapOpStats.getPeriodEnd() - mapOpStats.getPeriodStart()) / 1000);
      if (period == 0) {
        continue;
      }
      System.out.println(mapOpStats);
      System.out.println(""String_Node_Str"" + mapOpStats.total() / period);
    }
 catch (    Exception ignored) {
    }
  }
}","public void run(){
  while (true) {
    try {
      Thread.sleep(STATS_SECONDS * 1000);
      System.out.println(""String_Node_Str"" + Hazelcast.getCluster().getMembers().size());
      IMap<String,byte[]> map=Hazelcast.getMap(""String_Node_Str"");
      MapOperationStats mapOpStats=map.getLocalMapStats().getOperationStats();
      long period=((mapOpStats.getPeriodEnd() - mapOpStats.getPeriodStart()) / 1000);
      if (period == 0) {
        continue;
      }
      System.out.println(mapOpStats);
      System.out.println(""String_Node_Str"" + mapOpStats.total() / period);
    }
 catch (    InterruptedException ignored) {
      return;
    }
  }
}",0.9803613511390415
50450,"private String encodeURL(final String url,final String sessionURLPhrase){
  if (url != null || req == null || req.isRequestedSessionIdFromCookie()) {
    final int prefix=url.indexOf(sessionURLPhrase);
    if (prefix != -1) {
      int suffix=url.indexOf(""String_Node_Str"",prefix);
      if (suffix < 0)       suffix=url.indexOf(""String_Node_Str"",prefix);
      if (suffix <= prefix)       return url.substring(0,prefix);
      return url.substring(0,prefix) + url.substring(suffix);
    }
    return url;
  }
  final HazelSession session=req.getSession(false);
  if (session == null)   return url;
  if (!session.valid.get())   return url;
  final String id=session.getId();
  final int prefix=url.indexOf(sessionURLPhrase);
  if (prefix != -1) {
    int suffix=url.indexOf(""String_Node_Str"",prefix);
    if (suffix < 0)     suffix=url.indexOf(""String_Node_Str"",prefix);
    if (suffix <= prefix)     return url.substring(0,prefix + sessionURLPhrase.length()) + id;
    return url.substring(0,prefix + sessionURLPhrase.length()) + id + url.substring(suffix);
  }
  int suffix=url.indexOf('?');
  if (suffix < 0)   suffix=url.indexOf('#');
  if (suffix < 0)   return url + sessionURLPhrase + id;
  return url.substring(0,suffix) + sessionURLPhrase + id+ url.substring(suffix);
}","private String encodeURL(final String url,final String sessionURLPhrase){
  if (url == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (url != null || req == null || req.isRequestedSessionIdFromCookie()) {
    final int prefix=url.indexOf(sessionURLPhrase);
    if (prefix != -1) {
      int suffix=url.indexOf(""String_Node_Str"",prefix);
      if (suffix < 0)       suffix=url.indexOf(""String_Node_Str"",prefix);
      if (suffix <= prefix)       return url.substring(0,prefix);
      return url.substring(0,prefix) + url.substring(suffix);
    }
    return url;
  }
  final HazelSession session=req.getSession(false);
  if (session == null)   return url;
  if (!session.valid.get())   return url;
  final String id=session.getId();
  final int prefix=url.indexOf(sessionURLPhrase);
  if (prefix != -1) {
    int suffix=url.indexOf(""String_Node_Str"",prefix);
    if (suffix < 0)     suffix=url.indexOf(""String_Node_Str"",prefix);
    if (suffix <= prefix)     return url.substring(0,prefix + sessionURLPhrase.length()) + id;
    return url.substring(0,prefix + sessionURLPhrase.length()) + id + url.substring(suffix);
  }
  int suffix=url.indexOf('?');
  if (suffix < 0)   suffix=url.indexOf('#');
  if (suffix < 0)   return url + sessionURLPhrase + id;
  return url.substring(0,suffix) + sessionURLPhrase + id+ url.substring(suffix);
}",0.969650986342944
50451,"public int getBlockId(Data key){
  int hash=key.hashCode();
  int result=Math.abs(hash) % PARTITION_COUNT;
  if (result < 0) {
    result=0;
  }
  return result;
}","public int getBlockId(Data key){
  int hash=key.hashCode();
  return (hash == Integer.MIN_VALUE) ? 0 : Math.abs(hash) % PARTITION_COUNT;
}",0.6644518272425249
50452,"int random(int from,int to){
  double diff=(to - from);
  return from+=(diff * Math.random());
}","int random(int from,int to){
  double diff=(to - from);
  return (int)(diff * Math.random() + from);
}",0.9090909090909092
50453,"final boolean evict(Request req){
  Record record=getRecord(req.key);
  if (record != null && record.isEvictable()) {
    if (ownerForSure(record)) {
      if (req.operation == CONCURRENT_MAP_EVICT_INTERNAL && record.isActive()) {
        return false;
      }
      concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_EVICTED,record.getKey(),record.getValue(),record.getMapListeners());
      record.setValue(null);
      markAsRemoved(record);
      return true;
    }
  }
  return false;
}","final boolean evict(Request req){
  Record record=getRecord(req.key);
  if (record != null && record.isEvictable()) {
    if (ownerForSure(record)) {
      concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_EVICTED,record.getKey(),record.getValue(),record.getMapListeners());
      record.setValue(null);
      markAsRemoved(record);
      return true;
    }
  }
  return false;
}",0.6316939890710382
50454,"void startEviction(boolean force){
  long now=System.currentTimeMillis();
  if (!force && ((now - lastEvictionTime) < evictionDelayMillis)) {
    return;
  }
  lastEvictionTime=now;
  List<Data> lsKeysToEvict=null;
  if (evictionPolicy == SortedHashMap.OrderingType.NONE) {
    if (ttl != 0 || maxIdle != 0 || ttlPerRecord) {
      Collection<Record> values=mapRecords.values();
      for (      Record record : values) {
        if (record.isActive() && !record.isValid(now)) {
          if (record.isEvictable()) {
            if (lsKeysToEvict == null) {
              lsKeysToEvict=new ArrayList<Data>(100);
            }
            markAsRemoved(record);
            lsKeysToEvict.add(record.getKey());
          }
        }
 else {
          break;
        }
      }
    }
  }
 else {
    Collection<Record> records=mapRecords.values();
    int numberOfRecordsToEvict=(int)(ownedRecords.size() * evictionRate);
    int evictedCount=0;
    loopRecords:     for (    Record record : records) {
      if (record.isActive() && record.isEvictable()) {
        if (lsKeysToEvict == null) {
          lsKeysToEvict=new ArrayList<Data>(numberOfRecordsToEvict);
        }
        markAsRemoved(record);
        lsKeysToEvict.add(record.getKey());
        if (++evictedCount >= numberOfRecordsToEvict) {
          break loopRecords;
        }
      }
    }
  }
  if (lsKeysToEvict != null && lsKeysToEvict.size() > 0) {
    for (    final Data key : lsKeysToEvict) {
      concurrentMapManager.evictAsync(getName(),key);
    }
  }
}","void startEviction(boolean force){
  long now=System.currentTimeMillis();
  if (!force && ((now - lastEvictionTime) < evictionDelayMillis)) {
    return;
  }
  lastEvictionTime=now;
  List<Record> lsRecordsToEvict=null;
  if (evictionPolicy == SortedHashMap.OrderingType.NONE) {
    if (ttl != 0 || maxIdle != 0 || ttlPerRecord) {
      Collection<Record> values=mapRecords.values();
      for (      Record record : values) {
        if (ownedRecords.contains(record) && record.isActive() && !record.isValid(now)) {
          if (record.isEvictable()) {
            if (lsRecordsToEvict == null) {
              lsRecordsToEvict=new ArrayList<Record>(100);
            }
            lsRecordsToEvict.add(record);
          }
        }
      }
    }
  }
 else {
    Collection<Record> records=mapRecords.values();
    int numberOfRecordsToEvict=(int)(ownedRecords.size() * evictionRate);
    int evictedCount=0;
    loopRecords:     for (    Record record : records) {
      if (ownedRecords.contains(record) && record.isActive() && record.isEvictable()) {
        if (lsRecordsToEvict == null) {
          lsRecordsToEvict=new ArrayList<Record>(numberOfRecordsToEvict);
        }
        lsRecordsToEvict.add(record);
        if (++evictedCount >= numberOfRecordsToEvict) {
          break loopRecords;
        }
      }
    }
  }
  if (lsRecordsToEvict != null && lsRecordsToEvict.size() > 0) {
    for (    final Record recordToEvict : lsRecordsToEvict) {
      markAsRemoved(recordToEvict);
      concurrentMapManager.evictAsync(recordToEvict.getName(),recordToEvict.getKey());
    }
  }
}",0.8187059577194107
50455,"@Test(timeout=60000) public void testMapMaxSize() throws Exception {
  Config c=new XmlConfigBuilder().build();
  MapConfig mapConfig=new MapConfig();
  mapConfig.setEvictionPolicy(""String_Node_Str"");
  mapConfig.setMaxSize(3);
  c.getMapMapConfigs().put(""String_Node_Str"",mapConfig);
  HazelcastInstance h=Hazelcast.newHazelcastInstance(c);
  IMap map=h.getMap(""String_Node_Str"");
  for (int i=0; i < 3; i++) {
    map.put(String.valueOf(i),String.valueOf(i));
  }
  assertEquals(3,map.size());
  for (int i=3; i < 10; i++) {
    map.put(String.valueOf(i),String.valueOf(i));
    assertEquals(3,map.size());
  }
}","@Test(timeout=60000) public void testMapMaxSize() throws Exception {
  Config c=new XmlConfigBuilder().build();
  MapConfig mapConfig=new MapConfig();
  mapConfig.setEvictionPolicy(""String_Node_Str"");
  mapConfig.setMaxSize(3);
  c.getMapMapConfigs().put(""String_Node_Str"",mapConfig);
  HazelcastInstance h=Hazelcast.newHazelcastInstance(c);
  IMap map=h.getMap(""String_Node_Str"");
  for (int i=0; i < 10; i++) {
    map.put(String.valueOf(i),String.valueOf(i));
    int expectedSize=(i < 3) ? i + 1 : 3;
    assertEquals(expectedSize,map.size());
  }
}",0.8517566409597258
50456,"public Record copy(){
  return new Record(factory,name,blockId,key.get(),value.get(),getRemainingTTL(),getRemainingIdle(),id);
}","public Record copy(){
  Record recordCopy=new Record(factory,name,blockId,key.get(),value.get(),getRemainingTTL(),getRemainingIdle(),id);
  recordCopy.setIndexes(indexes,indexTypes);
  recordCopy.setValueHash(valueHash);
  recordCopy.setLockCount(lockCount);
  recordCopy.setLockAddress(lockAddress);
  recordCopy.setLockThreadId(lockThreadId);
  recordCopy.setMultiValues(lsMultiValues);
  recordCopy.setCopyCount(copyCount);
  recordCopy.setVersion(getVersion());
  return recordCopy;
}",0.3928571428571428
50457,"public void start(){
  logger.log(Level.FINEST,""String_Node_Str"" + String.valueOf(completelyShutdown));
  if (completelyShutdown)   return;
  Thread inThread=new Thread(threadGroup,inSelector,""String_Node_Str"");
  inThread.setContextClassLoader(config.getClassLoader());
  inThread.setPriority(7);
  logger.log(Level.FINEST,""String_Node_Str"" + inThread.getName());
  inThread.start();
  Thread outThread=new Thread(threadGroup,outSelector,""String_Node_Str"");
  outThread.setContextClassLoader(config.getClassLoader());
  outThread.setPriority(7);
  logger.log(Level.FINEST,""String_Node_Str"" + outThread.getName());
  outThread.start();
  serviceThread=new Thread(threadGroup,clusterService,""String_Node_Str"");
  serviceThread.setContextClassLoader(config.getClassLoader());
  serviceThread.setPriority(8);
  logger.log(Level.FINEST,""String_Node_Str"" + serviceThread.getName());
  serviceThread.start();
  queryThread=new Thread(threadGroup,queryService,""String_Node_Str"");
  queryThread.setContextClassLoader(config.getClassLoader());
  queryThread.setPriority(6);
  logger.log(Level.FINEST,""String_Node_Str"" + queryThread.getName());
  queryThread.start();
  if (config.getNetworkConfig().getJoin().getMulticastConfig().isEnabled()) {
    final Thread multicastServiceThread=new Thread(threadGroup,multicastService,""String_Node_Str"");
    multicastServiceThread.start();
    multicastServiceThread.setContextClassLoader(config.getClassLoader());
    multicastServiceThread.setPriority(6);
  }
  setActive(true);
  if (!completelyShutdown) {
    logger.log(Level.FINEST,""String_Node_Str"");
    Runtime.getRuntime().addShutdownHook(shutdownHookThread);
  }
  logger.log(Level.FINEST,""String_Node_Str"");
  join();
}","public void start(){
  logger.log(Level.FINEST,""String_Node_Str"" + String.valueOf(completelyShutdown));
  if (completelyShutdown)   return;
  Thread inThread=new Thread(threadGroup,inSelector,""String_Node_Str"");
  inThread.setPriority(7);
  logger.log(Level.FINEST,""String_Node_Str"" + inThread.getName());
  inThread.start();
  Thread outThread=new Thread(threadGroup,outSelector,""String_Node_Str"");
  outThread.setPriority(7);
  logger.log(Level.FINEST,""String_Node_Str"" + outThread.getName());
  outThread.start();
  serviceThread=new Thread(threadGroup,clusterService,""String_Node_Str"");
  serviceThread.setPriority(8);
  logger.log(Level.FINEST,""String_Node_Str"" + serviceThread.getName());
  serviceThread.start();
  queryThread=new Thread(threadGroup,queryService,""String_Node_Str"");
  queryThread.setPriority(6);
  logger.log(Level.FINEST,""String_Node_Str"" + queryThread.getName());
  queryThread.start();
  if (config.getNetworkConfig().getJoin().getMulticastConfig().isEnabled()) {
    final Thread multicastServiceThread=new Thread(threadGroup,multicastService,""String_Node_Str"");
    multicastServiceThread.start();
    multicastServiceThread.setPriority(6);
  }
  setActive(true);
  if (!completelyShutdown) {
    logger.log(Level.FINEST,""String_Node_Str"");
    Runtime.getRuntime().addShutdownHook(shutdownHookThread);
  }
  logger.log(Level.FINEST,""String_Node_Str"");
  join();
}",0.896973599484868
50458,"void completeMigration(int blockId){
  Block blockReal=blocks[blockId];
  if (blockReal.isMigrating()) {
    fireMigrationEvent(false,new Block(blockReal));
    blockReal.setOwner(blockReal.getMigrationAddress());
    blockReal.setMigrationAddress(null);
    logger.log(Level.FINEST,""String_Node_Str"" + blockReal);
  }
}","void completeMigration(int blockId){
  Block blockReal=blocks[blockId];
  if (blockReal != null && blockReal.isMigrating()) {
    fireMigrationEvent(false,new Block(blockReal));
    blockReal.setOwner(blockReal.getMigrationAddress());
    blockReal.setMigrationAddress(null);
    logger.log(Level.FINEST,""String_Node_Str"" + blockReal);
  }
}",0.9682299546142208
50459,"private PredicateBuilder addPredicate(Predicate predicate){
  qb.lsPredicates.add(predicate);
  qb.exp=null;
  return qb;
}","private PredicateBuilder addPredicate(Predicate predicate){
  qb.lsPredicates.add(predicate);
  return qb;
}",0.935064935064935
50460,"Set<T> getSubRecords(QueryContext queryContext,boolean equal,boolean lessThan,long value){
  if (mapIndex instanceof HashSet)   return null;
  TreeMap<Long,Set<T>> treeMap=(TreeMap<Long,Set<T>>)mapIndex;
  Set<T> results=new HashSet<T>();
  Map<Long,Set<T>> sub=(lessThan) ? treeMap.headMap(value) : treeMap.tailMap(value);
  Set<Map.Entry<Long,Set<T>>> entries=sub.entrySet();
  for (  Map.Entry<Long,Set<T>> entry : entries) {
    if (equal || entry.getKey() != value) {
      Set<T> values=entry.getValue();
      if (queryContext.getIndexedPredicateCount() > 1 && values.size() > 100) {
        return null;
      }
      results.addAll(values);
    }
    if (queryContext.getIndexedPredicateCount() > 1 && results.size() > 100) {
      return null;
    }
  }
  return results;
}","Set<T> getSubRecords(QueryContext queryContext,boolean equal,boolean lessThan,long value){
  if (mapIndex instanceof HashSet)   return null;
  TreeMap<Long,Set<T>> treeMap=(TreeMap<Long,Set<T>>)mapIndex;
  Set<T> results=new HashSet<T>();
  Map<Long,Set<T>> sub=(lessThan) ? treeMap.headMap(value) : treeMap.tailMap(value);
  Set<Map.Entry<Long,Set<T>>> entries=sub.entrySet();
  for (  Map.Entry<Long,Set<T>> entry : entries) {
    if (equal || entry.getKey() != value) {
      Set<T> values=entry.getValue();
      if (queryContext.getIndexedPredicateCount() > 1 && values.size() > 100) {
        return null;
      }
      results.addAll(values);
    }
    if (queryContext.getIndexedPredicateCount() > 1 && results.size() > 100) {
      return null;
    }
  }
  if (lessThan && equal) {
    Set<T> recs=treeMap.get(value);
    if (recs != null) {
      results.addAll(recs);
    }
  }
  return results;
}",0.9071555292726198
50461,"/** 
 * from and to should be included
 * @param from from value (included)
 * @param to   to value (included
 * @return matching record set
 */
Set<T> getSubRecordsBetween(QueryContext queryContext,long from,long to){
  if (mapIndex instanceof HashSet)   return null;
  TreeMap<Long,Set<T>> treeMap=(TreeMap<Long,Set<T>>)mapIndex;
  Set<T> results=new HashSet<T>();
  Collection<Set<T>> sub=treeMap.subMap(from,to).values();
  for (  Set<T> records : sub) {
    if (queryContext.getIndexedPredicateCount() > 1 && sub.size() > 100) {
      return null;
    }
    results.addAll(records);
    if (queryContext.getIndexedPredicateCount() > 1 && results.size() > 100) {
      return null;
    }
  }
  Set<T> lastSet=treeMap.get(to);
  if (lastSet != null) {
    results.addAll(lastSet);
  }
  return results;
}","/** 
 * from and to should be included
 * @param queryContext query context
 * @param from from value (included)
 * @param to   to value (included
 * @return matching record set
 */
Set<T> getSubRecordsBetween(QueryContext queryContext,long from,long to){
  if (mapIndex instanceof HashSet)   return null;
  TreeMap<Long,Set<T>> treeMap=(TreeMap<Long,Set<T>>)mapIndex;
  Set<T> results=new HashSet<T>();
  Collection<Set<T>> sub=treeMap.subMap(from,to).values();
  for (  Set<T> records : sub) {
    if (queryContext.getIndexedPredicateCount() > 1 && sub.size() > 100) {
      return null;
    }
    results.addAll(records);
    if (queryContext.getIndexedPredicateCount() > 1 && results.size() > 100) {
      return null;
    }
  }
  Set<T> lastSet=treeMap.get(to);
  if (lastSet != null) {
    results.addAll(lastSet);
  }
  return results;
}",0.977589339794064
50462,"@Test public void testPut(){
  Config config=new XmlConfigBuilder().build();
  FactoryImpl mockFactory=mock(FactoryImpl.class);
  Node node=new Node(mockFactory,config);
  node.serviceThread=Thread.currentThread();
  Object key=""String_Node_Str"";
  Object value=""String_Node_Str"";
  CMap cmap=new CMap(node.concurrentMapManager,""String_Node_Str"");
  Request putRequest=new Request();
  putRequest.setLocal(ClusterOperation.CONCURRENT_MAP_PUT,null,toData(key),toData(value),-1,-1,-1,null);
  cmap.put(putRequest);
  assertTrue(cmap.mapRecords.containsKey(toData(key)));
  Request getRequest=new Request();
  getRequest.setLocal(ClusterOperation.CONCURRENT_MAP_GET,null,toData(key),null,-1,-1,-1,null);
  Data actualValue=cmap.get(getRequest);
  assertThat(toObject(actualValue),equalTo(value));
}","@Test public void testPut(){
  Config config=new XmlConfigBuilder().build();
  FactoryImpl mockFactory=mock(FactoryImpl.class);
  Node node=new Node(mockFactory,config);
  node.serviceThread=Thread.currentThread();
  CMap cmap=new CMap(node.concurrentMapManager,""String_Node_Str"");
  Object key=""String_Node_Str"";
  Object value=""String_Node_Str"";
  Data dKey=toData(key);
  Data dValue=toData(value);
  cmap.put(newPutRequest(dKey,dValue));
  assertTrue(cmap.mapRecords.containsKey(toData(key)));
  Data actualValue=cmap.get(newGetRequest(dKey));
  assertThat(toObject(actualValue),equalTo(value));
  assertEquals(1,cmap.ownedRecords.size());
  Record record=cmap.getRecord(dKey);
  assertNotNull(record);
  assertTrue(record.isActive());
  assertTrue(record.isValid());
}",0.4502551020408163
50463,"@Test public void testEqual(){
  Object value=new QueryTest.Employee(""String_Node_Str"",34,true,10D);
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(Predicates.equal(new DummyExpression(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.equal(new DummyExpression(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.equal(new DummyExpression(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.equal(new DummyExpression(true),Boolean.TRUE).apply(null));
  assertTrue(Predicates.equal(new DummyExpression(Boolean.TRUE),true).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(Boolean.FALSE),true).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(15.23),15.22).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(15.23),15.22).apply(null));
  assertTrue(Predicates.equal(new DummyExpression(15.22),15.22).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(15),16).apply(null));
  assertTrue(Predicates.greaterThan(new DummyExpression(6),5).apply(null));
  assertFalse(Predicates.greaterThan(new DummyExpression(4),5).apply(null));
  assertFalse(Predicates.greaterThan(new DummyExpression(5),5).apply(null));
  assertTrue(Predicates.greaterEqual(new DummyExpression(5),5).apply(null));
  assertTrue(Predicates.lessThan(new DummyExpression(6),7).apply(null));
  assertFalse(Predicates.lessThan(new DummyExpression(4),3).apply(null));
  assertFalse(Predicates.lessThan(new DummyExpression(4),4).apply(null));
  assertTrue(Predicates.lessEqual(new DummyExpression(4),4).apply(null));
  assertTrue(Predicates.between(new DummyExpression(5),4,6).apply(null));
  assertTrue(Predicates.between(new DummyExpression(5),5,6).apply(null));
  assertFalse(Predicates.between(new DummyExpression(5),6,7).apply(null));
  assertTrue(Predicates.in(new DummyExpression(5),4,7,8,5).apply(null));
  assertTrue(Predicates.in(new DummyExpression(5),5,7,8).apply(null));
  assertFalse(Predicates.in(new DummyExpression(5),6,7,8).apply(null));
  assertFalse(Predicates.in(new DummyExpression(9),6,7,8).apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
}","@Test public void testEqual(){
  Object value=new QueryTest.Employee(""String_Node_Str"",34,true,10D);
  assertTrue(new SqlPredicate(""String_Node_Str"" + 20 + ""String_Node_Str""+ 40+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 20 + ""String_Node_Str""+ 34+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"" + 34 + ""String_Node_Str""+ 35+ ""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",value)));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertFalse(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(new SqlPredicate(""String_Node_Str"").apply(createEntry(""String_Node_Str"",new QueryTest.Employee(""String_Node_Str"",34,true,10D))));
  assertTrue(Predicates.equal(new DummyExpression(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.equal(new DummyExpression(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.equal(new DummyExpression(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.equal(new DummyExpression(true),Boolean.TRUE).apply(null));
  assertTrue(Predicates.equal(new DummyExpression(Boolean.TRUE),true).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(Boolean.FALSE),true).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(15.23),15.22).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(15.23),15.22).apply(null));
  assertTrue(Predicates.equal(new DummyExpression(15.22),15.22).apply(null));
  assertFalse(Predicates.equal(new DummyExpression(15),16).apply(null));
  assertTrue(Predicates.greaterThan(new DummyExpression(6),5).apply(null));
  assertFalse(Predicates.greaterThan(new DummyExpression(4),5).apply(null));
  assertFalse(Predicates.greaterThan(new DummyExpression(5),5).apply(null));
  assertTrue(Predicates.greaterEqual(new DummyExpression(5),5).apply(null));
  assertTrue(Predicates.lessThan(new DummyExpression(6),7).apply(null));
  assertFalse(Predicates.lessThan(new DummyExpression(4),3).apply(null));
  assertFalse(Predicates.lessThan(new DummyExpression(4),4).apply(null));
  assertTrue(Predicates.lessEqual(new DummyExpression(4),4).apply(null));
  assertTrue(Predicates.between(new DummyExpression(5),4,6).apply(null));
  assertTrue(Predicates.between(new DummyExpression(5),5,6).apply(null));
  assertFalse(Predicates.between(new DummyExpression(5),6,7).apply(null));
  assertTrue(Predicates.in(new DummyExpression(5),4,7,8,5).apply(null));
  assertTrue(Predicates.in(new DummyExpression(5),5,7,8).apply(null));
  assertFalse(Predicates.in(new DummyExpression(5),6,7,8).apply(null));
  assertFalse(Predicates.in(new DummyExpression(9),6,7,8).apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertTrue(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
  assertFalse(Predicates.like(new DummyExpression<String>(""String_Node_Str""),""String_Node_Str"").apply(null));
}",0.9448202207191172
50464,"public void doFunctionalQueryTest(IMap imap){
  imap.put(""String_Node_Str"",new Employee(""String_Node_Str"",33,false,14.56));
  imap.put(""String_Node_Str"",new Employee(""String_Node_Str"",23,true,15.00));
  for (int i=3; i < 103; i++) {
    imap.put(String.valueOf(i),new Employee(""String_Node_Str"" + i,i % 60,((i % 2) == 1),Double.valueOf(i)));
  }
  Set<Map.Entry> entries=imap.entrySet();
  assertEquals(102,entries.size());
  int itCount=0;
  for (  Map.Entry entry : entries) {
    Employee c=(Employee)entry.getValue();
    itCount++;
  }
  assertEquals(102,itCount);
  EntryObject e=new PredicateBuilder().getEntryObject();
  Predicate predicate=e.is(""String_Node_Str"").and(e.get(""String_Node_Str"").equal(23));
  entries=imap.entrySet(predicate);
  assertEquals(3,entries.size());
  for (  Map.Entry entry : entries) {
    Employee c=(Employee)entry.getValue();
    assertEquals(c.getAge(),23);
    assertTrue(c.isActive());
  }
  imap.remove(""String_Node_Str"");
  entries=imap.entrySet(predicate);
  assertEquals(2,entries.size());
  for (  Map.Entry entry : entries) {
    Employee c=(Employee)entry.getValue();
    assertEquals(c.getAge(),23);
    assertTrue(c.isActive());
  }
}","public void doFunctionalQueryTest(IMap imap){
  imap.put(""String_Node_Str"",new Employee(""String_Node_Str"",33,false,14.56));
  imap.put(""String_Node_Str"",new Employee(""String_Node_Str"",23,true,15.00));
  for (int i=3; i < 103; i++) {
    imap.put(String.valueOf(i),new Employee(""String_Node_Str"" + i,i % 60,((i % 2) == 1),Double.valueOf(i)));
  }
  Set<Map.Entry> entries=imap.entrySet();
  assertEquals(102,entries.size());
  int itCount=0;
  for (  Map.Entry entry : entries) {
    Employee c=(Employee)entry.getValue();
    itCount++;
  }
  assertEquals(102,itCount);
  EntryObject e=new PredicateBuilder().getEntryObject();
  Predicate predicate=e.is(""String_Node_Str"").and(e.get(""String_Node_Str"").equal(23));
  entries=imap.entrySet(predicate);
  assertEquals(3,entries.size());
  for (  Map.Entry entry : entries) {
    Employee c=(Employee)entry.getValue();
    assertEquals(c.getAge(),23);
    assertTrue(c.isActive());
  }
  imap.remove(""String_Node_Str"");
  entries=imap.entrySet(predicate);
  assertEquals(2,entries.size());
  for (  Map.Entry entry : entries) {
    Employee c=(Employee)entry.getValue();
    assertEquals(c.getAge(),23);
    assertTrue(c.isActive());
  }
  entries=imap.entrySet(new SqlPredicate(""String_Node_Str"" + 30 + ""String_Node_Str""+ 40+ ""String_Node_Str""));
  assertEquals(23,entries.size());
  for (  Map.Entry entry : entries) {
    Employee c=(Employee)entry.getValue();
    System.out.println(c);
    assertTrue(c.getAge() >= 30);
    assertTrue(c.getAge() <= 40);
  }
}",0.8794063079777366
50465,"public void memberAdded(MembershipEvent membershipEvent){
  this.clusterMembers.add(membershipEvent.getMember().getInetSocketAddress());
}","public synchronized void memberAdded(MembershipEvent membershipEvent){
  if (!this.clusterMembers.contains(membershipEvent.getMember().getInetSocketAddress())) {
    this.clusterMembers.add(membershipEvent.getMember().getInetSocketAddress());
  }
}",0.7046632124352331
50466,"public void memberRemoved(MembershipEvent membershipEvent){
  this.clusterMembers.remove(membershipEvent.getMember().getInetSocketAddress());
}","public synchronized void memberRemoved(MembershipEvent membershipEvent){
  this.clusterMembers.remove(membershipEvent.getMember().getInetSocketAddress());
}",0.9565217391304348
50467,"public static Object toObject(byte[] bytes){
  ByteArrayInputStream bis=new ByteArrayInputStream(bytes);
  DataInputStream dis=new DataInputStream(bis);
  int type=bis.read();
  try {
    if (type == SERIALIZER_TYPE_DATA) {
      String className=dis.readUTF();
      if (className.equals(""String_Node_Str"")) {
        className=""String_Node_Str"";
      }
 else       if (className.equals(""String_Node_Str"")) {
        className=""String_Node_Str"";
      }
 else       if (className.equals(""String_Node_Str"")) {
        className=""String_Node_Str"";
      }
      DataSerializable data=(DataSerializable)Class.forName(className).newInstance();
      data.readData(dis);
      return data;
    }
 else     if (type == SERIALIZER_TYPE_STRING) {
      StringBuilder result=new StringBuilder();
      while (dis.available() > 0) {
        result.append(dis.readUTF());
      }
      return result.toString();
    }
 else     if (type == SERIALIZER_TYPE_BYTE_ARRAY) {
      int size=dis.readInt();
      byte[] b=new byte[size];
      bis.read(b);
      return b;
    }
 else     if (type == SERIALIZER_TYPE_INTEGER) {
      return dis.readInt();
    }
 else     if (type == SERIALIZER_TYPE_LONG) {
      return dis.readLong();
    }
 else     if (type == SERIALIZER_TYPE_CLASS) {
      return Class.forName(dis.readUTF());
    }
 else     if (type == SERIALIZER_TYPE_OBJECT) {
      ObjectInputStream os=new ObjectInputStream(dis);
      return os.readObject();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}","public static Object toObject(byte[] bytes){
  ByteArrayInputStream bis=new ByteArrayInputStream(bytes);
  DataInputStream dis=new DataInputStream(bis);
  int type=bis.read();
  try {
    if (type == SERIALIZER_TYPE_DATA) {
      String className=dis.readUTF();
      if (className.equals(""String_Node_Str"")) {
        className=""String_Node_Str"";
      }
 else       if (className.equals(""String_Node_Str"")) {
        className=""String_Node_Str"";
      }
 else       if (className.equals(""String_Node_Str"")) {
        className=""String_Node_Str"";
      }
      DataSerializable data=(DataSerializable)Class.forName(className).newInstance();
      data.readData(dis);
      return data;
    }
 else     if (type == SERIALIZER_TYPE_STRING) {
      StringBuilder result=new StringBuilder();
      while (dis.available() > 0) {
        result.append(dis.readUTF());
      }
      return result.toString();
    }
 else     if (type == SERIALIZER_TYPE_BYTE_ARRAY) {
      int size=dis.readInt();
      byte[] b=new byte[size];
      bis.read(b);
      return b;
    }
 else     if (type == SERIALIZER_TYPE_INTEGER) {
      return dis.readInt();
    }
 else     if (type == SERIALIZER_TYPE_LONG) {
      return dis.readLong();
    }
 else     if (type == SERIALIZER_TYPE_CLASS) {
      return Class.forName(dis.readUTF());
    }
 else     if (type == SERIALIZER_TYPE_DATE) {
      return new Date(dis.readLong());
    }
 else     if (type == SERIALIZER_TYPE_BIG_INTEGER) {
      byte[] byts=new byte[dis.readInt()];
      dis.read(byts);
      return new BigInteger(byts);
    }
 else     if (type == SERIALIZER_TYPE_OBJECT) {
      ObjectInputStream os=new ObjectInputStream(dis);
      return os.readObject();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}",0.9247441300421432
50468,"public static byte[] toByte(Object object){
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(bos);
  if (object == null)   return new byte[0];
  try {
    if (object instanceof DataSerializable) {
      dos.writeByte(SERIALIZER_TYPE_DATA);
      dos.writeUTF(object.getClass().getName().replaceFirst(""String_Node_Str"",""String_Node_Str""));
      ((DataSerializable)object).writeData(dos);
    }
 else     if (object instanceof String) {
      String string=(String)object;
      dos.writeByte(SERIALIZER_TYPE_STRING);
      int length=string.length();
      int chunkSize=length / STRING_CHUNK_SIZE + 1;
      for (int i=0; i < chunkSize; i++) {
        int beginIndex=Math.max(0,i * STRING_CHUNK_SIZE - 1);
        int endIndex=Math.min((i + 1) * STRING_CHUNK_SIZE - 1,length);
        dos.writeUTF(string.substring(beginIndex,endIndex));
      }
    }
 else     if (object instanceof byte[]) {
      byte[] bytes=(byte[])object;
      dos.writeByte(SERIALIZER_TYPE_BYTE_ARRAY);
      dos.writeInt(bytes.length);
      dos.write(bytes);
    }
 else     if (object instanceof Integer) {
      dos.writeByte(SERIALIZER_TYPE_INTEGER);
      dos.writeInt((Integer)object);
    }
 else     if (object instanceof Long) {
      dos.writeByte(SERIALIZER_TYPE_LONG);
      dos.writeLong((Long)object);
    }
 else     if (object instanceof Class) {
      dos.writeByte(SERIALIZER_TYPE_CLASS);
      dos.writeUTF(((Class<?>)object).getName());
    }
 else {
      dos.writeByte(SERIALIZER_TYPE_OBJECT);
      ObjectOutputStream os=new ObjectOutputStream(dos);
      os.writeObject(object);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return bos.toByteArray();
}","public static byte[] toByte(Object object){
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(bos);
  if (object == null)   return new byte[0];
  try {
    if (object instanceof DataSerializable) {
      dos.writeByte(SERIALIZER_TYPE_DATA);
      dos.writeUTF(object.getClass().getName().replaceFirst(""String_Node_Str"",""String_Node_Str""));
      ((DataSerializable)object).writeData(dos);
    }
 else     if (object instanceof String) {
      String string=(String)object;
      dos.writeByte(SERIALIZER_TYPE_STRING);
      int length=string.length();
      int chunkSize=length / STRING_CHUNK_SIZE + 1;
      for (int i=0; i < chunkSize; i++) {
        int beginIndex=Math.max(0,i * STRING_CHUNK_SIZE - 1);
        int endIndex=Math.min((i + 1) * STRING_CHUNK_SIZE - 1,length);
        dos.writeUTF(string.substring(beginIndex,endIndex));
      }
    }
 else     if (object instanceof byte[]) {
      byte[] bytes=(byte[])object;
      dos.writeByte(SERIALIZER_TYPE_BYTE_ARRAY);
      dos.writeInt(bytes.length);
      dos.write(bytes);
    }
 else     if (object instanceof Integer) {
      dos.writeByte(SERIALIZER_TYPE_INTEGER);
      dos.writeInt((Integer)object);
    }
 else     if (object instanceof Long) {
      dos.writeByte(SERIALIZER_TYPE_LONG);
      dos.writeLong((Long)object);
    }
 else     if (object instanceof Class) {
      dos.writeByte(SERIALIZER_TYPE_CLASS);
      dos.writeUTF(((Class<?>)object).getName());
    }
 else     if (object instanceof Date) {
      dos.writeByte(SERIALIZER_TYPE_DATE);
      dos.writeLong(((Date)object).getTime());
    }
 else     if (object instanceof BigInteger) {
      dos.writeByte(SERIALIZER_TYPE_BIG_INTEGER);
      byte[] bytes=((BigInteger)object).toByteArray();
      dos.writeInt(bytes.length);
      dos.write(bytes);
    }
 else {
      dos.writeByte(SERIALIZER_TYPE_OBJECT);
      ObjectOutputStream os=new ObjectOutputStream(dos);
      os.writeObject(object);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return bos.toByteArray();
}",0.9077529566360052
50469,"public void addMembershipListener(MembershipListener listener){
}","public void addMembershipListener(MembershipListener listener){
  check(listener);
  if (client.listenerManager.noInstanceListenerRegistered()) {
    Packet request=proxyHelper.createRequestPacket(ClusterOperation.CLIENT_ADD_INSTANCE_LISTENER,null,null);
    Call c=proxyHelper.createCall(request);
    client.listenerManager.addListenerCall(c);
    proxyHelper.doCall(c);
  }
  client.listenerManager.registerMembershipListener(listener);
}",0.2569169960474308
50470,"public static byte[] toByte(Object object){
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(bos);
  if (object == null)   return new byte[0];
  try {
    if (object instanceof DataSerializable) {
      dos.writeByte(SERIALIZER_TYPE_DATA);
      dos.writeUTF(object.getClass().getName().replaceFirst(""String_Node_Str"",""String_Node_Str""));
      ((DataSerializable)object).writeData(dos);
    }
 else     if (object instanceof String) {
      String string=(String)object;
      dos.writeByte(SERIALIZER_TYPE_STRING);
      int length=string.length();
      int chunkSize=length / STRING_CHUNK_SIZE + 1;
      for (int i=0; i < chunkSize; i++) {
        int beginIndex=Math.max(0,i * STRING_CHUNK_SIZE - 1);
        int endIndex=Math.min((i + 1) * STRING_CHUNK_SIZE - 1,length);
        dos.writeUTF(string.substring(beginIndex,endIndex));
      }
    }
 else     if (object instanceof byte[]) {
      byte[] bytes=(byte[])object;
      dos.writeByte(SERIALIZER_TYPE_BYTE_ARRAY);
      bos.write(bytes.length);
      bos.write(bytes);
    }
 else     if (object instanceof Integer) {
      dos.writeByte(SERIALIZER_TYPE_INTEGER);
      dos.writeInt((Integer)object);
    }
 else     if (object instanceof Long) {
      dos.writeByte(SERIALIZER_TYPE_LONG);
      dos.writeLong((Long)object);
    }
 else     if (object instanceof Class) {
      dos.writeByte(SERIALIZER_TYPE_CLASS);
      dos.writeUTF(((Class<?>)object).getName());
    }
 else {
      dos.writeByte(SERIALIZER_TYPE_OBJECT);
      ObjectOutputStream os=new ObjectOutputStream(dos);
      os.writeObject(object);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return bos.toByteArray();
}","public static byte[] toByte(Object object){
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(bos);
  if (object == null)   return new byte[0];
  try {
    if (object instanceof DataSerializable) {
      dos.writeByte(SERIALIZER_TYPE_DATA);
      dos.writeUTF(object.getClass().getName().replaceFirst(""String_Node_Str"",""String_Node_Str""));
      ((DataSerializable)object).writeData(dos);
    }
 else     if (object instanceof String) {
      String string=(String)object;
      dos.writeByte(SERIALIZER_TYPE_STRING);
      int length=string.length();
      int chunkSize=length / STRING_CHUNK_SIZE + 1;
      for (int i=0; i < chunkSize; i++) {
        int beginIndex=Math.max(0,i * STRING_CHUNK_SIZE - 1);
        int endIndex=Math.min((i + 1) * STRING_CHUNK_SIZE - 1,length);
        dos.writeUTF(string.substring(beginIndex,endIndex));
      }
    }
 else     if (object instanceof byte[]) {
      byte[] bytes=(byte[])object;
      dos.writeByte(SERIALIZER_TYPE_BYTE_ARRAY);
      dos.writeInt(bytes.length);
      dos.write(bytes);
    }
 else     if (object instanceof Integer) {
      dos.writeByte(SERIALIZER_TYPE_INTEGER);
      dos.writeInt((Integer)object);
    }
 else     if (object instanceof Long) {
      dos.writeByte(SERIALIZER_TYPE_LONG);
      dos.writeLong((Long)object);
    }
 else     if (object instanceof Class) {
      dos.writeByte(SERIALIZER_TYPE_CLASS);
      dos.writeUTF(((Class<?>)object).getName());
    }
 else {
      dos.writeByte(SERIALIZER_TYPE_OBJECT);
      ObjectOutputStream os=new ObjectOutputStream(dos);
      os.writeObject(object);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return bos.toByteArray();
}",0.9933352651405388
50471,"public void entryUpdated(EntryEvent<K,V> event){
  entryUpdatedLatch.countDown();
  assertEquals(""String_Node_Str"",event.getValue());
  assertEquals(""String_Node_Str"",event.getKey());
}","public void entryUpdated(EntryEvent<K,V> event){
  entryUpdatedLatch.countDown();
}",0.6194029850746269
50472,"public void entryAdded(EntryEvent<K,V> event){
  entryAddLatch.countDown();
  assertEquals(""String_Node_Str"",event.getKey());
}","public void entryAdded(EntryEvent<K,V> event){
  entryAddLatch.countDown();
}",0.7549019607843137
50473,"public void entryRemoved(EntryEvent<K,V> event){
  entryRemovedLatch.countDown();
  assertEquals(""String_Node_Str"",event.getKey());
  assertEquals(""String_Node_Str"",event.getValue());
}","public void entryRemoved(EntryEvent<K,V> event){
  entryRemovedLatch.countDown();
}",0.6194029850746269
50474,"@Test public void destroy(){
  HazelcastClient hClient=getHazelcastClient();
  IMap map=hClient.getMap(""String_Node_Str"");
  for (int i=0; i < 100; i++) {
    assertNull(map.put(i,i));
    assertEquals(i,map.get(i));
  }
  IMap<Integer,Integer> map2=hClient.getMap(""String_Node_Str"");
  assertTrue(map == map2);
  assertTrue(map.getId().equals(map2.getId()));
  map.destroy();
  map2=hClient.getMap(""String_Node_Str"");
  assertFalse(map == map2);
  for (int i=0; i < 100; i++) {
    assertNull(map2.get(i));
  }
}","@Test public void destroy() throws InterruptedException {
  HazelcastClient hClient=getHazelcastClient();
  IMap map=hClient.getMap(""String_Node_Str"");
  for (int i=0; i < 100; i++) {
    assertNull(map.put(i,i));
    assertEquals(i,map.get(i));
  }
  IMap<Integer,Integer> map2=hClient.getMap(""String_Node_Str"");
  assertTrue(map == map2);
  assertTrue(map.getId().equals(map2.getId()));
  map.destroy();
  for (int i=0; i < 100; i++) {
  }
}",0.8661087866108786
50475,"private Long getNewMillion(){
  try {
    DistributedTask<Long> task=new DistributedTask<Long>(new IncrementTask(name,factory));
    factory.executorServiceImpl.execute(task);
    return task.get();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}","private Long getNewMillion(){
  try {
    DistributedTask<Long> task=new DistributedTask<Long>(new IncrementTask(name,factory),name);
    factory.executorServiceImpl.execute(task);
    return task.get();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}",0.9909255898366606
50476,"public long newId(){
  long millionNow=million.get();
  long idAddition=currentId.incrementAndGet();
  if (idAddition >= MILLION) {
synchronized (this) {
      try {
        millionNow=million.get();
        idAddition=currentId.incrementAndGet();
        if (idAddition >= MILLION) {
          Long idMillion=getNewMillion();
          long newMillion=idMillion * MILLION;
          million.set(newMillion);
          currentId.set(0);
        }
        millionNow=million.get();
        idAddition=currentId.incrementAndGet();
      }
 catch (      Throwable t) {
        t.printStackTrace();
      }
    }
  }
  return millionNow + idAddition;
}","public long newId(){
  long idAddition=currentId.incrementAndGet();
  if (idAddition >= MILLION) {
synchronized (this) {
      try {
        idAddition=currentId.get();
        if (idAddition >= MILLION) {
          Long idMillion=getNewMillion();
          long newMillion=idMillion * MILLION;
          million.set(newMillion);
          currentId.set(0L);
        }
        return newId();
      }
 catch (      Throwable t) {
        t.printStackTrace();
      }
    }
  }
  long millionNow=million.get();
  return millionNow + idAddition;
}",0.8063704945515507
50477,"public Object waitAndGetResult(){
  while (true) {
    try {
      Object obj=responses.poll(5,TimeUnit.SECONDS);
      if (obj != null) {
        return obj;
      }
 else       if (node.factory.restarted) {
        reset();
        throw new RuntimeException();
      }
 else       if (!node.active) {
        throw new RuntimeException();
      }
    }
 catch (    InterruptedException e) {
      if (node.factory.restarted) {
        reset();
        throw new RuntimeException();
      }
    }
  }
}","public Object waitAndGetResult(){
  while (true) {
    try {
      Object obj=responses.poll(5,TimeUnit.SECONDS);
      if (obj != null) {
        return obj;
      }
 else       if (node.factory.restarted) {
        reset();
        throw new RuntimeException();
      }
 else       if (!node.active) {
        throw new IllegalStateException(""String_Node_Str"");
      }
    }
 catch (    InterruptedException e) {
      if (node.factory.restarted) {
        reset();
        throw new RuntimeException();
      }
    }
  }
}",0.966990291262136
50478,"public void stop(){
  queue.clear();
  try {
    final CountDownLatch l=new CountDownLatch(1);
    queue.put(new Processable(){
      public void process(){
        running=false;
        l.countDown();
      }
    }
);
    l.await();
  }
 catch (  InterruptedException ignored) {
  }
}","public void stop(){
  packetQueue.clear();
  processableQueue.clear();
  try {
    final CountDownLatch l=new CountDownLatch(1);
    processableQueue.put(new Processable(){
      public void process(){
        running=false;
        l.countDown();
      }
    }
);
    l.await();
  }
 catch (  InterruptedException ignored) {
  }
}",0.920583468395462
50479,"public void enqueueAndReturn(final Object message){
  try {
    queue.put(message);
  }
 catch (  final InterruptedException e) {
    node.handleInterruptedException(Thread.currentThread(),e);
  }
}","public void enqueueAndReturn(Processable message){
  try {
    processableQueue.put(message);
    enqueueLock.lock();
    notEmpty.signal();
  }
 catch (  InterruptedException e) {
    node.handleInterruptedException(Thread.currentThread(),e);
  }
 finally {
    enqueueLock.unlock();
  }
}",0.6311475409836066
50480,"@Override public String toString(){
  return ""String_Node_Str"" + queue.size() + ""String_Node_Str""+ node.master()+ ""String_Node_Str""+ node.getMasterAddress();
}","@Override public String toString(){
  return ""String_Node_Str"" + packetQueue.size() + ""String_Node_Str""+ processableQueue.size()+ ""String_Node_Str""+ node.master()+ ""String_Node_Str""+ node.getMasterAddress();
}",0.8586956521739131
50481,"void enqueueFullPacket(Packet p){
  p.flipBuffers();
  p.read();
  p.setFromConnection(connection);
  if (p.client) {
    node.clientService.handle(p);
  }
 else {
    clusterService.enqueueAndReturn(p);
  }
}","void enqueueFullPacket(final Packet p){
  p.flipBuffers();
  p.read();
  p.setFromConnection(connection);
  if (p.client) {
    node.clientService.handle(p);
  }
 else {
    clusterService.enqueuePacket(p);
  }
}",0.9501187648456056
50482,"private void handleCommand(String command){
  if (echo) {
    if (Thread.currentThread().getName().toLowerCase().indexOf(""String_Node_Str"") < 0)     System.out.println(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ command);
 else     System.out.println(command);
  }
  if (command == null || command.startsWith(""String_Node_Str""))   return;
  command=command.trim();
  if (command == null || command.length() == 0) {
    return;
  }
  String first=command;
  int spaceIndex=command.indexOf(' ');
  String[] argsSplit=command.split(""String_Node_Str"");
  String[] args=new String[argsSplit.length];
  for (int i=0; i < argsSplit.length; i++) {
    args[i]=argsSplit[i].trim();
  }
  if (spaceIndex != -1) {
    first=args[0];
  }
  if (command.startsWith(""String_Node_Str"")) {
    handleHelp(command);
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    int repeat=Integer.parseInt(first.substring(1));
    long t0=System.currentTimeMillis();
    for (int i=0; i < repeat; i++) {
      handleCommand(command.substring(first.length()).replaceAll(""String_Node_Str"",""String_Node_Str"" + i));
    }
    System.out.println(""String_Node_Str"" + repeat * 1000 / (System.currentTimeMillis() - t0));
    return;
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    final int fork=Integer.parseInt(first.substring(1));
    ExecutorService pool=Executors.newFixedThreadPool(fork);
    final String threadCommand=command.substring(first.length());
    for (int i=0; i < fork; i++) {
      final int threadID=i;
      pool.submit(new Runnable(){
        public void run(){
          String command=threadCommand;
          String[] threadArgs=command.replaceAll(""String_Node_Str"",""String_Node_Str"" + threadID).trim().split(""String_Node_Str"");
          if (""String_Node_Str"".equals(threadArgs[0]) || ""String_Node_Str"".equals(threadArgs[0])) {
            if (threadArgs.length < 4) {
              command+=""String_Node_Str"" + Integer.parseInt(threadArgs[1]) * threadID;
            }
          }
          handleCommand(command);
        }
      }
);
    }
    pool.shutdown();
    try {
      pool.awaitTermination(60 * 60,TimeUnit.SECONDS);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (first.startsWith(""String_Node_Str"")) {
    if (first.length() == 1) {
      System.out.println(""String_Node_Str"");
      return;
    }
    File f=new File(first.substring(1));
    System.out.println(""String_Node_Str"" + f.getAbsolutePath());
    if (f.exists()) {
      try {
        BufferedReader br=new BufferedReader(new FileReader(f));
        String l=br.readLine();
        while (l != null) {
          handleCommand(l);
          l=br.readLine();
        }
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else {
      System.out.println(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
 else   if (command.indexOf(';') != -1) {
    StringTokenizer st=new StringTokenizer(command,""String_Node_Str"");
    while (st.hasMoreTokens()) {
      handleCommand(st.nextToken());
    }
    return;
  }
 else   if (""String_Node_Str"".equals(first)) {
    silent=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    Hazelcast.restart();
  }
 else   if (""String_Node_Str"".equals(first)) {
    Hazelcast.shutdown();
  }
 else   if (""String_Node_Str"".equals(first)) {
    echo=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    if (args.length > 1) {
      namespace=args[1];
      queue=Hazelcast.getQueue(namespace);
      topic=Hazelcast.getTopic(namespace);
      map=Hazelcast.getMap(namespace);
      set=Hazelcast.getSet(namespace);
      list=Hazelcast.getList(namespace);
    }
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.out.println(Hazelcast.getCluster().getLocalMember());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.out.println(Hazelcast.getCluster());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.gc();
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().maxMemory() / 1024 / 1024 + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + ""String_Node_Str"" + (int)(Runtime.getRuntime().freeMemory() * 100 / Runtime.getRuntime().maxMemory()) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().availableProcessors());
    System.out.println(""String_Node_Str"" + ManagementFactory.getOperatingSystemMXBean().getArch() + ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getName()+ ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getVersion());
    System.out.println(""String_Node_Str"" + ManagementFactory.getRuntimeMXBean().getVmVendor() + ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmName()+ ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmVersion());
  }
 else   if (first.indexOf(""String_Node_Str"") != -1 && first.indexOf(""String_Node_Str"") == -1) {
    handleLock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleSize(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleClear(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleDestroy(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleIterator(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleContains(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleTopicPublish(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOffer(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPoll(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPeek(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOfferMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPollMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemove(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAddMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemoveMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapReplace(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPutIfAbsent(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPut(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGet(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapGetMapEntry(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPutMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemoveMany(args);
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapValues();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapEntries();
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapTryLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleAddListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleRemoveListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleListAddMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListContains(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    execute(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    Hazelcast.getTransaction().begin();
  }
 else   if (first.equals(""String_Node_Str"")) {
    Hazelcast.getTransaction().commit();
  }
 else   if (first.equals(""String_Node_Str"")) {
    Hazelcast.getTransaction().rollback();
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnKey(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMembers(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLongTaskOnOtherMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLong(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleInstances(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    System.exit(0);
  }
 else {
    print(""String_Node_Str"");
  }
}","private void handleCommand(String command){
  if (echo) {
    if (Thread.currentThread().getName().toLowerCase().indexOf(""String_Node_Str"") < 0)     System.out.println(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ command);
 else     System.out.println(command);
  }
  if (command == null || command.startsWith(""String_Node_Str""))   return;
  command=command.trim();
  if (command == null || command.length() == 0) {
    return;
  }
  String first=command;
  int spaceIndex=command.indexOf(' ');
  String[] argsSplit=command.split(""String_Node_Str"");
  String[] args=new String[argsSplit.length];
  for (int i=0; i < argsSplit.length; i++) {
    args[i]=argsSplit[i].trim();
  }
  if (spaceIndex != -1) {
    first=args[0];
  }
  if (command.startsWith(""String_Node_Str"")) {
    handleHelp(command);
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    int repeat=Integer.parseInt(first.substring(1));
    long t0=System.currentTimeMillis();
    for (int i=0; i < repeat; i++) {
      handleCommand(command.substring(first.length()).replaceAll(""String_Node_Str"",""String_Node_Str"" + i));
    }
    System.out.println(""String_Node_Str"" + repeat * 1000 / (System.currentTimeMillis() - t0));
    return;
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    final int fork=Integer.parseInt(first.substring(1));
    ExecutorService pool=Executors.newFixedThreadPool(fork);
    final String threadCommand=command.substring(first.length());
    for (int i=0; i < fork; i++) {
      final int threadID=i;
      pool.submit(new Runnable(){
        public void run(){
          String command=threadCommand;
          String[] threadArgs=command.replaceAll(""String_Node_Str"",""String_Node_Str"" + threadID).trim().split(""String_Node_Str"");
          if (""String_Node_Str"".equals(threadArgs[0]) || ""String_Node_Str"".equals(threadArgs[0])) {
            if (threadArgs.length < 4) {
              command+=""String_Node_Str"" + Integer.parseInt(threadArgs[1]) * threadID;
            }
          }
          handleCommand(command);
        }
      }
);
    }
    pool.shutdown();
    try {
      pool.awaitTermination(60 * 60,TimeUnit.SECONDS);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (first.startsWith(""String_Node_Str"")) {
    if (first.length() == 1) {
      System.out.println(""String_Node_Str"");
      return;
    }
    File f=new File(first.substring(1));
    System.out.println(""String_Node_Str"" + f.getAbsolutePath());
    if (f.exists()) {
      try {
        BufferedReader br=new BufferedReader(new FileReader(f));
        String l=br.readLine();
        while (l != null) {
          handleCommand(l);
          l=br.readLine();
        }
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else {
      System.out.println(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
 else   if (command.indexOf(';') != -1) {
    StringTokenizer st=new StringTokenizer(command,""String_Node_Str"");
    while (st.hasMoreTokens()) {
      handleCommand(st.nextToken());
    }
    return;
  }
 else   if (""String_Node_Str"".equals(first)) {
    silent=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    Hazelcast.restart();
  }
 else   if (""String_Node_Str"".equals(first)) {
    Hazelcast.shutdown();
  }
 else   if (""String_Node_Str"".equals(first)) {
    echo=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    if (args.length > 1) {
      namespace=args[1];
      queue=Hazelcast.getQueue(namespace);
      topic=Hazelcast.getTopic(namespace);
      map=Hazelcast.getMap(namespace);
      set=Hazelcast.getSet(namespace);
      list=Hazelcast.getList(namespace);
    }
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.out.println(Hazelcast.getCluster().getLocalMember());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.out.println(Hazelcast.getCluster());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.gc();
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().maxMemory() / 1024 / 1024 + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + ""String_Node_Str"" + (int)(Runtime.getRuntime().freeMemory() * 100 / Runtime.getRuntime().maxMemory()) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().availableProcessors());
    System.out.println(""String_Node_Str"" + ManagementFactory.getOperatingSystemMXBean().getArch() + ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getName()+ ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getVersion());
    System.out.println(""String_Node_Str"" + ManagementFactory.getRuntimeMXBean().getVmVendor() + ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmName()+ ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmVersion());
  }
 else   if (first.indexOf(""String_Node_Str"") != -1 && first.indexOf(""String_Node_Str"") == -1) {
    handleLock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleSize(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleClear(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleDestroy(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleIterator(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleContains(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleTopicPublish(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOffer(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPoll(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPeek(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOfferMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPollMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemove(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAddMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemoveMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapReplace(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPutIfAbsent(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPut(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGet(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapGetMapEntry(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPutMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemoveMany(args);
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapLocalKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapValues();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapEntries();
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapTryLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleAddListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleRemoveListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleListAddMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListContains(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    execute(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    Hazelcast.getTransaction().begin();
  }
 else   if (first.equals(""String_Node_Str"")) {
    Hazelcast.getTransaction().commit();
  }
 else   if (first.equals(""String_Node_Str"")) {
    Hazelcast.getTransaction().rollback();
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnKey(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMembers(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLongTaskOnOtherMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLong(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleInstances(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    System.exit(0);
  }
 else {
    print(""String_Node_Str"");
  }
}",0.9957207085206652
50483,"public void run(){
  put(entry.getKey(),entry.getValue());
}","public void run(){
  put(entry.getKey(),entry.getValue());
  latch.countDown();
}",0.851063829787234
50484,"public void putAll(Map map){
  Set<Entry> entries=map.entrySet();
  final CountDownLatch latch=new CountDownLatch(entries.size());
  for (  final Entry entry : entries) {
    factory.node.executorManager.executeLocally(new Runnable(){
      public void run(){
        put(entry.getKey(),entry.getValue());
      }
    }
);
    latch.countDown();
  }
  try {
    latch.await();
  }
 catch (  InterruptedException ignored) {
  }
}","public void putAll(Map map){
  Set<Entry> entries=map.entrySet();
  final CountDownLatch latch=new CountDownLatch(entries.size());
  for (  final Entry entry : entries) {
    factory.node.executorManager.executeLocally(new Runnable(){
      public void run(){
        put(entry.getKey(),entry.getValue());
        latch.countDown();
      }
    }
);
  }
  try {
    latch.await();
  }
 catch (  InterruptedException ignored) {
  }
}",0.9651162790697676
50485,"public void readData(DataInput in) throws IOException {
  setName(in.readUTF());
  setFactory(ThreadContext.get().getCurrentFactory());
}","public void readData(DataInput in) throws IOException {
  this.name=in.readUTF();
}",0.7
50486,"public Long call(){
  FactoryImpl factory=getFactoryImpl(factoryName);
  MProxy map=factory.idGeneratorMapProxy;
  map.lock(name);
  try {
    Long max=(Long)map.get(name);
    if (max == null) {
      max=0L;
      map.put(name,0L);
      return max;
    }
 else {
      Long newMax=max + 1;
      map.put(name,newMax);
      return newMax;
    }
  }
  finally {
    map.unlock(name);
  }
}","public Long call(){
  MProxy map=((FactoryImpl)hazelcastInstance).idGeneratorMapProxy;
  map.lock(name);
  try {
    Long max=(Long)map.get(name);
    if (max == null) {
      max=0L;
      map.put(name,0L);
      return max;
    }
 else {
      Long newMax=max + 1;
      map.put(name,newMax);
      return newMax;
    }
  }
  finally {
    map.unlock(name);
  }
}",0.8835978835978836
50487,"private Long getNewMillion(){
  try {
    DistributedTask<Long> task=new DistributedTask<Long>(new IncrementTask(name,factory.getName()));
    factory.executorServiceImpl.execute(task);
    return task.get();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}","private Long getNewMillion(){
  try {
    DistributedTask<Long> task=new DistributedTask<Long>(new IncrementTask(name,factory));
    factory.executorServiceImpl.execute(task);
    return task.get();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}",0.9820143884892086
50488,"public IncrementTask(String uuidName,String factoryName){
  super();
  this.name=uuidName;
  this.factoryName=factoryName;
}","public IncrementTask(String uuidName,HazelcastInstance hazelcastInstance){
  super();
  this.name=uuidName;
  this.hazelcastInstance=hazelcastInstance;
}",0.7364620938628159
50489,"public long size(){
  return (lsKeyValues == null) ? 0 : lsKeyValues.size();
}","public int size(){
  return (lsKeyValues == null) ? 0 : lsKeyValues.size();
}",0.967741935483871
50490,"public void setName(String factoryName,String name){
  this.factoryName=factoryName;
  this.name=name;
}","public void setName(FactoryImpl factoryImpl,String name){
  this.factory=factoryImpl;
  this.name=name;
}",0.861244019138756
50491,"public Object setValue(Object newValue){
  if (name == null)   throw new UnsupportedOperationException();
  this.objValue=value;
  FactoryImpl factory=FactoryImpl.getFactoryImpl(factoryName);
  return ((FactoryImpl.MProxy)factory.getOrCreateProxyByName(name)).put(getKey(),newValue);
}","public Object setValue(Object newValue){
  if (name == null)   throw new UnsupportedOperationException();
  this.objValue=value;
  return ((FactoryImpl.MProxy)factory.getOrCreateProxyByName(name)).put(key,newValue);
}",0.852589641434263
50492,"public ClientService(Node node){
  this.node=node;
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_PUT.getValue()]=new MapPutHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_PUT_IF_ABSENT.getValue()]=new MapPutIfAbsentHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_GET.getValue()]=new MapGetHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REMOVE.getValue()]=new MapRemoveHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REMOVE_IF_SAME.getValue()]=new MapRemoveIfSameHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_EVICT.getValue()]=new MapEvictHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REPLACE_IF_NOT_NULL.getValue()]=new MapReplaceIfNotNullHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REPLACE_IF_SAME.getValue()]=new MapReplaceIfSameHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_SIZE.getValue()]=new MapSizeHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_GET_MAP_ENTRY.getValue()]=new GetMapEntryHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_LOCK.getValue()]=new MapLockHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_UNLOCK.getValue()]=new MapUnlockHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_CONTAINS.getValue()]=new MapContainsHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_CONTAINS_VALUE.getValue()]=new MapContainsValueHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_ADD_TO_LIST.getValue()]=new ListAddHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_ADD_TO_SET.getValue()]=new SetAddHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REMOVE_ITEM.getValue()]=new MapItemRemoveHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_ITERATE_KEYS.getValue()]=new MapIterateKeysHandler();
  clientOperationHandlers[ClusterOperation.BLOCKING_QUEUE_OFFER.getValue()]=new QueueOfferHandler();
  clientOperationHandlers[ClusterOperation.BLOCKING_QUEUE_POLL.getValue()]=new QueuePollHandler();
  clientOperationHandlers[ClusterOperation.BLOCKING_QUEUE_REMOVE.getValue()]=new QueueRemoveHandler();
  clientOperationHandlers[ClusterOperation.BLOCKING_QUEUE_PEEK.getValue()]=new QueuePeekHandler();
  clientOperationHandlers[ClusterOperation.BLOCKING_QUEUE_SIZE.getValue()]=new QueueSizeHandler();
  clientOperationHandlers[ClusterOperation.TRANSACTION_BEGIN.getValue()]=new TransactionBeginHandler();
  clientOperationHandlers[ClusterOperation.TRANSACTION_COMMIT.getValue()]=new TransactionCommitHandler();
  clientOperationHandlers[ClusterOperation.TRANSACTION_ROLLBACK.getValue()]=new TransactionRollbackHandler();
  clientOperationHandlers[ClusterOperation.ADD_LISTENER.getValue()]=new AddListenerHandler();
  clientOperationHandlers[ClusterOperation.REMOVE_LISTENER.getValue()]=new RemoveListenerHandler();
  clientOperationHandlers[ClusterOperation.REMOTELY_PROCESS.getValue()]=new RemotelyProcessHandler();
  clientOperationHandlers[ClusterOperation.DESTROY.getValue()]=new DestroyHandler();
  clientOperationHandlers[ClusterOperation.GET_ID.getValue()]=new GetIdHandler();
  clientOperationHandlers[ClusterOperation.ADD_INDEX.getValue()]=new AddIndexHandler();
}","public ClientService(Node node){
  this.node=node;
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_PUT.getValue()]=new MapPutHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_PUT_IF_ABSENT.getValue()]=new MapPutIfAbsentHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_GET.getValue()]=new MapGetHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REMOVE.getValue()]=new MapRemoveHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REMOVE_IF_SAME.getValue()]=new MapRemoveIfSameHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_EVICT.getValue()]=new MapEvictHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REPLACE_IF_NOT_NULL.getValue()]=new MapReplaceIfNotNullHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REPLACE_IF_SAME.getValue()]=new MapReplaceIfSameHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_SIZE.getValue()]=new MapSizeHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_GET_MAP_ENTRY.getValue()]=new GetMapEntryHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_LOCK.getValue()]=new MapLockHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_UNLOCK.getValue()]=new MapUnlockHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_CONTAINS.getValue()]=new MapContainsHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_CONTAINS_VALUE.getValue()]=new MapContainsValueHandler();
  clientOperationHandlers[ClusterOperation.TRANSACTION_BEGIN.getValue()]=new TransactionBeginHandler();
  clientOperationHandlers[ClusterOperation.TRANSACTION_COMMIT.getValue()]=new TransactionCommitHandler();
  clientOperationHandlers[ClusterOperation.TRANSACTION_ROLLBACK.getValue()]=new TransactionRollbackHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_ITERATE_KEYS.getValue()]=new MapIterateKeysHandler();
  clientOperationHandlers[ClusterOperation.ADD_LISTENER.getValue()]=new AddListenerHandler();
  clientOperationHandlers[ClusterOperation.REMOVE_LISTENER.getValue()]=new RemoveListenerHandler();
  clientOperationHandlers[ClusterOperation.REMOTELY_PROCESS.getValue()]=new RemotelyProcessHandler();
  clientOperationHandlers[ClusterOperation.DESTROY.getValue()]=new DestroyHandler();
  clientOperationHandlers[ClusterOperation.GET_ID.getValue()]=new GetIdHandler();
  clientOperationHandlers[ClusterOperation.ADD_INDEX.getValue()]=new AddIndexHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_ADD_TO_LIST.getValue()]=new ListAddHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REMOVE_ITEM.getValue()]=new ListRemoveHandler();
}",0.6206328279499012
50493,"@Test public void iterate(){
  HazelcastInstance h=Hazelcast.newHazelcastInstance(null);
  hClient=getHazelcastClient(h);
  IList list=hClient.getList(""String_Node_Str"");
  list.add(1);
  list.add(2);
  list.add(2);
  list.add(3);
  assertEquals(4,list.size());
  Map<Integer,Integer> counter=new HashMap<Integer,Integer>();
  counter.put(1,1);
  counter.put(2,2);
  counter.put(3,1);
  for (Iterator<Integer> iterator=list.iterator(); iterator.hasNext(); ) {
    Integer integer=(Integer)iterator.next();
    counter.put(integer,counter.get(integer) - 1);
    iterator.remove();
  }
  assertEquals(0,counter.get(1));
  assertEquals(0,counter.get(2));
  assertEquals(0,counter.get(3));
  assertTrue(list.isEmpty());
}","@Test public void iterate(){
  HazelcastInstance h=Hazelcast.newHazelcastInstance(null);
  hClient=getHazelcastClient(h);
  IList list=hClient.getList(""String_Node_Str"");
  list.add(1);
  list.add(2);
  list.add(2);
  list.add(3);
  assertEquals(4,list.size());
  Map counter=new HashMap();
  counter.put(1,1);
  counter.put(2,2);
  counter.put(3,1);
  for (Iterator<Integer> iterator=list.iterator(); iterator.hasNext(); ) {
    Integer integer=(Integer)iterator.next();
    counter.put(integer,(Integer)counter.get(integer) - 1);
    iterator.remove();
  }
  assertEquals(0,counter.get(1));
  assertEquals(0,counter.get(2));
  assertEquals(0,counter.get(3));
  assertTrue(list.isEmpty());
}",0.8573456352022711
50494,"@Test public void lockMap() throws InterruptedException {
  HazelcastInstance h=Hazelcast.newHazelcastInstance(null);
  hClient=getHazelcastClient(h);
  final IMap map=hClient.getMap(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  map.put(""String_Node_Str"",""String_Node_Str"");
  Thread.sleep(1000);
  System.out.println(""String_Node_Str"");
  map.lock(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  new Thread(new Runnable(){
    public void run(){
      map.lock(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      latch.countDown();
    }
  }
).start();
  Thread.sleep(100);
  assertEquals(1,latch.getCount());
  System.out.println(""String_Node_Str"");
  map.unlock(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  assertTrue(latch.await(100000,TimeUnit.MILLISECONDS));
}","@Test public void lockMap() throws InterruptedException {
  HazelcastInstance h=Hazelcast.newHazelcastInstance(null);
  hClient=getHazelcastClient(h);
  final IMap map=hClient.getMap(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  map.put(""String_Node_Str"",""String_Node_Str"");
  Thread.sleep(1000);
  System.out.println(""String_Node_Str"");
  map.lock(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  new Thread(new Runnable(){
    public void run(){
      map.lock(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      latch.countDown();
    }
  }
).start();
  Thread.sleep(100);
  assertEquals(1,latch.getCount());
  System.out.println(""String_Node_Str"");
  map.unlock(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  assertTrue(latch.await(2000,TimeUnit.MILLISECONDS));
}",0.9976331360946744
50495,"public CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.BLOCK_COUNT=concurrentMapManager.BLOCK_COUNT;
  this.blocks=concurrentMapManager.blocks;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  mapRecords=new SortedHashMap<Data,Record>(10000);
  MapConfig mapConfig=node.getConfig().getMapConfig(name.substring(2));
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  if (""String_Node_Str"".equalsIgnoreCase(mapConfig.getEvictionPolicy())) {
    evictionPolicy=SortedHashMap.OrderingType.LFU;
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(mapConfig.getEvictionPolicy())) {
    evictionPolicy=SortedHashMap.OrderingType.LRU;
  }
 else {
    evictionPolicy=SortedHashMap.OrderingType.NONE;
  }
  if (evictionPolicy == SortedHashMap.OrderingType.NONE) {
    maxSize=Integer.MAX_VALUE;
  }
 else {
    maxSize=(mapConfig.getMaxSize() == 0) ? MapConfig.DEFAULT_MAX_SIZE : mapConfig.getMaxSize();
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100f;
  instanceType=concurrentMapManager.getInstanceType(name);
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  MapStore storeTemp=null;
  MapLoader loaderTemp=null;
  if (mapStoreConfig != null) {
    if (mapStoreConfig.isEnabled()) {
      String mapStoreClassName=mapStoreConfig.getClassName();
      try {
        Object storeInstance=Class.forName(mapStoreClassName,true,node.getConfig().getClassLoader()).newInstance();
        if (storeInstance instanceof MapLoader) {
          loaderTemp=(MapLoader)storeInstance;
        }
        if (storeInstance instanceof MapStore) {
          storeTemp=(MapStore)storeInstance;
        }
        writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
        if (writeDelaySeconds > 0) {
          setDirtyRecords=new HashSet<Record>(5000);
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
  loader=loaderTemp;
  store=storeTemp;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + (writeDelaySeconds * 1000L);
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  if (evictionPolicy == SortedHashMap.OrderingType.NONE && instanceType == Instance.InstanceType.MAP) {
    locallyOwnedMap=new LocallyOwnedMap();
    concurrentMapManager.mapLocallyOwnedMaps.put(name,locallyOwnedMap);
  }
 else {
    locallyOwnedMap=null;
  }
}","public CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.BLOCK_COUNT=concurrentMapManager.BLOCK_COUNT;
  this.blocks=concurrentMapManager.blocks;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  mapRecords=new SortedHashMap<Data,Record>(10000);
  MapConfig mapConfig=node.getConfig().getMapConfig(name.substring(2));
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  if (""String_Node_Str"".equalsIgnoreCase(mapConfig.getEvictionPolicy())) {
    evictionPolicy=SortedHashMap.OrderingType.LFU;
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(mapConfig.getEvictionPolicy())) {
    evictionPolicy=SortedHashMap.OrderingType.LRU;
  }
 else {
    evictionPolicy=SortedHashMap.OrderingType.NONE;
  }
  if (evictionPolicy == SortedHashMap.OrderingType.NONE) {
    maxSize=Integer.MAX_VALUE;
  }
 else {
    maxSize=(mapConfig.getMaxSize() == 0) ? MapConfig.DEFAULT_MAX_SIZE : mapConfig.getMaxSize();
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100f;
  instanceType=concurrentMapManager.getInstanceType(name);
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  MapStore storeTemp=null;
  MapLoader loaderTemp=null;
  if (mapStoreConfig != null) {
    if (mapStoreConfig.isEnabled()) {
      String mapStoreClassName=mapStoreConfig.getClassName();
      try {
        Object storeInstance=Class.forName(mapStoreClassName).newInstance();
        if (storeInstance instanceof MapLoader) {
          loaderTemp=(MapLoader)storeInstance;
        }
        if (storeInstance instanceof MapStore) {
          storeTemp=(MapStore)storeInstance;
        }
        writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
        if (writeDelaySeconds > 0) {
          setDirtyRecords=new HashSet<Record>(5000);
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
  loader=loaderTemp;
  store=storeTemp;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + (writeDelaySeconds * 1000L);
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  if (evictionPolicy == SortedHashMap.OrderingType.NONE && instanceType == Instance.InstanceType.MAP) {
    locallyOwnedMap=new LocallyOwnedMap();
    concurrentMapManager.mapLocallyOwnedMaps.put(name,locallyOwnedMap);
  }
 else {
    locallyOwnedMap=null;
  }
}",0.9923000987166832
50496,"public boolean putMulti(Request req){
  Record record=getRecord(req.key);
  boolean added=true;
  if (record == null) {
    record=createNewRecord(req.key,null);
    req.key=null;
  }
 else {
    if (!record.isActive()) {
      markAsActive(record);
    }
    if (record.containsValue(req.value)) {
      added=false;
    }
  }
  if (added) {
    node.queryService.updateIndex(name,null,null,record,Integer.MIN_VALUE);
    record.addValue(req.value);
    req.value=null;
    record.setVersion(record.getVersion() + 1);
    touch(record);
    concurrentMapManager.fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,record.getKey(),req.value,record.getMapListeners());
  }
  logger.log(Level.FINEST,record.getValue() + ""String_Node_Str"" + record.getMultiValues());
  req.version=record.getVersion();
  return added;
}","public boolean putMulti(Request req){
  Record record=getRecord(req.key);
  boolean added=true;
  if (record == null) {
    record=createNewRecord(req.key,null);
    req.key=null;
  }
 else {
    if (!record.isActive()) {
      markAsActive(record);
    }
    if (record.containsValue(req.value)) {
      added=false;
    }
  }
  if (added) {
    node.queryService.updateIndex(name,null,null,record,Integer.MIN_VALUE);
    record.addValue(req.value);
    req.value=null;
    record.setVersion(record.getVersion() + 1);
    touch(record);
    concurrentMapManager.fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,record.getKey(),req.value,record.getMapListeners());
  }
  if (req.txnId != -1) {
    concurrentMapManager.unlock(record);
  }
  logger.log(Level.FINEST,record.getValue() + ""String_Node_Str"" + record.getMultiValues());
  req.version=record.getVersion();
  return added;
}",0.9589201877934272
50497,"private Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getCurrentTxn();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndReturnOld(name,key,DEFAULT_TXN_TIMEOUT,txn.getId());
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=toObject(oldValue);
      }
      txn.attachPutOp(name,key,value,(oldObject == null));
      return threadContext.isClient() ? oldValue : oldObject;
    }
 else {
      return txn.attachPutOp(name,key,value,false);
    }
  }
 else {
    setLocal(operation,name,key,value,timeout,-1);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    doOp();
    Object returnObject=getResultAsObject();
    if (returnObject instanceof AddressAwareException) {
      rethrowException(operation,(AddressAwareException)returnObject);
    }
    backup(CONCURRENT_MAP_BACKUP_PUT);
    return returnObject;
  }
}","private Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getCurrentTxn();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndReturnOld(name,key,DEFAULT_TXN_TIMEOUT,txn.getId());
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=toObject(oldValue);
      }
      txn.attachPutOp(name,key,value,(oldObject == null));
      return threadContext.isClient() ? oldValue : oldObject;
    }
 else {
      return txn.attachPutOp(name,key,value,false);
    }
  }
 else {
    setLocal(operation,name,key,value,timeout,-1);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    doOp();
    Object returnObject;
    returnObject=getResultAsObject();
    if (returnObject instanceof AddressAwareException) {
      rethrowException(operation,(AddressAwareException)returnObject);
    }
    backup(CONCURRENT_MAP_BACKUP_PUT);
    return returnObject;
  }
}",0.9929632525410476
50498,"/** 
 * Test case for issue 154 ExecutorService can block migration which can lead to dead-lock
 */
@Test(timeout=480000) public void testExecutorServiceAndMigration() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  List<DistributedTask> tasks=new ArrayList<DistributedTask>(10000);
  List<ExecutorServiceAndMigrationCallable> callables=new ArrayList<ExecutorServiceAndMigrationCallable>(10000);
  for (int i=0; i < 10000; i++) {
    ExecutorServiceAndMigrationCallable callable=new ExecutorServiceAndMigrationCallable(i);
    DistributedTask task=new DistributedTask(callable,""String_Node_Str"");
    Hazelcast.getExecutorService().execute(task);
    tasks.add(task);
    callables.add(callable);
  }
  for (int i=0; i < 10000; i++) {
    ExecutorServiceAndMigrationCallable callable=callables.get(i);
    DistributedTask task=tasks.get(i);
    assertEquals(callable.getInput(),task.get(20,TimeUnit.SECONDS));
  }
}","/** 
 * Test case for issue 154
 * @throws Exception
 */
@Test(timeout=240000) public void testExecutorServiceAndMigration() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  List<DistributedTask> tasks=new ArrayList<DistributedTask>(10000);
  List<ExecutorServiceAndMigrationCallable> callables=new ArrayList<ExecutorServiceAndMigrationCallable>(10000);
  for (int i=0; i < 10000; i++) {
    ExecutorServiceAndMigrationCallable callable=new ExecutorServiceAndMigrationCallable(i);
    DistributedTask task=new DistributedTask(callable,""String_Node_Str"");
    Hazelcast.getExecutorService().execute(task);
    tasks.add(task);
    callables.add(callable);
  }
  for (int i=0; i < 10000; i++) {
    ExecutorServiceAndMigrationCallable callable=callables.get(i);
    DistributedTask task=tasks.get(i);
    assertEquals(callable.getInput(),task.get(20,TimeUnit.SECONDS));
  }
}",0.95633423180593
50499,"public static void init(Config config){
  if (defaultInstance != null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
synchronized (initLock) {
    if (defaultInstance != null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    defaultInstance=com.hazelcast.impl.FactoryImpl.newFactory(config);
  }
}","public static void init(Config config){
  if (defaultInstance != null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
synchronized (initLock) {
    if (defaultInstance != null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    defaultInstance=com.hazelcast.impl.FactoryImpl.newHazelcastInstanceProxy(config);
  }
}",0.9604685212298684
50500,"private static HazelcastInstance getDefaultInstance(){
  if (defaultInstance == null) {
synchronized (initLock) {
      if (defaultInstance == null) {
        defaultInstance=com.hazelcast.impl.FactoryImpl.newFactory(null);
      }
    }
  }
  return defaultInstance;
}","private static HazelcastInstance getDefaultInstance(){
  if (defaultInstance == null) {
synchronized (initLock) {
      if (defaultInstance == null) {
        defaultInstance=com.hazelcast.impl.FactoryImpl.newHazelcastInstanceProxy(null);
      }
    }
  }
  return defaultInstance;
}",0.9511754068716094
50501,"/** 
 * Creates a new Hazelcast instance (a new node in a cluster). This method allows you to create and run multiple instances of Hazelcast cluster members on the same JVM. <p/> To shutdown all running hazelcast instances (all members on this JVM) call   {@link #shutdownAll()}.
 * @param config Configuration for the new hazelcast instance (member)
 * @return new hazelcast instance
 * @see #shutdownAll()
 */
public static HazelcastInstance newHazelcastInstance(Config config){
  return com.hazelcast.impl.FactoryImpl.newFactory(config);
}","/** 
 * Creates a new Hazelcast instance (a new node in a cluster). This method allows you to create and run multiple instances of Hazelcast cluster members on the same JVM. <p/> To shutdown all running hazelcast instances (all members on this JVM) call   {@link #shutdownAll()}.
 * @param config Configuration for the new hazelcast instance (member)
 * @return new hazelcast instance
 * @see #shutdownAll()
 */
public static HazelcastInstance newHazelcastInstance(Config config){
  return com.hazelcast.impl.FactoryImpl.newHazelcastInstanceProxy(config);
}",0.9754322111010008
50502,"ExecutorManager(Node node){
  super(node);
  registerPacketProcessor(ClusterOperation.REMOTELY_EXECUTE,new PacketProcessor(){
    public void process(    Packet packet){
      handleRemoteExecution(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.STREAM,new PacketProcessor(){
    public void process(    Packet packet){
      handleStream(packet);
    }
  }
);
  if (logger.isLoggable(Level.FINEST)) {
    logger.log(Level.FINEST,""String_Node_Str"");
  }
  Config config=node.getConfig();
  final int corePoolSize=config.getExecutorConfig().getCorePoolSize();
  final int maxPoolSize=config.getExecutorConfig().getMaxPoolsize();
  final long keepAliveSeconds=config.getExecutorConfig().getKeepAliveSeconds();
  if (logger.isLoggable(Level.FINEST)) {
    logger.log(Level.FINEST,""String_Node_Str"" + corePoolSize + ""String_Node_Str""+ maxPoolSize+ ""String_Node_Str""+ keepAliveSeconds);
  }
  executor=new ThreadPoolExecutor(corePoolSize,maxPoolSize,keepAliveSeconds,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>(),new ExecutorThreadFactory(node.threadGroup,node.getName()),new RejectionHandler());
  executorForMigrations=new ThreadPoolExecutor(1,16,60,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>(),new ExecutorThreadFactory(node.threadGroup,node.getName() + ""String_Node_Str""),new RejectionHandler());
  node.getClusterImpl().addMembershipListener(this);
  for (int i=0; i < 100; i++) {
    executionIds.add((long)i);
  }
  started=true;
}","ExecutorManager(final Node node){
  super(node);
  registerPacketProcessor(ClusterOperation.REMOTELY_EXECUTE,new PacketProcessor(){
    public void process(    Packet packet){
      handleRemoteExecution(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.STREAM,new PacketProcessor(){
    public void process(    Packet packet){
      handleStream(packet);
    }
  }
);
  if (logger.isLoggable(Level.FINEST)) {
    logger.log(Level.FINEST,""String_Node_Str"");
  }
  Config config=node.getConfig();
  final int corePoolSize=config.getExecutorConfig().getCorePoolSize();
  final int maxPoolSize=config.getExecutorConfig().getMaxPoolsize();
  final long keepAliveSeconds=config.getExecutorConfig().getKeepAliveSeconds();
  if (logger.isLoggable(Level.FINEST)) {
    logger.log(Level.FINEST,""String_Node_Str"" + corePoolSize + ""String_Node_Str""+ maxPoolSize+ ""String_Node_Str""+ keepAliveSeconds);
  }
  executor=new ThreadPoolExecutor(corePoolSize,maxPoolSize,keepAliveSeconds,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>(),new ExecutorThreadFactory(node.threadGroup,node.getName()),new RejectionHandler()){
    protected void beforeExecute(    Thread t,    Runnable r){
      ThreadContext.get().setCurrentFactory(node.factory);
    }
  }
;
  executorForMigrations=new ThreadPoolExecutor(1,16,60,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>(),new ExecutorThreadFactory(node.threadGroup,node.getName() + ""String_Node_Str""),new RejectionHandler()){
    protected void beforeExecute(    Thread t,    Runnable r){
      ThreadContext.get().setCurrentFactory(node.factory);
    }
  }
;
  node.getClusterImpl().addMembershipListener(this);
  for (int i=0; i < 100; i++) {
    executionIds.add((long)i);
  }
  started=true;
}",0.9144818976279652
50503,"public void handleRemoteExecution(Packet packet){
  log(""String_Node_Str"" + packet);
  final Data callableData=IOUtil.doTake(packet.value);
  final RemoteExecutionId remoteExecutionId=new RemoteExecutionId(packet.conn.getEndPoint(),packet.longValue);
  final SimpleExecution se=new SimpleExecution(remoteExecutionId,executor,null,callableData,null,false);
  mapRemoteExecutions.put(remoteExecutionId,se);
  executor.execute(se);
  packet.returnToContainer();
}","public void handleRemoteExecution(Packet packet){
  log(""String_Node_Str"" + packet);
  final Data callableData=IOUtil.doTake(packet.value);
  final RemoteExecutionId remoteExecutionId=new RemoteExecutionId(packet.conn.getEndPoint(),packet.longValue);
  final SimpleExecution se=new SimpleExecution(remoteExecutionId,executor,null,callableData,null,false);
  mapRemoteExecutions.put(remoteExecutionId,se);
  executeLocally(se);
  packet.returnToContainer();
}",0.9803921568627452
50504,"public Processable createNewExecutionAction(final DistributedTask task){
  if (task == null)   throw new RuntimeException(""String_Node_Str"");
  try {
    final Long executionId=executionIds.take();
    final InnerFutureTask inner=(InnerFutureTask)task.getInner();
    final Callable callable=inner.getCallable();
    final Data callableData=ThreadContext.get().toData(callable);
    final DistributedExecutorAction action=new DistributedExecutorAction(executionId,task,callableData,callable);
    inner.setExecutionManagerCallback(action);
    return action;
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
  return null;
}","public Processable createNewExecutionAction(final DistributedTask task){
  if (task == null)   throw new RuntimeException(""String_Node_Str"");
  try {
    final Long executionId=executionIds.take();
    final InnerFutureTask inner=(InnerFutureTask)task.getInner();
    final Callable callable=inner.getCallable();
    final Data callableData=toData(callable);
    final DistributedExecutorAction action=new DistributedExecutorAction(executionId,task,callableData,callable);
    inner.setExecutionManagerCallback(action);
    return action;
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
  return null;
}",0.9841017488076312
50505,"public void writeData(DataOutput out) throws IOException {
  out.writeUTF(name);
  out.writeUTF(factory.getName());
}","public void writeData(DataOutput out) throws IOException {
  out.writeUTF(name);
}",0.8241206030150754
50506,"public void readData(DataInput in) throws IOException {
  setName(in.readUTF());
  setFactory(getFactoryImpl(in.readUTF()));
}","public void readData(DataInput in) throws IOException {
  setName(in.readUTF());
  setFactory(ThreadContext.get().getCurrentFactory());
}",0.8365019011406845
50507,"private void beforeCall(){
  initialChecks();
  if (mproxyReal == null) {
    mproxyReal=(MProxy)factory.getOrCreateProxyByName(name);
  }
}","private void beforeCall(){
  ThreadContext.get().setCurrentFactory(factory);
  initialChecks();
  if (mproxyReal == null) {
    mproxyReal=(MProxy)factory.getOrCreateProxyByName(name);
  }
}",0.8484848484848485
50508,"public Object[] toArray(Object[] a){
  throw new UnsupportedOperationException();
}","public Object[] toArray(Object[] a){
  int size=size();
  if (size == 0) {
    return null;
  }
  if (a == null || a.length < size) {
    a=new Object[size];
  }
  for (int i=0; i < size; i++) {
    a[i]=toObject(lsValues.get(i));
  }
  return a;
}",0.2598187311178248
50509,"public int size(){
  return lsValues.size();
}","public int size(){
  return (lsValues == null) ? 0 : lsValues.size();
}",0.7863247863247863
50510,"public Object next(){
  Data value=it.next();
  return ThreadContext.get().toObject(value);
}","public Object next(){
  Data value=it.next();
  return toObject(value);
}",0.8795180722891566
50511,"public Object get(Object key){
  processLocalRecords();
  Record record=mapCache.get(key);
  if (record == null) {
    return OBJECT_REDO;
  }
 else {
    if (record.isActive()) {
      try {
        Object value=toObject(record.getValue());
        record.setLastAccessed();
        return value;
      }
 catch (      Throwable t) {
        logger.log(Level.FINEST,""String_Node_Str"",t);
        return OBJECT_REDO;
      }
    }
 else {
      mapCache.remove(key);
      return null;
    }
  }
}","public Object get(Object key){
  processLocalRecords();
  Record record=mapCache.get(key);
  if (record == null) {
    return OBJECT_REDO;
  }
 else {
    if (record.isActive() && record.isValid()) {
      try {
        Object value=toObject(record.getValue());
        record.setLastAccessed();
        return value;
      }
 catch (      Throwable t) {
        logger.log(Level.FINEST,""String_Node_Str"",t);
        return OBJECT_REDO;
      }
    }
 else {
      mapCache.remove(key);
      return OBJECT_REDO;
    }
  }
}",0.940254652301665
50512,"public <K,V>IMap<K,V> getMap(String name){
  String prefix=""String_Node_Str"";
  return (IMap<K,V>)getClientProxy(prefix,name);
}","public <K,V>IMap<K,V> getMap(String name){
  String prefix=MAP_PREFIX;
  return (IMap<K,V>)getClientProxy(prefix,name);
}",0.8995983935742972
50513,"public Object getId(){
  return null;
}","public Object getId(){
  return doOp(ClusterOperation.GET_ID,null,null);
}",0.6902654867256637
50514,"public void destroy(){
  clear();
}","public void destroy(){
  doOp(ClusterOperation.DESTROY,null,null);
  this.client.destroy(""String_Node_Str"" + name);
}",0.4342105263157895
50515,"public void addIndex(String attribute,boolean ordered){
}","public void addIndex(String attribute,boolean ordered){
  doOp(ClusterOperation.ADD_INDEX,attribute,ordered);
}",0.6785714285714286
50516,"public void addEntryListener(EntryListener<K,V> listener,K key,boolean includeValue){
  if (key != null) {
    if (client.listenerManager.mapOfListeners.containsKey(name) && client.listenerManager.mapOfListeners.get(name).containsKey(null) && client.listenerManager.mapOfListeners.get(name).get(null).size() > 0) {
      client.listenerManager.registerEntryListener(name,key,listener);
      return;
    }
  }
  Packet request=createRequestPacket(ClusterOperation.ADD_LISTENER,toByte(key),null);
  request.setLongValue(includeValue ? 1 : 0);
  Call c=createCall(request);
  client.listenerManager.addListenerCall(c);
  doCall(c);
  client.listenerManager.registerEntryListener(name,key,listener);
}","public void addEntryListener(EntryListener<K,V> listener,K key,boolean includeValue){
  Packet request=createRequestPacket(ClusterOperation.ADD_LISTENER,toByte(key),null);
  request.setLongValue(includeValue ? 1 : 0);
  Call c=createCall(request);
  client.listenerManager.addListenerCall(c);
  doCall(c);
  client.listenerManager.registerEntryListener(name,key,listener);
}",0.6977611940298507
50517,"protected void customRun() throws InterruptedException {
  Packet packet=queue.poll(100,TimeUnit.MILLISECONDS);
  if (packet == null) {
    return;
  }
  EntryEvent event=new EntryEvent(packet.getName(),(int)packet.getLongValue(),Serializer.toObject(packet.getKey()),Serializer.toObject(packet.getValue()));
  fireEvent(event);
}","protected void customRun() throws InterruptedException {
  Packet packet=queue.poll(100,TimeUnit.MILLISECONDS);
  if (packet == null) {
    return;
  }
  EntryEvent event=new EntryEvent(packet.getName(),(int)packet.getLongValue(),toObject(packet.getKey()),toObject(packet.getValue()));
  fireEvent(event);
}",0.9654088050314464
50518,"private void fireEvent(EntryEvent event){
  String name=event.getName();
  Object key=event.getKey();
  System.out.println(event);
  if (mapOfListeners.get(name.substring(2)) != null) {
    notifyListeners(event,mapOfListeners.get(name.substring(2)).get(null));
    notifyListeners(event,mapOfListeners.get(name.substring(2)).get(key));
  }
}","private void fireEvent(EntryEvent event){
  String name=event.getName();
  Object key=event.getKey();
  if (mapOfListeners.get(name.substring(2)) != null) {
    notifyListeners(event,mapOfListeners.get(name.substring(2)).get(null));
    notifyListeners(event,mapOfListeners.get(name.substring(2)).get(key));
  }
}",0.9557251908396946
50519,"@Test @Ignore public void addTwoListener1stToKeyOtherToMap() throws InterruptedException, IOException {
  HazelcastInstance h=Hazelcast.newHazelcastInstance(null);
  hClient=getHazelcastClient(h);
  final IMap<String,String> map=hClient.getMap(""String_Node_Str"");
  final CountDownLatch entryAddLatch=new CountDownLatch(5);
  final CountDownLatch entryUpdatedLatch=new CountDownLatch(5);
  final CountDownLatch entryRemovedLatch=new CountDownLatch(5);
  CountDownLatchEntryListener<String,String> listener1=new CountDownLatchEntryListener<String,String>(entryAddLatch,entryUpdatedLatch,entryRemovedLatch);
  CountDownLatchEntryListener<String,String> listener2=new CountDownLatchEntryListener<String,String>(entryAddLatch,entryUpdatedLatch,entryRemovedLatch);
  map.addEntryListener(listener2,""String_Node_Str"",true);
  map.addEntryListener(listener1,true);
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.remove(""String_Node_Str"");
  Thread.sleep(100);
  assertEquals(3,entryAddLatch.getCount());
  assertEquals(3,entryRemovedLatch.getCount());
  assertEquals(3,entryUpdatedLatch.getCount());
}","@Test public void addTwoListener1stToKeyOtherToMap() throws InterruptedException, IOException {
  HazelcastInstance h=Hazelcast.newHazelcastInstance(null);
  hClient=getHazelcastClient(h);
  final IMap<String,String> map=hClient.getMap(""String_Node_Str"");
  final CountDownLatch entryAddLatch=new CountDownLatch(5);
  final CountDownLatch entryUpdatedLatch=new CountDownLatch(5);
  final CountDownLatch entryRemovedLatch=new CountDownLatch(5);
  CountDownLatchEntryListener<String,String> listener1=new CountDownLatchEntryListener<String,String>(entryAddLatch,entryUpdatedLatch,entryRemovedLatch);
  CountDownLatchEntryListener<String,String> listener2=new CountDownLatchEntryListener<String,String>(entryAddLatch,entryUpdatedLatch,entryRemovedLatch);
  map.addEntryListener(listener2,""String_Node_Str"",true);
  map.addEntryListener(listener1,true);
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.remove(""String_Node_Str"");
  Thread.sleep(100);
  assertEquals(3,entryAddLatch.getCount());
  assertEquals(3,entryRemovedLatch.getCount());
  assertEquals(3,entryUpdatedLatch.getCount());
}",0.9965065502183406
50520,"@Test @Ignore public void lockMap() throws InterruptedException {
  HazelcastInstance h=Hazelcast.newHazelcastInstance(null);
  hClient=getHazelcastClient(h);
  final IMap map=hClient.getMap(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  map.put(""String_Node_Str"",""String_Node_Str"");
  Thread.sleep(1000);
  System.out.println(""String_Node_Str"");
  map.lock(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  new Thread(new Runnable(){
    public void run(){
      map.lock(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      latch.countDown();
    }
  }
).start();
  Thread.sleep(100);
  assertEquals(1,latch.getCount());
  System.out.println(""String_Node_Str"");
  map.unlock(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  assertTrue(latch.await(2000,TimeUnit.MILLISECONDS));
}","@Test public void lockMap() throws InterruptedException {
  HazelcastInstance h=Hazelcast.newHazelcastInstance(null);
  hClient=getHazelcastClient(h);
  final IMap map=hClient.getMap(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  map.put(""String_Node_Str"",""String_Node_Str"");
  Thread.sleep(1000);
  System.out.println(""String_Node_Str"");
  map.lock(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + Thread.currentThread().getId());
  new Thread(new Runnable(){
    public void run(){
      map.lock(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + Thread.currentThread().getId());
      latch.countDown();
    }
  }
).start();
  Thread.sleep(100);
  assertEquals(1,latch.getCount());
  System.out.println(""String_Node_Str"");
  map.unlock(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  assertTrue(latch.await(2000,TimeUnit.MILLISECONDS));
}",0.9580022701475596
50521,"public void addThisAsListener(IMap map,Object key,boolean includeValue){
  if (key == null) {
    map.addEntryListener(this,includeValue);
  }
 else {
    map.addEntryListener(this,key,includeValue);
  }
}","public void addThisAsListener(IMap map,Object key,boolean includeValue){
  String name=((MProxy)map).getLongName();
  Map<Object,EntryEvent> eventProcessedLog=getEventProcessedLog(name);
  if (key == null) {
    map.addEntryListener(this,includeValue);
  }
 else {
    map.addEntryListener(this,key,includeValue);
  }
}",0.7824427480916031
50522,"public ClientService(Node node){
  this.node=node;
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_PUT.getValue()]=new MapPutHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_PUT_IF_ABSENT.getValue()]=new MapPutIfAbsentHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_GET.getValue()]=new MapGetHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REMOVE.getValue()]=new MapRemoveHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REMOVE_IF_SAME.getValue()]=new MapRemoveIfSameHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_EVICT.getValue()]=new MapEvictHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REPLACE_IF_NOT_NULL.getValue()]=new MapReplaceIfNotNullHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REPLACE_IF_SAME.getValue()]=new MapReplaceIfSameHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_SIZE.getValue()]=new MapSizeHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_GET_MAP_ENTRY.getValue()]=new GetMapEntryHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_LOCK.getValue()]=new MapLockHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_UNLOCK.getValue()]=new MapUnlockHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_CONTAINS.getValue()]=new MapContainsKeyHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_CONTAINS_VALUE.getValue()]=new MapContainsValueHandler();
  clientOperationHandlers[ClusterOperation.TRANSACTION_BEGIN.getValue()]=new TransactionBeginHandler();
  clientOperationHandlers[ClusterOperation.TRANSACTION_COMMIT.getValue()]=new TransactionCommitHandler();
  clientOperationHandlers[ClusterOperation.TRANSACTION_ROLLBACK.getValue()]=new TransactionRollbackHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_ITERATE_KEYS.getValue()]=new MapIterateKeysHandler();
  clientOperationHandlers[ClusterOperation.ADD_LISTENER.getValue()]=new AddListenerHandler();
  clientOperationHandlers[ClusterOperation.REMOVE_LISTENER.getValue()]=new RemoveListenerHandler();
  clientOperationHandlers[ClusterOperation.REMOTELY_PROCESS.getValue()]=new RemotelyProcessHandler();
}","public ClientService(Node node){
  this.node=node;
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_PUT.getValue()]=new MapPutHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_PUT_IF_ABSENT.getValue()]=new MapPutIfAbsentHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_GET.getValue()]=new MapGetHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REMOVE.getValue()]=new MapRemoveHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REMOVE_IF_SAME.getValue()]=new MapRemoveIfSameHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_EVICT.getValue()]=new MapEvictHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REPLACE_IF_NOT_NULL.getValue()]=new MapReplaceIfNotNullHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_REPLACE_IF_SAME.getValue()]=new MapReplaceIfSameHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_SIZE.getValue()]=new MapSizeHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_GET_MAP_ENTRY.getValue()]=new GetMapEntryHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_LOCK.getValue()]=new MapLockHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_UNLOCK.getValue()]=new MapUnlockHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_CONTAINS.getValue()]=new MapContainsKeyHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_CONTAINS_VALUE.getValue()]=new MapContainsValueHandler();
  clientOperationHandlers[ClusterOperation.TRANSACTION_BEGIN.getValue()]=new TransactionBeginHandler();
  clientOperationHandlers[ClusterOperation.TRANSACTION_COMMIT.getValue()]=new TransactionCommitHandler();
  clientOperationHandlers[ClusterOperation.TRANSACTION_ROLLBACK.getValue()]=new TransactionRollbackHandler();
  clientOperationHandlers[ClusterOperation.CONCURRENT_MAP_ITERATE_KEYS.getValue()]=new MapIterateKeysHandler();
  clientOperationHandlers[ClusterOperation.ADD_LISTENER.getValue()]=new AddListenerHandler();
  clientOperationHandlers[ClusterOperation.REMOVE_LISTENER.getValue()]=new RemoveListenerHandler();
  clientOperationHandlers[ClusterOperation.REMOTELY_PROCESS.getValue()]=new RemotelyProcessHandler();
  clientOperationHandlers[ClusterOperation.DESTROY.getValue()]=new DestroyHandler();
  clientOperationHandlers[ClusterOperation.GET_ID.getValue()]=new GetIdHandler();
  clientOperationHandlers[ClusterOperation.ADD_INDEX.getValue()]=new AddIndexHandler();
}",0.9467752035065748
50523,"private void processEvent(EntryEvent event){
  Packet packet=createEventPacket(event);
  sendPacket(packet);
}","private void processEvent(EntryEvent event){
  Map<Object,EntryEvent> eventProcessedLog=getEventProcessedLog(event.getName());
  if (eventProcessedLog.get(event.getKey()) != null && eventProcessedLog.get(event.getKey()) == event) {
    return;
  }
  eventProcessedLog.put(event.getKey(),event);
  Object key=listeneds.get(event.getName());
  if (key == null) {
  }
  Packet packet=createEventPacket(event);
  sendPacket(packet);
}",0.1777777777777777
50524,"public CallContext getCallContext(int threadId){
  CallContext context=mapOfCallContexts.get(threadId);
  if (context == null) {
    int locallyMappedThreadId=ThreadContext.get().createNewThreadId();
    context=new CallContext(locallyMappedThreadId,true);
    mapOfCallContexts.put(threadId,context);
  }
  return context;
}","public CallContext getCallContext(int threadId){
  CallContext context=callContexts.get(threadId);
  if (context == null) {
    int locallyMappedThreadId=ThreadContext.get().createNewThreadId();
    context=new CallContext(locallyMappedThreadId,true);
    callContexts.put(threadId,context);
  }
  return context;
}",0.978125
50525,"public boolean backup(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  Record record=getRecord(req.key);
  if (record != null) {
    if (req.version > record.getVersion() + 1) {
      Request reqCopy=new Request();
      reqCopy.setFromRequest(req,true);
      req.key=null;
      req.value=null;
      record.addBackupOp(new VersionedBackupOp(this,reqCopy));
      return true;
    }
 else     if (req.version <= record.getVersion()) {
      return false;
    }
  }
  doBackup(req);
  if (record != null) {
    record.setVersion(req.version);
    record.runBackupOps();
  }
  return true;
}","public boolean backup(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  Record record=getRecord(req.key);
  if (record != null) {
    record.setActive();
    if (req.version > record.getVersion() + 1) {
      Request reqCopy=new Request();
      reqCopy.setFromRequest(req,true);
      req.key=null;
      req.value=null;
      record.addBackupOp(new VersionedBackupOp(this,reqCopy));
      return true;
    }
 else     if (req.version <= record.getVersion()) {
      return false;
    }
  }
  doBackup(req);
  if (record != null) {
    record.setVersion(req.version);
    record.runBackupOps();
  }
  return true;
}",0.9824304538799414
50526,"public void own(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=toRecord(req);
  markAsOwned(record);
  updateIndexes(true,req,record);
  record.setVersion(req.version);
}","public void own(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=toRecord(req);
  markAsActive(record);
  markAsOwned(record);
  updateIndexes(true,req,record);
  record.setVersion(req.version);
}",0.964179104477612
50527,"int getBlockId(Data key){
  int hash=key.hashCode();
  return Math.abs(hash) % BLOCK_COUNT;
}","public int getBlockId(Data key){
  int hash=key.hashCode();
  return Math.abs(hash) % BLOCK_COUNT;
}",0.9637305699481864
50528,"public <T>Future<T> submit(Runnable task,T result){
  DistributedTask dtask;
  if (task instanceof DistributedTask) {
    dtask=(DistributedTask)task;
  }
 else {
    dtask=new DistributedTask(task,result);
  }
  Processable action=node.executorManager.createNewExecutionAction(dtask);
  ClusterService clusterService=node.clusterService;
  clusterService.enqueueAndReturn(action);
  return dtask;
}","public <T>Future<T> submit(Runnable task,T result){
  DistributedTask dtask;
  if (task instanceof DistributedTask) {
    dtask=(DistributedTask)task;
  }
 else {
    check(task);
    dtask=new DistributedTask(task,result);
  }
  Processable action=node.executorManager.createNewExecutionAction(dtask);
  ClusterService clusterService=node.clusterService;
  clusterService.enqueueAndReturn(action);
  return dtask;
}",0.9791411042944784
50529,"public void execute(Runnable command){
  DistributedTask dtask;
  if (command instanceof DistributedTask) {
    dtask=(DistributedTask)command;
  }
 else {
    dtask=new DistributedTask(command,null);
  }
  Processable action=node.executorManager.createNewExecutionAction(dtask);
  node.clusterService.enqueueAndReturn(action);
}","public void execute(Runnable command){
  DistributedTask dtask;
  if (command instanceof DistributedTask) {
    dtask=(DistributedTask)command;
  }
 else {
    check(command);
    dtask=new DistributedTask(command,null);
  }
  Processable action=node.executorManager.createNewExecutionAction(dtask);
  node.clusterService.enqueueAndReturn(action);
}",0.9705014749262536
50530,"public HazelcastInstanceProxy(FactoryImpl factory){
  this.factory=factory;
}","public HazelcastInstanceProxy(FactoryImpl factory){
  this.hazelcastInstance=factory;
}",0.8902439024390244
50531,"public String toString(){
  return ""String_Node_Str"" + getKey() + ""String_Node_Str""+ isRemovable();
}","public String toString(){
  return ""String_Node_Str"" + getKey() + ""String_Node_Str""+ isRemovable()+ ""String_Node_Str""+ isActive()+ ""String_Node_Str""+ isValid();
}",0.7680608365019012
50532,"public Data put(Request req){
  if (ownedRecords.size() >= maxSize) {
    startEviction();
  }
  if (req.value == null) {
    req.value=new Data();
  }
  req.value.hash=(int)req.longValue;
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    Record record=getRecord(req.key);
    if (record != null && record.isActive() && record.getValue() != null) {
      return record.getValue();
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    Record record=getRecord(req.key);
    if (record == null || !record.isActive() || record.getValue() == null) {
      return null;
    }
  }
  Record record=getRecord(req.key);
  Data oldValue=null;
  boolean created=false;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    req.key=null;
    created=true;
  }
 else {
    markAsActive(record);
    oldValue=record.getValue();
    record.setValue(req.value);
    record.incrementVersion();
    touch(record);
    record.setLastUpdated();
  }
  markAsOwned(record);
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  req.value=null;
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,record);
  }
 else {
    concurrentMapManager.fireMapEvent(mapListeners,name,EntryEvent.TYPE_UPDATED,record);
  }
  if (req.txnId != -1) {
    concurrentMapManager.unlock(record);
  }
  updateIndexes(created,req,record);
  markAsDirty(record);
  return oldValue;
}","public void put(Request req){
  if (ownedRecords.size() >= maxSize) {
    startEviction();
  }
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req.key);
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (record != null && record.isActive() && record.getValue() != null) {
      req.response=record.getValue();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (record == null || !record.isActive() || record.getValue() == null) {
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (record == null || !record.isActive() || !record.isValid()) {
      req.response=Boolean.FALSE;
      req.value=null;
      req.key=null;
      return;
    }
    ConcurrentMapManager.MultiData multiData=(ConcurrentMapManager.MultiData)toObject(req.value);
    if (multiData == null || multiData.size() != 2) {
      throw new RuntimeException(""String_Node_Str"" + multiData);
    }
    Data expectedOldValue=multiData.getData(0);
    Data newValue=multiData.getData(1);
    req.value=newValue;
    if (!record.getValue().equals(expectedOldValue)) {
      req.response=Boolean.FALSE;
      return;
    }
  }
  req.value.hash=(int)req.longValue;
  Data oldValue=null;
  boolean created=false;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    req.key=null;
    created=true;
  }
 else {
    markAsActive(record);
    oldValue=record.getValue();
    record.setValue(req.value);
    record.incrementVersion();
    touch(record);
    record.setLastUpdated();
  }
  markAsOwned(record);
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  req.value=null;
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,record);
  }
 else {
    concurrentMapManager.fireMapEvent(mapListeners,name,EntryEvent.TYPE_UPDATED,record);
  }
  if (req.txnId != -1) {
    concurrentMapManager.unlock(record);
  }
  updateIndexes(created,req,record);
  markAsDirty(record);
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}",0.7154160982264666
50533,"ConcurrentMapManager(Node node){
  super(node);
  blocks=new Block[BLOCK_COUNT];
  maps=new ConcurrentHashMap<String,CMap>(10);
  mapLocallyOwnedMaps=new ConcurrentHashMap<String,LocallyOwnedMap>(10);
  orderedExecutionTasks=new OrderedExecutionTask[BLOCK_COUNT];
  mapMigrator=new MapMigrator(this);
  for (int i=0; i < BLOCK_COUNT; i++) {
    orderedExecutionTasks[i]=new OrderedExecutionTask();
  }
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      Collection<CMap> cmaps=maps.values();
      for (      CMap cmap : cmaps) {
        cmap.startRemove();
        if (cmap.ttl != 0) {
          cmap.startEviction();
        }
        if (cmap.writeDelaySeconds > 0) {
          cmap.startAsyncStoreWrite();
        }
      }
    }
  }
);
  node.clusterService.registerPeriodicRunnable(mapMigrator);
  registerPacketProcessor(CONCURRENT_MAP_GET_MAP_ENTRY,new GetMapEnryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET,new GetOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_IF_ABSENT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_MULTI,new PutMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_IF_SAME,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_ITEM,new RemoveItemOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_ADD,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE_MULTI,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_LOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_LOCK,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK_RETURN_OLD,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK,new UnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_ENTRIES,new QueryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_VALUES,new QueryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_KEYS,new QueryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_KEYS_ALL,new QueryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_MIGRATE_RECORD,new MigrationOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_MULTI,new RemoveMultiOperationHander());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_LIST,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_SET,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_SIZE,new SizeOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS,new ContainsOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_VALUE,new ContainsValueOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BLOCK_INFO,new BlockInfoOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BLOCKS,new BlocksOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_MIGRATION_COMPLETE,new MigrationCompleteOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_VALUE_COUNT,new ValueCountOperationHandler());
}","ConcurrentMapManager(Node node){
  super(node);
  blocks=new Block[BLOCK_COUNT];
  maps=new ConcurrentHashMap<String,CMap>(10);
  mapLocallyOwnedMaps=new ConcurrentHashMap<String,LocallyOwnedMap>(10);
  orderedExecutionTasks=new OrderedExecutionTask[BLOCK_COUNT];
  mapMigrator=new MapMigrator(this);
  for (int i=0; i < BLOCK_COUNT; i++) {
    orderedExecutionTasks[i]=new OrderedExecutionTask();
  }
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      Collection<CMap> cmaps=maps.values();
      for (      CMap cmap : cmaps) {
        cmap.startRemove();
        if (cmap.ttl != 0) {
          cmap.startEviction();
        }
        if (cmap.writeDelaySeconds > 0) {
          cmap.startAsyncStoreWrite();
        }
      }
    }
  }
);
  node.clusterService.registerPeriodicRunnable(mapMigrator);
  registerPacketProcessor(CONCURRENT_MAP_GET_MAP_ENTRY,new GetMapEnryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET,new GetOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_IF_ABSENT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_SAME,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_MULTI,new PutMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_IF_SAME,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_ITEM,new RemoveItemOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_ADD,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE_MULTI,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_LOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_LOCK,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK_RETURN_OLD,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK,new UnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_ENTRIES,new QueryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_VALUES,new QueryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_KEYS,new QueryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_KEYS_ALL,new QueryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_MIGRATE_RECORD,new MigrationOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_MULTI,new RemoveMultiOperationHander());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_LIST,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_SET,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_SIZE,new SizeOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS,new ContainsOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_VALUE,new ContainsValueOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BLOCK_INFO,new BlockInfoOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BLOCKS,new BlocksOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_MIGRATION_COMPLETE,new MigrationCompleteOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_VALUE_COUNT,new ValueCountOperationHandler());
}",0.988150006970584
50534,"private Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getCurrentTxn();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    try {
      if (!txn.has(name,key)) {
        MLock mlock=new MLock();
        boolean locked=mlock.lockAndReturnOld(name,key,DEFAULT_TXN_TIMEOUT,txn.getId());
        if (!locked)         throwCME(key);
        Object oldObject=null;
        Data oldValue=mlock.oldValue;
        if (oldValue != null) {
          oldObject=toObject(oldValue);
        }
        txn.attachPutOp(name,key,value,(oldObject == null));
        return threadContext.isClient() ? oldValue : oldObject;
      }
 else {
        return txn.attachPutOp(name,key,value,false);
      }
    }
 catch (    Exception e1) {
      e1.printStackTrace();
    }
    return null;
  }
 else {
    setLocal(operation,name,key,value,timeout,-1);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    doOp();
    Object oldValue=getResultAsObject();
    if (oldValue instanceof AddressAwareException) {
      rethrowException(operation,(AddressAwareException)oldValue);
    }
    backup(CONCURRENT_MAP_BACKUP_PUT);
    return oldValue;
  }
}","private Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getCurrentTxn();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndReturnOld(name,key,DEFAULT_TXN_TIMEOUT,txn.getId());
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=toObject(oldValue);
      }
      txn.attachPutOp(name,key,value,(oldObject == null));
      return threadContext.isClient() ? oldValue : oldObject;
    }
 else {
      return txn.attachPutOp(name,key,value,false);
    }
  }
 else {
    setLocal(operation,name,key,value,timeout,-1);
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    doOp();
    Object returnObject=getResultAsObject();
    if (returnObject instanceof AddressAwareException) {
      rethrowException(operation,(AddressAwareException)returnObject);
    }
    backup(CONCURRENT_MAP_BACKUP_PUT);
    return returnObject;
  }
}",0.888637221593054
50535,"public boolean replace(Object key,Object oldValue,Object newValue){
  check(key);
  check(newValue);
  throw new UnsupportedOperationException();
}","public boolean replace(Object key,Object oldValue,Object newValue){
  check(key);
  check(oldValue);
  check(newValue);
  MPut mput=concurrentMapManager.new MPut();
  return mput.replace(name,key,oldValue,newValue,-1);
}",0.5231607629427792
50536,"public Object get(final String name,final Object key){
  final TransactionRecord rec=findTransactionRecord(name,key);
  if (rec == null)   return null;
  if (rec.removed)   return null;
  return rec.value;
}","public Object get(final String name,final Object key){
  final TransactionRecord rec=findTransactionRecord(name,key);
  if (rec == null)   return null;
  if (rec.removed)   return null;
  rec.lastAccess=System.currentTimeMillis();
  return rec.value;
}",0.9019607843137256
50537,"@Test public void addListenerWithTwoMemberClusterAndKillOne() throws InterruptedException, IOException {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(null);
  Map realMap=h3.getMap(""String_Node_Str"");
  Map<Integer,HazelcastInstance> memberMap=getMapOfClustorMembers(h1,h2);
  client=getHazelcastClient(h1,h2);
  IMap<String,String> map=client.getMap(""String_Node_Str"");
  final CountDownLatch entryAddLatch=new CountDownLatch(2);
  final CountDownLatch entryUpdatedLatch=new CountDownLatch(2);
  final CountDownLatch entryRemovedLatch=new CountDownLatch(2);
  map.addEntryListener(new EntryListener(){
    public void entryAdded(    EntryEvent event){
      System.out.println(""String_Node_Str"" + event.getValue());
      assertEquals(""String_Node_Str"",event.getKey());
      entryAddLatch.countDown();
    }
    public void entryRemoved(    EntryEvent event){
      System.out.println(""String_Node_Str"" + event.getValue());
      entryRemovedLatch.countDown();
      assertEquals(""String_Node_Str"",event.getKey());
      assertEquals(""String_Node_Str"",event.getValue());
    }
    public void entryUpdated(    EntryEvent event){
      System.out.println(""String_Node_Str"" + event.getValue());
      assertEquals(""String_Node_Str"",event.getValue());
      assertEquals(""String_Node_Str"",event.getKey());
      entryUpdatedLatch.countDown();
    }
    public void entryEvicted(    EntryEvent event){
      entryRemoved(event);
    }
  }
,true);
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  realMap.remove(""String_Node_Str"");
  memberMap.remove(client.getConnectionManager().getConnection().getAddress().getPort()).shutdown();
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  realMap.remove(""String_Node_Str"");
  assertTrue(entryAddLatch.await(10,TimeUnit.MILLISECONDS));
  assertTrue(entryUpdatedLatch.await(10,TimeUnit.MILLISECONDS));
  assertTrue(entryRemovedLatch.await(10,TimeUnit.MILLISECONDS));
}","@Test public void addListenerWithTwoMemberClusterAndKillOne() throws InterruptedException, IOException {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(null);
  Map realMap=h3.getMap(""String_Node_Str"");
  Map<Integer,HazelcastInstance> memberMap=getMapOfClusterMembers(h1,h2);
  client=getHazelcastClient(h1,h2);
  IMap<String,String> map=client.getMap(""String_Node_Str"");
  final CountDownLatch entryAddLatch=new CountDownLatch(2);
  final CountDownLatch entryUpdatedLatch=new CountDownLatch(2);
  final CountDownLatch entryRemovedLatch=new CountDownLatch(2);
  map.addEntryListener(new EntryListener(){
    public void entryAdded(    EntryEvent event){
      System.out.println(""String_Node_Str"" + event.getValue());
      assertEquals(""String_Node_Str"",event.getKey());
      entryAddLatch.countDown();
    }
    public void entryRemoved(    EntryEvent event){
      System.out.println(""String_Node_Str"" + event.getValue());
      entryRemovedLatch.countDown();
      assertEquals(""String_Node_Str"",event.getKey());
      assertEquals(""String_Node_Str"",event.getValue());
    }
    public void entryUpdated(    EntryEvent event){
      System.out.println(""String_Node_Str"" + event.getValue());
      assertEquals(""String_Node_Str"",event.getValue());
      assertEquals(""String_Node_Str"",event.getKey());
      entryUpdatedLatch.countDown();
    }
    public void entryEvicted(    EntryEvent event){
      entryRemoved(event);
    }
  }
,true);
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  realMap.remove(""String_Node_Str"");
  memberMap.remove(client.getConnectionManager().getConnection().getAddress().getPort()).shutdown();
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  realMap.remove(""String_Node_Str"");
  assertTrue(entryAddLatch.await(10,TimeUnit.MILLISECONDS));
  assertTrue(entryUpdatedLatch.await(10,TimeUnit.MILLISECONDS));
  assertTrue(entryRemovedLatch.await(10,TimeUnit.MILLISECONDS));
}",0.9995316159250586
50538,"@Test public void continuePutAndGetIfOneOfConnectedClusterMemberFails() throws InterruptedException, IOException {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(null);
  client=getHazelcastClient(h1,h2);
  Map realMap=h3.getMap(""String_Node_Str"");
  Map<Integer,HazelcastInstance> memberMap=getMapOfClustorMembers(h1,h2);
  Map<String,Integer> map=client.getMap(""String_Node_Str"");
  int counter=0;
  while (counter < 2) {
    map.put(""String_Node_Str"",counter);
    assertEquals(counter,realMap.get(""String_Node_Str""));
    assertEquals(counter,map.get(""String_Node_Str""));
    memberMap.get(client.getConnectionManager().getConnection().getAddress().getPort()).shutdown();
    counter++;
  }
}","@Test public void continuePutAndGetIfOneOfConnectedClusterMemberFails() throws InterruptedException, IOException {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(null);
  client=getHazelcastClient(h1,h2);
  Map realMap=h3.getMap(""String_Node_Str"");
  Map<Integer,HazelcastInstance> memberMap=getMapOfClusterMembers(h1,h2);
  Map map=client.getMap(""String_Node_Str"");
  int counter=0;
  while (counter < 2) {
    map.put(""String_Node_Str"",counter);
    assertEquals(counter,realMap.get(""String_Node_Str""));
    assertEquals(counter,map.get(""String_Node_Str""));
    memberMap.get(client.getConnectionManager().getConnection().getAddress().getPort()).shutdown();
    counter++;
  }
}",0.988984088127295
50539,"@Test(expected=RuntimeException.class) public void throwsRuntimeExceptionWhenNoMemberToConnect() throws InterruptedException, IOException {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(null);
  Map realMap=h3.getMap(""String_Node_Str"");
  Map<Integer,HazelcastInstance> memberMap=getMapOfClustorMembers(h1,h2);
  client=getHazelcastClient(h1,h2);
  Map<String,Integer> map=client.getMap(""String_Node_Str"");
  int counter=0;
  realMap.get(""String_Node_Str"");
  while (counter < 3) {
    System.out.println(""String_Node_Str"" + counter);
    map.put(""String_Node_Str"",counter);
    assertEquals(counter,map.get(""String_Node_Str""));
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    assertEquals(counter,realMap.get(""String_Node_Str""));
    memberMap.get(client.getConnectionManager().getConnection().getAddress().getPort()).shutdown();
    System.out.println(""String_Node_Str"");
    counter++;
  }
}","@Test(expected=RuntimeException.class) public void throwsRuntimeExceptionWhenNoMemberToConnect() throws InterruptedException, IOException {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(null);
  Map realMap=h3.getMap(""String_Node_Str"");
  Map<Integer,HazelcastInstance> memberMap=getMapOfClusterMembers(h1,h2);
  client=getHazelcastClient(h1,h2);
  Map map=client.getMap(""String_Node_Str"");
  int counter=0;
  realMap.get(""String_Node_Str"");
  while (counter < 3) {
    System.out.println(""String_Node_Str"" + counter);
    map.put(""String_Node_Str"",counter);
    assertEquals(counter,map.get(""String_Node_Str""));
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    assertEquals(counter,realMap.get(""String_Node_Str""));
    memberMap.get(client.getConnectionManager().getConnection().getAddress().getPort()).shutdown();
    System.out.println(""String_Node_Str"");
    counter++;
  }
}",0.9914933837429112
50540,"public void begin() throws ResourceException {
  log(this,""String_Node_Str"");
  ThreadContext.get().getTransaction().begin();
  fireConnectionEvent(ConnectionEvent.LOCAL_TRANSACTION_STARTED);
}","public void begin() throws ResourceException {
  log(this,""String_Node_Str"");
  Hazelcast.getTransaction().begin();
  fireConnectionEvent(ConnectionEvent.LOCAL_TRANSACTION_STARTED);
}",0.9414893617021276
50541,"protected void writeObject(DataOutput out,Object obj) throws IOException {
  if (obj == null) {
    out.writeByte(0);
  }
  if (obj instanceof Long) {
    out.writeByte(1);
    out.writeLong((Long)obj);
  }
 else   if (obj instanceof Integer) {
    out.writeByte(2);
    out.writeInt((Integer)obj);
  }
 else   if (obj instanceof String) {
    out.writeByte(3);
    out.writeUTF((String)obj);
  }
 else   if (obj instanceof Double) {
    out.writeByte(4);
    out.writeDouble((Double)obj);
  }
 else   if (obj instanceof Float) {
    out.writeByte(5);
    out.writeDouble((Float)obj);
  }
 else   if (obj instanceof Boolean) {
    out.writeByte(6);
    out.writeBoolean((Boolean)obj);
  }
 else {
    out.writeByte(7);
    ByteArrayOutputStream bos=new ByteArrayOutputStream();
    ObjectOutputStream oos=new ObjectOutputStream(bos);
    oos.writeObject(obj);
    oos.close();
    byte[] buf=bos.toByteArray();
    out.writeInt(buf.length);
    out.write(buf);
  }
}","protected void writeObject(DataOutput out,Object obj) throws IOException {
  if (obj == null) {
    out.writeByte(0);
  }
  if (obj instanceof Long) {
    out.writeByte(1);
    out.writeLong((Long)obj);
  }
 else   if (obj instanceof Integer) {
    out.writeByte(2);
    out.writeInt((Integer)obj);
  }
 else   if (obj instanceof String) {
    out.writeByte(3);
    out.writeUTF((String)obj);
  }
 else   if (obj instanceof Double) {
    out.writeByte(4);
    out.writeDouble((Double)obj);
  }
 else   if (obj instanceof Float) {
    out.writeByte(5);
    out.writeDouble((Float)obj);
  }
 else   if (obj instanceof Boolean) {
    out.writeByte(6);
    out.writeBoolean((Boolean)obj);
  }
 else   if (obj instanceof DataSerializable) {
    out.writeByte(7);
    out.writeUTF(obj.getClass().getName());
    ((DataSerializable)obj).writeData(out);
  }
 else {
    out.writeByte(8);
    ByteArrayOutputStream bos=new ByteArrayOutputStream();
    ObjectOutputStream oos=new ObjectOutputStream(bos);
    oos.writeObject(obj);
    oos.close();
    byte[] buf=bos.toByteArray();
    out.writeInt(buf.length);
    out.write(buf);
  }
}",0.9230769230769232
50542,"protected Object readObject(DataInput in) throws IOException {
  byte type=in.readByte();
  if (type == 0) {
    return null;
  }
 else   if (type == 1) {
    return in.readInt();
  }
 else   if (type == 2) {
    return in.readInt();
  }
 else   if (type == 3) {
    return in.readUTF();
  }
 else   if (type == 4) {
    return in.readDouble();
  }
 else   if (type == 5) {
    return in.readFloat();
  }
 else   if (type == 6) {
    return in.readBoolean();
  }
 else   if (type == 7) {
    int len=in.readInt();
    byte[] buf=new byte[len];
    in.readFully(buf);
    ObjectInputStream oin=new ObjectInputStream(new ByteArrayInputStream(buf));
    try {
      return oin.readObject();
    }
 catch (    ClassNotFoundException e) {
      e.printStackTrace();
    }
    oin.close();
  }
 else {
    throw new IOException(""String_Node_Str"" + type);
  }
  return null;
}","protected Object readObject(DataInput in) throws IOException {
  byte type=in.readByte();
  if (type == 0) {
    return null;
  }
 else   if (type == 1) {
    return in.readInt();
  }
 else   if (type == 2) {
    return in.readInt();
  }
 else   if (type == 3) {
    return in.readUTF();
  }
 else   if (type == 4) {
    return in.readDouble();
  }
 else   if (type == 5) {
    return in.readFloat();
  }
 else   if (type == 6) {
    return in.readBoolean();
  }
 else   if (type == 7) {
    DataSerializable ds=null;
    try {
      ds=(DataSerializable)Class.forName(in.readUTF()).newInstance();
    }
 catch (    Throwable e) {
      throw new IOException(e.getMessage());
    }
    ds.readData(in);
    return ds;
  }
 else   if (type == 8) {
    int len=in.readInt();
    byte[] buf=new byte[len];
    in.readFully(buf);
    ObjectInputStream oin=new ObjectInputStream(new ByteArrayInputStream(buf));
    try {
      return oin.readObject();
    }
 catch (    ClassNotFoundException e) {
      e.printStackTrace();
    }
    oin.close();
  }
 else {
    throw new IOException(""String_Node_Str"" + type);
  }
  return null;
}",0.5688532799198798
50543,"public void doLocalOp(){
  if (isMigrationAware() && isMigrating()) {
    setResult(OBJECT_REDO);
  }
 else {
    request.attachment=TargetAwareOp.this;
    request.local=true;
    ((RequestHandler)getPacketProcessor(request.operation)).handle(request);
  }
}","public void doLocalOp(){
  if (isMigrationAware() && isMigrating(request)) {
    setResult(OBJECT_REDO);
  }
 else {
    request.attachment=TargetAwareOp.this;
    request.local=true;
    ((RequestHandler)getPacketProcessor(request.operation)).handle(request);
  }
}",0.9866666666666668
50544,"public void processMigrationAware(Packet packet){
  if (isMigrating()) {
    packet.responseType=RESPONSE_REDO;
    sendResponse(packet);
  }
 else {
    Request remoteReq=new Request();
    remoteReq.setFromPacket(packet);
    remoteReq.local=false;
    handle(remoteReq);
    packet.returnToContainer();
  }
}","public void processMigrationAware(Packet packet){
  Request remoteReq=new Request();
  remoteReq.setFromPacket(packet);
  remoteReq.local=false;
  if (isMigrating(remoteReq)) {
    packet.responseType=RESPONSE_REDO;
    sendResponse(packet);
  }
 else {
    handle(remoteReq);
    packet.returnToContainer();
  }
}",0.5632
50545,"protected boolean isMigrating(){
  return false;
}","protected boolean isMigrating(Request req){
  return false;
}",0.9009009009009008
50546,"public Connection getConnection(){
  if (currentConnection == null) {
synchronized (ConnectionManager.class) {
      if (currentConnection == null) {
        currentConnection=searchForAvailableConnection();
        if (currentConnection != null) {
          logger.info(""String_Node_Str"" + currentConnection);
          bind(currentConnection);
          out.redoWaitingCalls();
        }
      }
    }
  }
  return currentConnection;
}","public Connection getConnection() throws IOException {
  Connection connection=null;
  if (currentConnection == null) {
synchronized (ConnectionManager.class) {
      if (currentConnection == null) {
        connection=searchForAvailableConnection();
        if (connection != null) {
          logger.info(""String_Node_Str"" + connection);
          bind(connection);
          currentConnection=connection;
          out.redoWaitingCalls();
        }
      }
    }
  }
  return currentConnection;
}",0.8525641025641025
50547,"private void bind(Connection connection){
  Bind b=null;
  try {
    b=new Bind(new Address(connection.getAddress().getHostName(),connection.getSocket().getLocalPort()));
  }
 catch (  UnknownHostException e) {
    e.printStackTrace();
  }
  Packet bind=new Packet();
  bind.set(""String_Node_Str"",ClusterOperation.REMOTELY_PROCESS,Serializer.toByte(null),Serializer.toByte(b));
  Call cBind=new Call();
  cBind.setRequest(bind);
  out.enQueue(cBind);
}","private void bind(Connection connection) throws IOException {
  Bind b=null;
  try {
    b=new Bind(new Address(connection.getAddress().getHostName(),connection.getSocket().getLocalPort()));
  }
 catch (  UnknownHostException e) {
    e.printStackTrace();
  }
  Packet bind=new Packet();
  bind.set(""String_Node_Str"",ClusterOperation.REMOTELY_PROCESS,Serializer.toByte(null),Serializer.toByte(b));
  Call cBind=new Call();
  cBind.setRequest(bind);
  out.writer.write(connection,bind);
  try {
    Thread.sleep(10);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}",0.8420038535645472
50548,"public void run(){
  while (true) {
    Connection connection=connectionManager.getConnection();
    if (connection == null) {
      notifyWaitingCalls();
      continue;
    }
    Packet packet=null;
    try {
      packet=reader.readPacket(connection);
      Call c=callMap.remove(packet.getCallId());
      if (c != null) {
synchronized (c) {
          c.setResponse(packet);
          c.notify();
        }
      }
 else {
        if (packet.getOperation().equals(ClusterOperation.EVENT)) {
          listenerManager.enqueue(packet);
        }
      }
    }
 catch (    IOException e) {
      connectionManager.destroyConnection(connection);
      continue;
    }
  }
}","public void run(){
  while (true) {
    Connection connection=null;
    Packet packet=null;
    try {
      connection=connectionManager.getConnection();
      if (connection == null) {
        notifyWaitingCalls();
        continue;
      }
      packet=reader.readPacket(connection);
      Call c=null;
      if (packet.isRedoOnDisConnect()) {
        c=callMap.get(packet.getCallId());
      }
 else {
        c=callMap.remove(packet.getCallId());
      }
      if (c != null) {
synchronized (c) {
          c.setResponse(packet);
          c.notify();
        }
      }
 else {
        if (packet.getOperation().equals(ClusterOperation.EVENT)) {
          listenerManager.enqueue(packet);
        }
      }
    }
 catch (    IOException e) {
      connectionManager.destroyConnection(connection);
      continue;
    }
  }
}",0.8234510326449034
50549,"public void addEntryListener(EntryListener listener,K key,boolean includeValue){
  Packet request=createRequestPacket();
  request.setOperation(ClusterOperation.ADD_LISTENER);
  request.setLongValue(includeValue ? 1 : 0);
  request.setKey(Serializer.toByte(key));
  callAndGetResult(request);
  client.listenerManager.registerEntryListener(name,key,listener);
}","public void addEntryListener(EntryListener listener,K key,boolean includeValue){
  Packet request=createRequestPacket();
  request.setOperation(ClusterOperation.ADD_LISTENER);
  request.setLongValue(includeValue ? 1 : 0);
  request.setKey(Serializer.toByte(key));
  request.setRedoOnDisConnect(true);
  callAndGetResult(request);
  client.listenerManager.registerEntryListener(name,key,listener);
}",0.9512516469038208
50550,"public void run(){
  while (true) {
    Connection connection=null;
    Call c=null;
    try {
      try {
        c=queue.take();
        callMap.put(c.getId(),c);
        connection=connectionManager.getConnection();
        writer.write(connection,c.getRequest());
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
 catch (    IOException io) {
      io.printStackTrace();
      connectionManager.destroyConnection(connection);
      continue;
    }
  }
}","public void run(){
  while (true) {
    Connection connection=null;
    Call c=null;
    try {
      try {
        c=queue.take();
        callMap.put(c.getId(),c);
        connection=connectionManager.getConnection();
        if (connection != null) {
          writer.write(connection,c.getRequest());
        }
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
 catch (    IOException io) {
      io.printStackTrace();
      connectionManager.destroyConnection(connection);
      continue;
    }
  }
}",0.9559386973180076
50551,"private void redo(Call call){
  callMap.remove(call.getId());
  enQueue(call);
}","private void redo(Call call){
  System.out.println(""String_Node_Str"" + call);
  callMap.remove(call.getId());
  enQueue(call);
}",0.7692307692307693
50552,"public void redoWaitingCalls(){
  Collection<Call> cc=callMap.values();
  List<Call> waitingCalls=new ArrayList<Call>();
  waitingCalls.addAll(cc);
  for (Iterator<Call> iterator=waitingCalls.iterator(); iterator.hasNext(); ) {
    Call call=iterator.next();
    redo(call);
  }
}","public void redoWaitingCalls(){
  Collection<Call> cc=callMap.values();
  List<Call> waitingCalls=new ArrayList<Call>();
  waitingCalls.addAll(cc);
  for (Iterator<Call> iterator=waitingCalls.iterator(); iterator.hasNext(); ) {
    Call call=iterator.next();
    if (call.getRequest().isRedoOnDisConnect()) {
      redo(call);
    }
  }
}",0.8673139158576052
50553,"public Config(){
  final String superClientProp=System.getProperty(""String_Node_Str"");
  if (superClientProp != null) {
    if (""String_Node_Str"".equalsIgnoreCase(superClientProp)) {
      superClient=true;
    }
  }
}","public Config(){
  final String superClientProp=System.getProperty(""String_Node_Str"");
  if (superClientProp != null) {
    if (""String_Node_Str"".equalsIgnoreCase(superClientProp)) {
      superClient=true;
    }
  }
  String os=System.getProperty(""String_Node_Str"").toLowerCase();
  reuseAddress=(os.indexOf(""String_Node_Str"") == -1);
}",0.7855855855855856
50554,"public void parse(final Config config) throws Exception {
  this.config=config;
  final DocumentBuilder builder=DocumentBuilderFactory.newInstance().newDocumentBuilder();
  Document doc=null;
  try {
    doc=builder.parse(in);
    final ByteArrayOutputStream baos=new ByteArrayOutputStream();
    Util.streamXML(doc,baos);
    final byte[] bytes=baos.toByteArray();
    final ByteArrayInputStream bais=new ByteArrayInputStream(bytes);
    config.setXmlConfig(Util.inputStreamToString(bais));
    if (""String_Node_Str"".equals(System.getProperty(""String_Node_Str""))) {
      logger.log(Level.INFO,""String_Node_Str"" + config.getConfigurationUrl());
      logger.log(Level.INFO,""String_Node_Str"");
      logger.log(Level.INFO,config.getXmlConfig());
      logger.log(Level.INFO,""String_Node_Str"");
      logger.log(Level.INFO,""String_Node_Str"");
    }
  }
 catch (  final Exception e) {
    String msgPart=""String_Node_Str"" + config.getConfigurationFile() + ""String_Node_Str"";
    if (!usingSystemConfig) {
      msgPart=""String_Node_Str"";
    }
    String msg=""String_Node_Str"" + msgPart;
    msg+=""String_Node_Str"" + e.getMessage();
    msg+=""String_Node_Str"";
    logger.log(Level.WARNING,msg);
    return;
  }
  final Element docElement=doc.getDocumentElement();
  try {
    docElement.getTextContent();
  }
 catch (  final Throwable e) {
    domLevel3=false;
  }
  final NodeList nodelist=docElement.getChildNodes();
  for (int i=0; i < nodelist.getLength(); i++) {
    final org.w3c.dom.Node node=nodelist.item(i);
    final String nodeName=node.getNodeName();
    if (""String_Node_Str"".equals(nodeName)) {
      handleNetwork(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleGroup(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleProperties(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleExecutor(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleQueue(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleMap(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleTopic(node);
    }
  }
}","private void parse(final Config config) throws Exception {
  this.config=config;
  final DocumentBuilder builder=DocumentBuilderFactory.newInstance().newDocumentBuilder();
  Document doc=null;
  try {
    doc=builder.parse(in);
    final ByteArrayOutputStream baos=new ByteArrayOutputStream();
    Util.streamXML(doc,baos);
    final byte[] bytes=baos.toByteArray();
    final ByteArrayInputStream bais=new ByteArrayInputStream(bytes);
    config.setXmlConfig(Util.inputStreamToString(bais));
    if (""String_Node_Str"".equals(System.getProperty(""String_Node_Str""))) {
      logger.log(Level.INFO,""String_Node_Str"" + config.getConfigurationUrl());
      logger.log(Level.INFO,""String_Node_Str"");
      logger.log(Level.INFO,config.getXmlConfig());
      logger.log(Level.INFO,""String_Node_Str"");
      logger.log(Level.INFO,""String_Node_Str"");
    }
  }
 catch (  final Exception e) {
    String msgPart=""String_Node_Str"" + config.getConfigurationFile() + ""String_Node_Str"";
    if (!usingSystemConfig) {
      msgPart=""String_Node_Str"";
    }
    String msg=""String_Node_Str"" + msgPart;
    msg+=""String_Node_Str"" + e.getMessage();
    msg+=""String_Node_Str"";
    logger.log(Level.WARNING,msg);
    return;
  }
  final Element docElement=doc.getDocumentElement();
  try {
    docElement.getTextContent();
  }
 catch (  final Throwable e) {
    domLevel3=false;
  }
  final NodeList nodelist=docElement.getChildNodes();
  for (int i=0; i < nodelist.getLength(); i++) {
    final org.w3c.dom.Node node=nodelist.item(i);
    final String nodeName=node.getNodeName();
    if (""String_Node_Str"".equals(nodeName)) {
      handleNetwork(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleGroup(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleProperties(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleExecutor(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleQueue(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleMap(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleTopic(node);
    }
  }
}",0.9974436439693236
50555,"public Address pickAddress(Node node,final ServerSocketChannel serverSocketChannel) throws Exception {
  String currentAddress=null;
  try {
    final Config config=node.getConfig();
    final String localAddress=System.getProperty(""String_Node_Str"");
    if (localAddress != null) {
      currentAddress=InetAddress.getByName(localAddress.trim()).getHostAddress();
    }
    if (currentAddress == null) {
      final Enumeration<NetworkInterface> enums=NetworkInterface.getNetworkInterfaces();
      interfaces:       while (enums.hasMoreElements()) {
        final NetworkInterface ni=enums.nextElement();
        final Enumeration<InetAddress> e=ni.getInetAddresses();
        while (e.hasMoreElements()) {
          final InetAddress inetAddress=e.nextElement();
          if (inetAddress instanceof Inet4Address) {
            final String address=inetAddress.getHostAddress();
            final List<String> interfaces=config.getNetworkConfig().getInterfaces().getLsInterfaces();
            if (config.getNetworkConfig().getInterfaces().isEnabled()) {
              if (matchAddress(address,interfaces)) {
                currentAddress=address;
                break interfaces;
              }
            }
 else {
              if (!inetAddress.isLoopbackAddress()) {
                currentAddress=address;
                break interfaces;
              }
            }
          }
        }
      }
      if (config.getNetworkConfig().getInterfaces().isEnabled() && currentAddress == null) {
        String msg=""String_Node_Str"";
        msg+=""String_Node_Str"";
        logger.log(Level.SEVERE,msg);
        return null;
      }
    }
    if (currentAddress == null) {
      currentAddress=""String_Node_Str"";
    }
    final InetAddress inetAddress=InetAddress.getByName(currentAddress);
    ServerSocket serverSocket=serverSocketChannel.socket();
    serverSocket.setReuseAddress(true);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        isa=new InetSocketAddress(inetAddress,port);
        serverSocket.bind(isa,100);
        break;
      }
 catch (      final Exception e) {
        if (config.isPortAutoIncrement()) {
          serverSocket=serverSocketChannel.socket();
          serverSocket.setReuseAddress(true);
          port++;
        }
 else {
          String msg=""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str"";
          logger.log(Level.SEVERE,msg);
          throw e;
        }
      }
    }
    serverSocketChannel.configureBlocking(false);
    return new Address(currentAddress,port);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
}","public Address pickAddress(Node node,final ServerSocketChannel serverSocketChannel) throws Exception {
  String currentAddress=null;
  try {
    final Config config=node.getConfig();
    final String localAddress=System.getProperty(""String_Node_Str"");
    if (localAddress != null) {
      currentAddress=InetAddress.getByName(localAddress.trim()).getHostAddress();
    }
    if (currentAddress == null) {
      final Enumeration<NetworkInterface> enums=NetworkInterface.getNetworkInterfaces();
      interfaces:       while (enums.hasMoreElements()) {
        final NetworkInterface ni=enums.nextElement();
        final Enumeration<InetAddress> e=ni.getInetAddresses();
        while (e.hasMoreElements()) {
          final InetAddress inetAddress=e.nextElement();
          if (inetAddress instanceof Inet4Address) {
            final String address=inetAddress.getHostAddress();
            final List<String> interfaces=config.getNetworkConfig().getInterfaces().getLsInterfaces();
            if (config.getNetworkConfig().getInterfaces().isEnabled()) {
              if (matchAddress(address,interfaces)) {
                currentAddress=address;
                break interfaces;
              }
            }
 else {
              if (!inetAddress.isLoopbackAddress()) {
                currentAddress=address;
                break interfaces;
              }
            }
          }
        }
      }
      if (config.getNetworkConfig().getInterfaces().isEnabled() && currentAddress == null) {
        String msg=""String_Node_Str"";
        msg+=""String_Node_Str"";
        logger.log(Level.SEVERE,msg);
        return null;
      }
    }
    if (currentAddress == null) {
      currentAddress=""String_Node_Str"";
    }
    final InetAddress inetAddress=InetAddress.getByName(currentAddress);
    final boolean reuseAddress=config.isReuseAddress();
    ServerSocket serverSocket=serverSocketChannel.socket();
    serverSocket.setReuseAddress(reuseAddress);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        isa=new InetSocketAddress(inetAddress,port);
        serverSocket.bind(isa,100);
        break;
      }
 catch (      final Exception e) {
        if (config.isPortAutoIncrement()) {
          serverSocket=serverSocketChannel.socket();
          serverSocket.setReuseAddress(reuseAddress);
          port++;
        }
 else {
          String msg=""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str"";
          logger.log(Level.SEVERE,msg);
          throw e;
        }
      }
    }
    serverSocketChannel.configureBlocking(false);
    return new Address(currentAddress,port);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
}",0.9837278106508875
50556,"public Data put(Request req){
  if (req.value == null) {
    req.value=new Data();
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    Record record=recordExist(req);
    if (record != null && record.isActive() && record.getValue() != null) {
      return doHardCopy(record.getValue());
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    Record record=recordExist(req);
    if (record == null || !record.isActive() || record.getValue() == null) {
      return null;
    }
  }
  Record record=getRecord(req.key);
  Data oldValue=null;
  boolean created=true;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    req.key=null;
  }
 else {
    created=!record.isActive();
    markAsActive(record);
    if (!record.isValid()) {
      record.setExpirationTime(ttl);
    }
    oldValue=record.getValue();
    record.setValue(req.value);
    record.incrementVersion();
    touch(record);
    record.setLastUpdated();
  }
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  req.value=null;
  if (oldValue == null) {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,record);
  }
 else {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_UPDATED,record);
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  updateIndexes(created,req,record);
  markAsDirty(record);
  return oldValue;
}","public Data put(Request req){
  if (ownedEntryCount >= maxSize) {
    startEviction();
  }
  if (req.value == null) {
    req.value=new Data();
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    Record record=recordExist(req);
    if (record != null && record.isActive() && record.getValue() != null) {
      return doHardCopy(record.getValue());
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    Record record=recordExist(req);
    if (record == null || !record.isActive() || record.getValue() == null) {
      return null;
    }
  }
  Record record=getRecord(req.key);
  Data oldValue=null;
  boolean created=true;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    req.key=null;
  }
 else {
    created=!record.isActive();
    if (created) {
      ownedEntryCount++;
    }
    markAsActive(record);
    if (!record.isValid()) {
      record.setExpirationTime(ttl);
    }
    oldValue=record.getValue();
    record.setValue(req.value);
    record.incrementVersion();
    touch(record);
    record.setLastUpdated();
  }
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  req.value=null;
  if (oldValue == null) {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,record);
  }
 else {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_UPDATED,record);
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  updateIndexes(created,req,record);
  markAsDirty(record);
  return oldValue;
}",0.9611752360965372
50557,"void reset(){
  if (locallyOwnedMap != null) {
    locallyOwnedMap.reset();
  }
  mapRecords.clear();
  ownedEntryCount=0;
  evicting=false;
  if (setDirtyRecords != null) {
    setDirtyRecords.clear();
  }
  setRemovedRecords.clear();
  node.queryService.reset(name);
}","void reset(){
  if (locallyOwnedMap != null) {
    locallyOwnedMap.reset();
  }
  mapRecords.clear();
  ownedEntryCount=0;
  if (setDirtyRecords != null) {
    setDirtyRecords.clear();
  }
  setRemovedRecords.clear();
  node.queryService.reset(name);
}",0.9655172413793104
50558,"public boolean putMulti(Request req){
  Record record=getRecord(req.key);
  boolean added=true;
  if (record == null) {
    record=createNewRecord(req.key,null);
    req.key=null;
  }
 else {
    record.setActive();
    if (record.containsValue(req.value)) {
      added=false;
    }
  }
  if (added) {
    node.queryService.updateIndex(name,null,null,record,Integer.MIN_VALUE);
    record.addValue(req.value);
    req.value=null;
    record.setVersion(record.getVersion() + 1);
    touch(record);
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,record.getKey(),req.value,record.getMapListeners());
  }
  logger.log(Level.FINEST,record.getValue() + ""String_Node_Str"" + record.getMultiValues());
  req.version=record.getVersion();
  return added;
}","public boolean putMulti(Request req){
  Record record=getRecord(req.key);
  boolean added=true;
  if (record == null) {
    record=createNewRecord(req.key,null);
    req.key=null;
  }
 else {
    if (!record.isActive()) {
      markAsActive(record);
      ownedEntryCount++;
    }
    if (record.containsValue(req.value)) {
      added=false;
    }
  }
  if (added) {
    node.queryService.updateIndex(name,null,null,record,Integer.MIN_VALUE);
    record.addValue(req.value);
    req.value=null;
    record.setVersion(record.getVersion() + 1);
    touch(record);
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,record.getKey(),req.value,record.getMapListeners());
  }
  logger.log(Level.FINEST,record.getValue() + ""String_Node_Str"" + record.getMultiValues());
  req.version=record.getVersion();
  return added;
}",0.9448319594166138
50559,"public void run(){
  try {
    countDownLatchEvictionStart.await();
    MEvict mEvict=new MEvict();
    mEvict.evict(name,key);
    countDownLatchEvictionEnd.countDown();
  }
 catch (  Exception ignored) {
  }
}","public void run(){
  try {
    MEvict mEvict=new MEvict();
    mEvict.evict(name,key);
  }
 catch (  Exception ignored) {
  }
}",0.7514792899408284
50560,"void startEviction(){
  if (evicting)   return;
  List<Data> lsKeysToEvict=null;
  if (evictionPolicy == OrderingType.NONE) {
    if (ttl != 0) {
      long now=System.currentTimeMillis();
      Collection<Record> values=mapRecords.values();
      for (      Record record : values) {
        if (!record.isValid(now)) {
          if (record.isEvictable()) {
            if (lsKeysToEvict == null) {
              lsKeysToEvict=new ArrayList<Data>(100);
            }
            lsKeysToEvict.add(doHardCopy(record.getKey()));
          }
        }
 else {
          break;
        }
      }
    }
  }
 else {
    Collection<Record> values=mapRecords.values();
    int numberOfRecordsToEvict=(int)(ownedEntryCount * evictionRate);
    int evictedCount=0;
    for (    Record record : values) {
      if (record.isEvictable()) {
        if (lsKeysToEvict == null) {
          lsKeysToEvict=new ArrayList<Data>(numberOfRecordsToEvict);
        }
        lsKeysToEvict.add(doHardCopy(record.getKey()));
        if (++evictedCount >= numberOfRecordsToEvict) {
          break;
        }
      }
    }
  }
  if (lsKeysToEvict != null && lsKeysToEvict.size() > 1) {
    evicting=true;
    int latchCount=lsKeysToEvict.size();
    final CountDownLatch countDownLatchEvictionStart=new CountDownLatch(1);
    final CountDownLatch countDownLatchEvictionEnd=new CountDownLatch(latchCount);
    executeLocally(new Runnable(){
      public void run(){
        try {
          countDownLatchEvictionStart.countDown();
          countDownLatchEvictionEnd.await(60,TimeUnit.SECONDS);
          enqueueAndReturn(new Processable(){
            public void process(){
              evicting=false;
            }
          }
);
        }
 catch (        Exception ignored) {
        }
      }
    }
);
    for (    final Data key : lsKeysToEvict) {
      executeLocally(new Runnable(){
        public void run(){
          try {
            countDownLatchEvictionStart.await();
            MEvict mEvict=new MEvict();
            mEvict.evict(name,key);
            countDownLatchEvictionEnd.countDown();
          }
 catch (          Exception ignored) {
          }
        }
      }
);
    }
  }
}","void startEviction(){
  List<Data> lsKeysToEvict=null;
  if (evictionPolicy == OrderingType.NONE) {
    if (ttl != 0) {
      long now=System.currentTimeMillis();
      Collection<Record> values=mapRecords.values();
      for (      Record record : values) {
        if (record.isActive() && !record.isValid(now)) {
          if (record.isEvictable()) {
            if (lsKeysToEvict == null) {
              lsKeysToEvict=new ArrayList<Data>(100);
            }
            markAsRemoved(record);
            lsKeysToEvict.add(doHardCopy(record.getKey()));
          }
        }
 else {
          break;
        }
      }
    }
  }
 else {
    Collection<Record> values=mapRecords.values();
    int numberOfRecordsToEvict=(int)(ownedEntryCount * evictionRate);
    int evictedCount=0;
    for (    Record record : values) {
      if (record.isActive() && record.isEvictable()) {
        if (lsKeysToEvict == null) {
          lsKeysToEvict=new ArrayList<Data>(numberOfRecordsToEvict);
        }
        markAsRemoved(record);
        lsKeysToEvict.add(doHardCopy(record.getKey()));
        if (++evictedCount >= numberOfRecordsToEvict) {
          break;
        }
      }
    }
  }
  if (lsKeysToEvict != null && lsKeysToEvict.size() > 0) {
    for (    final Data key : lsKeysToEvict) {
      executeLocally(new Runnable(){
        public void run(){
          try {
            MEvict mEvict=new MEvict();
            mEvict.evict(name,key);
          }
 catch (          Exception ignored) {
          }
        }
      }
);
    }
  }
}",0.7297152068780226
50561,"public void start(){
  if (completelyShutdown)   return;
  final Thread inThread=new Thread(threadGroup,inSelector,""String_Node_Str"");
  inThread.setPriority(7);
  inThread.start();
  final Thread outThread=new Thread(threadGroup,outSelector,""String_Node_Str"");
  outThread.setPriority(7);
  outThread.start();
  final Thread clusterServiceThread=new Thread(threadGroup,clusterService,""String_Node_Str"");
  clusterServiceThread.setPriority(8);
  clusterServiceThread.start();
  final Thread queryThread=new Thread(threadGroup,queryService,""String_Node_Str"");
  queryThread.setPriority(6);
  queryThread.start();
  if (config.getNetworkConfig().getJoin().getMulticastConfig().isEnabled()) {
    startMulticastService();
  }
  active=true;
  if (!completelyShutdown) {
    logger.log(Level.FINEST,""String_Node_Str"");
    Runtime.getRuntime().addShutdownHook(shutdownHookThread);
  }
  join();
}","public void start(){
  if (completelyShutdown)   return;
  final Thread inThread=new Thread(threadGroup,inSelector,""String_Node_Str"");
  inThread.setPriority(7);
  inThread.start();
  final Thread outThread=new Thread(threadGroup,outSelector,""String_Node_Str"");
  outThread.setPriority(7);
  outThread.start();
  final Thread clusterServiceThread=new Thread(threadGroup,clusterService,""String_Node_Str"");
  clusterServiceThread.setPriority(8);
  clusterServiceThread.start();
  final Thread queryThread=new Thread(threadGroup,queryService,""String_Node_Str"");
  queryThread.setPriority(6);
  queryThread.start();
  if (config.getNetworkConfig().getJoin().getMulticastConfig().isEnabled()) {
    final Thread multicastServiceThread=new Thread(threadGroup,multicastService,""String_Node_Str"");
    multicastServiceThread.start();
    multicastServiceThread.setPriority(6);
  }
  active=true;
  if (!completelyShutdown) {
    logger.log(Level.FINEST,""String_Node_Str"");
    Runtime.getRuntime().addShutdownHook(shutdownHookThread);
  }
  join();
}",0.8996897621509824
50562,"public void shutdown(){
  try {
    if (active) {
      joined=false;
      active=false;
      inSelector.shutdown();
      outSelector.shutdown();
      clusterService.stop();
      queryService.stop();
      multicastService.stop();
      connectionManager.shutdown();
      concurrentMapManager.reset();
      clientService.reset();
      executorManager.stop();
      address=null;
      masterAddress=null;
      clusterManager.stop();
      int numThreads=threadGroup.activeCount();
      Thread[] threads=new Thread[numThreads * 2];
      numThreads=threadGroup.enumerate(threads,false);
      for (int i=0; i < numThreads; i++) {
        Thread thread=threads[i];
        thread.interrupt();
      }
    }
  }
 catch (  Throwable e) {
    e.printStackTrace();
  }
}","public void shutdown(){
  if (active) {
    joined=false;
    active=false;
    inSelector.shutdown();
    outSelector.shutdown();
    clusterService.stop();
    queryService.stop();
    if (multicastService != null) {
      multicastService.stop();
    }
    connectionManager.shutdown();
    concurrentMapManager.reset();
    clientService.reset();
    executorManager.stop();
    address=null;
    masterAddress=null;
    clusterManager.stop();
    int numThreads=threadGroup.activeCount();
    Thread[] threads=new Thread[numThreads * 2];
    numThreads=threadGroup.enumerate(threads,false);
    for (int i=0; i < numThreads; i++) {
      Thread thread=threads[i];
      thread.interrupt();
    }
  }
}",0.7905405405405406
50563,"@Test public void testMapRemove(){
  IMap<String,String> map=Hazelcast.getMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.remove(""String_Node_Str"");
  assertEquals(0,map.size());
}","@Test public void testMapRemove(){
  IMap<String,String> map=Hazelcast.getMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(1,map.size());
  assertEquals(1,map.keySet().size());
  map.remove(""String_Node_Str"");
  assertEquals(0,map.size());
  assertEquals(0,map.keySet().size());
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(1,map.size());
  assertEquals(1,map.keySet().size());
}",0.6511627906976745
50564,"@Test public void testMultiMapRemove(){
  MultiMap<String,String> map=Hazelcast.getMultiMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  Collection<String> values=map.remove(""String_Node_Str"");
  assertEquals(7,values.size());
  assertEquals(0,map.size());
}","@Test public void testMultiMapRemove(){
  MultiMap<String,String> map=Hazelcast.getMultiMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(7,map.size());
  assertEquals(1,map.keySet().size());
  Collection<String> values=map.remove(""String_Node_Str"");
  assertEquals(7,values.size());
  assertEquals(0,map.size());
  assertEquals(0,map.keySet().size());
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(1,map.size());
  assertEquals(1,map.keySet().size());
}",0.7403072421360644
50565,"void joinReset(){
  joinInProgress=false;
  setJoins.clear();
  timeToStartJoin=System.currentTimeMillis() + WAIT_SECONDS_BEFORE_JOIN + 1000;
}","void joinReset(){
  joinInProgress=false;
  setJoins.clear();
  timeToStartJoin=System.currentTimeMillis() + WAIT_MILLIS_BEFORE_JOIN;
}",0.935251798561151
50566,"public final void heartBeater(){
  if (!node.joined())   return;
  long now=System.currentTimeMillis();
  if (isMaster()) {
    List<Address> lsDeadAddresses=null;
    for (    MemberImpl memberImpl : lsMembers) {
      final Address address=memberImpl.getAddress();
      if (!thisAddress.equals(address)) {
        try {
          Connection conn=node.connectionManager.getConnection(address);
          if (conn != null && conn.live()) {
            if ((now - memberImpl.getLastRead()) >= (MAX_NO_HEARTBEAT_SECONDS * 1000L)) {
              conn=null;
              if (lsDeadAddresses == null) {
                lsDeadAddresses=new ArrayList<Address>();
              }
              lsDeadAddresses.add(address);
            }
          }
          if (conn != null && conn.live()) {
            if ((now - memberImpl.getLastWrite()) > 500) {
              Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
              sendOrReleasePacket(packet,conn);
            }
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
    if (lsDeadAddresses != null) {
      for (      Address address : lsDeadAddresses) {
        logger.log(Level.FINEST,""String_Node_Str"" + address);
        doRemoveAddress(address);
        sendRemoveMemberToOthers(address);
      }
    }
  }
 else {
    if (getMasterAddress() != null) {
      MemberImpl masterMember=getMember(getMasterAddress());
      boolean removed=false;
      if (masterMember != null) {
        if ((now - masterMember.getLastRead()) >= (MAX_NO_HEARTBEAT_SECONDS * 1000L)) {
          doRemoveAddress(getMasterAddress());
          removed=true;
        }
      }
      if (!removed) {
        Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
        Connection connMaster=node.connectionManager.getOrConnect(getMasterAddress());
        sendOrReleasePacket(packet,connMaster);
      }
    }
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember()) {
        Address address=member.getAddress();
        if (shouldConnectTo(address)) {
          Connection conn=node.connectionManager.getOrConnect(address);
          if (conn != null) {
            Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
            sendOrReleasePacket(packet,conn);
          }
        }
 else {
          Connection conn=node.connectionManager.getConnection(address);
          if (conn != null && conn.live()) {
            if ((now - member.getLastWrite()) > 1000) {
              Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
              sendOrReleasePacket(packet,conn);
            }
          }
        }
      }
    }
  }
}","public final void heartBeater(){
  if (!node.joined())   return;
  long now=System.currentTimeMillis();
  if (isMaster()) {
    List<Address> lsDeadAddresses=null;
    for (    MemberImpl memberImpl : lsMembers) {
      final Address address=memberImpl.getAddress();
      if (!thisAddress.equals(address)) {
        try {
          Connection conn=node.connectionManager.getConnection(address);
          if (conn != null && conn.live()) {
            if ((now - memberImpl.getLastRead()) >= (MAX_NO_HEARTBEAT_MILLIS)) {
              conn=null;
              if (lsDeadAddresses == null) {
                lsDeadAddresses=new ArrayList<Address>();
              }
              lsDeadAddresses.add(address);
            }
          }
          if (conn != null && conn.live()) {
            if ((now - memberImpl.getLastWrite()) > 500) {
              Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
              sendOrReleasePacket(packet,conn);
            }
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
    if (lsDeadAddresses != null) {
      for (      Address address : lsDeadAddresses) {
        logger.log(Level.FINEST,""String_Node_Str"" + address);
        doRemoveAddress(address);
        sendRemoveMemberToOthers(address);
      }
    }
  }
 else {
    if (getMasterAddress() != null) {
      MemberImpl masterMember=getMember(getMasterAddress());
      boolean removed=false;
      if (masterMember != null) {
        if ((now - masterMember.getLastRead()) >= (MAX_NO_HEARTBEAT_MILLIS)) {
          doRemoveAddress(getMasterAddress());
          removed=true;
        }
      }
      if (!removed) {
        Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
        Connection connMaster=node.connectionManager.getOrConnect(getMasterAddress());
        sendOrReleasePacket(packet,connMaster);
      }
    }
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember()) {
        Address address=member.getAddress();
        if (shouldConnectTo(address)) {
          Connection conn=node.connectionManager.getOrConnect(address);
          if (conn != null) {
            Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
            sendOrReleasePacket(packet,conn);
          }
        }
 else {
          Connection conn=node.connectionManager.getConnection(address);
          if (conn != null && conn.live()) {
            if ((now - member.getLastWrite()) > 1000) {
              Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
              sendOrReleasePacket(packet,conn);
            }
          }
        }
      }
    }
  }
}",0.6336562612127736
50567,"void handleJoinRequest(JoinRequest joinRequest){
  logger.log(Level.FINEST,joinInProgress + ""String_Node_Str"" + joinRequest);
  if (getMember(joinRequest.address) != null)   return;
  Connection conn=joinRequest.getConnection();
  if (!node.getConfig().getNetworkConfig().getJoin().getMulticastConfig().isEnabled()) {
    if (node.getMasterAddress() != null && !isMaster()) {
      sendProcessableTo(new Master(node.getMasterAddress()),conn);
    }
  }
  if (isMaster()) {
    if (joinRequest.to != null && !joinRequest.to.equals(thisAddress)) {
      sendProcessableTo(new Master(node.getMasterAddress()),conn);
      return;
    }
    Address newAddress=joinRequest.address;
    if (!joinInProgress) {
      MemberInfo newMemberInfo=new MemberInfo(newAddress,joinRequest.nodeType);
      if (setJoins.add(newMemberInfo)) {
        sendProcessableTo(new Master(node.getMasterAddress()),conn);
        timeToStartJoin=System.currentTimeMillis() + (WAIT_SECONDS_BEFORE_JOIN * 1000L);
      }
 else {
        if (System.currentTimeMillis() > timeToStartJoin) {
          startJoin();
        }
      }
    }
  }
}","void handleJoinRequest(JoinRequest joinRequest){
  logger.log(Level.FINEST,joinInProgress + ""String_Node_Str"" + joinRequest);
  if (getMember(joinRequest.address) != null)   return;
  Connection conn=joinRequest.getConnection();
  if (!node.getConfig().getNetworkConfig().getJoin().getMulticastConfig().isEnabled()) {
    if (node.getMasterAddress() != null && !isMaster()) {
      sendProcessableTo(new Master(node.getMasterAddress()),conn);
    }
  }
  if (isMaster()) {
    if (joinRequest.to != null && !joinRequest.to.equals(thisAddress)) {
      sendProcessableTo(new Master(node.getMasterAddress()),conn);
      return;
    }
    Address newAddress=joinRequest.address;
    if (!joinInProgress) {
      MemberInfo newMemberInfo=new MemberInfo(newAddress,joinRequest.nodeType);
      if (setJoins.add(newMemberInfo)) {
        sendProcessableTo(new Master(node.getMasterAddress()),conn);
        timeToStartJoin=System.currentTimeMillis() + WAIT_MILLIS_BEFORE_JOIN;
      }
 else {
        if (System.currentTimeMillis() > timeToStartJoin) {
          startJoin();
        }
      }
    }
  }
}",0.9905020352781548
50568,"public boolean putMulti(Request req){
  Record record=getRecord(req.key);
  boolean added=true;
  if (record == null) {
    record=createNewRecord(req.key,null);
    req.key=null;
  }
 else {
    if (record.containsValue(req.value)) {
      added=false;
    }
  }
  if (added) {
    node.queryService.updateIndex(name,null,null,record,Integer.MIN_VALUE);
    record.addValue(req.value);
    req.value=null;
    record.setVersion(record.getVersion() + 1);
    touch(record);
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,record.getKey(),req.value,record.getMapListeners());
  }
  logger.log(Level.FINEST,record.getValue() + ""String_Node_Str"" + record.getMultiValues());
  req.version=record.getVersion();
  return added;
}","public boolean putMulti(Request req){
  Record record=getRecord(req.key);
  boolean added=true;
  if (record == null) {
    record=createNewRecord(req.key,null);
    req.key=null;
  }
 else {
    record.setActive();
    if (record.containsValue(req.value)) {
      added=false;
    }
  }
  if (added) {
    node.queryService.updateIndex(name,null,null,record,Integer.MIN_VALUE);
    record.addValue(req.value);
    req.value=null;
    record.setVersion(record.getVersion() + 1);
    touch(record);
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,record.getKey(),req.value,record.getMapListeners());
  }
  logger.log(Level.FINEST,record.getValue() + ""String_Node_Str"" + record.getMultiValues());
  req.version=record.getVersion();
  return added;
}",0.9838709677419356
50569,"public static HazelcastInstance newHazelcastInstance(Config config){
  return com.hazelcast.impl.FactoryImpl.newFactory(config);
}","/** 
 * Creates a new Hazelcast instance (a new node in a cluster). This method allows you to create and run multiple instances of Hazelcast cluster members on the same JVM. To shutdown all running hazelcast instances (all members on this JVM) call   {@link #shutdownAll()}. 
 * @see #shutdownAll()
 * @param config Configuration for the new hazelcast instance (member)
 * @return new hazelcast instance
 */
public static HazelcastInstance newHazelcastInstance(Config config){
  return com.hazelcast.impl.FactoryImpl.newFactory(config);
}",0.3892215568862275
50570,"void doResetRecords(){
  InitialState initialState=new InitialState();
  Collection<CMap> cmaps=maps.values();
  for (  final CMap cmap : cmaps) {
    initialState.createAndAddMapState(cmap);
  }
  sendProcessableToAll(initialState,false);
  if (isSuperClient())   return;
  cmaps=maps.values();
  for (  final CMap cmap : cmaps) {
    final Object[] records=cmap.mapRecords.values().toArray();
    cmap.reset();
    for (    Object recObj : records) {
      final Record rec=(Record)recObj;
      if (rec.isActive()) {
        if (rec.getKey() == null || rec.getKey().size() == 0) {
          throw new RuntimeException(""String_Node_Str"" + rec.getKey());
        }
        executeLocally(new Runnable(){
          public void run(){
            MMigrate mmigrate=new MMigrate();
            if (cmap.isMultiMap()) {
              List<Data> values=rec.getMultiValues();
              if (values == null || values.size() == 0) {
                mmigrate.migrateMulti(rec,null);
              }
 else {
                for (                Data value : values) {
                  mmigrate.migrateMulti(rec,value);
                }
              }
            }
 else {
              boolean migrated=mmigrate.migrate(rec);
              if (!migrated) {
                logger.log(Level.FINEST,""String_Node_Str"" + rec.getKey());
              }
            }
          }
        }
);
      }
    }
  }
  executeLocally(new Runnable(){
    public void run(){
      MultiMigrationComplete mmc=new MultiMigrationComplete();
      mmc.call();
      logger.log(Level.FINEST,""String_Node_Str"");
    }
  }
);
}","void doResetRecords(){
  if (migrating) {
    throw new RuntimeException(""String_Node_Str"");
  }
  migrating=true;
  InitialState initialState=new InitialState();
  Collection<CMap> cmaps=maps.values();
  for (  final CMap cmap : cmaps) {
    initialState.createAndAddMapState(cmap);
  }
  sendProcessableToAll(initialState,false);
  if (isSuperClient())   return;
  cmaps=maps.values();
  final AtomicInteger count=new AtomicInteger(0);
  for (  final CMap cmap : cmaps) {
    final Object[] records=cmap.mapRecords.values().toArray();
    cmap.reset();
    for (    Object recObj : records) {
      final Record rec=(Record)recObj;
      if (rec.isActive()) {
        if (rec.getKey() == null || rec.getKey().size() == 0) {
          throw new RuntimeException(""String_Node_Str"" + rec.getKey());
        }
        count.incrementAndGet();
        executeLocally(new Runnable(){
          public void run(){
            try {
              MMigrate mmigrate=new MMigrate();
              if (cmap.isMultiMap()) {
                List<Data> values=rec.getMultiValues();
                if (values == null || values.size() == 0) {
                  mmigrate.migrateMulti(rec,null);
                }
 else {
                  for (                  Data value : values) {
                    mmigrate.migrateMulti(rec,value);
                  }
                }
              }
 else {
                boolean migrated=mmigrate.migrate(rec);
                if (!migrated) {
                  logger.log(Level.FINEST,""String_Node_Str"" + rec.getKey());
                }
              }
            }
  finally {
              count.decrementAndGet();
            }
          }
        }
);
      }
    }
  }
  executeLocally(new Runnable(){
    public void run(){
      while (count.get() != 0) {
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ignored) {
          return;
        }
      }
      MultiMigrationComplete mmc=new MultiMigrationComplete();
      mmc.call();
      logger.log(Level.FINEST,""String_Node_Str"");
      migrating=false;
    }
  }
);
}",0.8635382955771306
50571,"@Override public boolean isMigrating(){
  for (  Block block : blocks) {
    if (block != null && block.isMigrating()) {
      return true;
    }
  }
  return false;
}","@Override public boolean isMigrating(){
  return migrating;
}",0.4824561403508772
50572,"public void setMembers(List<MemberImpl> lsMembers){
  final Set<MembershipListener> listenerSet=listeners.get();
  Set<Member> setNew=new LinkedHashSet<Member>(lsMembers.size());
  for (  MemberImpl member : lsMembers) {
    final ClusterMember dummy=new ClusterMember(node.factory.getName(),member.getAddress(),member.localMember(),member.getNodeType());
    Member clusterMember=clusterMembers.get(dummy);
    if (clusterMember == null) {
      clusterMember=dummy;
      if (listenerSet != null && listenerSet.size() > 0) {
        node.executorManager.executeLocaly(new Runnable(){
          public void run(){
            MembershipEvent membershipEvent=new MembershipEvent(ClusterImpl.this,dummy,MembershipEvent.MEMBER_ADDED);
            for (            MembershipListener listener : listenerSet) {
              listener.memberAdded(membershipEvent);
            }
          }
        }
);
      }
    }
    if (clusterMember.localMember()) {
      localMember.set(clusterMember);
    }
    setNew.add(clusterMember);
  }
  if (listenerSet != null && listenerSet.size() > 0) {
    Set<Member> it=clusterMembers.keySet();
    for (    final Member cm : it) {
      if (!setNew.contains(cm)) {
        node.executorManager.executeLocaly(new Runnable(){
          public void run(){
            MembershipEvent membershipEvent=new MembershipEvent(ClusterImpl.this,cm,MembershipEvent.MEMBER_REMOVED);
            for (            MembershipListener listener : listenerSet) {
              listener.memberRemoved(membershipEvent);
            }
          }
        }
);
      }
    }
  }
  clusterMembers.clear();
  for (  Member cm : setNew) {
    clusterMembers.put(cm,cm);
  }
  members.set(setNew);
}","public void setMembers(List<MemberImpl> lsMembers){
  final Set<MembershipListener> listenerSet=listeners.get();
  Set<Member> setNew=new LinkedHashSet<Member>(lsMembers.size());
  for (  MemberImpl member : lsMembers) {
    final ClusterMember dummy=new ClusterMember(node.factory.getName(),member.getAddress(),member.localMember(),member.getNodeType());
    Member clusterMember=clusterMembers.get(dummy);
    if (clusterMember == null) {
      clusterMember=dummy;
      if (listenerSet != null && listenerSet.size() > 0) {
        node.executorManager.executeLocally(new Runnable(){
          public void run(){
            MembershipEvent membershipEvent=new MembershipEvent(ClusterImpl.this,dummy,MembershipEvent.MEMBER_ADDED);
            for (            MembershipListener listener : listenerSet) {
              listener.memberAdded(membershipEvent);
            }
          }
        }
);
      }
    }
    if (clusterMember.localMember()) {
      localMember.set(clusterMember);
    }
    setNew.add(clusterMember);
  }
  if (listenerSet != null && listenerSet.size() > 0) {
    Set<Member> it=clusterMembers.keySet();
    for (    final Member cm : it) {
      if (!setNew.contains(cm)) {
        node.executorManager.executeLocally(new Runnable(){
          public void run(){
            MembershipEvent membershipEvent=new MembershipEvent(ClusterImpl.this,cm,MembershipEvent.MEMBER_REMOVED);
            for (            MembershipListener listener : listenerSet) {
              listener.memberRemoved(membershipEvent);
            }
          }
        }
);
      }
    }
  }
  clusterMembers.clear();
  for (  Member cm : setNew) {
    clusterMembers.put(cm,cm);
  }
  members.set(setNew);
}",0.9994148624926856
50573,"public ClusterMBean(HazelcastInstance instance,Config config){
  super(instance);
  this.config=config;
  this.cluster=instance.getCluster();
  mbeanBuilder=new MBeanBuilder();
  mbeanBuilder.setClusterName(instance.getName());
  clusterObjectNames=new ObjectNameSpec(getManagedObject().getName());
}","public ClusterMBean(HazelcastInstance instance,Config config){
  super(instance);
  this.config=config;
  this.cluster=instance.getCluster();
  clusterObjectNames=new ObjectNameSpec(getManagedObject().getName());
}",0.8326848249027238
50574,"/** 
 * Stop the management service
 */
public static void shutdown(){
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(new ObjectName(MBeanBuilder.NAME_DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"",e);
  }
  if (statCollectors != null) {
    statCollectors.shutdownNow();
    statCollectors=null;
  }
}","/** 
 * Stop the management service
 */
public static void shutdown(){
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(new ObjectName(ObjectNameSpec.NAME_DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"",e);
  }
  if (statCollectors != null) {
    statCollectors.shutdownNow();
    statCollectors=null;
  }
}",0.977112676056338
50575,"public Data put(Request req){
  if (req.value == null) {
    req.value=new Data();
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    Record record=recordExist(req);
    if (record != null && record.getValue() != null) {
      return doHardCopy(record.getValue());
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    Record record=recordExist(req);
    if (record == null || record.getValue() == null) {
      return null;
    }
  }
  Record record=getRecord(req.key);
  Data oldValue=null;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    req.key=null;
  }
 else {
    record.markActive();
    if (!record.isValid()) {
      record.setExpirationTime(ttl);
    }
    oldValue=record.getValue();
    record.setValue(req.value);
    record.version++;
    touch(record);
    record.setLastUpdated();
  }
  req.version=record.version;
  req.longValue=record.copyCount;
  req.value=null;
  if (oldValue == null) {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,record);
  }
 else {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_UPDATED,record);
  }
  if (req.txnId != -1) {
    record.unlock();
  }
  markRecordDirty(record);
  return oldValue;
}","public Data put(Request req){
  if (req.value == null) {
    req.value=new Data();
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    Record record=recordExist(req);
    if (record != null && record.getValue() != null) {
      return doHardCopy(record.getValue());
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    Record record=recordExist(req);
    if (record == null || record.getValue() == null) {
      return null;
    }
  }
  Record record=getRecord(req.key);
  Data oldValue=null;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    req.key=null;
  }
 else {
    markAsActive(record);
    if (!record.isValid()) {
      record.setExpirationTime(ttl);
    }
    oldValue=record.getValue();
    record.setValue(req.value);
    record.version++;
    touch(record);
    record.setLastUpdated();
  }
  req.version=record.version;
  req.longValue=record.copyCount;
  req.value=null;
  if (oldValue == null) {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,record);
  }
 else {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_UPDATED,record);
  }
  if (req.txnId != -1) {
    record.unlock();
  }
  markAsDirty(record);
  return oldValue;
}",0.9905853458862056
50576,"public synchronized boolean bind(final Address endPoint,final Connection connection,final boolean accept){
  connection.setEndPoint(endPoint);
  final Connection connExisting=mapConnections.get(endPoint);
  if (connExisting != null && connExisting != connection) {
    final String msg=""String_Node_Str"" + endPoint + ""String_Node_Str""+ acceptTypeConnection+ ""String_Node_Str""+ accept;
    logger.log(Level.FINEST,msg);
    return true;
  }
  if (!endPoint.equals(Node.get().getThisAddress())) {
    acceptTypeConnection=accept;
    ClusterManager clusterManager=ClusterManager.get();
    Packet bindPacket=clusterManager.createRemotelyProcessablePacket(new Bind(clusterManager.getThisAddress()));
    connection.writeHandler.enqueuePacket(bindPacket);
    mapConnections.put(endPoint,connection);
    setConnectionInProgress.remove(endPoint);
    for (    final ConnectionListener listener : setConnectionListeners) {
      listener.connectionAdded(connection);
    }
  }
 else {
    return false;
  }
  return true;
}","public synchronized boolean bind(final Address endPoint,final Connection connection,final boolean accept){
  connection.setEndPoint(endPoint);
  final Connection connExisting=mapConnections.get(endPoint);
  if (connExisting != null && connExisting != connection) {
    final String msg=""String_Node_Str"" + endPoint + ""String_Node_Str""+ acceptTypeConnection+ ""String_Node_Str""+ accept;
    logger.log(Level.FINEST,msg);
    return true;
  }
  if (!endPoint.equals(Node.get().getThisAddress())) {
    acceptTypeConnection=accept;
    if (!accept) {
      ClusterManager clusterManager=ClusterManager.get();
      Packet bindPacket=clusterManager.createRemotelyProcessablePacket(new Bind(clusterManager.getThisAddress()));
      connection.writeHandler.enqueuePacket(bindPacket);
    }
    mapConnections.put(endPoint,connection);
    setConnectionInProgress.remove(endPoint);
    for (    final ConnectionListener listener : setConnectionListeners) {
      listener.connectionAdded(connection);
    }
  }
 else {
    return false;
  }
  return true;
}",0.9850024189646832
50577,"public static Address pickAddress(Node node,final ServerSocketChannel serverSocketChannel) throws Exception {
  String currentAddress=null;
  try {
    final Config config=Config.get();
    final String localAddress=System.getProperty(""String_Node_Str"");
    if (localAddress != null) {
      currentAddress=InetAddress.getByName(localAddress.trim()).getHostAddress();
    }
    if (currentAddress == null) {
      final Enumeration<NetworkInterface> enums=NetworkInterface.getNetworkInterfaces();
      interfaces:       while (enums.hasMoreElements()) {
        final NetworkInterface ni=enums.nextElement();
        final Enumeration<InetAddress> e=ni.getInetAddresses();
        while (e.hasMoreElements()) {
          final InetAddress inetAddress=e.nextElement();
          if (inetAddress instanceof Inet4Address) {
            final String address=inetAddress.getHostAddress();
            if (config.getNetworkConfig().getInterfaces().isEnabled()) {
              if (matchAddress(address)) {
                currentAddress=address;
                break interfaces;
              }
            }
 else {
              if (!inetAddress.isLoopbackAddress()) {
                currentAddress=address;
                break interfaces;
              }
            }
          }
        }
      }
      if (config.getNetworkConfig().getInterfaces().isEnabled() && currentAddress == null) {
        String msg=""String_Node_Str"";
        msg+=""String_Node_Str"";
        logger.log(Level.SEVERE,msg);
        node.dumpCore(null);
        return null;
      }
    }
    if (currentAddress == null) {
      currentAddress=""String_Node_Str"";
    }
    final InetAddress inetAddress=InetAddress.getByName(currentAddress);
    ServerSocket serverSocket=serverSocketChannel.socket();
    serverSocket.setReuseAddress(false);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        isa=new InetSocketAddress(inetAddress,port);
        serverSocket.bind(isa,100);
        break;
      }
 catch (      final Exception e) {
        serverSocket=serverSocketChannel.socket();
        serverSocket.setReuseAddress(false);
        port++;
      }
    }
    serverSocketChannel.configureBlocking(false);
    return new Address(currentAddress,port);
  }
 catch (  final Exception e) {
    node.dumpCore(e);
    e.printStackTrace();
    throw e;
  }
}","public static Address pickAddress(Node node,final ServerSocketChannel serverSocketChannel) throws Exception {
  String currentAddress=null;
  try {
    final Config config=Config.get();
    final String localAddress=System.getProperty(""String_Node_Str"");
    if (localAddress != null) {
      currentAddress=InetAddress.getByName(localAddress.trim()).getHostAddress();
    }
    if (currentAddress == null) {
      final Enumeration<NetworkInterface> enums=NetworkInterface.getNetworkInterfaces();
      interfaces:       while (enums.hasMoreElements()) {
        final NetworkInterface ni=enums.nextElement();
        final Enumeration<InetAddress> e=ni.getInetAddresses();
        while (e.hasMoreElements()) {
          final InetAddress inetAddress=e.nextElement();
          if (inetAddress instanceof Inet4Address) {
            final String address=inetAddress.getHostAddress();
            if (config.getNetworkConfig().getInterfaces().isEnabled()) {
              if (matchAddress(address)) {
                currentAddress=address;
                break interfaces;
              }
            }
 else {
              if (!inetAddress.isLoopbackAddress()) {
                currentAddress=address;
                break interfaces;
              }
            }
          }
        }
      }
      if (config.getNetworkConfig().getInterfaces().isEnabled() && currentAddress == null) {
        String msg=""String_Node_Str"";
        msg+=""String_Node_Str"";
        logger.log(Level.SEVERE,msg);
        node.dumpCore(null);
        return null;
      }
    }
    if (currentAddress == null) {
      currentAddress=""String_Node_Str"";
    }
    final InetAddress inetAddress=InetAddress.getByName(currentAddress);
    ServerSocket serverSocket=serverSocketChannel.socket();
    serverSocket.setReuseAddress(true);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        isa=new InetSocketAddress(inetAddress,port);
        serverSocket.bind(isa,100);
        break;
      }
 catch (      final Exception e) {
        serverSocket=serverSocketChannel.socket();
        serverSocket.setReuseAddress(true);
        port++;
      }
    }
    serverSocketChannel.configureBlocking(false);
    return new Address(currentAddress,port);
  }
 catch (  final Exception e) {
    node.dumpCore(e);
    e.printStackTrace();
    throw e;
  }
}",0.9970735785953178
50578,"public void sendProcessableToAll(RemotelyProcessable rp,boolean processLocally){
  if (processLocally) {
    rp.process();
  }
  Data value=toData(rp);
  for (  MemberImpl member : lsMembers) {
    if (!member.localMember()) {
      Packet packet=obtainPacket();
      try {
        packet.set(""String_Node_Str"",ClusterOperation.REMOTELY_PROCESS,null,value);
        boolean sent=send(packet,member.getAddress());
        if (!sent) {
          packet.returnToContainer();
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
}","public void sendProcessableToAll(RemotelyProcessable rp,boolean processLocally){
  if (processLocally) {
    rp.process();
  }
  Data value=toData(rp);
  for (  MemberImpl member : lsMembers) {
    if (!member.localMember()) {
      Packet packet=obtainPacket();
      packet.set(""String_Node_Str"",ClusterOperation.REMOTELY_PROCESS,null,value);
      boolean sent=send(packet,member.getAddress());
      if (!sent) {
        packet.returnToContainer();
      }
    }
  }
}",0.9076923076923076
50579,"public void sendEvents(final int eventType,final String name,final Data key,final Data value,final Map<Address,Boolean> mapListeners){
  if (mapListeners != null) {
    final Set<Map.Entry<Address,Boolean>> listeners=mapListeners.entrySet();
    for (    final Map.Entry<Address,Boolean> listener : listeners) {
      final Address address=listener.getKey();
      final boolean includeValue=listener.getValue();
      if (address.isThisAddress()) {
        try {
          enqueueEvent(eventType,name,doHardCopy(key),(includeValue) ? doHardCopy(value) : null,address);
        }
 catch (        final Exception e) {
          e.printStackTrace();
        }
      }
 else {
        final Packet packet=ThreadContext.get().getPacketPool().obtain();
        packet.reset();
        try {
          packet.set(name,ClusterOperation.EVENT,key,(includeValue) ? value : null);
          packet.longValue=eventType;
        }
 catch (        final Exception e) {
          e.printStackTrace();
        }
        final boolean sent=send(packet,address);
        if (!sent)         packet.returnToContainer();
      }
    }
  }
}","public void sendEvents(final int eventType,final String name,final Data key,final Data value,final Map<Address,Boolean> mapListeners){
  if (mapListeners != null) {
    final Set<Map.Entry<Address,Boolean>> listeners=mapListeners.entrySet();
    for (    final Map.Entry<Address,Boolean> listener : listeners) {
      final Address address=listener.getKey();
      final boolean includeValue=listener.getValue();
      if (address.isThisAddress()) {
        try {
          enqueueEvent(eventType,name,doHardCopy(key),(includeValue) ? doHardCopy(value) : null,address);
        }
 catch (        final Exception e) {
          e.printStackTrace();
        }
      }
 else {
        final Packet packet=ThreadContext.get().getPacketPool().obtain();
        packet.reset();
        packet.set(name,ClusterOperation.EVENT,key,(includeValue) ? value : null);
        packet.longValue=eventType;
        final boolean sent=send(packet,address);
        if (!sent)         packet.returnToContainer();
      }
    }
  }
}",0.8547328959700093
50580,"public void sendProcessableTo(final RemotelyProcessable rp,final Address address){
  final Data value=toData(rp);
  final Packet packet=obtainPacket();
  try {
    packet.set(""String_Node_Str"",ClusterOperation.REMOTELY_PROCESS,null,value);
    final boolean sent=send(packet,address);
    if (!sent) {
      packet.returnToContainer();
    }
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
}","public void sendProcessableTo(final RemotelyProcessable rp,final Address address){
  final Data value=toData(rp);
  final Packet packet=obtainPacket();
  packet.set(""String_Node_Str"",ClusterOperation.REMOTELY_PROCESS,null,value);
  final boolean sent=send(packet,address);
  if (!sent) {
    packet.returnToContainer();
  }
}",0.8879781420765027
50581,"public static ClusterImpl getCluster(){
  init();
  return node.getClusterImpl();
}","public static ClusterImpl getCluster(){
  initialChecks();
  return node.getClusterImpl();
}",0.9485714285714286
50582,"public Object put(Object key,Object value){
  check(key);
  check(value);
  MPut mput=ThreadContext.get().getMPut();
  return mput.put(name,key,value,-1);
}","public Object put(Object key,Object value){
  checkInputObject(key);
  checkInputObject(value);
  MPut mput=ThreadContext.get().getMPut();
  return mput.put(name,key,value,-1);
}",0.934131736526946
50583,"public boolean containsValue(Object value){
  check(value);
  TransactionImpl txn=ThreadContext.get().txn;
  if (txn != null) {
    if (txn.containsValue(name,value))     return true;
  }
  MContainsValue mContainsValue=ConcurrentMapManager.get().new MContainsValue(name,value);
  return (Boolean)mContainsValue.call();
}","public boolean containsValue(Object value){
  checkInputObject(value);
  TransactionImpl txn=ThreadContext.get().txn;
  if (txn != null) {
    if (txn.containsValue(name,value))     return true;
  }
  MContainsValue mContainsValue=ConcurrentMapManager.get().new MContainsValue(name,value);
  return (Boolean)mContainsValue.call();
}",0.9831546707503828
50584,"public void lock(Object key){
  check(key);
  MLock mlock=ThreadContext.get().getMLock();
  mlock.lock(name,key,-1);
}","public void lock(Object key){
  checkInputObject(key);
  MLock mlock=ThreadContext.get().getMLock();
  mlock.lock(name,key,-1);
}",0.9554655870445344
50585,"public boolean containsEntry(Object key,Object value){
  check(key);
  check(value);
  TransactionImpl txn=ThreadContext.get().txn;
  if (txn != null) {
    if (txn.has(name,key)) {
      Object v=txn.get(name,key);
      return v != null;
    }
  }
  MContainsKey mContainsKey=ConcurrentMapManager.get().new MContainsKey();
  return mContainsKey.containsEntry(name,key,value);
}","public boolean containsEntry(Object key,Object value){
  checkInputObject(key);
  checkInputObject(value);
  TransactionImpl txn=ThreadContext.get().txn;
  if (txn != null) {
    if (txn.has(name,key)) {
      Object v=txn.get(name,key);
      return v != null;
    }
  }
  MContainsKey mContainsKey=ConcurrentMapManager.get().new MContainsKey();
  return mContainsKey.containsEntry(name,key,value);
}",0.9717948717948718
50586,"public void removeEntryListener(EntryListener listener,Object key){
  if (listener == null)   throw new IllegalArgumentException(""String_Node_Str"");
  check(key);
  removeGenericListener(listener,key);
}","public void removeEntryListener(EntryListener listener,Object key){
  if (listener == null)   throw new IllegalArgumentException(""String_Node_Str"");
  checkInputObject(key);
  removeGenericListener(listener,key);
}",0.973621103117506
50587,"public void addEntryListener(EntryListener listener,Object key,boolean includeValue){
  if (listener == null)   throw new IllegalArgumentException(""String_Node_Str"");
  check(key);
  addGenericListener(listener,key,includeValue,ListenerManager.Type.Map);
}","public void addEntryListener(EntryListener listener,Object key,boolean includeValue){
  if (listener == null)   throw new IllegalArgumentException(""String_Node_Str"");
  checkInputObject(key);
  addGenericListener(listener,key,includeValue,ListenerManager.Type.Map);
}",0.9789674952198852
50588,"public boolean tryLock(Object key,long time,TimeUnit timeunit){
  check(key);
  if (time < 0)   throw new IllegalArgumentException(""String_Node_Str"" + time);
  MLock mlock=ThreadContext.get().getMLock();
  return mlock.lock(name,key,timeunit.toMillis(time));
}","public boolean tryLock(Object key,long time,TimeUnit timeunit){
  checkInputObject(key);
  if (time < 0)   throw new IllegalArgumentException(""String_Node_Str"" + time);
  MLock mlock=ThreadContext.get().getMLock();
  return mlock.lock(name,key,timeunit.toMillis(time));
}",0.9792843691148776
50589,"static Collection<Instance> getProxies(){
  init();
  return proxies.values();
}","static Collection<Instance> getProxies(){
  initialChecks();
  return proxies.values();
}",0.9467455621301776
50590,"public static Object getProxy(final ProxyKey proxyKey){
  if (!inited)   init();
  Object proxy=proxies.get(proxyKey);
  if (proxy == null) {
    proxy=createInstanceClusterwide(proxyKey);
  }
  return proxy;
}","public static Object getProxy(final ProxyKey proxyKey){
  initialChecks();
  Object proxy=proxies.get(proxyKey);
  if (proxy == null) {
    proxy=createInstanceClusterwide(proxyKey);
  }
  return proxy;
}",0.927536231884058
50591,"public boolean putMulti(Object key,Object value){
  check(key);
  check(value);
  MPutMulti mput=ThreadContext.get().getMPutMulti();
  return mput.put(name,key,value);
}","public boolean putMulti(Object key,Object value){
  checkInputObject(key);
  checkInputObject(value);
  MPutMulti mput=ThreadContext.get().getMPutMulti();
  return mput.put(name,key,value);
}",0.9388888888888888
50592,"public Object get(Object key){
  check(key);
  MGet mget=ThreadContext.get().getMGet();
  return mget.get(name,key,-1);
}","public Object get(Object key){
  checkInputObject(key);
  MGet mget=ThreadContext.get().getMGet();
  return mget.get(name,key,-1);
}",0.9565217391304348
50593,"public boolean replace(Object key,Object oldValue,Object newValue){
  check(key);
  check(newValue);
  throw new UnsupportedOperationException();
}","public boolean replace(Object key,Object oldValue,Object newValue){
  checkInputObject(key);
  checkInputObject(newValue);
  throw new UnsupportedOperationException();
}",0.930379746835443
50594,"public boolean removeMulti(Object key,Object value){
  check(key);
  check(value);
  MRemoveMulti mremove=ThreadContext.get().getMRemoveMulti();
  return mremove.remove(name,key,value);
}","public boolean removeMulti(Object key,Object value){
  checkInputObject(key);
  checkInputObject(value);
  MRemoveMulti mremove=ThreadContext.get().getMRemoveMulti();
  return mremove.remove(name,key,value);
}",0.9444444444444444
50595,"private void ensure(){
  if (base == null) {
    base=getIdGenerator(name);
  }
}","private void ensure(){
  initialChecks();
  if (base == null) {
    base=getIdGenerator(name);
  }
}",0.8950276243093923
50596,"public void unlock(Object key){
  check(key);
  MLock mlock=ThreadContext.get().getMLock();
  mlock.unlock(name,key,0);
}","public void unlock(Object key){
  checkInputObject(key);
  MLock mlock=ThreadContext.get().getMLock();
  mlock.unlock(name,key,0);
}",0.9565217391304348
50597,"public static ExecutorService getExecutorService(){
  init();
  return executorServiceImpl;
}","public static ExecutorService getExecutorService(){
  initialChecks();
  return executorServiceImpl;
}",0.953846153846154
50598,"public boolean containsKey(Object key){
  check(key);
  TransactionImpl txn=ThreadContext.get().txn;
  if (txn != null) {
    if (txn.has(name,key)) {
      Object value=txn.get(name,key);
      return value != null;
    }
  }
  MContainsKey mContainsKey=ConcurrentMapManager.get().new MContainsKey();
  return mContainsKey.containsKey(name,key);
}","public boolean containsKey(Object key){
  checkInputObject(key);
  TransactionImpl txn=ThreadContext.get().txn;
  if (txn != null) {
    if (txn.has(name,key)) {
      Object value=txn.get(name,key);
      return value != null;
    }
  }
  MContainsKey mContainsKey=ConcurrentMapManager.get().new MContainsKey();
  return mContainsKey.containsKey(name,key);
}",0.9844413012729843
50599,"public boolean remove(Object key,Object value){
  check(key);
  check(value);
  MRemove mremove=ThreadContext.get().getMRemove();
  return (mremove.removeIfSame(name,key,value,-1) != null);
}","public boolean remove(Object key,Object value){
  checkInputObject(key);
  checkInputObject(value);
  MRemove mremove=ThreadContext.get().getMRemove();
  return (mremove.removeIfSame(name,key,value,-1) != null);
}",0.9455445544554456
50600,"public static Transaction getTransaction(){
  if (!inited)   init();
  ThreadContext threadContext=ThreadContext.get();
  Transaction txn=threadContext.txn;
  if (txn == null)   txn=threadContext.getTransaction();
  return txn;
}","public static Transaction getTransaction(){
  initialChecks();
  ThreadContext threadContext=ThreadContext.get();
  Transaction txn=threadContext.txn;
  if (txn == null)   txn=threadContext.getTransaction();
  return txn;
}",0.9336283185840708
50601,"public MapEntry getMapEntry(Object key){
  check(key);
  MGetMapEntry mgetMapEntry=ConcurrentMapManager.get().new MGetMapEntry();
  return mgetMapEntry.get(name,key);
}","public MapEntry getMapEntry(Object key){
  checkInputObject(key);
  MGetMapEntry mgetMapEntry=ConcurrentMapManager.get().new MGetMapEntry();
  return mgetMapEntry.get(name,key);
}",0.968299711815562
50602,"public Object putIfAbsent(Object key,Object value){
  check(key);
  check(value);
  MPut mput=ThreadContext.get().getMPut();
  return mput.putIfAbsent(name,key,value,-1);
}","public Object putIfAbsent(Object key,Object value){
  checkInputObject(key);
  checkInputObject(value);
  MPut mput=ThreadContext.get().getMPut();
  return mput.putIfAbsent(name,key,value,-1);
}",0.9398907103825136
50603,"public static void shutdown(){
  if (dataMonitor != null) {
    dataMonitor=null;
  }
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(new ObjectName(MBeanBuilder.NAME_DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      mbs.unregisterMBean(name);
    }
  }
 catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"",e);
  }
  if (statCollectors != null) {
    statCollectors.shutdownNow();
  }
}","public static void shutdown(){
  if (dataMonitor != null) {
    dataMonitor=null;
  }
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(new ObjectName(MBeanBuilder.NAME_DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"",e);
  }
  if (statCollectors != null) {
    statCollectors.shutdownNow();
    statCollectors=null;
  }
}",0.929551692589204
50604,"/** 
 * Register all the MBeans.
 */
public static void register(Cluster cluster){
  if (!(""String_Node_Str"".equalsIgnoreCase(System.getProperty(ENABLE_JMX)) || System.getProperties().containsKey(""String_Node_Str""))) {
    return;
  }
  logger.log(Level.INFO,""String_Node_Str"");
  if (showDetails()) {
    if (statCollectors == null) {
      statCollectors=new ScheduledThreadPoolExecutor(4);
    }
  }
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  try {
    ClusterMBean clusterMBean=new ClusterMBean(cluster);
    mbs.registerMBean(clusterMBean,clusterMBean.getObjectName());
  }
 catch (  Exception e) {
    logger.log(Level.WARNING,""String_Node_Str"",e);
    return;
  }
  try {
    if (dataMonitor == null) {
      dataMonitor=new DataMBean();
    }
    mbs.registerMBean(dataMonitor,null);
  }
 catch (  Exception e) {
    logger.log(Level.WARNING,""String_Node_Str"",e);
  }
}","/** 
 * Register all the MBeans.
 */
public static void register(Cluster cluster){
  if (!(""String_Node_Str"".equalsIgnoreCase(System.getProperty(ENABLE_JMX)) || System.getProperties().containsKey(""String_Node_Str""))) {
    return;
  }
  logger.log(Level.INFO,""String_Node_Str"");
  if (showDetails()) {
    if (statCollectors == null) {
      statCollectors=new ScheduledThreadPoolExecutor(2);
    }
  }
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  try {
    ClusterMBean clusterMBean=new ClusterMBean(cluster);
    mbs.registerMBean(clusterMBean,clusterMBean.getObjectName());
  }
 catch (  Exception e) {
    logger.log(Level.WARNING,""String_Node_Str"",e);
    return;
  }
  try {
    if (dataMonitor == null) {
      dataMonitor=new DataMBean();
    }
    mbs.registerMBean(dataMonitor,null);
  }
 catch (  Exception e) {
    logger.log(Level.WARNING,""String_Node_Str"",e);
  }
}",0.9988864142538976
50605,"private void handleCommand(String command){
  if (echo) {
    if (Thread.currentThread().getName().toLowerCase().indexOf(""String_Node_Str"") < 0)     System.out.println(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ command);
 else     System.out.println(command);
  }
  if (command == null || command.startsWith(""String_Node_Str""))   return;
  command=command.trim();
  if (command == null || command.length() == 0) {
    return;
  }
  String first=command;
  int spaceIndex=command.indexOf(' ');
  String[] argsSplit=command.split(""String_Node_Str"");
  String[] args=new String[argsSplit.length];
  for (int i=0; i < argsSplit.length; i++) {
    args[i]=argsSplit[i].trim();
  }
  if (spaceIndex != -1) {
    first=args[0];
  }
  if (command.startsWith(""String_Node_Str"")) {
    handleHelp(command);
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    int repeat=Integer.parseInt(first.substring(1));
    long t0=System.currentTimeMillis();
    for (int i=0; i < repeat; i++) {
      handleCommand(command.substring(first.length()).replaceAll(""String_Node_Str"",""String_Node_Str"" + i));
    }
    System.out.println(""String_Node_Str"" + repeat * 1000 / (System.currentTimeMillis() - t0));
    return;
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    final int fork=Integer.parseInt(first.substring(1));
    ExecutorService pool=Executors.newFixedThreadPool(fork);
    final String threadCommand=command.substring(first.length());
    for (int i=0; i < fork; i++) {
      final int threadID=i;
      pool.submit(new Runnable(){
        public void run(){
          String command=threadCommand;
          String[] threadArgs=command.replaceAll(""String_Node_Str"",""String_Node_Str"" + threadID).trim().split(""String_Node_Str"");
          if (""String_Node_Str"".equals(threadArgs[0]) || ""String_Node_Str"".equals(threadArgs[0])) {
            if (threadArgs.length < 4) {
              command+=""String_Node_Str"" + Integer.parseInt(threadArgs[1]) * threadID;
            }
          }
          handleCommand(command);
        }
      }
);
    }
    pool.shutdown();
    try {
      pool.awaitTermination(60 * 60,TimeUnit.SECONDS);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (first.startsWith(""String_Node_Str"")) {
    if (first.length() == 1) {
      System.out.println(""String_Node_Str"");
      return;
    }
    File f=new File(first.substring(1));
    System.out.println(""String_Node_Str"" + f.getAbsolutePath());
    if (f.exists()) {
      try {
        BufferedReader br=new BufferedReader(new FileReader(f));
        String l=br.readLine();
        while (l != null) {
          handleCommand(l);
          l=br.readLine();
        }
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else {
      System.out.println(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
 else   if (command.indexOf(';') != -1) {
    StringTokenizer st=new StringTokenizer(command,""String_Node_Str"");
    while (st.hasMoreTokens()) {
      handleCommand(st.nextToken());
    }
    return;
  }
 else   if (""String_Node_Str"".equals(first)) {
    silent=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    Hazelcast.shutdown();
    handleCommand(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(first)) {
    Hazelcast.shutdown();
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleCommand(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(first)) {
    echo=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    if (args.length > 1) {
      namespace=args[1];
      queue=Hazelcast.getQueue(namespace);
      topic=Hazelcast.getTopic(namespace);
      map=Hazelcast.getMap(namespace);
      set=Hazelcast.getSet(namespace);
      list=Hazelcast.getList(namespace);
    }
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.out.println(Hazelcast.getCluster().getLocalMember());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.out.println(Hazelcast.getCluster());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.gc();
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().maxMemory() / 1024 / 1024 + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + ""String_Node_Str"" + (int)(Runtime.getRuntime().freeMemory() * 100 / Runtime.getRuntime().maxMemory()) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().availableProcessors());
    System.out.println(""String_Node_Str"" + ManagementFactory.getOperatingSystemMXBean().getArch() + ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getName()+ ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getVersion());
    System.out.println(""String_Node_Str"" + ManagementFactory.getRuntimeMXBean().getVmVendor() + ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmName()+ ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmVersion());
  }
 else   if (first.indexOf(""String_Node_Str"") != -1 && first.indexOf(""String_Node_Str"") == -1) {
    handleLock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleSize(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleClear(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleDestroy(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleIterator(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleContains(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleTopicPublish(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOffer(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPoll(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPeek(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOfferMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPollMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemove(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAddMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemoveMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapReplace(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPutIfAbsent(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPut(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGet(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapGetMapEntry(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPutMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemoveMany(args);
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapValues();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapEntries();
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapTryLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleAddListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleRemoveListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleListAddMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListContains(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    execute(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    Hazelcast.getTransaction().begin();
  }
 else   if (first.equals(""String_Node_Str"")) {
    Hazelcast.getTransaction().commit();
  }
 else   if (first.equals(""String_Node_Str"")) {
    Hazelcast.getTransaction().rollback();
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnKey(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMembers(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleInstances(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    System.exit(0);
  }
 else {
    print(""String_Node_Str"");
  }
}","private void handleCommand(String command){
  if (echo) {
    if (Thread.currentThread().getName().toLowerCase().indexOf(""String_Node_Str"") < 0)     System.out.println(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ command);
 else     System.out.println(command);
  }
  if (command == null || command.startsWith(""String_Node_Str""))   return;
  command=command.trim();
  if (command == null || command.length() == 0) {
    return;
  }
  String first=command;
  int spaceIndex=command.indexOf(' ');
  String[] argsSplit=command.split(""String_Node_Str"");
  String[] args=new String[argsSplit.length];
  for (int i=0; i < argsSplit.length; i++) {
    args[i]=argsSplit[i].trim();
  }
  if (spaceIndex != -1) {
    first=args[0];
  }
  if (command.startsWith(""String_Node_Str"")) {
    handleHelp(command);
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    int repeat=Integer.parseInt(first.substring(1));
    long t0=System.currentTimeMillis();
    for (int i=0; i < repeat; i++) {
      handleCommand(command.substring(first.length()).replaceAll(""String_Node_Str"",""String_Node_Str"" + i));
    }
    System.out.println(""String_Node_Str"" + repeat * 1000 / (System.currentTimeMillis() - t0));
    return;
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    final int fork=Integer.parseInt(first.substring(1));
    ExecutorService pool=Executors.newFixedThreadPool(fork);
    final String threadCommand=command.substring(first.length());
    for (int i=0; i < fork; i++) {
      final int threadID=i;
      pool.submit(new Runnable(){
        public void run(){
          String command=threadCommand;
          String[] threadArgs=command.replaceAll(""String_Node_Str"",""String_Node_Str"" + threadID).trim().split(""String_Node_Str"");
          if (""String_Node_Str"".equals(threadArgs[0]) || ""String_Node_Str"".equals(threadArgs[0])) {
            if (threadArgs.length < 4) {
              command+=""String_Node_Str"" + Integer.parseInt(threadArgs[1]) * threadID;
            }
          }
          handleCommand(command);
        }
      }
);
    }
    pool.shutdown();
    try {
      pool.awaitTermination(60 * 60,TimeUnit.SECONDS);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (first.startsWith(""String_Node_Str"")) {
    if (first.length() == 1) {
      System.out.println(""String_Node_Str"");
      return;
    }
    File f=new File(first.substring(1));
    System.out.println(""String_Node_Str"" + f.getAbsolutePath());
    if (f.exists()) {
      try {
        BufferedReader br=new BufferedReader(new FileReader(f));
        String l=br.readLine();
        while (l != null) {
          handleCommand(l);
          l=br.readLine();
        }
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else {
      System.out.println(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
 else   if (command.indexOf(';') != -1) {
    StringTokenizer st=new StringTokenizer(command,""String_Node_Str"");
    while (st.hasMoreTokens()) {
      handleCommand(st.nextToken());
    }
    return;
  }
 else   if (""String_Node_Str"".equals(first)) {
    silent=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    Hazelcast.shutdown();
    handleCommand(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(first)) {
    Hazelcast.shutdown();
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleCommand(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(first)) {
    echo=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    if (args.length > 1) {
      namespace=args[1];
      queue=Hazelcast.getQueue(namespace);
      topic=Hazelcast.getTopic(namespace);
      map=Hazelcast.getMap(namespace);
      set=Hazelcast.getSet(namespace);
      list=Hazelcast.getList(namespace);
    }
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.out.println(Hazelcast.getCluster().getLocalMember());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.out.println(Hazelcast.getCluster());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.gc();
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().maxMemory() / 1024 / 1024 + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + ""String_Node_Str"" + (int)(Runtime.getRuntime().freeMemory() * 100 / Runtime.getRuntime().maxMemory()) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + Runtime.getRuntime().availableProcessors());
    System.out.println(""String_Node_Str"" + ManagementFactory.getOperatingSystemMXBean().getArch() + ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getName()+ ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getVersion());
    System.out.println(""String_Node_Str"" + ManagementFactory.getRuntimeMXBean().getVmVendor() + ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmName()+ ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmVersion());
  }
 else   if (first.indexOf(""String_Node_Str"") != -1 && first.indexOf(""String_Node_Str"") == -1) {
    handleLock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleSize(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleClear(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleDestroy(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleIterator(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleContains(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleTopicPublish(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOffer(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPoll(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPeek(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOfferMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPollMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemove(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAddMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemoveMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapReplace(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPutIfAbsent(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPut(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGet(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapGetMapEntry(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPutMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemoveMany(args);
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapValues();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapEntries();
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapTryLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleAddListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleRemoveListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleListAddMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListContains(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    execute(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    Hazelcast.getTransaction().begin();
  }
 else   if (first.equals(""String_Node_Str"")) {
    Hazelcast.getTransaction().commit();
  }
 else   if (first.equals(""String_Node_Str"")) {
    Hazelcast.getTransaction().rollback();
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnKey(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMembers(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLongTaskOnOtherMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLong(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleInstances(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    System.exit(0);
  }
 else {
    print(""String_Node_Str"");
  }
}",0.9754397429613898
50606,"protected Address getTarget(){
  Address target=null;
  if (innerFutureTask.getKey() != null) {
    Data keyData=null;
    try {
      keyData=ThreadContext.get().toData(innerFutureTask.getKey());
    }
 catch (    final Exception e) {
      e.printStackTrace();
    }
    target=getKeyOwner(keyData);
  }
 else   if (innerFutureTask.getMember() != null) {
    final Object mem=innerFutureTask.getMember();
    if (mem instanceof ClusterMember) {
      final ClusterMember clusterMember=(ClusterMember)mem;
      target=clusterMember.getAddress();
    }
 else     if (mem instanceof MemberImpl) {
      target=((MemberImpl)mem).getAddress();
    }
    if (DEBUG)     log(""String_Node_Str"" + target);
  }
 else {
    Set<Member> members=Node.get().getClusterImpl().getMembers();
    final int random=(int)(Math.random() * 1000);
    final int randomIndex=random % members.size();
    ClusterMember randomClusterMember=(ClusterMember)members.toArray()[randomIndex];
    target=randomClusterMember.getAddress();
    randomTarget=target;
  }
  if (target == null)   return thisAddress;
 else   return target;
}","protected Address getTarget(){
  Address target=null;
  if (innerFutureTask.getKey() != null) {
    Data keyData=null;
    try {
      keyData=ThreadContext.get().toData(innerFutureTask.getKey());
    }
 catch (    final Exception e) {
      e.printStackTrace();
    }
    target=getKeyOwner(keyData);
  }
 else   if (innerFutureTask.getMember() != null) {
    final MemberImpl mem=(MemberImpl)innerFutureTask.getMember();
    target=mem.getAddress();
    if (DEBUG)     log(""String_Node_Str"" + target);
  }
 else {
    Set<Member> members=Node.get().getClusterImpl().getMembers();
    final int random=(int)(Math.random() * 1000);
    final int randomIndex=random % members.size();
    ClusterMember randomClusterMember=(ClusterMember)members.toArray()[randomIndex];
    target=randomClusterMember.getAddress();
    randomTarget=target;
  }
  if (target == null)   return thisAddress;
 else   return target;
}",0.8660714285714286
50607,"void handleMemberLeft(final Member member){
  boolean found=false;
  final ClusterMember clusterMember=(ClusterMember)member;
  if (innerFutureTask.getKey() != null) {
    final Data keyData=toData(innerFutureTask.getKey());
    final Address target=getKeyOwner(keyData);
    if (clusterMember.getAddress().equals(target)) {
      found=true;
    }
  }
 else   if (innerFutureTask.getMember() != null) {
    final Member target=innerFutureTask.getMember();
    if (target instanceof ClusterMember) {
      if (target.equals(member)) {
        found=true;
      }
    }
 else {
      if (((MemberImpl)target).getAddress().equals(clusterMember.getAddress())) {
        found=true;
      }
    }
  }
 else   if (innerFutureTask.getMembers() != null) {
    final Set<Member> members=innerFutureTask.getMembers();
    for (    final Member targetMember : members) {
      if (member.equals(targetMember)) {
        found=true;
      }
    }
  }
 else {
    if (clusterMember.getAddress().equals(randomTarget)) {
      found=true;
    }
  }
  if (!found)   return;
  innerFutureTask.innerSetMemberLeft(member);
  handleStreamResponse(OBJECT_DONE);
}","void handleMemberLeft(final Member dead){
  boolean found=false;
  final MemberImpl deadMember=(MemberImpl)dead;
  if (innerFutureTask.getKey() != null) {
    final Data keyData=toData(innerFutureTask.getKey());
    final Address target=getKeyOwner(keyData);
    found=(deadMember.getAddress().equals(target));
  }
 else   if (innerFutureTask.getMember() != null) {
    final MemberImpl targetMember=(MemberImpl)innerFutureTask.getMember();
    found=(targetMember.getAddress().equals(deadMember.getAddress()));
  }
 else   if (innerFutureTask.getMembers() != null) {
    final Set<Member> members=innerFutureTask.getMembers();
    for (    final Member m : members) {
      MemberImpl targetMember=(MemberImpl)m;
      if (targetMember.getAddress().equals(deadMember.getAddress())) {
        found=true;
        break;
      }
    }
  }
 else {
    found=(deadMember.getAddress().equals(randomTarget));
  }
  if (found) {
    logger.log(Level.FINEST,""String_Node_Str"" + dead);
    innerFutureTask.innerSetMemberLeft(dead);
    handleStreamResponse(OBJECT_MEMBER_LEFT);
    finalizeTask();
  }
}",0.2940125111706881
50608,"/** 
 * !! Called by multiple threads.
 */
public void handleStreamResponse(Object response){
  if (response == null)   response=OBJECT_NULL;
  if (response == OBJECT_DONE || response == OBJECT_CANCELLED) {
    responseQueue.add(response);
    finalizeTask();
  }
 else {
    final int resultCountNow=resultCount.incrementAndGet();
    if (resultCountNow >= expectedResultCount) {
      try {
        if (response != null)         responseQueue.add(response);
        responseQueue.add(OBJECT_DONE);
      }
 catch (      final Exception e) {
        e.printStackTrace();
      }
      finalizeTask();
    }
 else {
      responseQueue.add(response);
    }
  }
}","/** 
 * !! Called by multiple threads.
 */
public void handleStreamResponse(Object response){
  if (executionId == null)   return;
  if (response == null)   response=OBJECT_NULL;
  if (response == OBJECT_DONE || response == OBJECT_CANCELLED) {
    responseQueue.add(response);
    finalizeTask();
  }
 else {
    final int resultCountNow=resultCount.incrementAndGet();
    if (resultCountNow >= expectedResultCount) {
      try {
        if (response != null)         responseQueue.add(response);
        responseQueue.add(OBJECT_DONE);
      }
 catch (      final Exception e) {
        e.printStackTrace();
      }
      finalizeTask();
    }
 else {
      responseQueue.add(response);
    }
  }
}",0.9728141072740631
50609,"public static void main(String[] args){
  SortedHashMap m=new SortedHashMap(100,SortedHashMap.OrderingType.LRU);
  for (int i=0; i < 10; i++) {
    m.put(i,""String_Node_Str"" + i);
  }
  m.get(0);
  m.get(4);
  SortedHashMap.moveToTop(m,7);
  Object[] values=m.values().toArray();
  for (  Object o : values) {
    System.out.println(""String_Node_Str"" + o);
  }
  m.clear();
  values=m.values().toArray();
  for (  Object o : values) {
    System.out.println(""String_Node_Str"" + o);
  }
}","public static void main(String[] args){
  SortedHashMap m=new SortedHashMap(100,SortedHashMap.OrderingType.HASH);
  List l=new ArrayList();
  l.add(100);
  l.add(101);
  for (int i=0; i < 10; i++) {
    l.add(i);
  }
  l.add(102);
  l.add(103);
  for (  Object o : l) {
    System.out.println(""String_Node_Str"" + o);
    m.put(o,o);
    SortedHashMap.touch(m,o,SortedHashMap.OrderingType.HASH);
  }
  Object[] values=m.values().toArray();
  for (  Object o : values) {
    System.out.println(""String_Node_Str"" + o);
  }
}",0.6071428571428571
50610,"void touch(SortedHashMap<K,V> lm,OrderingType orderingType){
  if (orderingType != OrderingType.NONE) {
    lastAccess=System.currentTimeMillis();
    accessCount++;
    lm.modCount++;
    if (orderingType == OrderingType.LFU) {
      moveLFU(lm);
    }
 else     if (orderingType == OrderingType.LRU) {
      moveLRU(lm);
    }
 else     throw new RuntimeException(""String_Node_Str"" + lm.orderingType);
  }
}","void touch(SortedHashMap<K,V> lm,OrderingType orderingType){
  if (orderingType != OrderingType.NONE) {
    lastAccess=System.currentTimeMillis();
    accessCount++;
    lm.modCount++;
    if (orderingType == OrderingType.LFU) {
      moveLFU(lm);
    }
 else     if (orderingType == OrderingType.LRU) {
      moveLRU(lm);
    }
 else     if (orderingType == OrderingType.HASH) {
      moveHash(lm);
    }
 else     throw new RuntimeException(""String_Node_Str"" + lm.orderingType);
  }
}",0.9139664804469274
50611,"@Override public void doLocalOp(){
  if (isMigrating()) {
    setResult(OBJECT_REDO);
  }
 else {
    doLocalCall();
    setResult(request.response);
  }
}","public void doLocalOp(){
  if (isMigrationAware() && isMigrating()) {
    setResult(OBJECT_REDO);
  }
 else {
    request.attachment=TargetAwareOp.this;
    request.local=true;
    ((RequestHandler)getPacketProcessor(request.operation)).handle(request);
  }
}",0.4589371980676328
50612,"void joinReset(){
  joinInProgress=false;
  setJoins.clear();
  timeToStartJoin=System.currentTimeMillis() + waitTimeBeforeJoin + 1000;
}","void joinReset(){
  joinInProgress=false;
  setJoins.clear();
  timeToStartJoin=System.currentTimeMillis() + WAIT_SECONDS_BEFORE_JOIN + 1000;
}",0.8714285714285714
50613,"public final void heartBeater(){
  if (!Node.get().joined())   return;
  long now=System.currentTimeMillis();
  if (isMaster()) {
    List<Address> lsDeadAddresses=null;
    for (    MemberImpl memberImpl : lsMembers) {
      final Address address=memberImpl.getAddress();
      if (!thisAddress.equals(address)) {
        try {
          Connection conn=ConnectionManager.get().getConnection(address);
          if (conn != null && conn.live()) {
            if ((now - memberImpl.getLastRead()) >= 10000) {
              conn=null;
              if (lsDeadAddresses == null) {
                lsDeadAddresses=new ArrayList<Address>();
              }
              lsDeadAddresses.add(address);
            }
          }
          if (conn != null && conn.live()) {
            if ((now - memberImpl.getLastWrite()) > 500) {
              Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
              sendOrReleasePacket(packet,conn);
            }
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
    if (lsDeadAddresses != null) {
      for (      Address address : lsDeadAddresses) {
        logger.log(Level.FINEST,""String_Node_Str"" + address);
        doRemoveAddress(address);
        sendRemoveMemberToOthers(address);
      }
    }
  }
 else {
    if (getMasterAddress() != null) {
      MemberImpl masterMember=getMember(getMasterAddress());
      boolean removed=false;
      if (masterMember != null) {
        if ((now - masterMember.getLastRead()) >= 10000) {
          doRemoveAddress(getMasterAddress());
          removed=true;
        }
      }
      if (!removed) {
        Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
        Connection connMaster=ConnectionManager.get().getOrConnect(getMasterAddress());
        sendOrReleasePacket(packet,connMaster);
      }
    }
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember()) {
        Address address=member.getAddress();
        if (shouldConnectTo(address)) {
          Connection conn=ConnectionManager.get().getOrConnect(address);
          if (conn != null) {
            Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
            sendOrReleasePacket(packet,conn);
          }
        }
 else {
          Connection conn=ConnectionManager.get().getConnection(address);
          if (conn != null && conn.live()) {
            if ((now - member.getLastWrite()) > 1000) {
              Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
              sendOrReleasePacket(packet,conn);
            }
          }
        }
      }
    }
  }
}","public final void heartBeater(){
  if (!Node.get().joined())   return;
  long now=System.currentTimeMillis();
  if (isMaster()) {
    List<Address> lsDeadAddresses=null;
    for (    MemberImpl memberImpl : lsMembers) {
      final Address address=memberImpl.getAddress();
      if (!thisAddress.equals(address)) {
        try {
          Connection conn=ConnectionManager.get().getConnection(address);
          if (conn != null && conn.live()) {
            if ((now - memberImpl.getLastRead()) >= (MAX_NO_HEARTBEAT_SECONDS * 1000L)) {
              conn=null;
              if (lsDeadAddresses == null) {
                lsDeadAddresses=new ArrayList<Address>();
              }
              lsDeadAddresses.add(address);
            }
          }
          if (conn != null && conn.live()) {
            if ((now - memberImpl.getLastWrite()) > 500) {
              Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
              sendOrReleasePacket(packet,conn);
            }
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
    if (lsDeadAddresses != null) {
      for (      Address address : lsDeadAddresses) {
        logger.log(Level.FINEST,""String_Node_Str"" + address);
        doRemoveAddress(address);
        sendRemoveMemberToOthers(address);
      }
    }
  }
 else {
    if (getMasterAddress() != null) {
      MemberImpl masterMember=getMember(getMasterAddress());
      boolean removed=false;
      if (masterMember != null) {
        if ((now - masterMember.getLastRead()) >= (MAX_NO_HEARTBEAT_SECONDS * 1000L)) {
          doRemoveAddress(getMasterAddress());
          removed=true;
        }
      }
      if (!removed) {
        Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
        Connection connMaster=ConnectionManager.get().getOrConnect(getMasterAddress());
        sendOrReleasePacket(packet,connMaster);
      }
    }
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember()) {
        Address address=member.getAddress();
        if (shouldConnectTo(address)) {
          Connection conn=ConnectionManager.get().getOrConnect(address);
          if (conn != null) {
            Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
            sendOrReleasePacket(packet,conn);
          }
        }
 else {
          Connection conn=ConnectionManager.get().getConnection(address);
          if (conn != null && conn.live()) {
            if ((now - member.getLastWrite()) > 1000) {
              Packet packet=obtainPacket(""String_Node_Str"",null,null,ClusterOperation.HEARTBEAT,0);
              sendOrReleasePacket(packet,conn);
            }
          }
        }
      }
    }
  }
}",0.9888368743248108
50614,"void handleJoinRequest(JoinRequest joinRequest){
  logger.log(Level.FINEST,joinInProgress + ""String_Node_Str"" + joinRequest);
  if (getMember(joinRequest.address) != null)   return;
  if (DEBUG) {
  }
  Connection conn=joinRequest.getConnection();
  if (!Config.get().getNetworkConfig().getJoin().getMulticastConfig().isEnabled()) {
    if (Node.get().getMasterAddress() != null && !isMaster()) {
      sendProcessableTo(new Master(Node.get().getMasterAddress()),conn);
    }
  }
  if (isMaster()) {
    if (joinRequest.to != null && !joinRequest.to.equals(thisAddress)) {
      sendProcessableTo(new Master(Node.get().getMasterAddress()),conn);
      return;
    }
    Address newAddress=joinRequest.address;
    if (!joinInProgress) {
      MemberInfo newMemberInfo=new MemberInfo(newAddress,joinRequest.nodeType);
      if (setJoins.add(newMemberInfo)) {
        sendProcessableTo(new Master(Node.get().getMasterAddress()),conn);
        timeToStartJoin=System.currentTimeMillis() + waitTimeBeforeJoin;
      }
 else {
        if (System.currentTimeMillis() > timeToStartJoin) {
          startJoin();
        }
      }
    }
  }
}","void handleJoinRequest(JoinRequest joinRequest){
  logger.log(Level.FINEST,joinInProgress + ""String_Node_Str"" + joinRequest);
  if (getMember(joinRequest.address) != null)   return;
  if (DEBUG) {
  }
  Connection conn=joinRequest.getConnection();
  if (!Config.get().getNetworkConfig().getJoin().getMulticastConfig().isEnabled()) {
    if (Node.get().getMasterAddress() != null && !isMaster()) {
      sendProcessableTo(new Master(Node.get().getMasterAddress()),conn);
    }
  }
  if (isMaster()) {
    if (joinRequest.to != null && !joinRequest.to.equals(thisAddress)) {
      sendProcessableTo(new Master(Node.get().getMasterAddress()),conn);
      return;
    }
    Address newAddress=joinRequest.address;
    if (!joinInProgress) {
      MemberInfo newMemberInfo=new MemberInfo(newAddress,joinRequest.nodeType);
      if (setJoins.add(newMemberInfo)) {
        sendProcessableTo(new Master(Node.get().getMasterAddress()),conn);
        timeToStartJoin=System.currentTimeMillis() + (WAIT_SECONDS_BEFORE_JOIN * 1000L);
      }
 else {
        if (System.currentTimeMillis() > timeToStartJoin) {
          startJoin();
        }
      }
    }
  }
}",0.9798598949211909
50615,"public static void main(String[] args){
  SortedHashMap m=new SortedHashMap(100,SortedHashMap.OrderingType.LRU);
  for (int i=0; i < 10; i++) {
    m.put(i,""String_Node_Str"" + i);
  }
  m.get(0);
  m.get(4);
  SortedHashMap.moveToTop(m,7);
  Collection values=m.values();
  for (  Object o : values) {
    System.out.println(""String_Node_Str"" + o);
  }
}","public static void main(String[] args){
  SortedHashMap m=new SortedHashMap(100,SortedHashMap.OrderingType.LRU);
  for (int i=0; i < 10; i++) {
    m.put(i,""String_Node_Str"" + i);
  }
  m.get(0);
  m.get(4);
  SortedHashMap.moveToTop(m,7);
  Object[] values=m.values().toArray();
  for (  Object o : values) {
    System.out.println(""String_Node_Str"" + o);
  }
  m.clear();
  values=m.values().toArray();
  for (  Object o : values) {
    System.out.println(""String_Node_Str"" + o);
  }
}",0.7491082045184304
50616,"public void parse(final Config config) throws Exception {
  this.config=config;
  final DocumentBuilder builder=DocumentBuilderFactory.newInstance().newDocumentBuilder();
  Document doc=null;
  try {
    doc=builder.parse(inputStream);
    final ByteArrayOutputStream baos=new ByteArrayOutputStream();
    Util.streamXML(doc,baos);
    final byte[] bytes=baos.toByteArray();
    final ByteArrayInputStream bais=new ByteArrayInputStream(bytes);
    config.setXmlConfig(Util.inputStreamToString(bais));
    if (""String_Node_Str"".equals(System.getProperty(""String_Node_Str""))) {
      logger.log(Level.INFO,""String_Node_Str"" + config.getConfigurationUrl());
      logger.log(Level.INFO,""String_Node_Str"");
      logger.log(Level.INFO,config.getXmlConfig());
      logger.log(Level.INFO,""String_Node_Str"");
      logger.log(Level.INFO,""String_Node_Str"");
    }
  }
 catch (  final Exception e) {
    String msgPart=""String_Node_Str"" + config.getConfigurationFile() + ""String_Node_Str"";
    if (!config.isUsingSystemConfig()) {
      msgPart=""String_Node_Str"";
    }
    String msg=""String_Node_Str"" + msgPart;
    msg+=""String_Node_Str"" + e.getMessage();
    msg+=""String_Node_Str"";
    logger.log(Level.WARNING,msg);
    return;
  }
  final Element docElement=doc.getDocumentElement();
  try {
    docElement.getTextContent();
  }
 catch (  final Throwable e) {
    domLevel3=false;
  }
  final NodeList nodelist=docElement.getChildNodes();
  for (int i=0; i < nodelist.getLength(); i++) {
    final org.w3c.dom.Node node=nodelist.item(i);
    final String nodeName=node.getNodeName();
    if (""String_Node_Str"".equals(nodeName)) {
      handleNetwork(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleGroup(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleExecutor(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleQueue(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleMap(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleTopic(node);
    }
  }
}","public void parse(final Config config) throws Exception {
  this.config=config;
  final DocumentBuilder builder=DocumentBuilderFactory.newInstance().newDocumentBuilder();
  Document doc=null;
  try {
    doc=builder.parse(inputStream);
    final ByteArrayOutputStream baos=new ByteArrayOutputStream();
    Util.streamXML(doc,baos);
    final byte[] bytes=baos.toByteArray();
    final ByteArrayInputStream bais=new ByteArrayInputStream(bytes);
    config.setXmlConfig(Util.inputStreamToString(bais));
    if (""String_Node_Str"".equals(System.getProperty(""String_Node_Str""))) {
      logger.log(Level.INFO,""String_Node_Str"" + config.getConfigurationUrl());
      logger.log(Level.INFO,""String_Node_Str"");
      logger.log(Level.INFO,config.getXmlConfig());
      logger.log(Level.INFO,""String_Node_Str"");
      logger.log(Level.INFO,""String_Node_Str"");
    }
  }
 catch (  final Exception e) {
    String msgPart=""String_Node_Str"" + config.getConfigurationFile() + ""String_Node_Str"";
    if (!config.isUsingSystemConfig()) {
      msgPart=""String_Node_Str"";
    }
    String msg=""String_Node_Str"" + msgPart;
    msg+=""String_Node_Str"" + e.getMessage();
    msg+=""String_Node_Str"";
    logger.log(Level.WARNING,msg);
    return;
  }
  final Element docElement=doc.getDocumentElement();
  try {
    docElement.getTextContent();
  }
 catch (  final Throwable e) {
    domLevel3=false;
  }
  final NodeList nodelist=docElement.getChildNodes();
  for (int i=0; i < nodelist.getLength(); i++) {
    final org.w3c.dom.Node node=nodelist.item(i);
    final String nodeName=node.getNodeName();
    if (""String_Node_Str"".equals(nodeName)) {
      handleNetwork(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleGroup(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleProperties(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleExecutor(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleQueue(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleMap(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleTopic(node);
    }
  }
}",0.9793135872120358
50617,"public boolean backup(Request req){
  Record record=getRecord(req.key);
  if (record != null) {
    if (req.version > record.version + 1) {
      Request reqCopy=new Request();
      reqCopy.setFromRequest(req,true);
      req.key=null;
      req.value=null;
      record.addBackupOp(new VersionedBackupOp(reqCopy));
      return true;
    }
 else     if (req.version <= record.version) {
      return false;
    }
  }
  doBackup(req);
  if (record != null) {
    record.version=req.version;
    record.runBackupOps();
  }
  return true;
}","public boolean backup(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  Record record=getRecord(req.key);
  if (record != null) {
    if (req.version > record.version + 1) {
      Request reqCopy=new Request();
      reqCopy.setFromRequest(req,true);
      req.key=null;
      req.value=null;
      record.addBackupOp(new VersionedBackupOp(reqCopy));
      return true;
    }
 else     if (req.version <= record.version) {
      return false;
    }
  }
  doBackup(req);
  if (record != null) {
    record.version=req.version;
    record.runBackupOps();
  }
  return true;
}",0.90512174643157
50618,"private ConcurrentMapManager(){
  ClusterService.get().registerPeriodicRunnable(new Runnable(){
    public void run(){
      Collection<CMap> cmaps=maps.values();
      for (      CMap cmap : cmaps) {
        if (cmap.ttl != 0) {
          cmap.startEviction();
        }
        if (cmap.writeDelaySeconds > 0) {
          cmap.startAsyncStoreWrite();
        }
      }
    }
  }
);
  registerPacketProcessor(CONCURRENT_MAP_GET_MAP_ENTRY,new GetMapEnryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET,new GetOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_IF_ABSENT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_MULTI,new PutMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_IF_SAME,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_ITEM,new RemoveItemOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_ADD,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE_MULTI,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_LOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_LOCK,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK_RETURN_OLD,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK,new UnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_ENTRIES,new GetMapEntriesOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_VALUES,new GetMapEntriesOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_KEYS,new GetMapEntriesOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_KEYS_ALL,new GetMapEntriesOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_MIGRATE_RECORD,new MigrationOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_MULTI,new RemoveMultiOperationHander());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_LIST,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_SET,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_SIZE,new SizeOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS,new ContainsOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BLOCK_INFO,new BlockInfoOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BLOCKS,new BlocksOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_MIGRATION_COMPLETE,new MigrationCompleteOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_VALUE_COUNT,new ValueCountOperationHandler());
  for (int i=0; i < BLOCK_COUNT; i++) {
    loadStoreForks[i]=new LoadStoreFork();
  }
}","private ConcurrentMapManager(){
  blocks=new Block[BLOCK_COUNT];
  maps=new ConcurrentHashMap<String,CMap>(10);
  loadStoreForks=new LoadStoreFork[BLOCK_COUNT];
  for (int i=0; i < BLOCK_COUNT; i++) {
    loadStoreForks[i]=new LoadStoreFork();
  }
  ClusterService.get().registerPeriodicRunnable(new Runnable(){
    public void run(){
      Collection<CMap> cmaps=maps.values();
      for (      CMap cmap : cmaps) {
        if (cmap.ttl != 0) {
          cmap.startEviction();
        }
        if (cmap.writeDelaySeconds > 0) {
          cmap.startAsyncStoreWrite();
        }
      }
    }
  }
);
  registerPacketProcessor(CONCURRENT_MAP_GET_MAP_ENTRY,new GetMapEnryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET,new GetOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_IF_ABSENT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_MULTI,new PutMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_IF_SAME,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_ITEM,new RemoveItemOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_ADD,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE_MULTI,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_LOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_LOCK,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK_RETURN_OLD,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK,new UnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_ENTRIES,new GetMapEntriesOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_VALUES,new GetMapEntriesOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_KEYS,new GetMapEntriesOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ITERATE_KEYS_ALL,new GetMapEntriesOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_MIGRATE_RECORD,new MigrationOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_MULTI,new RemoveMultiOperationHander());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_LIST,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_SET,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_SIZE,new SizeOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS,new ContainsOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BLOCK_INFO,new BlockInfoOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BLOCKS,new BlocksOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_MIGRATION_COMPLETE,new MigrationCompleteOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_VALUE_COUNT,new ValueCountOperationHandler());
}",0.9522909777987718
50619,"void doResetRecords(){
  if (isSuperClient())   return;
  Collection<CMap> cmaps=maps.values();
  for (  final CMap cmap : cmaps) {
    final Object[] records=cmap.mapRecords.values().toArray();
    cmap.reset();
    for (    Object recObj : records) {
      final Record rec=(Record)recObj;
      if (rec.key == null || rec.key.size() == 0) {
        logger.log(Level.SEVERE,""String_Node_Str"" + rec.key);
      }
      executeLocally(new Runnable(){
        public void run(){
          MMigrate mmigrate=new MMigrate();
          if (cmap.isMultiMap()) {
            List<Data> values=rec.lsValues;
            if (values == null || values.size() == 0) {
              mmigrate.migrateMulti(rec,null);
            }
 else {
              for (              Data value : values) {
                mmigrate.migrateMulti(rec,value);
              }
            }
          }
 else {
            boolean migrated=mmigrate.migrate(rec);
            if (!migrated) {
              logger.log(Level.FINEST,""String_Node_Str"" + rec.key);
            }
          }
        }
      }
);
    }
  }
  executeLocally(new Runnable(){
    public void run(){
      Processable processCompletion=new Processable(){
        public void process(){
          MigrationCompleteOperationHandler h=(MigrationCompleteOperationHandler)getPacketProcessor(CONCURRENT_MAP_MIGRATION_COMPLETE);
          h.doMigrationComplete(thisAddress);
          h.sendMigrationCompleteToAll();
          if (DEBUG) {
            printBlocks();
            logger.log(Level.FINEST,""String_Node_Str"");
          }
        }
      }
;
      enqueueAndReturn(processCompletion);
    }
  }
);
}","void doResetRecords(){
  if (isSuperClient())   return;
  Collection<CMap> cmaps=maps.values();
  for (  final CMap cmap : cmaps) {
    final Object[] records=cmap.mapRecords.values().toArray();
    cmap.reset();
    for (    Object recObj : records) {
      final Record rec=(Record)recObj;
      if (rec.key == null || rec.key.size() == 0) {
        logger.log(Level.SEVERE,""String_Node_Str"" + rec.key);
      }
      executeLocally(new Runnable(){
        MMigrate mmigrate=new MMigrate();
        public void run(){
          if (cmap.isMultiMap()) {
            List<Data> values=rec.lsValues;
            if (values == null || values.size() == 0) {
              mmigrate.migrateMulti(rec,null);
            }
 else {
              for (              Data value : values) {
                mmigrate.migrateMulti(rec,value);
              }
            }
          }
 else {
            boolean migrated=mmigrate.migrate(rec);
            if (!migrated) {
              logger.log(Level.FINEST,""String_Node_Str"" + rec.key);
            }
          }
        }
      }
);
    }
  }
  executeLocally(new Runnable(){
    public void run(){
      Processable processCompletion=new Processable(){
        public void process(){
          MigrationCompleteOperationHandler h=(MigrationCompleteOperationHandler)getPacketProcessor(CONCURRENT_MAP_MIGRATION_COMPLETE);
          h.doMigrationComplete(thisAddress);
          h.sendMigrationCompleteToAll();
          logger.log(Level.FINEST,""String_Node_Str"");
        }
      }
;
      enqueueAndReturn(processCompletion);
    }
  }
);
}",0.9238861386138614
50620,"public boolean migrate(Record record){
  copyRecordToRequest(record,request,true);
  if (request.key == null)   throw new RuntimeException(""String_Node_Str"");
  request.operation=CONCURRENT_MAP_MIGRATE_RECORD;
  doOp();
  boolean result=getResultAsBoolean();
  backup(CONCURRENT_MAP_BACKUP_PUT);
  return result;
}","public boolean migrate(Record record){
  copyRecordToRequest(record,request,true);
  if (request.key == null)   throw new RuntimeException(""String_Node_Str"" + request.redoCount);
  request.operation=CONCURRENT_MAP_MIGRATE_RECORD;
  doOp();
  boolean result=getResultAsBoolean();
  backup(CONCURRENT_MAP_BACKUP_PUT);
  return result;
}",0.9691358024691358
50621,"public void doBackup(Request req){
  if (req.operation == CONCURRENT_MAP_BACKUP_PUT) {
    toRecord(req);
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (record.value != null) {
        record.value.setNoData();
      }
      if (record.lsValues != null) {
        for (        Data value : record.lsValues) {
          value.setNoData();
        }
      }
      if (record.copyCount > 0) {
        record.decrementCopyCount();
      }
      record.value=null;
      if (record.isRemovable()) {
        removeRecord(record.key);
        record.key.setNoData();
      }
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_LOCK) {
    toRecord(req);
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_ADD) {
    add(req);
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE_MULTI) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (req.value == null) {
        removeRecord(req.key);
      }
 else {
        if (record.containsValue(req.value)) {
          if (record.lsValues != null) {
            Iterator<Data> itValues=record.lsValues.iterator();
            while (itValues.hasNext()) {
              Data value=itValues.next();
              if (req.value.equals(value)) {
                itValues.remove();
                value.setNoData();
              }
            }
          }
        }
      }
      if (record.isRemovable()) {
        removeRecord(record.key);
      }
    }
  }
 else {
    logger.log(Level.SEVERE,""String_Node_Str"" + req.operation);
  }
}","public void doBackup(Request req){
  if (req.key == null || req.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + req.key);
  }
  if (req.operation == CONCURRENT_MAP_BACKUP_PUT) {
    toRecord(req);
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (record.value != null) {
        record.value.setNoData();
      }
      if (record.lsValues != null) {
        for (        Data value : record.lsValues) {
          value.setNoData();
        }
      }
      if (record.copyCount > 0) {
        record.decrementCopyCount();
      }
      record.value=null;
      if (record.isRemovable()) {
        if (removeRecord(record.key) == null) {
          throw new RuntimeException(""String_Node_Str"");
        }
        record.key.setNoData();
        record.key=null;
      }
    }
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_LOCK) {
    toRecord(req);
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_ADD) {
    add(req);
  }
 else   if (req.operation == CONCURRENT_MAP_BACKUP_REMOVE_MULTI) {
    Record record=getRecord(req.key);
    if (record != null) {
      if (req.value == null) {
        removeRecord(req.key);
      }
 else {
        if (record.containsValue(req.value)) {
          if (record.lsValues != null) {
            Iterator<Data> itValues=record.lsValues.iterator();
            while (itValues.hasNext()) {
              Data value=itValues.next();
              if (req.value.equals(value)) {
                itValues.remove();
                value.setNoData();
              }
            }
          }
        }
      }
      if (record.isRemovable()) {
        removeRecord(record.key);
      }
    }
  }
 else {
    logger.log(Level.SEVERE,""String_Node_Str"" + req.operation);
  }
}",0.9357371328874672
50622,"Record createNewRecord(Data key,Data value){
  int blockId=getBlockId(key);
  Record rec=new Record(name,blockId,key,value,ttl);
  Block ownerBlock=getOrCreateBlock(blockId);
  if (thisAddress.equals(ownerBlock.getRealOwner())) {
    ownedEntryCount++;
  }
  rec.owner=ownerBlock.owner;
  mapRecords.put(key,rec);
  if (evictionPolicy != OrderingType.NONE) {
    if (maxSize != Integer.MAX_VALUE) {
      int limitSize=(maxSize / lsMembers.size());
      if (ownedEntryCount > limitSize) {
        startEviction();
      }
    }
  }
  return rec;
}","Record createNewRecord(Data key,Data value){
  if (key == null || key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + key);
  }
  int blockId=getBlockId(key);
  Record rec=new Record(name,blockId,key,value,ttl);
  Block ownerBlock=getOrCreateBlock(blockId);
  if (thisAddress.equals(ownerBlock.getRealOwner())) {
    ownedEntryCount++;
  }
  rec.owner=ownerBlock.owner;
  mapRecords.put(key,rec);
  if (evictionPolicy != OrderingType.NONE) {
    if (maxSize != Integer.MAX_VALUE) {
      int limitSize=(maxSize / lsMembers.size());
      if (ownedEntryCount > limitSize) {
        startEviction();
      }
    }
  }
  return rec;
}",0.9156223893065998
50623,"public void returnResponse(Request request){
  if (request.local) {
    final TargetAwareOp targetAwareOp=(TargetAwareOp)request.attachment;
    targetAwareOp.setResult(request.response);
  }
 else {
    Packet packet=obtainPacket();
    request.setPacket(packet);
    packet.operation=ClusterOperation.RESPONSE;
    packet.responseType=RESPONSE_SUCCESS;
    System.out.println(""String_Node_Str"" + request.value);
    if (request.value != null) {
      doSet(request.value,packet.value);
    }
    if (request.response == OBJECT_REDO) {
      packet.responseType=RESPONSE_REDO;
    }
 else     if (request.response != null) {
      if (request.response instanceof Boolean) {
        if (request.response == Boolean.FALSE) {
          packet.responseType=RESPONSE_FAILURE;
        }
      }
 else {
        Data data=null;
        if (request.response instanceof Data) {
          data=(Data)request.response;
        }
 else {
          data=toData(request.response);
        }
        if (data != null && data.size() > 0) {
          doSet(data,packet.value);
        }
      }
    }
    sendResponse(packet,request.caller);
    request.reset();
  }
}","public void returnResponse(Request request){
  if (request.local) {
    final TargetAwareOp targetAwareOp=(TargetAwareOp)request.attachment;
    targetAwareOp.setResult(request.response);
  }
 else {
    Packet packet=obtainPacket();
    request.setPacket(packet);
    packet.operation=ClusterOperation.RESPONSE;
    packet.responseType=RESPONSE_SUCCESS;
    if (request.value != null) {
      doSet(request.value,packet.value);
    }
    if (request.response == OBJECT_REDO) {
      packet.responseType=RESPONSE_REDO;
    }
 else     if (request.response != null) {
      if (request.response instanceof Boolean) {
        if (request.response == Boolean.FALSE) {
          packet.responseType=RESPONSE_FAILURE;
        }
      }
 else {
        Data data=null;
        if (request.response instanceof Data) {
          data=(Data)request.response;
        }
 else {
          data=toData(request.response);
        }
        if (data != null && data.size() > 0) {
          doSet(data,packet.value);
        }
      }
    }
    sendResponse(packet,request.caller);
    request.reset();
  }
}",0.973719376391982
50624,"public void handle(Request request){
  if (shouldSchedule(request)) {
    if (request.hasEnoughTimeToSchedule()) {
      Record record=ensureRecord(request);
      request.scheduled=true;
      record.addScheduledAction(new ScheduledAction(request){
        @Override public boolean consume(){
          handle(request);
          return true;
        }
      }
);
    }
 else {
      onNoTimeToSchedule(request);
    }
    return;
  }
  if (shouldExecuteStore(request)) {
    executeLoadStore(request);
    return;
  }
  doOperation(request);
  returnResponse(request);
}","public void handle(Request request){
  if (shouldSchedule(request)) {
    if (request.hasEnoughTimeToSchedule()) {
      schedule(request);
    }
 else {
      onNoTimeToSchedule(request);
    }
    return;
  }
  if (shouldExecuteStore(request)) {
    executeLoadStore(request);
    return;
  }
  doOperation(request);
  returnResponse(request);
}",0.720348204570185
50625,"public void addScheduledAction(ScheduledAction scheduledAction){
  if (lsScheduledActions == null)   lsScheduledActions=new ArrayList<ScheduledAction>(1);
  lsScheduledActions.add(scheduledAction);
  ClusterManager.get().registerScheduledAction(scheduledAction);
  if (DEBUG) {
    log(""String_Node_Str"" + scheduledAction);
  }
}","public void addScheduledAction(ScheduledAction scheduledAction){
  if (lsScheduledActions == null) {
    lsScheduledActions=new ArrayList<ScheduledAction>(1);
  }
  lsScheduledActions.add(scheduledAction);
  ClusterManager.get().registerScheduledAction(scheduledAction);
  logger.log(Level.FINEST,scheduledAction.request.operation + ""String_Node_Str"" + scheduledAction);
}",0.8701854493580599
50626,"public void onExpire(){
  request.response=Boolean.FALSE;
  returnScheduledAsBoolean(request);
}","@Override public void onExpire(){
  onNoTimeToSchedule(request);
}",0.6172839506172839
50627,"public Object invoke(final Object o,final Method method,final Object[] objects) throws Throwable {
  final String name=method.getName();
  final BlockingQueue resultQ=new ArrayBlockingQueue(1);
  if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    es.execute(new Runnable(){
      public void run(){
        try {
          Transaction txn=Hazelcast.getTransaction();
          if (name.equals(""String_Node_Str"")) {
            txn.begin();
          }
 else           if (name.equals(""String_Node_Str"")) {
            txn.commit();
          }
 else           if (name.equals(""String_Node_Str"")) {
            txn.rollback();
          }
          resultQ.put(NULL_OBJECT);
        }
 catch (        Exception e) {
          try {
            resultQ.put(e);
          }
 catch (          InterruptedException ignored) {
          }
        }
      }
    }
);
  }
 else {
    es.execute(new Runnable(){
      public void run(){
        try {
          Object result=method.invoke(target,objects);
          resultQ.put((result == null) ? NULL_OBJECT : result);
        }
 catch (        Exception e) {
          try {
            resultQ.put(e);
          }
 catch (          InterruptedException ignored) {
          }
        }
      }
    }
);
  }
  Object result=resultQ.take();
  if (name.equals(""String_Node_Str"")) {
    es.shutdown();
  }
  if (result instanceof Throwable) {
    throw ((Throwable)result);
  }
  return (result == NULL_OBJECT) ? null : result;
}","public Object invoke(final Object o,final Method method,final Object[] objects) throws Throwable {
  final String name=method.getName();
  final BlockingQueue resultQ=new ArrayBlockingQueue(1);
  if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    es.execute(new Runnable(){
      public void run(){
        try {
          Transaction txn=Hazelcast.getTransaction();
          if (name.equals(""String_Node_Str"")) {
            txn.begin();
          }
 else           if (name.equals(""String_Node_Str"")) {
            txn.commit();
          }
 else           if (name.equals(""String_Node_Str"")) {
            txn.rollback();
          }
          resultQ.put(NULL_OBJECT);
        }
 catch (        Exception e) {
          try {
            resultQ.put(e);
          }
 catch (          InterruptedException ignored) {
          }
        }
      }
    }
);
  }
 else {
    es.execute(new Runnable(){
      public void run(){
        try {
          Object result=method.invoke(target,objects);
          resultQ.put((result == null) ? NULL_OBJECT : result);
        }
 catch (        Exception e) {
          try {
            resultQ.put(e);
          }
 catch (          InterruptedException ignored) {
          }
        }
      }
    }
);
  }
  Object result=resultQ.poll(5,TimeUnit.SECONDS);
  if (result == null)   throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str"");
  if (name.equals(""String_Node_Str"")) {
    es.shutdown();
  }
  if (result instanceof Throwable) {
    throw ((Throwable)result);
  }
  return (result == NULL_OBJECT) ? null : result;
}",0.9602774274905422
50628,"public ResponseQueueCall(final boolean limited){
  if (limited) {
    responses=new ArrayBlockingQueue(1);
  }
 else {
    responses=new LinkedBlockingQueue();
  }
}","public ResponseQueueCall(){
}",0.2989690721649484
50629,"public void syncForDead(Address deadAddress){
  if (deadAddress.equals(thisAddress))   return;
  for (  Block block : blocks) {
    if (block != null) {
      if (deadAddress.equals(block.owner)) {
        MemberImpl member=getNextMemberBeforeSync(block.owner,true,1);
        block.owner=(member == null) ? thisAddress : member.getAddress();
      }
      if (block.migrationAddress != null) {
        if (deadAddress.equals(block.migrationAddress)) {
          MemberImpl member=getNextMemberBeforeSync(block.migrationAddress,true,1);
          block.migrationAddress=(member == null) ? thisAddress : member.getAddress();
        }
      }
    }
  }
  Collection<CMap> cmaps=maps.values();
  for (  CMap map : cmaps) {
    Collection<Record> records=map.mapRecords.values();
    for (    Record record : records) {
      record.onDisconnect(deadAddress);
    }
  }
  doResetRecords();
}","public void syncForDead(Address deadAddress){
  if (deadAddress.equals(thisAddress))   return;
  for (  Block block : blocks) {
    if (block != null) {
      if (deadAddress.equals(block.owner)) {
        MemberImpl member=getNextMemberBeforeSync(block.owner,true,1);
        if (member == null) {
          if (!isSuperClient()) {
            block.owner=thisAddress;
          }
 else {
            block.owner=null;
          }
        }
 else {
          if (!deadAddress.equals(member.getAddress())) {
            block.owner=member.getAddress();
          }
 else {
            block.owner=null;
          }
        }
      }
      if (block.migrationAddress != null) {
        if (deadAddress.equals(block.migrationAddress)) {
          MemberImpl member=getNextMemberBeforeSync(block.migrationAddress,true,1);
          if (member == null) {
            if (!isSuperClient()) {
              block.migrationAddress=thisAddress;
            }
 else {
              block.migrationAddress=null;
            }
          }
 else {
            if (!deadAddress.equals(member.getAddress())) {
              block.migrationAddress=member.getAddress();
            }
 else {
              block.migrationAddress=null;
            }
          }
        }
      }
    }
  }
  Collection<CMap> cmaps=maps.values();
  for (  CMap map : cmaps) {
    Collection<Record> records=map.mapRecords.values();
    for (    Record record : records) {
      record.onDisconnect(deadAddress);
    }
  }
  if (isMaster() && isSuperClient()) {
    syncForAdd();
  }
 else {
    doResetRecords();
  }
}",0.6674757281553398
50630,"void printBlocks(){
  if (true)   return;
  if (DEBUG)   log(""String_Node_Str"");
  for (int i=0; i < BLOCK_COUNT; i++) {
    if (DEBUG)     log(blocks[i]);
  }
  Collection<CMap> cmaps=maps.values();
  for (  CMap cmap : cmaps) {
    if (DEBUG)     log(cmap);
  }
  if (DEBUG)   log(""String_Node_Str"");
}","void printBlocks(){
  logger.log(Level.FINEST,""String_Node_Str"");
  for (int i=0; i < BLOCK_COUNT; i++) {
    logger.log(Level.FINEST,String.valueOf(blocks[i]));
  }
  logger.log(Level.FINEST,""String_Node_Str"");
}",0.4216634429400386
50631,"public void syncForAdd(){
  if (isMaster()) {
    for (int i=0; i < BLOCK_COUNT; i++) {
      Block block=blocks[i];
      if (block == null) {
        getOrCreateBlock(i);
      }
    }
    List<Block> lsBlocksToRedistribute=new ArrayList<Block>();
    Map<Address,Integer> addressBlocks=new HashMap<Address,Integer>();
    int storageEnabledMemberCount=0;
    for (    MemberImpl member : lsMembers) {
      if (!member.isSuperClient()) {
        addressBlocks.put(member.getAddress(),0);
        storageEnabledMemberCount++;
      }
    }
    if (storageEnabledMemberCount == 0)     return;
    int aveBlockOwnCount=BLOCK_COUNT / (storageEnabledMemberCount);
    for (    Block block : blocks) {
      if (block.owner == null) {
        lsBlocksToRedistribute.add(block);
      }
 else {
        if (!block.isMigrating()) {
          Integer countInt=addressBlocks.get(block.owner);
          int count=(countInt == null) ? 0 : countInt;
          if (count >= aveBlockOwnCount) {
            lsBlocksToRedistribute.add(block);
          }
 else {
            count++;
            addressBlocks.put(block.owner,count);
          }
        }
      }
    }
    Set<Address> allAddress=addressBlocks.keySet();
    setNewMembers:     for (    Address address : allAddress) {
      Integer countInt=addressBlocks.get(address);
      int count=(countInt == null) ? 0 : countInt;
      while (count < aveBlockOwnCount) {
        if (lsBlocksToRedistribute.size() > 0) {
          Block blockToMigrate=lsBlocksToRedistribute.remove(0);
          if (blockToMigrate.owner == null) {
            blockToMigrate.owner=address;
          }
 else {
            blockToMigrate.migrationAddress=address;
            if (blockToMigrate.owner.equals(blockToMigrate.migrationAddress)) {
              blockToMigrate.migrationAddress=null;
            }
          }
          count++;
        }
 else {
          break setNewMembers;
        }
      }
    }
    int addressIndex=0;
    for (int i=0; i < BLOCK_COUNT; i++) {
      Block block=blocks[i];
      if (block.owner == null) {
        int index=addressIndex++ % addressBlocks.size();
        block.owner=(Address)addressBlocks.keySet().toArray()[index];
      }
    }
    Data dataAllBlocks=null;
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember()) {
        if (dataAllBlocks == null) {
          Blocks allBlocks=new Blocks();
          for (          Block block : blocks) {
            allBlocks.addBlock(block);
          }
          dataAllBlocks=ThreadContext.get().toData(allBlocks);
        }
        send(""String_Node_Str"",CONCURRENT_MAP_BLOCKS,dataAllBlocks,member.getAddress());
      }
    }
    doResetRecords();
    if (DEBUG) {
      printBlocks();
    }
  }
}","public void syncForAdd(){
  if (isMaster()) {
    for (int i=0; i < BLOCK_COUNT; i++) {
      Block block=blocks[i];
      if (block == null) {
        getOrCreateBlock(i);
      }
    }
    List<Block> lsBlocksToRedistribute=new ArrayList<Block>();
    Map<Address,Integer> addressBlocks=new HashMap<Address,Integer>();
    int storageEnabledMemberCount=0;
    for (    MemberImpl member : lsMembers) {
      if (!member.isSuperClient()) {
        addressBlocks.put(member.getAddress(),0);
        storageEnabledMemberCount++;
      }
    }
    if (storageEnabledMemberCount == 0)     return;
    int aveBlockOwnCount=BLOCK_COUNT / (storageEnabledMemberCount);
    for (    Block block : blocks) {
      if (block.owner == null) {
        lsBlocksToRedistribute.add(block);
      }
 else {
        if (!block.isMigrating()) {
          Integer countInt=addressBlocks.get(block.owner);
          int count=(countInt == null) ? 0 : countInt;
          if (count >= aveBlockOwnCount) {
            lsBlocksToRedistribute.add(block);
          }
 else {
            count++;
            addressBlocks.put(block.owner,count);
          }
        }
      }
    }
    Set<Address> allAddress=addressBlocks.keySet();
    setNewMembers:     for (    Address address : allAddress) {
      Integer countInt=addressBlocks.get(address);
      int count=(countInt == null) ? 0 : countInt;
      while (count < aveBlockOwnCount) {
        if (lsBlocksToRedistribute.size() > 0) {
          Block blockToMigrate=lsBlocksToRedistribute.remove(0);
          if (blockToMigrate.owner == null) {
            blockToMigrate.owner=address;
          }
 else {
            blockToMigrate.migrationAddress=address;
            if (blockToMigrate.owner.equals(blockToMigrate.migrationAddress)) {
              blockToMigrate.migrationAddress=null;
            }
          }
          count++;
        }
 else {
          break setNewMembers;
        }
      }
    }
    int addressIndex=0;
    for (int i=0; i < BLOCK_COUNT; i++) {
      Block block=blocks[i];
      if (block.owner == null) {
        int index=addressIndex++ % addressBlocks.size();
        block.owner=(Address)addressBlocks.keySet().toArray()[index];
      }
    }
    Data dataAllBlocks=null;
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember()) {
        if (dataAllBlocks == null) {
          Blocks allBlocks=new Blocks();
          for (          Block block : blocks) {
            allBlocks.addBlock(block);
          }
          dataAllBlocks=ThreadContext.get().toData(allBlocks);
        }
        send(""String_Node_Str"",CONCURRENT_MAP_BLOCKS,dataAllBlocks,member.getAddress());
      }
    }
    doResetRecords();
  }
}",0.9919236417033774
50632,"public static void shutdown(){
  if (dataMonitor != null) {
    dataMonitor=null;
  }
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(new ObjectName(MBeanBuilder.NAME_DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      mbs.unregisterMBean(name);
    }
  }
 catch (  Exception e) {
    logger.log(Level.WARNING,""String_Node_Str"",e);
  }
  if (statCollectors != null) {
    statCollectors.shutdownNow();
  }
}","public static void shutdown(){
  if (dataMonitor != null) {
    dataMonitor=null;
  }
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(new ObjectName(MBeanBuilder.NAME_DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      mbs.unregisterMBean(name);
    }
  }
 catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"",e);
  }
  if (statCollectors != null) {
    statCollectors.shutdownNow();
  }
}",0.9931707317073172
50633,"public void sendProcessableTo(RemotelyProcessable rp,Connection conn){
  Data value=ThreadContext.get().toData(rp);
  Packet packet=obtainPacket();
  try {
    packet.set(""String_Node_Str"",ClusterOperation.REMOTELY_PROCESS,null,value);
    boolean sent=send(packet,conn);
    if (!sent) {
      packet.returnToContainer();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void sendProcessableTo(RemotelyProcessable rp,Connection conn){
  Data value=ThreadContext.get().toData(rp);
  Packet packet=obtainPacket();
  packet.set(""String_Node_Str"",ClusterOperation.REMOTELY_PROCESS,null,value);
  boolean sent=send(packet,conn);
  if (!sent) {
    packet.returnToContainer();
  }
}",0.8914285714285715
50634,"public void sendFullMessage(Block block){
  try {
    Packet packet=ThreadContext.get().getPacketPool().obtain();
    packet.set(block.name,ClusterOperation.BLOCKING_QUEUE_FULL_BLOCK,null,null);
    packet.blockId=block.blockId;
    Address master=getMasterAddress();
    boolean sent=send(packet,master);
    if (!sent)     packet.returnToContainer();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void sendFullMessage(Block block){
  Packet packet=ThreadContext.get().getPacketPool().obtain();
  packet.set(block.name,ClusterOperation.BLOCKING_QUEUE_FULL_BLOCK,null,null);
  packet.blockId=block.blockId;
  Address master=getMasterAddress();
  boolean sent=send(packet,master);
  if (!sent)   packet.returnToContainer();
}",0.8924731182795699
50635,"public void process(){
  try {
    if (key != null) {
      Address owner=ConcurrentMapManager.get().getKeyOwner(key);
      if (owner.equals(thisAddress)) {
        handleListenerRegisterations(add,name,key,thisAddress,includeValue);
      }
 else {
        Packet packet=obtainPacket();
        packet.set(name,packetProcess,key,null);
        packet.longValue=(includeValue) ? 1 : 0;
        boolean sent=send(packet,owner);
        if (!sent) {
          packet.returnToContainer();
        }
      }
    }
 else {
      for (      MemberImpl member : lsMembers) {
        if (member.localMember()) {
          handleListenerRegisterations(add,name,key,thisAddress,includeValue);
        }
 else {
          sendAddRemoveListener(member.getAddress(),add,name,key,includeValue);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void process(){
  if (key != null) {
    Address owner=ConcurrentMapManager.get().getKeyOwner(key);
    if (owner.equals(thisAddress)) {
      handleListenerRegisterations(add,name,key,thisAddress,includeValue);
    }
 else {
      Packet packet=obtainPacket();
      packet.set(name,packetProcess,key,null);
      packet.longValue=(includeValue) ? 1 : 0;
      boolean sent=send(packet,owner);
      if (!sent) {
        packet.returnToContainer();
      }
    }
  }
 else {
    for (    MemberImpl member : lsMembers) {
      if (member.localMember()) {
        handleListenerRegisterations(add,name,key,thisAddress,includeValue);
      }
 else {
        sendAddRemoveListener(member.getAddress(),add,name,key,includeValue);
      }
    }
  }
}",0.865265760197775
50636,"private void registerListener(String name,Object key,boolean add,boolean includeValue){
  Data dataKey=null;
  if (key != null) {
    try {
      dataKey=ThreadContext.get().toData(key);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  enqueueAndReturn(new ListenerRegistrationProcess(name,dataKey,add,includeValue));
}","private void registerListener(String name,Object key,boolean add,boolean includeValue){
  Data dataKey=null;
  if (key != null) {
    dataKey=ThreadContext.get().toData(key);
  }
  enqueueAndReturn(new ListenerRegistrationProcess(name,dataKey,add,includeValue));
}",0.6072607260726073
50637,"public void syncForAdd(Address newAddress){
  for (  ListenerItem listenerItem : listeners) {
    Data dataKey=null;
    if (listenerItem.key != null) {
      try {
        dataKey=ThreadContext.get().toData(listenerItem.key);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
    sendAddRemoveListener(newAddress,true,listenerItem.name,dataKey,listenerItem.includeValue);
  }
}","public void syncForAdd(Address newAddress){
  for (  ListenerItem listenerItem : listeners) {
    Data dataKey=null;
    if (listenerItem.key != null) {
      dataKey=ThreadContext.get().toData(listenerItem.key);
    }
    sendAddRemoveListener(newAddress,true,listenerItem.name,dataKey,listenerItem.includeValue);
  }
}",0.6291208791208791
50638,"void sendAddRemoveListener(Address toAddress,boolean add,String name,Data key,boolean includeValue){
  Packet packet=obtainPacket();
  try {
    packet.set(name,(add) ? ClusterOperation.ADD_LISTENER : ClusterOperation.REMOVE_LISTENER,key,null);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  packet.longValue=(includeValue) ? 1 : 0;
  boolean sent=send(packet,toAddress);
  if (!sent) {
    packet.returnToContainer();
  }
}","void sendAddRemoveListener(Address toAddress,boolean add,String name,Data key,boolean includeValue){
  Packet packet=obtainPacket();
  packet.set(name,(add) ? ClusterOperation.ADD_LISTENER : ClusterOperation.REMOVE_LISTENER,key,null);
  packet.longValue=(includeValue) ? 1 : 0;
  boolean sent=send(packet,toAddress);
  if (!sent) {
    packet.returnToContainer();
  }
}",0.9156327543424316
50639,"public void set(String name,ClusterOperation operation,Object objKey,Object objValue) throws Exception {
  this.threadId=Thread.currentThread().hashCode();
  this.name=name;
  this.operation=operation;
  if (objKey != null) {
    key=ThreadContext.get().toData(objKey);
  }
  if (objValue != null) {
    value=ThreadContext.get().toData(objValue);
  }
}","public void set(String name,ClusterOperation operation,Object objKey,Object objValue){
  this.threadId=Thread.currentThread().hashCode();
  this.name=name;
  this.operation=operation;
  if (objKey != null) {
    key=ThreadContext.get().toData(objKey);
  }
  if (objValue != null) {
    value=ThreadContext.get().toData(objValue);
  }
}",0.377906976744186
50640,"public void setFromConnection(Connection conn){
  this.conn=conn;
  if (lockAddress == null)   lockAddress=conn.getEndPoint();
}","public void setFromConnection(Connection conn){
  this.conn=conn;
  if (lockAddress == null) {
    lockAddress=conn.getEndPoint();
  }
}",0.9696969696969696
50641,"@JMXAttribute(""String_Node_Str"") @JMXDescription(""String_Node_Str"") public String getConfigFileURL(){
  return Config.get().getConfigurationUrl().toString();
}","@JMXAttribute(""String_Node_Str"") @JMXDescription(""String_Node_Str"") public String getConfigFileURL(){
  File configurationFile=Config.get().getConfigurationFile();
  if (configurationFile != null) {
    return configurationFile.getAbsolutePath();
  }
  URL configurationUrl=Config.get().getConfigurationUrl();
  if (configurationUrl != null) {
    return configurationUrl.toString();
  }
  return null;
}",0.4902309058614564
50642,"public EntryEvent(Object source,int eventType,Object key,Object value){
  this(source);
  this.key=key;
  this.value=value;
  if (eventType == TYPE_REMOVED) {
    entryEventType=EntryEventType.REMOVED;
  }
 else   if (eventType == TYPE_UPDATED) {
    entryEventType=EntryEventType.UPDATED;
  }
}","public EntryEvent(Object source,int eventType,Object key,Object value){
  this(source);
  this.key=key;
  this.value=value;
  if (eventType == TYPE_REMOVED) {
    entryEventType=EntryEventType.REMOVED;
  }
 else   if (eventType == TYPE_UPDATED) {
    entryEventType=EntryEventType.UPDATED;
  }
 else   if (eventType == TYPE_EVICTED) {
    entryEventType=EntryEventType.EVICTED;
  }
}",0.8702064896755162
50643,"final boolean evict(Request req){
  Record record=getRecord(req.key);
  if (record != null && record.isEvictable()) {
    if (ownerForSure(record)) {
      removeRecord(req.key);
      return true;
    }
  }
  return false;
}","final boolean evict(Request req){
  Record record=getRecord(req.key);
  if (record != null && record.isEvictable()) {
    if (ownerForSure(record)) {
      fireMapEvent(mapListeners,name,EntryEvent.TYPE_EVICTED,record.key,record.value,record.mapListeners);
      removeRecord(req.key);
      return true;
    }
  }
  return false;
}",0.800718132854578
50644,"public void getEntries(Request request){
  Collection<Record> colRecords=mapRecords.values();
  Pairs pairs=new Pairs();
  long now=System.currentTimeMillis();
  for (  Record record : colRecords) {
    if (record.isValid(now)) {
      Block block=blocks[record.blockId];
      if (thisAddress.equals(block.owner)) {
        if (record.value != null || request.operation == CONCURRENT_MAP_ITERATE_KEYS_ALL) {
          pairs.addKeyValue(new KeyValue(record.key,null));
        }
 else         if (record.copyCount > 0) {
          for (int i=0; i < record.copyCount; i++) {
            pairs.addKeyValue(new KeyValue(record.key,null));
          }
        }
 else         if (record.lsValues != null) {
          int size=record.lsValues.size();
          if (size > 0) {
            if (request.operation == CONCURRENT_MAP_ITERATE_KEYS) {
              pairs.addKeyValue(new KeyValue(record.key,null));
            }
 else {
              for (int i=0; i < size; i++) {
                Data value=record.lsValues.get(i);
                pairs.addKeyValue(new KeyValue(record.key,value));
              }
            }
          }
        }
      }
    }
 else {
      if (!record.isEvictable()) {
        scheduleForEviction(record);
      }
    }
  }
  Data dataEntries=toData(pairs);
  request.longValue=pairs.size();
  request.response=dataEntries;
}","public void getEntries(Request request){
  Collection<Record> colRecords=mapRecords.values();
  Pairs pairs=new Pairs();
  long now=System.currentTimeMillis();
  for (  Record record : colRecords) {
    if (record.isValid(now)) {
      if (record.key == null || record.key.size() == 0) {
        throw new RuntimeException(""String_Node_Str"" + record.key);
      }
      Block block=blocks[record.blockId];
      if (thisAddress.equals(block.owner)) {
        if (record.value != null || request.operation == CONCURRENT_MAP_ITERATE_KEYS_ALL) {
          pairs.addKeyValue(new KeyValue(record.key,null));
        }
 else         if (record.copyCount > 0) {
          for (int i=0; i < record.copyCount; i++) {
            pairs.addKeyValue(new KeyValue(record.key,null));
          }
        }
 else         if (record.lsValues != null) {
          int size=record.lsValues.size();
          if (size > 0) {
            if (request.operation == CONCURRENT_MAP_ITERATE_KEYS) {
              pairs.addKeyValue(new KeyValue(record.key,null));
            }
 else {
              for (int i=0; i < size; i++) {
                Data value=record.lsValues.get(i);
                pairs.addKeyValue(new KeyValue(record.key,value));
              }
            }
          }
        }
      }
    }
 else {
      if (!record.isEvictable()) {
        scheduleForEviction(record);
      }
    }
  }
  Data dataEntries=toData(pairs);
  request.longValue=pairs.size();
  request.response=dataEntries;
}",0.9528501055594653
50645,"private static void init(){
  if (!inited) {
synchronized (Node.class) {
      if (startCount > 0) {
        try {
          Thread.sleep(5000);
        }
 catch (        InterruptedException ignored) {
        }
      }
      if (!inited) {
        node=Node.get();
        node.start();
        inited=true;
        startCount++;
        ManagementService.register(node.getClusterImpl());
        try {
          globalProxies.addEntryListener(new EntryListener(){
            public void entryAdded(            EntryEvent event){
              final ProxyKey proxyKey=(ProxyKey)event.getKey();
              if (!proxies.containsKey(proxyKey)) {
                logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
                ClusterService.get().enqueueAndReturn(new Processable(){
                  public void process(){
                    createProxy(proxyKey);
                  }
                }
);
              }
            }
            public void entryRemoved(            EntryEvent event){
              final ProxyKey proxyKey=(ProxyKey)event.getKey();
              if (proxies.containsKey(proxyKey)) {
                logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
                ClusterService.get().enqueueAndReturn(new Processable(){
                  public void process(){
                    destroyProxy(proxyKey);
                  }
                }
);
              }
            }
            public void entryUpdated(            EntryEvent event){
              logger.log(Level.FINEST,""String_Node_Str"" + event.getKey());
            }
          }
,false);
          if (Hazelcast.getCluster().getMembers().size() > 1) {
            Set<ProxyKey> proxyKeys=globalProxies.allKeys();
            for (            final ProxyKey proxyKey : proxyKeys) {
              if (!proxies.containsKey(proxyKey)) {
                ClusterService.get().enqueueAndReturn(new Processable(){
                  public void process(){
                    createProxy(proxyKey);
                  }
                }
);
              }
            }
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
  }
}","private static void init(){
  if (!inited) {
synchronized (Node.class) {
      if (startCount > 0) {
        try {
          Thread.sleep(5000);
        }
 catch (        InterruptedException ignored) {
        }
      }
      if (!inited) {
        node=Node.get();
        node.start();
        inited=true;
        startCount++;
        ManagementService.register(node.getClusterImpl());
        try {
          globalProxies.addEntryListener(new EntryListener(){
            public void entryAdded(            EntryEvent event){
              final ProxyKey proxyKey=(ProxyKey)event.getKey();
              if (!proxies.containsKey(proxyKey)) {
                logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
                ClusterService.get().enqueueAndReturn(new Processable(){
                  public void process(){
                    createProxy(proxyKey);
                  }
                }
);
              }
            }
            public void entryRemoved(            EntryEvent event){
              final ProxyKey proxyKey=(ProxyKey)event.getKey();
              if (proxies.containsKey(proxyKey)) {
                logger.log(Level.FINEST,""String_Node_Str"" + proxyKey);
                ClusterService.get().enqueueAndReturn(new Processable(){
                  public void process(){
                    destroyProxy(proxyKey);
                  }
                }
);
              }
            }
            public void entryUpdated(            EntryEvent event){
              logger.log(Level.FINEST,""String_Node_Str"" + event.getKey());
            }
            public void entryEvicted(            EntryEvent event){
              logger.log(Level.FINEST,""String_Node_Str"" + event.getKey());
            }
          }
,false);
          if (Hazelcast.getCluster().getMembers().size() > 1) {
            Set<ProxyKey> proxyKeys=globalProxies.allKeys();
            for (            final ProxyKey proxyKey : proxyKeys) {
              if (!proxies.containsKey(proxyKey)) {
                ClusterService.get().enqueueAndReturn(new Processable(){
                  public void process(){
                    createProxy(proxyKey);
                  }
                }
);
              }
            }
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
  }
}",0.965471739608533
50646,"@Override public void postRegister(Boolean registrationDone){
  super.postRegister(registrationDone);
  if (!registrationDone) {
    return;
  }
  if (ManagementService.showDetails()) {
    listener=new EntryListener(){
      public void entryAdded(      EntryEvent event){
        addEntry(event.getKey());
      }
      public void entryRemoved(      EntryEvent event){
        removeEntry(event.getKey());
      }
      public void entryUpdated(      EntryEvent event){
      }
    }
;
    getManagedObject().addEntryListener(listener,false);
    for (    Object key : getManagedObject().keySet()) {
      addEntry(key);
    }
  }
}","@Override public void postRegister(Boolean registrationDone){
  super.postRegister(registrationDone);
  if (!registrationDone) {
    return;
  }
  if (ManagementService.showDetails()) {
    listener=new EntryListener(){
      public void entryAdded(      EntryEvent event){
        addEntry(event.getKey());
      }
      public void entryRemoved(      EntryEvent event){
        removeEntry(event.getKey());
      }
      public void entryUpdated(      EntryEvent event){
      }
      public void entryEvicted(      EntryEvent event){
        entryRemoved(event);
      }
    }
;
    getManagedObject().addEntryListener(listener,false);
    for (    Object key : getManagedObject().keySet()) {
      addEntry(key);
    }
  }
}",0.9317681584739546
50647,"@Test public void testMapEntryListener(){
  IMap<String,String> map=Hazelcast.getMap(""String_Node_Str"");
  map.addEntryListener(new EntryListener(){
    public void entryAdded(    EntryEvent event){
      assertEquals(""String_Node_Str"",event.getValue());
      assertEquals(""String_Node_Str"",event.getKey());
    }
    public void entryRemoved(    EntryEvent event){
      assertEquals(""String_Node_Str"",event.getKey());
      assertEquals(""String_Node_Str"",event.getValue());
    }
    public void entryUpdated(    EntryEvent event){
      assertEquals(""String_Node_Str"",event.getValue());
      assertEquals(""String_Node_Str"",event.getKey());
    }
  }
,true);
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.remove(""String_Node_Str"");
}","@Test public void testMapEntryListener(){
  IMap<String,String> map=Hazelcast.getMap(""String_Node_Str"");
  map.addEntryListener(new EntryListener(){
    public void entryAdded(    EntryEvent event){
      assertEquals(""String_Node_Str"",event.getValue());
      assertEquals(""String_Node_Str"",event.getKey());
    }
    public void entryRemoved(    EntryEvent event){
      assertEquals(""String_Node_Str"",event.getKey());
      assertEquals(""String_Node_Str"",event.getValue());
    }
    public void entryUpdated(    EntryEvent event){
      assertEquals(""String_Node_Str"",event.getValue());
      assertEquals(""String_Node_Str"",event.getKey());
    }
    public void entryEvicted(    EntryEvent event){
      entryRemoved(event);
    }
  }
,true);
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.remove(""String_Node_Str"");
}",0.9491322561340516
50648,"public void connectionRemoved(Connection connection){
}","public void connectionRemoved(Connection connection){
  logger.log(Level.FINEST,""String_Node_Str"" + connection.getEndPoint());
  if (!Node.get().joined()) {
    if (getMasterAddress() != null) {
      if (getMasterAddress().equals(connection.getEndPoint())) {
        Node.get().setMasterAddress(null);
      }
    }
  }
}",0.2917771883289125
50649,"public int getEventType(){
  return eventType;
}","public EntryEventType getEventType(){
  return entryEventType;
}",0.8392857142857143
50650,"@Override public Object getSource(){
  if (name.startsWith(""String_Node_Str"")) {
    return FactoryImpl.getProxy(name.substring(2));
  }
  return FactoryImpl.getProxy(name);
}","@Override public Object getSource(){
  return FactoryImpl.getProxyByName(name);
}",0.609375
50651,"public EntryEvent(Object source,int eventType,Object key,Object value){
  this(source);
  this.eventType=eventType;
  this.key=key;
  this.value=value;
}","public EntryEvent(Object source,int eventType,Object key,Object value){
  this(source);
  this.key=key;
  this.value=value;
  if (eventType == TYPE_REMOVED) {
    entryEventType=EntryEventType.REMOVED;
  }
 else   if (eventType == TYPE_UPDATED) {
    entryEventType=EntryEventType.UPDATED;
  }
}",0.5267857142857143
50652,"@Override public String toString(){
  String event=ADDED;
  if (eventType == TYPE_REMOVED) {
    event=REMOVED;
  }
 else   if (eventType == TYPE_UPDATED) {
    event=UPDATED;
  }
  return ""String_Node_Str"" + getSource() + ""String_Node_Str""+ key+ ""String_Node_Str""+ value+ ""String_Node_Str""+ event;
}","@Override public String toString(){
  return ""String_Node_Str"" + getSource() + ""String_Node_Str""+ key+ ""String_Node_Str""+ value+ ""String_Node_Str""+ entryEventType;
}",0.6709677419354839
50653,"public EventTask(final int eventType,final String name,final Data dataKey,final Data dataValue){
  super(name);
  this.eventType=eventType;
  this.dataKey=dataKey;
  this.dataValue=dataValue;
}","public EventTask(final int eventType,final String name,final Data dataKey,final Data dataValue){
  super(name,eventType,null,null);
  this.dataKey=dataKey;
  this.dataValue=dataValue;
}",0.9206349206349206
50654,"public static Map.Entry createSimpleEntry(final String name,final Object key,final Object value){
  return new Map.Entry(){
    public Object getKey(){
      return key;
    }
    public Object getValue(){
      return value;
    }
    public Object setValue(    Object newValue){
      return ((FactoryImpl.MProxy)FactoryImpl.getProxy(name)).put(key,newValue);
    }
    @Override public String toString(){
      return ""String_Node_Str"" + getKey() + ""String_Node_Str""+ getValue();
    }
  }
;
}","public static Map.Entry createSimpleEntry(final String name,final Object key,final Object value){
  return new Map.Entry(){
    public Object getKey(){
      return key;
    }
    public Object getValue(){
      return value;
    }
    public Object setValue(    Object newValue){
      return ((FactoryImpl.MProxy)FactoryImpl.getProxyByName(name)).put(key,newValue);
    }
    @Override public String toString(){
      return ""String_Node_Str"" + getKey() + ""String_Node_Str""+ getValue();
    }
  }
;
}",0.9939879759519038
50655,"public Object getValue(){
  if (objValue == null) {
    if (value != null) {
      objValue=toObject(value);
    }
 else {
      objValue=((FactoryImpl.IGetAwareProxy)FactoryImpl.getProxy(name)).get((key == null) ? getKey() : key);
    }
  }
  return objValue;
}","public Object getValue(){
  if (objValue == null) {
    if (value != null) {
      objValue=toObject(value);
    }
 else {
      objValue=((FactoryImpl.IGetAwareProxy)FactoryImpl.getProxyByName(name)).get((key == null) ? getKey() : key);
    }
  }
  return objValue;
}",0.9886792452830188
50656,"public Object setValue(Object newValue){
  if (name == null)   throw new UnsupportedOperationException();
  this.objValue=value;
  return ((FactoryImpl.MProxy)FactoryImpl.getProxy(name)).put(getKey(),newValue);
}","public Object setValue(Object newValue){
  if (name == null)   throw new UnsupportedOperationException();
  this.objValue=value;
  return ((FactoryImpl.MProxy)FactoryImpl.getProxyByName(name)).put(getKey(),newValue);
}",0.986046511627907
50657,"public Data put(Request req){
  if (req.operation == ClusterOperation.CONCURRENT_MAP_PUT_IF_ABSENT) {
    Record record=recordExist(req);
    if (record != null && record.getValue() != null) {
      return doHardCopy(record.getValue());
    }
  }
 else   if (req.operation == ClusterOperation.CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    Record record=recordExist(req);
    if (record == null || record.getValue() == null) {
      return null;
    }
  }
  Record record=getRecord(req.key);
  Data oldValue=null;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    req.key=null;
  }
 else {
    if (!record.isValid()) {
      record.setExpirationTime(ttl);
    }
    oldValue=record.getValue();
    record.setValue(req.value);
    record.version++;
    touch(record);
    record.setLastUpdated();
  }
  req.version=record.version;
  req.longValue=record.copyCount;
  req.value=null;
  if (oldValue == null) {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,record);
  }
 else {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_UPDATED,record);
  }
  markRecordDirty(record);
  return oldValue;
}","public Data put(Request req){
  if (req.value == null) {
    req.value=new Data();
  }
  if (req.operation == ClusterOperation.CONCURRENT_MAP_PUT_IF_ABSENT) {
    Record record=recordExist(req);
    if (record != null && record.getValue() != null) {
      return doHardCopy(record.getValue());
    }
  }
 else   if (req.operation == ClusterOperation.CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    Record record=recordExist(req);
    if (record == null || record.getValue() == null) {
      return null;
    }
  }
  Record record=getRecord(req.key);
  Data oldValue=null;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    req.key=null;
  }
 else {
    if (!record.isValid()) {
      record.setExpirationTime(ttl);
    }
    oldValue=record.getValue();
    record.setValue(req.value);
    record.version++;
    touch(record);
    record.setLastUpdated();
  }
  req.version=record.version;
  req.longValue=record.copyCount;
  req.value=null;
  if (oldValue == null) {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,record);
  }
 else {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_UPDATED,record);
  }
  markRecordDirty(record);
  return oldValue;
}",0.9752925877763328
50658,"public void own(Request req){
  Record record=toRecord(req);
  record.owner=thisAddress;
}","public void own(Request req){
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=toRecord(req);
  record.owner=thisAddress;
}",0.759493670886076
50659,"public Object getValue(){
  if (value == null) {
    value=((FactoryImpl.MProxy)FactoryImpl.getProxy(name)).get(key);
  }
  return value;
}","public Object getValue(){
  if (value == null) {
    value=((FactoryImpl.MProxy)FactoryImpl.getProxyByName(name)).get(key);
  }
  return value;
}",0.9788732394366196
50660,"public Object setValue(Object value){
  Object oldValue=this.value;
  ((FactoryImpl.MProxy)FactoryImpl.getProxy(name)).put(key,value);
  return oldValue;
}","public Object setValue(Object value){
  Object oldValue=this.value;
  ((FactoryImpl.MProxy)FactoryImpl.getProxyByName(name)).put(key,value);
  return oldValue;
}",0.981012658227848
50661,"public void stop(){
  setJoins.clear();
  timeToStartJoin=0;
  lsMembers.clear();
}","public void stop(){
  if (setJoins != null) {
    setJoins.clear();
  }
  timeToStartJoin=0;
  if (lsMembers != null) {
    lsMembers.clear();
  }
}",0.7186147186147186
50662,"public void stop(){
  if (!started)   return;
  executionIds.clear();
  executor.shutdownNow();
  started=false;
}","public void stop(){
  if (!started)   return;
  executionIds.clear();
  if (executor != null) {
    executor.shutdownNow();
  }
  started=false;
}",0.8769230769230769
50663,"public void shutdown(){
  try {
    joined=false;
    ConcurrentMapManager.get().reset();
    ClusterService.get().stop();
    MulticastService.get().stop();
    ConnectionManager.get().shutdown();
    ExecutorManager.get().stop();
    InSelector.get().shutdown();
    OutSelector.get().shutdown();
    address=null;
    masterAddress=null;
    FactoryImpl.inited=false;
    ClusterManager.get().stop();
  }
 catch (  Throwable e) {
    logger.log(Level.FINEST,""String_Node_Str"",e);
  }
}","public void shutdown(){
  try {
    joined=false;
    ConcurrentMapManager.get().reset();
    ClusterService.get().stop();
    MulticastService.get().stop();
    ConnectionManager.get().shutdown();
    ExecutorManager.get().stop();
    InSelector.get().shutdown();
    OutSelector.get().shutdown();
    address=null;
    masterAddress=null;
    FactoryImpl.inited=false;
    ClusterManager.get().stop();
  }
 catch (  Throwable e) {
    if (logger != null)     logger.log(Level.FINEST,""String_Node_Str"",e);
  }
}",0.976
50664,"@Override public void shutdown(){
  try {
    super.shutdown();
    serverSocketChannel.close();
  }
 catch (  IOException ignored) {
  }
}","@Override public void shutdown(){
  try {
    super.shutdown();
    if (serverSocketChannel != null) {
      serverSocketChannel.close();
    }
  }
 catch (  IOException ignored) {
  }
}",0.8553846153846154
50665,"public void shutdown(){
  live=false;
  selectorQueue.clear();
}","public void shutdown(){
  live=false;
  if (selectorQueue != null) {
    selectorQueue.clear();
  }
}",0.7757575757575758
50666,"public void removeMembershipListener(MembershipListener listener){
  Set<MembershipListener> oldListeners=listeners.get();
  if (oldListeners == null || oldListeners.size() == 0)   return;
  int size=oldListeners.size() - 1;
  Set<MembershipListener> newListeners=new LinkedHashSet<MembershipListener>(size);
  for (  MembershipListener existingListener : oldListeners) {
    if (existingListener.equals(listener))     newListeners.add(existingListener);
  }
  listeners.set(newListeners);
}","public void removeMembershipListener(MembershipListener listener){
  Set<MembershipListener> oldListeners=listeners.get();
  if (oldListeners == null || oldListeners.size() == 0)   return;
  int size=oldListeners.size() - 1;
  Set<MembershipListener> newListeners=new LinkedHashSet<MembershipListener>(size);
  for (  MembershipListener existingListener : oldListeners) {
    if (!existingListener.equals(listener)) {
      newListeners.add(existingListener);
    }
  }
  listeners.set(newListeners);
}",0.9889224572004028
50667,"void doRemoveAddress(Address deadAddress){
  if (DEBUG) {
    log(""String_Node_Str"" + deadAddress);
  }
  if (!Node.get().joined()) {
    return;
  }
  if (deadAddress.equals(thisAddress))   return;
  if (deadAddress.equals(getMasterAddress())) {
    if (Node.get().joined()) {
      MemberImpl newMaster=getNextMemberAfter(deadAddress,false,1);
      if (newMaster != null)       Node.get().setMasterAddress(newMaster.getAddress());
 else       Node.get().setMasterAddress(null);
    }
 else {
      Node.get().setMasterAddress(null);
    }
    if (DEBUG) {
      log(""String_Node_Str"" + Node.get().getMasterAddress());
    }
  }
  if (isMaster()) {
    setJoins.remove(new MemberInfo(deadAddress));
  }
  lsMembersBefore.clear();
  for (  MemberImpl member : lsMembers) {
    lsMembersBefore.add(member);
  }
  Connection conn=ConnectionManager.get().getConnection(deadAddress);
  if (conn != null) {
    ConnectionManager.get().remove(conn);
  }
  MemberImpl member=getMember(deadAddress);
  if (member != null) {
    removeMember(deadAddress);
  }
  BlockingQueueManager.get().syncForDead(deadAddress);
  ConcurrentMapManager.get().syncForDead(deadAddress);
  ListenerManager.get().syncForDead(deadAddress);
  TopicManager.get().syncForDead(deadAddress);
  Node.get().getClusterImpl().setMembers(lsMembers);
  Object[] calls=mapCalls.values().toArray();
  for (  Object call : calls) {
    ((Call)call).onDisconnect(deadAddress);
  }
  System.out.println(this);
}","void doRemoveAddress(Address deadAddress){
  if (DEBUG) {
    log(""String_Node_Str"" + deadAddress);
  }
  if (!Node.get().joined()) {
    return;
  }
  if (deadAddress.equals(thisAddress))   return;
  if (deadAddress.equals(getMasterAddress())) {
    if (Node.get().joined()) {
      MemberImpl newMaster=getNextMemberAfter(deadAddress,false,1);
      if (newMaster != null)       Node.get().setMasterAddress(newMaster.getAddress());
 else       Node.get().setMasterAddress(null);
    }
 else {
      Node.get().setMasterAddress(null);
    }
    if (DEBUG) {
      log(""String_Node_Str"" + Node.get().getMasterAddress());
    }
  }
  if (isMaster()) {
    setJoins.remove(new MemberInfo(deadAddress));
  }
  lsMembersBefore.clear();
  for (  MemberImpl member : lsMembers) {
    lsMembersBefore.add(member);
  }
  Connection conn=ConnectionManager.get().getConnection(deadAddress);
  if (conn != null) {
    ConnectionManager.get().remove(conn);
  }
  MemberImpl member=getMember(deadAddress);
  if (member != null) {
    removeMember(deadAddress);
  }
  BlockingQueueManager.get().syncForDead(deadAddress);
  ConcurrentMapManager.get().syncForDead(deadAddress);
  ListenerManager.get().syncForDead(deadAddress);
  TopicManager.get().syncForDead(deadAddress);
  Node.get().getClusterImpl().setMembers(lsMembers);
  Object[] calls=mapCalls.values().toArray();
  for (  Object call : calls) {
    ((Call)call).onDisconnect(deadAddress);
  }
  logger.log(Level.INFO,this.toString());
}",0.980325644504749
50668,"private ClusterManager(){
  ClusterService.get().registerPeriodicRunnable(new Runnable(){
    public void run(){
      heartBeater();
    }
  }
);
  ClusterService.get().registerPeriodicRunnable(new Runnable(){
    public void run(){
      checkScheduledActions();
    }
  }
);
  ConnectionManager.get().addConnectionListener(this);
  ClusterService.get().registerPacketProcessor(ClusterOperation.RESPONSE,new PacketProcessor(){
    public void process(    Packet packet){
      handleResponse(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(ClusterOperation.HEARTBEAT,new PacketProcessor(){
    public void process(    Packet packet){
      packet.returnToContainer();
    }
  }
);
  ClusterService.get().registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS_AND_RESPOND,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=BufferUtil.doTake(packet.value);
      RemotelyProcessable rp=(RemotelyProcessable)ThreadContext.get().toObject(data);
      rp.setConnection(packet.conn);
      rp.process();
      sendResponse(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=BufferUtil.doTake(packet.value);
      RemotelyProcessable rp=(RemotelyProcessable)ThreadContext.get().toObject(data);
      rp.setConnection(packet.conn);
      rp.process();
      packet.returnToContainer();
    }
  }
);
  ClusterService.get().registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_BOOLEAN,new PacketProcessor(){
    public void process(    Packet packet){
      Boolean result;
      try {
        Data data=BufferUtil.doTake(packet.value);
        AbstractRemotelyCallable<Boolean> callable=(AbstractRemotelyCallable<Boolean>)ThreadContext.get().toObject(data);
        callable.setConnection(packet.conn);
        result=callable.call();
      }
 catch (      Exception e) {
        e.printStackTrace(System.out);
        result=Boolean.FALSE;
      }
      if (result == Boolean.TRUE) {
        sendResponse(packet);
      }
 else {
        sendResponseFailure(packet);
      }
    }
  }
);
  ClusterService.get().registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_OBJECT,new PacketProcessor(){
    public void process(    Packet packet){
      Object result;
      try {
        Data data=BufferUtil.doTake(packet.value);
        AbstractRemotelyCallable callable=(AbstractRemotelyCallable)ThreadContext.get().toObject(data);
        callable.setConnection(packet.conn);
        result=callable.call();
      }
 catch (      Exception e) {
        e.printStackTrace(System.out);
        result=null;
      }
      if (result != null) {
        Data value;
        if (result instanceof Data) {
          value=(Data)result;
        }
 else {
          value=ThreadContext.get().toData(result);
        }
        BufferUtil.doSet(value,packet.value);
      }
      sendResponse(packet);
    }
  }
);
}","private ClusterManager(){
  ClusterService.get().registerPeriodicRunnable(new Runnable(){
    public void run(){
      heartBeater();
    }
  }
);
  ClusterService.get().registerPeriodicRunnable(new Runnable(){
    public void run(){
      checkScheduledActions();
    }
  }
);
  ConnectionManager.get().addConnectionListener(this);
  ClusterService.get().registerPacketProcessor(ClusterOperation.RESPONSE,new PacketProcessor(){
    public void process(    Packet packet){
      handleResponse(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(ClusterOperation.HEARTBEAT,new PacketProcessor(){
    public void process(    Packet packet){
      packet.returnToContainer();
    }
  }
);
  ClusterService.get().registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS_AND_RESPOND,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=BufferUtil.doTake(packet.value);
      RemotelyProcessable rp=(RemotelyProcessable)ThreadContext.get().toObject(data);
      rp.setConnection(packet.conn);
      rp.process();
      sendResponse(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=BufferUtil.doTake(packet.value);
      RemotelyProcessable rp=(RemotelyProcessable)ThreadContext.get().toObject(data);
      rp.setConnection(packet.conn);
      rp.process();
      packet.returnToContainer();
    }
  }
);
  ClusterService.get().registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_BOOLEAN,new PacketProcessor(){
    public void process(    Packet packet){
      Boolean result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=BufferUtil.doTake(packet.value);
        callable=(AbstractRemotelyCallable<Boolean>)toObject(data);
        callable.setConnection(packet.conn);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=Boolean.FALSE;
      }
      if (result == Boolean.TRUE) {
        sendResponse(packet);
      }
 else {
        sendResponseFailure(packet);
      }
    }
  }
);
  ClusterService.get().registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_OBJECT,new PacketProcessor(){
    public void process(    Packet packet){
      Object result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=BufferUtil.doTake(packet.value);
        callable=(AbstractRemotelyCallable)toObject(data);
        callable.setConnection(packet.conn);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=null;
      }
      if (result != null) {
        Data value;
        if (result instanceof Data) {
          value=(Data)result;
        }
 else {
          value=toData(result);
        }
        doSet(value,packet.value);
      }
      sendResponse(packet);
    }
  }
);
}",0.9269830733488218
50669,"public CMap(String name){
  super();
  this.name=name;
  mapRecords=new SortedHashMap<Data,Record>(10000);
  MapConfig mapConfig=Config.get().getMapConfig(name.substring(2));
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  if (""String_Node_Str"".equalsIgnoreCase(mapConfig.getEvictionPolicy())) {
    evictionPolicy=OrderingType.LFU;
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(mapConfig.getEvictionPolicy())) {
    evictionPolicy=OrderingType.LRU;
  }
 else {
    evictionPolicy=OrderingType.NONE;
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100;
  if (evictionPolicy == OrderingType.NONE) {
    maxSize=Integer.MAX_VALUE;
  }
 else {
    maxSize=(mapConfig.getMaxSize() == 0) ? MapConfig.DEFAULT_MAX_SIZE : mapConfig.getMaxSize();
  }
  instanceType=getInstanceType(name);
  loader=null;
  store=null;
}","public CMap(String name){
  super();
  this.name=name;
  mapRecords=new SortedHashMap<Data,Record>(10000);
  MapConfig mapConfig=Config.get().getMapConfig(name.substring(2));
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  if (""String_Node_Str"".equalsIgnoreCase(mapConfig.getEvictionPolicy())) {
    evictionPolicy=OrderingType.LFU;
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(mapConfig.getEvictionPolicy())) {
    evictionPolicy=OrderingType.LRU;
  }
 else {
    evictionPolicy=OrderingType.NONE;
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100f;
  if (evictionPolicy == OrderingType.NONE) {
    maxSize=Integer.MAX_VALUE;
  }
 else {
    maxSize=(mapConfig.getMaxSize() == 0) ? MapConfig.DEFAULT_MAX_SIZE : mapConfig.getMaxSize();
  }
  instanceType=getInstanceType(name);
  loader=null;
  store=null;
}",0.9994262765347104
50670,"public void run(){
  while (live) {
    if (size.get() > 0) {
      processSelectionQueue();
    }
    int selectedKeys;
    try {
      selectedKeys=selector.select(waitTime);
      if (Thread.interrupted()) {
        Node.get().handleInterruptedException(Thread.currentThread(),new RuntimeException());
      }
    }
 catch (    final Throwable exp) {
      continue;
    }
    if (selectedKeys == 0) {
      continue;
    }
    final Set<SelectionKey> setSelectedKeys=selector.selectedKeys();
    final Iterator<SelectionKey> it=setSelectedKeys.iterator();
    while (it.hasNext()) {
      final SelectionKey sk=it.next();
      it.remove();
      try {
        sk.interestOps(sk.interestOps() & ~sk.readyOps());
        final SelectionHandler selectionHandler=(SelectionHandler)sk.attachment();
        selectionHandler.handle();
      }
 catch (      final Exception e) {
        handleSelectorException(e);
      }
    }
  }
}","public void run(){
  while (live) {
    if (size.get() > 0) {
      processSelectionQueue();
    }
    int selectedKeys;
    try {
      selectedKeys=selector.select(waitTime);
      if (Thread.interrupted()) {
        Node.get().handleInterruptedException(Thread.currentThread(),new RuntimeException());
      }
    }
 catch (    final Throwable exp) {
      continue;
    }
    if (selectedKeys == 0) {
      continue;
    }
    final Set<SelectionKey> setSelectedKeys=selector.selectedKeys();
    final Iterator<SelectionKey> it=setSelectedKeys.iterator();
    while (it.hasNext()) {
      final SelectionKey sk=it.next();
      it.remove();
      try {
        sk.interestOps(sk.interestOps() & ~sk.readyOps());
        final SelectionHandler selectionHandler=(SelectionHandler)sk.attachment();
        selectionHandler.handle();
      }
 catch (      final Exception e) {
        handleSelectorException(e);
      }
    }
  }
  try {
    selector.close();
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
}",0.95097037793667
50671,"public void shutdown(){
  live=false;
  selectorQueue.clear();
  try {
    selector.close();
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
}","public void shutdown(){
  live=false;
  selectorQueue.clear();
}",0.5765765765765766
50672,"private String encodeURL(final String url,final String sessionURLPhrase){
  if (url == null || req == null || req.isRequestedSessionIdFromCookie()) {
    final int prefix=url.indexOf(sessionURLPhrase);
    if (prefix != -1) {
      int suffix=url.indexOf(""String_Node_Str"",prefix);
      if (suffix < 0)       suffix=url.indexOf(""String_Node_Str"",prefix);
      if (suffix <= prefix)       return url.substring(0,prefix);
      return url.substring(0,prefix) + url.substring(suffix);
    }
    return url;
  }
  final HazelSession session=req.getSession(false);
  if (session == null)   return url;
  if (!session.valid.get())   return url;
  final String id=session.getId();
  final int prefix=url.indexOf(sessionURLPhrase);
  if (prefix != -1) {
    int suffix=url.indexOf(""String_Node_Str"",prefix);
    if (suffix < 0)     suffix=url.indexOf(""String_Node_Str"",prefix);
    if (suffix <= prefix)     return url.substring(0,prefix + sessionURLPhrase.length()) + id;
    return url.substring(0,prefix + sessionURLPhrase.length()) + id + url.substring(suffix);
  }
  int suffix=url.indexOf('?');
  if (suffix < 0)   suffix=url.indexOf('#');
  if (suffix < 0)   return url + sessionURLPhrase + id;
  return url.substring(0,suffix) + sessionURLPhrase + id+ url.substring(suffix);
}","private String encodeURL(final String url,final String sessionURLPhrase){
  if (url != null || req == null || req.isRequestedSessionIdFromCookie()) {
    final int prefix=url.indexOf(sessionURLPhrase);
    if (prefix != -1) {
      int suffix=url.indexOf(""String_Node_Str"",prefix);
      if (suffix < 0)       suffix=url.indexOf(""String_Node_Str"",prefix);
      if (suffix <= prefix)       return url.substring(0,prefix);
      return url.substring(0,prefix) + url.substring(suffix);
    }
    return url;
  }
  final HazelSession session=req.getSession(false);
  if (session == null)   return url;
  if (!session.valid.get())   return url;
  final String id=session.getId();
  final int prefix=url.indexOf(sessionURLPhrase);
  if (prefix != -1) {
    int suffix=url.indexOf(""String_Node_Str"",prefix);
    if (suffix < 0)     suffix=url.indexOf(""String_Node_Str"",prefix);
    if (suffix <= prefix)     return url.substring(0,prefix + sessionURLPhrase.length()) + id;
    return url.substring(0,prefix + sessionURLPhrase.length()) + id + url.substring(suffix);
  }
  int suffix=url.indexOf('?');
  if (suffix < 0)   suffix=url.indexOf('#');
  if (suffix < 0)   return url + sessionURLPhrase + id;
  return url.substring(0,suffix) + sessionURLPhrase + id+ url.substring(suffix);
}",0.9992175273865416
50673,"public void getEntries(Request request){
  Collection<Record> colRecords=mapRecords.values();
  Pairs pairs=new Pairs();
  long now=System.currentTimeMillis();
  for (  Record record : colRecords) {
    if (record.isValid(now)) {
      Block block=blocks[record.blockId];
      if (thisAddress.equals(block.owner)) {
        if (record.value != null) {
          pairs.addKeyValue(new KeyValue(record.key,null));
        }
 else         if (record.copyCount > 0) {
          for (int i=0; i < record.copyCount; i++) {
            pairs.addKeyValue(new KeyValue(record.key,null));
          }
        }
 else         if (record.lsValues != null) {
          int size=record.lsValues.size();
          if (size > 0) {
            if (request.operation == OP_CMAP_ITERATE_VALUES) {
              for (int i=0; i < size; i++) {
                Data value=record.lsValues.get(i);
                pairs.addKeyValue(new KeyValue(record.key,value));
              }
            }
 else {
              pairs.addKeyValue(new KeyValue(record.key,null));
            }
          }
        }
      }
    }
 else {
      if (!record.isEvictable()) {
        scheduleForEviction(record);
      }
    }
  }
  Data dataEntries=toData(pairs);
  request.longValue=pairs.size();
  request.response=dataEntries;
}","public void getEntries(Request request){
  Collection<Record> colRecords=mapRecords.values();
  Pairs pairs=new Pairs();
  long now=System.currentTimeMillis();
  for (  Record record : colRecords) {
    if (record.isValid(now)) {
      Block block=blocks[record.blockId];
      if (thisAddress.equals(block.owner)) {
        if (record.value != null) {
          pairs.addKeyValue(new KeyValue(record.key,null));
        }
 else         if (record.copyCount > 0) {
          for (int i=0; i < record.copyCount; i++) {
            pairs.addKeyValue(new KeyValue(record.key,null));
          }
        }
 else         if (record.lsValues != null) {
          int size=record.lsValues.size();
          if (size > 0) {
            if (request.operation == OP_CMAP_ITERATE_KEYS) {
              pairs.addKeyValue(new KeyValue(record.key,null));
            }
 else {
              for (int i=0; i < size; i++) {
                Data value=record.lsValues.get(i);
                pairs.addKeyValue(new KeyValue(record.key,value));
              }
            }
          }
        }
      }
    }
 else {
      if (!record.isEvictable()) {
        scheduleForEviction(record);
      }
    }
  }
  Data dataEntries=toData(pairs);
  request.longValue=pairs.size();
  request.response=dataEntries;
}",0.9295665634674922
50674,"static Object createProxy(String name){
  ICommon proxy=proxies.get(name);
  if (proxy == null) {
    if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        proxy=new QProxyImpl(name);
        proxies.put(name,proxy);
      }
    }
 else     if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        proxy=new TopicProxyImpl(name);
        proxies.put(name,proxy);
      }
    }
 else     if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        proxy=new MProxyImpl(name);
        proxies.put(name,proxy);
      }
    }
 else     if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        if (BaseManager.getMapType(name) == MAP_TYPE_MULTI_MAP) {
          proxy=new MultiMapProxy(name);
        }
 else {
          proxy=new CollectionProxyImpl(name);
        }
        proxies.put(name,proxy);
      }
    }
  }
  return proxy;
}","static Object createProxy(String name){
  ICommon proxy=proxies.get(name);
  if (proxy == null) {
    if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        proxy=new QProxyImpl(name);
        proxies.put(name,proxy);
      }
    }
 else     if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        proxy=new TopicProxyImpl(name);
        proxies.put(name,proxy);
      }
    }
 else     if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        proxy=new MProxyImpl(name);
        proxies.put(name,proxy);
      }
    }
 else     if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        if (BaseManager.getInstanceType(name) == ICommon.InstanceType.MULTIMAP) {
          proxy=new MultiMapProxy(name);
        }
 else {
          proxy=new CollectionProxyImpl(name);
        }
        proxies.put(name,proxy);
      }
    }
  }
  return proxy;
}",0.980824544582934
50675,"public Object getValue(){
  if (objValue == null) {
    if (value != null) {
      objValue=toObject(value);
    }
 else {
      objValue=((FactoryImpl.MProxy)FactoryImpl.getProxy(name)).get((key == null) ? getKey() : key);
    }
  }
  return objValue;
}","public Object getValue(){
  if (objValue == null) {
    if (value != null) {
      objValue=toObject(value);
    }
 else {
      objValue=((FactoryImpl.IGetAwareProxy)FactoryImpl.getProxy(name)).get((key == null) ? getKey() : key);
    }
  }
  return objValue;
}",0.9806201550387597
50676,"public MGetEntries(Address target){
  this.target=target;
  request.reset();
  request.name=name;
  request.operation=(iteratorType == MIterate.TYPE_KEYS) ? OP_CMAP_ITERATE_KEYS : OP_CMAP_ITERATE;
}","public MGetEntries(Address target){
  this.target=target;
  request.reset();
  request.name=name;
  if (iteratorType == MIterate.TYPE_ENTRIES) {
    request.operation=OP_CMAP_ITERATE_ENTRIES;
  }
 else   if (iteratorType == MIterate.TYPE_KEYS) {
    request.operation=OP_CMAP_ITERATE_KEYS;
  }
 else   if (iteratorType == MIterate.TYPE_VALUES) {
    request.operation=OP_CMAP_ITERATE_VALUES;
  }
}",0.5815126050420169
50677,"private ConcurrentMapManager(){
  ClusterService.get().registerPeriodicRunnable(new Runnable(){
    public void run(){
      Collection<CMap> cmaps=maps.values();
      for (      CMap cmap : cmaps) {
        if (cmap.ttl != 0) {
          cmap.startEviction();
        }
      }
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_GET,new DefaultPacketProcessor(false,true,false,true){
    void handle(    Request request){
      doGet(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_GET_MAP_ENTRY,new DefaultPacketProcessor(false,true,false,true){
    void handle(    Request request){
      doGetMapEntry(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doPut(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_PUT,new DefaultPacketProcessor(){
    void handle(    Request request){
      doBackup(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT_IF_ABSENT,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doPut(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REPLACE_IF_NOT_NULL,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doPut(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_ADD,new DefaultPacketProcessor(){
    void handle(    Request request){
      doBackup(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_REMOVE_MULTI,new DefaultPacketProcessor(){
    void handle(    Request request){
      doBackup(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_REMOVE,new DefaultPacketProcessor(false,false,false,false){
    void handle(    Request request){
      doBackup(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_LOCK,new DefaultPacketProcessor(false,false,false,false){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT_MULTI,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doPut(request,false);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doRemove(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE_MULTI,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doRemoveMulti(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE_ITEM,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doRemove(request,false);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE_IF_SAME,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doRemove(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_LOCK,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_LOCK_RETURN_OLD,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_UNLOCK,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_SIZE,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleSize(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ITERATE,new DefaultPacketProcessor(true,false,false,true){
    void handle(    Request request){
      CMap cmap=getMap(request.name);
      cmap.getEntries(remoteReq);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ITERATE_KEYS,new DefaultPacketProcessor(true,false,false,true){
    void handle(    Request request){
      CMap cmap=getMap(request.name);
      cmap.getEntries(remoteReq);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ADD_TO_LIST,new DefaultPacketProcessor(false,true,false,false){
    void handle(    Request request){
      doAdd(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ADD_TO_SET,new DefaultPacketProcessor(false,true,false,false){
    void handle(    Request request){
      doAdd(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_CONTAINS,new DefaultPacketProcessor(true,false,false,false){
    void handle(    Request request){
      doContains(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BLOCK_INFO,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleBlockInfo(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BLOCKS,new PacketProcessor(){
    public void process(    Packet packet){
      handleBlocks(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_MIGRATION_COMPLETE,new PacketProcessor(){
    public void process(    Packet packet){
      doMigrationComplete(packet.conn.getEndPoint());
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_MIGRATE_RECORD,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleMigrateRecord(packet);
    }
  }
);
}","private ConcurrentMapManager(){
  ClusterService.get().registerPeriodicRunnable(new Runnable(){
    public void run(){
      Collection<CMap> cmaps=maps.values();
      for (      CMap cmap : cmaps) {
        if (cmap.ttl != 0) {
          cmap.startEviction();
        }
      }
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_GET,new DefaultPacketProcessor(false,true,false,true){
    void handle(    Request request){
      doGet(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_GET_MAP_ENTRY,new DefaultPacketProcessor(false,true,false,true){
    void handle(    Request request){
      doGetMapEntry(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doPut(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_PUT,new DefaultPacketProcessor(){
    void handle(    Request request){
      doBackup(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT_IF_ABSENT,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doPut(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REPLACE_IF_NOT_NULL,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doPut(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_ADD,new DefaultPacketProcessor(){
    void handle(    Request request){
      doBackup(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_REMOVE_MULTI,new DefaultPacketProcessor(){
    void handle(    Request request){
      doBackup(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_REMOVE,new DefaultPacketProcessor(false,false,false,false){
    void handle(    Request request){
      doBackup(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_LOCK,new DefaultPacketProcessor(false,false,false,false){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT_MULTI,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doPut(request,false);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doRemove(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE_MULTI,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doRemoveMulti(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE_ITEM,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doRemove(request,false);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE_IF_SAME,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doRemove(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_LOCK,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_LOCK_RETURN_OLD,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_UNLOCK,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_SIZE,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleSize(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ITERATE_ENTRIES,new DefaultPacketProcessor(true,false,false,true){
    void handle(    Request request){
      CMap cmap=getMap(request.name);
      cmap.getEntries(remoteReq);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ITERATE_VALUES,new DefaultPacketProcessor(true,false,false,true){
    void handle(    Request request){
      CMap cmap=getMap(request.name);
      cmap.getEntries(remoteReq);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ITERATE_KEYS,new DefaultPacketProcessor(true,false,false,true){
    void handle(    Request request){
      CMap cmap=getMap(request.name);
      cmap.getEntries(remoteReq);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ADD_TO_LIST,new DefaultPacketProcessor(false,true,false,false){
    void handle(    Request request){
      doAdd(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ADD_TO_SET,new DefaultPacketProcessor(false,true,false,false){
    void handle(    Request request){
      doAdd(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_CONTAINS,new DefaultPacketProcessor(true,false,false,false){
    void handle(    Request request){
      doContains(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BLOCK_INFO,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleBlockInfo(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BLOCKS,new PacketProcessor(){
    public void process(    Packet packet){
      handleBlocks(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_MIGRATION_COMPLETE,new PacketProcessor(){
    public void process(    Packet packet){
      doMigrationComplete(packet.conn.getEndPoint());
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_MIGRATE_RECORD,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleMigrateRecord(packet);
    }
  }
);
}",0.9785092955824664
50678,"public void getEntries(Request request){
  Collection<Record> colRecords=mapRecords.values();
  Pairs pairs=new Pairs();
  long now=System.currentTimeMillis();
  for (  Record record : colRecords) {
    if (record.isValid(now)) {
      Block block=blocks[record.blockId];
      if (thisAddress.equals(block.owner)) {
        if (record.value != null) {
          pairs.addKeyValue(new KeyValue(record.key,null));
        }
 else         if (record.copyCount > 0) {
          for (int i=0; i < record.copyCount; i++) {
            pairs.addKeyValue(new KeyValue(record.key,null));
          }
        }
 else         if (record.lsValues != null) {
          int size=record.lsValues.size();
          if (size > 0) {
            if (request.operation == OP_CMAP_ITERATE_KEYS) {
              pairs.addKeyValue(new KeyValue(record.key,null));
            }
 else {
              for (int i=0; i < size; i++) {
                Data value=record.lsValues.get(i);
                pairs.addKeyValue(new KeyValue(record.key,null));
              }
            }
          }
        }
      }
    }
 else {
      if (!record.isEvictable()) {
        scheduleForEviction(record);
      }
    }
  }
  Data dataEntries=toData(pairs);
  request.longValue=pairs.size();
  request.response=dataEntries;
}","public void getEntries(Request request){
  Collection<Record> colRecords=mapRecords.values();
  Pairs pairs=new Pairs();
  long now=System.currentTimeMillis();
  for (  Record record : colRecords) {
    if (record.isValid(now)) {
      Block block=blocks[record.blockId];
      if (thisAddress.equals(block.owner)) {
        if (record.value != null) {
          pairs.addKeyValue(new KeyValue(record.key,null));
        }
 else         if (record.copyCount > 0) {
          for (int i=0; i < record.copyCount; i++) {
            pairs.addKeyValue(new KeyValue(record.key,null));
          }
        }
 else         if (record.lsValues != null) {
          int size=record.lsValues.size();
          if (size > 0) {
            if (request.operation == OP_CMAP_ITERATE_VALUES) {
              for (int i=0; i < size; i++) {
                Data value=record.lsValues.get(i);
                pairs.addKeyValue(new KeyValue(record.key,value));
              }
            }
 else {
              pairs.addKeyValue(new KeyValue(record.key,null));
            }
          }
        }
      }
    }
 else {
      if (!record.isEvictable()) {
        scheduleForEviction(record);
      }
    }
  }
  Data dataEntries=toData(pairs);
  request.longValue=pairs.size();
  request.response=dataEntries;
}",0.9128919860627178
50679,"public boolean removeItem(Request req){
  Record record=mapRecords.get(req.key);
  req.key.setNoData();
  req.key=null;
  if (record == null) {
    return false;
  }
  boolean removed=false;
  if (record.getCopyCount() > 0) {
    record.decrementCopyCount();
    removed=true;
  }
 else   if (record.value != null) {
    removed=true;
  }
  if (removed) {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_REMOVED,record);
    record.version++;
    if (record.value != null) {
      record.value.setNoData();
      record.value=null;
    }
  }
  req.version=record.version;
  req.longValue=record.copyCount;
  if (record.isRemovable()) {
    removeRecord(record.key);
    record.key.setNoData();
    record.key=null;
  }
  return true;
}","public boolean removeItem(Request req){
  Record record=mapRecords.get(req.key);
  req.key.setNoData();
  req.key=null;
  if (record == null) {
    return false;
  }
  boolean removed=false;
  if (record.getCopyCount() > 0) {
    record.decrementCopyCount();
    removed=true;
  }
 else   if (record.value != null) {
    removed=true;
  }
 else   if (record.lsValues != null) {
    removed=true;
  }
  if (removed) {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_REMOVED,record);
    record.version++;
    if (record.value != null) {
      record.value.setNoData();
      record.value=null;
    }
 else     if (record.lsValues != null) {
      for (      Data v : record.lsValues) {
        v.setNoData();
      }
      record.lsValues=null;
    }
  }
  req.version=record.version;
  req.longValue=record.copyCount;
  if (record.isRemovable()) {
    removeRecord(record.key);
    record.key.setNoData();
    record.key=null;
  }
  return true;
}",0.8744075829383886
50680,"public static int copy(ByteBuffer src,ByteBuffer dest){
  int n=Math.min(src.remaining(),dest.remaining());
  int srcPosition=src.position();
  int destPosition=dest.position();
  int ixSrc=srcPosition + src.arrayOffset();
  int ixDest=destPosition + dest.arrayOffset();
  System.arraycopy(src.array(),ixSrc,dest.array(),ixDest,n);
  src.position(srcPosition + n);
  dest.position(destPosition + n);
  return n;
}","public static int copy(ByteBuffer src,ByteBuffer dest){
  int n=Math.min(src.remaining(),dest.remaining());
  if (n > 0) {
    int srcPosition=src.position();
    int destPosition=dest.position();
    int ixSrc=srcPosition + src.arrayOffset();
    int ixDest=destPosition + dest.arrayOffset();
    System.arraycopy(src.array(),ixSrc,dest.array(),ixDest,n);
    src.position(srcPosition + n);
    dest.position(destPosition + n);
  }
  return n;
}",0.9615832363213038
50681,"public void reset(){
  name=null;
  operation=-1;
  threadId=-1;
  lockCount=0;
  lockAddress=null;
  timeout=-1;
  txnId=-1;
  responseType=Constants.ResponseTypes.RESPONSE_NONE;
  local=true;
  currentCallCount=0;
  blockId=-1;
  longValue=Long.MIN_VALUE;
  recordId=-1;
  version=-1;
  callId=-1;
  bbSizes.clear();
  bbHeader.clear();
  key.setNoData();
  value.setNoData();
  conn=null;
  totalSize=0;
}","public void reset(){
  name=null;
  operation=-1;
  threadId=-1;
  lockCount=0;
  lockAddress=null;
  timeout=-1;
  txnId=-1;
  responseType=Constants.ResponseTypes.RESPONSE_NONE;
  local=true;
  currentCallCount=0;
  blockId=-1;
  longValue=Long.MIN_VALUE;
  recordId=-1;
  version=-1;
  callId=-1;
  bbSizes.clear();
  bbHeader.clear();
  key.setNoData();
  value.setNoData();
  conn=null;
  totalSize=0;
  totalWritten=0;
}",0.9784172661870504
50682,"public ReadHandler(final Connection connection){
  super(connection);
  inBuffer=ByteBuffer.allocate(32 * 1024);
}","public ReadHandler(final Connection connection){
  super(connection);
}",0.7675675675675676
50683,"public final void handle(){
  if (!connection.live())   return;
  try {
    final int readBytes=socketChannel.read(inBuffer);
    if (readBytes == -1) {
      connection.close();
      return;
    }
    if (readBytes <= 0) {
      return;
    }
  }
 catch (  final Exception e) {
    if (packet != null) {
      packet.returnToContainer();
      packet=null;
    }
    handleSocketException(e);
    return;
  }
  try {
    inBuffer.flip();
    while (true) {
      final int remaining=inBuffer.remaining();
      if (remaining <= 0) {
        inBuffer.clear();
        return;
      }
      if (packet == null) {
        if (remaining >= 12) {
          packet=obtainReadable();
          if (packet == null) {
            throw new RuntimeException(messageRead + ""String_Node_Str"" + connection.getEndPoint());
          }
        }
 else {
          inBuffer.compact();
          return;
        }
      }
      final boolean full=packet.read(inBuffer);
      if (full) {
        if (readCount++ % 10000 == 0) {
          logger.log(Level.FINEST,""String_Node_Str"" + readCount);
          readCount=1;
        }
        messageRead++;
        packet.flipBuffers();
        packet.read();
        packet.setFromConnection(connection);
        ClusterService.get().enqueueAndReturn(packet);
        packet=null;
      }
 else {
        if (inBuffer.hasRemaining()) {
          if (DEBUG) {
            throw new RuntimeException(""String_Node_Str"" + inBuffer.remaining());
          }
        }
      }
    }
  }
 catch (  final Throwable t) {
    logger.log(Level.SEVERE,""String_Node_Str"" + connection.getEndPoint(),t);
  }
 finally {
    registerOp(inSelector.selector,SelectionKey.OP_READ);
  }
}","public final void handle(){
  if (!connection.live())   return;
  try {
    final int readBytes=socketChannel.read(inBuffer);
    if (readBytes == -1) {
      connection.close();
      return;
    }
    if (readBytes <= 0) {
      return;
    }
  }
 catch (  final Exception e) {
    if (packet != null) {
      packet.returnToContainer();
      packet=null;
    }
    handleSocketException(e);
    return;
  }
  try {
    inBuffer.flip();
    while (true) {
      final int remaining=inBuffer.remaining();
      if (remaining <= 0) {
        inBuffer.clear();
        return;
      }
      if (packet == null) {
        if (remaining >= 12) {
          packet=obtainReadable();
          if (packet == null) {
            throw new RuntimeException(""String_Node_Str"" + connection.getEndPoint());
          }
        }
 else {
          inBuffer.compact();
          return;
        }
      }
      final boolean full=packet.read(inBuffer);
      if (full) {
        packet.flipBuffers();
        packet.read();
        packet.setFromConnection(connection);
        ClusterService.get().enqueueAndReturn(packet);
        packet=null;
      }
 else {
        if (inBuffer.hasRemaining()) {
          if (DEBUG) {
            throw new RuntimeException(""String_Node_Str"" + inBuffer.remaining());
          }
        }
      }
    }
  }
 catch (  final Throwable t) {
    logger.log(Level.SEVERE,""String_Node_Str"" + connection.getEndPoint(),t);
  }
 finally {
    registerOp(inSelector.selector,SelectionKey.OP_READ);
  }
}",0.945273631840796
50684,"public void handle(){
  if (writeCount++ % 10000 == 0) {
    logger.log(Level.FINEST,""String_Node_Str"" + writeCount);
    writeCount=1;
  }
  if (writeQueue.size() == 0) {
    ready=true;
    return;
  }
  if (!connection.live())   return;
  try {
    bbOut.clear();
    copyLoop:     while (bbOut.position() < (32 * 1024)) {
      final PacketQueue.Packet packet=(PacketQueue.Packet)writeQueue.poll();
      if (packet == null)       break copyLoop;
      packet.write(bbOut);
      packet.returnToContainer();
    }
    if (bbOut.position() == 0)     return;
    bbOut.flip();
    int remaining=bbOut.remaining();
    int loopCount=0;
    while (remaining > 0) {
      try {
        final int written=socketChannel.write(bbOut);
        remaining-=written;
        loopCount++;
        if (DEBUG) {
          if (loopCount > 1) {
            logger.log(Level.FINEST,""String_Node_Str"" + loopCount);
          }
        }
      }
 catch (      final Exception e) {
        handleSocketException(e);
        return;
      }
    }
  }
 catch (  final Throwable t) {
    logger.log(Level.SEVERE,""String_Node_Str"" + connection.getEndPoint(),t);
  }
 finally {
    ready=false;
    registerWrite();
  }
}","public void handle(){
  if (lastPacket == null && writeQueue.size() == 0) {
    ready=true;
    return;
  }
  if (!connection.live())   return;
  try {
    loop:     while (socketBB.hasRemaining()) {
      if (lastPacket == null) {
        lastPacket=(Packet)writeQueue.poll();
      }
      if (lastPacket != null) {
        boolean packetDone=lastPacket.doWrite(socketBB);
        if (packetDone) {
          lastPacket.returnToContainer();
          lastPacket=null;
        }
      }
 else       break loop;
    }
    socketBB.flip();
    try {
      socketChannel.write(socketBB);
    }
 catch (    final Exception e) {
      if (lastPacket != null) {
        lastPacket.returnToContainer();
        lastPacket=null;
      }
      handleSocketException(e);
      return;
    }
    if (socketBB.hasRemaining()) {
      socketBB.compact();
    }
 else {
      socketBB.clear();
    }
  }
 catch (  final Throwable t) {
    logger.log(Level.SEVERE,""String_Node_Str"" + connection.getEndPoint(),t);
  }
 finally {
    ready=false;
    registerWrite();
  }
}",0.3820921985815603
50685,"private BlockingQueueManager(){
  ClusterService.get().registerPacketProcessor(OP_B_POLL,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handlePoll(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_OFFER,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleOffer(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_BACKUP_ADD,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleBackup(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_BACKUP_REMOVE,new PacketProcessor(){
    public void process(    Packet packet){
      handleBackup(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_PUBLISH,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handlePublish(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_ADD_TOPIC_LISTENER,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleAddTopicListener(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_SIZE,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleSize(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_PEEK,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handlePoll(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_READ,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleRead(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_REMOVE,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleRemove(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_TXN_BACKUP_POLL,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleTxnBackupPoll(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_TXN_COMMIT,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleTxnCommit(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_ADD_BLOCK,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleAddBlock(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_REMOVE_BLOCK,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleRemoveBlock(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_FULL_BLOCK,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleFullBlock(packet);
    }
  }
);
}","private BlockingQueueManager(){
  ClusterService.get().registerPacketProcessor(OP_B_POLL,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      try {
        handlePoll(packet);
      }
 catch (      Throwable t) {
        Request req=new Request();
        req.setFromPacket(packet);
        printState(req,false,packet.conn.getEndPoint(),1);
        t.printStackTrace();
      }
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_OFFER,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleOffer(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_BACKUP_ADD,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleBackup(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_BACKUP_REMOVE,new PacketProcessor(){
    public void process(    Packet packet){
      handleBackup(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_PUBLISH,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handlePublish(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_ADD_TOPIC_LISTENER,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleAddTopicListener(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_SIZE,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleSize(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_PEEK,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handlePoll(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_READ,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleRead(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_REMOVE,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleRemove(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_TXN_BACKUP_POLL,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleTxnBackupPoll(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_TXN_COMMIT,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleTxnCommit(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_ADD_BLOCK,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleAddBlock(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_REMOVE_BLOCK,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleRemoveBlock(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_B_FULL_BLOCK,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleFullBlock(packet);
    }
  }
);
}",0.962293657688966
50686,"int offer(Request req){
  int addIndex=blCurrentPut.add(req.value);
  try {
    long recordId=getRecordId(blCurrentPut.blockId,addIndex);
    req.recordId=recordId;
    doFireEntryEvent(true,req.value,recordId);
    size++;
    while (lsScheduledPollActions.size() > 0) {
      ScheduledAction pollAction=lsScheduledPollActions.remove(0);
      ClusterManager.get().deregisterScheduledAction(pollAction);
      if (pollAction.expired()) {
        pollAction.onExpire();
      }
 else {
        boolean consumed=pollAction.consume();
        if (consumed)         return -1;
      }
    }
    sendBackup(true,req.caller,req.value,blCurrentPut.blockId,addIndex);
  }
  finally {
    req.longValue=addIndex;
    if (blCurrentPut.isFull()) {
      fireBlockFullEvent(blCurrentPut);
      blCurrentPut=null;
      setCurrentPut();
    }
  }
  return addIndex;
}","int offer(Request req){
  try {
    int addIndex=blCurrentPut.add(req.value);
    long recordId=getRecordId(blCurrentPut.blockId,addIndex);
    req.recordId=recordId;
    doFireEntryEvent(true,req.value,recordId);
    size++;
    sendBackup(true,req.caller,req.value,blCurrentPut.blockId,addIndex);
    req.longValue=addIndex;
    if (blCurrentPut.isFull()) {
      fireBlockFullEvent(blCurrentPut);
      blCurrentPut=null;
      setCurrentPut();
    }
    return addIndex;
  }
  finally {
    boolean consumed=false;
    while (!consumed && lsScheduledPollActions.size() > 0) {
      ScheduledAction pollAction=lsScheduledPollActions.remove(0);
      ClusterManager.get().deregisterScheduledAction(pollAction);
      if (pollAction.expired()) {
        pollAction.onExpire();
      }
 else {
        consumed=pollAction.consume();
      }
    }
  }
}",0.6276346604215457
50687,"public void sendAddBlockMessageToOthers(Block block,int fullBlockId,Address except,boolean add){
  int operation=OP_B_ADD_BLOCK;
  if (!add) {
    operation=OP_B_REMOVE_BLOCK;
  }
  if (lsMembers.size() > 1) {
    int addBlockId=-1;
    int removeBlockId=-1;
    Address addAddress=null;
    if (add) {
      addBlockId=block.blockId;
      addAddress=block.address;
      except=null;
    }
 else {
      removeBlockId=block.blockId;
    }
    BlockUpdate addRemove=new BlockUpdate(addAddress,addBlockId,fullBlockId,removeBlockId);
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember()) {
        Address dest=member.getAddress();
        if (!dest.equals(except)) {
          send(block.name,operation,addRemove,dest);
        }
      }
    }
  }
}","public void sendAddBlockMessageToOthers(String name,Address addAddress,int blockId,int fullBlockId,Address except,boolean add){
  int operation=OP_B_ADD_BLOCK;
  if (!add) {
    operation=OP_B_REMOVE_BLOCK;
  }
  if (lsMembers.size() > 1) {
    int addBlockId=-1;
    int removeBlockId=-1;
    if (add) {
      addBlockId=blockId;
      except=null;
    }
 else {
      removeBlockId=blockId;
    }
    BlockUpdate addRemove=new BlockUpdate(addAddress,addBlockId,fullBlockId,removeBlockId);
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember()) {
        Address dest=member.getAddress();
        if (!dest.equals(except)) {
          send(name,operation,addRemove,dest);
        }
      }
    }
  }
}",0.8373333333333334
50688,"public void doRemoveBlock(Q q,Address originalRemover,int blockId){
  Block blockRemoved=q.removeBlock(blockId);
  if (blockRemoved != null) {
    if (isMaster()) {
      sendAddBlockMessageToOthers(blockRemoved,-1,originalRemover,false);
    }
  }
}","public void doRemoveBlock(Q q,Address originalRemover,int blockId){
  Block blockRemoved=q.removeBlock(blockId);
  if (isMaster()) {
    sendAddBlockMessageToOthers(q.name,null,blockId,-1,originalRemover,false);
  }
}",0.8094218415417559
50689,"public Data poll(Request request){
  setCurrentTake();
  Data value=blCurrentTake.remove();
  if (request.txnId != -1) {
    MemberImpl backup=null;
    if (request.caller.equals(thisAddress)) {
      backup=getNextMemberAfter(thisAddress,true,1);
    }
 else {
      backup=getNextMemberAfter(request.caller,true,1);
    }
    if (backup != null) {
      if (backup.getAddress().equals(thisAddress)) {
        doTxnBackupPoll(request.txnId,value);
      }
 else {
        sendTxnBackup(backup.getAddress(),value,request.txnId);
      }
    }
  }
  size--;
  long recordId=getRecordId(blCurrentTake.blockId,blCurrentTake.removeIndex);
  request.recordId=recordId;
  doFireEntryEvent(false,value,recordId);
  runScheduledOffer:   while (lsScheduledOfferActions.size() > 0) {
    ScheduledOfferAction offerAction=lsScheduledOfferActions.remove(0);
    ClusterManager.get().deregisterScheduledAction(offerAction);
    if (offerAction.expired()) {
      offerAction.onExpire();
    }
 else {
      boolean consumed=offerAction.consume();
      if (consumed) {
        break runScheduledOffer;
      }
    }
  }
  sendBackup(false,request.caller,null,blCurrentTake.blockId,0);
  if (blCurrentTake.size() == 0 && blCurrentTake.isFull()) {
    fireBlockRemoveEvent(blCurrentTake);
    blCurrentTake=null;
  }
  return value;
}","public Data poll(Request request){
  try {
    setCurrentTake();
    Data value=blCurrentTake.remove();
    if (request.txnId != -1) {
      MemberImpl backup=null;
      if (request.caller.equals(thisAddress)) {
        backup=getNextMemberAfter(thisAddress,true,1);
      }
 else {
        backup=getNextMemberAfter(request.caller,true,1);
      }
      if (backup != null) {
        if (backup.getAddress().equals(thisAddress)) {
          doTxnBackupPoll(request.txnId,value);
        }
 else {
          sendTxnBackup(backup.getAddress(),value,request.txnId);
        }
      }
    }
    size--;
    long recordId=getRecordId(blCurrentTake.blockId,blCurrentTake.removeIndex);
    request.recordId=recordId;
    doFireEntryEvent(false,value,recordId);
    sendBackup(false,request.caller,null,blCurrentTake.blockId,0);
    if (blCurrentTake.size() == 0 && blCurrentTake.isFull()) {
      fireBlockRemoveEvent(blCurrentTake);
      blCurrentTake=null;
    }
    return value;
  }
  finally {
    boolean consumed=false;
    while (!consumed && lsScheduledOfferActions.size() > 0) {
      ScheduledOfferAction offerAction=lsScheduledOfferActions.remove(0);
      ClusterManager.get().deregisterScheduledAction(offerAction);
      if (offerAction.expired()) {
        offerAction.onExpire();
      }
 else {
        consumed=offerAction.consume();
      }
    }
  }
}",0.7651656122069223
50690,"public Block removeBlock(int blockId){
  int size=lsBlocks.size();
  for (int i=0; i < size; i++) {
    Block b=lsBlocks.get(i);
    if (b.blockId == blockId) {
      blCurrentTake=null;
      return lsBlocks.remove(i);
    }
  }
  return null;
}","public Block removeBlock(int blockId){
  try {
    if (blCurrentPut != null && blCurrentPut.blockId == blockId) {
      blCurrentPut=null;
    }
    if (blCurrentTake != null && blCurrentTake.blockId == blockId) {
      blCurrentTake=null;
    }
    int size=lsBlocks.size();
    for (int i=0; i < size; i++) {
      Block b=lsBlocks.get(i);
      if (b.blockId == blockId) {
        blCurrentTake=null;
        return lsBlocks.remove(i);
      }
    }
    return null;
  }
  finally {
    if (blCurrentPut == null) {
      setCurrentPut();
    }
  }
}",0.5614035087719298
50691,"public void setBlockFull(int fullBlockId){
  int size=lsBlocks.size();
  for (int i=0; i < size; i++) {
    Block block=lsBlocks.get(i);
    if (block.blockId == fullBlockId) {
      block.setFull(true);
      blCurrentPut=null;
      return;
    }
  }
}","public void setBlockFull(int fullBlockId){
  if (blCurrentPut != null && blCurrentPut.blockId == fullBlockId) {
    blCurrentPut.setFull(true);
    blCurrentPut=null;
  }
  if (blCurrentTake != null && blCurrentTake.blockId == fullBlockId) {
    blCurrentTake.setFull(true);
  }
  int size=lsBlocks.size();
  for (int i=0; i < size; i++) {
    Block block=lsBlocks.get(i);
    if (block.blockId == fullBlockId) {
      block.setFull(true);
      blCurrentPut=null;
      return;
    }
  }
}",0.6827956989247311
50692,"public EventTask(final int eventType,final String name,final Data dataKey,final Data dataValue){
  super(name);
  this.eventType=eventType;
  this.dataValue=dataValue;
  this.dataKey=dataKey;
}","public EventTask(final int eventType,final String name,final Data dataKey,final Data dataValue){
  super(name);
  this.eventType=eventType;
  this.dataKey=dataKey;
  this.dataValue=dataValue;
}",0.8756476683937824
50693,"public void run(){
  try {
    if (!collection) {
      key=ThreadContext.get().toObject(dataKey);
    }
    if (dataValue != null) {
      value=ThreadContext.get().toObject(dataValue);
    }
    ListenerManager.get().callListeners(this);
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
}","public void run(){
  try {
    if (dataKey != null) {
      key=toObject(dataKey);
    }
    if (dataValue != null) {
      value=toObject(dataValue);
    }
 else     if (collection) {
      value=key;
    }
    ListenerManager.get().callListeners(this);
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
}",0.816
50694,"public void sendEvents(final int eventType,final String name,final Data key,final Data value,final Map<Address,Boolean> mapListeners){
  if (mapListeners != null) {
    final PacketQueue sq=PacketQueue.get();
    final Set<Map.Entry<Address,Boolean>> entries=mapListeners.entrySet();
    for (    final Map.Entry<Address,Boolean> entry : entries) {
      final Address address=entry.getKey();
      final boolean includeValue=entry.getValue();
      if (address.isThisAddress()) {
        try {
          final Data eventKey=(key != null) ? ThreadContext.get().hardCopy(key) : null;
          Data eventValue=null;
          if (includeValue)           eventValue=ThreadContext.get().hardCopy(value);
          enqueueEvent(eventType,name,eventKey,eventValue,address);
        }
 catch (        final Exception e) {
          e.printStackTrace();
        }
      }
 else {
        final PacketQueue.Packet packet=sq.obtainPacket();
        packet.reset();
        try {
          final Data eventKey=key;
          Data eventValue=null;
          if (includeValue)           eventValue=value;
          packet.set(name,OP_EVENT,eventKey,eventValue);
          packet.longValue=eventType;
        }
 catch (        final Exception e) {
          e.printStackTrace();
        }
        final boolean sent=send(packet,address);
        if (!sent)         packet.returnToContainer();
      }
    }
  }
}","public void sendEvents(final int eventType,final String name,final Data key,final Data value,final Map<Address,Boolean> mapListeners){
  if (mapListeners != null) {
    final PacketQueue sq=PacketQueue.get();
    final Set<Map.Entry<Address,Boolean>> listeners=mapListeners.entrySet();
    for (    final Map.Entry<Address,Boolean> listener : listeners) {
      final Address address=listener.getKey();
      final boolean includeValue=listener.getValue();
      if (address.isThisAddress()) {
        try {
          enqueueEvent(eventType,name,doHardCopy(key),(includeValue) ? doHardCopy(value) : null,address);
        }
 catch (        final Exception e) {
          e.printStackTrace();
        }
      }
 else {
        final PacketQueue.Packet packet=sq.obtainPacket();
        packet.reset();
        try {
          packet.set(name,OP_EVENT,key,(includeValue) ? value : null);
          packet.longValue=eventType;
        }
 catch (        final Exception e) {
          e.printStackTrace();
        }
        final boolean sent=send(packet,address);
        if (!sent)         packet.returnToContainer();
      }
    }
  }
}",0.7947908445146015
50695,"int offer(Request req){
  try {
    int addIndex=blCurrentPut.add(req.value);
    long recordId=getRecordId(blCurrentPut.blockId,addIndex);
    req.recordId=recordId;
    doFireEntryEvent(true,req.value,recordId);
    sendBackup(true,req.caller,req.value,blCurrentPut.blockId,addIndex);
    req.longValue=addIndex;
    if (blCurrentPut.isFull()) {
      fireBlockFullEvent(blCurrentPut);
      blCurrentPut=null;
      setCurrentPut();
    }
    return addIndex;
  }
  finally {
    boolean consumed=false;
    while (!consumed && lsScheduledPollActions.size() > 0) {
      ScheduledAction pollAction=lsScheduledPollActions.remove(0);
      ClusterManager.get().deregisterScheduledAction(pollAction);
      if (pollAction.expired()) {
        pollAction.onExpire();
      }
 else {
        consumed=pollAction.consume();
      }
    }
  }
}","int offer(Request req){
  try {
    int addIndex=blCurrentPut.add(req.value);
    long recordId=getRecordId(blCurrentPut.blockId,addIndex);
    req.recordId=recordId;
    doFireEntryEvent(true,req.value);
    sendBackup(true,req.caller,req.value,blCurrentPut.blockId,addIndex);
    req.longValue=addIndex;
    if (blCurrentPut.isFull()) {
      fireBlockFullEvent(blCurrentPut);
      blCurrentPut=null;
      setCurrentPut();
    }
    return addIndex;
  }
  finally {
    boolean consumed=false;
    while (!consumed && lsScheduledPollActions.size() > 0) {
      ScheduledAction pollAction=lsScheduledPollActions.remove(0);
      ClusterManager.get().deregisterScheduledAction(pollAction);
      if (pollAction.expired()) {
        pollAction.onExpire();
      }
 else {
        consumed=pollAction.consume();
      }
    }
  }
}",0.9946140035906644
50696,"public Data poll(Request request){
  try {
    setCurrentTake();
    Data value=blCurrentTake.remove();
    if (request.txnId != -1) {
      MemberImpl backup=null;
      if (request.caller.equals(thisAddress)) {
        backup=getNextMemberAfter(thisAddress,true,1);
      }
 else {
        backup=getNextMemberAfter(request.caller,true,1);
      }
      if (backup != null) {
        if (backup.getAddress().equals(thisAddress)) {
          doTxnBackupPoll(request.txnId,value);
        }
 else {
          sendTxnBackup(backup.getAddress(),value,request.txnId);
        }
      }
    }
    long recordId=getRecordId(blCurrentTake.blockId,blCurrentTake.removeIndex);
    request.recordId=recordId;
    doFireEntryEvent(false,value,recordId);
    sendBackup(false,request.caller,null,blCurrentTake.blockId,0);
    if (!blCurrentTake.containsValidItem() && blCurrentTake.isFull()) {
      fireBlockRemoveEvent(blCurrentTake);
      blCurrentTake=null;
    }
    return value;
  }
  finally {
    boolean consumed=false;
    while (!consumed && lsScheduledOfferActions.size() > 0) {
      ScheduledOfferAction offerAction=lsScheduledOfferActions.remove(0);
      ClusterManager.get().deregisterScheduledAction(offerAction);
      if (offerAction.expired()) {
        offerAction.onExpire();
      }
 else {
        consumed=offerAction.consume();
      }
    }
  }
}","public Data poll(Request request){
  try {
    setCurrentTake();
    Data value=blCurrentTake.remove();
    if (request.txnId != -1) {
      MemberImpl backup=null;
      if (request.caller.equals(thisAddress)) {
        backup=getNextMemberAfter(thisAddress,true,1);
      }
 else {
        backup=getNextMemberAfter(request.caller,true,1);
      }
      if (backup != null) {
        if (backup.getAddress().equals(thisAddress)) {
          doTxnBackupPoll(request.txnId,value);
        }
 else {
          sendTxnBackup(backup.getAddress(),value,request.txnId);
        }
      }
    }
    request.recordId=getRecordId(blCurrentTake.blockId,blCurrentTake.removeIndex);
    doFireEntryEvent(false,value);
    sendBackup(false,request.caller,null,blCurrentTake.blockId,0);
    if (!blCurrentTake.containsValidItem() && blCurrentTake.isFull()) {
      fireBlockRemoveEvent(blCurrentTake);
      blCurrentTake=null;
    }
    return value;
  }
  finally {
    boolean consumed=false;
    while (!consumed && lsScheduledOfferActions.size() > 0) {
      ScheduledOfferAction offerAction=lsScheduledOfferActions.remove(0);
      ClusterManager.get().deregisterScheduledAction(offerAction);
      if (offerAction.expired()) {
        offerAction.onExpire();
      }
 else {
        consumed=offerAction.consume();
      }
    }
  }
}",0.9803193464537692
50697,"void doFireEntryEvent(boolean add,Data value,long recordId){
  if (mapListeners.size() == 0)   return;
  if (add) {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,value);
  }
 else {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_REMOVED,value);
  }
}","void doFireEntryEvent(boolean add,Data value){
  if (mapListeners.size() == 0)   return;
  if (add) {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,value);
  }
 else {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_REMOVED,value);
  }
}",0.9728682170542636
50698,"public void set(String name,int operation,Object objKey,Object objValue) throws Exception {
  this.threadId=Thread.currentThread().hashCode();
  this.name=name;
  this.operation=operation;
  if (objValue != null) {
    value=ThreadContext.get().toData(objValue);
  }
  if (objKey != null) {
    key=ThreadContext.get().toData(objKey);
  }
}","public void set(String name,int operation,Object objKey,Object objValue) throws Exception {
  this.threadId=Thread.currentThread().hashCode();
  this.name=name;
  this.operation=operation;
  if (objKey != null) {
    key=ThreadContext.get().toData(objKey);
  }
  if (objValue != null) {
    value=ThreadContext.get().toData(objValue);
  }
}",0.788235294117647
50699,"public void syncForDead(Address deadAddress){
  Collection<Block> blocks=mapBlocks.values();
  for (  Block block : blocks) {
    if (deadAddress.equals(block.owner)) {
      MemberImpl member=getNextMemberBeforeSync(block.owner,true,1);
      block.owner=(member == null) ? thisAddress : member.getAddress();
    }
    if (block.migrationAddress != null) {
      if (deadAddress.equals(block.migrationAddress)) {
        MemberImpl member=getNextMemberBeforeSync(block.migrationAddress,true,1);
        block.migrationAddress=(member == null) ? thisAddress : member.getAddress();
      }
    }
  }
  Collection<CMap> cmaps=maps.values();
  for (  CMap map : cmaps) {
    Collection<Record> records=map.mapRecords.values();
    for (    Record record : records) {
      record.onDisconnect(deadAddress);
    }
  }
  doResetRecords();
}","public void syncForDead(Address deadAddress){
  Collection<Block> blocks=mapBlocks.values();
  for (  Block block : blocks) {
    if (deadAddress.equals(block.owner)) {
      MemberImpl member=getNextMemberBeforeSync(block.owner,true,1);
      block.owner=(member == null) ? thisAddress : member.getAddress();
    }
    if (block.migrationAddress != null) {
      if (deadAddress.equals(block.migrationAddress)) {
        MemberImpl member=getNextMemberBeforeSync(block.migrationAddress,true,1);
        block.migrationAddress=(member == null) ? thisAddress : member.getAddress();
      }
    }
  }
  Collection<CMap> cmaps=maps.values();
  for (  CMap map : cmaps) {
    Collection<Record> records=map.mapRecords.values();
    for (    Record record : records) {
      record.onDisconnect(deadAddress);
    }
  }
  doResetRecords(deadAddress);
}",0.9934562760261748
50700,"public boolean backup(Request req){
  Record record=getRecord(req.key);
  if (record != null) {
    if (req.version > record.version + 1) {
      Request reqCopy=new Request();
      reqCopy.setFromRequest(req,false);
      req.key=null;
      req.value=null;
      record.addBackupOp(new VersionedBackupOp(reqCopy));
      return true;
    }
 else     if (req.version <= record.version) {
      return false;
    }
  }
  doBackup(req);
  if (record != null) {
    record.version=req.version;
    record.runBackupOps();
  }
  return true;
}","public boolean backup(Request req){
  Record record=getRecord(req.key);
  if (record != null) {
    if (req.version > record.version + 1) {
      Request reqCopy=new Request();
      reqCopy.setFromRequest(req,true);
      req.key=null;
      req.value=null;
      record.addBackupOp(new VersionedBackupOp(reqCopy));
      return true;
    }
 else     if (req.version <= record.version) {
      return false;
    }
  }
  doBackup(req);
  if (record != null) {
    record.version=req.version;
    record.runBackupOps();
  }
  return true;
}",0.4170528266913809
50701,"Address getTarget(String name,Data key){
  int blockId=getBlockId(key);
  Block block=mapBlocks.get(blockId);
  if (block == null) {
    if (isMaster() && !isSuperClient()) {
      block=getOrCreateBlock(blockId);
      block.owner=thisAddress;
    }
 else     return null;
  }
  if (block.isMigrating())   return null;
  if (block.owner == null)   return null;
  if (block.owner.equals(thisAddress)) {
    if (block.isMigrating()) {
      if (name == null)       return block.migrationAddress;
      CMap map=getMap(name);
      Record record=map.getRecord(key);
      if (record == null)       return block.migrationAddress;
 else {
        Address recordOwner=record.getOwner();
        if (recordOwner == null)         return thisAddress;
        if ((!recordOwner.equals(thisAddress)) && (!recordOwner.equals(block.migrationAddress))) {
          record.setOwner(thisAddress);
        }
        return record.getOwner();
      }
    }
  }
 else   if (thisAddress.equals(block.migrationAddress)) {
    if (name == null)     return thisAddress;
    CMap map=getMap(name);
    Record record=map.getRecord(key);
    if (record == null)     return thisAddress;
 else     return record.getOwner();
  }
  return block.owner;
}","Address getTarget(String name,Data key){
  int blockId=getBlockId(key);
  Block block=mapBlocks.get(blockId);
  if (block == null) {
    if (isMaster() && !isSuperClient()) {
      block=getOrCreateBlock(blockId);
      block.owner=thisAddress;
    }
 else     return null;
  }
  if (block.isMigrating())   return null;
  if (block.owner == null)   return null;
  if (block.owner.equals(thisAddress)) {
    if (block.isMigrating()) {
      if (name == null)       return block.migrationAddress;
      CMap map=getMap(name);
      Record record=map.getRecord(key);
      if (record == null)       return block.migrationAddress;
 else {
        Address recordOwner=record.owner;
        if (recordOwner == null)         return thisAddress;
        if ((!recordOwner.equals(thisAddress)) && (!recordOwner.equals(block.migrationAddress))) {
          record.owner=thisAddress;
        }
        return record.owner;
      }
    }
  }
 else   if (thisAddress.equals(block.migrationAddress)) {
    if (name == null)     return thisAddress;
    CMap map=getMap(name);
    Record record=map.getRecord(key);
    if (record == null)     return thisAddress;
 else     return record.owner;
  }
  return block.owner;
}",0.8571428571428571
50702,"void doResetRecords(){
  if (isSuperClient())   return;
  final Object[] records=mapRecordsById.values().toArray();
  mapRecordsById.clear();
  Collection<CMap> cmaps=maps.values();
  for (  CMap cmap : cmaps) {
    cmap.mapRecords.clear();
  }
  for (  Object recObj : records) {
    final Record rec=(Record)recObj;
    rec.forceBackupOps();
    CMap cmap=getMap(rec.name);
    cmap.removeRecord(rec.key);
    executeLocally(new Runnable(){
      public void run(){
        MMigrate mmigrate=new MMigrate();
        mmigrate.migrate(rec);
      }
    }
);
  }
  executeLocally(new Runnable(){
    public void run(){
      Processable processCompletion=new Processable(){
        public void process(){
          doMigrationComplete(thisAddress);
          sendMigrationComplete();
          if (DEBUG) {
            printBlocks();
            logger.log(Level.FINEST,""String_Node_Str"");
          }
        }
      }
;
      enqueueAndReturn(processCompletion);
    }
  }
);
}","void doResetRecords(Address deadAddress){
  if (isSuperClient())   return;
  final Object[] records=mapRecordsById.values().toArray();
  mapRecordsById.clear();
  Collection<CMap> cmaps=maps.values();
  for (  CMap cmap : cmaps) {
    cmap.mapRecords.clear();
  }
  for (  Object recObj : records) {
    final Record rec=(Record)recObj;
    CMap cmap=getMap(rec.name);
    cmap.removeRecord(rec.key);
    boolean shouldMigrate=false;
    if (thisAddress.equals(rec.owner)) {
      shouldMigrate=true;
    }
 else     if (deadAddress != null && deadAddress.equals(rec.owner)) {
      rec.forceBackupOps();
      shouldMigrate=true;
    }
    if (shouldMigrate) {
      executeLocally(new Runnable(){
        public void run(){
          MMigrate mmigrate=new MMigrate();
          mmigrate.migrate(rec);
        }
      }
);
    }
  }
  executeLocally(new Runnable(){
    public void run(){
      Processable processCompletion=new Processable(){
        public void process(){
          doMigrationComplete(thisAddress);
          sendMigrationComplete();
          if (DEBUG) {
            printBlocks();
            logger.log(Level.FINEST,""String_Node_Str"");
          }
        }
      }
;
      enqueueAndReturn(processCompletion);
    }
  }
);
}",0.7064631956912029
50703,"public void addBackupOp(VersionedBackupOp bo){
  if (backupOps == null) {
    backupOps=new TreeSet<VersionedBackupOp>();
  }
  backupOps.add(bo);
  if (backupOps.size() > 5) {
    logger.log(Level.FINEST,id + ""String_Node_Str"" + version);
    forceBackupOps();
  }
}","public void addBackupOp(VersionedBackupOp bo){
  if (backupOps == null) {
    backupOps=new TreeSet<VersionedBackupOp>();
  }
  backupOps.add(bo);
  if (backupOps.size() > 4) {
    logger.log(Level.FINEST,id + ""String_Node_Str"" + version);
    forceBackupOps();
  }
}",0.99625468164794
50704,"public void syncForAdd(){
  if (isMaster()) {
    for (int i=0; i < BLOCK_COUNT; i++) {
      Block block=mapBlocks.get(i);
      if (block == null) {
        getOrCreateBlock(i);
      }
    }
    List<Block> lsBlocksToRedistribute=new ArrayList<Block>();
    Map<Address,Integer> addressBlocks=new HashMap<Address,Integer>();
    int storageEnabledMemberCount=0;
    for (    MemberImpl member : lsMembers) {
      if (!member.isSuperClient()) {
        addressBlocks.put(member.getAddress(),0);
        storageEnabledMemberCount++;
      }
    }
    if (storageEnabledMemberCount == 0)     return;
    int aveBlockOwnCount=mapBlocks.size() / (storageEnabledMemberCount);
    Collection<Block> blocks=mapBlocks.values();
    for (    Block block : blocks) {
      if (block.owner == null) {
        lsBlocksToRedistribute.add(block);
      }
 else {
        if (!block.isMigrating()) {
          Integer countInt=addressBlocks.get(block.owner);
          int count=(countInt == null) ? 0 : countInt;
          if (count >= aveBlockOwnCount) {
            lsBlocksToRedistribute.add(block);
          }
 else {
            count++;
            addressBlocks.put(block.owner,count);
          }
        }
      }
    }
    Set<Address> allAddress=addressBlocks.keySet();
    setNewMembers:     for (    Address address : allAddress) {
      Integer countInt=addressBlocks.get(address);
      int count=(countInt == null) ? 0 : countInt.intValue();
      while (count < aveBlockOwnCount) {
        if (lsBlocksToRedistribute.size() > 0) {
          Block blockToMigrate=lsBlocksToRedistribute.remove(0);
          if (blockToMigrate.owner == null) {
            blockToMigrate.owner=address;
          }
 else {
            blockToMigrate.migrationAddress=address;
            if (blockToMigrate.owner.equals(blockToMigrate.migrationAddress)) {
              blockToMigrate.migrationAddress=null;
            }
          }
          count++;
        }
 else {
          break setNewMembers;
        }
      }
    }
    int addressIndex=0;
    for (int i=0; i < BLOCK_COUNT; i++) {
      Block block=mapBlocks.get(i);
      if (block.owner == null) {
        int index=addressIndex++ % addressBlocks.size();
        block.owner=(Address)addressBlocks.keySet().toArray()[index];
      }
    }
    Data dataAllBlocks=null;
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember()) {
        if (dataAllBlocks == null) {
          Blocks allBlocks=new Blocks();
          Collection<Block> currentBlocks=mapBlocks.values();
          for (          Block block : currentBlocks) {
            allBlocks.addBlock(block);
          }
          dataAllBlocks=ThreadContext.get().toData(allBlocks);
        }
        send(""String_Node_Str"",OP_CMAP_BLOCKS,dataAllBlocks,member.getAddress());
      }
    }
    doResetRecords();
    if (DEBUG) {
      printBlocks();
    }
  }
}","public void syncForAdd(){
  if (isMaster()) {
    for (int i=0; i < BLOCK_COUNT; i++) {
      Block block=mapBlocks.get(i);
      if (block == null) {
        getOrCreateBlock(i);
      }
    }
    List<Block> lsBlocksToRedistribute=new ArrayList<Block>();
    Map<Address,Integer> addressBlocks=new HashMap<Address,Integer>();
    int storageEnabledMemberCount=0;
    for (    MemberImpl member : lsMembers) {
      if (!member.isSuperClient()) {
        addressBlocks.put(member.getAddress(),0);
        storageEnabledMemberCount++;
      }
    }
    if (storageEnabledMemberCount == 0)     return;
    int aveBlockOwnCount=mapBlocks.size() / (storageEnabledMemberCount);
    Collection<Block> blocks=mapBlocks.values();
    for (    Block block : blocks) {
      if (block.owner == null) {
        lsBlocksToRedistribute.add(block);
      }
 else {
        if (!block.isMigrating()) {
          Integer countInt=addressBlocks.get(block.owner);
          int count=(countInt == null) ? 0 : countInt;
          if (count >= aveBlockOwnCount) {
            lsBlocksToRedistribute.add(block);
          }
 else {
            count++;
            addressBlocks.put(block.owner,count);
          }
        }
      }
    }
    Set<Address> allAddress=addressBlocks.keySet();
    setNewMembers:     for (    Address address : allAddress) {
      Integer countInt=addressBlocks.get(address);
      int count=(countInt == null) ? 0 : countInt.intValue();
      while (count < aveBlockOwnCount) {
        if (lsBlocksToRedistribute.size() > 0) {
          Block blockToMigrate=lsBlocksToRedistribute.remove(0);
          if (blockToMigrate.owner == null) {
            blockToMigrate.owner=address;
          }
 else {
            blockToMigrate.migrationAddress=address;
            if (blockToMigrate.owner.equals(blockToMigrate.migrationAddress)) {
              blockToMigrate.migrationAddress=null;
            }
          }
          count++;
        }
 else {
          break setNewMembers;
        }
      }
    }
    int addressIndex=0;
    for (int i=0; i < BLOCK_COUNT; i++) {
      Block block=mapBlocks.get(i);
      if (block.owner == null) {
        int index=addressIndex++ % addressBlocks.size();
        block.owner=(Address)addressBlocks.keySet().toArray()[index];
      }
    }
    Data dataAllBlocks=null;
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember()) {
        if (dataAllBlocks == null) {
          Blocks allBlocks=new Blocks();
          Collection<Block> currentBlocks=mapBlocks.values();
          for (          Block block : currentBlocks) {
            allBlocks.addBlock(block);
          }
          dataAllBlocks=ThreadContext.get().toData(allBlocks);
        }
        send(""String_Node_Str"",OP_CMAP_BLOCKS,dataAllBlocks,member.getAddress());
      }
    }
    doResetRecords(null);
    if (DEBUG) {
      printBlocks();
    }
  }
}",0.9993077189338871
50705,"@Override public void run(){
  logger.log(Level.FINEST,""String_Node_Str"");
  shutdown();
}","@Override public void run(){
  completelyShutdown=true;
  logger.log(Level.FINEST,""String_Node_Str"");
  shutdown();
}",0.8695652173913043
50706,"public void start(){
  firstMainThread=Thread.currentThread();
  clusterImpl=new ClusterImpl();
  final boolean inited=init();
  if (!inited)   return;
  final Thread inThread=new Thread(InSelector.get(),""String_Node_Str"");
  inThread.start();
  inThread.setPriority(8);
  lsThreads.add(inThread);
  final Thread outThread=new Thread(OutSelector.get(),""String_Node_Str"");
  outThread.start();
  outThread.setPriority(8);
  lsThreads.add(outThread);
  final Thread clusterServiceThread=new Thread(ClusterService.get(),""String_Node_Str"");
  clusterServiceThread.start();
  clusterServiceThread.setPriority(7);
  lsThreads.add(clusterServiceThread);
  if (Config.get().join.multicastConfig.enabled) {
    startMulticastService();
  }
  join();
  firstMainThread=null;
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      logger.log(Level.FINEST,""String_Node_Str"");
      shutdown();
    }
  }
);
}","public void start(){
  if (completelyShutdown)   return;
  firstMainThread=Thread.currentThread();
  clusterImpl=new ClusterImpl();
  final boolean inited=init();
  if (!inited)   return;
  final Thread inThread=new Thread(InSelector.get(),""String_Node_Str"");
  inThread.start();
  inThread.setPriority(8);
  lsThreads.add(inThread);
  final Thread outThread=new Thread(OutSelector.get(),""String_Node_Str"");
  outThread.start();
  outThread.setPriority(8);
  lsThreads.add(outThread);
  final Thread clusterServiceThread=new Thread(ClusterService.get(),""String_Node_Str"");
  clusterServiceThread.start();
  clusterServiceThread.setPriority(7);
  lsThreads.add(clusterServiceThread);
  if (Config.get().join.multicastConfig.enabled) {
    startMulticastService();
  }
  join();
  firstMainThread=null;
  if (!completelyShutdown) {
    Runtime.getRuntime().addShutdownHook(new Thread(){
      @Override public void run(){
        completelyShutdown=true;
        logger.log(Level.FINEST,""String_Node_Str"");
        shutdown();
      }
    }
);
  }
}",0.9424242424242424
50707,"/** 
 * See the general contract of the <code>readUTF</code> method of <code>DataInput</code>. <p/> Bytes for this operation are read from the contained input stream.
 * @return a Unicode string.
 * @throws EOFException           if this input stream reaches the end before reading allthe bytes.
 * @throws IOException            if an I/O error occurs.
 * @throws UTFDataFormatException if the bytes do not represent a valid modified UTF-8encoding of a string.
 * @see java.io.DataInputStream#readUTF(java.io.DataInput)
 */
public final String readUTF() throws IOException {
  final int utflen=readUnsignedShort();
  byte[] bytearr=null;
  char[] chararr=null;
  bytearr=new byte[utflen];
  chararr=new char[utflen];
  int c, char2, char3;
  int count=0;
  int chararr_count=0;
  readFully(bytearr,0,utflen);
  while (count < utflen) {
    c=bytearr[count] & 0xff;
    if (c > 127)     break;
    count++;
    chararr[chararr_count++]=(char)c;
  }
  while (count < utflen) {
    c=bytearr[count] & 0xff;
switch (c >> 4) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
      count++;
    chararr[chararr_count++]=(char)c;
  break;
case 12:
case 13:
count+=2;
if (count > utflen) throw new UTFDataFormatException(""String_Node_Str"");
char2=bytearr[count - 1];
if ((char2 & 0xC0) != 0x80) throw new UTFDataFormatException(""String_Node_Str"" + count);
chararr[chararr_count++]=(char)(((c & 0x1F) << 6) | (char2 & 0x3F));
break;
case 14:
count+=3;
if (count > utflen) throw new UTFDataFormatException(""String_Node_Str"");
char2=bytearr[count - 2];
char3=bytearr[count - 1];
if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80)) throw new UTFDataFormatException(""String_Node_Str"" + (count - 1));
chararr[chararr_count++]=(char)(((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));
break;
default :
throw new UTFDataFormatException(""String_Node_Str"" + count);
}
}
return new String(chararr,0,chararr_count);
}","/** 
 * See the general contract of the <code>readUTF</code> method of <code>DataInput</code>. <p/> Bytes for this operation are read from the contained input stream.
 * @return a Unicode string.
 * @throws EOFException           if this input stream reaches the end before reading allthe bytes.
 * @throws IOException            if an I/O error occurs.
 * @throws UTFDataFormatException if the bytes do not represent a valid modified UTF-8encoding of a string.
 * @see java.io.DataInputStream#readUTF(java.io.DataInput)
 */
public final String readUTF() throws IOException {
  final int utflen=readInt();
  byte[] bytearr=null;
  char[] chararr=null;
  bytearr=new byte[utflen];
  chararr=new char[utflen];
  int c, char2, char3;
  int count=0;
  int chararr_count=0;
  readFully(bytearr,0,utflen);
  while (count < utflen) {
    c=bytearr[count] & 0xff;
    if (c > 127)     break;
    count++;
    chararr[chararr_count++]=(char)c;
  }
  while (count < utflen) {
    c=bytearr[count] & 0xff;
switch (c >> 4) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
      count++;
    chararr[chararr_count++]=(char)c;
  break;
case 12:
case 13:
count+=2;
if (count > utflen) throw new UTFDataFormatException(""String_Node_Str"");
char2=bytearr[count - 1];
if ((char2 & 0xC0) != 0x80) throw new UTFDataFormatException(""String_Node_Str"" + count);
chararr[chararr_count++]=(char)(((c & 0x1F) << 6) | (char2 & 0x3F));
break;
case 14:
count+=3;
if (count > utflen) throw new UTFDataFormatException(""String_Node_Str"");
char2=bytearr[count - 2];
char3=bytearr[count - 1];
if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80)) throw new UTFDataFormatException(""String_Node_Str"" + (count - 1));
chararr[chararr_count++]=(char)(((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));
break;
default :
throw new UTFDataFormatException(""String_Node_Str"" + count);
}
}
return new String(chararr,0,chararr_count);
}",0.9963786859803414
50708,"public final void writeUTF(final String str) throws IOException {
  final int strlen=str.length();
  int utflen=0;
  int c, count=0;
  for (int i=0; i < strlen; i++) {
    c=str.charAt(i);
    if ((c >= 0x0001) && (c <= 0x007F)) {
      utflen++;
    }
 else     if (c > 0x07FF) {
      utflen+=3;
    }
 else {
      utflen+=2;
    }
  }
  if (utflen > 65535)   throw new UTFDataFormatException(""String_Node_Str"" + utflen + ""String_Node_Str"");
  final byte[] bytearr=new byte[utflen + 2];
  bytearr[count++]=(byte)((utflen >>> 8) & 0xFF);
  bytearr[count++]=(byte)((utflen >>> 0) & 0xFF);
  int i=0;
  for (i=0; i < strlen; i++) {
    c=str.charAt(i);
    if (!((c >= 0x0001) && (c <= 0x007F)))     break;
    bytearr[count++]=(byte)c;
  }
  for (; i < strlen; i++) {
    c=str.charAt(i);
    if ((c >= 0x0001) && (c <= 0x007F)) {
      bytearr[count++]=(byte)c;
    }
 else     if (c > 0x07FF) {
      bytearr[count++]=(byte)(0xE0 | ((c >> 12) & 0x0F));
      bytearr[count++]=(byte)(0x80 | ((c >> 6) & 0x3F));
      bytearr[count++]=(byte)(0x80 | ((c >> 0) & 0x3F));
    }
 else {
      bytearr[count++]=(byte)(0xC0 | ((c >> 6) & 0x1F));
      bytearr[count++]=(byte)(0x80 | ((c >> 0) & 0x3F));
    }
  }
  write(bytearr,0,utflen + 2);
}","public final void writeUTF(final String str) throws IOException {
  final int strlen=str.length();
  int utflen=0;
  int c, count=0;
  for (int i=0; i < strlen; i++) {
    c=str.charAt(i);
    if ((c >= 0x0001) && (c <= 0x007F)) {
      utflen++;
    }
 else     if (c > 0x07FF) {
      utflen+=3;
    }
 else {
      utflen+=2;
    }
  }
  final byte[] bytearr=new byte[utflen + 4];
  bytearr[count++]=(byte)((utflen >>> 24) & 0xFF);
  bytearr[count++]=(byte)((utflen >>> 16) & 0xFF);
  bytearr[count++]=(byte)((utflen >>> 8) & 0xFF);
  bytearr[count++]=(byte)((utflen >>> 0) & 0xFF);
  int i=0;
  for (i=0; i < strlen; i++) {
    c=str.charAt(i);
    if (!((c >= 0x0001) && (c <= 0x007F)))     break;
    bytearr[count++]=(byte)c;
  }
  for (; i < strlen; i++) {
    c=str.charAt(i);
    if ((c >= 0x0001) && (c <= 0x007F)) {
      bytearr[count++]=(byte)c;
    }
 else     if (c > 0x07FF) {
      bytearr[count++]=(byte)(0xE0 | ((c >> 12) & 0x0F));
      bytearr[count++]=(byte)(0x80 | ((c >> 6) & 0x3F));
      bytearr[count++]=(byte)(0x80 | ((c >> 0) & 0x3F));
    }
 else {
      bytearr[count++]=(byte)(0xC0 | ((c >> 6) & 0x1F));
      bytearr[count++]=(byte)(0x80 | ((c >> 0) & 0x3F));
    }
  }
  write(bytearr,0,utflen + 4);
}",0.9151857835218092
50709,"private ConcurrentMapManager(){
  ClusterService.get().registerPacketProcessor(OP_CMAP_GET,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleGet(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT,new PacketProcessor(){
    public void process(    Packet packet){
      handlePut(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_PUT_SYNC,new PacketProcessor(){
    public void process(    Packet packet){
      handleBackupSync(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_REMOVE_SYNC,new PacketProcessor(){
    public void process(    Packet packet){
      handleBackupSync(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_LOCK_SYNC,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleBackupSync(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT_MULTI,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handlePutMulti(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_ADD,new PacketProcessor(){
    public void process(    Packet packet){
      handleBackupAdd(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleRemove(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE_IF_SAME,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleRemove(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_LOCK,new PacketProcessor(){
    public void process(    Packet packet){
      handleLock(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_LOCK_RETURN_OLD,new PacketProcessor(){
    public void process(    Packet packet){
      handleLock(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_UNLOCK,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleLock(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_READ,new PacketProcessor(){
    public void process(    Packet packet){
      handleRead(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_SIZE,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleSize(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ADD_TO_LIST,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleAdd(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ADD_TO_SET,new PacketProcessor(){
    public void process(    Packet packet){
      handleAdd(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_CONTAINS,new PacketProcessor(){
    public void process(    Packet packet){
      handleContains(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BLOCK_INFO,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleBlockInfo(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BLOCKS,new PacketProcessor(){
    public void process(    Packet packet){
      handleBlocks(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT_IF_ABSENT,new PacketProcessor(){
    public void process(    Packet packet){
      handlePut(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REPLACE_IF_NOT_NULL,new PacketProcessor(){
    public void process(    Packet packet){
      handlePut(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_MIGRATION_COMPLETE,new PacketProcessor(){
    public void process(    Packet packet){
      doMigrationComplete(packet.conn.getEndPoint());
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_MIGRATE_RECORD,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleMigrateRecord(packet);
    }
  }
);
}","private ConcurrentMapManager(){
  ClusterService.get().registerPacketProcessor(OP_CMAP_GET,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleGet(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT,new PacketProcessor(){
    public void process(    Packet packet){
      handlePut(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_PUT_SYNC,new PacketProcessor(){
    public void process(    Packet packet){
      handleBackupSync(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_REMOVE_SYNC,new PacketProcessor(){
    public void process(    Packet packet){
      handleBackupSync(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_LOCK_SYNC,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleBackupSync(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT_MULTI,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handlePutMulti(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_ADD,new PacketProcessor(){
    public void process(    Packet packet){
      handleBackupAdd(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleRemove(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE_ITEM,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleRemoveItem(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE_IF_SAME,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleRemove(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_LOCK,new PacketProcessor(){
    public void process(    Packet packet){
      handleLock(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_LOCK_RETURN_OLD,new PacketProcessor(){
    public void process(    Packet packet){
      handleLock(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_UNLOCK,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleLock(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_READ,new PacketProcessor(){
    public void process(    Packet packet){
      handleRead(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_SIZE,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleSize(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ADD_TO_LIST,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleAdd(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ADD_TO_SET,new PacketProcessor(){
    public void process(    Packet packet){
      handleAdd(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_CONTAINS,new PacketProcessor(){
    public void process(    Packet packet){
      handleContains(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BLOCK_INFO,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleBlockInfo(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BLOCKS,new PacketProcessor(){
    public void process(    Packet packet){
      handleBlocks(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT_IF_ABSENT,new PacketProcessor(){
    public void process(    Packet packet){
      handlePut(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REPLACE_IF_NOT_NULL,new PacketProcessor(){
    public void process(    Packet packet){
      handlePut(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_MIGRATION_COMPLETE,new PacketProcessor(){
    public void process(    Packet packet){
      doMigrationComplete(packet.conn.getEndPoint());
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_MIGRATE_RECORD,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleMigrateRecord(packet);
    }
  }
);
}",0.977705147659624
50710,"Record nextOwnedRecord(String name,long recordId,int blockId){
  Record rec=null;
  while (rec == null && recordId <= maxId) {
    rec=getRecordById(recordId);
    if (rec != null) {
      if (name != null && name.equals(rec.name)) {
        if (rec.blockId == blockId) {
          if (rec.owner.equals(thisAddress)) {
            return rec;
          }
        }
      }
    }
    rec=null;
    recordId++;
  }
  return rec;
}","Record nextOwnedRecord(String name,long recordId,int blockId){
  Record rec=null;
  while (rec == null && recordId <= maxId) {
    rec=getRecordById(recordId);
    if (rec != null) {
      if (rec.valueCount() > 0) {
        if (name != null && name.equals(rec.name)) {
          if (rec.blockId == blockId) {
            if (rec.owner.equals(thisAddress)) {
              return rec;
            }
          }
        }
      }
    }
    rec=null;
    recordId++;
  }
  return rec;
}",0.9144736842105264
50711,"public boolean removeKey(Object key){
  if (key == null)   throw new NullPointerException();
  try {
    Data dataKey=ThreadContext.get().toData(key);
    return remove(dataKey) != null;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return false;
}","public boolean removeKey(Object key){
  if (key == null)   throw new NullPointerException();
  ConcurrentMapManager.MRemoveItem mRemoveItem=ConcurrentMapManager.get().new MRemoveItem();
  return mRemoveItem.removeItem(name,key);
}",0.4390243902439024
50712,"public void clear(){
}","public void clear(){
  MIterator it=ConcurrentMapManager.get().new MIterator();
  it.set(name,EntrySet.TYPE_KEYS);
  while (it.hasNext()) {
    it.next();
    it.remove();
  }
}",0.2211055276381909
50713,"int offer(Request req){
  int addIndex=blCurrentPut.add(req.value);
  long recordId=getRecordId(blCurrentPut.blockId,addIndex);
  req.recordId=recordId;
  doFireEntryEvent(true,req.value,recordId);
  size++;
  while (lsScheduledPollActions.size() > 0) {
    ScheduledAction pollAction=lsScheduledPollActions.remove(0);
    ClusterManager.get().deregisterScheduledAction(pollAction);
    if (pollAction.expired()) {
      pollAction.onExpire();
    }
 else {
      boolean consumed=pollAction.consume();
      if (consumed)       return -1;
    }
  }
  sendBackup(true,req.caller,req.value,blCurrentPut.blockId,addIndex);
  if (blCurrentPut.isFull()) {
    fireBlockFullEvent(blCurrentPut);
    blCurrentPut=null;
    setCurrentPut();
  }
  return addIndex;
}","int offer(Request req){
  int addIndex=blCurrentPut.add(req.value);
  try {
    long recordId=getRecordId(blCurrentPut.blockId,addIndex);
    req.recordId=recordId;
    doFireEntryEvent(true,req.value,recordId);
    size++;
    while (lsScheduledPollActions.size() > 0) {
      ScheduledAction pollAction=lsScheduledPollActions.remove(0);
      ClusterManager.get().deregisterScheduledAction(pollAction);
      if (pollAction.expired()) {
        pollAction.onExpire();
      }
 else {
        boolean consumed=pollAction.consume();
        if (consumed)         return -1;
      }
    }
    sendBackup(true,req.caller,req.value,blCurrentPut.blockId,addIndex);
  }
  finally {
    if (blCurrentPut.isFull()) {
      fireBlockFullEvent(blCurrentPut);
      blCurrentPut=null;
      setCurrentPut();
    }
  }
  return addIndex;
}",0.9546027742749056
50714,"void doFireEntryEvent(boolean add,Data value,long recordId){
  if (mapListeners.size() == 0)   return;
  if (add) {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,value,null,recordId);
  }
 else {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_REMOVED,value,null,recordId);
  }
}","void doFireEntryEvent(boolean add,Data value,long recordId){
  if (mapListeners.size() == 0)   return;
  if (add) {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_ADDED,value);
  }
 else {
    fireMapEvent(mapListeners,name,EntryEvent.TYPE_REMOVED,value);
  }
}",0.949820788530466
50715,"private void joinExisting(final Address masterAddress) throws Exception {
  Connection conn=ConnectionManager.get().getOrConnect(masterAddress);
  if (conn == null)   Thread.sleep(1000);
  conn=ConnectionManager.get().getConnection(masterAddress);
  if (DEBUG) {
    logger.log(Level.FINEST,""String_Node_Str"" + conn);
  }
  if (conn != null)   ClusterManager.get().sendJoinRequest(masterAddress);
}","private void joinExisting(final Address masterAddress) throws Exception {
  if (masterAddress == null)   return;
  if (masterAddress.equals(getThisAddress()))   return;
  Connection conn=ConnectionManager.get().getOrConnect(masterAddress);
  if (conn == null)   Thread.sleep(1000);
  conn=ConnectionManager.get().getConnection(masterAddress);
  if (DEBUG) {
    logger.log(Level.FINEST,""String_Node_Str"" + conn);
  }
  if (conn != null)   ClusterManager.get().sendJoinRequest(masterAddress);
}",0.8933782267115601
50716,"private void joinWithMulticast(){
  masterAddress=findMaster();
  if (DEBUG)   logger.log(Level.FINEST,address + ""String_Node_Str"" + masterAddress);
  if (masterAddress == null || masterAddress.equals(address)) {
    ClusterManager.get().addMember(address,getLocalNodeType());
    masterAddress=address;
    clusterImpl.setMembers(ClusterManager.get().lsMembers);
    unlock();
  }
 else {
    while (!joined) {
      try {
        if (DEBUG)         logger.log(Level.FINEST,""String_Node_Str"" + masterAddress);
        while (!joined()) {
          joinExisting(masterAddress);
          Thread.sleep(500);
        }
        if (masterAddress == null) {
          joinWithMulticast();
        }
 else         if (masterAddress.equals(address)) {
          setAsMaster();
        }
      }
 catch (      final Exception e) {
        e.printStackTrace();
      }
    }
  }
}","private void joinWithMulticast(){
  masterAddress=findMaster();
  if (DEBUG)   logger.log(Level.FINEST,address + ""String_Node_Str"" + masterAddress);
  if (masterAddress == null || masterAddress.equals(address)) {
    ClusterManager.get().addMember(address,getLocalNodeType());
    masterAddress=address;
    clusterImpl.setMembers(ClusterManager.get().lsMembers);
    unlock();
  }
 else {
    while (!joined) {
      try {
        if (DEBUG)         logger.log(Level.FINEST,""String_Node_Str"" + masterAddress);
        if (masterAddress == null) {
          joinWithMulticast();
        }
 else         if (masterAddress.equals(address)) {
          setAsMaster();
        }
        joinExisting(masterAddress);
        Thread.sleep(500);
      }
 catch (      final Exception e) {
        logger.log(Level.FINEST,""String_Node_Str"",e);
      }
    }
  }
}",0.7712796757382745
50717,"public static Address pickAddress(final ServerSocketChannel serverSocketChannel) throws Exception {
  String currentAddress=null;
  try {
    final Config config=Config.get();
    final String localAddress=System.getProperty(""String_Node_Str"");
    currentAddress=InetAddress.getByName(localAddress).getHostAddress().trim();
    if (currentAddress == null || currentAddress.length() == 0 || currentAddress.equalsIgnoreCase(""String_Node_Str"") || currentAddress.equals(""String_Node_Str"")) {
      boolean matchFound=false;
      final Enumeration<NetworkInterface> enums=NetworkInterface.getNetworkInterfaces();
      interfaces:       while (enums.hasMoreElements()) {
        final NetworkInterface ni=enums.nextElement();
        final Enumeration<InetAddress> e=ni.getInetAddresses();
        while (e.hasMoreElements()) {
          final InetAddress inetAddress=e.nextElement();
          if (inetAddress instanceof Inet4Address) {
            final String address=inetAddress.getHostAddress();
            if (!inetAddress.isLoopbackAddress()) {
              currentAddress=address;
              if (config.interfaces.enabled) {
                if (matchAddress(address)) {
                  matchFound=true;
                  break interfaces;
                }
              }
 else {
                break interfaces;
              }
            }
          }
        }
      }
      if (config.interfaces.enabled && !matchFound) {
        String msg=""String_Node_Str"";
        msg+=""String_Node_Str"";
        logger.log(Level.SEVERE,msg);
        Node.get().dumpCore(null);
        return null;
      }
    }
    final InetAddress inetAddress=InetAddress.getByName(currentAddress);
    ServerSocket serverSocket=serverSocketChannel.socket();
    serverSocket.setReuseAddress(false);
    InetSocketAddress isa=null;
    int port=config.port;
    socket:     for (int i=0; i < 100; i++) {
      try {
        isa=new InetSocketAddress(inetAddress,port);
        serverSocket.bind(isa,100);
        break socket;
      }
 catch (      final Exception e) {
        serverSocket=serverSocketChannel.socket();
        serverSocket.setReuseAddress(false);
        port++;
        continue socket;
      }
    }
    serverSocketChannel.configureBlocking(false);
    final Address selectedAddress=new Address(currentAddress,port);
    return selectedAddress;
  }
 catch (  final Exception e) {
    Node.get().dumpCore(e);
    e.printStackTrace();
    throw e;
  }
}","public static Address pickAddress(final ServerSocketChannel serverSocketChannel) throws Exception {
  String currentAddress=null;
  try {
    final Config config=Config.get();
    final String localAddress=System.getProperty(""String_Node_Str"");
    if (localAddress != null) {
      currentAddress=InetAddress.getByName(localAddress.trim()).getHostAddress();
    }
    if (currentAddress == null) {
      final Enumeration<NetworkInterface> enums=NetworkInterface.getNetworkInterfaces();
      interfaces:       while (enums.hasMoreElements()) {
        final NetworkInterface ni=enums.nextElement();
        final Enumeration<InetAddress> e=ni.getInetAddresses();
        while (e.hasMoreElements()) {
          final InetAddress inetAddress=e.nextElement();
          if (inetAddress instanceof Inet4Address) {
            final String address=inetAddress.getHostAddress();
            if (config.interfaces.enabled) {
              if (matchAddress(address)) {
                currentAddress=address;
                break interfaces;
              }
            }
 else {
              if (!inetAddress.isLoopbackAddress()) {
                currentAddress=address;
                break interfaces;
              }
            }
          }
        }
      }
      if (config.interfaces.enabled && currentAddress == null) {
        String msg=""String_Node_Str"";
        msg+=""String_Node_Str"";
        logger.log(Level.SEVERE,msg);
        Node.get().dumpCore(null);
        return null;
      }
    }
    if (currentAddress == null) {
      currentAddress=""String_Node_Str"";
    }
    final InetAddress inetAddress=InetAddress.getByName(currentAddress);
    ServerSocket serverSocket=serverSocketChannel.socket();
    serverSocket.setReuseAddress(false);
    InetSocketAddress isa=null;
    int port=config.port;
    socket:     for (int i=0; i < 100; i++) {
      try {
        isa=new InetSocketAddress(inetAddress,port);
        serverSocket.bind(isa,100);
        break socket;
      }
 catch (      final Exception e) {
        serverSocket=serverSocketChannel.socket();
        serverSocket.setReuseAddress(false);
        port++;
        continue socket;
      }
    }
    serverSocketChannel.configureBlocking(false);
    final Address selectedAddress=new Address(currentAddress,port);
    return selectedAddress;
  }
 catch (  final Exception e) {
    Node.get().dumpCore(e);
    e.printStackTrace();
    throw e;
  }
}",0.8269387755102041
50718,"public void run(){
  while (running) {
    Object obj=null;
    try {
      lsBuffer.clear();
      queue.drainTo(lsBuffer);
      final int size=lsBuffer.size();
      if (size > 0) {
        for (int i=0; i < size; i++) {
          obj=lsBuffer.get(i);
          checkPeriodics();
          process(obj);
        }
        lsBuffer.clear();
      }
 else {
        obj=queue.poll(100,TimeUnit.MILLISECONDS);
        checkPeriodics();
        if (obj != null) {
          process(obj);
        }
      }
    }
 catch (    final InterruptedException e) {
      Node.get().handleInterruptedException(Thread.currentThread(),e);
    }
catch (    final Throwable e) {
      logger.log(Level.FINEST,e + ""String_Node_Str"" + e+ ""String_Node_Str""+ obj,e);
      e.printStackTrace();
    }
  }
  lsBuffer.clear();
  queue.clear();
}","public void run(){
  while (running) {
    Object obj=null;
    try {
      lsBuffer.clear();
      queue.drainTo(lsBuffer);
      final int size=lsBuffer.size();
      if (size > 0) {
        for (int i=0; i < size; i++) {
          obj=lsBuffer.get(i);
          checkPeriodics();
          process(obj);
        }
        lsBuffer.clear();
      }
 else {
        obj=queue.poll(100,TimeUnit.MILLISECONDS);
        checkPeriodics();
        if (obj != null) {
          process(obj);
        }
      }
    }
 catch (    final InterruptedException e) {
      Node.get().handleInterruptedException(Thread.currentThread(),e);
    }
catch (    final Throwable e) {
      logger.log(Level.FINEST,e + ""String_Node_Str"" + e+ ""String_Node_Str""+ obj,e);
      e.printStackTrace();
      System.out.println(""String_Node_Str"" + obj);
    }
  }
  lsBuffer.clear();
  queue.clear();
}",0.9699469652327636
50719,"public boolean backup(Request req){
  Record record=getRecord(req.key);
  if (record != null) {
    record.version=req.version;
    if (req.version > record.version + 1) {
      Request reqCopy=new Request();
      reqCopy.setFromRequest(req,false);
      req.key=null;
      req.value=null;
      record.addBackupOp(new VersionedBackupOp(reqCopy));
      return true;
    }
 else     if (req.version <= record.version) {
      return false;
    }
  }
  doBackup(req);
  if (record != null) {
    record.version=req.version;
    record.runBackupOps();
  }
  return true;
}","public boolean backup(Request req){
  Record record=getRecord(req.key);
  if (record != null) {
    if (req.version > record.version + 1) {
      Request reqCopy=new Request();
      reqCopy.setFromRequest(req,false);
      req.key=null;
      req.value=null;
      record.addBackupOp(new VersionedBackupOp(reqCopy));
      return true;
    }
 else     if (req.version <= record.version) {
      return false;
    }
  }
  doBackup(req);
  if (record != null) {
    record.version=req.version;
    record.runBackupOps();
  }
  return true;
}",0.9712230215827338
50720,"private ConcurrentMapManager(){
  ClusterService.get().registerPacketProcessor(OP_CMAP_GET,new DefaultPacketProcessor(false,true,false,true){
    void handle(    Request request){
      doGet(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doPut(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_PUT,new DefaultPacketProcessor(){
    void handle(    Request request){
      doBackup(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT_IF_ABSENT,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doPut(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REPLACE_IF_NOT_NULL,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doPut(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_ADD,new DefaultPacketProcessor(){
    void handle(    Request request){
      doBackup(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_REMOVE,new DefaultPacketProcessor(false,false,false,false){
    void handle(    Request request){
      doBackup(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_LOCK,new DefaultPacketProcessor(false,false,false,false){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT_MULTI,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doPut(request,false);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doRemove(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE_MULTI,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doRemoveMulti(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE_ITEM,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doRemove(request,false);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE_IF_SAME,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doRemove(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_LOCK,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_LOCK_RETURN_OLD,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_UNLOCK,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_SIZE,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleSize(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ITERATE,new DefaultPacketProcessor(true,false,false,true){
    void handle(    Request request){
      CMap cmap=getMap(request.name);
      cmap.getEntries(remoteReq);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ITERATE_KEYS,new DefaultPacketProcessor(true,false,false,true){
    void handle(    Request request){
      CMap cmap=getMap(request.name);
      cmap.getEntries(remoteReq);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ADD_TO_LIST,new DefaultPacketProcessor(false,true,false,false){
    void handle(    Request request){
      doAdd(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ADD_TO_SET,new DefaultPacketProcessor(false,true,false,false){
    void handle(    Request request){
      doAdd(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_CONTAINS,new DefaultPacketProcessor(true,false,false,false){
    void handle(    Request request){
      doContains(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BLOCK_INFO,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleBlockInfo(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BLOCKS,new PacketProcessor(){
    public void process(    Packet packet){
      handleBlocks(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_MIGRATION_COMPLETE,new PacketProcessor(){
    public void process(    Packet packet){
      doMigrationComplete(packet.conn.getEndPoint());
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_MIGRATE_RECORD,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleMigrateRecord(packet);
    }
  }
);
}","private ConcurrentMapManager(){
  ClusterService.get().registerPacketProcessor(OP_CMAP_GET,new DefaultPacketProcessor(false,true,false,true){
    void handle(    Request request){
      doGet(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doPut(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_PUT,new DefaultPacketProcessor(){
    void handle(    Request request){
      doBackup(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT_IF_ABSENT,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doPut(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REPLACE_IF_NOT_NULL,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doPut(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_ADD,new DefaultPacketProcessor(){
    void handle(    Request request){
      doBackup(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_REMOVE,new DefaultPacketProcessor(false,false,false,false){
    void handle(    Request request){
      doBackup(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BACKUP_LOCK,new DefaultPacketProcessor(false,false,false,false){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_PUT_MULTI,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doPut(request,false);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doRemove(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE_MULTI,new DefaultPacketProcessor(false,true,true,true){
    void handle(    Request request){
      doRemoveMulti(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE_ITEM,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doRemove(request,false);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_REMOVE_IF_SAME,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doRemove(request,true);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_LOCK,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_LOCK_RETURN_OLD,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_UNLOCK,new DefaultPacketProcessor(false,true,true,false){
    void handle(    Request request){
      doLock(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_SIZE,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleSize(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ITERATE,new DefaultPacketProcessor(true,false,false,true){
    void handle(    Request request){
      CMap cmap=getMap(request.name);
      cmap.getEntries(remoteReq);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ITERATE_KEYS,new DefaultPacketProcessor(true,false,false,true){
    void handle(    Request request){
      CMap cmap=getMap(request.name);
      cmap.getEntries(remoteReq);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ADD_TO_LIST,new DefaultPacketProcessor(false,true,false,false){
    void handle(    Request request){
      doAdd(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_ADD_TO_SET,new DefaultPacketProcessor(false,true,false,false){
    void handle(    Request request){
      doAdd(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_CONTAINS,new DefaultPacketProcessor(true,false,false,false){
    void handle(    Request request){
      doContains(request);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BLOCK_INFO,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleBlockInfo(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_BLOCKS,new PacketProcessor(){
    public void process(    Packet packet){
      handleBlocks(packet);
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_MIGRATION_COMPLETE,new PacketProcessor(){
    public void process(    Packet packet){
      doMigrationComplete(packet.conn.getEndPoint());
    }
  }
);
  ClusterService.get().registerPacketProcessor(OP_CMAP_MIGRATE_RECORD,new PacketProcessor(){
    public void process(    PacketQueue.Packet packet){
      handleMigrateRecord(packet);
    }
  }
);
}",0.9993128497104152
50721,"void doResetRecords(){
  if (isSuperClient())   return;
  final Object[] records=mapRecordsById.values().toArray();
  mapRecordsById.clear();
  Collection<CMap> cmaps=maps.values();
  for (  CMap cmap : cmaps) {
    cmap.mapRecords.clear();
  }
  for (  Object recObj : records) {
    final Record rec=(Record)recObj;
    CMap cmap=getMap(rec.name);
    cmap.removeRecord(rec.key);
    executeLocally(new Runnable(){
      public void run(){
        MMigrate mmigrate=new MMigrate();
        mmigrate.migrate(rec);
      }
    }
);
  }
  executeLocally(new Runnable(){
    public void run(){
      Processable processCompletion=new Processable(){
        public void process(){
          doMigrationComplete(thisAddress);
          sendMigrationComplete();
          if (DEBUG) {
            printBlocks();
            logger.log(Level.FINEST,""String_Node_Str"");
          }
        }
      }
;
      enqueueAndReturn(processCompletion);
    }
  }
);
}","void doResetRecords(){
  if (isSuperClient())   return;
  final Object[] records=mapRecordsById.values().toArray();
  mapRecordsById.clear();
  Collection<CMap> cmaps=maps.values();
  for (  CMap cmap : cmaps) {
    cmap.mapRecords.clear();
  }
  for (  Object recObj : records) {
    final Record rec=(Record)recObj;
    rec.runBackupOps();
    CMap cmap=getMap(rec.name);
    cmap.removeRecord(rec.key);
    executeLocally(new Runnable(){
      public void run(){
        MMigrate mmigrate=new MMigrate();
        mmigrate.migrate(rec);
      }
    }
);
  }
  executeLocally(new Runnable(){
    public void run(){
      Processable processCompletion=new Processable(){
        public void process(){
          doMigrationComplete(thisAddress);
          sendMigrationComplete();
          if (DEBUG) {
            printBlocks();
            logger.log(Level.FINEST,""String_Node_Str"");
          }
        }
      }
;
      enqueueAndReturn(processCompletion);
    }
  }
);
}",0.9875518672199172
50722,"final void doPut(Request request){
  if (request.operation == OP_CMAP_MIGRATE_RECORD) {
    doMigrate(request);
    return;
  }
  if (request.operation == OP_CMAP_PUT_MULTI) {
    doPutMulti(request);
    return;
  }
  if (request.operation == OP_CMAP_PUT_IF_ABSENT) {
    Record record=recordExist(request);
    if (record != null && record.getValue() != null) {
      Data valueCopy=ThreadContext.get().hardCopy(record.getValue());
      request.response=valueCopy;
      return;
    }
  }
 else   if (request.operation == OP_CMAP_REPLACE_IF_NOT_NULL) {
    Record record=recordExist(request);
    if (record == null || record.getValue() == null) {
      request.response=null;
      return;
    }
  }
  if (!testLock(request)) {
    if (request.hasEnoughTimeToSchedule()) {
      Record record=ensureRecord(request);
      request.scheduled=true;
      final Request reqScheduled=(request.local) ? request : request.hardCopy();
      record.addScheduledAction(new ScheduledAction(request){
        @Override public boolean consume(){
          CMap cmap=getMap(reqScheduled.name);
          Data oldValue=cmap.put(reqScheduled);
          reqScheduled.response=oldValue;
          reqScheduled.key=null;
          reqScheduled.value=null;
          returnScheduledAsSuccess(reqScheduled);
          return true;
        }
      }
);
    }
 else {
      request.response=null;
    }
  }
 else {
    CMap cmap=getMap(request.name);
    Data oldValue=cmap.put(request);
    request.response=oldValue;
  }
}","final void doPut(Request request){
  if (request.operation == OP_CMAP_PUT_MULTI) {
    doPutMulti(request);
    return;
  }
  if (request.operation == OP_CMAP_PUT_IF_ABSENT) {
    Record record=recordExist(request);
    if (record != null && record.getValue() != null) {
      Data valueCopy=ThreadContext.get().hardCopy(record.getValue());
      request.response=valueCopy;
      return;
    }
  }
 else   if (request.operation == OP_CMAP_REPLACE_IF_NOT_NULL) {
    Record record=recordExist(request);
    if (record == null || record.getValue() == null) {
      request.response=null;
      return;
    }
  }
  if (!testLock(request)) {
    if (request.hasEnoughTimeToSchedule()) {
      Record record=ensureRecord(request);
      request.scheduled=true;
      final Request reqScheduled=(request.local) ? request : request.hardCopy();
      record.addScheduledAction(new ScheduledAction(request){
        @Override public boolean consume(){
          CMap cmap=getMap(reqScheduled.name);
          Data oldValue=cmap.put(reqScheduled);
          reqScheduled.response=oldValue;
          reqScheduled.key=null;
          reqScheduled.value=null;
          returnScheduledAsSuccess(reqScheduled);
          return true;
        }
      }
);
    }
 else {
      request.response=null;
    }
  }
 else {
    CMap cmap=getMap(request.name);
    Data oldValue=cmap.put(request);
    request.response=oldValue;
  }
}",0.9681397738951696
50723,"public RequestWrapper(final AppContext context,final HttpServletRequest req,final ResponseWrapper res){
  super(req);
  this.res=res;
  this.context=context;
  this.original=req;
  this.original.setAttribute(HAZELCAST_REQUEST,this);
  creationTime=System.nanoTime();
  final Cookie[] cookies=req.getCookies();
  if (cookies != null) {
    for (int i=0; i < cookies.length; i++) {
      final Cookie cookie=cookies[i];
      if (cookie.getName().equals(""String_Node_Str"")) {
        requestedSessionId=cookie.getValue();
        requestedSessionIdFromCookie=true;
        if (DEBUG) {
          log(""String_Node_Str"" + requestedSessionId);
        }
      }
    }
  }
  if (requestedSessionId == null) {
    if (DEBUG) {
      logger.log(Level.FINEST,""String_Node_Str"" + getContextPath());
      logger.log(Level.FINEST,""String_Node_Str"" + getQueryString());
      logger.log(Level.FINEST,""String_Node_Str"" + getRequestURI());
      logger.log(Level.FINEST,""String_Node_Str"" + getRequestURL());
    }
    requestedSessionId=res.extractSessionId(getRequestURL().toString());
    if (DEBUG) {
      log(""String_Node_Str"" + requestedSessionId);
    }
    if (requestedSessionId != null) {
      requestedSessionIdFromURL=true;
    }
  }
}","public RequestWrapper(final AppContext context,final HttpServletRequest req,final ResponseWrapper res){
  super(req);
  this.res=res;
  this.context=context;
  this.original=req;
  this.original.setAttribute(HAZELCAST_REQUEST,this);
  creationTime=System.nanoTime();
  final Cookie[] cookies=req.getCookies();
  if (cookies != null) {
    for (    final Cookie cookie : cookies) {
      if (cookie.getName().equalsIgnoreCase(""String_Node_Str"")) {
        requestedSessionId=cookie.getValue();
        requestedSessionIdFromCookie=true;
        if (DEBUG) {
          log(""String_Node_Str"" + requestedSessionId);
        }
      }
    }
  }
  if (requestedSessionId == null) {
    if (DEBUG) {
      logger.log(Level.FINEST,""String_Node_Str"" + getContextPath());
      logger.log(Level.FINEST,""String_Node_Str"" + getQueryString());
      logger.log(Level.FINEST,""String_Node_Str"" + getRequestURI());
      logger.log(Level.FINEST,""String_Node_Str"" + getRequestURL());
    }
    requestedSessionId=res.extractSessionId(getRequestURL().toString());
    if (DEBUG) {
      log(""String_Node_Str"" + requestedSessionId);
    }
    if (requestedSessionId != null) {
      requestedSessionIdFromURL=true;
    }
  }
}",0.9389594428512904
50724,"public void doFilter(ServletRequest req,ServletResponse res,final FilterChain chain) throws IOException, ServletException {
  log(""String_Node_Str"");
  if (DEBUG) {
    log(appsSharingSessions + ""String_Node_Str"" + req.getClass().getName());
  }
  if (!(req instanceof HttpServletRequest)) {
    chain.doFilter(req,res);
  }
 else {
    if (req instanceof RequestWrapper) {
      chain.doFilter(req,res);
      return;
    }
 else {
      if (req.getAttribute(HAZELCAST_REQUEST) != null) {
        chain.doFilter(req,res);
        return;
      }
    }
    HttpServletRequest httpReq=(HttpServletRequest)req;
    if (DEBUG) {
      final Cookie[] cookies=httpReq.getCookies();
      if (cookies != null) {
        for (int i=0; i < cookies.length; i++) {
          final Cookie cookie=cookies[i];
          final String name=cookie.getName();
          final String value=cookie.getValue();
          final String path=cookie.getPath();
          if (name.equals(""String_Node_Str"")) {
            log(path + ""String_Node_Str"" + value);
          }
        }
      }
    }
    final ResponseWrapper resWrapper=new ResponseWrapper(app,(HttpServletResponse)res);
    final RequestWrapper reqWrapper=new RequestWrapper(app,httpReq,resWrapper);
    resWrapper.setRequest(reqWrapper);
    final ServletRequestEvent event=(app.lsRequestListeners.size() == 0) ? null : new ServletRequestEvent(app.getOriginalServletContext(),reqWrapper);
    if (event != null) {
      executor.execute(new Runnable(){
        public void run(){
          for (          final ServletRequestListener listener : app.lsRequestListeners) {
            listener.requestInitialized(event);
          }
        }
      }
);
    }
    req=null;
    res=null;
    httpReq=null;
    HazelSession session=null;
    String sessionId=null;
    session=reqWrapper.getSession(false);
    if (session != null)     sessionId=session.getId();
    if (session != null) {
      if (session.expired(System.currentTimeMillis())) {
        if (DEBUG) {
          log(""String_Node_Str"" + session.getId());
        }
        app.destroySession(session);
      }
    }
    chain.doFilter(reqWrapper,resWrapper);
    req=null;
    session=reqWrapper.getSession(false);
    if (session != null)     sessionId=session.getId();
    if (session != null) {
      if (!session.valid.get()) {
        if (DEBUG) {
          log(""String_Node_Str"" + sessionId);
        }
        removeCookieForSession(reqWrapper,sessionId);
        return;
      }
      final Enumeration<String> attsNames=session.getAttributeNames();
      Map mapData=null;
      while (attsNames.hasMoreElements()) {
        final String attName=attsNames.nextElement();
        final Object value=session.getAttribute(attName);
        if (value instanceof Serializable) {
          if (mapData == null) {
            mapData=new HashMap<String,Object>();
          }
          mapData.put(attName,value);
        }
      }
      boolean sessionChanged=false;
      Data data=session.writeObject(mapData);
      sessionChanged=session.sessionChanged(data);
      if (sessionChanged) {
        if (data == null) {
          mapData=new HashMap<String,Object>();
          data=session.writeObject(mapData);
        }
        if (DEBUG) {
          log(""String_Node_Str"" + sessionId);
        }
        if (session.knownToCluster()) {
          app.getClusterMap().put(sessionId,data);
        }
 else {
          Object old=app.getClusterMap().putIfAbsent(sessionId,data);
          int tryCount=1;
          while (old != null) {
            app.changeSessionId(session);
            old=app.getClusterMap().putIfAbsent(sessionId,data);
            if (tryCount++ >= 3)             throw new RuntimeException(""String_Node_Str"");
          }
          session.setKnownToCluster(true);
        }
      }
      session.setLastAccessed();
      session.setNew(false);
    }
    app.getSnapshot().requestTime((System.nanoTime() - reqWrapper.creationTime) / 1000);
    if (event != null) {
      executor.execute(new Runnable(){
        public void run(){
          for (          final ServletRequestListener listener : app.lsRequestListeners) {
            listener.requestDestroyed(event);
          }
        }
      }
);
    }
  }
}","public void doFilter(ServletRequest req,ServletResponse res,final FilterChain chain) throws IOException, ServletException {
  log(""String_Node_Str"");
  if (DEBUG) {
    log(appsSharingSessions + ""String_Node_Str"" + req.getClass().getName());
  }
  if (!(req instanceof HttpServletRequest)) {
    chain.doFilter(req,res);
  }
 else {
    if (req instanceof RequestWrapper) {
      chain.doFilter(req,res);
      return;
    }
 else {
      if (req.getAttribute(HAZELCAST_REQUEST) != null) {
        chain.doFilter(req,res);
        return;
      }
    }
    HttpServletRequest httpReq=(HttpServletRequest)req;
    if (DEBUG) {
      final Cookie[] cookies=httpReq.getCookies();
      if (cookies != null) {
        for (        final Cookie cookie : cookies) {
          final String name=cookie.getName();
          final String value=cookie.getValue();
          final String path=cookie.getPath();
          if (name.equalsIgnoreCase(""String_Node_Str"")) {
            log(path + ""String_Node_Str"" + value);
          }
        }
      }
    }
    final ResponseWrapper resWrapper=new ResponseWrapper(app,(HttpServletResponse)res);
    final RequestWrapper reqWrapper=new RequestWrapper(app,httpReq,resWrapper);
    resWrapper.setRequest(reqWrapper);
    final ServletRequestEvent event=(app.lsRequestListeners.size() == 0) ? null : new ServletRequestEvent(app.getOriginalServletContext(),reqWrapper);
    if (event != null) {
      executor.execute(new Runnable(){
        public void run(){
          for (          final ServletRequestListener listener : app.lsRequestListeners) {
            listener.requestInitialized(event);
          }
        }
      }
);
    }
    req=null;
    res=null;
    httpReq=null;
    HazelSession session=null;
    String sessionId=null;
    session=reqWrapper.getSession(false);
    if (session != null)     sessionId=session.getId();
    if (session != null) {
      if (session.expired(System.currentTimeMillis())) {
        if (DEBUG) {
          log(""String_Node_Str"" + session.getId());
        }
        app.destroySession(session);
      }
    }
    chain.doFilter(reqWrapper,resWrapper);
    req=null;
    session=reqWrapper.getSession(false);
    if (session != null)     sessionId=session.getId();
    if (session != null) {
      if (!session.valid.get()) {
        if (DEBUG) {
          log(""String_Node_Str"" + sessionId);
        }
        removeCookieForSession(reqWrapper,sessionId);
        return;
      }
      final Enumeration<String> attsNames=session.getAttributeNames();
      Map mapData=null;
      while (attsNames.hasMoreElements()) {
        final String attName=attsNames.nextElement();
        final Object value=session.getAttribute(attName);
        if (value instanceof Serializable) {
          if (mapData == null) {
            mapData=new HashMap<String,Object>();
          }
          mapData.put(attName,value);
        }
      }
      boolean sessionChanged=false;
      Data data=session.writeObject(mapData);
      sessionChanged=session.sessionChanged(data);
      if (sessionChanged) {
        if (data == null) {
          mapData=new HashMap<String,Object>();
          data=session.writeObject(mapData);
        }
        if (DEBUG) {
          log(""String_Node_Str"" + sessionId);
        }
        if (session.knownToCluster()) {
          app.getClusterMap().put(sessionId,data);
        }
 else {
          Object old=app.getClusterMap().putIfAbsent(sessionId,data);
          int tryCount=1;
          while (old != null) {
            app.changeSessionId(session);
            old=app.getClusterMap().putIfAbsent(sessionId,data);
            if (tryCount++ >= 3)             throw new RuntimeException(""String_Node_Str"");
          }
          session.setKnownToCluster(true);
        }
      }
      session.setLastAccessed();
      session.setNew(false);
    }
    app.getSnapshot().requestTime((System.nanoTime() - reqWrapper.creationTime) / 1000);
    if (event != null) {
      executor.execute(new Runnable(){
        public void run(){
          for (          final ServletRequestListener listener : app.lsRequestListeners) {
            listener.requestDestroyed(event);
          }
        }
      }
);
    }
  }
}",0.9481148800378206
50725,"public void setMaxInactiveInterval(int maxInactiveSeconds){
  if (DEBUG)   log(""String_Node_Str"" + maxInactiveSeconds);
  if (maxInactiveSeconds < 0)   maxInactiveSeconds=-1;
  maxInactiveInterval.set(maxInactiveSeconds * 1000);
}","public void setMaxInactiveInterval(int maxInactiveSeconds){
  if (DEBUG)   log(""String_Node_Str"" + maxInactiveSeconds);
  if (maxInactiveSeconds < 0)   maxInactiveSeconds=-1;
  maxInactiveInterval.set(maxInactiveSeconds * 1000L);
}",0.9978308026030368
50726,"public boolean hasNext(){
  if (next != null) {
    if (next.copyCount-- <= 0) {
      next=null;
    }
  }
  while (next == null) {
    boolean canRead=setNextBlock();
    if (!canRead)     return false;
    next=read.read(name,currentBlockId,currentIndex);
    if (next == null) {
      currentIndex=-1;
    }
 else {
      currentIndex=read.lastReadRecordId;
      currentIndex++;
    }
  }
  hasNextCalled=true;
  return true;
}","public boolean hasNext(){
  if (next != null) {
    if (next.copyCount-- <= 0) {
      next=null;
    }
  }
  if (lsEntries != null) {
    if (lsEntries.size() > 0) {
      next=lsEntries.remove(0);
    }
 else {
      next=null;
      lsEntries=null;
    }
  }
  while (next == null) {
    boolean canRead=setNextBlock();
    if (!canRead)     return false;
    next=read.read(name,currentBlockId,currentIndex);
    if (next == null) {
      currentIndex=-1;
    }
 else {
      currentIndex=read.lastReadRecordId;
      currentIndex++;
      TransactionImpl txn=ThreadContext.get().txn;
      if (txn != null) {
        Object key=next.getKey();
        if (txn.has(name,key)) {
          next=null;
        }
      }
    }
  }
  hasNextCalled=true;
  return true;
}",0.7066666666666667
50727,"public void set(String name,int type){
  this.name=name;
  this.type=type;
}","public void set(String name,int type){
  this.name=name;
  this.type=type;
  TransactionImpl txn=ThreadContext.get().txn;
  if (txn != null) {
    lsEntries=txn.entries(name);
  }
}",0.5914396887159533
50728,"public EventTask(final int eventType,final String name,final Data dataKey,final Data dataValue,final long recordId){
  super(name);
  this.eventType=eventType;
  this.name=name;
  this.dataValue=dataValue;
  this.dataKey=dataKey;
  this.recordId=recordId;
}","public EventTask(final int eventType,final String name,final Data dataKey,final Data dataValue,final long recordId){
  super(name);
  this.eventType=eventType;
  this.dataValue=dataValue;
  this.dataKey=dataKey;
  this.recordId=recordId;
}",0.9637096774193548
50729,"void callListeners(EventTask event){
  String name=event.name;
  for (  ListenerItem listenerItem : lsListeners) {
    if (listenerItem.name.equals(name)) {
      if (listenerItem.key == null) {
        callListener(listenerItem,event);
      }
 else       if (event.getKey().equals(listenerItem.key)) {
        callListener(listenerItem,event);
      }
    }
  }
}","void callListeners(EventTask event){
  String name=event.getName();
  for (  ListenerItem listenerItem : lsListeners) {
    if (listenerItem.name.equals(name)) {
      if (listenerItem.key == null) {
        callListener(listenerItem,event);
      }
 else       if (event.getKey().equals(listenerItem.key)) {
        callListener(listenerItem,event);
      }
    }
  }
}",0.982312925170068
50730,"public void returnScheduledAsSuccess(final Request request){
  if (request.local) {
    final TargetAwareOp mop=(TargetAwareOp)request.attachment;
    mop.setResult(request.response);
  }
 else {
    final Invocation inv=request.toInvocation();
    final Object result=request.response;
    if (result != null) {
      if (result instanceof Data) {
        final Data oldValue=(Data)result;
        if (oldValue != null && oldValue.size() > 0) {
          doSet(oldValue,inv.value);
        }
      }
    }
    sendResponse(inv,request.caller);
  }
}","public void returnScheduledAsSuccess(final Request request){
  if (request.local) {
    final TargetAwareOp mop=(TargetAwareOp)request.attachment;
    mop.setResult(request.response);
  }
 else {
    final Invocation inv=request.toInvocation();
    final Object result=request.response;
    if (result != null) {
      if (result instanceof Data) {
        final Data data=(Data)result;
        if (data.size() > 0) {
          doSet(data,inv.value);
        }
      }
    }
    sendResponse(inv,request.caller);
  }
}",0.947565543071161
50731,"public Object getValue(){
  if (value == null) {
    if (valueData != null) {
      value=ThreadContext.get().toObject(valueData);
    }
  }
  return value;
}","public Object getValue(){
  if (value == null) {
    if (valueData != null) {
      value=ThreadContext.get().toObject(valueData);
    }
 else {
      return getKey();
    }
  }
  return value;
}",0.8951841359773371
50732,"public void run(){
  while (running) {
    Object obj=null;
    try {
      lsBuffer.clear();
      queue.drainTo(lsBuffer);
      final int size=lsBuffer.size();
      if (size > 0) {
        for (int i=0; i < size; i++) {
          obj=lsBuffer.get(i);
          checkPeriodics();
          process(obj);
        }
        lsBuffer.clear();
      }
 else {
        obj=queue.poll(100,TimeUnit.MILLISECONDS);
        checkPeriodics();
        if (obj != null) {
          process(obj);
        }
      }
    }
 catch (    final InterruptedException e) {
      Node.get().handleInterruptedException(Thread.currentThread(),e);
    }
catch (    final Throwable e) {
      if (DEBUG) {
        logger.log(Level.FINEST,e + ""String_Node_Str"" + e+ ""String_Node_Str""+ obj);
        logger.log(Level.FINEST,e.getMessage(),e);
      }
    }
  }
  lsBuffer.clear();
  queue.clear();
}","public void run(){
  while (running) {
    Object obj=null;
    try {
      lsBuffer.clear();
      queue.drainTo(lsBuffer);
      final int size=lsBuffer.size();
      if (size > 0) {
        for (int i=0; i < size; i++) {
          obj=lsBuffer.get(i);
          checkPeriodics();
          process(obj);
        }
        lsBuffer.clear();
      }
 else {
        obj=queue.poll(100,TimeUnit.MILLISECONDS);
        checkPeriodics();
        if (obj != null) {
          process(obj);
        }
      }
    }
 catch (    final InterruptedException e) {
      Node.get().handleInterruptedException(Thread.currentThread(),e);
    }
catch (    final Throwable e) {
      logger.log(Level.FINEST,e + ""String_Node_Str"" + e+ ""String_Node_Str""+ obj,e);
    }
  }
  lsBuffer.clear();
  queue.clear();
}",0.9508982035928144
50733,"public void run3(){
  Object obj=null;
  while (running) {
    try {
      obj=queue.take();
      process(obj);
    }
 catch (    final InterruptedException e) {
      Node.get().handleInterruptedException(Thread.currentThread(),e);
    }
catch (    final Exception e) {
      if (DEBUG) {
        logger.log(Level.FINEST,e + ""String_Node_Str"" + e.getMessage()+ ""String_Node_Str""+ obj);
      }
      e.printStackTrace();
    }
  }
}","public void run3(){
  Object obj=null;
  while (running) {
    try {
      obj=queue.take();
      process(obj);
    }
 catch (    final InterruptedException e) {
      Node.get().handleInterruptedException(Thread.currentThread(),e);
    }
catch (    final Exception e) {
      logger.log(Level.FINEST,e + ""String_Node_Str"" + e.getMessage()+ ""String_Node_Str""+ obj,e);
    }
  }
}",0.8943488943488943
50734,"void consumeResponse(Invocation inv){
  complete(true);
  inv.returnToContainer();
}","@Override void consumeResponse(Invocation inv){
  complete(true);
  inv.returnToContainer();
}",0.9438202247191012
50735,"void doRemoveAddress(Address deadAddress){
  if (DEBUG) {
    log(""String_Node_Str"" + deadAddress);
  }
  if (deadAddress.equals(thisAddress))   return;
  if (deadAddress.equals(getMasterAddress())) {
    if (Node.get().joined()) {
      MemberImpl newMaster=getNextMemberAfter(deadAddress,false,1);
      if (newMaster != null)       Node.get().setMasterAddress(newMaster.getAddress());
 else       Node.get().setMasterAddress(null);
    }
 else {
      Node.get().setMasterAddress(null);
    }
    if (DEBUG) {
      log(""String_Node_Str"" + Node.get().getMasterAddress());
    }
  }
  if (isMaster()) {
    if (setJoins.contains(deadAddress)) {
      setJoins.remove(deadAddress);
    }
  }
  lsMembersBefore.clear();
  for (  MemberImpl member : lsMembers) {
    lsMembersBefore.add(member);
  }
  Connection conn=ConnectionManager.get().getConnection(deadAddress);
  if (conn != null) {
    ConnectionManager.get().remove(conn);
  }
  MemberImpl member=getMember(deadAddress);
  if (member != null) {
    removeMember(deadAddress);
  }
  BlockingQueueManager.get().syncForDead(deadAddress);
  ConcurrentMapManager.get().syncForDead(deadAddress);
  ListenerManager.get().syncForDead(deadAddress);
  TopicManager.get().syncForDead(deadAddress);
  Node.get().getClusterImpl().setMembers(lsMembers);
  Object[] calls=mapCalls.values().toArray();
  for (  Object call : calls) {
    ((Call)call).onDisconnect(deadAddress);
  }
  System.out.println(this);
}","void doRemoveAddress(Address deadAddress){
  if (DEBUG) {
    log(""String_Node_Str"" + deadAddress);
  }
  if (deadAddress.equals(thisAddress))   return;
  if (deadAddress.equals(getMasterAddress())) {
    if (Node.get().joined()) {
      MemberImpl newMaster=getNextMemberAfter(deadAddress,false,1);
      if (newMaster != null)       Node.get().setMasterAddress(newMaster.getAddress());
 else       Node.get().setMasterAddress(null);
    }
 else {
      Node.get().setMasterAddress(null);
    }
    if (DEBUG) {
      log(""String_Node_Str"" + Node.get().getMasterAddress());
    }
  }
  if (isMaster()) {
    setJoins.remove(new MemberInfo(deadAddress,0));
  }
  lsMembersBefore.clear();
  for (  MemberImpl member : lsMembers) {
    lsMembersBefore.add(member);
  }
  Connection conn=ConnectionManager.get().getConnection(deadAddress);
  if (conn != null) {
    ConnectionManager.get().remove(conn);
  }
  MemberImpl member=getMember(deadAddress);
  if (member != null) {
    removeMember(deadAddress);
  }
  BlockingQueueManager.get().syncForDead(deadAddress);
  ConcurrentMapManager.get().syncForDead(deadAddress);
  ListenerManager.get().syncForDead(deadAddress);
  TopicManager.get().syncForDead(deadAddress);
  Node.get().getClusterImpl().setMembers(lsMembers);
  Object[] calls=mapCalls.values().toArray();
  for (  Object call : calls) {
    ((Call)call).onDisconnect(deadAddress);
  }
  System.out.println(this);
}",0.9673384294649062
50736,"private void handleJoinRequest(JoinRequest joinRequest){
  if (getMember(joinRequest.address) != null)   return;
  if (DEBUG) {
  }
  Connection conn=joinRequest.getConnection();
  if (!Config.get().join.multicastConfig.enabled) {
    if (Node.get().getMasterAddress() != null && !isMaster()) {
      sendProcessableTo(new Master(Node.get().getMasterAddress()),conn);
    }
  }
  if (isMaster()) {
    Address newAddress=joinRequest.address;
    MemberInfo newMemberInfo=new MemberInfo(newAddress,joinRequest.nodeType);
    if (!joinInProgress) {
      if (setJoins.add(newMemberInfo)) {
        sendProcessableTo(new Master(Node.get().getMasterAddress()),conn);
        timeToStartJoin=System.currentTimeMillis() + waitTimeBeforeJoin;
      }
 else {
        if (System.currentTimeMillis() > timeToStartJoin) {
          startJoin();
        }
      }
    }
  }
}","private void handleJoinRequest(JoinRequest joinRequest){
  if (getMember(joinRequest.address) != null)   return;
  if (DEBUG) {
  }
  Connection conn=joinRequest.getConnection();
  if (!Config.get().join.multicastConfig.enabled) {
    if (Node.get().getMasterAddress() != null && !isMaster()) {
      sendProcessableTo(new Master(Node.get().getMasterAddress()),conn);
    }
  }
  if (isMaster()) {
    Address newAddress=joinRequest.address;
    if (!joinInProgress) {
      MemberInfo newMemberInfo=new MemberInfo(newAddress,joinRequest.nodeType);
      if (setJoins.add(newMemberInfo)) {
        sendProcessableTo(new Master(Node.get().getMasterAddress()),conn);
        timeToStartJoin=System.currentTimeMillis() + waitTimeBeforeJoin;
      }
 else {
        if (System.currentTimeMillis() > timeToStartJoin) {
          startJoin();
        }
      }
    }
  }
}",0.9676300578034682
50737,"public void onDisconnect(Address deadAddress){
}","@Override public void onDisconnect(Address deadAddress){
}",0.9056603773584906
50738,"public void doLocalOp(){
  arp.process();
  setResult(Boolean.TRUE);
}","@Override public void doLocalOp(){
  arp.process();
  setResult(Boolean.TRUE);
}",0.9333333333333332
50739,"public Data poll(Request request){
  setCurrentTake();
  Data value=blCurrentTake.remove();
  if (request.txnId != -1) {
    MemberImpl backup=null;
    if (request.caller.equals(thisAddress)) {
      backup=getNextMemberAfter(thisAddress,true,1);
    }
 else {
      backup=getNextMemberAfter(request.caller,true,1);
    }
    if (backup != null) {
      if (backup.getAddress().equals(thisAddress)) {
        doTxnBackupPoll(request.txnId,value);
      }
 else {
        sendTxnBackup(backup.getAddress(),value,request.txnId);
      }
    }
  }
  size--;
  long recordId=getRecordId(blCurrentTake.blockId,blCurrentTake.removeIndex);
  doFireEntryEvent(false,value,recordId);
  runScheduledOffer:   while (lsScheduledOfferActions.size() > 0) {
    ScheduledOfferAction offerAction=lsScheduledOfferActions.remove(0);
    ClusterManager.get().deregisterScheduledAction(offerAction);
    if (offerAction.expired()) {
      offerAction.onExpire();
    }
 else {
      boolean consumed=offerAction.consume();
      if (consumed) {
        break runScheduledOffer;
      }
    }
  }
  sendBackup(false,request.caller,null,blCurrentTake.blockId,0);
  if (blCurrentTake.size() == 0 && blCurrentTake.isFull()) {
    fireBlockRemoveEvent(blCurrentTake);
    blCurrentTake=null;
  }
  return value;
}","public Data poll(Request request){
  setCurrentTake();
  Data value=blCurrentTake.remove();
  if (request.txnId != -1) {
    MemberImpl backup=null;
    if (request.caller.equals(thisAddress)) {
      backup=getNextMemberAfter(thisAddress,true,1);
    }
 else {
      backup=getNextMemberAfter(request.caller,true,1);
    }
    if (backup != null) {
      if (backup.getAddress().equals(thisAddress)) {
        doTxnBackupPoll(request.txnId,value);
      }
 else {
        sendTxnBackup(backup.getAddress(),value,request.txnId);
      }
    }
  }
  size--;
  long recordId=getRecordId(blCurrentTake.blockId,blCurrentTake.removeIndex);
  request.recordId=recordId;
  doFireEntryEvent(false,value,recordId);
  runScheduledOffer:   while (lsScheduledOfferActions.size() > 0) {
    ScheduledOfferAction offerAction=lsScheduledOfferActions.remove(0);
    ClusterManager.get().deregisterScheduledAction(offerAction);
    if (offerAction.expired()) {
      offerAction.onExpire();
    }
 else {
      boolean consumed=offerAction.consume();
      if (consumed) {
        break runScheduledOffer;
      }
    }
  }
  sendBackup(false,request.caller,null,blCurrentTake.blockId,0);
  if (blCurrentTake.size() == 0 && blCurrentTake.isFull()) {
    fireBlockRemoveEvent(blCurrentTake);
    blCurrentTake=null;
  }
  return value;
}",0.9888846301264852
50740,"int offer(Request req){
  int addIndex=blCurrentPut.add(req.value);
  long recordId=getRecordId(blCurrentPut.blockId,addIndex);
  doFireEntryEvent(true,req.value,recordId);
  size++;
  while (lsScheduledPollActions.size() > 0) {
    ScheduledAction pollAction=lsScheduledPollActions.remove(0);
    ClusterManager.get().deregisterScheduledAction(pollAction);
    if (pollAction.expired()) {
      pollAction.onExpire();
    }
 else {
      boolean consumed=pollAction.consume();
      if (consumed)       return -1;
    }
  }
  sendBackup(true,req.caller,req.value,blCurrentPut.blockId,addIndex);
  if (blCurrentPut.isFull()) {
    fireBlockFullEvent(blCurrentPut);
    blCurrentPut=null;
    setCurrentPut();
  }
  return addIndex;
}","int offer(Request req){
  int addIndex=blCurrentPut.add(req.value);
  long recordId=getRecordId(blCurrentPut.blockId,addIndex);
  req.recordId=recordId;
  doFireEntryEvent(true,req.value,recordId);
  size++;
  while (lsScheduledPollActions.size() > 0) {
    ScheduledAction pollAction=lsScheduledPollActions.remove(0);
    ClusterManager.get().deregisterScheduledAction(pollAction);
    if (pollAction.expired()) {
      pollAction.onExpire();
    }
 else {
      boolean consumed=pollAction.consume();
      if (consumed)       return -1;
    }
  }
  sendBackup(true,req.caller,req.value,blCurrentPut.blockId,addIndex);
  if (blCurrentPut.isFull()) {
    fireBlockFullEvent(blCurrentPut);
    blCurrentPut=null;
    setCurrentPut();
  }
  return addIndex;
}",0.9832327297116028
50741,"@Override void handleNoneRedoResponse(Invocation inv){
  if (request.operation == OP_B_OFFER && inv.responseType == ResponseTypes.RESPONSE_SUCCESS) {
    if (!zeroBackup) {
      if (getPreviousMemberBefore(thisAddress,true,1).getAddress().equals(inv.conn.getEndPoint())) {
        int itemIndex=(int)inv.longValue;
        if (itemIndex != -1) {
          Q q=getQ(request.name);
          if (request.value == null || request.value.size() == 0) {
            throw new RuntimeException(""String_Node_Str"" + request.value);
          }
          q.doBackup(true,request.value,request.blockId,(int)inv.longValue);
        }
      }
    }
  }
  super.handleNoneRedoResponse(inv);
}","@Override void handleNoneRedoResponse(Invocation inv){
  if (request.operation == OP_B_POLL && inv.responseType == ResponseTypes.RESPONSE_SUCCESS) {
    if (!zeroBackup) {
      if (getPreviousMemberBefore(thisAddress,true,1).getAddress().equals(inv.conn.getEndPoint())) {
        if (inv.value != null) {
          Q q=getQ(inv.name);
          q.doBackup(false,null,request.blockId,0);
        }
      }
    }
  }
  super.handleNoneRedoResponse(inv);
}",0.6902030008826125
50742,"public void run(){
  EventTask eventTask=poll();
  if (eventTask == null)   return;
  logger.log(Level.FINE,expectedRecordId + ""String_Node_Str"" + eventTask.recordId);
  if (expectedRecordId == eventTask.recordId) {
    try {
      eventTask.run();
    }
 catch (    final Throwable e) {
      e.printStackTrace();
    }
    expectedRecordId++;
    while (eventTask != null && mapDelayedEventTasks.size() > 0) {
      eventTask=mapDelayedEventTasks.remove(expectedRecordId);
      if (eventTask != null) {
        eventTask.run();
        expectedRecordId++;
      }
    }
  }
 else   if (eventTask.recordId > expectedRecordId) {
    System.out.println(expectedRecordId + ""String_Node_Str"" + eventTask.recordId);
    mapDelayedEventTasks.put(eventTask.recordId,eventTask);
  }
}","public void run(){
  try {
    if (!collection) {
      key=ThreadContext.get().toObject(dataKey);
    }
    if (dataValue != null) {
      value=ThreadContext.get().toObject(dataValue);
    }
    ListenerManager.get().callListeners(this);
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
}",0.0997229916897507
50743,"void enqueueEvent(final int eventType,final String name,final Data eventKey,final Data eventValue,final Address from,final long recordId){
  final EventTask eventTask=new EventTask(eventType,name,eventKey,eventValue,recordId);
  if (name.startsWith(""String_Node_Str"")) {
    OrderedEventQueue orderedEventQueue=mapOrderedEventQueues.get(name);
    if (orderedEventQueue == null) {
      orderedEventQueue=new OrderedEventQueue(recordId);
      mapOrderedEventQueues.put(name,orderedEventQueue);
    }
    logger.log(Level.FINE,eventTask.recordId + ""String_Node_Str"" + recordId);
    orderedEventQueue.offer(eventTask);
    executeLocally(orderedEventQueue);
  }
 else {
    int eventQueueIndex=-1;
    if (eventKey != null) {
      eventQueueIndex=Math.abs(eventKey.hashCode()) % 100;
    }
 else {
      eventQueueIndex=Math.abs(from.hashCode()) % 100;
    }
    final EventQueue eventQueue=eventQueues[eventQueueIndex];
    final boolean offered=eventQueue.offer(eventTask);
    if (!offered)     throw new RuntimeException(""String_Node_Str"");
    executeLocally(eventQueue);
  }
}","void enqueueEvent(final int eventType,final String name,final Data eventKey,final Data eventValue,final Address from,final long recordId){
  final EventTask eventTask=new EventTask(eventType,name,eventKey,eventValue,recordId);
  if (name.startsWith(""String_Node_Str"")) {
    OrderedEventQueue orderedEventQueue=mapOrderedEventQueues.get(name);
    if (orderedEventQueue == null) {
      orderedEventQueue=new OrderedEventQueue(recordId);
      mapOrderedEventQueues.put(name,orderedEventQueue);
    }
    logger.log(Level.FINE,eventTask.recordId + ""String_Node_Str"" + recordId);
    orderedEventQueue.offer(eventTask);
    executeLocally(orderedEventQueue);
  }
 else {
    int eventQueueIndex=-1;
    if (eventKey != null) {
      eventQueueIndex=Math.abs(eventKey.hashCode()) % EVENT_QUEUE_COUNT;
    }
 else {
      eventQueueIndex=Math.abs(from.hashCode()) % EVENT_QUEUE_COUNT;
    }
    final EventQueue eventQueue=eventQueues[eventQueueIndex];
    final int size=eventQueue.offerRunnable(eventTask);
    if (size == 1)     executeLocally(eventQueue);
  }
}",0.9081585081585082
50744,"protected BaseManager(){
  thisAddress=Node.get().address;
  thisMember=Node.get().localMember;
  for (int i=0; i < 100; i++) {
    eventQueues[i]=new EventQueue();
  }
}","protected BaseManager(){
  thisAddress=Node.get().address;
  thisMember=Node.get().localMember;
  for (int i=0; i < EVENT_QUEUE_COUNT; i++) {
    eventQueues[i]=new EventQueue();
  }
}",0.943502824858757
50745,"protected boolean sendResponseFailure(final Invocation inv,final Address address){
  final Connection conn=ConnectionManager.get().getConnection(address);
  inv.conn=conn;
  return sendResponseFailure(inv);
}","protected boolean sendResponseFailure(final Invocation inv,final Address address){
  inv.conn=ConnectionManager.get().getConnection(address);
  return sendResponseFailure(inv);
}",0.911917098445596
50746,"public static Address pickAddress(final ServerSocketChannel serverSocketChannel) throws Exception {
  String currentAddress=null;
  try {
    final Config config=Config.get();
    final String localAddress=System.getProperty(""String_Node_Str"");
    currentAddress=InetAddress.getByName(localAddress).getHostAddress().trim();
    if (currentAddress == null || currentAddress.length() == 0 || currentAddress.equalsIgnoreCase(""String_Node_Str"") || currentAddress.equals(""String_Node_Str"")) {
      boolean matchFound=false;
      final Enumeration<NetworkInterface> enums=NetworkInterface.getNetworkInterfaces();
      interfaces:       while (enums.hasMoreElements()) {
        final NetworkInterface ni=enums.nextElement();
        final Enumeration<InetAddress> e=ni.getInetAddresses();
        final boolean isUp=invoke(true,1.6,ni,""String_Node_Str"");
        final boolean supportsMulticast=invoke(true,1.6,ni,""String_Node_Str"");
        while (e.hasMoreElements()) {
          final InetAddress inetAddress=e.nextElement();
          if (inetAddress instanceof Inet4Address) {
            final byte[] ip=inetAddress.getAddress();
            final String address=inetAddress.getHostAddress();
            if (!inetAddress.isLoopbackAddress()) {
              currentAddress=address;
              if (config.interfaces.enabled) {
                if (matchAddress(address)) {
                  matchFound=true;
                  break interfaces;
                }
              }
 else {
                break interfaces;
              }
            }
          }
        }
      }
      if (config.interfaces.enabled && !matchFound) {
        String msg=""String_Node_Str"";
        msg+=""String_Node_Str"";
        logger.log(Level.SEVERE,msg);
        Node.get().dumpCore(null);
        return null;
      }
    }
    final InetAddress inetAddress=InetAddress.getByName(currentAddress);
    ServerSocket serverSocket=serverSocketChannel.socket();
    serverSocket.setReuseAddress(false);
    InetSocketAddress isa=null;
    int port=config.port;
    socket:     for (int i=0; i < 100; i++) {
      try {
        isa=new InetSocketAddress(inetAddress,port);
        serverSocket.bind(isa,100);
        break socket;
      }
 catch (      final Exception e) {
        serverSocket=serverSocketChannel.socket();
        serverSocket.setReuseAddress(false);
        port++;
        continue socket;
      }
    }
    serverSocketChannel.configureBlocking(false);
    final Address selectedAddress=new Address(currentAddress,port);
    return selectedAddress;
  }
 catch (  final Exception e) {
    Node.get().dumpCore(e);
    e.printStackTrace();
    throw e;
  }
}","public static Address pickAddress(final ServerSocketChannel serverSocketChannel) throws Exception {
  String currentAddress=null;
  try {
    final Config config=Config.get();
    final String localAddress=System.getProperty(""String_Node_Str"");
    currentAddress=InetAddress.getByName(localAddress).getHostAddress().trim();
    if (currentAddress == null || currentAddress.length() == 0 || currentAddress.equalsIgnoreCase(""String_Node_Str"") || currentAddress.equals(""String_Node_Str"")) {
      boolean matchFound=false;
      final Enumeration<NetworkInterface> enums=NetworkInterface.getNetworkInterfaces();
      interfaces:       while (enums.hasMoreElements()) {
        final NetworkInterface ni=enums.nextElement();
        final Enumeration<InetAddress> e=ni.getInetAddresses();
        while (e.hasMoreElements()) {
          final InetAddress inetAddress=e.nextElement();
          if (inetAddress instanceof Inet4Address) {
            final String address=inetAddress.getHostAddress();
            if (!inetAddress.isLoopbackAddress()) {
              currentAddress=address;
              if (config.interfaces.enabled) {
                if (matchAddress(address)) {
                  matchFound=true;
                  break interfaces;
                }
              }
 else {
                break interfaces;
              }
            }
          }
        }
      }
      if (config.interfaces.enabled && !matchFound) {
        String msg=""String_Node_Str"";
        msg+=""String_Node_Str"";
        logger.log(Level.SEVERE,msg);
        Node.get().dumpCore(null);
        return null;
      }
    }
    final InetAddress inetAddress=InetAddress.getByName(currentAddress);
    ServerSocket serverSocket=serverSocketChannel.socket();
    serverSocket.setReuseAddress(false);
    InetSocketAddress isa=null;
    int port=config.port;
    socket:     for (int i=0; i < 100; i++) {
      try {
        isa=new InetSocketAddress(inetAddress,port);
        serverSocket.bind(isa,100);
        break socket;
      }
 catch (      final Exception e) {
        serverSocket=serverSocketChannel.socket();
        serverSocket.setReuseAddress(false);
        port++;
        continue socket;
      }
    }
    serverSocketChannel.configureBlocking(false);
    final Address selectedAddress=new Address(currentAddress,port);
    return selectedAddress;
  }
 catch (  final Exception e) {
    Node.get().dumpCore(e);
    e.printStackTrace();
    throw e;
  }
}",0.9612161372052233
50747,"public static String createCoreDump(){
  final StringBuilder sb=new StringBuilder();
  addLine(sb,""String_Node_Str"");
  addLine(sb,""String_Node_Str"" + Config.get().urlConfig);
  addLine(sb,Config.get().xmlConfig);
  final Set<Object> propKeys=System.getProperties().keySet();
  addLine(sb,""String_Node_Str"");
  for (  final Object key : propKeys) {
    addLine(sb,key + ""String_Node_Str"" + System.getProperty((String)key));
  }
  try {
    final Enumeration<NetworkInterface> enums=NetworkInterface.getNetworkInterfaces();
    while (enums.hasMoreElements()) {
      final NetworkInterface ni=enums.nextElement();
      sb.append(""String_Node_Str"");
      addLine(sb,""String_Node_Str"" + ni.getName() + ""String_Node_Str"");
      final boolean isUp=invoke(true,1.6,ni,""String_Node_Str"");
      final boolean supportsMulticast=invoke(true,1.6,ni,""String_Node_Str"");
      addLine(sb,""String_Node_Str"" + ni.getDisplayName());
      addLine(sb,""String_Node_Str"" + isUp);
      addLine(sb,""String_Node_Str"" + supportsMulticast);
      final Enumeration<InetAddress> e=ni.getInetAddresses();
      while (e.hasMoreElements()) {
        try {
          final InetAddress inetAddress=e.nextElement();
          addLine(1,sb,""String_Node_Str"");
          final boolean ipv4=(inetAddress instanceof Inet4Address);
          final byte[] ip=inetAddress.getAddress();
          final String address=inetAddress.getHostAddress();
          addLine(1,sb,""String_Node_Str"" + inetAddress);
          addLine(1,sb,""String_Node_Str"" + address);
          addLine(1,sb,""String_Node_Str"" + ipv4);
          if (ipv4) {
            addLine(1,sb,""String_Node_Str"" + new Address(address,-1,true));
          }
          addLine(1,sb,""String_Node_Str"" + inetAddress.isMulticastAddress());
          addLine(1,sb,""String_Node_Str"" + inetAddress.isLoopbackAddress());
          if (Config.get().interfaces.enabled) {
            addLine(1,sb,""String_Node_Str"" + matchAddress(address));
          }
        }
 catch (        final Exception ex) {
          addLine(1,sb,""String_Node_Str"" + ex.getMessage());
        }
      }
    }
  }
 catch (  final Exception e1) {
    e1.printStackTrace();
  }
  return sb.toString();
}","public static String createCoreDump(){
  final StringBuilder sb=new StringBuilder();
  addLine(sb,""String_Node_Str"");
  addLine(sb,""String_Node_Str"" + Config.get().urlConfig);
  addLine(sb,Config.get().xmlConfig);
  final Set<Object> propKeys=System.getProperties().keySet();
  addLine(sb,""String_Node_Str"");
  for (  final Object key : propKeys) {
    addLine(sb,key + ""String_Node_Str"" + System.getProperty((String)key));
  }
  try {
    final Enumeration<NetworkInterface> enums=NetworkInterface.getNetworkInterfaces();
    while (enums.hasMoreElements()) {
      final NetworkInterface ni=enums.nextElement();
      sb.append(""String_Node_Str"");
      addLine(sb,""String_Node_Str"" + ni.getName() + ""String_Node_Str"");
      final boolean isUp=invoke(true,1.6,ni,""String_Node_Str"");
      final boolean supportsMulticast=invoke(true,1.6,ni,""String_Node_Str"");
      addLine(sb,""String_Node_Str"" + ni.getDisplayName());
      addLine(sb,""String_Node_Str"" + isUp);
      addLine(sb,""String_Node_Str"" + supportsMulticast);
      final Enumeration<InetAddress> e=ni.getInetAddresses();
      while (e.hasMoreElements()) {
        try {
          final InetAddress inetAddress=e.nextElement();
          addLine(1,sb,""String_Node_Str"");
          final boolean ipv4=(inetAddress instanceof Inet4Address);
          final String address=inetAddress.getHostAddress();
          addLine(1,sb,""String_Node_Str"" + inetAddress);
          addLine(1,sb,""String_Node_Str"" + address);
          addLine(1,sb,""String_Node_Str"" + ipv4);
          if (ipv4) {
            addLine(1,sb,""String_Node_Str"" + new Address(address,-1,true));
          }
          addLine(1,sb,""String_Node_Str"" + inetAddress.isMulticastAddress());
          addLine(1,sb,""String_Node_Str"" + inetAddress.isLoopbackAddress());
          if (Config.get().interfaces.enabled) {
            addLine(1,sb,""String_Node_Str"" + matchAddress(address));
          }
        }
 catch (        final Exception ex) {
          addLine(1,sb,""String_Node_Str"" + ex.getMessage());
        }
      }
    }
  }
 catch (  final Exception e1) {
    e1.printStackTrace();
  }
  return sb.toString();
}",0.9880129091747348
50748,"public void doRemoveBlock(Q q,Address originalRemover,int blockId){
  List<Block> lsBlocks=q.lsBlocks;
  Block blockRemoved=q.removeBlock(blockId);
  if (blockRemoved != null) {
    if (isMaster()) {
      sendAddBlockMessageToOthers(blockRemoved,-1,originalRemover,false);
    }
  }
}","public void doRemoveBlock(Q q,Address originalRemover,int blockId){
  Block blockRemoved=q.removeBlock(blockId);
  if (blockRemoved != null) {
    if (isMaster()) {
      sendAddBlockMessageToOthers(blockRemoved,-1,originalRemover,false);
    }
  }
}",0.8672897196261682
50749,"public void onExpire(){
  request.response=Boolean.FALSE;
  returnScheduledAsBoolean(request);
}","@Override public void onExpire(){
  request.response=Boolean.FALSE;
  returnScheduledAsBoolean(request);
}",0.9504950495049505
50750,"public String[] getValueNames(){
  checkState();
  return (String[])atts.keySet().toArray();
}","public String[] getValueNames(){
  checkState();
  return atts.keySet().toArray(new String[atts.size()]);
}",0.835820895522388
50751,"public synchronized void removeListener(String name,Object listener,Object key){
  Iterator<ListenerItem> it=lsListeners.iterator();
  for (; it.hasNext(); ) {
    ListenerItem listenerItem=it.next();
    if (listener == listenerItem.listener) {
      if (key == null) {
        if (listenerItem.key == null) {
          registerListener(name,null,false,false);
          it.remove();
        }
      }
 else       if (key.equals(listenerItem.key)) {
        registerListener(name,key,false,false);
        it.remove();
      }
    }
  }
}","public synchronized void removeListener(String name,Object listener,Object key){
  Iterator<ListenerItem> it=lsListeners.iterator();
  for (; it.hasNext(); ) {
    ListenerItem listenerItem=it.next();
    if (listener == listenerItem.listener) {
      if (key == null) {
        if (listenerItem.key == null) {
          registerListener(name,null,false,false);
          lsListeners.remove(listenerItem);
        }
      }
 else       if (key.equals(listenerItem.key)) {
        registerListener(name,key,false,false);
        lsListeners.remove(listenerItem);
      }
    }
  }
}",0.9553571428571428
50752,"public void setTimeout(long timeout){
  this.timeout=timeout;
  if (timeout > -1) {
    timeToExpire=System.currentTimeMillis() + timeout;
  }
 else   timeout=-1;
}","public void setTimeout(long timeout){
  if (timeout > -1) {
    this.timeout=timeout;
    timeToExpire=System.currentTimeMillis() + timeout;
  }
 else {
    this.timeout=-1;
  }
}",0.8279883381924198
50753,"public boolean containsValue(Request req){
  Data value=req.value;
  Collection<Record> records=mapRecords.values();
  for (  Record record : records) {
    if (value.equals(record.getValue()))     return true;
  }
  return false;
}","public boolean containsValue(Request req){
  Data value=req.value;
  Collection<Record> records=mapRecords.values();
  for (  Record record : records) {
    if (record.getValue() == null)     return false;
    if (value.equals(record.getValue()))     return true;
  }
  return false;
}",0.8471953578336557
50754,"public void handle(Invocation inv){
  if (inv.operation == OP_CMAP_GET) {
    handleGet(inv);
  }
 else   if (inv.operation == OP_CMAP_PUT) {
    handlePut(inv);
  }
 else   if (inv.operation == OP_CMAP_BACKUP_ADD) {
    handleBackupAdd(inv);
  }
 else   if (inv.operation == OP_CMAP_REMOVE) {
    handleRemove(inv);
  }
 else   if (inv.operation == OP_CMAP_BACKUP_REMOVE) {
    handleBackupRemove(inv);
  }
 else   if (inv.operation == OP_CMAP_LOCK) {
    handleLock(inv);
  }
 else   if (inv.operation == OP_CMAP_UNLOCK) {
    handleLock(inv);
  }
 else   if (inv.operation == OP_CMAP_BACKUP_LOCK) {
    handleBackupLock(inv);
  }
 else   if (inv.operation == OP_CMAP_READ) {
    handleRead(inv);
  }
 else   if (inv.operation == OP_CMAP_SIZE) {
    handleSize(inv);
  }
 else   if (inv.operation == OP_CMAP_ADD_TO_LIST || inv.operation == OP_CMAP_ADD_TO_SET) {
    handleAdd(inv);
  }
 else   if (inv.operation == OP_CMAP_CONTAINS_KEY) {
    handleContains(true,inv);
  }
 else   if (inv.operation == OP_CMAP_CONTAINS_VALUE) {
    handleContains(false,inv);
  }
 else   if (inv.operation == OP_CMAP_BLOCK_INFO) {
    handleBlockInfo(inv);
  }
 else   if (inv.operation == OP_CMAP_BLOCKS) {
    handleBlocks(inv);
  }
 else   if (inv.operation == OP_CMAP_PUT_IF_ABSENT) {
    handlePut(inv);
  }
 else   if (inv.operation == OP_CMAP_REPLACE_IF_NOT_NULL) {
    handlePut(inv);
  }
 else   if (inv.operation == OP_CMAP_MIGRATION_COMPLETE) {
    doMigrationComplete(inv.conn.getEndPoint());
  }
 else   if (inv.operation == OP_CMAP_MIGRATE_RECORD) {
    handleMigrateRecord(inv);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + inv.operation);
  }
}","public void handle(Invocation inv){
  if (inv.operation == OP_CMAP_GET) {
    handleGet(inv);
  }
 else   if (inv.operation == OP_CMAP_PUT) {
    handlePut(inv);
  }
 else   if (inv.operation == OP_CMAP_BACKUP_ADD) {
    handleBackupAdd(inv);
  }
 else   if (inv.operation == OP_CMAP_REMOVE) {
    handleRemove(inv);
  }
 else   if (inv.operation == OP_CMAP_BACKUP_REMOVE) {
    handleBackupRemove(inv);
  }
 else   if (inv.operation == OP_CMAP_LOCK) {
    handleLock(inv);
  }
 else   if (inv.operation == OP_CMAP_LOCK_RETURN_OLD) {
    handleLock(inv);
  }
 else   if (inv.operation == OP_CMAP_UNLOCK) {
    handleLock(inv);
  }
 else   if (inv.operation == OP_CMAP_BACKUP_LOCK) {
    handleBackupLock(inv);
  }
 else   if (inv.operation == OP_CMAP_READ) {
    handleRead(inv);
  }
 else   if (inv.operation == OP_CMAP_SIZE) {
    handleSize(inv);
  }
 else   if (inv.operation == OP_CMAP_ADD_TO_LIST || inv.operation == OP_CMAP_ADD_TO_SET) {
    handleAdd(inv);
  }
 else   if (inv.operation == OP_CMAP_CONTAINS_KEY) {
    handleContains(true,inv);
  }
 else   if (inv.operation == OP_CMAP_CONTAINS_VALUE) {
    handleContains(false,inv);
  }
 else   if (inv.operation == OP_CMAP_BLOCK_INFO) {
    handleBlockInfo(inv);
  }
 else   if (inv.operation == OP_CMAP_BLOCKS) {
    handleBlocks(inv);
  }
 else   if (inv.operation == OP_CMAP_PUT_IF_ABSENT) {
    handlePut(inv);
  }
 else   if (inv.operation == OP_CMAP_REPLACE_IF_NOT_NULL) {
    handlePut(inv);
  }
 else   if (inv.operation == OP_CMAP_MIGRATION_COMPLETE) {
    doMigrationComplete(inv.conn.getEndPoint());
  }
 else   if (inv.operation == OP_CMAP_MIGRATE_RECORD) {
    handleMigrateRecord(inv);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + inv.operation);
  }
}",0.9762254182565306
50755,"final void doLock(Request request){
  boolean lock=(request.operation == OP_CMAP_LOCK) ? true : false;
  if (!lock) {
    boolean unlocked=true;
    Record record=recordExist(request);
    if (DEBUG) {
      log(request.operation + ""String_Node_Str"" + record);
    }
    if (record != null) {
      unlocked=record.unlock(request.lockThreadId,request.lockAddress);
      if (unlocked) {
        sendLockBackup(record);
      }
    }
    if (request.local) {
      if (unlocked)       request.response=Boolean.TRUE;
 else       request.response=Boolean.FALSE;
    }
  }
 else   if (!testLock(request)) {
    if (request.hasEnoughTimeToSchedule()) {
      final Record record=ensureRecord(request);
      final Request reqScheduled=(request.local) ? request : request.softCopy();
      if (request.operation == OP_CMAP_LOCK_RETURN_OLD) {
        reqScheduled.value=ThreadContext.get().hardCopy(record.getValue());
      }
      if (DEBUG) {
        log(""String_Node_Str"");
      }
      record.addScheduledAction(new ScheduledLockAction(reqScheduled,record));
      request.scheduled=true;
    }
 else {
      request.response=Boolean.FALSE;
    }
  }
 else {
    if (DEBUG) {
      log(""String_Node_Str"");
    }
    Record rec=ensureRecord(request);
    if (request.operation == OP_CMAP_LOCK_RETURN_OLD) {
      request.value=ThreadContext.get().hardCopy(rec.getValue());
    }
    rec.lock(request.lockThreadId,request.lockAddress);
    sendLockBackup(rec);
    request.response=Boolean.TRUE;
  }
}","final void doLock(Request request){
  boolean lock=(request.operation == OP_CMAP_LOCK || request.operation == OP_CMAP_LOCK_RETURN_OLD) ? true : false;
  if (!lock) {
    boolean unlocked=true;
    Record record=recordExist(request);
    if (DEBUG) {
      log(request.operation + ""String_Node_Str"" + record);
    }
    if (record != null) {
      unlocked=record.unlock(request.lockThreadId,request.lockAddress);
      if (unlocked) {
        sendLockBackup(record);
      }
    }
    if (request.local) {
      if (unlocked)       request.response=Boolean.TRUE;
 else       request.response=Boolean.FALSE;
    }
  }
 else   if (!testLock(request)) {
    if (request.hasEnoughTimeToSchedule()) {
      final Record record=ensureRecord(request);
      final Request reqScheduled=(request.local) ? request : request.softCopy();
      if (request.operation == OP_CMAP_LOCK_RETURN_OLD) {
        reqScheduled.value=ThreadContext.get().hardCopy(record.getValue());
      }
      if (DEBUG) {
        log(""String_Node_Str"");
      }
      record.addScheduledAction(new ScheduledLockAction(reqScheduled,record));
      request.scheduled=true;
    }
 else {
      request.response=Boolean.FALSE;
    }
  }
 else {
    if (DEBUG) {
      log(""String_Node_Str"");
    }
    Record rec=ensureRecord(request);
    if (request.operation == OP_CMAP_LOCK_RETURN_OLD) {
      request.value=ThreadContext.get().hardCopy(rec.getValue());
    }
    rec.lock(request.lockThreadId,request.lockAddress);
    sendLockBackup(rec);
    request.response=Boolean.TRUE;
  }
}",0.3508541392904074
50756,"public Object removeIfSame(String name,Object key,Object value,long timeout,long txnId){
  return objectCall(OP_CMAP_REMOVE_IF_SAME,name,key,value,timeout,txnId,-1);
}","public Object removeIfSame(String name,Object key,Object value,long timeout,long txnId){
  return txnalRemove(OP_CMAP_REMOVE_IF_SAME,name,key,value,timeout,txnId);
}",0.9457831325301204
50757,"public boolean containsValue(Object value){
  check(value);
  MContainsValue mContainsValue=ConcurrentMapManager.get().new MContainsValue();
  return mContainsValue.containsValue(name,value,-1);
}","public boolean containsValue(Object value){
  check(value);
  TransactionImpl txn=ThreadContext.get().txn;
  if (txn != null) {
    if (txn.containsValue(name,value))     return true;
  }
  MContainsValue mContainsValue=ConcurrentMapManager.get().new MContainsValue();
  return mContainsValue.containsValue(name,value,-1);
}",0.7538461538461538
50758,"public boolean containsKey(Object key){
  check(key);
  MContainsKey mContainsKey=ConcurrentMapManager.get().new MContainsKey();
  return mContainsKey.containsKey(name,key,-1);
}","public boolean containsKey(Object key){
  check(key);
  TransactionImpl txn=ThreadContext.get().txn;
  if (txn != null) {
    if (txn.has(name,key)) {
      Object value=txn.get(name,key);
      if (value == null)       return false;
 else       return true;
    }
  }
  MContainsKey mContainsKey=ConcurrentMapManager.get().new MContainsKey();
  return mContainsKey.containsKey(name,key,-1);
}",0.6234676007005254
50759,"public Object attachRemoveOp(final String name,final Object key,final Object value,final boolean newRecord){
  TxnRecord rec=findTxnRecord(name,key);
  Object oldValue=null;
  if (rec == null) {
    rec=new TxnRecord(name,key,value,newRecord);
    rec.removed=true;
    lsTxnRecords.add(rec);
    return null;
  }
 else {
    oldValue=rec.value;
    rec.value=value;
  }
  rec.removed=true;
  return oldValue;
}","public Object attachRemoveOp(final String name,final Object key,final Object value,final boolean newRecord){
  TxnRecord rec=findTxnRecord(name,key);
  Object oldValue=null;
  if (rec == null) {
    rec=new TxnRecord(name,key,value,newRecord);
    rec.removed=true;
    lsTxnRecords.add(rec);
  }
 else {
    oldValue=rec.value;
    rec.value=value;
  }
  rec.removed=true;
  return oldValue;
}",0.9788819875776398
50760,"public int size(final String name){
  int size=0;
  for (  final TxnRecord txnRecord : lsTxnRecords) {
    if (txnRecord.name.equals(name)) {
      if (txnRecord.removed) {
        if (!txnRecord.newRecord) {
          if (txnRecord.map)           size--;
        }
      }
 else {
        size++;
      }
    }
  }
  return size;
}","public int size(final String name){
  int size=0;
  for (  final TxnRecord txnRecord : lsTxnRecords) {
    if (txnRecord.name.equals(name)) {
      if (txnRecord.removed) {
        if (!txnRecord.newRecord) {
          if (txnRecord.map) {
            size--;
          }
        }
      }
 else {
        size++;
      }
    }
  }
  return size;
}",0.976470588235294
50761,"void registerInvocationProcessor(int operation,InvocationProcessor invocationProcessor){
  if (invProcessors[operation] != null) {
    logger.log(Level.SEVERE,operation + ""String_Node_Str"" + invProcessors[operation]);
  }
  invProcessors[operation]=invocationProcessor;
}","void registerInvocationProcessor(int operation,InvocationProcessor invocationProcessor){
  if (invocationProcessors[operation] != null) {
    logger.log(Level.SEVERE,operation + ""String_Node_Str"" + invocationProcessors[operation]);
  }
  invocationProcessors[operation]=invocationProcessor;
}",0.9626998223801064
50762,"public void process(final Object obj){
  final long processStart=System.nanoTime();
  if (obj instanceof Invocation) {
    final Invocation inv=(Invocation)obj;
    final MemberImpl memberFrom=ClusterManager.get().getMember(inv.conn.getEndPoint());
    if (memberFrom != null) {
      memberFrom.didRead();
    }
    InvocationProcessor invocationProcessor=invProcessors[inv.operation];
    if (invocationProcessor == null) {
      logger.log(Level.SEVERE,""String_Node_Str"" + inv.operation);
    }
    invocationProcessor.process(inv);
  }
 else   if (obj instanceof Processable) {
    ((Processable)obj).process();
  }
 else {
    logger.log(Level.SEVERE,""String_Node_Str"" + obj);
  }
  final long processEnd=System.nanoTime();
  final long elipsedTime=processEnd - processStart;
  totalProcessTime+=elipsedTime;
  final long duration=(processEnd - start);
  if (duration > UTILIZATION_CHECK_INTERVAL) {
    if (DEBUG) {
      logger.log(Level.FINEST,""String_Node_Str"" + ((totalProcessTime * 100) / duration) + ""String_Node_Str"");
    }
    start=processEnd;
    totalProcessTime=0;
  }
}","public void process(final Object obj){
  final long processStart=System.nanoTime();
  if (obj instanceof Invocation) {
    final Invocation inv=(Invocation)obj;
    final MemberImpl memberFrom=ClusterManager.get().getMember(inv.conn.getEndPoint());
    if (memberFrom != null) {
      memberFrom.didRead();
    }
    InvocationProcessor invocationProcessor=invocationProcessors[inv.operation];
    if (invocationProcessor == null) {
      logger.log(Level.SEVERE,""String_Node_Str"" + inv.operation);
    }
    invocationProcessor.process(inv);
  }
 else   if (obj instanceof Processable) {
    ((Processable)obj).process();
  }
 else {
    logger.log(Level.SEVERE,""String_Node_Str"" + obj);
  }
  final long processEnd=System.nanoTime();
  final long elipsedTime=processEnd - processStart;
  totalProcessTime+=elipsedTime;
  final long duration=(processEnd - start);
  if (duration > UTILIZATION_CHECK_INTERVAL) {
    if (DEBUG) {
      logger.log(Level.FINEST,""String_Node_Str"" + ((totalProcessTime * 100) / duration) + ""String_Node_Str"");
    }
    start=processEnd;
    totalProcessTime=0;
  }
}",0.9967963386727688
50763,"public SimpleDataEntry(final String name,final int blockId,final Data key,final Data value,final int copyCount){
  super();
  this.blockId=blockId;
  this.keyData=key;
  this.name=name;
  this.valueData=value;
  this.copyCount=copyCount;
}","public SimpleDataEntry(final String name,final Object key,final Object value){
  this.key=key;
  this.value=value;
  this.name=name;
}",0.5576407506702413
50764,"public void run(){
  while (running) {
    Object obj=null;
    try {
      lsBuffer.clear();
      queue.drainTo(lsBuffer);
      final int size=lsBuffer.size();
      if (size > 0) {
        for (int i=0; i < size; i++) {
          obj=lsBuffer.get(i);
          checkPeriodics();
          process(obj);
        }
        lsBuffer.clear();
      }
 else {
        obj=queue.poll(100,TimeUnit.MILLISECONDS);
        checkPeriodics();
        if (obj != null) {
          process(obj);
        }
      }
    }
 catch (    final InterruptedException e) {
      Node.get().handleInterruptedException(Thread.currentThread(),e);
    }
catch (    final Throwable e) {
      if (DEBUG) {
        logger.log(Level.FINEST,e + ""String_Node_Str"" + e+ ""String_Node_Str""+ obj);
      }
    }
  }
}","public void run(){
  while (running) {
    Object obj=null;
    try {
      lsBuffer.clear();
      queue.drainTo(lsBuffer);
      final int size=lsBuffer.size();
      if (size > 0) {
        for (int i=0; i < size; i++) {
          obj=lsBuffer.get(i);
          checkPeriodics();
          process(obj);
        }
        lsBuffer.clear();
      }
 else {
        obj=queue.poll(100,TimeUnit.MILLISECONDS);
        checkPeriodics();
        if (obj != null) {
          process(obj);
        }
      }
    }
 catch (    final InterruptedException e) {
      Node.get().handleInterruptedException(Thread.currentThread(),e);
    }
catch (    final Throwable e) {
      if (DEBUG) {
        logger.log(Level.FINEST,e + ""String_Node_Str"" + e+ ""String_Node_Str""+ obj);
        logger.log(Level.FINEST,e.getMessage(),e);
      }
    }
  }
}",0.9525569932224276
50765,"public void shutdown(){
  executor.purge();
  executor.shutdownNow();
  eventFireExecutor.shutdownNow();
}","public void shutdown(){
  executor.purge();
  executor.shutdownNow();
}",0.8022598870056498
50766,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  Data data=(Data)obj;
  if (data.size != size)   return false;
  int bufferCount=lsData.size();
  if (bufferCount != data.lsData.size())   return false;
  for (int i=0; i < bufferCount; i++) {
    ByteBuffer thisBB=lsData.get(i);
    byte[] thisBuffer=thisBB.array();
    byte[] dataBuffer=data.lsData.get(i).array();
    int limit=thisBB.limit();
    for (int b=0; b < limit; b++) {
      if (thisBuffer[b] != dataBuffer[b])       return false;
    }
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (obj == null)   return false;
  if (this == obj)   return true;
  Data data=(Data)obj;
  if (data.size != size)   return false;
  int bufferCount=lsData.size();
  if (bufferCount != data.lsData.size())   return false;
  for (int i=0; i < bufferCount; i++) {
    ByteBuffer thisBB=lsData.get(i);
    byte[] thisBuffer=thisBB.array();
    byte[] dataBuffer=data.lsData.get(i).array();
    int limit=thisBB.limit();
    for (int b=0; b < limit; b++) {
      if (thisBuffer[b] != dataBuffer[b])       return false;
    }
  }
  return true;
}",0.9692712906057944
50767,"Address getTarget(String name,Data key){
  int blockId=getBlockId(key);
  Block block=mapBlocks.get(blockId);
  if (block == null) {
    if (isMaster() && !isSuperClient()) {
      block=getOrCreateBlock(blockId);
      block.owner=thisAddress;
    }
 else     return null;
  }
  if (block.owner == null)   return null;
  if (block.owner.equals(thisAddress)) {
    if (block.isMigrating()) {
      if (name == null)       return block.migrationAddress;
      CMap map=getMap(name);
      Record record=map.getRecord(key);
      if (record == null)       return block.migrationAddress;
 else {
        Address recordOwner=record.getOwner();
        if (recordOwner == null)         return thisAddress;
        if ((!recordOwner.equals(thisAddress)) && (!recordOwner.equals(block.migrationAddress))) {
          record.setOwner(thisAddress);
        }
        return record.getOwner();
      }
    }
  }
 else   if (thisAddress.equals(block.migrationAddress)) {
    if (name == null)     return thisAddress;
    CMap map=getMap(name);
    Record record=map.getRecord(key);
    if (record == null)     return thisAddress;
 else     return record.getOwner();
  }
  return block.owner;
}","Address getTarget(String name,Data key){
  int blockId=getBlockId(key);
  Block block=mapBlocks.get(blockId);
  if (block == null) {
    if (isMaster() && !isSuperClient()) {
      block=getOrCreateBlock(blockId);
      block.owner=thisAddress;
    }
 else     return null;
  }
  if (block.isMigrating())   return null;
  if (block.owner == null)   return null;
  if (block.owner.equals(thisAddress)) {
    if (block.isMigrating()) {
      if (name == null)       return block.migrationAddress;
      CMap map=getMap(name);
      Record record=map.getRecord(key);
      if (record == null)       return block.migrationAddress;
 else {
        Address recordOwner=record.getOwner();
        if (recordOwner == null)         return thisAddress;
        if ((!recordOwner.equals(thisAddress)) && (!recordOwner.equals(block.migrationAddress))) {
          record.setOwner(thisAddress);
        }
        return record.getOwner();
      }
    }
  }
 else   if (thisAddress.equals(block.migrationAddress)) {
    if (name == null)     return thisAddress;
    CMap map=getMap(name);
    Record record=map.getRecord(key);
    if (record == null)     return thisAddress;
 else     return record.getOwner();
  }
  return block.owner;
}",0.9825436408977556
50768,"private void sendMigrationComplete(){
  for (  MemberImpl member : lsMembers) {
    if (!member.localMember()) {
      Invocation inv=obtainServiceInvocation();
      inv.name=""String_Node_Str"";
      inv.operation=OP_CMAP_MIGRATION_COMPLETE;
      boolean sent=send(inv,member.getAddress());
      if (!sent) {
        inv.returnToContainer();
      }
    }
  }
}","private void sendMigrationComplete(){
  for (  MemberImpl member : lsMembers) {
    if (!member.localMember()) {
      sendProcessableTo(new MigrationComplete(thisAddress),member.getAddress());
    }
  }
}",0.5553602811950791
50769,"private void doMigrationComplete(Address from){
  logger.log(Level.FINEST,""String_Node_Str"" + from);
  Collection<Block> blocks=mapBlocks.values();
  for (  Block block : blocks) {
    if (from.equals(block.owner)) {
      if (block.isMigrating()) {
        block.owner=block.migrationAddress;
        block.migrationAddress=null;
      }
    }
  }
  if (isMaster() && !from.equals(thisAddress)) {
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember() || !from.equals(member.getAddress())) {
        Invocation inv=obtainServiceInvocation();
        inv.name=""String_Node_Str"";
        inv.operation=OP_CMAP_MIGRATION_COMPLETE;
        boolean sent=send(inv,member.getAddress());
        if (!sent) {
          inv.returnToContainer();
        }
      }
    }
  }
}","private void doMigrationComplete(Address from){
  logger.log(Level.FINEST,""String_Node_Str"" + from);
  Collection<Block> blocks=mapBlocks.values();
  for (  Block block : blocks) {
    if (from.equals(block.owner)) {
      if (block.isMigrating()) {
        block.owner=block.migrationAddress;
        block.migrationAddress=null;
      }
    }
  }
  if (isMaster() && !from.equals(thisAddress)) {
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember() && !from.equals(member.getAddress())) {
        sendProcessableTo(new MigrationComplete(from),member.getAddress());
      }
    }
  }
}",0.7771428571428571
50770,"final private boolean writeInvocation(final Connection conn,final Invocation inv){
  if (!conn.live()) {
    inv.returnToContainer();
    return false;
  }
  final MemberImpl memberImpl=getMember(conn.getEndPoint());
  if (memberImpl != null) {
    memberImpl.didWrite();
  }
  inv.currentCallCount=mapCalls.size();
  inv.write();
  conn.getWriteHandler().enqueueInvocation(inv);
  return true;
}","final private boolean writeInvocation(final Connection conn,final Invocation inv){
  if (!conn.live()) {
    return false;
  }
  final MemberImpl memberImpl=getMember(conn.getEndPoint());
  if (memberImpl != null) {
    memberImpl.didWrite();
  }
  inv.currentCallCount=mapCalls.size();
  inv.write();
  conn.getWriteHandler().enqueueInvocation(inv);
  return true;
}",0.9619921363040628
50771,"public boolean isTerminated(){
  return false;
}","public boolean isTerminated(){
  throw new UnsupportedOperationException();
}",0.672
50772,"public List invokeAll(Collection tasks,long timeout,TimeUnit unit) throws InterruptedException {
  return null;
}","public List invokeAll(Collection tasks,long timeout,TimeUnit unit) throws InterruptedException {
  throw new UnsupportedOperationException();
}",0.828125
50773,"public boolean awaitTermination(long timeout,TimeUnit unit) throws InterruptedException {
  return false;
}","public boolean awaitTermination(long timeout,TimeUnit unit) throws InterruptedException {
  throw new UnsupportedOperationException();
}",0.831275720164609
50774,"public Object invokeAny(Collection tasks,long timeout,TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
  return null;
}","public Object invokeAny(Collection tasks,long timeout,TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
  throw new UnsupportedOperationException();
}",0.8690476190476191
50775,"public List<Runnable> shutdownNow(){
  return null;
}","public List<Runnable> shutdownNow(){
  throw new UnsupportedOperationException();
}",0.6764705882352942
50776,"public void shutdown(){
}","public void shutdown(){
  throw new UnsupportedOperationException();
}",0.5263157894736842
50777,"public boolean isShutdown(){
  return false;
}","public boolean isShutdown(){
  throw new UnsupportedOperationException();
}",0.6611570247933884
50778,"final private boolean writeInvocation(final Connection conn,final Invocation inv){
  if (!conn.live()) {
    inv.returnToContainer();
    return false;
  }
  final MemberImpl memberImpl=getMember(conn.getEndPoint());
  if (memberImpl != null) {
    memberImpl.didWrite();
  }
  inv.write();
  conn.getWriteHandler().enqueueInvocation(inv);
  return true;
}","final private boolean writeInvocation(final Connection conn,final Invocation inv){
  if (!conn.live()) {
    inv.returnToContainer();
    return false;
  }
  final MemberImpl memberImpl=getMember(conn.getEndPoint());
  if (memberImpl != null) {
    memberImpl.didWrite();
  }
  inv.currentCallCount=mapCalls.size();
  inv.write();
  conn.getWriteHandler().enqueueInvocation(inv);
  return true;
}",0.946808510638298
50779,"public void reset(){
  name=null;
  operation=-1;
  threadId=-1;
  lockCount=0;
  lockAddress=null;
  timeout=-1;
  txnId=-1;
  responseType=RESPONSE_NONE;
  local=true;
  scheduled=false;
  blockId=-1;
  longValue=Long.MIN_VALUE;
  recordId=-1;
  eventId=-1;
  bbSizes.clear();
  bbHeader.clear();
  key.setNoData();
  data.setNoData();
  attachment=null;
  conn=null;
}","public void reset(){
  name=null;
  operation=-1;
  threadId=-1;
  lockCount=0;
  lockAddress=null;
  timeout=-1;
  txnId=-1;
  responseType=RESPONSE_NONE;
  local=true;
  currentCallCount=0;
  scheduled=false;
  blockId=-1;
  longValue=Long.MIN_VALUE;
  recordId=-1;
  eventId=-1;
  bbSizes.clear();
  bbHeader.clear();
  key.setNoData();
  data.setNoData();
  attachment=null;
  conn=null;
}",0.9712041884816754
50780,"public final void enqueueInvocation(final Invocation inv){
  try {
    writeHandlerQueue.put(inv);
  }
 catch (  final InterruptedException e) {
    Node.get().handleInterruptedException(Thread.currentThread(),e);
  }
  if (informSelector.get()) {
    informSelector.set(false);
    final int size=outSelector.addTask(this);
  }
}","public final void enqueueInvocation(final Invocation inv){
  try {
    writeHandlerQueue.put(inv);
  }
 catch (  final InterruptedException e) {
    Node.get().handleInterruptedException(Thread.currentThread(),e);
  }
  if (informSelector.get()) {
    informSelector.set(false);
    outSelector.addTask(this);
    if (inv.currentCallCount < 2) {
      outSelector.selector.wakeup();
    }
  }
}",0.861878453038674
50781,"public final void handle(){
  informSelector.set(true);
  if (writeHandlerQueue.size() == 0) {
    ready=true;
    return;
  }
  if (!connection.live())   return;
  try {
    bbOut.clear();
    copyLoop:     while (bbOut.position() < (32 * 1024)) {
      final Invocation inv=(Invocation)writeHandlerQueue.poll();
      if (inv == null)       break copyLoop;
      inv.write(bbOut);
      doPostWrite(inv);
    }
    if (bbOut.position() == 0)     return;
    bbOut.flip();
    int remaining=bbOut.remaining();
    int loopCount=0;
    connection.didWrite();
    while (remaining > 0) {
      try {
        final int written=socketChannel.write(bbOut);
        remaining-=written;
        loopCount++;
        if (DEBUG) {
          if (loopCount > 1) {
            logger.log(Level.INFO,""String_Node_Str"" + loopCount);
          }
        }
      }
 catch (      final Exception e) {
        handleSocketException(e);
        return;
      }
    }
  }
 catch (  final Throwable t) {
    logger.log(Level.INFO,""String_Node_Str"" + t);
  }
 finally {
    ready=false;
    registerWrite();
  }
}","public final void handle(){
  if (writeHandlerQueue.size() == 0) {
    ready=true;
    return;
  }
  if (!connection.live())   return;
  try {
    bbOut.clear();
    copyLoop:     while (bbOut.position() < (32 * 1024)) {
      final Invocation inv=(Invocation)writeHandlerQueue.poll();
      if (inv == null)       break copyLoop;
      inv.write(bbOut);
      doPostWrite(inv);
    }
    if (bbOut.position() == 0)     return;
    bbOut.flip();
    int remaining=bbOut.remaining();
    int loopCount=0;
    connection.didWrite();
    while (remaining > 0) {
      try {
        final int written=socketChannel.write(bbOut);
        remaining-=written;
        loopCount++;
        if (DEBUG) {
          if (loopCount > 1) {
            logger.log(Level.INFO,""String_Node_Str"" + loopCount);
          }
        }
      }
 catch (      final Exception e) {
        handleSocketException(e);
        return;
      }
    }
  }
 catch (  final Throwable t) {
    logger.log(Level.INFO,""String_Node_Str"" + t);
  }
 finally {
    ready=false;
    registerWrite();
  }
}",0.987012987012987
50782,"public final void run(){
  wakeupSelector.set(true);
  informSelector.set(true);
  if (ready) {
    handle();
  }
 else {
    registerWrite();
  }
  ready=false;
}","public final void run(){
  informSelector.set(true);
  if (ready) {
    handle();
  }
 else {
    registerWrite();
  }
  ready=false;
}",0.906040268456376
50783,"public void process(){
  setTarget();
  if (target == null) {
    setResult(OBJECT_REDO);
    return;
  }
  if (target.equals(thisAddress)) {
    doLocalOp();
  }
 else {
    invoke();
  }
}",void process(Invocation inv);,0.2100456621004566
50784,"private BlockingQueueManager(){
}","private BlockingQueueManager(){
  ClusterService.get().registerInvocationProcessor(OP_B_POLL,new InvocationProcessor(){
    public void process(    Invocation inv){
      handlePoll(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_B_OFFER,new InvocationProcessor(){
    public void process(    Invocation inv){
      handleOffer(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_B_BACKUP_ADD,new InvocationProcessor(){
    public void process(    Invocation inv){
      handleBackup(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_B_BACKUP_REMOVE,new InvocationProcessor(){
    public void process(    Invocation inv){
      handleBackup(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_B_PUBLISH,new InvocationProcessor(){
    public void process(    Invocation inv){
      handlePublish(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_B_ADD_TOPIC_LISTENER,new InvocationProcessor(){
    public void process(    Invocation inv){
      handleAddTopicListener(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_B_SIZE,new InvocationProcessor(){
    public void process(    Invocation inv){
      handleSize(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_B_PEEK,new InvocationProcessor(){
    public void process(    Invocation inv){
      handlePoll(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_B_READ,new InvocationProcessor(){
    public void process(    Invocation inv){
      handleRead(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_B_REMOVE,new InvocationProcessor(){
    public void process(    Invocation inv){
      handleRemove(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_B_TXN_BACKUP_POLL,new InvocationProcessor(){
    public void process(    Invocation inv){
      handleTxnBackupPoll(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_B_TXN_COMMIT,new InvocationProcessor(){
    public void process(    Invocation inv){
      handleTxnCommit(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_B_ADD_BLOCK,new InvocationProcessor(){
    public void process(    Invocation inv){
      handleAddBlock(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_B_REMOVE_BLOCK,new InvocationProcessor(){
    public void process(    Invocation inv){
      handleRemoveBlock(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_B_FULL_BLOCK,new InvocationProcessor(){
    public void process(    Invocation inv){
      handleFullBlock(inv);
    }
  }
);
}",0.0234948604992657
50785,"private ClusterManager(){
  ConnectionManager.get().addConnectionListener(this);
}","private ClusterManager(){
  ConnectionManager.get().addConnectionListener(this);
  ClusterService.get().registerInvocationProcessor(OP_RESPONSE,new InvocationProcessor(){
    public void process(    Invocation inv){
      handleResponse(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_HEARTBEAT,new InvocationProcessor(){
    public void process(    Invocation inv){
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_REMOTELY_PROCESS_AND_RESPOND,new InvocationProcessor(){
    public void process(    Invocation inv){
      Data data=inv.doTake(inv.data);
      RemotelyProcessable rp=(RemotelyProcessable)ThreadContext.get().toObject(data);
      rp.setConnection(inv.conn);
      rp.process();
      sendResponse(inv);
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_REMOTELY_PROCESS,new InvocationProcessor(){
    public void process(    Invocation inv){
      Data data=inv.doTake(inv.data);
      RemotelyProcessable rp=(RemotelyProcessable)ThreadContext.get().toObject(data);
      rp.setConnection(inv.conn);
      rp.process();
      inv.returnToContainer();
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_REMOTELY_BOOLEAN_CALLABLE,new InvocationProcessor(){
    public void process(    Invocation inv){
      Boolean result=null;
      try {
        Data data=inv.doTake(inv.data);
        AbstractRemotelyCallable<Boolean> callable=(AbstractRemotelyCallable<Boolean>)ThreadContext.get().toObject(data);
        callable.setConnection(inv.conn);
        result=callable.call();
      }
 catch (      Exception e) {
        e.printStackTrace(System.out);
        result=Boolean.FALSE;
      }
      if (result == Boolean.TRUE) {
        sendResponse(inv);
      }
 else {
        sendResponseFailure(inv);
      }
    }
  }
);
  ClusterService.get().registerInvocationProcessor(OP_REMOTELY_OBJECT_CALLABLE,new InvocationProcessor(){
    public void process(    Invocation inv){
      Object result=null;
      try {
        Data data=inv.doTake(inv.data);
        AbstractRemotelyCallable callable=(AbstractRemotelyCallable)ThreadContext.get().toObject(data);
        callable.setConnection(inv.conn);
        result=callable.call();
      }
 catch (      Exception e) {
        e.printStackTrace(System.out);
        result=null;
      }
      if (result != null) {
        Data value=null;
        if (result instanceof Data) {
          value=(Data)result;
        }
 else {
          value=ThreadContext.get().toData(result);
        }
        inv.doSet(value,inv.data);
      }
      sendResponse(inv);
    }
  }
);
}",0.0608986260675826
50786,"public void process(final Object obj){
  final long processStart=System.nanoTime();
  if (obj instanceof Invocation) {
    final Invocation inv=(Invocation)obj;
    final MemberImpl memberFrom=ClusterManager.get().getMember(inv.conn.getEndPoint());
    if (memberFrom != null) {
      memberFrom.didRead();
    }
    final int operation=inv.operation;
    if (operation == OP_RESPONSE) {
      ClusterManager.get().handleResponse(inv);
    }
 else     if (operation > 500) {
      ConcurrentMapManager.get().handle(inv);
    }
 else     if (operation > 400) {
      BlockingQueueManager.get().handle(inv);
    }
 else     if (operation > 300) {
      ExecutorManager.get().handle(inv);
    }
 else     if (operation > 200) {
      ListenerManager.get().handle(inv);
    }
 else     if (operation > 0) {
      ClusterManager.get().handle(inv);
    }
 else     throw new RuntimeException(""String_Node_Str"" + operation);
  }
 else   if (obj instanceof Processable) {
    ((Processable)obj).process();
  }
 else   if (obj instanceof Runnable) {
synchronized (obj) {
      ((Runnable)obj).run();
      obj.notify();
    }
  }
 else   throw new RuntimeException(""String_Node_Str"" + obj);
  final long processEnd=System.nanoTime();
  final long elipsedTime=processEnd - processStart;
  totalProcessTime+=elipsedTime;
  final long duration=(processEnd - start);
  if (duration > UTILIZATION_CHECK_INTERVAL) {
    if (DEBUG) {
      logger.log(Level.FINEST,""String_Node_Str"" + ((totalProcessTime * 100) / duration) + ""String_Node_Str"");
    }
    start=processEnd;
    totalProcessTime=0;
  }
}","public void process(final Object obj){
  final long processStart=System.nanoTime();
  if (obj instanceof Invocation) {
    final Invocation inv=(Invocation)obj;
    final MemberImpl memberFrom=ClusterManager.get().getMember(inv.conn.getEndPoint());
    if (memberFrom != null) {
      memberFrom.didRead();
    }
    InvocationProcessor invocationProcessor=invProcessors[inv.operation];
    if (invocationProcessor == null) {
      logger.log(Level.SEVERE,""String_Node_Str"" + inv.operation);
    }
    invocationProcessor.process(inv);
  }
 else   if (obj instanceof Processable) {
    ((Processable)obj).process();
  }
 else {
    logger.log(Level.SEVERE,""String_Node_Str"" + obj);
  }
  final long processEnd=System.nanoTime();
  final long elipsedTime=processEnd - processStart;
  totalProcessTime+=elipsedTime;
  final long duration=(processEnd - start);
  if (duration > UTILIZATION_CHECK_INTERVAL) {
    if (DEBUG) {
      logger.log(Level.FINEST,""String_Node_Str"" + ((totalProcessTime * 100) / duration) + ""String_Node_Str"");
    }
    start=processEnd;
    totalProcessTime=0;
  }
}",0.6432311144353029
50787,"final boolean send(final Invocation inv,final Connection conn){
  if (conn != null) {
    writeInvocation(conn,inv);
  }
 else {
    return false;
  }
  return true;
}","final boolean send(final Invocation inv,final Connection conn){
  if (conn != null) {
    return writeInvocation(conn,inv);
  }
 else {
    return false;
  }
}",0.9325153374233128
50788,"final private void writeInvocation(final Connection conn,final Invocation inv){
  if (!conn.live()) {
    inv.returnToContainer();
    return;
  }
  final MemberImpl memberImpl=getMember(conn.getEndPoint());
  if (memberImpl != null) {
    memberImpl.didWrite();
  }
  inv.write();
  conn.getWriteHandler().enqueueInvocation(inv);
}","final private boolean writeInvocation(final Connection conn,final Invocation inv){
  if (!conn.live()) {
    inv.returnToContainer();
    return false;
  }
  final MemberImpl memberImpl=getMember(conn.getEndPoint());
  if (memberImpl != null) {
    memberImpl.didWrite();
  }
  inv.write();
  conn.getWriteHandler().enqueueInvocation(inv);
  return true;
}",0.9534883720930232
50789,"final void handleResponse(final Invocation invResponse){
  final Call call=mapCalls.get(invResponse.eventId);
  if (call != null)   call.handleResponse(invResponse);
 else {
    if (DEBUG) {
      log(invResponse.operation + ""String_Node_Str"" + invResponse.eventId);
    }
    invResponse.returnToContainer();
  }
}","final void handleResponse(final Invocation invResponse){
  final Call call=mapCalls.get(invResponse.eventId);
  if (call != null) {
    call.handleResponse(invResponse);
  }
 else {
    if (DEBUG) {
      log(invResponse.operation + ""String_Node_Str"" + invResponse.eventId);
    }
    invResponse.returnToContainer();
  }
}",0.987460815047022
50790,"public void run(){
  try {
    socketChannel=SocketChannel.open();
    final Address thisAddress=Node.get().getThisAddress();
    final int addition=(thisAddress.getPort() - Config.get().port);
    localPort=10000 + addition;
    boolean bindOk=false;
    while (!bindOk) {
      try {
        localPort+=20;
        if (boundPorts.size() > 2000 || localPort > 60000) {
          boundPorts.clear();
          final Connection[] conns=ConnectionManager.get().getConnections();
          for (          final Connection conn : conns) {
            boundPorts.add(conn.localPort);
          }
        }
        if (boundPorts.add(localPort)) {
          socketChannel.socket().bind(new InetSocketAddress(thisAddress.getInetAddress(),localPort));
          bindOk=true;
          socketChannel.configureBlocking(false);
          if (DEBUG)           logger.log(Level.INFO,""String_Node_Str"" + address);
          socketChannel.connect(new InetSocketAddress(address.getInetAddress(),address.getPort()));
        }
      }
 catch (      final Exception e) {
      }
    }
    socketChannel.register(selector,SelectionKey.OP_CONNECT,Connector.this);
  }
 catch (  final Exception e) {
    try {
      socketChannel.close();
    }
 catch (    final IOException ignored) {
    }
    if (numberOfConnectionError++ < 5) {
      if (DEBUG) {
        logger.log(Level.INFO,""String_Node_Str"" + e.getMessage());
      }
      run();
    }
 else {
      ConnectionManager.get().failedConnection(address);
    }
  }
}","public void run(){
  try {
    socketChannel=SocketChannel.open();
    final Address thisAddress=Node.get().getThisAddress();
    final int addition=(thisAddress.getPort() - Config.get().port);
    localPort=10000 + addition;
    boolean bindOk=false;
    while (!bindOk) {
      try {
        localPort+=20;
        if (boundPorts.size() > 2000 || localPort > 60000) {
          boundPorts.clear();
          final Connection[] conns=ConnectionManager.get().getConnections();
          for (          final Connection conn : conns) {
            boundPorts.add(conn.localPort);
          }
        }
        if (boundPorts.add(localPort)) {
          socketChannel.socket().bind(new InetSocketAddress(thisAddress.getInetAddress(),localPort));
          bindOk=true;
          socketChannel.configureBlocking(false);
          if (DEBUG)           logger.log(Level.FINEST,""String_Node_Str"" + address + ""String_Node_Str""+ localPort);
          boolean connected=socketChannel.connect(new InetSocketAddress(address.getInetAddress(),address.getPort()));
          if (DEBUG)           logger.log(Level.FINEST,""String_Node_Str"" + connected + ""String_Node_Str""+ address+ ""String_Node_Str""+ localPort);
          if (connected) {
            handle();
            return;
          }
        }
      }
 catch (      final Throwable e) {
        if (DEBUG)         logger.log(Level.FINEST,""String_Node_Str"" + localPort,e);
      }
    }
    socketChannel.register(selector,SelectionKey.OP_CONNECT,Connector.this);
  }
 catch (  final Exception e) {
    try {
      socketChannel.close();
    }
 catch (    final IOException ignored) {
    }
    if (numberOfConnectionError++ < 5) {
      if (DEBUG) {
        logger.log(Level.FINEST,""String_Node_Str"" + e.getMessage());
      }
      run();
    }
 else {
      ConnectionManager.get().failedConnection(address);
    }
  }
}",0.8737748737748737
50791,"@Override public void doOp(){
  responses.clear();
  enqueueAndReturn(TargetAwareOp.this);
}","@Override public void doOp(){
  responses.clear();
  enqueueAndReturn(ResponseQueueCall.this);
}",0.851063829787234
50792,"public int size(){
  int size=0;
  Collection<Record> records=mapRecords.values();
  for (  Record record : records) {
    if (record.value != null) {
      if (record.owner.equals(thisAddress)) {
        size++;
        size+=record.getCopyCount();
      }
    }
  }
  return size;
}","public int size(){
  int size=0;
  Collection<Record> records=mapRecords.values();
  for (  Record record : records) {
    if (record.value != null) {
      Block block=mapBlocks.get(record.blockId);
      if (thisAddress.equals(block.owner)) {
        size++;
        size+=record.getCopyCount();
      }
    }
  }
  return size;
}",0.8409090909090909
50793,"@Override void setTarget(){
}","@Override void setTarget(){
  setTargetBasedOnKey();
}",0.6987951807228916
50794,"@Override void doLocalOp(){
}","@Override void doLocalOp(){
  CMap cmap=getMap(request.name);
  total+=cmap.size();
}",0.5087719298245614
50795,"@Override public void handleResponse(Invocation inv){
  total+=(int)inv.longValue;
  consumeResponse(inv);
}","public void handleResponse(Invocation inv){
}",0.5882352941176471
50796,"public void run(){
  logger.log(Level.FINEST,""String_Node_Str"");
  for (  final Long recordId : recordsToMigrate) {
    MMigrate mmigrate=new MMigrate();
    boolean migrated=mmigrate.migrate(recordId);
    if (!migrated) {
      logger.log(Level.FINEST,""String_Node_Str"" + recordId);
    }
  }
  Processable removeMigratedRecordsProcess=new Processable(){
    public void process(){
      for (      final Long recordId : recordsToMigrate) {
        Record record=getRecordById(recordId);
        if (record != null) {
          Block block=getBlock(record.key);
          if (!backupMemberFor(block)) {
            CMap cmap=getMap(record.name);
            cmap.removeRecord(record.key);
          }
        }
      }
    }
  }
;
  enqueueAndReturn(removeMigratedRecordsProcess);
  if (recordsToBackup != null) {
    int count=0;
    MBackupOp mbackupOp=new MBackupOp();
    for (    final Long recordId : recordsToBackup) {
      Record record=getRecordById(recordId);
      if (record != null) {
        mbackupOp.backup(record);
        if (count++ > 10) {
          count=0;
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
  Processable processCompletion=new Processable(){
    public void process(){
      doMigrationComplete(thisAddress);
      sendMigrationComplete();
      if (DEBUG) {
        printBlocks();
        logger.log(Level.FINEST,""String_Node_Str"");
      }
    }
  }
;
  enqueueAndReturn(processCompletion);
}","public void run(){
  logger.log(Level.FINEST,""String_Node_Str"");
  CheckAllConnectionsOp checkAllConnectionsOp=new CheckAllConnectionsOp();
  checkAllConnectionsOp.check();
  for (  final Long recordId : recordsToMigrate) {
    MMigrate mmigrate=new MMigrate();
    boolean migrated=mmigrate.migrate(recordId);
    if (!migrated) {
      logger.log(Level.FINEST,""String_Node_Str"" + recordId);
    }
  }
  Processable removeMigratedRecordsProcess=new Processable(){
    public void process(){
      for (      final Long recordId : recordsToMigrate) {
        Record record=getRecordById(recordId);
        if (record != null) {
          Block block=getBlock(record.key);
          if (!backupMemberFor(block)) {
            CMap cmap=getMap(record.name);
            cmap.removeRecord(record.key);
          }
        }
      }
    }
  }
;
  enqueueAndReturn(removeMigratedRecordsProcess);
  if (recordsToBackup != null) {
    int count=0;
    MBackupOp mbackupOp=new MBackupOp();
    for (    final Long recordId : recordsToBackup) {
      Record record=getRecordById(recordId);
      if (record != null) {
        mbackupOp.backup(record);
        if (count++ > 10) {
          count=0;
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
  Processable processCompletion=new Processable(){
    public void process(){
      doMigrationComplete(thisAddress);
      sendMigrationComplete();
      if (DEBUG) {
        printBlocks();
        logger.log(Level.FINEST,""String_Node_Str"");
      }
    }
  }
;
  enqueueAndReturn(processCompletion);
}",0.9665220086794792
50797,"private void doMigrationComplete(Address from){
  Collection<Block> blocks=mapBlocks.values();
  for (  Block block : blocks) {
    if (from.equals(block.owner)) {
      if (block.isMigrating()) {
        block.owner=block.migrationAddress;
        block.migrationAddress=null;
      }
    }
  }
  if (isMaster() && !from.equals(thisAddress)) {
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember() || !from.equals(member.getAddress())) {
        Invocation inv=obtainServiceInvocation();
        inv.name=""String_Node_Str"";
        inv.operation=OP_CMAP_MIGRATION_COMPLETE;
        boolean sent=send(inv,member.getAddress());
        if (!sent) {
          inv.returnToContainer();
        }
      }
    }
  }
}","private void doMigrationComplete(Address from){
  System.out.println(""String_Node_Str"" + from);
  Collection<Block> blocks=mapBlocks.values();
  for (  Block block : blocks) {
    if (from.equals(block.owner)) {
      if (block.isMigrating()) {
        block.owner=block.migrationAddress;
        block.migrationAddress=null;
      }
    }
  }
  if (isMaster() && !from.equals(thisAddress)) {
    for (    MemberImpl member : lsMembers) {
      if (!member.localMember() || !from.equals(member.getAddress())) {
        Invocation inv=obtainServiceInvocation();
        inv.name=""String_Node_Str"";
        inv.operation=OP_CMAP_MIGRATION_COMPLETE;
        boolean sent=send(inv,member.getAddress());
        if (!sent) {
          inv.returnToContainer();
        }
      }
    }
  }
}",0.968421052631579
50798,"public int getSize(String name){
  total=0;
  setLocal(OP_CMAP_SIZE,name,null,null,0,-1,-1);
  doOp();
  return total;
}","public int getSize(String name){
  reset();
  shouldRedo=false;
  total=0;
  setLocal(OP_CMAP_SIZE,name,null,null,0,-1,-1);
  doOp();
  if (shouldRedo) {
    try {
      Thread.sleep(2000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    return getSize(name);
  }
  return total;
}",0.488479262672811
50799,"Record nextOwnedRecord(long recordId,int blockId){
  Record rec=null;
  while (rec == null && recordId <= maxId) {
    rec=getRecordById(recordId);
    if (rec != null) {
      if (rec.blockId == blockId) {
        if (rec.owner.equals(thisAddress)) {
          return rec;
        }
      }
    }
    rec=null;
    recordId++;
  }
  return rec;
}","Record nextOwnedRecord(String name,long recordId,int blockId){
  Record rec=null;
  while (rec == null && recordId <= maxId) {
    rec=getRecordById(recordId);
    if (rec != null) {
      if (name != null && name.equals(rec.name)) {
        if (rec.blockId == blockId) {
          if (rec.owner.equals(thisAddress)) {
            return rec;
          }
        }
      }
    }
    rec=null;
    recordId++;
  }
  return rec;
}",0.8670967741935484
50800,"public Record read(Request req){
  return nextOwnedRecord(req.recordId,req.blockId);
}","public Record read(Request req){
  return nextOwnedRecord(req.name,req.recordId,req.blockId);
}",0.9502762430939228
50801,"void handleSize(Invocation inv){
  CMap cmap=getMap(inv.name);
  inv.longValue=cmap.size();
  sendResponse(inv);
}","void handleSize(Invocation inv){
  if (migrating()) {
    inv.responseType=RESPONSE_REDO;
  }
 else {
    CMap cmap=getMap(inv.name);
    inv.longValue=cmap.size();
  }
  sendResponse(inv);
}",0.7475409836065574
50802,"public void writeObject(BufferProvider bufferProvider,Object obj) throws Exception {
  bbos.setBufferProvider(bufferProvider);
  bbos.reset();
  if (obj instanceof byte[]) {
    bbos.write((byte)40);
    byte[] bytes=(byte[])obj;
    bbos.writeInt(bytes.length);
    bbos.write((byte[])obj);
  }
 else   if (obj instanceof Long) {
    bbos.write((byte)41);
    bbos.writeLong(((Long)obj).longValue());
  }
 else   if (obj instanceof Integer) {
    bbos.write((byte)42);
    bbos.writeInt(((Integer)obj).intValue());
  }
 else   if (obj instanceof DataSerializable) {
    bbos.write((byte)45);
    bbos.writeUTF(obj.getClass().getName());
    ((DataSerializable)obj).writeData(bbos);
    bbos.writeInt(STREAM_END);
  }
 else   if (obj instanceof String) {
    bbos.write((byte)46);
    String str=(String)obj;
    bbos.writeUTF(str);
  }
 else {
    bbos.write((byte)66);
    ObjectOutputStream os=new ObjectOutputStream(bbos);
    os.writeObject(obj);
  }
  bbos.flush();
}","public void writeObject(BufferProvider bufferProvider,Object obj) throws Exception {
  bbos.setBufferProvider(bufferProvider);
  bbos.reset();
  if (obj instanceof byte[]) {
    bbos.write((byte)40);
    byte[] bytes=(byte[])obj;
    bbos.writeInt(bytes.length);
    bbos.write((byte[])obj);
  }
 else   if (obj instanceof Long) {
    bbos.write((byte)41);
    bbos.writeLong(((Long)obj).longValue());
  }
 else   if (obj instanceof Integer) {
    bbos.write((byte)42);
    bbos.writeInt(((Integer)obj).intValue());
  }
 else   if (obj instanceof DataSerializable) {
    bbos.write((byte)45);
    bbos.writeUTF(obj.getClass().getName());
    ((DataSerializable)obj).writeData(bbos);
    bbos.writeInt(STREAM_END);
  }
 else   if (obj instanceof String) {
    bbos.write((byte)46);
    String str=(String)obj;
    bbos.writeUTF(str);
  }
 else {
    bbos.write((byte)66);
    ObjectOutputStream os=new ObjectOutputStream(bbos);
    os.writeUnshared(obj);
  }
  bbos.flush();
}",0.9928131416837782
50803,"public Object readObject(BufferProvider bufferProvider){
  try {
    bbis.setBufferProvider(bufferProvider);
    bbis.reset();
    Object result=null;
    byte type=(byte)bbis.read();
    if (type == 40) {
      int size=bbis.readInt();
      byte[] bytes=new byte[size];
      bbis.read(bytes);
      result=bytes;
    }
 else     if (type == 41) {
      result=Long.valueOf(bbis.readLong());
    }
 else     if (type == 42) {
      result=Integer.valueOf(bbis.readInt());
    }
 else     if (type == 66) {
      ObjectInputStream in=new ObjectInputStream(bbis);
      result=in.readUnshared();
    }
 else     if (type == 45) {
      String className=bbis.readUTF();
      DataSerializable ds=(DataSerializable)Class.forName(className).newInstance();
      ds.readData(bbis);
      if (bbis.readInt() != STREAM_END)       throw new RuntimeException(""String_Node_Str"");
      result=ds;
    }
 else     if (type == 46) {
      result=bbis.readUTF();
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + type);
    }
    return result;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}","public Object readObject(BufferProvider bufferProvider){
  try {
    bbis.setBufferProvider(bufferProvider);
    bbis.reset();
    Object result=null;
    byte type=(byte)bbis.read();
    if (type == 40) {
      int size=bbis.readInt();
      byte[] bytes=new byte[size];
      bbis.read(bytes);
      result=bytes;
    }
 else     if (type == 41) {
      result=Long.valueOf(bbis.readLong());
    }
 else     if (type == 42) {
      result=Integer.valueOf(bbis.readInt());
    }
 else     if (type == 45) {
      String className=bbis.readUTF();
      DataSerializable ds=(DataSerializable)Class.forName(className).newInstance();
      ds.readData(bbis);
      if (bbis.readInt() != STREAM_END)       throw new RuntimeException(""String_Node_Str"");
      result=ds;
    }
 else     if (type == 46) {
      result=bbis.readUTF();
    }
 else     if (type == 66) {
      ObjectInputStream in=new ObjectInputStream(bbis);
      result=in.readUnshared();
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + type);
    }
    return result;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}",0.8916518650088809
50804,"public boolean executeProcess(Address address,AbstractRemotelyProcessable arp){
  this.arp=arp;
  super.target=address;
  return booleanCall(OP_REMOTELY_PROCESS_AND_RESPONSE,""String_Node_Str"",null,arp,0,-1,-1);
}","public boolean executeProcess(Address address,AbstractRemotelyProcessable arp){
  this.arp=arp;
  super.target=address;
  return booleanCall(OP_REMOTELY_PROCESS_AND_RESPOND,""String_Node_Str"",null,arp,0,-1,-1);
}",0.9929078014184396
50805,"public void handle(Invocation inv){
  try {
    if (inv.operation == OP_RESPONSE) {
      handleResponse(inv);
    }
 else     if (inv.operation == OP_HEARTBEAT) {
      inv.returnToContainer();
    }
 else     if (inv.operation == OP_REMOTELY_PROCESS_AND_RESPONSE) {
      Data data=inv.doTake(inv.data);
      RemotelyProcessable rp=(RemotelyProcessable)ThreadContext.get().toObject(data);
      rp.setConnection(inv.conn);
      rp.process();
      sendResponse(inv);
    }
 else     if (inv.operation == OP_REMOTELY_PROCESS) {
      Data data=inv.doTake(inv.data);
      RemotelyProcessable rp=(RemotelyProcessable)ThreadContext.get().toObject(data);
      rp.setConnection(inv.conn);
      rp.process();
      inv.returnToContainer();
    }
 else     if (inv.operation == OP_REMOTELY_BOOLEAN_CALLABLE) {
      Boolean result=null;
      try {
        Data data=inv.doTake(inv.data);
        AbstractRemotelyCallable<Boolean> callable=(AbstractRemotelyCallable<Boolean>)ThreadContext.get().toObject(data);
        callable.setConnection(inv.conn);
        result=callable.call();
      }
 catch (      Exception e) {
        e.printStackTrace(System.out);
        result=Boolean.FALSE;
      }
      if (result == Boolean.TRUE) {
        sendResponse(inv);
      }
 else {
        sendResponseFailure(inv);
      }
    }
 else     if (inv.operation == OP_REMOTELY_OBJECT_CALLABLE) {
      Object result=null;
      try {
        Data data=inv.doTake(inv.data);
        AbstractRemotelyCallable callable=(AbstractRemotelyCallable)ThreadContext.get().toObject(data);
        callable.setConnection(inv.conn);
        result=callable.call();
      }
 catch (      Exception e) {
        e.printStackTrace(System.out);
        result=null;
      }
      if (result != null) {
        Data value=null;
        if (result instanceof Data) {
          value=(Data)result;
        }
 else {
          value=ThreadContext.get().toData(result);
        }
        inv.doSet(value,inv.data);
      }
      sendResponse(inv);
    }
 else     throw new RuntimeException(""String_Node_Str"" + inv.name);
  }
 catch (  Exception e) {
    log(e);
    e.printStackTrace();
  }
}","public void handle(Invocation inv){
  try {
    if (inv.operation == OP_RESPONSE) {
      handleResponse(inv);
    }
 else     if (inv.operation == OP_HEARTBEAT) {
      inv.returnToContainer();
    }
 else     if (inv.operation == OP_REMOTELY_PROCESS_AND_RESPOND) {
      Data data=inv.doTake(inv.data);
      RemotelyProcessable rp=(RemotelyProcessable)ThreadContext.get().toObject(data);
      rp.setConnection(inv.conn);
      rp.process();
      sendResponse(inv);
    }
 else     if (inv.operation == OP_REMOTELY_PROCESS) {
      Data data=inv.doTake(inv.data);
      RemotelyProcessable rp=(RemotelyProcessable)ThreadContext.get().toObject(data);
      rp.setConnection(inv.conn);
      rp.process();
      inv.returnToContainer();
    }
 else     if (inv.operation == OP_REMOTELY_BOOLEAN_CALLABLE) {
      Boolean result=null;
      try {
        Data data=inv.doTake(inv.data);
        AbstractRemotelyCallable<Boolean> callable=(AbstractRemotelyCallable<Boolean>)ThreadContext.get().toObject(data);
        callable.setConnection(inv.conn);
        result=callable.call();
      }
 catch (      Exception e) {
        e.printStackTrace(System.out);
        result=Boolean.FALSE;
      }
      if (result == Boolean.TRUE) {
        sendResponse(inv);
      }
 else {
        sendResponseFailure(inv);
      }
    }
 else     if (inv.operation == OP_REMOTELY_OBJECT_CALLABLE) {
      Object result=null;
      try {
        Data data=inv.doTake(inv.data);
        AbstractRemotelyCallable callable=(AbstractRemotelyCallable)ThreadContext.get().toObject(data);
        callable.setConnection(inv.conn);
        result=callable.call();
      }
 catch (      Exception e) {
        e.printStackTrace(System.out);
        result=null;
      }
      if (result != null) {
        Data value=null;
        if (result instanceof Data) {
          value=(Data)result;
        }
 else {
          value=ThreadContext.get().toData(result);
        }
        inv.doSet(value,inv.data);
      }
      sendResponse(inv);
    }
 else     throw new RuntimeException(""String_Node_Str"" + inv.name);
  }
 catch (  Exception e) {
    log(e);
    e.printStackTrace();
  }
}",0.9993060374739764
50806,"public void invoke(){
  ClusterService.get().enqueueAndReturn(DistributedExecutorAction.this);
}","public void invoke(){
  enqueueAndReturn(DistributedExecutorAction.this);
}",0.8771929824561403
50807,"static Object createProxy(String name){
  Object proxy=proxies.get(name);
  if (proxy == null) {
    if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        proxy=new QProxy(name);
        proxies.put(name,proxy);
      }
    }
 else     if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        proxy=new TopicProxy(name);
        proxies.put(name,proxy);
      }
    }
 else     if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        proxy=new CProxy(name);
        proxies.put(name,proxy);
      }
    }
 else     if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        byte mapType=BaseManager.getMapType(name);
        CProxy mapProxy=new CProxy(name);
        if (mapType == MAP_TYPE_SET) {
          proxy=new SetProxy(mapProxy);
        }
 else         if (mapType == MAP_TYPE_LIST) {
          proxy=new ListProxy(mapProxy);
        }
 else {
          proxy=mapProxy;
        }
        proxies.put(name,proxy);
      }
    }
  }
  return proxy;
}","static Object createProxy(String name){
  Object proxy=proxies.get(name);
  if (proxy == null) {
    if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        proxy=new QProxy(name);
        proxies.put(name,proxy);
      }
    }
 else     if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        proxy=new TopicProxy(name);
        proxies.put(name,proxy);
      }
    }
 else     if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        proxy=new MProxy(name);
        proxies.put(name,proxy);
      }
    }
 else     if (name.startsWith(""String_Node_Str"")) {
      proxy=proxies.get(name);
      if (proxy == null) {
        byte mapType=BaseManager.getMapType(name);
        MProxy mapProxy=new MProxy(name);
        if (mapType == MAP_TYPE_SET) {
          proxy=new SetProxy(mapProxy);
        }
 else         if (mapType == MAP_TYPE_LIST) {
          proxy=new ListProxy(mapProxy);
        }
 else {
          proxy=mapProxy;
        }
        proxies.put(name,proxy);
      }
    }
  }
  return proxy;
}",0.9974204643164232
50808,"public CollectionProxy(CProxy mapProxy){
  super();
  this.mapProxy=mapProxy;
  this.name=mapProxy.name;
}","public CollectionProxy(MProxy mapProxy){
  super();
  this.mapProxy=mapProxy;
  this.name=mapProxy.name;
}",0.9905660377358492
50809,"public SetProxy(CProxy mapProxy){
  super(mapProxy);
}","public SetProxy(MProxy mapProxy){
  super(mapProxy);
}",0.9814814814814816
50810,"@Override public int size(){
  return CProxy.this.size();
}","@Override public int size(){
  return MProxy.this.size();
}",0.9830508474576272
50811,"public LockProxy(CProxy mapProxy,Object key){
  super();
  this.mapProxy=mapProxy;
  this.key=key;
}","public LockProxy(MProxy mapProxy,Object key){
  super();
  this.mapProxy=mapProxy;
  this.key=key;
}",0.99
50812,"public TopicProxy(String name){
  super();
  this.name=name;
  if (Config.get().getTopicConfig(getName()).globalOrderingEnabled) {
    qProxy=new QProxy(""String_Node_Str"" + name);
  }
}","public TopicProxy(String name){
  super();
  this.name=name;
}",0.5020242914979757
50813,"public CProxy getCProxy(){
  return mapProxy;
}","public MProxy getCProxy(){
  return mapProxy;
}",0.9787234042553192
50814,"public ListProxy(CProxy mapProxy){
  super(mapProxy);
}","public ListProxy(MProxy mapProxy){
  super(mapProxy);
}",0.9818181818181818
50815,"public void removeListener(String name,Object listener,Object key){
  Iterator<ListenerItem> it=lsListeners.iterator();
  for (; it.hasNext(); ) {
    ListenerItem listenerItem=it.next();
    if (listener == listenerItem.listener) {
      if (key == null) {
        if (listenerItem.key == null) {
          registerListener(name,null,false,false);
          it.remove();
        }
      }
 else       if (key.equals(listenerItem.key)) {
        registerListener(name,key,false,false);
        it.remove();
      }
    }
  }
}","public synchronized void removeListener(String name,Object listener,Object key){
  Iterator<ListenerItem> it=lsListeners.iterator();
  for (; it.hasNext(); ) {
    ListenerItem listenerItem=it.next();
    if (listener == listenerItem.listener) {
      if (key == null) {
        if (listenerItem.key == null) {
          registerListener(name,null,false,false);
          it.remove();
        }
      }
 else       if (key.equals(listenerItem.key)) {
        registerListener(name,key,false,false);
        it.remove();
      }
    }
  }
}",0.9877934272300468
50816,"public void syncForAdd(){
  for (  ListenerItem listenerItem : lsListeners) {
    registerListener(listenerItem.name,listenerItem.key,true,listenerItem.includeValue);
  }
}","public void syncForAdd(Address newAddress){
  for (  ListenerItem listenerItem : lsListeners) {
    Data dataKey=null;
    if (listenerItem.key != null) {
      try {
        dataKey=ThreadContext.get().toData(listenerItem.key);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
    sendAddRemoveListener(newAddress,true,listenerItem.name,dataKey,listenerItem.includeValue);
  }
}",0.4432989690721649
50817,"public void addListener(String name,Object listener,Object key,boolean includeValue,int listenerType,boolean shouldRemotelyRegister){
  if (shouldRemotelyRegister) {
    boolean remotelyRegister=true;
    for (    ListenerItem listenerItem : lsListeners) {
      if (remotelyRegister) {
        if (listenerItem.listener == listener) {
          if (listenerItem.name.equals(name)) {
            if (key == null) {
              if (listenerItem.key == null) {
                if (!includeValue || listenerItem.includeValue == includeValue) {
                  remotelyRegister=false;
                }
              }
            }
 else {
              if (listenerItem.key != null) {
                if (listenerItem.key.equals(key)) {
                  if (!includeValue || listenerItem.includeValue == includeValue) {
                    remotelyRegister=false;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (remotelyRegister) {
      registerListener(name,key,true,includeValue);
    }
  }
  ListenerItem listenerItem=new ListenerItem(name,key,listener,includeValue,listenerType);
  lsListeners.add(listenerItem);
}","public synchronized void addListener(String name,Object listener,Object key,boolean includeValue,int listenerType,boolean shouldRemotelyRegister){
  if (shouldRemotelyRegister) {
    boolean remotelyRegister=true;
    for (    ListenerItem listenerItem : lsListeners) {
      if (remotelyRegister) {
        if (listenerItem.listener == listener) {
          if (listenerItem.name.equals(name)) {
            if (key == null) {
              if (listenerItem.key == null) {
                if (!includeValue || listenerItem.includeValue == includeValue) {
                  remotelyRegister=false;
                }
              }
            }
 else {
              if (listenerItem.key != null) {
                if (listenerItem.key.equals(key)) {
                  if (!includeValue || listenerItem.includeValue == includeValue) {
                    remotelyRegister=false;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (remotelyRegister) {
      registerListener(name,key,true,includeValue);
    }
  }
  ListenerItem listenerItem=new ListenerItem(name,key,listener,includeValue,listenerType);
  lsListeners.add(listenerItem);
}",0.9945492662473796
50818,"private static void appendApplicationInfo(final Appendable report,final WalletApplication application) throws IOException {
  final PackageInfo pi=application.packageInfo();
  final Configuration configuration=application.getConfiguration();
  final Calendar calendar=new GregorianCalendar(UTC);
  report.append(""String_Node_Str"" + pi.versionName + ""String_Node_Str""+ pi.versionCode+ ""String_Node_Str"");
  report.append(""String_Node_Str"" + pi.packageName + ""String_Node_Str"");
  report.append(""String_Node_Str"" + application.getPackageManager().getInstallerPackageName(pi.packageName) + ""String_Node_Str"");
  report.append(""String_Node_Str"" + (Constants.TEST ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  report.append(""String_Node_Str"" + TimeZone.getDefault().getID() + ""String_Node_Str"");
  calendar.setTimeInMillis(System.currentTimeMillis());
  report.append(""String_Node_Str"" + String.format(Locale.US,""String_Node_Str"",calendar,calendar,calendar) + ""String_Node_Str"");
  calendar.setTimeInMillis(WalletApplication.TIME_CREATE_APPLICATION);
  report.append(""String_Node_Str"" + String.format(Locale.US,""String_Node_Str"",calendar,calendar,calendar) + ""String_Node_Str"");
  calendar.setTimeInMillis(pi.lastUpdateTime);
  report.append(""String_Node_Str"" + String.format(Locale.US,""String_Node_Str"",calendar,calendar,calendar) + ""String_Node_Str"");
  calendar.setTimeInMillis(pi.firstInstallTime);
  report.append(""String_Node_Str"" + String.format(Locale.US,""String_Node_Str"",calendar,calendar,calendar) + ""String_Node_Str"");
  final long lastBackupTime=configuration.getLastBackupTime();
  calendar.setTimeInMillis(lastBackupTime);
  report.append(""String_Node_Str"" + (lastBackupTime > 0 ? String.format(Locale.US,""String_Node_Str"",calendar,calendar,calendar) : ""String_Node_Str"") + ""String_Node_Str"");
  report.append(""String_Node_Str"" + Constants.NETWORK_PARAMETERS.getId() + ""String_Node_Str"");
  final Wallet wallet=application.getWallet();
  report.append(""String_Node_Str"" + wallet.isEncrypted() + ""String_Node_Str"");
  report.append(""String_Node_Str"" + wallet.getKeyChainGroupSize() + ""String_Node_Str"");
  final Set<Transaction> transactions=wallet.getTransactions(true);
  int numInputs=0;
  int numOutputs=0;
  int numSpentOutputs=0;
  for (  final Transaction tx : transactions) {
    numInputs+=tx.getInputs().size();
    final List<TransactionOutput> outputs=tx.getOutputs();
    numOutputs+=outputs.size();
    for (    final TransactionOutput txout : outputs) {
      if (!txout.isAvailableForSpending())       numSpentOutputs++;
    }
  }
  report.append(""String_Node_Str"" + transactions.size() + ""String_Node_Str"");
  report.append(""String_Node_Str"" + numInputs + ""String_Node_Str"");
  report.append(""String_Node_Str"" + numOutputs + ""String_Node_Str""+ numSpentOutputs+ ""String_Node_Str"");
  report.append(""String_Node_Str"" + wallet.getLastBlockSeenHeight() + ""String_Node_Str""+ wallet.getLastBlockSeenHash()+ ""String_Node_Str"");
  report.append(""String_Node_Str"");
  for (  final String db : application.databaseList())   report.append(""String_Node_Str"" + db);
  report.append(""String_Node_Str"");
  final File filesDir=application.getFilesDir();
  report.append(""String_Node_Str"" + filesDir + ""String_Node_Str"");
  appendDir(report,filesDir,0);
}","private void appendApplicationInfo(final Appendable report,final WalletApplication application) throws IOException {
  final PackageInfo pi=application.packageInfo();
  final Configuration configuration=application.getConfiguration();
  final Calendar calendar=new GregorianCalendar(UTC);
  report.append(""String_Node_Str"" + pi.versionName + ""String_Node_Str""+ pi.versionCode+ ""String_Node_Str"");
  report.append(""String_Node_Str"" + pi.packageName + ""String_Node_Str"");
  report.append(""String_Node_Str"" + application.getPackageManager().getInstallerPackageName(pi.packageName) + ""String_Node_Str"");
  report.append(""String_Node_Str"" + (Constants.TEST ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  report.append(""String_Node_Str"" + TimeZone.getDefault().getID() + ""String_Node_Str"");
  calendar.setTimeInMillis(System.currentTimeMillis());
  report.append(""String_Node_Str"" + String.format(Locale.US,""String_Node_Str"",calendar,calendar,calendar) + ""String_Node_Str"");
  calendar.setTimeInMillis(WalletApplication.TIME_CREATE_APPLICATION);
  report.append(""String_Node_Str"" + String.format(Locale.US,""String_Node_Str"",calendar,calendar,calendar) + ""String_Node_Str"");
  calendar.setTimeInMillis(pi.lastUpdateTime);
  report.append(""String_Node_Str"" + String.format(Locale.US,""String_Node_Str"",calendar,calendar,calendar) + ""String_Node_Str"");
  calendar.setTimeInMillis(pi.firstInstallTime);
  report.append(""String_Node_Str"" + String.format(Locale.US,""String_Node_Str"",calendar,calendar,calendar) + ""String_Node_Str"");
  final long lastBackupTime=configuration.getLastBackupTime();
  calendar.setTimeInMillis(lastBackupTime);
  report.append(""String_Node_Str"" + (lastBackupTime > 0 ? String.format(Locale.US,""String_Node_Str"",calendar,calendar,calendar) : ""String_Node_Str"") + ""String_Node_Str"");
  report.append(""String_Node_Str"" + Constants.NETWORK_PARAMETERS.getId() + ""String_Node_Str"");
  final Wallet wallet=viewModel.wallet.getValue();
  report.append(""String_Node_Str"" + wallet.isEncrypted() + ""String_Node_Str"");
  report.append(""String_Node_Str"" + wallet.getKeyChainGroupSize() + ""String_Node_Str"");
  final Set<Transaction> transactions=wallet.getTransactions(true);
  int numInputs=0;
  int numOutputs=0;
  int numSpentOutputs=0;
  for (  final Transaction tx : transactions) {
    numInputs+=tx.getInputs().size();
    final List<TransactionOutput> outputs=tx.getOutputs();
    numOutputs+=outputs.size();
    for (    final TransactionOutput txout : outputs) {
      if (!txout.isAvailableForSpending())       numSpentOutputs++;
    }
  }
  report.append(""String_Node_Str"" + transactions.size() + ""String_Node_Str"");
  report.append(""String_Node_Str"" + numInputs + ""String_Node_Str"");
  report.append(""String_Node_Str"" + numOutputs + ""String_Node_Str""+ numSpentOutputs+ ""String_Node_Str"");
  report.append(""String_Node_Str"" + wallet.getLastBlockSeenHeight() + ""String_Node_Str""+ wallet.getLastBlockSeenHash()+ ""String_Node_Str"");
  report.append(""String_Node_Str"");
  for (  final String db : application.databaseList())   report.append(""String_Node_Str"" + db);
  report.append(""String_Node_Str"");
  final File filesDir=application.getFilesDir();
  report.append(""String_Node_Str"" + filesDir + ""String_Node_Str"");
  appendDir(report,filesDir,0);
}",0.9919244248057292
50819,"private void restorePrivateKeysFromBase58(final File file){
  try (final FileInputStream is=new FileInputStream(file)){
    restoreWallet(WalletUtils.restorePrivateKeysFromBase58(is,Constants.NETWORK_PARAMETERS));
    log.info(""String_Node_Str"",file);
  }
 catch (  final IOException x) {
    FailureDialogFragment.showDialog(getFragmentManager(),x.toString());
    log.info(""String_Node_Str"" + file,x);
  }
}","private void restorePrivateKeysFromBase58(final File file){
  try (final FileInputStream is=new FileInputStream(file)){
    restoreWallet(WalletUtils.restorePrivateKeysFromBase58(is,Constants.NETWORK_PARAMETERS));
    log.info(""String_Node_Str"",file);
  }
 catch (  final IOException x) {
    FailureDialogFragment.showDialog(getFragmentManager(),x.getMessage());
    log.info(""String_Node_Str"" + file,x);
  }
}",0.9780487804878047
50820,"private void restoreWalletFromProtobuf(final File file){
  try (final FileInputStream is=new FileInputStream(file)){
    restoreWallet(WalletUtils.restoreWalletFromProtobuf(is,Constants.NETWORK_PARAMETERS));
    log.info(""String_Node_Str"",file);
  }
 catch (  final IOException x) {
    FailureDialogFragment.showDialog(getFragmentManager(),x.toString());
    log.info(""String_Node_Str"" + file,x);
  }
}","private void restoreWalletFromProtobuf(final File file){
  try (final FileInputStream is=new FileInputStream(file)){
    restoreWallet(WalletUtils.restoreWalletFromProtobuf(is,Constants.NETWORK_PARAMETERS));
    log.info(""String_Node_Str"",file);
  }
 catch (  final IOException x) {
    FailureDialogFragment.showDialog(getFragmentManager(),x.getMessage());
    log.info(""String_Node_Str"" + file,x);
  }
}",0.9777227722772276
50821,"private void restoreWalletFromEncrypted(final File file,final String password){
  try {
    final BufferedReader cipherIn=new BufferedReader(new InputStreamReader(new FileInputStream(file),StandardCharsets.UTF_8));
    final StringBuilder cipherText=new StringBuilder();
    Io.copy(cipherIn,cipherText,Constants.BACKUP_MAX_CHARS);
    cipherIn.close();
    final byte[] plainText=Crypto.decryptBytes(cipherText.toString(),password.toCharArray());
    final InputStream is=new ByteArrayInputStream(plainText);
    restoreWallet(WalletUtils.restoreWalletFromProtobufOrBase58(is,Constants.NETWORK_PARAMETERS));
    log.info(""String_Node_Str"",file);
  }
 catch (  final IOException x) {
    FailureDialogFragment.showDialog(getFragmentManager(),x.toString());
    log.info(""String_Node_Str"" + file,x);
  }
}","private void restoreWalletFromEncrypted(final File file,final String password){
  try {
    final BufferedReader cipherIn=new BufferedReader(new InputStreamReader(new FileInputStream(file),StandardCharsets.UTF_8));
    final StringBuilder cipherText=new StringBuilder();
    Io.copy(cipherIn,cipherText,Constants.BACKUP_MAX_CHARS);
    cipherIn.close();
    final byte[] plainText=Crypto.decryptBytes(cipherText.toString(),password.toCharArray());
    final InputStream is=new ByteArrayInputStream(plainText);
    restoreWallet(WalletUtils.restoreWalletFromProtobufOrBase58(is,Constants.NETWORK_PARAMETERS));
    log.info(""String_Node_Str"",file);
  }
 catch (  final IOException x) {
    FailureDialogFragment.showDialog(getFragmentManager(),x.getMessage());
    log.info(""String_Node_Str"" + file,x);
  }
}",0.9888198757763976
50822,"private void restoreWallet(final Wallet wallet) throws IOException {
  application.replaceWallet(wallet);
  config.disarmBackupReminder();
  SuccessDialogFragment.showDialog(getFragmentManager(),wallet.isEncrypted());
}","private void restoreWallet(final Wallet restoredWallet) throws IOException {
  application.replaceWallet(restoredWallet);
  config.disarmBackupReminder();
  SuccessDialogFragment.showDialog(getFragmentManager(),restoredWallet.isEncrypted());
}",0.935064935064935
50823,"@Override public void onCreate(final Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  viewModel=ViewModelProviders.of(this).get(ReportIssueViewModel.class);
  viewModel.wallet.observe(this,new Observer<Wallet>(){
    @Override public void onChanged(    final Wallet wallet){
      if (wallet != null)       positiveButton.setEnabled(true);
    }
  }
);
}","@Override public void onCreate(final Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  viewModel=ViewModelProviders.of(this).get(ReportIssueViewModel.class);
}",0.6436363636363637
50824,"@Override public void onShow(final DialogInterface d){
  positiveButton=dialog.getButton(DialogInterface.BUTTON_POSITIVE);
  positiveButton.setEnabled(false);
}","@Override public void onShow(final DialogInterface d){
  positiveButton=dialog.getButton(DialogInterface.BUTTON_POSITIVE);
  positiveButton.setEnabled(false);
  viewModel.wallet.observe(ReportIssueDialogFragment.this,new Observer<Wallet>(){
    @Override public void onChanged(    final Wallet wallet){
      positiveButton.setEnabled(true);
    }
  }
);
}",0.6201550387596899
50825,"@Override public void onChanged(final Wallet wallet){
  if (wallet != null)   positiveButton.setEnabled(true);
}","@Override public void onChanged(final Wallet wallet){
  positiveButton.setEnabled(true);
}",0.8910891089108911
50826,"@Override public Dialog onCreateDialog(final Bundle savedInstanceState){
  final Bundle args=getArguments();
  final int titleResId=args.getInt(KEY_TITLE);
  final int messageResId=args.getInt(KEY_MESSAGE);
  final String subject=args.getString(KEY_SUBJECT);
  final String contextualData=args.getString(KEY_CONTEXTUAL_DATA);
  final ReportIssueDialogBuilder builder=new ReportIssueDialogBuilder(activity,titleResId,messageResId){
    @Override protected String subject(){
      return subject + ""String_Node_Str"" + WalletApplication.versionLine(application.packageInfo());
    }
    @Override protected CharSequence collectApplicationInfo() throws IOException {
      final StringBuilder applicationInfo=new StringBuilder();
      appendApplicationInfo(applicationInfo,application);
      return applicationInfo;
    }
    @Override protected CharSequence collectStackTrace() throws IOException {
      final StringBuilder stackTrace=new StringBuilder();
      CrashReporter.appendSavedCrashTrace(stackTrace);
      return stackTrace.length() > 0 ? stackTrace : null;
    }
    @Override protected CharSequence collectDeviceInfo() throws IOException {
      final StringBuilder deviceInfo=new StringBuilder();
      appendDeviceInfo(deviceInfo,activity);
      return deviceInfo;
    }
    @Override protected CharSequence collectContextualData(){
      return contextualData;
    }
    @Override protected CharSequence collectWalletDump(){
      return viewModel.wallet.getValue().toString(false,true,true,null);
    }
  }
;
  final AlertDialog dialog=builder.create();
  dialog.setOnShowListener(new OnShowListener(){
    @Override public void onShow(    final DialogInterface d){
      positiveButton=dialog.getButton(DialogInterface.BUTTON_POSITIVE);
      positiveButton.setEnabled(false);
    }
  }
);
  return dialog;
}","@Override public Dialog onCreateDialog(final Bundle savedInstanceState){
  final Bundle args=getArguments();
  final int titleResId=args.getInt(KEY_TITLE);
  final int messageResId=args.getInt(KEY_MESSAGE);
  final String subject=args.getString(KEY_SUBJECT);
  final String contextualData=args.getString(KEY_CONTEXTUAL_DATA);
  final ReportIssueDialogBuilder builder=new ReportIssueDialogBuilder(activity,titleResId,messageResId){
    @Override protected String subject(){
      return subject + ""String_Node_Str"" + WalletApplication.versionLine(application.packageInfo());
    }
    @Override protected CharSequence collectApplicationInfo() throws IOException {
      final StringBuilder applicationInfo=new StringBuilder();
      appendApplicationInfo(applicationInfo,application);
      return applicationInfo;
    }
    @Override protected CharSequence collectStackTrace() throws IOException {
      final StringBuilder stackTrace=new StringBuilder();
      CrashReporter.appendSavedCrashTrace(stackTrace);
      return stackTrace.length() > 0 ? stackTrace : null;
    }
    @Override protected CharSequence collectDeviceInfo() throws IOException {
      final StringBuilder deviceInfo=new StringBuilder();
      appendDeviceInfo(deviceInfo,activity);
      return deviceInfo;
    }
    @Override protected CharSequence collectContextualData(){
      return contextualData;
    }
    @Override protected CharSequence collectWalletDump(){
      return viewModel.wallet.getValue().toString(false,true,true,null);
    }
  }
;
  final AlertDialog dialog=builder.create();
  dialog.setOnShowListener(new OnShowListener(){
    @Override public void onShow(    final DialogInterface d){
      positiveButton=dialog.getButton(DialogInterface.BUTTON_POSITIVE);
      positiveButton.setEnabled(false);
      viewModel.wallet.observe(ReportIssueDialogFragment.this,new Observer<Wallet>(){
        @Override public void onChanged(        final Wallet wallet){
          positiveButton.setEnabled(true);
        }
      }
);
    }
  }
);
  return dialog;
}",0.935467217346412
50827,"public static String getAddress(final BluetoothAdapter adapter){
  if (adapter == null)   return null;
  final String address=adapter.getAddress();
  if (!MARSHMELLOW_FAKE_MAC.equals(address))   return address;
  try {
    final Field mServiceField=BluetoothAdapter.class.getDeclaredField(""String_Node_Str"");
    mServiceField.setAccessible(true);
    final Object mService=mServiceField.get(adapter);
    if (mService == null)     return null;
    return (String)mService.getClass().getMethod(""String_Node_Str"").invoke(mService);
  }
 catch (  final ReflectiveOperationException x) {
    throw new RuntimeException(x);
  }
}","public static String getAddress(final BluetoothAdapter adapter){
  if (adapter == null)   return null;
  final String address=adapter.getAddress();
  if (!MARSHMELLOW_FAKE_MAC.equals(address))   return address;
  try {
    final Field mServiceField=BluetoothAdapter.class.getDeclaredField(""String_Node_Str"");
    mServiceField.setAccessible(true);
    final Object mService=mServiceField.get(adapter);
    if (mService == null)     return null;
    return (String)mService.getClass().getMethod(""String_Node_Str"").invoke(mService);
  }
 catch (  final Exception x) {
    throw new RuntimeException(x);
  }
}",0.9845653939886272
50828,"private boolean isValidAmount(final boolean zeroIsValid){
  final String str=textView.getText().toString().trim();
  try {
    if (!str.isEmpty()) {
      final Monetary amount;
      if (localCurrencyCode == null)       amount=inputFormat.parse(str);
 else       amount=inputFormat.parseFiat(localCurrencyCode,str);
      return zeroIsValid || amount.signum() > 0;
    }
  }
 catch (  final Exception x) {
  }
  return false;
}","private boolean isValidAmount(final boolean zeroIsValid){
  final String str=textView.getText().toString().trim();
  try {
    if (!str.isEmpty()) {
      final Monetary amount;
      if (localCurrencyCode == null) {
        amount=inputFormat.parse(str);
        if (((Coin)amount).isGreaterThan(Constants.NETWORK_PARAMETERS.getMaxMoney()))         return false;
      }
 else {
        amount=inputFormat.parseFiat(localCurrencyCode,str);
      }
      return zeroIsValid || amount.signum() > 0;
    }
  }
 catch (  final Exception x) {
  }
  return false;
}",0.8582995951417004
50829,"/** 
 * Password based encryption using AES - CBC 256 bits.
 * @param plainBytes The bytes to encrypt
 * @param password The password to use for encryption
 * @return SALT_LENGTH bytes of salt followed by the encrypted bytes.
 * @throws IOException
 */
private static byte[] encrypt(final byte[] plainTextAsBytes,final char[] password) throws IOException {
  try {
    final byte[] salt=new byte[SALT_LENGTH];
    secureRandom.nextBytes(salt);
    final ParametersWithIV key=(ParametersWithIV)getAESPasswordKey(password,salt);
    final BufferedBlockCipher cipher=new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));
    cipher.init(true,key);
    final byte[] encryptedBytes=new byte[cipher.getOutputSize(plainTextAsBytes.length)];
    final int length=cipher.processBytes(plainTextAsBytes,0,plainTextAsBytes.length,encryptedBytes,0);
    cipher.doFinal(encryptedBytes,length);
    return concat(salt,encryptedBytes);
  }
 catch (  final InvalidCipherTextException x) {
    throw new IOException(""String_Node_Str"",x);
  }
catch (  final DataLengthException x) {
    throw new IOException(""String_Node_Str"",x);
  }
}","/** 
 * Password based encryption using AES - CBC 256 bits.
 * @param plainBytes The bytes to encrypt
 * @param password The password to use for encryption
 * @return SALT_LENGTH bytes of salt followed by the encrypted bytes.
 * @throws IOException
 */
private static byte[] encrypt(final byte[] plainTextAsBytes,final char[] password) throws IOException {
  try {
    final byte[] salt=new byte[SALT_LENGTH];
    secureRandom.nextBytes(salt);
    final ParametersWithIV key=(ParametersWithIV)getAESPasswordKey(password,salt);
    final BufferedBlockCipher cipher=new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));
    cipher.init(true,key);
    final byte[] encryptedBytes=new byte[cipher.getOutputSize(plainTextAsBytes.length)];
    final int processLen=cipher.processBytes(plainTextAsBytes,0,plainTextAsBytes.length,encryptedBytes,0);
    final int doFinalLen=cipher.doFinal(encryptedBytes,processLen);
    return concat(salt,Arrays.copyOf(encryptedBytes,processLen + doFinalLen));
  }
 catch (  final InvalidCipherTextException x) {
    throw new IOException(""String_Node_Str"",x);
  }
catch (  final DataLengthException x) {
    throw new IOException(""String_Node_Str"",x);
  }
}",0.9486740804106074
50830,"/** 
 * Decrypt bytes previously encrypted with this class.
 * @param bytesToDecode The bytes to decrypt
 * @param passwordbThe password to use for decryption
 * @return The decrypted bytes
 * @throws IOException
 */
private static byte[] decrypt(final byte[] bytesToDecode,final char[] password) throws IOException {
  try {
    final byte[] salt=new byte[SALT_LENGTH];
    System.arraycopy(bytesToDecode,0,salt,0,SALT_LENGTH);
    final byte[] cipherBytes=new byte[bytesToDecode.length - SALT_LENGTH];
    System.arraycopy(bytesToDecode,SALT_LENGTH,cipherBytes,0,bytesToDecode.length - SALT_LENGTH);
    final ParametersWithIV key=(ParametersWithIV)getAESPasswordKey(password,salt);
    final BufferedBlockCipher cipher=new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));
    cipher.init(false,key);
    final byte[] decryptedBytes=new byte[cipher.getOutputSize(cipherBytes.length)];
    final int length=cipher.processBytes(cipherBytes,0,cipherBytes.length,decryptedBytes,0);
    cipher.doFinal(decryptedBytes,length);
    return decryptedBytes;
  }
 catch (  final InvalidCipherTextException x) {
    throw new IOException(""String_Node_Str"",x);
  }
catch (  final DataLengthException x) {
    throw new IOException(""String_Node_Str"",x);
  }
}","/** 
 * Decrypt bytes previously encrypted with this class.
 * @param bytesToDecode The bytes to decrypt
 * @param passwordbThe password to use for decryption
 * @return The decrypted bytes
 * @throws IOException
 */
private static byte[] decrypt(final byte[] bytesToDecode,final char[] password) throws IOException {
  try {
    final byte[] salt=new byte[SALT_LENGTH];
    System.arraycopy(bytesToDecode,0,salt,0,SALT_LENGTH);
    final byte[] cipherBytes=new byte[bytesToDecode.length - SALT_LENGTH];
    System.arraycopy(bytesToDecode,SALT_LENGTH,cipherBytes,0,bytesToDecode.length - SALT_LENGTH);
    final ParametersWithIV key=(ParametersWithIV)getAESPasswordKey(password,salt);
    final BufferedBlockCipher cipher=new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));
    cipher.init(false,key);
    final byte[] decryptedBytes=new byte[cipher.getOutputSize(cipherBytes.length)];
    final int processLen=cipher.processBytes(cipherBytes,0,cipherBytes.length,decryptedBytes,0);
    final int doFinalLen=cipher.doFinal(decryptedBytes,processLen);
    return Arrays.copyOf(decryptedBytes,processLen + doFinalLen);
  }
 catch (  final InvalidCipherTextException x) {
    throw new IOException(""String_Node_Str"",x);
  }
catch (  final DataLengthException x) {
    throw new IOException(""String_Node_Str"",x);
  }
}",0.8784615384615385
50831,"public static ExchangeRate getExchangeRate(final Cursor cursor){
  final String currencyCode=cursor.getString(cursor.getColumnIndexOrThrow(ExchangeRatesProvider.KEY_CURRENCY_CODE));
  final double rate=cursor.getDouble(cursor.getColumnIndexOrThrow(ExchangeRatesProvider.KEY_RATE));
  final String source=cursor.getString(cursor.getColumnIndexOrThrow(ExchangeRatesProvider.KEY_SOURCE));
  return new ExchangeRate(currencyCode,rate,source);
}","public static ExchangeRate getExchangeRate(final Cursor cursor){
  final String currencyCode=cursor.getString(cursor.getColumnIndexOrThrow(ExchangeRatesProvider.KEY_CURRENCY_CODE));
  final BigInteger rate=BigInteger.valueOf(cursor.getLong(cursor.getColumnIndexOrThrow(ExchangeRatesProvider.KEY_RATE)));
  final String source=cursor.getString(cursor.getColumnIndexOrThrow(ExchangeRatesProvider.KEY_SOURCE));
  return new ExchangeRate(currencyCode,rate,source);
}",0.926829268292683
50832,"private static Map<String,ExchangeRate> getBitcoinCharts(){
  try {
    final URL URL=new URL(""String_Node_Str"");
    final URLConnection connection=URL.openConnection();
    connection.connect();
    final StringBuilder content=new StringBuilder();
    Reader reader=null;
    try {
      reader=new InputStreamReader(new BufferedInputStream(connection.getInputStream(),1024));
      IOUtils.copy(reader,content);
      final Map<String,ExchangeRate> rates=new TreeMap<String,ExchangeRate>();
      final JSONObject head=new JSONObject(content.toString());
      for (final Iterator<String> i=head.keys(); i.hasNext(); ) {
        final String currencyCode=i.next();
        if (!""String_Node_Str"".equals(currencyCode)) {
          final JSONObject o=head.getJSONObject(currencyCode);
          double rate=o.optDouble(""String_Node_Str"",0);
          if (rate == 0)           rate=o.optDouble(""String_Node_Str"",0);
          if (rate == 0)           rate=o.optDouble(""String_Node_Str"",0);
          if (rate != 0)           rates.put(currencyCode,new ExchangeRate(currencyCode,rate,URL.getHost()));
        }
      }
      return rates;
    }
  finally {
      if (reader != null)       reader.close();
    }
  }
 catch (  final IOException x) {
    x.printStackTrace();
  }
catch (  final JSONException x) {
    x.printStackTrace();
  }
  return null;
}","private static Map<String,ExchangeRate> getBitcoinCharts(){
  try {
    final URL URL=new URL(""String_Node_Str"");
    final URLConnection connection=URL.openConnection();
    connection.connect();
    final StringBuilder content=new StringBuilder();
    Reader reader=null;
    try {
      reader=new InputStreamReader(new BufferedInputStream(connection.getInputStream(),1024));
      IOUtils.copy(reader,content);
      final Map<String,ExchangeRate> rates=new TreeMap<String,ExchangeRate>();
      final JSONObject head=new JSONObject(content.toString());
      for (final Iterator<String> i=head.keys(); i.hasNext(); ) {
        final String currencyCode=i.next();
        if (!""String_Node_Str"".equals(currencyCode)) {
          final JSONObject o=head.getJSONObject(currencyCode);
          String rate=o.optString(""String_Node_Str"",null);
          if (rate == null)           rate=o.optString(""String_Node_Str"",null);
          if (rate == null)           rate=o.optString(""String_Node_Str"",null);
          if (rate != null)           rates.put(currencyCode,new ExchangeRate(currencyCode,Utils.toNanoCoins(rate),URL.getHost()));
        }
      }
      return rates;
    }
  finally {
      if (reader != null)       reader.close();
    }
  }
 catch (  final IOException x) {
    x.printStackTrace();
  }
catch (  final JSONException x) {
    x.printStackTrace();
  }
  return null;
}",0.8853294503094284
50833,"public ExchangeRate(final String currencyCode,final double rate,final String source){
  this.currencyCode=currencyCode;
  this.rate=rate;
  this.source=source;
}","public ExchangeRate(final String currencyCode,final BigInteger rate,final String source){
  this.currencyCode=currencyCode;
  this.rate=rate;
  this.source=source;
}",0.9570552147239264
50834,"private static Map<String,ExchangeRate> getBlockchainInfo(){
  try {
    final URL URL=new URL(""String_Node_Str"");
    final URLConnection connection=URL.openConnection();
    connection.connect();
    final StringBuilder content=new StringBuilder();
    Reader reader=null;
    try {
      reader=new InputStreamReader(new BufferedInputStream(connection.getInputStream(),1024));
      IOUtils.copy(reader,content);
      final Map<String,ExchangeRate> rates=new TreeMap<String,ExchangeRate>();
      final JSONObject head=new JSONObject(content.toString());
      for (final Iterator<String> i=head.keys(); i.hasNext(); ) {
        final String currencyCode=i.next();
        final JSONObject o=head.getJSONObject(currencyCode);
        final double rate=o.optDouble(""String_Node_Str"",0);
        if (rate != 0)         rates.put(currencyCode,new ExchangeRate(currencyCode,rate,URL.getHost()));
      }
      return rates;
    }
  finally {
      if (reader != null)       reader.close();
    }
  }
 catch (  final IOException x) {
    x.printStackTrace();
  }
catch (  final JSONException x) {
    x.printStackTrace();
  }
  return null;
}","private static Map<String,ExchangeRate> getBlockchainInfo(){
  try {
    final URL URL=new URL(""String_Node_Str"");
    final URLConnection connection=URL.openConnection();
    connection.connect();
    final StringBuilder content=new StringBuilder();
    Reader reader=null;
    try {
      reader=new InputStreamReader(new BufferedInputStream(connection.getInputStream(),1024));
      IOUtils.copy(reader,content);
      final Map<String,ExchangeRate> rates=new TreeMap<String,ExchangeRate>();
      final JSONObject head=new JSONObject(content.toString());
      for (final Iterator<String> i=head.keys(); i.hasNext(); ) {
        final String currencyCode=i.next();
        final JSONObject o=head.getJSONObject(currencyCode);
        final String rate=o.optString(""String_Node_Str"",null);
        if (rate != null)         rates.put(currencyCode,new ExchangeRate(currencyCode,Utils.toNanoCoins(rate),URL.getHost()));
      }
      return rates;
    }
  finally {
      if (reader != null)       reader.close();
    }
  }
 catch (  final IOException x) {
    x.printStackTrace();
  }
catch (  final JSONException x) {
    x.printStackTrace();
  }
  return null;
}",0.964022540095362
50835,"@Override public Cursor query(final Uri uri,final String[] projection,final String selection,final String[] selectionArgs,final String sortOrder){
  final long now=System.currentTimeMillis();
  if (exchangeRates == null || now - lastUpdated > UPDATE_FREQ_MS) {
    Map<String,ExchangeRate> newExchangeRates=getBitcoinCharts();
    if (exchangeRates == null && newExchangeRates == null)     newExchangeRates=getBlockchainInfo();
    if (newExchangeRates != null) {
      exchangeRates=newExchangeRates;
      lastUpdated=now;
    }
  }
  if (exchangeRates == null)   return null;
  final MatrixCursor cursor=new MatrixCursor(new String[]{BaseColumns._ID,KEY_CURRENCY_CODE,KEY_RATE,KEY_SOURCE});
  if (selection == null) {
    for (    final Map.Entry<String,ExchangeRate> entry : exchangeRates.entrySet()) {
      final ExchangeRate rate=entry.getValue();
      cursor.newRow().add(entry.getKey().hashCode()).add(rate.currencyCode).add(rate.rate).add(rate.source);
    }
  }
 else   if (selection.equals(KEY_CURRENCY_CODE)) {
    final String code=selectionArgs[0];
    final ExchangeRate rate=exchangeRates.get(code);
    cursor.newRow().add(code.hashCode()).add(rate.currencyCode).add(rate.rate).add(rate.source);
  }
  return cursor;
}","@Override public Cursor query(final Uri uri,final String[] projection,final String selection,final String[] selectionArgs,final String sortOrder){
  final long now=System.currentTimeMillis();
  if (exchangeRates == null || now - lastUpdated > UPDATE_FREQ_MS) {
    Map<String,ExchangeRate> newExchangeRates=getBitcoinCharts();
    if (exchangeRates == null && newExchangeRates == null)     newExchangeRates=getBlockchainInfo();
    if (newExchangeRates != null) {
      exchangeRates=newExchangeRates;
      lastUpdated=now;
    }
  }
  if (exchangeRates == null)   return null;
  final MatrixCursor cursor=new MatrixCursor(new String[]{BaseColumns._ID,KEY_CURRENCY_CODE,KEY_RATE,KEY_SOURCE});
  if (selection == null) {
    for (    final Map.Entry<String,ExchangeRate> entry : exchangeRates.entrySet()) {
      final ExchangeRate rate=entry.getValue();
      cursor.newRow().add(entry.getKey().hashCode()).add(rate.currencyCode).add(rate.rate.longValue()).add(rate.source);
    }
  }
 else   if (selection.equals(KEY_CURRENCY_CODE)) {
    final String code=selectionArgs[0];
    final ExchangeRate rate=exchangeRates.get(code);
    cursor.newRow().add(code.hashCode()).add(rate.currencyCode).add(rate.rate.longValue()).add(rate.source);
  }
  return cursor;
}",0.9903923138510808
50836,"@Override public Dialog onCreateDialog(final Bundle savedInstanceState){
  final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(activity);
  exchangeCurrency=prefs.getString(Constants.PREFS_KEY_EXCHANGE_CURRENCY,Constants.DEFAULT_EXCHANGE_CURRENCY);
  final AlertDialog.Builder dialog=new AlertDialog.Builder(activity);
  dialog.setInverseBackgroundForced(true);
  dialog.setTitle(R.string.amount_calculator_dialog_title);
  final View view=inflater.inflate(R.layout.amount_calculator_dialog,null);
  btcAmountView=(CurrencyAmountView)view.findViewById(R.id.amount_calculator_row_btc);
  btcAmountView.setListener(new CurrencyAmountView.Listener(){
    public void changed(){
      if (btcAmountView.getAmount() != null) {
        exchangeDirection=true;
        updateAppearance();
      }
 else {
        localAmountView.setHint(null);
      }
    }
    public void done(){
      AmountCalculatorFragment.this.done();
    }
    public void focusChanged(    final boolean hasFocus){
    }
  }
);
  localAmountView=(CurrencyAmountView)view.findViewById(R.id.amount_calculator_row_local);
  localAmountView.setCurrencyCode(exchangeCurrency);
  localAmountView.setListener(new CurrencyAmountView.Listener(){
    public void changed(){
      if (localAmountView.getAmount() != null) {
        exchangeDirection=false;
        updateAppearance();
      }
 else {
        btcAmountView.setHint(null);
      }
    }
    public void done(){
      AmountCalculatorFragment.this.done();
    }
    public void focusChanged(    final boolean hasFocus){
    }
  }
);
  exchangeRateView=(TextView)view.findViewById(R.id.amount_calculator_rate);
  dialog.setView(view);
  dialog.setPositiveButton(R.string.amount_calculator_dialog_button_use,new DialogInterface.OnClickListener(){
    public void onClick(    final DialogInterface dialog,    final int whichButton){
      done();
    }
  }
);
  dialog.setNegativeButton(R.string.button_cancel,new DialogInterface.OnClickListener(){
    public void onClick(    final DialogInterface dialog,    final int whichButton){
      dismiss();
    }
  }
);
  updateAppearance();
  getLoaderManager().initLoader(0,null,this);
  return dialog.create();
}","@Override public Dialog onCreateDialog(final Bundle savedInstanceState){
  final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(activity);
  exchangeCurrency=prefs.getString(Constants.PREFS_KEY_EXCHANGE_CURRENCY,Constants.DEFAULT_EXCHANGE_CURRENCY);
  final AlertDialog.Builder dialog=new AlertDialog.Builder(activity);
  dialog.setInverseBackgroundForced(true);
  dialog.setTitle(R.string.amount_calculator_dialog_title);
  final View view=inflater.inflate(R.layout.amount_calculator_dialog,null);
  btcAmountView=(CurrencyAmountView)view.findViewById(R.id.amount_calculator_row_btc);
  btcAmountView.setListener(new CurrencyAmountView.Listener(){
    public void changed(){
      if (btcAmountView.getAmount() != null) {
        exchangeDirection=true;
        updateAppearance();
      }
 else {
        localAmountView.setHint(null);
      }
    }
    public void done(){
      AmountCalculatorFragment.this.done();
    }
    public void focusChanged(    final boolean hasFocus){
    }
  }
);
  localAmountView=(CurrencyAmountView)view.findViewById(R.id.amount_calculator_row_local);
  localAmountView.setCurrencyCode(exchangeCurrency);
  localAmountView.setPrecision(Constants.LOCAL_PRECISION);
  localAmountView.setListener(new CurrencyAmountView.Listener(){
    public void changed(){
      if (localAmountView.getAmount() != null) {
        exchangeDirection=false;
        updateAppearance();
      }
 else {
        btcAmountView.setHint(null);
      }
    }
    public void done(){
      AmountCalculatorFragment.this.done();
    }
    public void focusChanged(    final boolean hasFocus){
    }
  }
);
  exchangeRateView=(TextView)view.findViewById(R.id.amount_calculator_rate);
  dialog.setView(view);
  dialog.setPositiveButton(R.string.amount_calculator_dialog_button_use,new DialogInterface.OnClickListener(){
    public void onClick(    final DialogInterface dialog,    final int whichButton){
      done();
    }
  }
);
  dialog.setNegativeButton(R.string.button_cancel,new DialogInterface.OnClickListener(){
    public void onClick(    final DialogInterface dialog,    final int whichButton){
      dismiss();
    }
  }
);
  updateAppearance();
  getLoaderManager().initLoader(0,null,this);
  return dialog.create();
}",0.9867742658596728
50837,"private void updateAppearance(){
  if (exchangeRate != null) {
    localAmountView.setEnabled(true);
    final BigDecimal bdRate=new BigDecimal(exchangeRate.rate);
    if (exchangeDirection) {
      final BigInteger btcAmount=btcAmountView.getAmount();
      if (btcAmount != null) {
        localAmountView.setAmount(null);
        localAmountView.setHint(new BigDecimal(btcAmount).multiply(bdRate).toBigInteger());
        btcAmountView.setHint(null);
      }
    }
 else {
      final BigInteger localAmount=localAmountView.getAmount();
      if (localAmount != null) {
        btcAmountView.setAmount(null);
        btcAmountView.setHint(new BigDecimal(localAmount).divide(bdRate,RoundingMode.HALF_UP).toBigInteger());
        localAmountView.setHint(null);
      }
    }
    exchangeRateView.setText(getString(R.string.amount_calculator_dialog_exchange_rate,exchangeCurrency,WalletUtils.formatValue(WalletUtils.localValue(Utils.COIN,bdRate)),exchangeRate.source));
  }
 else {
    localAmountView.setEnabled(false);
    exchangeRateView.setText(R.string.amount_calculator_dialog_exchange_rate_not_available);
  }
}","private void updateAppearance(){
  if (exchangeRate != null) {
    localAmountView.setEnabled(true);
    if (exchangeDirection) {
      final BigInteger btcAmount=btcAmountView.getAmount();
      if (btcAmount != null) {
        localAmountView.setAmount(null);
        localAmountView.setHint(WalletUtils.localValue(btcAmount,exchangeRate.rate));
        btcAmountView.setHint(null);
      }
    }
 else {
      final BigInteger localAmount=localAmountView.getAmount();
      if (localAmount != null) {
        btcAmountView.setAmount(null);
        btcAmountView.setHint(WalletUtils.btcValue(localAmount,exchangeRate.rate));
        localAmountView.setHint(null);
      }
    }
    exchangeRateView.setText(getString(R.string.amount_calculator_dialog_exchange_rate,exchangeCurrency,WalletUtils.formatValue(WalletUtils.localValue(Utils.COIN,exchangeRate.rate)),exchangeRate.source));
  }
 else {
    localAmountView.setEnabled(false);
    exchangeRateView.setText(R.string.amount_calculator_dialog_exchange_rate_not_available);
  }
}",0.8732001857872735
50838,"private void done(){
  final BigInteger amount=exchangeDirection ? btcAmountView.getAmount() : new BigDecimal(localAmountView.getAmount()).divide(new BigDecimal(exchangeRate.rate),RoundingMode.HALF_UP).toBigInteger();
  ((Listener)getTargetFragment()).useCalculatedAmount(amount);
  dismiss();
}","private void done(){
  final BigInteger amount=exchangeDirection ? btcAmountView.getAmount() : WalletUtils.btcValue(localAmountView.getAmount(),exchangeRate.rate);
  ((Listener)getTargetFragment()).useCalculatedAmount(amount);
  dismiss();
}",0.4701492537313433
50839,"public void setHint(final BigInteger amount){
  final SpannableStringBuilder hint;
  if (amount != null)   hint=new SpannableStringBuilder(WalletUtils.formatValue(amount));
 else   hint=new SpannableStringBuilder(""String_Node_Str"");
  WalletUtils.formatSignificant(hint,smallerInsignificant);
  textView.setHint(hint);
}","public void setHint(final BigInteger amount){
  final SpannableStringBuilder hint;
  if (amount != null)   hint=new SpannableStringBuilder(WalletUtils.formatValue(amount,precision));
 else   hint=new SpannableStringBuilder(""String_Node_Str"");
  WalletUtils.formatSignificant(hint,smallerInsignificant);
  textView.setHint(hint);
}",0.9846153846153848
50840,"public void setAmount(final BigInteger amount){
  if (amount != null)   textView.setText(amountSigned ? WalletUtils.formatValue(amount,Constants.CURRENCY_PLUS_SIGN,Constants.CURRENCY_MINUS_SIGN) : WalletUtils.formatValue(amount));
 else   textView.setText(null);
}","public void setAmount(final BigInteger amount){
  if (amount != null)   textView.setText(amountSigned ? WalletUtils.formatValue(amount,Constants.CURRENCY_PLUS_SIGN,Constants.CURRENCY_MINUS_SIGN,precision) : WalletUtils.formatValue(amount,precision));
 else   textView.setText(null);
}",0.9635036496350364
50841,"@Override public void bindView(final View view,final Context context,final Cursor cursor){
  final ExchangeRate exchangeRate=ExchangeRatesProvider.getExchangeRate(cursor);
  final BigDecimal bdRate=new BigDecimal(exchangeRate.rate);
  final boolean isDefaultCurrency=exchangeRate.currencyCode.equals(defaultCurrency);
  view.setBackgroundResource(isDefaultCurrency ? R.color.bg_less_bright : R.color.bg_bright);
  final View defaultView=view.findViewById(R.id.exchange_rate_row_default);
  defaultView.setVisibility(isDefaultCurrency ? View.VISIBLE : View.INVISIBLE);
  final TextView currencyCodeView=(TextView)view.findViewById(R.id.exchange_rate_row_currency_code);
  currencyCodeView.setText(exchangeRate.currencyCode);
  final CurrencyAmountView rateView=(CurrencyAmountView)view.findViewById(R.id.exchange_rate_row_rate);
  rateView.setCurrencyCode(null);
  rateView.setAmount(WalletUtils.localValue(Utils.COIN,bdRate));
  final CurrencyAmountView walletView=(CurrencyAmountView)view.findViewById(R.id.exchange_rate_row_balance);
  walletView.setCurrencyCode(null);
  walletView.setAmount(WalletUtils.localValue(balance,bdRate));
  walletView.setStrikeThru(Constants.TEST);
  walletView.setTextColor(getResources().getColor(R.color.fg_less_significant));
}","@Override public void bindView(final View view,final Context context,final Cursor cursor){
  final ExchangeRate exchangeRate=ExchangeRatesProvider.getExchangeRate(cursor);
  final boolean isDefaultCurrency=exchangeRate.currencyCode.equals(defaultCurrency);
  view.setBackgroundResource(isDefaultCurrency ? R.color.bg_less_bright : R.color.bg_bright);
  final View defaultView=view.findViewById(R.id.exchange_rate_row_default);
  defaultView.setVisibility(isDefaultCurrency ? View.VISIBLE : View.INVISIBLE);
  final TextView currencyCodeView=(TextView)view.findViewById(R.id.exchange_rate_row_currency_code);
  currencyCodeView.setText(exchangeRate.currencyCode);
  final CurrencyAmountView rateView=(CurrencyAmountView)view.findViewById(R.id.exchange_rate_row_rate);
  rateView.setCurrencyCode(null);
  rateView.setPrecision(Constants.LOCAL_PRECISION);
  rateView.setAmount(WalletUtils.localValue(Utils.COIN,exchangeRate.rate));
  final CurrencyAmountView walletView=(CurrencyAmountView)view.findViewById(R.id.exchange_rate_row_balance);
  walletView.setCurrencyCode(null);
  walletView.setPrecision(Constants.LOCAL_PRECISION);
  walletView.setAmount(WalletUtils.localValue(balance,exchangeRate.rate));
  walletView.setStrikeThru(Constants.TEST);
  walletView.setTextColor(getResources().getColor(R.color.fg_less_significant));
}",0.9224237746043998
50842,"@Override public void onActivityCreated(final Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  setEmptyText(getString(R.string.exchange_rates_fragment_empty_text));
  adapter=new ResourceCursorAdapter(activity,R.layout.exchange_rate_row,null,true){
    @Override public void bindView(    final View view,    final Context context,    final Cursor cursor){
      final ExchangeRate exchangeRate=ExchangeRatesProvider.getExchangeRate(cursor);
      final BigDecimal bdRate=new BigDecimal(exchangeRate.rate);
      final boolean isDefaultCurrency=exchangeRate.currencyCode.equals(defaultCurrency);
      view.setBackgroundResource(isDefaultCurrency ? R.color.bg_less_bright : R.color.bg_bright);
      final View defaultView=view.findViewById(R.id.exchange_rate_row_default);
      defaultView.setVisibility(isDefaultCurrency ? View.VISIBLE : View.INVISIBLE);
      final TextView currencyCodeView=(TextView)view.findViewById(R.id.exchange_rate_row_currency_code);
      currencyCodeView.setText(exchangeRate.currencyCode);
      final CurrencyAmountView rateView=(CurrencyAmountView)view.findViewById(R.id.exchange_rate_row_rate);
      rateView.setCurrencyCode(null);
      rateView.setAmount(WalletUtils.localValue(Utils.COIN,bdRate));
      final CurrencyAmountView walletView=(CurrencyAmountView)view.findViewById(R.id.exchange_rate_row_balance);
      walletView.setCurrencyCode(null);
      walletView.setAmount(WalletUtils.localValue(balance,bdRate));
      walletView.setStrikeThru(Constants.TEST);
      walletView.setTextColor(getResources().getColor(R.color.fg_less_significant));
    }
  }
;
  setListAdapter(adapter);
  getLoaderManager().initLoader(0,null,this);
}","@Override public void onActivityCreated(final Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  setEmptyText(getString(R.string.exchange_rates_fragment_empty_text));
  adapter=new ResourceCursorAdapter(activity,R.layout.exchange_rate_row,null,true){
    @Override public void bindView(    final View view,    final Context context,    final Cursor cursor){
      final ExchangeRate exchangeRate=ExchangeRatesProvider.getExchangeRate(cursor);
      final boolean isDefaultCurrency=exchangeRate.currencyCode.equals(defaultCurrency);
      view.setBackgroundResource(isDefaultCurrency ? R.color.bg_less_bright : R.color.bg_bright);
      final View defaultView=view.findViewById(R.id.exchange_rate_row_default);
      defaultView.setVisibility(isDefaultCurrency ? View.VISIBLE : View.INVISIBLE);
      final TextView currencyCodeView=(TextView)view.findViewById(R.id.exchange_rate_row_currency_code);
      currencyCodeView.setText(exchangeRate.currencyCode);
      final CurrencyAmountView rateView=(CurrencyAmountView)view.findViewById(R.id.exchange_rate_row_rate);
      rateView.setCurrencyCode(null);
      rateView.setPrecision(Constants.LOCAL_PRECISION);
      rateView.setAmount(WalletUtils.localValue(Utils.COIN,exchangeRate.rate));
      final CurrencyAmountView walletView=(CurrencyAmountView)view.findViewById(R.id.exchange_rate_row_balance);
      walletView.setCurrencyCode(null);
      walletView.setPrecision(Constants.LOCAL_PRECISION);
      walletView.setAmount(WalletUtils.localValue(balance,exchangeRate.rate));
      walletView.setStrikeThru(Constants.TEST);
      walletView.setTextColor(getResources().getColor(R.color.fg_less_significant));
    }
  }
;
  setListAdapter(adapter);
  getLoaderManager().initLoader(0,null,this);
}",0.9387755102040816
50843,"@Override public void onViewCreated(final View view,final Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  viewBalance=(CurrencyAmountView)view.findViewById(R.id.wallet_balance);
  viewBalanceLocal=(CurrencyAmountView)view.findViewById(R.id.wallet_balance_local);
  viewBalanceLocal.setSmallerInsignificant(false);
  viewBalanceLocal.setStrikeThru(Constants.TEST);
}","@Override public void onViewCreated(final View view,final Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  viewBalance=(CurrencyAmountView)view.findViewById(R.id.wallet_balance);
  viewBalanceLocal=(CurrencyAmountView)view.findViewById(R.id.wallet_balance_local);
  viewBalanceLocal.setPrecision(Constants.LOCAL_PRECISION);
  viewBalanceLocal.setSmallerInsignificant(false);
  viewBalanceLocal.setStrikeThru(Constants.TEST);
}",0.9294117647058824
50844,"private void updateView(){
  if (!showLocalBalance)   viewBalanceLocal.setVisibility(View.GONE);
  if (balance != null) {
    viewBalance.setVisibility(View.VISIBLE);
    viewBalance.setAmount(balance);
    if (showLocalBalance) {
      if (exchangeRate != null) {
        final BigInteger balance=wallet.getBalance(BalanceType.ESTIMATED);
        final BigDecimal bdRate=new BigDecimal(exchangeRate.rate);
        final BigInteger localValue=WalletUtils.localValue(balance,bdRate);
        viewBalanceLocal.setVisibility(View.VISIBLE);
        viewBalanceLocal.setCurrencyCode(Constants.PREFIX_ALMOST_EQUAL_TO + exchangeRate.currencyCode);
        viewBalanceLocal.setAmount(localValue);
        viewBalanceLocal.setTextColor(getResources().getColor(R.color.fg_less_significant));
      }
 else {
        viewBalanceLocal.setVisibility(View.INVISIBLE);
      }
    }
  }
 else {
    viewBalance.setVisibility(View.INVISIBLE);
  }
}","private void updateView(){
  if (!showLocalBalance)   viewBalanceLocal.setVisibility(View.GONE);
  if (balance != null) {
    viewBalance.setVisibility(View.VISIBLE);
    viewBalance.setAmount(balance);
    if (showLocalBalance) {
      if (exchangeRate != null) {
        final BigInteger balance=wallet.getBalance(BalanceType.ESTIMATED);
        final BigInteger localValue=WalletUtils.localValue(balance,exchangeRate.rate);
        viewBalanceLocal.setVisibility(View.VISIBLE);
        viewBalanceLocal.setCurrencyCode(Constants.PREFIX_ALMOST_EQUAL_TO + exchangeRate.currencyCode);
        viewBalanceLocal.setAmount(localValue);
        viewBalanceLocal.setTextColor(getResources().getColor(R.color.fg_less_significant));
      }
 else {
        viewBalanceLocal.setVisibility(View.INVISIBLE);
      }
    }
  }
 else {
    viewBalance.setVisibility(View.INVISIBLE);
  }
}",0.9546460176991152
50845,"public static String formatValue(final BigInteger value,final String plusSign,final String minusSign){
  final boolean negative=value.compareTo(BigInteger.ZERO) < 0;
  final BigInteger absValue=value.abs();
  final String sign=negative ? minusSign : plusSign;
  final int coins=absValue.divide(Utils.COIN).intValue();
  final int cents=absValue.remainder(Utils.COIN).intValue();
  if (cents % 1000000 == 0)   return String.format(Locale.US,""String_Node_Str"",sign,coins,cents / 1000000);
 else   if (cents % 10000 == 0)   return String.format(Locale.US,""String_Node_Str"",sign,coins,cents / 10000);
 else   return String.format(Locale.US,""String_Node_Str"",sign,coins,cents);
}","public static String formatValue(final BigInteger value,final String plusSign,final String minusSign,final int precision){
  final boolean negative=value.compareTo(BigInteger.ZERO) < 0;
  final BigInteger absValue=value.abs();
  final String sign=negative ? minusSign : plusSign;
  final int coins=absValue.divide(Utils.COIN).intValue();
  final int cents=absValue.remainder(Utils.COIN).intValue();
  if (cents % 1000000 == 0 || precision <= 2)   return String.format(Locale.US,""String_Node_Str"",sign,coins,cents / 1000000);
 else   if (cents % 10000 == 0 || precision <= 4)   return String.format(Locale.US,""String_Node_Str"",sign,coins,cents / 10000);
 else   return String.format(Locale.US,""String_Node_Str"",sign,coins,cents);
}",0.96011396011396
50846,"public static BigInteger localValue(final BigInteger btcValue,final BigDecimal exchangeRate){
  final BigDecimal value=new BigDecimal(btcValue).multiply(exchangeRate);
  final BigDecimal remainder=value.remainder(LOCAL_VALUE_PRECISION);
  return value.subtract(remainder).toBigInteger();
}","public static BigInteger localValue(final BigInteger btcValue,final BigInteger rate){
  return btcValue.multiply(rate).divide(Utils.COIN);
}",0.5547785547785548
50847,"public void onClick(final DialogInterface dialog,final int which){
  stackTraceFile.delete();
  dialog.dismiss();
}","public void onClick(final DialogInterface dialog,final int which){
  stackTraceFile.delete();
}",0.9047619047619048
50848,"public synchronized void check(final Context context){
  if (!stackTraceFile.exists())   return;
  final Builder builder=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(DIALOG_TITLE).setMessage(DIALOG_MESSAGE);
  builder.setPositiveButton(""String_Node_Str"",new OnClickListener(){
    public void onClick(    final DialogInterface dialog,    final int which){
      sendError(context);
      stackTraceFile.delete();
    }
  }
);
  builder.setNegativeButton(""String_Node_Str"",new OnClickListener(){
    public void onClick(    final DialogInterface dialog,    final int which){
      stackTraceFile.delete();
      dialog.dismiss();
    }
  }
);
  try {
    builder.show();
  }
 catch (  final Exception x) {
  }
}","public synchronized void check(final Context context){
  if (!stackTraceFile.exists())   return;
  final Builder builder=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(DIALOG_TITLE).setMessage(DIALOG_MESSAGE);
  builder.setPositiveButton(""String_Node_Str"",new OnClickListener(){
    public void onClick(    final DialogInterface dialog,    final int which){
      sendError(context);
      stackTraceFile.delete();
    }
  }
);
  builder.setNegativeButton(""String_Node_Str"",new OnClickListener(){
    public void onClick(    final DialogInterface dialog,    final int which){
      stackTraceFile.delete();
    }
  }
);
  builder.setOnCancelListener(new OnCancelListener(){
    public void onCancel(    final DialogInterface dialog){
      stackTraceFile.delete();
    }
  }
);
  try {
    builder.show();
  }
 catch (  final Exception x) {
  }
}",0.8985330073349633
50849,"public synchronized void uncaughtException(final Thread t,final Throwable e){
  report.append(""String_Node_Str"");
  report.append(""String_Node_Str"" + getTotalInternalMemorySize() + ""String_Node_Str"");
  report.append(""String_Node_Str"" + getAvailableInternalMemorySize() + ""String_Node_Str"");
  report.append(""String_Node_Str"");
  final Writer result=new StringWriter();
  final PrintWriter printWriter=new PrintWriter(result);
  e.printStackTrace(printWriter);
  final String stacktrace=result.toString();
  report.append(stacktrace + ""String_Node_Str"");
  Throwable cause=e.getCause();
  while (cause != null) {
    cause.printStackTrace(printWriter);
    report.append(""String_Node_Str"");
    report.append(result.toString() + ""String_Node_Str"");
    cause=cause.getCause();
  }
  printWriter.close();
  report.append(""String_Node_Str"" + filesDir + ""String_Node_Str"");
  appendReport(report,filesDir,0);
  report.append(""String_Node_Str"" + cacheDir + ""String_Node_Str"");
  appendReport(report,cacheDir,0);
  Process process=null;
  try {
    process=Runtime.getRuntime().exec(""String_Node_Str"");
    final BufferedReader logReader=new BufferedReader(new InputStreamReader(process.getInputStream()));
    report.append('\n');
    String line;
    while ((line=logReader.readLine()) != null)     report.append(line).append('\n');
    logReader.close();
  }
 catch (  final IOException x) {
    x.printStackTrace();
  }
 finally {
    if (process != null)     process.destroy();
  }
  saveAsFile(report.toString());
  previousHandler.uncaughtException(t,e);
}","public synchronized void uncaughtException(final Thread t,final Throwable e){
  Process process=null;
  try {
    report.append(""String_Node_Str"");
    report.append(""String_Node_Str"" + getTotalInternalMemorySize() + ""String_Node_Str"");
    report.append(""String_Node_Str"" + getAvailableInternalMemorySize() + ""String_Node_Str"");
    report.append(""String_Node_Str"");
    final Writer result=new StringWriter();
    final PrintWriter printWriter=new PrintWriter(result);
    e.printStackTrace(printWriter);
    final String stacktrace=result.toString();
    report.append(stacktrace + ""String_Node_Str"");
    Throwable cause=e.getCause();
    while (cause != null) {
      cause.printStackTrace(printWriter);
      report.append(""String_Node_Str"");
      report.append(result.toString() + ""String_Node_Str"");
      cause=cause.getCause();
    }
    printWriter.close();
    report.append(""String_Node_Str"" + filesDir + ""String_Node_Str"");
    appendReport(report,filesDir,0);
    report.append(""String_Node_Str"" + cacheDir + ""String_Node_Str"");
    appendReport(report,cacheDir,0);
    process=Runtime.getRuntime().exec(""String_Node_Str"");
    final BufferedReader logReader=new BufferedReader(new InputStreamReader(process.getInputStream()));
    report.append('\n');
    String line;
    while ((line=logReader.readLine()) != null)     report.append(line).append('\n');
    logReader.close();
    saveAsFile(report.toString());
  }
 catch (  final Exception x) {
    x.printStackTrace();
  }
 finally {
    if (process != null)     process.destroy();
  }
  previousHandler.uncaughtException(t,e);
}",0.9442685243825206
50850,"private void loadWalletFromProtobuf(){
  if (walletFile.exists()) {
    final long start=System.currentTimeMillis();
    FileInputStream walletStream=null;
    try {
      walletStream=new FileInputStream(walletFile);
      final WalletProtobufSerializer walletSerializer=new WalletProtobufSerializer();
      final File blockChainFile=new File(getDir(""String_Node_Str"",Context.MODE_WORLD_READABLE | Context.MODE_WORLD_WRITEABLE),Constants.BLOCKCHAIN_FILENAME);
      if (blockChainFile.exists()) {
        try {
          final BlockStore blockStore=new BoundedOverheadBlockStore(Constants.NETWORK_PARAMETERS,blockChainFile);
          walletSerializer.setChainHeight(blockStore.getChainHead().getHeight());
          blockStore.close();
        }
 catch (        final BlockStoreException x) {
          x.printStackTrace();
        }
      }
      wallet=walletSerializer.readWallet(walletStream);
    }
 catch (    final IOException x) {
      x.printStackTrace();
      Toast.makeText(WalletApplication.this,x.getClass().getName(),Toast.LENGTH_LONG).show();
      wallet=restoreWalletFromBackup();
    }
catch (    final IllegalStateException x) {
      x.printStackTrace();
      Toast.makeText(WalletApplication.this,x.getClass().getName(),Toast.LENGTH_LONG).show();
      wallet=restoreWalletFromBackup();
    }
 finally {
      if (walletStream != null) {
        try {
          walletStream.close();
        }
 catch (        final IOException x) {
          x.printStackTrace();
        }
      }
    }
    if (!wallet.isConsistent()) {
      Toast.makeText(this,""String_Node_Str"" + walletFile,Toast.LENGTH_LONG).show();
      wallet=restoreWalletFromBackup();
    }
    if (!wallet.getParams().equals(Constants.NETWORK_PARAMETERS))     throw new Error(""String_Node_Str"" + wallet.getParams().getId());
    System.out.println(""String_Node_Str"" + walletFile + ""String_Node_Str""+ (System.currentTimeMillis() - start)+ ""String_Node_Str"");
  }
 else {
    try {
      wallet=restoreWalletFromSnapshot();
    }
 catch (    final FileNotFoundException x) {
      wallet=new Wallet(Constants.NETWORK_PARAMETERS);
      wallet.addKey(new ECKey());
      try {
        protobufSerializeWallet(wallet);
        System.out.println(""String_Node_Str"" + walletFile + ""String_Node_Str"");
      }
 catch (      final IOException x2) {
        throw new Error(""String_Node_Str"",x2);
      }
    }
  }
}","private void loadWalletFromProtobuf(){
  if (walletFile.exists()) {
    final long start=System.currentTimeMillis();
    FileInputStream walletStream=null;
    try {
      walletStream=new FileInputStream(walletFile);
      final WalletProtobufSerializer walletSerializer=new WalletProtobufSerializer();
      final File blockChainFile=new File(getDir(""String_Node_Str"",Context.MODE_WORLD_READABLE | Context.MODE_WORLD_WRITEABLE),Constants.BLOCKCHAIN_FILENAME);
      if (blockChainFile.exists()) {
        try {
          final BlockStore blockStore=new BoundedOverheadBlockStore(Constants.NETWORK_PARAMETERS,blockChainFile);
          walletSerializer.setChainHeight(blockStore.getChainHead().getHeight());
          blockStore.close();
        }
 catch (        final BlockStoreException x) {
          x.printStackTrace();
        }
      }
      wallet=walletSerializer.readWallet(walletStream);
      System.out.println(""String_Node_Str"" + walletFile + ""String_Node_Str""+ (System.currentTimeMillis() - start)+ ""String_Node_Str"");
    }
 catch (    final IOException x) {
      x.printStackTrace();
      Toast.makeText(WalletApplication.this,x.getClass().getName(),Toast.LENGTH_LONG).show();
      wallet=restoreWalletFromBackup();
    }
catch (    final IllegalStateException x) {
      x.printStackTrace();
      Toast.makeText(WalletApplication.this,x.getClass().getName(),Toast.LENGTH_LONG).show();
      wallet=restoreWalletFromBackup();
    }
 finally {
      if (walletStream != null) {
        try {
          walletStream.close();
        }
 catch (        final IOException x) {
          x.printStackTrace();
        }
      }
    }
    if (!wallet.isConsistent()) {
      Toast.makeText(this,""String_Node_Str"" + walletFile,Toast.LENGTH_LONG).show();
      wallet=restoreWalletFromBackup();
    }
    if (!wallet.getParams().equals(Constants.NETWORK_PARAMETERS))     throw new Error(""String_Node_Str"" + wallet.getParams().getId());
  }
 else {
    try {
      wallet=restoreWalletFromSnapshot();
    }
 catch (    final FileNotFoundException x) {
      wallet=new Wallet(Constants.NETWORK_PARAMETERS);
      wallet.addKey(new ECKey());
      try {
        protobufSerializeWallet(wallet);
        System.out.println(""String_Node_Str"" + walletFile + ""String_Node_Str"");
      }
 catch (      final IOException x2) {
        throw new Error(""String_Node_Str"",x2);
      }
    }
  }
}",0.9440967876512308
50851,"private Wallet restoreWalletFromBackup(){
  try {
    final Wallet wallet=readKeys(openFileInput(Constants.WALLET_KEY_BACKUP_BASE58));
    final File file=new File(getDir(""String_Node_Str"",Context.MODE_WORLD_READABLE | Context.MODE_WORLD_WRITEABLE),Constants.BLOCKCHAIN_FILENAME);
    file.delete();
    Toast.makeText(this,R.string.toast_wallet_reset,Toast.LENGTH_LONG).show();
    return wallet;
  }
 catch (  final IOException x) {
    throw new RuntimeException(x);
  }
}","private Wallet restoreWalletFromBackup(){
  try {
    final Wallet wallet=readKeys(openFileInput(Constants.WALLET_KEY_BACKUP_BASE58));
    final File file=new File(getDir(""String_Node_Str"",Context.MODE_WORLD_READABLE | Context.MODE_WORLD_WRITEABLE),Constants.BLOCKCHAIN_FILENAME);
    file.delete();
    Toast.makeText(this,R.string.toast_wallet_reset,Toast.LENGTH_LONG).show();
    System.out.println(""String_Node_Str"" + Constants.WALLET_KEY_BACKUP_BASE58 + ""String_Node_Str"");
    return wallet;
  }
 catch (  final IOException x) {
    throw new RuntimeException(x);
  }
}",0.9047619047619048
50852,"private Wallet restoreWalletFromSnapshot() throws FileNotFoundException {
  try {
    final Wallet wallet=readKeys(getAssets().open(Constants.WALLET_KEY_BACKUP_SNAPSHOT));
    System.out.println(""String_Node_Str"");
    return wallet;
  }
 catch (  final FileNotFoundException x) {
    throw x;
  }
catch (  final IOException x) {
    throw new RuntimeException(x);
  }
}","private Wallet restoreWalletFromSnapshot() throws FileNotFoundException {
  try {
    final Wallet wallet=readKeys(getAssets().open(Constants.WALLET_KEY_BACKUP_SNAPSHOT));
    System.out.println(""String_Node_Str"" + Constants.WALLET_KEY_BACKUP_SNAPSHOT + ""String_Node_Str"");
    return wallet;
  }
 catch (  final FileNotFoundException x) {
    throw x;
  }
catch (  final IOException x) {
    throw new RuntimeException(x);
  }
}",0.9261576971214016
50853,"/** 
 * Returns the time at which the block was solved and broadcast, according to the clock of the solving node. 
 */
public long getTime(){
  return time;
}","/** 
 * Returns the time in seconds at which the block was solved and broadcast, according to the clock of the solving node. 
 */
public long getTime(){
  return time;
}",0.9663608562691132
50854,"public int getMaxConnections(){
  return maxConnections;
}","public int getMaxConnections(){
  return peerPool.getMaximumPoolSize();
}",0.732824427480916
50855,"/** 
 * Create a PeerGroup
 */
public PeerGroup(BlockStore blockStore,NetworkParameters params,BlockChain chain,Wallet wallet,final PeerConnectionListener peerConnectionListener){
  this.maxConnections=DEFAULT_CONNECTIONS;
  this.blockStore=blockStore;
  this.params=params;
  this.chain=chain;
  this.wallet=wallet;
  this.peerConnectionListener=peerConnectionListener;
  inactives=new LinkedBlockingQueue<PeerAddress>();
  peers=Collections.synchronizedSet(new HashSet<Peer>());
  peerPool=new ThreadPoolExecutor(CORE_THREADS,this.maxConnections,THREAD_KEEP_ALIVE_SECONDS,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>(1),new PeerGroupThreadFactory());
}","/** 
 * Create a PeerGroup
 */
public PeerGroup(BlockStore blockStore,NetworkParameters params,BlockChain chain,Wallet wallet,final PeerConnectionListener peerConnectionListener){
  this.blockStore=blockStore;
  this.params=params;
  this.chain=chain;
  this.wallet=wallet;
  this.peerConnectionListener=peerConnectionListener;
  inactives=new LinkedBlockingQueue<PeerAddress>();
  peers=Collections.synchronizedSet(new HashSet<Peer>());
  peerPool=new ThreadPoolExecutor(CORE_THREADS,DEFAULT_CONNECTIONS,THREAD_KEEP_ALIVE_SECONDS,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>(1),new PeerGroupThreadFactory());
}",0.5027407987470635
50856,"/** 
 * Depending on the environment, this should normally be between 1 and 10, default is 4.
 * @param maxConnections the maximum number of peer connections that this group will try to make.
 */
public void setMaxConnections(int maxConnections){
  this.maxConnections=maxConnections;
  peerPool.setMaximumPoolSize(maxConnections);
}","/** 
 * Depending on the environment, this should normally be between 1 and 10, default is 4.
 * @param maxConnections the maximum number of peer connections that this group will try to make.
 */
public void setMaxConnections(int maxConnections){
  peerPool.setMaximumPoolSize(maxConnections);
}",0.9394904458598726
50857,"/** 
 * Start downloading the blockchain from the first available peer. <p>If no peers are currently connected, the download will be started once a peer starts.  If the peer dies, the download will resume with another peer.
 * @param listener a listener for chain download events, may not be null
 */
public synchronized void startBlockChainDownload(PeerEventListener listener){
  this.downloadListener=listener;
  if (!peers.isEmpty()) {
synchronized (peers) {
      startBlockChainDownloadFromPeer(peers.iterator().next());
    }
  }
}","/** 
 * Start downloading the blockchain from the first available peer. <p>If no peers are currently connected, the download will be started once a peer starts.  If the peer dies, the download will resume with another peer.
 * @param listener a listener for chain download events, may not be null
 */
public synchronized void startBlockChainDownload(PeerEventListener listener){
  this.downloadListener=listener;
synchronized (peers) {
    if (!peers.isEmpty()) {
      startBlockChainDownloadFromPeer(peers.iterator().next());
    }
  }
}",0.9553903345724908
50858,"protected synchronized void handlePeerDeath(Peer peer){
  if (peer == downloadPeer) {
    downloadPeer=null;
    if (downloadListener != null && !peers.isEmpty()) {
synchronized (peers) {
        startBlockChainDownloadFromPeer(peers.iterator().next());
      }
    }
  }
}","protected synchronized void handlePeerDeath(Peer peer){
  if (peer == downloadPeer) {
    downloadPeer=null;
synchronized (peers) {
      if (downloadListener != null && !peers.isEmpty()) {
        startBlockChainDownloadFromPeer(peers.iterator().next());
      }
    }
  }
}",0.9124087591240876
50859,"public String getConnectString(){
  return connectInfo.toString();
}","public String getConnectString(){
  final Util.PropertyList connectInfoClone=connectInfo.clone();
  connectInfoClone.remove(RolapConnectionProperties.JdbcPassword.name());
  return connectInfoClone.toString();
}",0.4874551971326165
50860,"private int computeHashCode(){
  int hash=42;
  hash=Util.hash(hash,schemaName);
  hash=Util.hash(hash,schemaChecksum);
  hash=Util.hash(hash,cubeName);
  hash=Util.hash(hash,measureName);
  for (  SegmentColumn col : this.constrainedColumns) {
    hash=Util.hash(hash,col.columnExpression);
    if (col.values != null) {
      hash=Util.hashArray(hash,col.values.toArray());
    }
  }
  for (  SegmentColumn col : this.excludedRegions) {
    hash=Util.hash(hash,col.columnExpression);
    if (col.values != null) {
      hash=Util.hashArray(hash,col.values.toArray());
    }
  }
  hash=Util.hash(hash,compoundPredicates);
  return hash;
}","private int computeHashCode(){
  int hash=42;
  hash=Util.hash(hash,schemaName);
  hash=Util.hash(hash,schemaChecksum);
  hash=Util.hash(hash,cubeName);
  hash=Util.hash(hash,measureName);
  for (  SegmentColumn col : getSortedColumns()) {
    hash=Util.hash(hash,col.columnExpression);
    if (col.values != null) {
      hash=Util.hashArray(hash,col.values.toArray());
    }
  }
  for (  SegmentColumn col : getSortedRegions()) {
    hash=Util.hash(hash,col.columnExpression);
    if (col.values != null) {
      hash=Util.hashArray(hash,col.values.toArray());
    }
  }
  hash=Util.hash(hash,compoundPredicates);
  return hash;
}",0.966168371361133
50861,"/** 
 * Returns a human readable description of this segment header.
 * @return A string describing the header.
 */
public String getDescription(){
  if (this.description == null) {
    StringBuilder descriptionSB=new StringBuilder();
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(this.schemaName);
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(this.schemaChecksum);
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(this.cubeName);
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(this.measureName);
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(""String_Node_Str"");
    for (    SegmentColumn c : constrainedColumns) {
      descriptionSB.append(""String_Node_Str"");
      descriptionSB.append(c.columnExpression);
      descriptionSB.append(""String_Node_Str"");
      if (c.values == null) {
        descriptionSB.append(""String_Node_Str"");
      }
 else {
        for (        Object value : c.values) {
          descriptionSB.append(""String_Node_Str"");
          descriptionSB.append(value);
          descriptionSB.append(""String_Node_Str"");
        }
      }
      descriptionSB.deleteCharAt(descriptionSB.length() - 1);
      descriptionSB.append(""String_Node_Str"");
    }
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(""String_Node_Str"");
    for (    SegmentColumn c : excludedRegions) {
      descriptionSB.append(""String_Node_Str"");
      descriptionSB.append(c.columnExpression);
      descriptionSB.append(""String_Node_Str"");
      if (c.values == null) {
        descriptionSB.append(""String_Node_Str"");
      }
 else {
        for (        Object value : c.values) {
          descriptionSB.append(""String_Node_Str"");
          descriptionSB.append(value);
          descriptionSB.append(""String_Node_Str"");
        }
      }
      descriptionSB.deleteCharAt(descriptionSB.length() - 1);
      descriptionSB.append(""String_Node_Str"");
    }
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(""String_Node_Str"");
    for (    String c : compoundPredicates) {
      descriptionSB.append(""String_Node_Str"");
      descriptionSB.append(c);
    }
    descriptionSB.append(""String_Node_Str"").append(""String_Node_Str"").append(getUniqueID()).append(""String_Node_Str"");
    this.description=descriptionSB.toString();
  }
  return description;
}","/** 
 * Returns a human readable description of this segment header.
 * @return A string describing the header.
 */
public String getDescription(){
  if (this.description == null) {
    StringBuilder descriptionSB=new StringBuilder();
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(this.schemaName);
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(this.schemaChecksum);
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(this.cubeName);
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(this.measureName);
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(""String_Node_Str"");
    for (    SegmentColumn c : getSortedColumns()) {
      descriptionSB.append(""String_Node_Str"");
      descriptionSB.append(c.columnExpression);
      descriptionSB.append(""String_Node_Str"");
      if (c.values == null) {
        descriptionSB.append(""String_Node_Str"");
      }
 else {
        for (        Object value : c.values) {
          descriptionSB.append(""String_Node_Str"");
          descriptionSB.append(value);
          descriptionSB.append(""String_Node_Str"");
        }
      }
      descriptionSB.deleteCharAt(descriptionSB.length() - 1);
      descriptionSB.append(""String_Node_Str"");
    }
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(""String_Node_Str"");
    for (    SegmentColumn c : getSortedRegions()) {
      descriptionSB.append(""String_Node_Str"");
      descriptionSB.append(c.columnExpression);
      descriptionSB.append(""String_Node_Str"");
      if (c.values == null) {
        descriptionSB.append(""String_Node_Str"");
      }
 else {
        for (        Object value : c.values) {
          descriptionSB.append(""String_Node_Str"");
          descriptionSB.append(value);
          descriptionSB.append(""String_Node_Str"");
        }
      }
      descriptionSB.deleteCharAt(descriptionSB.length() - 1);
      descriptionSB.append(""String_Node_Str"");
    }
    descriptionSB.append(""String_Node_Str"");
    descriptionSB.append(""String_Node_Str"");
    for (    String c : compoundPredicates) {
      descriptionSB.append(""String_Node_Str"");
      descriptionSB.append(c);
    }
    descriptionSB.append(""String_Node_Str"").append(""String_Node_Str"").append(getUniqueID()).append(""String_Node_Str"");
    this.description=descriptionSB.toString();
  }
  return description;
}",0.9932666802693328
50862,"/** 
 * Returns a unique identifier for this header. The identifier can be used for storage and will be the same across segments which have the same schema name, cube name, measure name, and for each constrained column, the same column name, table name, and predicate values.
 * @return A unique identification string.
 */
public ByteString getUniqueID(){
  if (this.uniqueID == null) {
    StringBuilder hashSB=new StringBuilder();
    hashSB.append(this.schemaName);
    hashSB.append(this.schemaChecksum);
    hashSB.append(this.cubeName);
    hashSB.append(this.measureName);
    for (    SegmentColumn c : constrainedColumns) {
      hashSB.append(c.columnExpression);
      if (c.values != null) {
        for (        Object value : c.values) {
          hashSB.append(String.valueOf(value));
        }
      }
    }
    for (    SegmentColumn c : excludedRegions) {
      hashSB.append(c.columnExpression);
      if (c.values != null) {
        for (        Object value : c.values) {
          hashSB.append(String.valueOf(value));
        }
      }
    }
    for (    String c : compoundPredicates) {
      hashSB.append(c);
    }
    this.uniqueID=new ByteString(Util.digestSha256(hashSB.toString()));
  }
  return uniqueID;
}","/** 
 * Returns a unique identifier for this header. The identifier can be used for storage and will be the same across segments which have the same schema name, cube name, measure name, and for each constrained column, the same column name, table name, and predicate values.
 * @return A unique identification string.
 */
public ByteString getUniqueID(){
  if (this.uniqueID == null) {
    StringBuilder hashSB=new StringBuilder();
    hashSB.append(this.schemaName);
    hashSB.append(this.schemaChecksum);
    hashSB.append(this.cubeName);
    hashSB.append(this.measureName);
    for (    SegmentColumn c : getSortedColumns()) {
      hashSB.append(c.columnExpression);
      if (c.values != null) {
        for (        Object value : c.values) {
          hashSB.append(String.valueOf(value));
        }
      }
    }
    for (    SegmentColumn c : getSortedRegions()) {
      hashSB.append(c.columnExpression);
      if (c.values != null) {
        for (        Object value : c.values) {
          hashSB.append(String.valueOf(value));
        }
      }
    }
    for (    String c : compoundPredicates) {
      hashSB.append(c);
    }
    this.uniqueID=new ByteString(Util.digestSha256(hashSB.toString()));
  }
  return uniqueID;
}",0.9866774323778764
50863,"private StarPredicate makeUnaryPredicate(RolapCubeMember member,RolapCube baseCube,Evaluator evaluator){
  List<Member> expandedMemberList=SqlConstraintUtils.expandSupportedCalculatedMember(member,evaluator);
  for (  Member checkMember : expandedMemberList) {
    if (checkMember == null || checkMember.isCalculated() || !(checkMember instanceof RolapCubeMember)) {
      throw MondrianResource.instance().UnsupportedCalculatedMember.ex(member.getName(),null);
    }
  }
  List<StarPredicate> predicates=new ArrayList<StarPredicate>(expandedMemberList.size());
  for (  Member iMember : expandedMemberList) {
    RolapCubeMember iCubeMember=((RolapCubeMember)iMember);
    RolapCubeLevel iLevel=iCubeMember.getLevel();
    RolapStar.Column iColumn=iLevel.getBaseStarKeyColumn(baseCube);
    Object iKey=iCubeMember.getKey();
    StarPredicate iPredicate=new ValueColumnPredicate(iColumn,iKey);
    predicates.add(iPredicate);
  }
  StarPredicate r=null;
  if (predicates.size() == 1) {
    r=predicates.get(0);
  }
 else {
    r=new OrPredicate(predicates);
  }
  return r;
}","private StarPredicate makeUnaryPredicate(RolapCubeMember member,RolapCube baseCube,Evaluator evaluator){
  TupleConstraintStruct constraint=new TupleConstraintStruct();
  SqlConstraintUtils.expandSupportedCalculatedMember(member,evaluator,constraint);
  List<Member> expandedMemberList=constraint.getMembers();
  for (  Member checkMember : expandedMemberList) {
    if (checkMember == null || checkMember.isCalculated() || !(checkMember instanceof RolapCubeMember)) {
      throw MondrianResource.instance().UnsupportedCalculatedMember.ex(member.getName(),null);
    }
  }
  List<StarPredicate> predicates=new ArrayList<StarPredicate>(expandedMemberList.size());
  for (  Member iMember : expandedMemberList) {
    RolapCubeMember iCubeMember=((RolapCubeMember)iMember);
    RolapCubeLevel iLevel=iCubeMember.getLevel();
    RolapStar.Column iColumn=iLevel.getBaseStarKeyColumn(baseCube);
    Object iKey=iCubeMember.getKey();
    StarPredicate iPredicate=new ValueColumnPredicate(iColumn,iKey);
    predicates.add(iPredicate);
  }
  StarPredicate r=null;
  if (predicates.size() == 1) {
    r=predicates.get(0);
  }
 else {
    r=new OrPredicate(predicates);
  }
  return r;
}",0.9263531499556344
50864,"NativeEvaluator createEvaluator(RolapEvaluator evaluator,FunDef fun,Exp[] args){
  if (!isEnabled()) {
    return null;
  }
  if (!FilterConstraint.isValidContext(evaluator,restrictMemberTypes())) {
    return null;
  }
  String funName=fun.getName();
  if (!""String_Node_Str"".equalsIgnoreCase(funName)) {
    return null;
  }
  if (args.length != 2) {
    return null;
  }
  List<CrossJoinArg[]> allArgs=crossJoinArgFactory().checkCrossJoinArg(evaluator,args[0]);
  if (allArgs == null || allArgs.isEmpty() || allArgs.get(0) == null) {
    return null;
  }
  CrossJoinArg[] cjArgs=allArgs.get(0);
  if (isPreferInterpreter(cjArgs,false)) {
    return null;
  }
  SchemaReader schemaReader=evaluator.getSchemaReader();
  DataSource ds=schemaReader.getDataSource();
  SqlQuery sqlQuery=SqlQuery.newQuery(ds,""String_Node_Str"");
  RolapNativeSql sql=new RolapNativeSql(sqlQuery,null,evaluator,cjArgs[0].getLevel());
  final Exp filterExpr=args[1];
  String filterExprStr=sql.generateFilterCondition(filterExpr);
  if (filterExprStr == null) {
    return null;
  }
  if (SqlConstraintUtils.containsCalculatedMember(evaluator.getNonAllMembers(),true)) {
    return null;
  }
  LOGGER.debug(""String_Node_Str"");
  final int savepoint=evaluator.savepoint();
  try {
    overrideContext(evaluator,cjArgs,sql.getStoredMeasure());
    if (!evaluator.isNonEmpty() && sql.getStoredMeasure() == null) {
      for (      Member m : evaluator.getMembers()) {
        evaluator.setContext(m.getLevel().getHierarchy().getDefaultMember());
      }
    }
    CrossJoinArg[] combinedArgs=cjArgs;
    if (allArgs.size() == 2) {
      CrossJoinArg[] predicateArgs=allArgs.get(1);
      if (predicateArgs != null) {
        combinedArgs=Util.appendArrays(cjArgs,predicateArgs);
      }
    }
    TupleConstraint constraint=new FilterConstraint(combinedArgs,evaluator,filterExpr);
    return new SetEvaluator(cjArgs,schemaReader,constraint);
  }
  finally {
    evaluator.restore(savepoint);
  }
}","NativeEvaluator createEvaluator(RolapEvaluator evaluator,FunDef fun,Exp[] args){
  if (!isEnabled()) {
    return null;
  }
  if (!FilterConstraint.isValidContext(evaluator,restrictMemberTypes())) {
    return null;
  }
  String funName=fun.getName();
  if (!""String_Node_Str"".equalsIgnoreCase(funName)) {
    return null;
  }
  if (args.length != 2) {
    return null;
  }
  List<CrossJoinArg[]> allArgs=crossJoinArgFactory().checkCrossJoinArg(evaluator,args[0]);
  if (allArgs == null || allArgs.isEmpty() || allArgs.get(0) == null) {
    return null;
  }
  CrossJoinArg[] cjArgs=allArgs.get(0);
  if (isPreferInterpreter(cjArgs,false)) {
    return null;
  }
  SchemaReader schemaReader=evaluator.getSchemaReader();
  DataSource ds=schemaReader.getDataSource();
  SqlQuery sqlQuery=SqlQuery.newQuery(ds,""String_Node_Str"");
  RolapNativeSql sql=new RolapNativeSql(sqlQuery,null,evaluator,cjArgs[0].getLevel());
  final Exp filterExpr=args[1];
  String filterExprStr=sql.generateFilterCondition(filterExpr);
  if (filterExprStr == null) {
    return null;
  }
  if (SqlConstraintUtils.containsCalculatedMember(Arrays.asList(evaluator.getNonAllMembers()),true)) {
    return null;
  }
  LOGGER.debug(""String_Node_Str"");
  final int savepoint=evaluator.savepoint();
  try {
    overrideContext(evaluator,cjArgs,sql.getStoredMeasure());
    if (!evaluator.isNonEmpty() && sql.getStoredMeasure() == null) {
      for (      Member m : evaluator.getMembers()) {
        evaluator.setContext(m.getLevel().getHierarchy().getDefaultMember());
      }
    }
    CrossJoinArg[] combinedArgs=cjArgs;
    if (allArgs.size() == 2) {
      CrossJoinArg[] predicateArgs=allArgs.get(1);
      if (predicateArgs != null) {
        combinedArgs=Util.appendArrays(cjArgs,predicateArgs);
      }
    }
    TupleConstraint constraint=new FilterConstraint(combinedArgs,evaluator,filterExpr);
    return new SetEvaluator(cjArgs,schemaReader,constraint);
  }
  finally {
    evaluator.restore(savepoint);
  }
}",0.9962111644354636
50865,"@Override protected void runTest() throws Exception {
  if (!Bug.BugMondrian785Fixed && (getName().equals(""String_Node_Str"") || getName().equals(""String_Node_Str"") || getName().equals(""String_Node_Str"")) && MondrianProperties.instance().EnableNativeCrossJoin.get()) {
    return;
  }
  super.runTest();
}","@Override protected void runTest() throws Exception {
  if (!Bug.BugMondrian785Fixed && (getName().equals(""String_Node_Str"") || getName().equals(""String_Node_Str"") || getName().equals(""String_Node_Str"")) && MondrianProperties.instance().EnableNativeCrossJoin.get()) {
    return;
  }
  if (!Bug.BugMondrian2452Fixed && (getName().equals(""String_Node_Str"")) && !MondrianProperties.instance().EnableNativeCrossJoin.get()) {
    return;
  }
  super.runTest();
}",0.7926509186351706
50866,"/** 
 * Returns a the XML of the foodmart schema, adding dimension definitions to the definition of a given cube.
 */
private String substituteSchema(String rawSchema,String cubeName,String dimensionDefs,String measureDefs,String memberDefs,String namedSetDefs){
  String s=rawSchema;
  int h=s.indexOf(""String_Node_Str"" + cubeName + ""String_Node_Str"");
  int end;
  if (h < 0) {
    h=s.indexOf(""String_Node_Str"" + cubeName + ""String_Node_Str"");
  }
  if (h < 0) {
    h=s.indexOf(""String_Node_Str"" + cubeName + ""String_Node_Str"");
    if (h < 0) {
      h=s.indexOf(""String_Node_Str"" + cubeName + ""String_Node_Str"");
    }
    if (h < 0) {
      throw new RuntimeException(""String_Node_Str"" + cubeName + ""String_Node_Str"");
    }
 else {
      end=s.indexOf(""String_Node_Str"",h);
    }
  }
 else {
    end=s.indexOf(""String_Node_Str"",h);
  }
  if (dimensionDefs != null) {
    int i=s.indexOf(""String_Node_Str"",h);
    s=s.substring(0,i) + dimensionDefs + s.substring(i);
  }
  if (measureDefs != null) {
    int i=s.indexOf(""String_Node_Str"",h);
    if (i < 0 || i > end) {
      i=end;
    }
    s=s.substring(0,i) + measureDefs + s.substring(i);
  }
  if (memberDefs != null) {
    int i=s.indexOf(""String_Node_Str"",h);
    if (i < 0 || i > end) {
      i=end;
    }
    s=s.substring(0,i) + memberDefs + s.substring(i);
  }
  if (namedSetDefs != null) {
    int i=s.indexOf(""String_Node_Str"",h);
    if (i < 0 || i > end) {
      i=end;
    }
    s=s.substring(0,i) + namedSetDefs + s.substring(i);
  }
  return s;
}","/** 
 * Returns a the XML of the foodmart schema, adding dimension definitions to the definition of a given cube.
 */
private String substituteSchema(String rawSchema,String cubeName,String dimensionDefs,String measureDefs,String memberDefs,String namedSetDefs){
  String s=rawSchema;
  int h=s.indexOf(""String_Node_Str"" + cubeName + ""String_Node_Str"");
  int end;
  if (h < 0) {
    h=s.indexOf(""String_Node_Str"" + cubeName + ""String_Node_Str"");
  }
  if (h < 0) {
    h=s.indexOf(""String_Node_Str"" + cubeName + ""String_Node_Str"");
    if (h < 0) {
      h=s.indexOf(""String_Node_Str"" + cubeName + ""String_Node_Str"");
    }
    if (h < 0) {
      throw new RuntimeException(""String_Node_Str"" + cubeName + ""String_Node_Str"");
    }
 else {
      end=s.indexOf(""String_Node_Str"",h);
    }
  }
 else {
    end=s.indexOf(""String_Node_Str"",h);
  }
  if (dimensionDefs != null) {
    int i=s.indexOf(""String_Node_Str"",h);
    s=s.substring(0,i) + dimensionDefs + s.substring(i);
  }
  if (measureDefs != null) {
    int i=s.indexOf(""String_Node_Str"",h);
    if (i < 0 || i > end) {
      i=end;
    }
    s=s.substring(0,i) + measureDefs + s.substring(i);
    if (i == end) {
      i=s.indexOf(""String_Node_Str"",h);
      if (i < 0 || i > end) {
        i=end;
      }
      s=s.substring(0,i) + measureDefs + s.substring(i);
    }
  }
  if (memberDefs != null) {
    int i=s.indexOf(""String_Node_Str"",h);
    if (i < 0 || i > end) {
      i=end;
    }
    s=s.substring(0,i) + memberDefs + s.substring(i);
  }
  if (namedSetDefs != null) {
    int i=s.indexOf(""String_Node_Str"",h);
    if (i < 0 || i > end) {
      i=end;
    }
    s=s.substring(0,i) + namedSetDefs + s.substring(i);
  }
  return s;
}",0.9453416149068324
50867,"NativeEvaluator createEvaluator(RolapEvaluator evaluator,FunDef fun,Exp[] args){
  if (!isEnabled()) {
    return null;
  }
  if (!FilterConstraint.isValidContext(evaluator,restrictMemberTypes())) {
    return null;
  }
  String funName=fun.getName();
  if (!""String_Node_Str"".equalsIgnoreCase(funName)) {
    return null;
  }
  if (args.length != 2) {
    return null;
  }
  List<CrossJoinArg[]> allArgs=crossJoinArgFactory().checkCrossJoinArg(evaluator,args[0]);
  if (allArgs == null || allArgs.isEmpty() || allArgs.get(0) == null) {
    return null;
  }
  CrossJoinArg[] cjArgs=allArgs.get(0);
  if (isPreferInterpreter(cjArgs,false)) {
    return null;
  }
  SchemaReader schemaReader=evaluator.getSchemaReader();
  DataSource ds=schemaReader.getDataSource();
  SqlQuery sqlQuery=SqlQuery.newQuery(ds,""String_Node_Str"");
  RolapNativeSql sql=new RolapNativeSql(sqlQuery,null,evaluator,cjArgs[0].getLevel());
  final Exp filterExpr=args[1];
  String filterExprStr=sql.generateFilterCondition(filterExpr);
  if (filterExprStr == null) {
    return null;
  }
  if (SqlConstraintUtils.containsCalculatedMember(evaluator.getNonAllMembers(),true)) {
    return null;
  }
  LOGGER.debug(""String_Node_Str"");
  final int savepoint=evaluator.savepoint();
  try {
    overrideContext(evaluator,cjArgs,sql.getStoredMeasure());
    CrossJoinArg[] combinedArgs=cjArgs;
    if (allArgs.size() == 2) {
      CrossJoinArg[] predicateArgs=allArgs.get(1);
      if (predicateArgs != null) {
        combinedArgs=Util.appendArrays(cjArgs,predicateArgs);
      }
    }
    TupleConstraint constraint=new FilterConstraint(combinedArgs,evaluator,filterExpr);
    return new SetEvaluator(cjArgs,schemaReader,constraint);
  }
  finally {
    evaluator.restore(savepoint);
  }
}","NativeEvaluator createEvaluator(RolapEvaluator evaluator,FunDef fun,Exp[] args){
  if (!isEnabled()) {
    return null;
  }
  if (!FilterConstraint.isValidContext(evaluator,restrictMemberTypes())) {
    return null;
  }
  String funName=fun.getName();
  if (!""String_Node_Str"".equalsIgnoreCase(funName)) {
    return null;
  }
  if (args.length != 2) {
    return null;
  }
  List<CrossJoinArg[]> allArgs=crossJoinArgFactory().checkCrossJoinArg(evaluator,args[0]);
  if (allArgs == null || allArgs.isEmpty() || allArgs.get(0) == null) {
    return null;
  }
  CrossJoinArg[] cjArgs=allArgs.get(0);
  if (isPreferInterpreter(cjArgs,false)) {
    return null;
  }
  SchemaReader schemaReader=evaluator.getSchemaReader();
  DataSource ds=schemaReader.getDataSource();
  SqlQuery sqlQuery=SqlQuery.newQuery(ds,""String_Node_Str"");
  RolapNativeSql sql=new RolapNativeSql(sqlQuery,null,evaluator,cjArgs[0].getLevel());
  final Exp filterExpr=args[1];
  String filterExprStr=sql.generateFilterCondition(filterExpr);
  if (filterExprStr == null) {
    return null;
  }
  if (SqlConstraintUtils.containsCalculatedMember(evaluator.getNonAllMembers(),true)) {
    return null;
  }
  LOGGER.debug(""String_Node_Str"");
  final int savepoint=evaluator.savepoint();
  try {
    overrideContext(evaluator,cjArgs,sql.getStoredMeasure());
    if (!evaluator.isNonEmpty() && sql.getStoredMeasure() == null) {
      for (      Member m : evaluator.getMembers()) {
        evaluator.setContext(m.getLevel().getHierarchy().getDefaultMember());
      }
    }
    CrossJoinArg[] combinedArgs=cjArgs;
    if (allArgs.size() == 2) {
      CrossJoinArg[] predicateArgs=allArgs.get(1);
      if (predicateArgs != null) {
        combinedArgs=Util.appendArrays(cjArgs,predicateArgs);
      }
    }
    TupleConstraint constraint=new FilterConstraint(combinedArgs,evaluator,filterExpr);
    return new SetEvaluator(cjArgs,schemaReader,constraint);
  }
  finally {
    evaluator.restore(savepoint);
  }
}",0.942343791901314
50868,"/** 
 * Evaluates an expression. Intended for evaluating named sets. <p>Does not modify the contents of the evaluator.
 * @param calc Compiled expression
 * @param slicerEvaluator Evaluation context for slicers
 * @param contextEvaluator Evaluation context (optional)
 * @return Result
 */
Object evaluateExp(Calc calc,RolapEvaluator slicerEvaluator,Evaluator contextEvaluator){
  int attempt=0;
  RolapEvaluator evaluator=slicerEvaluator.push();
  if (contextEvaluator != null && contextEvaluator.isEvalAxes()) {
    evaluator.setEvalAxes(true);
    evaluator.setContext(contextEvaluator.getMembers());
    evaluator.setSlicerTuples(((RolapEvaluator)contextEvaluator).getSlicerTuples());
  }
  final int savepoint=evaluator.savepoint();
  boolean dirty=batchingReader.isDirty();
  try {
    while (true) {
      evaluator.restore(savepoint);
      evaluator.setCellReader(batchingReader);
      Object preliminaryValue=calc.evaluate(evaluator);
      if (preliminaryValue instanceof TupleIterable) {
        TupleIterable iterable=(TupleIterable)preliminaryValue;
        final TupleCursor cursor=iterable.tupleCursor();
        while (cursor.forward()) {
        }
      }
      if (!phase()) {
        break;
      }
 else {
        evaluator.clearExpResultCache(false);
      }
      if (attempt++ > maxEvalDepth) {
        throw Util.newInternal(""String_Node_Str"" + maxEvalDepth + ""String_Node_Str"");
      }
    }
    if (dirty) {
      batchingReader.setDirty(true);
    }
    evaluator.restore(savepoint);
    evaluator.setCellReader(aggregatingReader);
    final Object o=calc.evaluate(evaluator);
    return o;
  }
  finally {
    evaluator.restore(savepoint);
  }
}","/** 
 * Evaluates an expression. Intended for evaluating named sets. <p>Does not modify the contents of the evaluator.
 * @param calc Compiled expression
 * @param slicerEvaluator Evaluation context for slicers
 * @param contextEvaluator Evaluation context (optional)
 * @return Result
 */
Object evaluateExp(Calc calc,RolapEvaluator slicerEvaluator,Evaluator contextEvaluator){
  int attempt=0;
  RolapEvaluator evaluator=slicerEvaluator.push();
  if (contextEvaluator != null && contextEvaluator.isEvalAxes()) {
    evaluator.setEvalAxes(true);
  }
  final int savepoint=evaluator.savepoint();
  boolean dirty=batchingReader.isDirty();
  try {
    while (true) {
      evaluator.restore(savepoint);
      evaluator.setCellReader(batchingReader);
      Object preliminaryValue=calc.evaluate(evaluator);
      if (preliminaryValue instanceof TupleIterable) {
        TupleIterable iterable=(TupleIterable)preliminaryValue;
        final TupleCursor cursor=iterable.tupleCursor();
        while (cursor.forward()) {
        }
      }
      if (!phase()) {
        break;
      }
 else {
        evaluator.clearExpResultCache(false);
      }
      if (attempt++ > maxEvalDepth) {
        throw Util.newInternal(""String_Node_Str"" + maxEvalDepth + ""String_Node_Str"");
      }
    }
    if (dirty) {
      batchingReader.setDirty(true);
    }
    evaluator.restore(savepoint);
    evaluator.setCellReader(aggregatingReader);
    final Object o=calc.evaluate(evaluator);
    return o;
  }
  finally {
    evaluator.restore(savepoint);
  }
}",0.9557632398753894
50869,"private boolean phase(){
  if (batchingReader.isDirty()) {
    execution.tracePhase(batchingReader.getHitCount(),batchingReader.getMissCount(),batchingReader.getPendingCount());
    return batchingReader.loadAggregations();
  }
 else {
    return false;
  }
}","private boolean phase(){
  if (batchingReader.isDirty()) {
    execution.tracePhase(batchingReader.getHitCount(),batchingReader.getMissCount(),batchingReader.getPendingCount());
    evaluator.clearExpResultCache(false);
    return batchingReader.loadAggregations();
  }
 else {
    return false;
  }
}",0.925
50870,"/** 
 * Creates a RolapResult.
 * @param execution Execution of a statement
 * @param execute Whether to execute the query
 */
RolapResult(final Execution execution,boolean execute){
  super(execution,null);
  this.point=CellKey.Generator.newCellKey(axes.length);
  final AggregationManager aggMgr=execution.getMondrianStatement().getMondrianConnection().getServer().getAggregationManager();
  this.aggregatingReader=aggMgr.getCacheCellReader();
  final int expDeps=MondrianProperties.instance().TestExpDependencies.get();
  if (expDeps > 0) {
    this.evaluator=new RolapDependencyTestingEvaluator(this,expDeps);
  }
 else {
    final RolapEvaluatorRoot root=new RolapResultEvaluatorRoot(this);
    if (statement.getProfileHandler() != null) {
      this.evaluator=new RolapProfilingEvaluator(root);
    }
 else {
      this.evaluator=new RolapEvaluator(root);
    }
  }
  RolapCube cube=(RolapCube)query.getCube();
  this.batchingReader=new FastBatchingCellReader(execution,cube,aggMgr);
  this.cellInfos=(query.axes.length > 4) ? new CellInfoMap(point) : new CellInfoPool(query.axes.length);
  if (!execute) {
    return;
  }
  boolean normalExecution=true;
  try {
    cube.clearCachedAggregations();
    final AxisMemberList axisMembers=new AxisMemberList();
    final List<Member> nonDefaultAllMembers=new ArrayList<Member>();
    List<List<Member>> nonAllMembers=new ArrayList<List<Member>>();
    final List<Member> measureMembers=new ArrayList<Member>();
    loadSpecialMembers(nonDefaultAllMembers,nonAllMembers,measureMembers);
    query.clearEvalCache();
    query.putEvalCache(""String_Node_Str"",nonDefaultAllMembers);
    final List<List<Member>> emptyNonAllMembers=Collections.emptyList();
    slicerEvaluator=evaluator.push();
    axisMembers.setSlicer(true);
    loadMembers(emptyNonAllMembers,evaluator,query.getSlicerAxis(),query.slicerCalc,axisMembers);
    axisMembers.setSlicer(false);
    final RolapEvaluator savedEvaluator=evaluator.push();
    if (!axisMembers.isEmpty()) {
      for (      Member m : axisMembers) {
        if (m == null) {
          break;
        }
        evaluator.setSlicerContext(m);
        if (m.isMeasure()) {
          measureMembers.clear();
        }
      }
      replaceNonAllMembers(nonAllMembers,axisMembers);
      axisMembers.clearMembers();
    }
    slicerEvaluator=evaluator.push();
    boolean changed=false;
    axisMembers.clearTotalCellCount();
    for (int i=0; i < axes.length; i++) {
      final QueryAxis axis=query.axes[i];
      final Calc calc=query.axisCalcs[i];
      loadMembers(emptyNonAllMembers,evaluator,axis,calc,axisMembers);
    }
    if (!axisMembers.isEmpty()) {
      for (      Member m : axisMembers) {
        if (m.isMeasure()) {
          measureMembers.clear();
        }
      }
      changed=replaceNonAllMembers(nonAllMembers,axisMembers);
      axisMembers.clearMembers();
    }
    if (changed) {
      axisMembers.countOnly(true);
      axisMembers.clearTotalCellCount();
      final int savepoint=evaluator.savepoint();
      try {
        for (int i=0; i < axes.length; i++) {
          final QueryAxis axis=query.axes[i];
          final Calc calc=query.axisCalcs[i];
          loadMembers(nonAllMembers,evaluator,axis,calc,axisMembers);
          evaluator.restore(savepoint);
        }
      }
  finally {
        evaluator.restore(savepoint);
      }
    }
    axisMembers.checkLimit();
    Axis savedSlicerAxis;
    RolapEvaluator slicerEvaluator;
    do {
      TupleIterable tupleIterable=evalExecute(nonAllMembers,nonAllMembers.size() - 1,savedEvaluator,query.getSlicerAxis(),query.slicerCalc);
      TupleList tupleList=TupleCollections.materialize(tupleIterable,true);
      this.slicerAxis=new RolapAxis(tupleList);
      savedSlicerAxis=this.slicerAxis;
      slicerEvaluator=this.evaluator;
      if (tupleList.size() > 1) {
        tupleList=AggregateFunDef.AggregateCalc.optimizeTupleList(slicerEvaluator,tupleList,false);
        evaluator.setSlicerTuples(tupleList);
        final Calc valueCalc=new ValueCalc(new DummyExp(new ScalarType()));
        final List<Member> prevSlicerMembers=new ArrayList<Member>();
        final Calc calc=new GenericCalc(new DummyExp(query.slicerCalc.getType())){
          public Object evaluate(          Evaluator evaluator){
            TupleList list=AbstractAggregateFunDef.processUnrelatedDimensions(((RolapEvaluator)evaluator).getOptimizedSlicerTuples(null),evaluator);
            for (            Member member : prevSlicerMembers) {
              if (evaluator.getContext(member.getHierarchy()) instanceof CompoundSlicerRolapMember) {
                evaluator.setContext(member);
              }
            }
            return AggregateFunDef.AggregateCalc.aggregate(valueCalc,evaluator,list);
          }
          public boolean dependsOn(          Hierarchy hierarchy){
            return true;
          }
        }
;
        if (tupleList.get(0).size() > 1) {
          for (int i=1; i < tupleList.get(0).size(); i++) {
            Member placeholder=setPlaceholderSlicerAxis((RolapMember)tupleList.get(0).get(i),calc,false);
            prevSlicerMembers.add(evaluator.setContext(placeholder));
          }
        }
        Member placeholder=setPlaceholderSlicerAxis((RolapMember)tupleList.get(0).get(0),calc,true);
        evaluator.setContext(placeholder);
      }
    }
 while (phase());
    final int savepoint=evaluator.savepoint();
    do {
      try {
        boolean redo;
        do {
          evaluator.restore(savepoint);
          redo=false;
          for (int i=0; i < axes.length; i++) {
            QueryAxis axis=query.axes[i];
            final Calc calc=query.axisCalcs[i];
            TupleIterable tupleIterable=evalExecute(nonAllMembers,nonAllMembers.size() - 1,evaluator,axis,calc);
            if (!nonAllMembers.isEmpty()) {
              final TupleIterator tupleIterator=tupleIterable.tupleIterator();
              if (tupleIterator.hasNext()) {
                List<Member> tuple0=tupleIterator.next();
                for (                Member m : tuple0) {
                  if (m.isCalculated()) {
                    CalculatedMeasureVisitor visitor=new CalculatedMeasureVisitor();
                    m.getExpression().accept(visitor);
                    Dimension dimension=visitor.dimension;
                    if (removeDimension(dimension,nonAllMembers)) {
                      redo=true;
                    }
                  }
                }
              }
            }
            this.axes[i]=new RolapAxis(TupleCollections.materialize(tupleIterable,false));
          }
        }
 while (redo);
      }
 catch (      CellRequestQuantumExceededException e) {
      }
    }
 while (phase());
    evaluator.restore(savepoint);
    final Locus locus=new Locus(execution,null,""String_Node_Str"");
    Locus.push(locus);
    try {
      executeBody(slicerEvaluator,query,new int[axes.length]);
    }
  finally {
      Locus.pop(locus);
    }
    if (this.cellInfos.size() > 10000) {
      this.cellInfos.trimToSize();
    }
    this.slicerAxis=savedSlicerAxis;
  }
 catch (  ResultLimitExceededException ex) {
    normalExecution=false;
    evaluator=null;
    slicerEvaluator=null;
    cellInfos=null;
    batchingReader=null;
    for (int i=0; i < axes.length; i++) {
      axes[i]=null;
    }
    slicerAxis=null;
    query.clearEvalCache();
    throw ex;
  }
 finally {
    if (normalExecution) {
      evaluator.clearExpResultCache(true);
    }
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug(""String_Node_Str"" + Util.printMemory());
    }
  }
}","/** 
 * Creates a RolapResult.
 * @param execution Execution of a statement
 * @param execute Whether to execute the query
 */
RolapResult(final Execution execution,boolean execute){
  super(execution,null);
  this.point=CellKey.Generator.newCellKey(axes.length);
  final AggregationManager aggMgr=execution.getMondrianStatement().getMondrianConnection().getServer().getAggregationManager();
  this.aggregatingReader=aggMgr.getCacheCellReader();
  final int expDeps=MondrianProperties.instance().TestExpDependencies.get();
  if (expDeps > 0) {
    this.evaluator=new RolapDependencyTestingEvaluator(this,expDeps);
  }
 else {
    final RolapEvaluatorRoot root=new RolapResultEvaluatorRoot(this);
    if (statement.getProfileHandler() != null) {
      this.evaluator=new RolapProfilingEvaluator(root);
    }
 else {
      this.evaluator=new RolapEvaluator(root);
    }
  }
  RolapCube cube=(RolapCube)query.getCube();
  this.batchingReader=new FastBatchingCellReader(execution,cube,aggMgr);
  this.cellInfos=(query.axes.length > 4) ? new CellInfoMap(point) : new CellInfoPool(query.axes.length);
  if (!execute) {
    return;
  }
  boolean normalExecution=true;
  try {
    cube.clearCachedAggregations();
    final AxisMemberList axisMembers=new AxisMemberList();
    final List<Member> nonDefaultAllMembers=new ArrayList<Member>();
    List<List<Member>> nonAllMembers=new ArrayList<List<Member>>();
    final List<Member> measureMembers=new ArrayList<Member>();
    loadSpecialMembers(nonDefaultAllMembers,nonAllMembers,measureMembers);
    query.clearEvalCache();
    query.putEvalCache(""String_Node_Str"",nonDefaultAllMembers);
    final List<List<Member>> emptyNonAllMembers=Collections.emptyList();
    slicerEvaluator=evaluator.push();
    axisMembers.setSlicer(true);
    loadMembers(emptyNonAllMembers,evaluator,query.getSlicerAxis(),query.slicerCalc,axisMembers);
    axisMembers.setSlicer(false);
    final RolapEvaluator savedEvaluator=evaluator.push();
    if (!axisMembers.isEmpty()) {
      for (      Member m : axisMembers) {
        if (m == null) {
          break;
        }
        evaluator.setSlicerContext(m);
        if (m.isMeasure()) {
          measureMembers.clear();
        }
      }
      replaceNonAllMembers(nonAllMembers,axisMembers);
      axisMembers.clearMembers();
    }
    slicerEvaluator=evaluator.push();
    Axis savedSlicerAxis;
    RolapEvaluator internalSlicerEvaluator;
    do {
      TupleIterable tupleIterable=evalExecute(nonAllMembers,nonAllMembers.size() - 1,savedEvaluator,query.getSlicerAxis(),query.slicerCalc);
      TupleList tupleList=TupleCollections.materialize(tupleIterable,true);
      this.slicerAxis=new RolapAxis(tupleList);
      savedSlicerAxis=this.slicerAxis;
      internalSlicerEvaluator=this.evaluator;
      if (tupleList.size() > 1) {
        tupleList=removeUnaryMembersFromTupleList(tupleList,evaluator);
        tupleList=AggregateFunDef.AggregateCalc.optimizeTupleList(evaluator,tupleList,false);
        evaluator.setSlicerTuples(tupleList);
        final Calc valueCalc=new ValueCalc(new DummyExp(new ScalarType()));
        final List<Member> prevSlicerMembers=new ArrayList<Member>();
        final Calc calcCached=new GenericCalc(new DummyExp(query.slicerCalc.getType())){
          public Object evaluate(          Evaluator evaluator){
            TupleList list=AbstractAggregateFunDef.processUnrelatedDimensions(((RolapEvaluator)evaluator).getOptimizedSlicerTuples(null),evaluator);
            for (            Member member : prevSlicerMembers) {
              if (evaluator.getContext(member.getHierarchy()) instanceof CompoundSlicerRolapMember) {
                evaluator.setContext(member);
              }
            }
            return AggregateFunDef.AggregateCalc.aggregate(valueCalc,evaluator,list);
          }
          public boolean dependsOn(          Hierarchy hierarchy){
            return true;
          }
        }
;
        final ExpCacheDescriptor cacheDescriptor=new ExpCacheDescriptor(query.getSlicerAxis().getSet(),calcCached,evaluator);
        final Calc calc=new CacheCalc(query.getSlicerAxis().getSet(),cacheDescriptor);
        if (tupleList.get(0).size() > 1) {
          for (int i=1; i < tupleList.get(0).size(); i++) {
            Member placeholder=setPlaceholderSlicerAxis((RolapMember)tupleList.get(0).get(i),calc,false);
            prevSlicerMembers.add(evaluator.setContext(placeholder));
          }
        }
        Member placeholder=setPlaceholderSlicerAxis((RolapMember)tupleList.get(0).get(0),calc,true);
        evaluator.setContext(placeholder);
      }
    }
 while (phase());
    slicerEvaluator=evaluator.push();
    boolean changed=false;
    axisMembers.clearTotalCellCount();
    for (int i=0; i < axes.length; i++) {
      final QueryAxis axis=query.axes[i];
      final Calc calc=query.axisCalcs[i];
      loadMembers(emptyNonAllMembers,evaluator,axis,calc,axisMembers);
    }
    if (!axisMembers.isEmpty()) {
      for (      Member m : axisMembers) {
        if (m.isMeasure()) {
          measureMembers.clear();
        }
      }
      changed=replaceNonAllMembers(nonAllMembers,axisMembers);
      axisMembers.clearMembers();
    }
    if (changed) {
      axisMembers.countOnly(true);
      axisMembers.clearTotalCellCount();
      final int savepoint=evaluator.savepoint();
      try {
        for (int i=0; i < axes.length; i++) {
          final QueryAxis axis=query.axes[i];
          final Calc calc=query.axisCalcs[i];
          loadMembers(nonAllMembers,evaluator,axis,calc,axisMembers);
          evaluator.restore(savepoint);
        }
      }
  finally {
        evaluator.restore(savepoint);
      }
    }
    axisMembers.checkLimit();
    final int savepoint=evaluator.savepoint();
    do {
      try {
        boolean redo;
        do {
          evaluator.restore(savepoint);
          redo=false;
          for (int i=0; i < axes.length; i++) {
            QueryAxis axis=query.axes[i];
            final Calc calc=query.axisCalcs[i];
            TupleIterable tupleIterable=evalExecute(nonAllMembers,nonAllMembers.size() - 1,evaluator,axis,calc);
            if (!nonAllMembers.isEmpty()) {
              final TupleIterator tupleIterator=tupleIterable.tupleIterator();
              if (tupleIterator.hasNext()) {
                List<Member> tuple0=tupleIterator.next();
                for (                Member m : tuple0) {
                  if (m.isCalculated()) {
                    CalculatedMeasureVisitor visitor=new CalculatedMeasureVisitor();
                    m.getExpression().accept(visitor);
                    Dimension dimension=visitor.dimension;
                    if (removeDimension(dimension,nonAllMembers)) {
                      redo=true;
                    }
                  }
                }
              }
            }
            this.axes[i]=new RolapAxis(TupleCollections.materialize(tupleIterable,false));
          }
        }
 while (redo);
      }
 catch (      CellRequestQuantumExceededException e) {
      }
    }
 while (phase());
    evaluator.restore(savepoint);
    final Locus locus=new Locus(execution,null,""String_Node_Str"");
    Locus.push(locus);
    try {
      executeBody(internalSlicerEvaluator,query,new int[axes.length]);
    }
  finally {
      Locus.pop(locus);
    }
    if (this.cellInfos.size() > 10000) {
      this.cellInfos.trimToSize();
    }
    this.slicerAxis=savedSlicerAxis;
  }
 catch (  ResultLimitExceededException ex) {
    normalExecution=false;
    evaluator=null;
    slicerEvaluator=null;
    cellInfos=null;
    batchingReader=null;
    for (int i=0; i < axes.length; i++) {
      axes[i]=null;
    }
    slicerAxis=null;
    query.clearEvalCache();
    throw ex;
  }
 finally {
    if (normalExecution) {
      evaluator.clearExpResultCache(true);
    }
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug(""String_Node_Str"" + Util.printMemory());
    }
  }
}",0.7232148616396826
50871,"/** 
 * Looks up a   {@link RolapStar}, creating it if it does not exist. <p>   {@link RolapStar.Table#addJoin} works in a similar way.
 */
synchronized RolapStar getOrCreateStar(final MondrianDef.Relation fact){
  String factTableName=fact.toString();
  RolapStar star=stars.get(factTableName);
  if (star == null) {
    star=makeRolapStar(fact);
    stars.put(factTableName,star);
  }
  return star;
}","/** 
 * Looks up a   {@link RolapStar}, creating it if it does not exist. <p>   {@link RolapStar.Table#addJoin} works in a similar way.
 */
synchronized RolapStar getOrCreateStar(final MondrianDef.Relation fact){
  final String factTableName=fact.getAlias();
  RolapStar star=stars.get(factTableName);
  if (star == null) {
    star=makeRolapStar(fact);
    stars.put(factTableName,star);
  }
  return star;
}",0.9753694581280788
50872,"private static CellRequest makeCellRequest(final Member[] members,boolean drillThrough,final boolean extendedContext,RolapCube cube,List<Exp> fieldsList){
}","private static CellRequest makeCellRequest(final Member[] members,boolean drillThrough,final boolean extendedContext,RolapCube cube,List<Exp> fieldsList,Evaluator evaluator){
}",0.9397590361445785
50873,"public void addConstraint(SqlQuery sqlQuery,RolapCube baseCube,AggStar aggStar){
  if (orderByExpr != null) {
    RolapNativeSql sql=new RolapNativeSql(sqlQuery,aggStar,getEvaluator(),null);
    String orderBySql=sql.generateTopCountOrderBy(orderByExpr);
    Dialect dialect=sqlQuery.getDialect();
    boolean nullable=deduceNullability(orderByExpr);
    if (dialect.requiresOrderByAlias()) {
      String alias=sqlQuery.nextColumnAlias();
      alias=dialect.quoteIdentifier(alias);
      sqlQuery.addSelect(orderBySql,null,alias);
      sqlQuery.addOrderBy(alias,ascending,true,nullable);
    }
 else {
      sqlQuery.addOrderBy(orderBySql,ascending,true,nullable);
    }
  }
  super.addConstraint(sqlQuery,baseCube,aggStar);
}","public void addConstraint(SqlQuery sqlQuery,RolapCube baseCube,AggStar aggStar){
  if (orderByExpr != null) {
    RolapNativeSql sql=new RolapNativeSql(sqlQuery,aggStar,getEvaluator(),null);
    final String orderBySql=sql.generateTopCountOrderBy(orderByExpr);
    boolean nullable=deduceNullability(orderByExpr);
    final String orderByAlias=sqlQuery.addSelect(orderBySql,null);
    sqlQuery.addOrderBy(orderBySql,orderByAlias,ascending,true,nullable,true);
  }
  super.addConstraint(sqlQuery,baseCube,aggStar);
}",0.5514469453376206
50874,"/** 
 * Generates the SQL to find all root members of a parent-child hierarchy. For example, <blockquote> <pre>SELECT ""employee_id"" FROM ""employee"" WHERE ""supervisor_id"" IS NULL GROUP BY ""employee_id""</pre> </blockquote> retrieves the root members of the <code>[Employee]</code> hierarchy. <p>Currently, parent-child hierarchies may have only one level (plus the 'All' level).
 */
private Pair<String,List<SqlStatement.Type>> makeChildMemberSql_PCRoot(RolapMember member){
  SqlQuery sqlQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + ""String_Node_Str"" + member);
  Util.assertTrue(member.isAll(),""String_Node_Str"" + ""String_Node_Str"");
  RolapLevel level=(RolapLevel)member.getLevel().getChildLevel();
  Util.assertTrue(!level.isAll(),""String_Node_Str"");
  Util.assertTrue(level.isUnique(),""String_Node_Str"" + level + ""String_Node_Str"");
  hierarchy.addToFrom(sqlQuery,level.getParentExp());
  String parentId=level.getParentExp().getExpression(sqlQuery);
  StringBuilder condition=new StringBuilder(64);
  condition.append(parentId);
  if (level.getNullParentValue() == null || level.getNullParentValue().equalsIgnoreCase(""String_Node_Str"")) {
    condition.append(""String_Node_Str"");
  }
 else {
    try {
      Util.discard(Double.parseDouble(level.getNullParentValue()));
      condition.append(""String_Node_Str"");
      condition.append(level.getNullParentValue());
    }
 catch (    NumberFormatException e) {
      condition.append(""String_Node_Str"");
      Util.singleQuoteString(level.getNullParentValue(),condition);
    }
  }
  sqlQuery.addWhere(condition.toString());
  hierarchy.addToFrom(sqlQuery,level.getKeyExp());
  String childId=level.getKeyExp().getExpression(sqlQuery);
  sqlQuery.addSelectGroupBy(childId,level.getInternalType());
  hierarchy.addToFrom(sqlQuery,level.getOrdinalExp());
  String orderBy=level.getOrdinalExp().getExpression(sqlQuery);
  sqlQuery.addOrderBy(orderBy,true,false,true);
  if (!orderBy.equals(childId)) {
    sqlQuery.addSelectGroupBy(orderBy,null);
  }
  RolapProperty[] properties=level.getProperties();
  for (  RolapProperty property : properties) {
    final MondrianDef.Expression exp=property.getExp();
    hierarchy.addToFrom(sqlQuery,exp);
    final String s=exp.getExpression(sqlQuery);
    String alias=sqlQuery.addSelect(s,null);
    if (!sqlQuery.getDialect().allowsSelectNotInGroupBy() || !property.dependsOnLevelValue()) {
      sqlQuery.addGroupBy(s,alias);
    }
  }
  return sqlQuery.toSqlAndTypes();
}","/** 
 * Generates the SQL to find all root members of a parent-child hierarchy. For example, <blockquote> <pre>SELECT ""employee_id"" FROM ""employee"" WHERE ""supervisor_id"" IS NULL GROUP BY ""employee_id""</pre> </blockquote> retrieves the root members of the <code>[Employee]</code> hierarchy. <p>Currently, parent-child hierarchies may have only one level (plus the 'All' level).
 */
private Pair<String,List<SqlStatement.Type>> makeChildMemberSql_PCRoot(RolapMember member){
  SqlQuery sqlQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + ""String_Node_Str"" + member);
  Util.assertTrue(member.isAll(),""String_Node_Str"" + ""String_Node_Str"");
  RolapLevel level=(RolapLevel)member.getLevel().getChildLevel();
  Util.assertTrue(!level.isAll(),""String_Node_Str"");
  Util.assertTrue(level.isUnique(),""String_Node_Str"" + level + ""String_Node_Str"");
  hierarchy.addToFrom(sqlQuery,level.getParentExp());
  String parentId=level.getParentExp().getExpression(sqlQuery);
  StringBuilder condition=new StringBuilder(64);
  condition.append(parentId);
  if (level.getNullParentValue() == null || level.getNullParentValue().equalsIgnoreCase(""String_Node_Str"")) {
    condition.append(""String_Node_Str"");
  }
 else {
    try {
      Util.discard(Double.parseDouble(level.getNullParentValue()));
      condition.append(""String_Node_Str"");
      condition.append(level.getNullParentValue());
    }
 catch (    NumberFormatException e) {
      condition.append(""String_Node_Str"");
      Util.singleQuoteString(level.getNullParentValue(),condition);
    }
  }
  sqlQuery.addWhere(condition.toString());
  addLevel(sqlQuery,level,true);
  return sqlQuery.toSqlAndTypes();
}",0.7706821480406386
50875,"/** 
 * Generates the SQL statement to access the children of <code>member</code>. For example, <blockquote> <pre>SELECT ""city"" FROM ""customer"" WHERE ""country"" = 'USA' AND ""state_province"" = 'BC' GROUP BY ""city""</pre> </blockquote> retrieves the children of the member <code>[Canada].[BC]</code>. <p>Note that this method is never called in the context of virtual cubes, it is only called on regular cubes. <p>See also   {@link SqlTupleReader#makeLevelMembersSql}.
 */
Pair<String,List<SqlStatement.Type>> makeChildMemberSql(RolapMember member,DataSource dataSource,MemberChildrenConstraint constraint){
  SqlQuery sqlQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + member);
  AggStar aggStar=chooseAggStar(constraint,member);
  constraint.addMemberConstraint(sqlQuery,null,aggStar,member);
  RolapLevel level=(RolapLevel)member.getLevel().getChildLevel();
  boolean levelCollapsed=(aggStar != null) && isLevelCollapsed(aggStar,(RolapCubeLevel)level);
  boolean multipleCols=SqlMemberSource.levelContainsMultipleColumns(level);
  if (levelCollapsed && !multipleCols) {
    RolapStar.Column starColumn=((RolapCubeLevel)level).getStarKeyColumn();
    int bitPos=starColumn.getBitPosition();
    AggStar.Table.Column aggColumn=aggStar.lookupColumn(bitPos);
    String q=aggColumn.generateExprString(sqlQuery);
    sqlQuery.addSelectGroupBy(q,starColumn.getInternalType());
    sqlQuery.addOrderBy(q,true,false,true);
    aggColumn.getTable().addToFrom(sqlQuery,false,true);
    return sqlQuery.toSqlAndTypes();
  }
  hierarchy.addToFrom(sqlQuery,level.getKeyExp());
  String q=level.getKeyExp().getExpression(sqlQuery);
  sqlQuery.addSelectGroupBy(q,level.getInternalType());
  constraint.addLevelConstraint(sqlQuery,null,aggStar,level);
  if (levelCollapsed) {
    RolapStar.Column starColumn=((RolapCubeLevel)level).getStarKeyColumn();
    int bitPos=starColumn.getBitPosition();
    AggStar.Table.Column aggColumn=aggStar.lookupColumn(bitPos);
    RolapStar.Condition condition=new RolapStar.Condition(level.getKeyExp(),aggColumn.getExpression());
    sqlQuery.addWhere(condition.toString(sqlQuery));
    hierarchy.addToFromInverse(sqlQuery,level.getKeyExp());
    RolapCubeLevel parentLevel=(RolapCubeLevel)level.getParentLevel();
    boolean isUnique=level.isUnique();
    while (parentLevel != null && !parentLevel.isAll() && !isUnique) {
      hierarchy.addToFromInverse(sqlQuery,parentLevel.getKeyExp());
      starColumn=parentLevel.getStarKeyColumn();
      bitPos=starColumn.getBitPosition();
      aggColumn=aggStar.lookupColumn(bitPos);
      condition=new RolapStar.Condition(parentLevel.getKeyExp(),aggColumn.getExpression());
      sqlQuery.addWhere(condition.toString(sqlQuery));
      parentLevel=parentLevel.getParentLevel();
    }
  }
  if (level.hasCaptionColumn()) {
    MondrianDef.Expression captionExp=level.getCaptionExp();
    if (!levelCollapsed) {
      hierarchy.addToFrom(sqlQuery,captionExp);
    }
    String captionSql=captionExp.getExpression(sqlQuery);
    sqlQuery.addSelectGroupBy(captionSql,null);
  }
  if (!levelCollapsed) {
    hierarchy.addToFrom(sqlQuery,level.getOrdinalExp());
  }
  String orderBy=level.getOrdinalExp().getExpression(sqlQuery);
  sqlQuery.addOrderBy(orderBy,true,false,true);
  if (!orderBy.equals(q)) {
    sqlQuery.addSelectGroupBy(orderBy,null);
  }
  RolapProperty[] properties=level.getProperties();
  for (  RolapProperty property : properties) {
    final MondrianDef.Expression exp=property.getExp();
    if (!levelCollapsed) {
      hierarchy.addToFrom(sqlQuery,exp);
    }
    final String s=exp.getExpression(sqlQuery);
    String alias=sqlQuery.addSelect(s,null);
    if (!sqlQuery.getDialect().allowsSelectNotInGroupBy() || !property.dependsOnLevelValue()) {
      sqlQuery.addGroupBy(s,alias);
    }
  }
  return sqlQuery.toSqlAndTypes();
}","/** 
 * Generates the SQL statement to access the children of <code>member</code>. For example, <blockquote> <pre>SELECT ""city"" FROM ""customer"" WHERE ""country"" = 'USA' AND ""state_province"" = 'BC' GROUP BY ""city""</pre> </blockquote> retrieves the children of the member <code>[Canada].[BC]</code>. <p>Note that this method is never called in the context of virtual cubes, it is only called on regular cubes. <p>See also   {@link SqlTupleReader#makeLevelMembersSql}.
 */
Pair<String,List<SqlStatement.Type>> makeChildMemberSql(RolapMember member,DataSource dataSource,MemberChildrenConstraint constraint){
  SqlQuery sqlQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + member);
  AggStar aggStar=chooseAggStar(constraint,member);
  constraint.addMemberConstraint(sqlQuery,null,aggStar,member);
  RolapLevel level=(RolapLevel)member.getLevel().getChildLevel();
  boolean levelCollapsed=(aggStar != null) && isLevelCollapsed(aggStar,(RolapCubeLevel)level);
  boolean multipleCols=SqlMemberSource.levelContainsMultipleColumns(level);
  if (levelCollapsed && !multipleCols) {
    RolapStar.Column starColumn=((RolapCubeLevel)level).getStarKeyColumn();
    int bitPos=starColumn.getBitPosition();
    AggStar.Table.Column aggColumn=aggStar.lookupColumn(bitPos);
    String q=aggColumn.generateExprString(sqlQuery);
    final String qAlias=sqlQuery.addSelectGroupBy(q,starColumn.getInternalType());
    sqlQuery.addOrderBy(q,qAlias,true,false,true,true);
    aggColumn.getTable().addToFrom(sqlQuery,false,true);
    return sqlQuery.toSqlAndTypes();
  }
  hierarchy.addToFrom(sqlQuery,level.getKeyExp());
  String q=level.getKeyExp().getExpression(sqlQuery);
  String idAlias=sqlQuery.addSelectGroupBy(q,level.getInternalType());
  constraint.addLevelConstraint(sqlQuery,null,aggStar,level);
  if (levelCollapsed) {
    RolapStar.Column starColumn=((RolapCubeLevel)level).getStarKeyColumn();
    int bitPos=starColumn.getBitPosition();
    AggStar.Table.Column aggColumn=aggStar.lookupColumn(bitPos);
    RolapStar.Condition condition=new RolapStar.Condition(level.getKeyExp(),aggColumn.getExpression());
    sqlQuery.addWhere(condition.toString(sqlQuery));
    hierarchy.addToFromInverse(sqlQuery,level.getKeyExp());
    RolapCubeLevel parentLevel=(RolapCubeLevel)level.getParentLevel();
    boolean isUnique=level.isUnique();
    while (parentLevel != null && !parentLevel.isAll() && !isUnique) {
      hierarchy.addToFromInverse(sqlQuery,parentLevel.getKeyExp());
      starColumn=parentLevel.getStarKeyColumn();
      bitPos=starColumn.getBitPosition();
      aggColumn=aggStar.lookupColumn(bitPos);
      condition=new RolapStar.Condition(parentLevel.getKeyExp(),aggColumn.getExpression());
      sqlQuery.addWhere(condition.toString(sqlQuery));
      parentLevel=parentLevel.getParentLevel();
    }
  }
  if (level.hasCaptionColumn()) {
    MondrianDef.Expression captionExp=level.getCaptionExp();
    if (!levelCollapsed) {
      hierarchy.addToFrom(sqlQuery,captionExp);
    }
    String captionSql=captionExp.getExpression(sqlQuery);
    sqlQuery.addSelectGroupBy(captionSql,null);
  }
  if (!levelCollapsed) {
    hierarchy.addToFrom(sqlQuery,level.getOrdinalExp());
  }
  final String orderBy=level.getOrdinalExp().getExpression(sqlQuery);
  if (!orderBy.equals(q)) {
    String orderAlias=sqlQuery.addSelectGroupBy(orderBy,null);
    sqlQuery.addOrderBy(orderBy,orderAlias,true,false,true,true);
  }
 else {
    sqlQuery.addOrderBy(q,idAlias,true,false,true,true);
  }
  RolapProperty[] properties=level.getProperties();
  for (  RolapProperty property : properties) {
    final MondrianDef.Expression exp=property.getExp();
    if (!levelCollapsed) {
      hierarchy.addToFrom(sqlQuery,exp);
    }
    final String s=exp.getExpression(sqlQuery);
    String alias=sqlQuery.addSelect(s,null);
    if (!sqlQuery.getDialect().allowsSelectNotInGroupBy() || !property.dependsOnLevelValue()) {
      sqlQuery.addGroupBy(s,alias);
    }
  }
  return sqlQuery.toSqlAndTypes();
}",0.9612820512820512
50876,"private Pair<String,List<SqlStatement.Type>> makeKeysSql(DataSource dataSource){
  SqlQuery sqlQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + hierarchy);
  RolapLevel[] levels=(RolapLevel[])hierarchy.getLevels();
  for (  RolapLevel level : levels) {
    if (level.isAll()) {
      continue;
    }
    MondrianDef.Expression exp=level.getKeyExp();
    hierarchy.addToFrom(sqlQuery,exp);
    String expString=exp.getExpression(sqlQuery);
    sqlQuery.addSelectGroupBy(expString,null);
    exp=level.getOrdinalExp();
    hierarchy.addToFrom(sqlQuery,exp);
    expString=exp.getExpression(sqlQuery);
    sqlQuery.addOrderBy(expString,true,false,true);
    if (!exp.equals(level.getKeyExp())) {
      sqlQuery.addSelect(expString,null);
    }
    RolapProperty[] properties=level.getProperties();
    for (    RolapProperty property : properties) {
      exp=property.getExp();
      hierarchy.addToFrom(sqlQuery,exp);
      expString=exp.getExpression(sqlQuery);
      String alias=sqlQuery.addSelect(expString,null);
      if (!sqlQuery.getDialect().allowsSelectNotInGroupBy() || !property.dependsOnLevelValue()) {
        sqlQuery.addGroupBy(expString,alias);
      }
    }
  }
  return sqlQuery.toSqlAndTypes();
}","private Pair<String,List<SqlStatement.Type>> makeKeysSql(DataSource dataSource){
  SqlQuery sqlQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + hierarchy);
  RolapLevel[] levels=(RolapLevel[])hierarchy.getLevels();
  for (  RolapLevel level : levels) {
    if (level.isAll()) {
      continue;
    }
    final MondrianDef.Expression keyExp=level.getKeyExp();
    hierarchy.addToFrom(sqlQuery,keyExp);
    final String expString=keyExp.getExpression(sqlQuery);
    final String keyAlias=sqlQuery.addSelectGroupBy(expString,null);
    if (!keyExp.equals(level.getOrdinalExp())) {
      final MondrianDef.Expression ordinalExp=level.getOrdinalExp();
      hierarchy.addToFrom(sqlQuery,ordinalExp);
      final String ordinalExpString=ordinalExp.getExpression(sqlQuery);
      final String orderAlias=sqlQuery.addSelectGroupBy(ordinalExpString,null);
      sqlQuery.addOrderBy(ordinalExpString,orderAlias,true,false,true,true);
    }
 else {
      sqlQuery.addOrderBy(expString,keyAlias,true,false,true,true);
    }
    RolapProperty[] properties=level.getProperties();
    for (    RolapProperty property : properties) {
      final MondrianDef.Expression propExpr=property.getExp();
      hierarchy.addToFrom(sqlQuery,propExpr);
      final String propStringExpr=propExpr.getExpression(sqlQuery);
      final String propAlias=sqlQuery.addSelect(propStringExpr,null);
      if (!sqlQuery.getDialect().allowsSelectNotInGroupBy() || !property.dependsOnLevelValue()) {
        sqlQuery.addGroupBy(propStringExpr,propAlias);
      }
    }
  }
  return sqlQuery.toSqlAndTypes();
}",0.6873883529832083
50877,"/** 
 * Generates the SQL statement to access the children of <code>member</code> in a parent-child hierarchy. For example, <blockquote> <pre>SELECT ""employee_id"" FROM ""employee"" WHERE ""supervisor_id"" = 5</pre> </blockquote> retrieves the children of the member <code>[Employee].[5]</code>. <p>See also   {@link SqlTupleReader#makeLevelMembersSql}.
 */
private Pair<String,List<SqlStatement.Type>> makeChildMemberSqlPC(RolapMember member){
  SqlQuery sqlQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + ""String_Node_Str"" + member);
  RolapLevel level=member.getLevel();
  Util.assertTrue(!level.isAll(),""String_Node_Str"");
  Util.assertTrue(level.isUnique(),""String_Node_Str"" + level + ""String_Node_Str""+ ""String_Node_Str"");
  hierarchy.addToFrom(sqlQuery,level.getParentExp());
  String parentId=level.getParentExp().getExpression(sqlQuery);
  StringBuilder buf=new StringBuilder();
  sqlQuery.getDialect().quote(buf,member.getKey(),level.getDatatype());
  sqlQuery.addWhere(parentId,""String_Node_Str"",buf.toString());
  hierarchy.addToFrom(sqlQuery,level.getKeyExp());
  String childId=level.getKeyExp().getExpression(sqlQuery);
  sqlQuery.addSelectGroupBy(childId,level.getInternalType());
  hierarchy.addToFrom(sqlQuery,level.getOrdinalExp());
  String orderBy=level.getOrdinalExp().getExpression(sqlQuery);
  sqlQuery.addOrderBy(orderBy,true,false,true);
  if (!orderBy.equals(childId)) {
    sqlQuery.addSelectGroupBy(orderBy,null);
  }
  RolapProperty[] properties=level.getProperties();
  for (  RolapProperty property : properties) {
    final MondrianDef.Expression exp=property.getExp();
    hierarchy.addToFrom(sqlQuery,exp);
    final String s=exp.getExpression(sqlQuery);
    String alias=sqlQuery.addSelect(s,null);
    if (!sqlQuery.getDialect().allowsSelectNotInGroupBy() || !property.dependsOnLevelValue()) {
      sqlQuery.addGroupBy(s,alias);
    }
  }
  return sqlQuery.toSqlAndTypes();
}","/** 
 * Generates the SQL statement to access the children of <code>member</code> in a parent-child hierarchy. For example, <blockquote> <pre>SELECT ""employee_id"" FROM ""employee"" WHERE ""supervisor_id"" = 5</pre> </blockquote> retrieves the children of the member <code>[Employee].[5]</code>. <p>See also   {@link SqlTupleReader#makeLevelMembersSql}.
 */
private Pair<String,List<SqlStatement.Type>> makeChildMemberSqlPC(RolapMember member){
  SqlQuery sqlQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + ""String_Node_Str"" + member);
  RolapLevel level=member.getLevel();
  Util.assertTrue(!level.isAll(),""String_Node_Str"");
  Util.assertTrue(level.isUnique(),""String_Node_Str"" + level + ""String_Node_Str""+ ""String_Node_Str"");
  hierarchy.addToFrom(sqlQuery,level.getParentExp());
  String parentId=level.getParentExp().getExpression(sqlQuery);
  StringBuilder buf=new StringBuilder();
  sqlQuery.getDialect().quote(buf,member.getKey(),level.getDatatype());
  sqlQuery.addWhere(parentId,""String_Node_Str"",buf.toString());
  hierarchy.addToFrom(sqlQuery,level.getKeyExp());
  String childId=level.getKeyExp().getExpression(sqlQuery);
  String idAlias=sqlQuery.addSelectGroupBy(childId,level.getInternalType());
  hierarchy.addToFrom(sqlQuery,level.getOrdinalExp());
  final String orderBy=level.getOrdinalExp().getExpression(sqlQuery);
  if (!orderBy.equals(childId)) {
    String orderAlias=sqlQuery.addSelectGroupBy(orderBy,null);
    sqlQuery.addOrderBy(orderBy,orderAlias,true,false,true,true);
  }
 else {
    sqlQuery.addOrderBy(childId,idAlias,true,false,true,true);
  }
  RolapProperty[] properties=level.getProperties();
  for (  RolapProperty property : properties) {
    final MondrianDef.Expression exp=property.getExp();
    hierarchy.addToFrom(sqlQuery,exp);
    final String s=exp.getExpression(sqlQuery);
    String alias=sqlQuery.addSelect(s,null);
    if (!sqlQuery.getDialect().allowsSelectNotInGroupBy() || !property.dependsOnLevelValue()) {
      sqlQuery.addGroupBy(s,alias);
    }
  }
  return sqlQuery.toSqlAndTypes();
}",0.9273094396769308
50878,"/** 
 * Generates the SQL statement to access members of <code>level</code>. For example, <blockquote> <pre>SELECT ""country"", ""state_province"", ""city"" FROM ""customer"" GROUP BY ""country"", ""state_province"", ""city"", ""init"", ""bar"" ORDER BY ""country"", ""state_province"", ""city""</pre> </blockquote> accesses the ""City"" level of the ""Customers"" hierarchy. Note that:<ul> <li><code>""country"", ""state_province""</code> are the parent keys;</li> <li><code>""city""</code> is the level key;</li> <li><code>""init"", ""bar""</code> are member properties.</li> </ul>
 * @param sqlQuery the query object being constructed
 * @param level level to be added to the sql query
 * @param baseCube this is the cube object for regular cubes, and theunderlying base cube for virtual cubes
 * @param whichSelect describes whether this select belongs to a larger
 * @param aggStar aggregate star if available
 */
protected void addLevelMemberSql(SqlQuery sqlQuery,RolapLevel level,RolapCube baseCube,WhichSelect whichSelect,AggStar aggStar){
  RolapHierarchy hierarchy=level.getHierarchy();
  if (hierarchy instanceof RolapCubeHierarchy) {
    RolapCubeHierarchy cubeHierarchy=(RolapCubeHierarchy)hierarchy;
    if (baseCube != null && !cubeHierarchy.getCube().equals(baseCube)) {
      hierarchy=baseCube.findBaseCubeHierarchy(hierarchy);
    }
  }
  RolapLevel[] levels=(RolapLevel[])hierarchy.getLevels();
  int levelDepth=level.getDepth();
  boolean needsGroupBy=isGroupByNeeded(sqlQuery,hierarchy,levels,levelDepth);
  for (int i=0; i <= levelDepth; i++) {
    RolapLevel currLevel=levels[i];
    if (currLevel.isAll()) {
      continue;
    }
    boolean levelCollapsed=(aggStar != null) && SqlMemberSource.isLevelCollapsed(aggStar,(RolapCubeLevel)currLevel);
    boolean multipleCols=SqlMemberSource.levelContainsMultipleColumns(currLevel);
    if (levelCollapsed && !multipleCols) {
      RolapStar.Column starColumn=((RolapCubeLevel)currLevel).getStarKeyColumn();
      int bitPos=starColumn.getBitPosition();
      AggStar.Table.Column aggColumn=aggStar.lookupColumn(bitPos);
      String q=aggColumn.generateExprString(sqlQuery);
      sqlQuery.addSelectGroupBy(q,starColumn.getInternalType());
      if (whichSelect == WhichSelect.ONLY) {
        sqlQuery.addOrderBy(q,true,false,true);
      }
      aggColumn.getTable().addToFrom(sqlQuery,false,true);
      continue;
    }
    MondrianDef.Expression keyExp=currLevel.getKeyExp();
    MondrianDef.Expression ordinalExp=currLevel.getOrdinalExp();
    MondrianDef.Expression captionExp=currLevel.getCaptionExp();
    MondrianDef.Expression parentExp=currLevel.getParentExp();
    if (parentExp != null) {
      if (!levelCollapsed) {
        hierarchy.addToFrom(sqlQuery,parentExp);
      }
      String parentSql=parentExp.getExpression(sqlQuery);
      sqlQuery.addSelectGroupBy(parentSql,currLevel.getInternalType());
      if (whichSelect == WhichSelect.LAST || whichSelect == WhichSelect.ONLY) {
        sqlQuery.addOrderBy(parentSql,true,false,true,false);
      }
    }
    String keySql=keyExp.getExpression(sqlQuery);
    String ordinalSql=ordinalExp.getExpression(sqlQuery);
    if (!levelCollapsed) {
      hierarchy.addToFrom(sqlQuery,keyExp);
      hierarchy.addToFrom(sqlQuery,ordinalExp);
    }
    String captionSql=null;
    if (captionExp != null) {
      captionSql=captionExp.getExpression(sqlQuery);
      if (!levelCollapsed) {
        hierarchy.addToFrom(sqlQuery,captionExp);
      }
    }
    String alias=sqlQuery.addSelect(keySql,currLevel.getInternalType());
    if (needsGroupBy) {
      sqlQuery.addGroupBy(keySql,alias);
    }
    if (captionSql != null) {
      alias=sqlQuery.addSelect(captionSql,null);
      if (needsGroupBy) {
        sqlQuery.addGroupBy(captionSql,alias);
      }
    }
    if (!ordinalSql.equals(keySql)) {
      alias=sqlQuery.addSelect(ordinalSql,null);
      if (needsGroupBy) {
        sqlQuery.addGroupBy(ordinalSql,alias);
      }
    }
    constraint.addLevelConstraint(sqlQuery,baseCube,aggStar,currLevel);
    if (levelCollapsed) {
      hierarchy.addToFromInverse(sqlQuery,keyExp);
      RolapStar.Column starColumn=((RolapCubeLevel)currLevel).getStarKeyColumn();
      int bitPos=starColumn.getBitPosition();
      AggStar.Table.Column aggColumn=aggStar.lookupColumn(bitPos);
      RolapStar.Condition condition=new RolapStar.Condition(keyExp,aggColumn.getExpression());
      sqlQuery.addWhere(condition.toString(sqlQuery));
    }
    if (whichSelect == WhichSelect.ONLY) {
      sqlQuery.addOrderBy(ordinalSql,true,false,true);
    }
    RolapProperty[] properties=currLevel.getProperties();
    for (    RolapProperty property : properties) {
      final MondrianDef.Expression propExp=property.getExp();
      final String propSql;
      if (propExp instanceof MondrianDef.Column) {
        propSql=sqlQuery.getDialect().quoteIdentifier(currLevel.getTableAlias(),((MondrianDef.Column)propExp).name);
      }
 else {
        propSql=property.getExp().getExpression(sqlQuery);
      }
      alias=sqlQuery.addSelect(propSql,null);
      if (needsGroupBy) {
        if (!sqlQuery.getDialect().allowsSelectNotInGroupBy() || !property.dependsOnLevelValue()) {
          sqlQuery.addGroupBy(propSql,alias);
        }
      }
    }
  }
}","/** 
 * Generates the SQL statement to access members of <code>level</code>. For example, <blockquote> <pre>SELECT ""country"", ""state_province"", ""city"" FROM ""customer"" GROUP BY ""country"", ""state_province"", ""city"", ""init"", ""bar"" ORDER BY ""country"", ""state_province"", ""city""</pre> </blockquote> accesses the ""City"" level of the ""Customers"" hierarchy. Note that:<ul> <li><code>""country"", ""state_province""</code> are the parent keys;</li> <li><code>""city""</code> is the level key;</li> <li><code>""init"", ""bar""</code> are member properties.</li> </ul>
 * @param sqlQuery the query object being constructed
 * @param level level to be added to the sql query
 * @param baseCube this is the cube object for regular cubes, and theunderlying base cube for virtual cubes
 * @param whichSelect describes whether this select belongs to a larger
 * @param aggStar aggregate star if available
 */
protected void addLevelMemberSql(SqlQuery sqlQuery,RolapLevel level,RolapCube baseCube,WhichSelect whichSelect,AggStar aggStar){
  RolapHierarchy hierarchy=level.getHierarchy();
  if (hierarchy instanceof RolapCubeHierarchy) {
    RolapCubeHierarchy cubeHierarchy=(RolapCubeHierarchy)hierarchy;
    if (baseCube != null && !cubeHierarchy.getCube().equals(baseCube)) {
      hierarchy=baseCube.findBaseCubeHierarchy(hierarchy);
    }
  }
  RolapLevel[] levels=(RolapLevel[])hierarchy.getLevels();
  int levelDepth=level.getDepth();
  boolean needsGroupBy=isGroupByNeeded(sqlQuery,hierarchy,levels,levelDepth);
  for (int i=0; i <= levelDepth; i++) {
    RolapLevel currLevel=levels[i];
    if (currLevel.isAll()) {
      continue;
    }
    boolean levelCollapsed=(aggStar != null) && SqlMemberSource.isLevelCollapsed(aggStar,(RolapCubeLevel)currLevel);
    boolean multipleCols=SqlMemberSource.levelContainsMultipleColumns(currLevel);
    if (levelCollapsed && !multipleCols) {
      RolapStar.Column starColumn=((RolapCubeLevel)currLevel).getStarKeyColumn();
      int bitPos=starColumn.getBitPosition();
      AggStar.Table.Column aggColumn=aggStar.lookupColumn(bitPos);
      String q=aggColumn.generateExprString(sqlQuery);
      final String qAlias=sqlQuery.addSelectGroupBy(q,starColumn.getInternalType());
      if (whichSelect == WhichSelect.ONLY) {
        sqlQuery.addOrderBy(q,qAlias,true,false,true,true);
      }
      aggColumn.getTable().addToFrom(sqlQuery,false,true);
      continue;
    }
    MondrianDef.Expression keyExp=currLevel.getKeyExp();
    MondrianDef.Expression ordinalExp=currLevel.getOrdinalExp();
    MondrianDef.Expression captionExp=currLevel.getCaptionExp();
    MondrianDef.Expression parentExp=currLevel.getParentExp();
    if (parentExp != null) {
      if (!levelCollapsed) {
        hierarchy.addToFrom(sqlQuery,parentExp);
      }
      if (whichSelect == WhichSelect.LAST || whichSelect == WhichSelect.ONLY) {
        final String parentSql=parentExp.getExpression(sqlQuery);
        final String parentAlias=sqlQuery.addSelectGroupBy(parentSql,currLevel.getInternalType());
        sqlQuery.addOrderBy(parentSql,parentAlias,true,false,true,false);
      }
    }
    String keySql=keyExp.getExpression(sqlQuery);
    String ordinalSql=ordinalExp.getExpression(sqlQuery);
    if (!levelCollapsed) {
      hierarchy.addToFrom(sqlQuery,keyExp);
      hierarchy.addToFrom(sqlQuery,ordinalExp);
    }
    String captionSql=null;
    if (captionExp != null) {
      captionSql=captionExp.getExpression(sqlQuery);
      if (!levelCollapsed) {
        hierarchy.addToFrom(sqlQuery,captionExp);
      }
    }
    final String keyAlias=sqlQuery.addSelect(keySql,currLevel.getInternalType());
    if (needsGroupBy) {
      sqlQuery.addGroupBy(keySql,keyAlias);
    }
    if (captionSql != null) {
      final String captionAlias=sqlQuery.addSelect(captionSql,null);
      if (needsGroupBy) {
        sqlQuery.addGroupBy(captionSql,captionAlias);
      }
    }
    final String orderByAlias;
    if (!ordinalSql.equals(keySql)) {
      orderByAlias=sqlQuery.addSelect(ordinalSql,null);
      if (needsGroupBy) {
        sqlQuery.addGroupBy(ordinalSql,orderByAlias);
      }
      if (whichSelect == WhichSelect.ONLY) {
        sqlQuery.addOrderBy(ordinalSql,orderByAlias,true,false,true,true);
      }
    }
 else {
      if (whichSelect == WhichSelect.ONLY) {
        sqlQuery.addOrderBy(keySql,keyAlias,true,false,true,true);
      }
    }
    constraint.addLevelConstraint(sqlQuery,baseCube,aggStar,currLevel);
    if (levelCollapsed) {
      hierarchy.addToFromInverse(sqlQuery,keyExp);
      RolapStar.Column starColumn=((RolapCubeLevel)currLevel).getStarKeyColumn();
      int bitPos=starColumn.getBitPosition();
      AggStar.Table.Column aggColumn=aggStar.lookupColumn(bitPos);
      RolapStar.Condition condition=new RolapStar.Condition(keyExp,aggColumn.getExpression());
      sqlQuery.addWhere(condition.toString(sqlQuery));
    }
    RolapProperty[] properties=currLevel.getProperties();
    for (    RolapProperty property : properties) {
      final MondrianDef.Expression propExp=property.getExp();
      final String propSql;
      if (propExp instanceof MondrianDef.Column) {
        propSql=sqlQuery.getDialect().quoteIdentifier(currLevel.getTableAlias(),((MondrianDef.Column)propExp).name);
      }
 else {
        propSql=property.getExp().getExpression(sqlQuery);
      }
      final String propAlias=sqlQuery.addSelect(propSql,null);
      if (needsGroupBy) {
        if (!sqlQuery.getDialect().allowsSelectNotInGroupBy() || !property.dependsOnLevelValue()) {
          sqlQuery.addGroupBy(propSql,propAlias);
        }
      }
    }
  }
}",0.8479911127568969
50879,"/** 
 * Testcase for bug <a href=""http://jira.pentaho.com/browse/MONDRIAN-852""> MONDRIAN-852, ""Using the generate command, cast and calculated measures causes ClassCastException""</a>. <p>The problem is in the implicit conversion that occurs when using a member as a numeric value. (In this case the conversion occurs because we apply the numeric operator '/'.) We have to assume at prepare time that the current measure will be numeric, but at run time the value may be a string. <p>We were wrongly throwing a ClassCastException. Correct behavior is an evaluation exception: the cell is in error, but the query as a whole succeeds.
 */
public void testBugMondrian852(){
  assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Testcase for bug <a href=""http://jira.pentaho.com/browse/MONDRIAN-852""> MONDRIAN-852, ""Using the generate command, cast and calculated measures causes ClassCastException""</a>. <p>The problem is in the implicit conversion that occurs when using a member as a numeric value. (In this case the conversion occurs because we apply the numeric operator '/'.) We have to assume at prepare time that the current measure will be numeric, but at run time the value may be a string. <p>We were wrongly throwing a ClassCastException. Correct behavior is an evaluation exception: the cell is in error, but the query as a whole succeeds.
 */
public void testBugMondrian852(){
  assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  executeQuery(""String_Node_Str"" + ""String_Node_Str"");
  assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.984877646411878
50880,"public void testAllowsCompoundCountDistinct(){
  String sql=dialectize(""String_Node_Str"" + ""String_Node_Str"");
  if (getDialect().allowsCompoundCountDistinct()) {
    assertQuerySucceeds(sql);
  }
 else {
    String[] errs={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",INFOBRIGHT_UNSUPPORTED,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}","public void testAllowsCompoundCountDistinct(){
  String sql=dialectize(""String_Node_Str"" + ""String_Node_Str"");
  if (getDialect().allowsCompoundCountDistinct()) {
    assertQuerySucceeds(sql);
  }
 else {
    String[] errs={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",INFOBRIGHT_UNSUPPORTED,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}",0.9823874755381604
50881,"/** 
 * Unit test for   {@link Dialect#allowsSelectNotInGroupBy}.
 */
public void testAllowsSelectNotInGroupBy() throws SQLException {
  Dialect dialect=getDialect();
  String sql=""String_Node_Str"" + dialect.quoteIdentifier(""String_Node_Str"") + ""String_Node_Str""+ dialect.quoteIdentifier(""String_Node_Str"")+ ""String_Node_Str""+ dialect.quoteIdentifier(""String_Node_Str"")+ ""String_Node_Str""+ dialect.quoteIdentifier(""String_Node_Str"");
  if (dialect.allowsSelectNotInGroupBy()) {
    final ResultSet resultSet=getConnection().createStatement().executeQuery(sql);
    assertTrue(resultSet.next());
    resultSet.close();
  }
 else {
    String[] errs={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}","/** 
 * Unit test for   {@link Dialect#allowsSelectNotInGroupBy}.
 */
public void testAllowsSelectNotInGroupBy() throws SQLException {
  Dialect dialect=getDialect();
  String sql=""String_Node_Str"" + dialect.quoteIdentifier(""String_Node_Str"") + ""String_Node_Str""+ dialect.quoteIdentifier(""String_Node_Str"")+ ""String_Node_Str""+ dialect.quoteIdentifier(""String_Node_Str"")+ ""String_Node_Str""+ dialect.quoteIdentifier(""String_Node_Str"");
  if (dialect.allowsSelectNotInGroupBy()) {
    final ResultSet resultSet=getConnection().createStatement().executeQuery(sql);
    assertTrue(resultSet.next());
    resultSet.close();
  }
 else {
    String[] errs={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}",0.991906474820144
50882,"public void testSupportsMultiValueInExpr(){
  String sql=dialectize(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  if (getDialect().supportsMultiValueInExpr()) {
    assertQuerySucceeds(sql);
  }
 else {
    String[] errs={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",INFOBRIGHT_UNSUPPORTED,NEOVIEW_SYNTAX_ERROR,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}","public void testSupportsMultiValueInExpr(){
  String sql=dialectize(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  if (getDialect().supportsMultiValueInExpr()) {
    assertQuerySucceeds(sql);
  }
 else {
    String[] errs={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",INFOBRIGHT_UNSUPPORTED,NEOVIEW_SYNTAX_ERROR,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}",0.9802631578947368
50883,"public void testRequiresUnionOrderByExprToBeInSelectClause(){
  String sql=dialectize(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  if (!getDialect().requiresUnionOrderByExprToBeInSelectClause()) {
    assertQuerySucceeds(sql);
  }
 else {
    String[] errs={""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",NEOVIEW_SYNTAX_ERROR,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}","public void testRequiresUnionOrderByExprToBeInSelectClause(){
  String sql=dialectize(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  if (!getDialect().requiresUnionOrderByExprToBeInSelectClause()) {
    assertQuerySucceeds(sql);
  }
 else {
    String[] errs={""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",NEOVIEW_SYNTAX_ERROR,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}",0.986425339366516
50884,"public void testDialectVsDatabaseProduct() throws SQLException {
  final Dialect dialect=getDialect();
  final Dialect.DatabaseProduct databaseProduct=dialect.getDatabaseProduct();
  final DatabaseMetaData databaseMetaData=getConnection().getMetaData();
switch (databaseProduct) {
case MYSQL:
    assertTrue(dialect instanceof MySqlDialect);
  assertFalse(dialect instanceof InfobrightDialect);
assertFalse(MySqlDialect.isInfobright(databaseMetaData));
assertEquals(""String_Node_Str"",databaseMetaData.getDatabaseProductName());
break;
case HIVE:
assertTrue(dialect instanceof HiveDialect);
break;
case INFOBRIGHT:
assertTrue(dialect instanceof MySqlDialect);
assertTrue(dialect instanceof InfobrightDialect);
assertTrue(MySqlDialect.isInfobright(databaseMetaData));
assertEquals(""String_Node_Str"",databaseMetaData.getDatabaseProductName());
break;
case POSTGRESQL:
assertTrue(dialect instanceof PostgreSqlDialect);
assertFalse(dialect instanceof NetezzaDialect);
assertTrue(databaseMetaData.getDatabaseProductName().indexOf(""String_Node_Str"") >= 0);
break;
case NETEZZA:
assertTrue(dialect instanceof PostgreSqlDialect);
assertTrue(dialect instanceof NetezzaDialect);
assertTrue(databaseMetaData.getDatabaseProductName().indexOf(""String_Node_Str"") >= 0);
break;
default :
assertFalse(dialect instanceof MySqlDialect);
assertFalse(dialect instanceof InfobrightDialect);
assertNotSame(""String_Node_Str"",databaseMetaData.getDatabaseProductName());
break;
}
}","public void testDialectVsDatabaseProduct() throws SQLException {
  final Dialect dialect=getDialect();
  final Dialect.DatabaseProduct databaseProduct=dialect.getDatabaseProduct();
  final DatabaseMetaData databaseMetaData=getConnection().getMetaData();
switch (databaseProduct) {
case MYSQL:
    assertTrue(dialect instanceof MySqlDialect);
  assertFalse(dialect instanceof InfobrightDialect);
assertFalse(MySqlDialect.isInfobright(databaseMetaData));
assertEquals(""String_Node_Str"",databaseMetaData.getDatabaseProductName());
break;
case HIVE:
assertTrue(dialect instanceof HiveDialect);
break;
case INFOBRIGHT:
assertTrue(dialect instanceof MySqlDialect);
assertTrue(dialect instanceof InfobrightDialect);
assertTrue(MySqlDialect.isInfobright(databaseMetaData));
assertEquals(""String_Node_Str"",databaseMetaData.getDatabaseProductName());
break;
case POSTGRESQL:
assertTrue(dialect instanceof PostgreSqlDialect);
assertFalse(dialect instanceof NetezzaDialect);
assertTrue(databaseMetaData.getDatabaseProductName().indexOf(""String_Node_Str"") >= 0);
break;
case MSSQL:
assertTrue(dialect instanceof MicrosoftSqlServerDialect);
assertTrue(databaseMetaData.getDatabaseProductName().contains(""String_Node_Str""));
break;
case NETEZZA:
assertTrue(dialect instanceof PostgreSqlDialect);
assertTrue(dialect instanceof NetezzaDialect);
assertTrue(databaseMetaData.getDatabaseProductName().indexOf(""String_Node_Str"") >= 0);
break;
default :
assertFalse(dialect instanceof MySqlDialect);
assertFalse(dialect instanceof InfobrightDialect);
assertNotSame(""String_Node_Str"",databaseMetaData.getDatabaseProductName());
break;
}
}",0.9478827361563518
50885,"public void testRequiresFromQueryAlias(){
  if (getDialect().requiresAliasForFromQuery()) {
    assertTrue(getDialect().allowsFromQuery());
  }
  if (!getDialect().allowsFromQuery()) {
    return;
  }
  String sql=dialectize(""String_Node_Str"");
  if (getDialect().requiresAliasForFromQuery()) {
    String[] errs={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NEOVIEW_SYNTAX_ERROR,""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
 else {
    assertQuerySucceeds(sql);
  }
}","public void testRequiresFromQueryAlias(){
  if (getDialect().requiresAliasForFromQuery()) {
    assertTrue(getDialect().allowsFromQuery());
  }
  if (!getDialect().allowsFromQuery()) {
    return;
  }
  String sql=dialectize(""String_Node_Str"");
  if (getDialect().requiresAliasForFromQuery()) {
    String[] errs={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NEOVIEW_SYNTAX_ERROR,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
 else {
    assertQuerySucceeds(sql);
  }
}",0.9847715736040608
50886,"public void testAllowsCompoundCountDistinct(){
  String sql=dialectize(""String_Node_Str"" + ""String_Node_Str"");
  if (getDialect().allowsCompoundCountDistinct()) {
    assertQuerySucceeds(sql);
  }
 else {
    String[] errs={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",INFOBRIGHT_UNSUPPORTED,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}","public void testAllowsCompoundCountDistinct(){
  String sql=dialectize(""String_Node_Str"" + ""String_Node_Str"");
  if (getDialect().allowsCompoundCountDistinct()) {
    assertQuerySucceeds(sql);
  }
 else {
    String[] errs={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",INFOBRIGHT_UNSUPPORTED,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}",0.9817444219066938
50887,"public void testSupportsGroupByExpressions(){
  String sql=dialectize(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  if (getDialect().supportsGroupByExpressions()) {
    assertQuerySucceeds(sql);
  }
 else {
    final String[] errs={""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}","public void testSupportsGroupByExpressions(){
  String sql=dialectize(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  if (getDialect().supportsGroupByExpressions()) {
    assertQuerySucceeds(sql);
  }
 else {
    final String[] errs={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}",0.9728915662650602
50888,"/** 
 * Unit test for   {@link Dialect#allowsSelectNotInGroupBy}.
 */
public void testAllowsSelectNotInGroupBy() throws SQLException {
  Dialect dialect=getDialect();
  String sql=""String_Node_Str"" + dialect.quoteIdentifier(""String_Node_Str"") + ""String_Node_Str""+ dialect.quoteIdentifier(""String_Node_Str"")+ ""String_Node_Str""+ dialect.quoteIdentifier(""String_Node_Str"")+ ""String_Node_Str""+ dialect.quoteIdentifier(""String_Node_Str"");
  if (dialect.allowsSelectNotInGroupBy()) {
    final ResultSet resultSet=getConnection().createStatement().executeQuery(sql);
    assertTrue(resultSet.next());
    resultSet.close();
  }
 else {
    String[] errs={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}","/** 
 * Unit test for   {@link Dialect#allowsSelectNotInGroupBy}.
 */
public void testAllowsSelectNotInGroupBy() throws SQLException {
  Dialect dialect=getDialect();
  String sql=""String_Node_Str"" + dialect.quoteIdentifier(""String_Node_Str"") + ""String_Node_Str""+ dialect.quoteIdentifier(""String_Node_Str"")+ ""String_Node_Str""+ dialect.quoteIdentifier(""String_Node_Str"")+ ""String_Node_Str""+ dialect.quoteIdentifier(""String_Node_Str"");
  if (dialect.allowsSelectNotInGroupBy()) {
    final ResultSet resultSet=getConnection().createStatement().executeQuery(sql);
    assertTrue(resultSet.next());
    resultSet.close();
  }
 else {
    String[] errs={""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}",0.9917733089579523
50889,"public void testSupportsMultiValueInExpr(){
  String sql=dialectize(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  if (getDialect().supportsMultiValueInExpr()) {
    assertQuerySucceeds(sql);
  }
 else {
    String[] errs={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",INFOBRIGHT_UNSUPPORTED,NEOVIEW_SYNTAX_ERROR,""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}","public void testSupportsMultiValueInExpr(){
  String sql=dialectize(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  if (getDialect().supportsMultiValueInExpr()) {
    assertQuerySucceeds(sql);
  }
 else {
    String[] errs={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",INFOBRIGHT_UNSUPPORTED,NEOVIEW_SYNTAX_ERROR,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}",0.9794520547945206
50890,"/** 
 * Tests that the  {@link mondrian.spi.Dialect#supportsGroupingSets()}dialect property is accurate.
 */
public void testAllowsGroupingSets(){
  String sql=dialectize(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  if (getDialect().supportsGroupingSets()) {
    assertQuerySucceeds(sql);
  }
 else {
    String[] errs={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",NEOVIEW_SYNTAX_ERROR,""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}","/** 
 * Tests that the  {@link mondrian.spi.Dialect#supportsGroupingSets()}dialect property is accurate.
 */
public void testAllowsGroupingSets(){
  String sql=dialectize(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  if (getDialect().supportsGroupingSets()) {
    assertQuerySucceeds(sql);
  }
 else {
    String[] errs={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",NEOVIEW_SYNTAX_ERROR,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
}",0.9868035190615836
50891,"public void testRequiresFromQueryAlias(){
  if (getDialect().requiresAliasForFromQuery()) {
    assertTrue(getDialect().allowsFromQuery());
  }
  if (!getDialect().allowsFromQuery()) {
    return;
  }
  String sql=dialectize(""String_Node_Str"");
  if (getDialect().requiresAliasForFromQuery()) {
    String[] errs={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NEOVIEW_SYNTAX_ERROR,""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
 else {
    assertQuerySucceeds(sql);
  }
}","public void testRequiresFromQueryAlias(){
  if (getDialect().requiresAliasForFromQuery()) {
    assertTrue(getDialect().allowsFromQuery());
  }
  if (!getDialect().allowsFromQuery()) {
    return;
  }
  String sql=dialectize(""String_Node_Str"");
  if (getDialect().requiresAliasForFromQuery()) {
    String[] errs={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NEOVIEW_SYNTAX_ERROR,""String_Node_Str"",""String_Node_Str""};
    assertQueryFails(sql,errs);
  }
 else {
    assertQuerySucceeds(sql);
  }
}",0.9842931937172776
50892,"/** 
 * Unit test for bug <a href=""http://jira.pentaho.com/browse/MONDRIAN-747""> MONDRIAN-747, ""When joining a shared dimension into a cube at a level other than its leaf level, Mondrian gives wrong results""</a>.
 */
public void testBugMondrian747(){
switch (TestContext.instance().getDialect().getDatabaseProduct()) {
case ORACLE:
    break;
default :
  return;
}
final TestContext testContext=TestContext.instance().withSchema(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
if (!Bug.BugMondrian747Fixed && MondrianProperties.instance().EnableGroupingSets.get()) {
return;
}
final String x=!Bug.BugMondrian747Fixed ? ""String_Node_Str"" : ""String_Node_Str"";
testContext.assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + x + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
final String y=!Bug.BugMondrian747Fixed && MondrianProperties.instance().ReadAggregates.get() && MondrianProperties.instance().UseAggregates.get() ? ""String_Node_Str"" : ""String_Node_Str"";
testContext.assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + y + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
testContext.assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + y + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Unit test for bug <a href=""http://jira.pentaho.com/browse/MONDRIAN-747""> MONDRIAN-747, ""When joining a shared dimension into a cube at a level other than its leaf level, Mondrian gives wrong results""</a>.
 */
public void testBugMondrian747(){
switch (TestContext.instance().getDialect().getDatabaseProduct()) {
case ORACLE:
    break;
default :
  return;
}
final TestContext testContext=TestContext.instance().withSchema(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
if (!Bug.BugMondrian747Fixed && MondrianProperties.instance().EnableGroupingSets.get()) {
return;
}
final String x=!Bug.BugMondrian747Fixed ? ""String_Node_Str"" : ""String_Node_Str"";
testContext.assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + x + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
testContext.assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
testContext.assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9721894885694085
50893,"public RolapResultShepherd(){
  final IntegerProperty property=MondrianProperties.instance().RolapConnectionShepherdNbThreads;
  final int maximumPoolSize=property.get();
  executor=Util.getExecutorService(maximumPoolSize,0,1,""String_Node_Str"",new RejectedExecutionHandler(){
    public void rejectedExecution(    Runnable r,    ThreadPoolExecutor executor){
      throw MondrianResource.instance().QueryLimitReached.ex(maximumPoolSize,property.getPath());
    }
  }
);
  final Pair<Long,TimeUnit> interval=Util.parseInterval(MondrianProperties.instance().RolapConnectionShepherdThreadPollingInterval.get(),TimeUnit.MILLISECONDS);
  long period=interval.right.toMillis(interval.left);
  timer.scheduleAtFixedRate(new TimerTask(){
    public void run(){
      for (      final Pair<FutureTask<Result>,Execution> task : tasks) {
        if (task.left.isDone()) {
          tasks.remove(task);
          continue;
        }
        if (task.right.isCancelOrTimeout()) {
          tasks.remove(task);
          task.left.cancel(false);
          executor.submit(new Runnable(){
            public void run(){
              try {
                task.right.cancelSqlStatements();
              }
 catch (              Throwable e) {
                e.printStackTrace();
              }
            }
          }
);
        }
      }
    }
  }
,period,period);
}","public RolapResultShepherd(){
  final IntegerProperty property=MondrianProperties.instance().RolapConnectionShepherdNbThreads;
  final int maximumPoolSize=property.get();
  executor=Util.getExecutorService(maximumPoolSize,0,1,""String_Node_Str"",new RejectedExecutionHandler(){
    public void rejectedExecution(    Runnable r,    ThreadPoolExecutor executor){
      throw MondrianResource.instance().QueryLimitReached.ex(maximumPoolSize,property.getPath());
    }
  }
);
  final Pair<Long,TimeUnit> interval=Util.parseInterval(String.valueOf(MondrianProperties.instance().RolapConnectionShepherdThreadPollingInterval.get()),TimeUnit.MILLISECONDS);
  long period=interval.right.toMillis(interval.left);
  timer.scheduleAtFixedRate(new TimerTask(){
    public void run(){
      for (      final Pair<FutureTask<Result>,Execution> task : tasks) {
        if (task.left.isDone()) {
          tasks.remove(task);
          continue;
        }
        if (task.right.isCancelOrTimeout()) {
          tasks.remove(task);
          task.left.cancel(false);
          executor.submit(new Runnable(){
            public void run(){
              try {
                task.right.cancelSqlStatements();
              }
 catch (              Throwable e) {
                e.printStackTrace();
              }
            }
          }
);
        }
      }
    }
  }
,period,period);
}",0.9941348973607038
50894,"/** 
 * Creates a DynamicContentFinder.
 * @param dataSourcesConfigUrl URL of repository
 */
public DynamicContentFinder(String dataSourcesConfigUrl){
  super(dataSourcesConfigUrl);
  reloadDataSources();
  timer=Util.newTimer(""String_Node_Str"",true);
  final Pair<Long,TimeUnit> interval=Util.parseInterval(MondrianProperties.instance().XmlaSchemaRefreshInterval.get(),TimeUnit.MILLISECONDS);
  final long period=interval.right.toMillis(interval.left);
  timer.scheduleAtFixedRate(new TimerTask(){
    public void run(){
      reloadDataSources();
    }
  }
,period,period);
}","/** 
 * Creates a DynamicContentFinder.
 * @param dataSourcesConfigUrl URL of repository
 */
public DynamicContentFinder(String dataSourcesConfigUrl){
  super(dataSourcesConfigUrl);
  reloadDataSources();
  timer=Util.newTimer(""String_Node_Str"",true);
  final Pair<Long,TimeUnit> interval=Util.parseInterval(String.valueOf(MondrianProperties.instance().XmlaSchemaRefreshInterval.get()),TimeUnit.MILLISECONDS);
  final long period=interval.right.toMillis(interval.left);
  timer.scheduleAtFixedRate(new TimerTask(){
    public void run(){
      reloadDataSources();
    }
  }
,period,period);
}",0.9863247863247864
50895,"private synchronized void setTimer(T referent,String timeoutString){
  final long timeout=toMillis(timeoutString);
  if (timeout == Long.MIN_VALUE && expiry != Long.MIN_VALUE) {
    return;
  }
  if (timeout == 0) {
    expiry=Long.MAX_VALUE;
    this.hardRef=referent;
    return;
  }
  if (timeout > 0) {
    long newExpiry=System.currentTimeMillis() + timeout;
    if (newExpiry > expiry) {
      expiry=newExpiry;
    }
    this.hardRef=referent;
    timer.schedule(getTask(),timeout + 10);
    return;
  }
  this.hardRef=null;
}","private synchronized void setTimer(T referent,String timeoutString){
  Pair<Long,TimeUnit> pair=Util.parseInterval(timeoutString,null);
  final long timeout=pair.right.toMillis(pair.left);
  if (timeout == Long.MIN_VALUE && expiry != Long.MIN_VALUE) {
    return;
  }
  if (timeout == 0) {
    expiry=Long.MAX_VALUE;
    this.hardRef=referent;
    return;
  }
  if (timeout > 0) {
    long newExpiry=System.currentTimeMillis() + timeout;
    if (newExpiry > expiry) {
      expiry=newExpiry;
    }
    this.hardRef=referent;
    timer.schedule(getTask(),timeout + 10);
    return;
  }
  this.hardRef=null;
}",0.8789473684210526
50896,V get(K key);,"/** 
 * Looks up and returns a cache value according to a given key. If the cache does not correspond an entry corresponding to the key, <code>null</code> is returned.
 */
V get(K key);",0.1313131313131313
50897,"/** 
 * Places a key/value pair into the queue.
 * @param key Key
 * @param value Value
 * @return the previous value of <code>key</code> or null
 */
V put(K key,V value);","/** 
 * Places a key/value pair into the cache.
 * @param key Key
 * @param value Value
 * @return the previous value of <code>key</code> or null
 */
V put(K key,V value);",0.9766081871345028
50898,"@Override public String processSchema(String schemaUrl,PropertyList connectInfo) throws Exception {
  return Util.readVirtualFileAsString(schemaUrl);
}","public String processSchema(String schemaUrl,PropertyList connectInfo) throws Exception {
  return Util.readVirtualFileAsString(schemaUrl);
}",0.9657534246575342
50899,"/** 
 * Creates a TestSuite to test the whole of mondrian. Methods with the signature <code>public static Test suite()</code> are recognized automatically by JUnit test-harnesses; see   {@link TestSuite}.
 * @return test suite
 * @throws Exception on error
 */
public static Test suite() throws Exception {
  MondrianProperties properties=MondrianProperties.instance();
  String testName=properties.TestName.get();
  String testClass=properties.TestClass.get();
  System.out.println(""String_Node_Str"" + testName);
  System.out.println(""String_Node_Str"" + testClass);
  System.out.println(""String_Node_Str"" + System.getProperty(""String_Node_Str""));
  TestSuite suite=new TestSuite();
  if (testClass != null && !testClass.equals(""String_Node_Str"")) {
    Class<? extends TestCase> clazz=(Class<? extends TestCase>)Class.forName(testClass);
    boolean matchTestMethods=false;
    if (Test.class.isAssignableFrom(clazz)) {
      Method[] methods=clazz.getMethods();
      for (int i=0; i < methods.length && !matchTestMethods; i++) {
        matchTestMethods=methods[i].getName().startsWith(""String_Node_Str"");
      }
    }
    if (matchTestMethods) {
      addTest(suite,clazz);
    }
 else {
      Method method=clazz.getMethod(""String_Node_Str"",new Class[0]);
      TestCase target;
      if (Modifier.isStatic(method.getModifiers())) {
        target=null;
      }
 else {
        target=clazz.newInstance();
      }
      Object o=method.invoke(target);
      addTest(suite,(Test)o,clazz.getName() + method.getName());
    }
  }
 else {
    if (RUN_OPTIONAL_TESTS) {
      addTest(suite,SegmentLoaderTest.class);
      addTest(suite,AggGenTest.class);
      addTest(suite,DefaultRuleTest.class);
      addTest(suite,SelectNotInGroupByTest.class);
      addTest(suite,CVConcurrentMdxTest.class);
      addTest(suite,CacheHitTest.class);
      addTest(suite,ConcurrentMdxTest.class);
      addTest(suite,MemHungryTest.class,""String_Node_Str"");
      addTest(suite,MultiDimTest.class,""String_Node_Str"");
      addTest(suite,MultiDimVCTest.class,""String_Node_Str"");
      addTest(suite,MultiLevelTest.class,""String_Node_Str"");
      addTest(suite,MultiLevelVCTest.class,""String_Node_Str"");
      addTest(suite,PartialCacheTest.class,""String_Node_Str"");
      addTest(suite,PartialCacheVCTest.class,""String_Node_Str"");
      addTest(suite,QueryAllTest.class,""String_Node_Str"");
      addTest(suite,QueryAllVCTest.class,""String_Node_Str"");
      addTest(suite,Base64Test.class);
      return suite;
    }
    addTest(suite,NativeFilterMatchingTest.class);
    addTest(suite,RolapConnectionTest.class);
    addTest(suite,FilteredIterableTest.class);
    addTest(suite,HighDimensionsTest.class);
    addTest(suite,IndexedValuesTest.class);
    addTest(suite,MemoryMonitorTest.class);
    addTest(suite,ObjectPoolTest.class);
    addTest(suite,Ssas2005CompatibilityTest.OldBehaviorTest.class);
    addTest(suite,DialectTest.class);
    addTest(suite,ResultComparatorTest.class,""String_Node_Str"");
    addTest(suite,DrillThroughTest.class);
    addTest(suite,ScenarioTest.class);
    addTest(suite,BasicQueryTest.class);
    addTest(suite,SegmentCacheTest.class);
    addTest(suite,CVBasicTest.class,""String_Node_Str"");
    addTest(suite,GrandTotalTest.class,""String_Node_Str"");
    addTest(suite,HangerDimensionTest.class,""String_Node_Str"");
    addTest(suite,MetricFilterTest.class,""String_Node_Str"");
    addTest(suite,MiscTest.class,""String_Node_Str"");
    addTest(suite,PredicateFilterTest.class,""String_Node_Str"");
    addTest(suite,SubTotalTest.class,""String_Node_Str"");
    addTest(suite,SummaryMetricPercentTest.class,""String_Node_Str"");
    addTest(suite,SummaryTest.class,""String_Node_Str"");
    addTest(suite,TopBottomTest.class,""String_Node_Str"");
    addTest(suite,OrderTest.class,""String_Node_Str"");
    addTest(suite,CacheControlTest.class);
    addTest(suite,MemberCacheControlTest.class);
    addTest(suite,FunctionTest.class);
    addTest(suite,CurrentDateMemberUdfTest.class);
    addTest(suite,PartialSortTest.class);
    addTest(suite,VbaTest.class);
    addTest(suite,ExcelTest.class);
    addTest(suite,HierarchyBugTest.class);
    addTest(suite,ScheduleTest.class);
    addTest(suite,UtilTestCase.class);
    addTest(suite,PartiallyOrderedSetTest.class);
    addTest(suite,Olap4jTest.class);
    addTest(suite,SortTest.class);
    if (isRunOnce()) {
      addTest(suite,TestAggregationManager.class);
    }
    addTest(suite,VirtualCubeTest.class);
    addTest(suite,ParameterTest.class);
    addTest(suite,AccessControlTest.class);
    addTest(suite,ParserTest.class);
    addTest(suite,CustomizedParserTest.class);
    addTest(suite,SolveOrderScopeIsolationTest.class);
    addTest(suite,ParentChildHierarchyTest.class);
    addTest(suite,Olap4jTckTest.class,""String_Node_Str"");
    addTest(suite,MondrianServerTest.class);
    addTest(suite,XmlaBasicTest.class);
    addTest(suite,XmlaMetaDataConstraintsTest.class);
    addTest(suite,XmlaErrorTest.class);
    addTest(suite,XmlaExcel2000Test.class);
    addTest(suite,XmlaExcelXPTest.class);
    addTest(suite,XmlaExcel2007Test.class);
    addTest(suite,XmlaCognosTest.class);
    addTest(suite,XmlaTabularTest.class);
    addTest(suite,XmlaTests.class);
    addTest(suite,DynamicDatasourceXmlaServletTest.class);
    addTest(suite,XmlaTest.class,""String_Node_Str"");
    if (isRunOnce()) {
      addTest(suite,TestCalculatedMembers.class);
    }
    addTest(suite,CompoundSlicerTest.class);
    addTest(suite,RaggedHierarchyTest.class);
    addTest(suite,NonEmptyPropertyForAllAxisTest.class);
    addTest(suite,InlineTableTest.class);
    addTest(suite,CompatibilityTest.class);
    addTest(suite,CaptionTest.class);
    addTest(suite,UdfTest.class);
    addTest(suite,NullValueTest.class);
    addTest(suite,NamedSetTest.class);
    addTest(suite,PropertiesTest.class);
    addTest(suite,MultipleHierarchyTest.class);
    addTest(suite,I18nTest.class);
    addTest(suite,FormatTest.class);
    addTest(suite,ParallelTest.class);
    addTest(suite,SchemaTest.class);
    addTest(suite,PerformanceTest.class);
    addTest(suite,GroupingSetQueryTest.class);
    addTest(suite,CmdRunnerTest.class);
    addTest(suite,DataSourceChangeListenerTest.class);
    addTest(suite,ModulosTest.class);
    addTest(suite,PrimeFinderTest.class);
    addTest(suite,CellKeyTest.class);
    addTest(suite,RolapAxisTest.class);
    addTest(suite,CrossJoinTest.class);
    if (Bug.BugMondrian503Fixed) {
      addTest(suite,RolapResultTest.class);
    }
    addTest(suite,ConstantCalcTest.class);
    addTest(suite,SharedDimensionTest.class);
    addTest(suite,CellPropertyTest.class);
    addTest(suite,QueryTest.class);
    addTest(suite,RolapSchemaReaderTest.class);
    addTest(suite,RolapCubeTest.class);
    addTest(suite,RolapStarTest.class);
    addTest(suite,NullMemberRepresentationTest.class);
    addTest(suite,IgnoreUnrelatedDimensionsTest.class);
    addTest(suite,IgnoreMeasureForNonJoiningDimensionInAggregationTest.class);
    addTest(suite,SetFunDefTest.class);
    addTest(suite,VisualTotalsTest.class);
    addTest(suite,AggregationOnDistinctCountMeasuresTest.class);
    addTest(suite,NonCollapsedAggTest.class);
    addTest(suite,BitKeyTest.class);
    addTest(suite,TypeTest.class);
    addTest(suite,SteelWheelsSchemaTest.class);
    addTest(suite,MultipleColsInTupleAggTest.class);
    addTest(suite,DynamicSchemaProcessorTest.class);
    addTest(suite,MonitorTest.class);
    addTest(suite,CodeComplianceTest.class);
    boolean testNonEmpty=isRunOnce();
    if (!MondrianProperties.instance().EnableNativeNonEmpty.get()) {
      testNonEmpty=false;
    }
    if (!MondrianProperties.instance().EnableNativeCrossJoin.get()) {
      testNonEmpty=false;
    }
    if (testNonEmpty) {
      addTest(suite,NonEmptyTest.class);
      addTest(suite,FilterTest.class);
      addTest(suite,NativizeSetFunDefTest.class);
    }
 else {
      logger.warn(""String_Node_Str"");
    }
    addTest(suite,FastBatchingCellReaderTest.class);
    addTest(suite,SqlQueryTest.class);
    if (MondrianProperties.instance().EnableNativeCrossJoin.get()) {
      addTest(suite,BatchedFillTest.class,""String_Node_Str"");
    }
 else {
      logger.warn(""String_Node_Str"");
    }
  }
  if (testName != null && !testName.equals(""String_Node_Str"")) {
    Pattern testPattern=Pattern.compile(testName);
    suite=copySuite(suite,testPattern);
  }
  String testInfo=testSuiteInfo.get(suite);
  if (testInfo != null && testInfo.length() > 0) {
    System.out.println(testInfo);
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  System.out.flush();
  return suite;
}","/** 
 * Creates a TestSuite to test the whole of mondrian. Methods with the signature <code>public static Test suite()</code> are recognized automatically by JUnit test-harnesses; see   {@link TestSuite}.
 * @return test suite
 * @throws Exception on error
 */
public static Test suite() throws Exception {
  MondrianProperties properties=MondrianProperties.instance();
  String testName=properties.TestName.get();
  String testClass=properties.TestClass.get();
  System.out.println(""String_Node_Str"" + testName);
  System.out.println(""String_Node_Str"" + testClass);
  System.out.println(""String_Node_Str"" + System.getProperty(""String_Node_Str""));
  TestSuite suite=new TestSuite();
  if (testClass != null && !testClass.equals(""String_Node_Str"")) {
    Class<? extends TestCase> clazz=(Class<? extends TestCase>)Class.forName(testClass);
    boolean matchTestMethods=false;
    if (Test.class.isAssignableFrom(clazz)) {
      Method[] methods=clazz.getMethods();
      for (int i=0; i < methods.length && !matchTestMethods; i++) {
        matchTestMethods=methods[i].getName().startsWith(""String_Node_Str"");
      }
    }
    if (matchTestMethods) {
      addTest(suite,clazz);
    }
 else {
      Method method=clazz.getMethod(""String_Node_Str"",new Class[0]);
      TestCase target;
      if (Modifier.isStatic(method.getModifiers())) {
        target=null;
      }
 else {
        target=clazz.newInstance();
      }
      Object o=method.invoke(target);
      addTest(suite,(Test)o,clazz.getName() + method.getName());
    }
  }
 else {
    if (RUN_OPTIONAL_TESTS) {
      addTest(suite,SegmentLoaderTest.class);
      addTest(suite,AggGenTest.class);
      addTest(suite,DefaultRuleTest.class);
      addTest(suite,SelectNotInGroupByTest.class);
      addTest(suite,CVConcurrentMdxTest.class);
      addTest(suite,CacheHitTest.class);
      addTest(suite,ConcurrentMdxTest.class);
      addTest(suite,MemHungryTest.class,""String_Node_Str"");
      addTest(suite,MultiDimTest.class,""String_Node_Str"");
      addTest(suite,MultiDimVCTest.class,""String_Node_Str"");
      addTest(suite,MultiLevelTest.class,""String_Node_Str"");
      addTest(suite,MultiLevelVCTest.class,""String_Node_Str"");
      addTest(suite,PartialCacheTest.class,""String_Node_Str"");
      addTest(suite,PartialCacheVCTest.class,""String_Node_Str"");
      addTest(suite,QueryAllTest.class,""String_Node_Str"");
      addTest(suite,QueryAllVCTest.class,""String_Node_Str"");
      addTest(suite,Base64Test.class);
      return suite;
    }
    addTest(suite,NativeFilterMatchingTest.class);
    addTest(suite,RolapConnectionTest.class);
    addTest(suite,FilteredIterableTest.class);
    addTest(suite,HighDimensionsTest.class);
    addTest(suite,IndexedValuesTest.class);
    addTest(suite,MemoryMonitorTest.class);
    addTest(suite,ObjectPoolTest.class);
    addTest(suite,Ssas2005CompatibilityTest.OldBehaviorTest.class);
    addTest(suite,DialectTest.class);
    addTest(suite,ResultComparatorTest.class,""String_Node_Str"");
    addTest(suite,DrillThroughTest.class);
    addTest(suite,ScenarioTest.class);
    addTest(suite,BasicQueryTest.class);
    addTest(suite,SegmentCacheTest.class);
    addTest(suite,CVBasicTest.class,""String_Node_Str"");
    addTest(suite,GrandTotalTest.class,""String_Node_Str"");
    addTest(suite,HangerDimensionTest.class,""String_Node_Str"");
    addTest(suite,MetricFilterTest.class,""String_Node_Str"");
    addTest(suite,MiscTest.class,""String_Node_Str"");
    addTest(suite,PredicateFilterTest.class,""String_Node_Str"");
    addTest(suite,SubTotalTest.class,""String_Node_Str"");
    addTest(suite,SummaryMetricPercentTest.class,""String_Node_Str"");
    addTest(suite,SummaryTest.class,""String_Node_Str"");
    addTest(suite,TopBottomTest.class,""String_Node_Str"");
    addTest(suite,OrderTest.class,""String_Node_Str"");
    addTest(suite,CacheControlTest.class);
    addTest(suite,MemberCacheControlTest.class);
    addTest(suite,FunctionTest.class);
    addTest(suite,CurrentDateMemberUdfTest.class);
    addTest(suite,PartialSortTest.class);
    addTest(suite,VbaTest.class);
    addTest(suite,ExcelTest.class);
    addTest(suite,HierarchyBugTest.class);
    addTest(suite,ScheduleTest.class);
    addTest(suite,UtilTestCase.class);
    addTest(suite,PartiallyOrderedSetTest.class);
    addTest(suite,Olap4jTest.class);
    addTest(suite,SortTest.class);
    if (isRunOnce()) {
      addTest(suite,TestAggregationManager.class);
    }
    addTest(suite,VirtualCubeTest.class);
    addTest(suite,ParameterTest.class);
    addTest(suite,AccessControlTest.class);
    addTest(suite,ParserTest.class);
    addTest(suite,CustomizedParserTest.class);
    addTest(suite,SolveOrderScopeIsolationTest.class);
    addTest(suite,ParentChildHierarchyTest.class);
    addTest(suite,Olap4jTckTest.class,""String_Node_Str"");
    addTest(suite,MondrianServerTest.class);
    addTest(suite,XmlaBasicTest.class);
    addTest(suite,XmlaMetaDataConstraintsTest.class);
    addTest(suite,XmlaErrorTest.class);
    addTest(suite,XmlaExcel2000Test.class);
    addTest(suite,XmlaExcelXPTest.class);
    addTest(suite,XmlaExcel2007Test.class);
    addTest(suite,XmlaCognosTest.class);
    addTest(suite,XmlaTabularTest.class);
    addTest(suite,XmlaTests.class);
    addTest(suite,DynamicDatasourceXmlaServletTest.class);
    addTest(suite,XmlaTest.class,""String_Node_Str"");
    if (isRunOnce()) {
      addTest(suite,TestCalculatedMembers.class);
    }
    addTest(suite,CompoundSlicerTest.class);
    addTest(suite,RaggedHierarchyTest.class);
    addTest(suite,NonEmptyPropertyForAllAxisTest.class);
    addTest(suite,InlineTableTest.class);
    addTest(suite,CompatibilityTest.class);
    addTest(suite,CaptionTest.class);
    addTest(suite,UdfTest.class);
    addTest(suite,NullValueTest.class);
    addTest(suite,NamedSetTest.class);
    addTest(suite,PropertiesTest.class);
    addTest(suite,MultipleHierarchyTest.class);
    addTest(suite,I18nTest.class);
    addTest(suite,FormatTest.class);
    addTest(suite,ParallelTest.class);
    addTest(suite,SchemaTest.class);
    addTest(suite,PerformanceTest.class);
    addTest(suite,GroupingSetQueryTest.class);
    addTest(suite,CmdRunnerTest.class);
    addTest(suite,DataSourceChangeListenerTest.class);
    addTest(suite,ModulosTest.class);
    addTest(suite,PrimeFinderTest.class);
    addTest(suite,CellKeyTest.class);
    addTest(suite,RolapAxisTest.class);
    addTest(suite,CrossJoinTest.class);
    if (Bug.BugMondrian503Fixed) {
      addTest(suite,RolapResultTest.class);
    }
    addTest(suite,ConstantCalcTest.class);
    addTest(suite,SharedDimensionTest.class);
    addTest(suite,CellPropertyTest.class);
    addTest(suite,QueryTest.class);
    addTest(suite,RolapSchemaReaderTest.class);
    addTest(suite,RolapCubeTest.class);
    addTest(suite,RolapStarTest.class);
    addTest(suite,RolapSchemaPoolTest.class);
    addTest(suite,NullMemberRepresentationTest.class);
    addTest(suite,IgnoreUnrelatedDimensionsTest.class);
    addTest(suite,IgnoreMeasureForNonJoiningDimensionInAggregationTest.class);
    addTest(suite,SetFunDefTest.class);
    addTest(suite,VisualTotalsTest.class);
    addTest(suite,AggregationOnDistinctCountMeasuresTest.class);
    addTest(suite,NonCollapsedAggTest.class);
    addTest(suite,BitKeyTest.class);
    addTest(suite,TypeTest.class);
    addTest(suite,SteelWheelsSchemaTest.class);
    addTest(suite,MultipleColsInTupleAggTest.class);
    addTest(suite,DynamicSchemaProcessorTest.class);
    addTest(suite,MonitorTest.class);
    addTest(suite,CodeComplianceTest.class);
    boolean testNonEmpty=isRunOnce();
    if (!MondrianProperties.instance().EnableNativeNonEmpty.get()) {
      testNonEmpty=false;
    }
    if (!MondrianProperties.instance().EnableNativeCrossJoin.get()) {
      testNonEmpty=false;
    }
    if (testNonEmpty) {
      addTest(suite,NonEmptyTest.class);
      addTest(suite,FilterTest.class);
      addTest(suite,NativizeSetFunDefTest.class);
    }
 else {
      logger.warn(""String_Node_Str"");
    }
    addTest(suite,FastBatchingCellReaderTest.class);
    addTest(suite,SqlQueryTest.class);
    if (MondrianProperties.instance().EnableNativeCrossJoin.get()) {
      addTest(suite,BatchedFillTest.class,""String_Node_Str"");
    }
 else {
      logger.warn(""String_Node_Str"");
    }
  }
  if (testName != null && !testName.equals(""String_Node_Str"")) {
    Pattern testPattern=Pattern.compile(testName);
    suite=copySuite(suite,testPattern);
  }
  String testInfo=testSuiteInfo.get(suite);
  if (testInfo != null && testInfo.length() > 0) {
    System.out.println(testInfo);
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  System.out.flush();
  return suite;
}",0.9973395026026604
50900,"public Component getTableCellEditorComponent(final JTable table,Object value,boolean isSelected,final int row,final int column){
  PropertyTableModel tableModel=(PropertyTableModel)table.getModel();
  Class<?> parentClassz=null;
  if (tableModel.getParentTarget() != null) {
    parentClassz=tableModel.getParentTarget().getClass();
  }
  Class<?> targetClassz=tableModel.target.getClass();
  String propertyName=tableModel.getRowName(row);
  String selectedFactTable=tableModel.getFactTable();
  String selectedFactTableSchema=tableModel.getFactTableSchema();
  listEditorValue=null;
  Object parent=this.getParentObject();
  MondrianGuiDef.RelationOrJoin currentRelation=getRelation(table,row,column);
  boolean nonTableRelation=currentRelation != null && !(currentRelation instanceof MondrianGuiDef.Table || currentRelation instanceof MondrianGuiDef.Join);
  if (targetClassz == MondrianGuiDef.UserDefinedFunction.class && propertyName.equals(""String_Node_Str"")) {
    List<String> udfs=getUdfs();
    ComboBoxModel cAlludfs=new DefaultComboBoxModel(new Vector<String>(udfs));
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAlludfs);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Measure.class && propertyName.equals(""String_Node_Str"")) {
    List<String> formatStrs=getFormatStrings();
    ComboBoxModel cAllformatStrs=new DefaultComboBoxModel(new Vector<String>(formatStrs));
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllformatStrs);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Measure.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Measure._aggregator_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Measure.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Measure._datatype_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Parameter.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Parameter._type_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.SQL.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.SQL._dialect_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Level._hideMemberIf_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Level._levelType_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Level._type_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Level._internalType_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Dimension.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Dimension._type_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.DimensionUsage.class && propertyName.equals(""String_Node_Str"")) {
    List<String> source=getSource();
    ComboBoxModel cAllsource=new DefaultComboBoxModel(new Vector<String>(source));
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllsource);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if ((tableModel.target instanceof MondrianGuiDef.Grant || tableModel.target instanceof MondrianGuiDef.MemberGrant) && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    ComboBoxModel cAccess=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
    if (targetClassz == MondrianGuiDef.SchemaGrant.class) {
      cAccess=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    }
 else     if (targetClassz == MondrianGuiDef.CubeGrant.class || targetClassz == MondrianGuiDef.DimensionGrant.class || targetClassz == MondrianGuiDef.MemberGrant.class) {
      cAccess=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    }
 else     if (targetClassz == MondrianGuiDef.HierarchyGrant.class || targetClassz == MondrianGuiDef.DimensionGrant.class) {
      cAccess=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    }
    listEditor.setModel(cAccess);
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if ((targetClassz == MondrianGuiDef.DimensionGrant.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.HierarchyGrant.class && propertyName.equals(""String_Node_Str""))) {
    List<String> source=getHierarchies();
    ComboBoxModel cAllsource=new DefaultComboBoxModel(new Vector<String>(source));
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllsource);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if ((targetClassz == MondrianGuiDef.HierarchyGrant.class && (propertyName.equals(""String_Node_Str"") || propertyName.equals(""String_Node_Str"")))) {
    List<String> source=getLevels(((MondrianGuiDef.HierarchyGrant)tableModel.target).hierarchy);
    ComboBoxModel cAllsource=new DefaultComboBoxModel(new Vector<String>(source));
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllsource);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if (((targetClassz == MondrianGuiDef.VirtualCubeDimension.class || targetClassz == MondrianGuiDef.VirtualCubeMeasure.class) && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.CubeGrant.class && propertyName.equals(""String_Node_Str""))) {
    List<String> source=getCubes();
    ComboBoxModel cAllsource=new DefaultComboBoxModel(new Vector<String>(source));
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllsource);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if ((targetClassz == MondrianGuiDef.Dimension.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.DimensionUsage.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.Measure.class && propertyName.equals(""String_Node_Str""))) {
    Vector<String> fks=new Vector<String>(jdbcMetaData.getFactTableFKs(selectedFactTableSchema,selectedFactTable));
    fks.add(0,getResourceConverter().getString(""String_Node_Str"",""String_Node_Str""));
    Vector<String> allcols=new Vector<String>(jdbcMetaData.getAllColumns(selectedFactTableSchema,selectedFactTable));
    ComboBoxModel cFks=new DefaultComboBoxModel(fks);
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    if ((fks.size() > 1) && propertyName.equals(""String_Node_Str"")) {
      allcols.add(0,getResourceConverter().getString(""String_Node_Str"",""String_Node_Str""));
      ComboBoxModel cAllcols=new DefaultComboBoxModel(allcols);
      listEditor.setModel(cFks);
      selOptions=cFks;
      allOptions=cAllcols;
      listEditor.addActionListener(al);
    }
 else {
      ComboBoxModel cAllcols=new DefaultComboBoxModel(allcols);
      listEditor.setModel(cAllcols);
    }
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Hierarchy.class && propertyName.equals(""String_Node_Str"")) {
    MondrianGuiDef.Hierarchy hProps=(MondrianGuiDef.Hierarchy)tableModel.getValue();
    String pkTable=hProps.primaryKeyTable;
    String schemaName=null;
    String pk=""String_Node_Str"";
    List<String> allcols;
    MondrianGuiDef.RelationOrJoin relation=hProps.relation;
    if (relation instanceof MondrianGuiDef.Table) {
      pkTable=((MondrianGuiDef.Table)relation).name;
      schemaName=((MondrianGuiDef.Table)relation).schema;
      pk=jdbcMetaData.getTablePK(schemaName,pkTable);
    }
 else     if (relation instanceof MondrianGuiDef.Join) {
      String[] schemaAndTable=SchemaExplorer.getTableNameForAlias(hProps.relation,pkTable);
      schemaName=schemaAndTable[0];
      pkTable=schemaAndTable[1];
    }
    if (relation instanceof MondrianGuiDef.Table || relation instanceof MondrianGuiDef.Join) {
      allcols=jdbcMetaData.getAllColumns(schemaName,pkTable);
      pk=jdbcMetaData.getTablePK(schemaName,pkTable);
    }
 else {
      allcols=Collections.emptyList();
    }
    ComboBoxModel cAllcols=new DefaultComboBoxModel(new Vector<String>(allcols));
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllcols);
    if (value == null || ((String)value).equals(""String_Node_Str"")) {
      listEditor.setSelectedItem(pk);
    }
 else {
      listEditor.setSelectedItem((String)value);
      listEditorValue=(String)value;
    }
    activeEditor=listEditor;
  }
 else   if ((targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.Closure.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.Closure.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.Property.class && propertyName.equals(""String_Node_Str""))) {
    MondrianGuiDef.Level lProps;
    if (targetClassz == MondrianGuiDef.Level.class) {
      lProps=(MondrianGuiDef.Level)tableModel.getValue();
    }
 else {
      lProps=(MondrianGuiDef.Level)this.getParentObject();
    }
    String schemaName=null;
    String lTable=lProps.table;
    List<String> allcols;
    if (targetClassz == MondrianGuiDef.Level.class && parent != null) {
      if (parent instanceof MondrianGuiDef.Hierarchy) {
        MondrianGuiDef.RelationOrJoin relation=((MondrianGuiDef.Hierarchy)parent).relation;
        if (relation instanceof MondrianGuiDef.Table) {
          lTable=((MondrianGuiDef.Table)relation).name;
          schemaName=((MondrianGuiDef.Table)relation).schema;
        }
 else         if (relation instanceof MondrianGuiDef.Join) {
          String[] schemaAndTable=SchemaExplorer.getTableNameForAlias(relation,lTable);
          schemaName=schemaAndTable[0];
          lTable=schemaAndTable[1];
        }
      }
    }
    if (lTable != null) {
      allcols=jdbcMetaData.getAllColumns(schemaName,lTable);
    }
 else {
      allcols=Collections.emptyList();
    }
    ComboBoxModel cAllcols=new DefaultComboBoxModel(new Vector<String>(allcols));
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllcols);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Property.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Property._type_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if ((targetClassz == MondrianGuiDef.AggFactCount.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.AggIgnoreColumn.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.AggLevel.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.AggMeasure.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.AggForeignKey.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.AggForeignKey.class && propertyName.equals(""String_Node_Str""))) {
    List<String> allcols=jdbcMetaData.getAllColumns(null,null);
    ComboBoxModel cAllcols=new DefaultComboBoxModel(new Vector<String>(allcols));
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllcols);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Table.class && propertyName.equals(""String_Node_Str"")) {
    List<String> allschemas=jdbcMetaData.getAllSchemas();
    ComboBoxModel cAllschemas=new DefaultComboBoxModel(new Vector<String>(allschemas));
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllschemas);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if (currentRelation != null && nonTableRelation && ((targetClassz == MondrianGuiDef.Hierarchy.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str"")))) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    activeEditor=listEditor;
  }
 else   if ((targetClassz == MondrianGuiDef.Table.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.Hierarchy.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str""))) {
    String schema=""String_Node_Str"";
    if (targetClassz == MondrianGuiDef.Table.class) {
      MondrianGuiDef.Table tProps=(MondrianGuiDef.Table)tableModel.getValue();
      schema=tProps.schema;
    }
    Vector<String> factTables=new Vector<String>(jdbcMetaData.getFactTables(schema));
    Vector<String> allTablesMinusFact=new Vector<String>(jdbcMetaData.getAllTables(schema,selectedFactTable));
    Vector<String> allTables=new Vector<String>(jdbcMetaData.getAllTables(schema));
    Vector<String> dimeTables=new Vector<String>(jdbcMetaData.getDimensionTables(schema,selectedFactTable));
    ComboBoxModel cFactTables=new DefaultComboBoxModel(factTables);
    ComboBoxModel cAllTables=new DefaultComboBoxModel((allTablesMinusFact.size() > 0) ? allTablesMinusFact : allTables);
    ComboBoxModel cDimeTables=new DefaultComboBoxModel(dimeTables);
    if (targetClassz == MondrianGuiDef.Level.class || targetClassz == MondrianGuiDef.Hierarchy.class) {
      MondrianGuiDef.RelationOrJoin relation=null;
      if (parent != null && parent instanceof MondrianGuiDef.Hierarchy) {
        relation=((MondrianGuiDef.Hierarchy)parent).relation;
      }
 else {
        relation=((MondrianGuiDef.Hierarchy)tableModel.target).relation;
      }
      if (relation instanceof MondrianGuiDef.Join) {
        TreeSet<String> joinTables=new TreeSet<String>();
        SchemaExplorer.getTableNamesForJoin(relation,joinTables);
        cAllTables=new DefaultComboBoxModel(new Vector<String>(joinTables));
      }
    }
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllTables);
    allOptions=cAllTables;
    boolean toggleModel=false;
    if (parentClassz == MondrianGuiDef.Cube.class) {
      cAllTables=new DefaultComboBoxModel(allTables);
      allOptions=cAllTables;
      if (factTables.size() > 0) {
        ((DefaultComboBoxModel)cFactTables).insertElementAt(workbench.getResourceConverter().getString(""String_Node_Str"",""String_Node_Str""),0);
        ((DefaultComboBoxModel)cAllTables).insertElementAt(workbench.getResourceConverter().getString(""String_Node_Str"",""String_Node_Str""),0);
        listEditor.setModel(cFactTables);
        selOptions=cFactTables;
        toggleModel=true;
      }
    }
 else {
      if (dimeTables.size() > 0) {
        ((DefaultComboBoxModel)cDimeTables).insertElementAt(workbench.getResourceConverter().getString(""String_Node_Str"",""String_Node_Str""),0);
        ((DefaultComboBoxModel)cAllTables).insertElementAt(workbench.getResourceConverter().getString(""String_Node_Str"",""String_Node_Str""),0);
        listEditor.setModel(cDimeTables);
        selOptions=cDimeTables;
        toggleModel=true;
      }
    }
    if (toggleModel) {
      listEditor.addActionListener(al);
    }
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
    if ((targetClassz == MondrianGuiDef.Level.class && propertyName.equals(SchemaExplorer.DEF_LEVEL[1]) && parent != null) || (targetClassz == MondrianGuiDef.Hierarchy.class && propertyName.equals(SchemaExplorer.DEF_HIERARCHY[7]) && parent != null)) {
      MondrianGuiDef.RelationOrJoin relation=null;
      if (parent instanceof MondrianGuiDef.Hierarchy) {
        relation=((MondrianGuiDef.Hierarchy)parent).relation;
      }
 else       if (parent instanceof MondrianGuiDef.Dimension) {
        relation=((MondrianGuiDef.Hierarchy)tableModel.target).relation;
      }
      if (relation instanceof MondrianGuiDef.Table) {
        activeEditor=stringEditor;
        stringEditor.setText((String)value);
      }
    }
  }
 else   if (propertyName.equals(""String_Node_Str"")) {
    try {
      cdataTextArea.read(new StringReader((String)value),null);
    }
 catch (    Exception ex) {
    }
    activeEditor=jScrollPaneCDATA;
  }
 else   if (value instanceof String) {
    activeEditor=stringEditor;
    stringEditor.setText((String)value);
  }
 else   if (value instanceof Boolean) {
    activeEditor=booleanEditor;
    booleanEditor.setSelected((Boolean)value);
  }
 else   if (value instanceof Integer) {
    activeEditor=integerEditor;
    integerEditor.setText((String)value);
  }
 else   if (value == null) {
    value=""String_Node_Str"";
    activeEditor=stringEditor;
    stringEditor.setText((String)value);
  }
 else   if (value.getClass() == MondrianGuiDef.Join.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench);
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_JOIN);
    tableEditor.setModel(ptm);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.NameExpression.class) {
    return null;
  }
 else   if (value.getClass() == MondrianGuiDef.RelationOrJoin.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench);
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_RELATION);
    tableEditor.setModel(ptm);
    activeEditor=tableEditor;
    return null;
  }
 else   if (value.getClass() == MondrianGuiDef.OrdinalExpression.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench);
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,((MondrianGuiDef.OrdinalExpression)value).expressions[0],SchemaExplorer.DEF_SQL);
    ptm.setParentTarget(((PropertyTableModel)table.getModel()).target);
    tableEditor.setModel(ptm);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.CaptionExpression.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench);
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,((MondrianGuiDef.CaptionExpression)value).expressions[0],SchemaExplorer.DEF_SQL);
    ptm.setParentTarget(((PropertyTableModel)table.getModel()).target);
    tableEditor.setModel(ptm);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.Formula.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench,jdbcMetaData);
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_FORMULA);
    tableEditor.setModel(ptm);
    tableEditor.getColumnModel().getColumn(0).setMaxWidth(100);
    tableEditor.getColumnModel().getColumn(0).setMinWidth(100);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.CalculatedMemberProperty.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench,jdbcMetaData);
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_CALCULATED_MEMBER_PROPERTY);
    tableEditor.setModel(ptm);
    tableEditor.getColumnModel().getColumn(0).setMaxWidth(100);
    tableEditor.getColumnModel().getColumn(0).setMinWidth(100);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.Table.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench,jdbcMetaData);
    for (int i=listeners.size() - 1; i >= 0; i--) {
      spce.addCellEditorListener(listeners.get(i));
    }
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_TABLE);
    ptm.setFactTable(selectedFactTable);
    if (targetClassz == MondrianGuiDef.Cube.class) {
      ptm.setParentTarget(((PropertyTableModel)table.getModel()).target);
    }
    tableEditor.setModel(ptm);
    tableEditor.getColumnModel().getColumn(0).setMaxWidth(100);
    tableEditor.getColumnModel().getColumn(0).setMinWidth(100);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.AggFactCount.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench,jdbcMetaData);
    for (int i=listeners.size() - 1; i >= 0; i--) {
      spce.addCellEditorListener(listeners.get(i));
    }
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_AGG_FACT_COUNT);
    ptm.setFactTable(selectedFactTable);
    tableEditor.setModel(ptm);
    tableEditor.getColumnModel().getColumn(0).setMaxWidth(100);
    tableEditor.getColumnModel().getColumn(0).setMinWidth(100);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.Closure.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench,jdbcMetaData);
    for (int i=listeners.size() - 1; i >= 0; i--) {
      spce.addCellEditorListener(listeners.get(i));
    }
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_CLOSURE);
    ptm.setFactTable(selectedFactTable);
    if (targetClassz == MondrianGuiDef.Level.class) {
      ptm.setParentTarget(((PropertyTableModel)table.getModel()).target);
    }
    tableEditor.setModel(ptm);
    tableEditor.getColumnModel().getColumn(0).setMaxWidth(100);
    tableEditor.getColumnModel().getColumn(0).setMinWidth(100);
    spcr.setTableRendererHeight(tableEditor,null);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.Property.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench);
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_PROPERTY);
    tableEditor.setModel(ptm);
    activeEditor=tableEditor;
  }
 else {
    value=""String_Node_Str"";
    activeEditor=stringEditor;
    stringEditor.setText((String)value);
  }
  activeEditor.setVisible(true);
  setOriginalValue();
  table.changeSelection(row,column,false,false);
  activeEditor.setBackground(new java.awt.Color(224,249,255));
  activeEditor.requestFocusInWindow();
  return activeEditor;
}","public Component getTableCellEditorComponent(final JTable table,Object value,boolean isSelected,final int row,final int column){
  PropertyTableModel tableModel=(PropertyTableModel)table.getModel();
  Class<?> parentClassz=null;
  if (tableModel.getParentTarget() != null) {
    parentClassz=tableModel.getParentTarget().getClass();
  }
  Class<?> targetClassz=tableModel.target.getClass();
  String propertyName=tableModel.getRowName(row);
  String selectedFactTable=tableModel.getFactTable();
  String selectedFactTableSchema=tableModel.getFactTableSchema();
  listEditorValue=null;
  Object parent=this.getParentObject();
  MondrianGuiDef.RelationOrJoin currentRelation=getRelation(table,row,column);
  boolean nonTableRelation=currentRelation != null && !(currentRelation instanceof MondrianGuiDef.Table || currentRelation instanceof MondrianGuiDef.Join);
  if (targetClassz == MondrianGuiDef.UserDefinedFunction.class && propertyName.equals(""String_Node_Str"")) {
    List<String> udfs=getUdfs();
    ComboBoxModel cAlludfs=new DefaultComboBoxModel(new Vector<String>(udfs));
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAlludfs);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Measure.class && propertyName.equals(""String_Node_Str"")) {
    List<String> formatStrs=getFormatStrings();
    ComboBoxModel cAllformatStrs=new DefaultComboBoxModel(new Vector<String>(formatStrs));
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllformatStrs);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Measure.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Measure._aggregator_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Measure.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Measure._datatype_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Parameter.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Parameter._type_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.SQL.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.SQL._dialect_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Level._hideMemberIf_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Level._levelType_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Level._type_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Level._internalType_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Dimension.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Dimension._type_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.DimensionUsage.class && propertyName.equals(""String_Node_Str"")) {
    List<String> source=getSource();
    ComboBoxModel cAllsource=new DefaultComboBoxModel(new Vector<String>(source));
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllsource);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if ((tableModel.target instanceof MondrianGuiDef.Grant || tableModel.target instanceof MondrianGuiDef.MemberGrant) && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    ComboBoxModel cAccess=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
    if (targetClassz == MondrianGuiDef.SchemaGrant.class) {
      cAccess=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    }
 else     if (targetClassz == MondrianGuiDef.CubeGrant.class || targetClassz == MondrianGuiDef.DimensionGrant.class || targetClassz == MondrianGuiDef.MemberGrant.class) {
      cAccess=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    }
 else     if (targetClassz == MondrianGuiDef.HierarchyGrant.class || targetClassz == MondrianGuiDef.DimensionGrant.class) {
      cAccess=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    }
    listEditor.setModel(cAccess);
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.DimensionGrant.class && propertyName.equals(""String_Node_Str"")) {
    List<String> source=getDimensions();
    ComboBoxModel cAllsource=new DefaultComboBoxModel(new Vector<String>(source));
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllsource);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.HierarchyGrant.class && propertyName.equals(""String_Node_Str"")) {
    List<String> source=getHierarchies();
    ComboBoxModel cAllsource=new DefaultComboBoxModel(new Vector<String>(source));
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllsource);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if ((targetClassz == MondrianGuiDef.HierarchyGrant.class && (propertyName.equals(""String_Node_Str"") || propertyName.equals(""String_Node_Str"")))) {
    List<String> source=getLevels(((MondrianGuiDef.HierarchyGrant)tableModel.target).hierarchy);
    ComboBoxModel cAllsource=new DefaultComboBoxModel(new Vector<String>(source));
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllsource);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if (((targetClassz == MondrianGuiDef.VirtualCubeDimension.class || targetClassz == MondrianGuiDef.VirtualCubeMeasure.class) && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.CubeGrant.class && propertyName.equals(""String_Node_Str""))) {
    List<String> source=getCubes();
    ComboBoxModel cAllsource=new DefaultComboBoxModel(new Vector<String>(source));
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllsource);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if ((targetClassz == MondrianGuiDef.Dimension.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.DimensionUsage.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.Measure.class && propertyName.equals(""String_Node_Str""))) {
    Vector<String> fks=new Vector<String>(jdbcMetaData.getFactTableFKs(selectedFactTableSchema,selectedFactTable));
    fks.add(0,getResourceConverter().getString(""String_Node_Str"",""String_Node_Str""));
    Vector<String> allcols=new Vector<String>(jdbcMetaData.getAllColumns(selectedFactTableSchema,selectedFactTable));
    ComboBoxModel cFks=new DefaultComboBoxModel(fks);
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    if ((fks.size() > 1) && propertyName.equals(""String_Node_Str"")) {
      allcols.add(0,getResourceConverter().getString(""String_Node_Str"",""String_Node_Str""));
      ComboBoxModel cAllcols=new DefaultComboBoxModel(allcols);
      listEditor.setModel(cFks);
      selOptions=cFks;
      allOptions=cAllcols;
      listEditor.addActionListener(al);
    }
 else {
      ComboBoxModel cAllcols=new DefaultComboBoxModel(allcols);
      listEditor.setModel(cAllcols);
    }
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Hierarchy.class && propertyName.equals(""String_Node_Str"")) {
    MondrianGuiDef.Hierarchy hProps=(MondrianGuiDef.Hierarchy)tableModel.getValue();
    String pkTable=hProps.primaryKeyTable;
    String schemaName=null;
    String pk=""String_Node_Str"";
    List<String> allcols;
    MondrianGuiDef.RelationOrJoin relation=hProps.relation;
    if (relation instanceof MondrianGuiDef.Table) {
      pkTable=((MondrianGuiDef.Table)relation).name;
      schemaName=((MondrianGuiDef.Table)relation).schema;
      pk=jdbcMetaData.getTablePK(schemaName,pkTable);
    }
 else     if (relation instanceof MondrianGuiDef.Join) {
      String[] schemaAndTable=SchemaExplorer.getTableNameForAlias(hProps.relation,pkTable);
      schemaName=schemaAndTable[0];
      pkTable=schemaAndTable[1];
    }
    if (relation instanceof MondrianGuiDef.Table || relation instanceof MondrianGuiDef.Join) {
      allcols=jdbcMetaData.getAllColumns(schemaName,pkTable);
      pk=jdbcMetaData.getTablePK(schemaName,pkTable);
    }
 else {
      allcols=Collections.emptyList();
    }
    ComboBoxModel cAllcols=new DefaultComboBoxModel(new Vector<String>(allcols));
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllcols);
    if (value == null || ((String)value).equals(""String_Node_Str"")) {
      listEditor.setSelectedItem(pk);
    }
 else {
      listEditor.setSelectedItem((String)value);
      listEditorValue=(String)value;
    }
    activeEditor=listEditor;
  }
 else   if ((targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.Closure.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.Closure.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.Property.class && propertyName.equals(""String_Node_Str""))) {
    MondrianGuiDef.Level lProps;
    if (targetClassz == MondrianGuiDef.Level.class) {
      lProps=(MondrianGuiDef.Level)tableModel.getValue();
    }
 else {
      lProps=(MondrianGuiDef.Level)this.getParentObject();
    }
    String schemaName=null;
    String lTable=lProps.table;
    List<String> allcols;
    if (targetClassz == MondrianGuiDef.Level.class && parent != null) {
      if (parent instanceof MondrianGuiDef.Hierarchy) {
        MondrianGuiDef.RelationOrJoin relation=((MondrianGuiDef.Hierarchy)parent).relation;
        if (relation instanceof MondrianGuiDef.Table) {
          lTable=((MondrianGuiDef.Table)relation).name;
          schemaName=((MondrianGuiDef.Table)relation).schema;
        }
 else         if (relation instanceof MondrianGuiDef.Join) {
          String[] schemaAndTable=SchemaExplorer.getTableNameForAlias(relation,lTable);
          schemaName=schemaAndTable[0];
          lTable=schemaAndTable[1];
        }
      }
    }
    if (lTable != null) {
      allcols=jdbcMetaData.getAllColumns(schemaName,lTable);
    }
 else {
      allcols=Collections.emptyList();
    }
    ComboBoxModel cAllcols=new DefaultComboBoxModel(new Vector<String>(allcols));
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllcols);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Property.class && propertyName.equals(""String_Node_Str"")) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(new DefaultComboBoxModel(MondrianGuiDef.Property._type_values));
    listEditor.setSelectedItem((String)value);
    activeEditor=listEditor;
  }
 else   if ((targetClassz == MondrianGuiDef.AggFactCount.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.AggIgnoreColumn.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.AggLevel.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.AggMeasure.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.AggForeignKey.class && propertyName.equals(""String_Node_Str""))|| (targetClassz == MondrianGuiDef.AggForeignKey.class && propertyName.equals(""String_Node_Str""))) {
    List<String> allcols=jdbcMetaData.getAllColumns(null,null);
    ComboBoxModel cAllcols=new DefaultComboBoxModel(new Vector<String>(allcols));
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllcols);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if (targetClassz == MondrianGuiDef.Table.class && propertyName.equals(""String_Node_Str"")) {
    List<String> allschemas=jdbcMetaData.getAllSchemas();
    ComboBoxModel cAllschemas=new DefaultComboBoxModel(new Vector<String>(allschemas));
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllschemas);
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
  }
 else   if (currentRelation != null && nonTableRelation && ((targetClassz == MondrianGuiDef.Hierarchy.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str"")))) {
    listEditor.setEditable(false);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    activeEditor=listEditor;
  }
 else   if ((targetClassz == MondrianGuiDef.Table.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.Hierarchy.class && propertyName.equals(""String_Node_Str"")) || (targetClassz == MondrianGuiDef.Level.class && propertyName.equals(""String_Node_Str""))) {
    String schema=""String_Node_Str"";
    if (targetClassz == MondrianGuiDef.Table.class) {
      MondrianGuiDef.Table tProps=(MondrianGuiDef.Table)tableModel.getValue();
      schema=tProps.schema;
    }
    Vector<String> factTables=new Vector<String>(jdbcMetaData.getFactTables(schema));
    Vector<String> allTablesMinusFact=new Vector<String>(jdbcMetaData.getAllTables(schema,selectedFactTable));
    Vector<String> allTables=new Vector<String>(jdbcMetaData.getAllTables(schema));
    Vector<String> dimeTables=new Vector<String>(jdbcMetaData.getDimensionTables(schema,selectedFactTable));
    ComboBoxModel cFactTables=new DefaultComboBoxModel(factTables);
    ComboBoxModel cAllTables=new DefaultComboBoxModel((allTablesMinusFact.size() > 0) ? allTablesMinusFact : allTables);
    ComboBoxModel cDimeTables=new DefaultComboBoxModel(dimeTables);
    if (targetClassz == MondrianGuiDef.Level.class || targetClassz == MondrianGuiDef.Hierarchy.class) {
      MondrianGuiDef.RelationOrJoin relation=null;
      if (parent != null && parent instanceof MondrianGuiDef.Hierarchy) {
        relation=((MondrianGuiDef.Hierarchy)parent).relation;
      }
 else {
        relation=((MondrianGuiDef.Hierarchy)tableModel.target).relation;
      }
      if (relation instanceof MondrianGuiDef.Join) {
        TreeSet<String> joinTables=new TreeSet<String>();
        SchemaExplorer.getTableNamesForJoin(relation,joinTables);
        cAllTables=new DefaultComboBoxModel(new Vector<String>(joinTables));
      }
    }
    listEditor.setEditable(true);
    listEditor.setToolTipText(null);
    listEditor.removeActionListener(al);
    listEditor.setModel(cAllTables);
    allOptions=cAllTables;
    boolean toggleModel=false;
    if (parentClassz == MondrianGuiDef.Cube.class) {
      cAllTables=new DefaultComboBoxModel(allTables);
      allOptions=cAllTables;
      if (factTables.size() > 0) {
        ((DefaultComboBoxModel)cFactTables).insertElementAt(workbench.getResourceConverter().getString(""String_Node_Str"",""String_Node_Str""),0);
        ((DefaultComboBoxModel)cAllTables).insertElementAt(workbench.getResourceConverter().getString(""String_Node_Str"",""String_Node_Str""),0);
        listEditor.setModel(cFactTables);
        selOptions=cFactTables;
        toggleModel=true;
      }
    }
 else {
      if (dimeTables.size() > 0) {
        ((DefaultComboBoxModel)cDimeTables).insertElementAt(workbench.getResourceConverter().getString(""String_Node_Str"",""String_Node_Str""),0);
        ((DefaultComboBoxModel)cAllTables).insertElementAt(workbench.getResourceConverter().getString(""String_Node_Str"",""String_Node_Str""),0);
        listEditor.setModel(cDimeTables);
        selOptions=cDimeTables;
        toggleModel=true;
      }
    }
    if (toggleModel) {
      listEditor.addActionListener(al);
    }
    listEditor.setSelectedItem((String)value);
    listEditorValue=(String)value;
    activeEditor=listEditor;
    if ((targetClassz == MondrianGuiDef.Level.class && propertyName.equals(SchemaExplorer.DEF_LEVEL[1]) && parent != null) || (targetClassz == MondrianGuiDef.Hierarchy.class && propertyName.equals(SchemaExplorer.DEF_HIERARCHY[7]) && parent != null)) {
      MondrianGuiDef.RelationOrJoin relation=null;
      if (parent instanceof MondrianGuiDef.Hierarchy) {
        relation=((MondrianGuiDef.Hierarchy)parent).relation;
      }
 else       if (parent instanceof MondrianGuiDef.Dimension) {
        relation=((MondrianGuiDef.Hierarchy)tableModel.target).relation;
      }
      if (relation instanceof MondrianGuiDef.Table) {
        activeEditor=stringEditor;
        stringEditor.setText((String)value);
      }
    }
  }
 else   if (propertyName.equals(""String_Node_Str"")) {
    try {
      cdataTextArea.read(new StringReader((String)value),null);
    }
 catch (    Exception ex) {
    }
    activeEditor=jScrollPaneCDATA;
  }
 else   if (value instanceof String) {
    activeEditor=stringEditor;
    stringEditor.setText((String)value);
  }
 else   if (value instanceof Boolean) {
    activeEditor=booleanEditor;
    booleanEditor.setSelected((Boolean)value);
  }
 else   if (value instanceof Integer) {
    activeEditor=integerEditor;
    integerEditor.setText((String)value);
  }
 else   if (value == null) {
    value=""String_Node_Str"";
    activeEditor=stringEditor;
    stringEditor.setText((String)value);
  }
 else   if (value.getClass() == MondrianGuiDef.Join.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench);
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_JOIN);
    tableEditor.setModel(ptm);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.NameExpression.class) {
    return null;
  }
 else   if (value.getClass() == MondrianGuiDef.RelationOrJoin.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench);
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_RELATION);
    tableEditor.setModel(ptm);
    activeEditor=tableEditor;
    return null;
  }
 else   if (value.getClass() == MondrianGuiDef.OrdinalExpression.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench);
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,((MondrianGuiDef.OrdinalExpression)value).expressions[0],SchemaExplorer.DEF_SQL);
    ptm.setParentTarget(((PropertyTableModel)table.getModel()).target);
    tableEditor.setModel(ptm);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.CaptionExpression.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench);
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,((MondrianGuiDef.CaptionExpression)value).expressions[0],SchemaExplorer.DEF_SQL);
    ptm.setParentTarget(((PropertyTableModel)table.getModel()).target);
    tableEditor.setModel(ptm);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.Formula.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench,jdbcMetaData);
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_FORMULA);
    tableEditor.setModel(ptm);
    tableEditor.getColumnModel().getColumn(0).setMaxWidth(100);
    tableEditor.getColumnModel().getColumn(0).setMinWidth(100);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.CalculatedMemberProperty.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench,jdbcMetaData);
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_CALCULATED_MEMBER_PROPERTY);
    tableEditor.setModel(ptm);
    tableEditor.getColumnModel().getColumn(0).setMaxWidth(100);
    tableEditor.getColumnModel().getColumn(0).setMinWidth(100);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.Table.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench,jdbcMetaData);
    for (int i=listeners.size() - 1; i >= 0; i--) {
      spce.addCellEditorListener(listeners.get(i));
    }
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_TABLE);
    ptm.setFactTable(selectedFactTable);
    if (targetClassz == MondrianGuiDef.Cube.class) {
      ptm.setParentTarget(((PropertyTableModel)table.getModel()).target);
    }
    tableEditor.setModel(ptm);
    tableEditor.getColumnModel().getColumn(0).setMaxWidth(100);
    tableEditor.getColumnModel().getColumn(0).setMinWidth(100);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.AggFactCount.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench,jdbcMetaData);
    for (int i=listeners.size() - 1; i >= 0; i--) {
      spce.addCellEditorListener(listeners.get(i));
    }
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_AGG_FACT_COUNT);
    ptm.setFactTable(selectedFactTable);
    tableEditor.setModel(ptm);
    tableEditor.getColumnModel().getColumn(0).setMaxWidth(100);
    tableEditor.getColumnModel().getColumn(0).setMinWidth(100);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.Closure.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench,jdbcMetaData);
    for (int i=listeners.size() - 1; i >= 0; i--) {
      spce.addCellEditorListener(listeners.get(i));
    }
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_CLOSURE);
    ptm.setFactTable(selectedFactTable);
    if (targetClassz == MondrianGuiDef.Level.class) {
      ptm.setParentTarget(((PropertyTableModel)table.getModel()).target);
    }
    tableEditor.setModel(ptm);
    tableEditor.getColumnModel().getColumn(0).setMaxWidth(100);
    tableEditor.getColumnModel().getColumn(0).setMinWidth(100);
    spcr.setTableRendererHeight(tableEditor,null);
    activeEditor=tableEditor;
  }
 else   if (value.getClass() == MondrianGuiDef.Property.class) {
    SchemaPropertyCellEditor spce=new SchemaPropertyCellEditor(workbench);
    tableEditor.setDefaultEditor(Object.class,spce);
    SchemaPropertyCellRenderer spcr=new SchemaPropertyCellRenderer(workbench);
    tableEditor.setDefaultRenderer(Object.class,spcr);
    PropertyTableModel ptm=new PropertyTableModel(workbench,value,SchemaExplorer.DEF_PROPERTY);
    tableEditor.setModel(ptm);
    activeEditor=tableEditor;
  }
 else {
    value=""String_Node_Str"";
    activeEditor=stringEditor;
    stringEditor.setText((String)value);
  }
  activeEditor.setVisible(true);
  setOriginalValue();
  table.changeSelection(row,column,false,false);
  activeEditor.setBackground(new java.awt.Color(224,249,255));
  activeEditor.requestFocusInWindow();
  return activeEditor;
}",0.9928197854800106
50901,"private List<String> getLevels(String hierarchy){
  if (hierarchy == null || hierarchy.equals(""String_Node_Str"")) {
    return hlevels;
  }
  if (hierarchy.startsWith(""String_Node_Str"") && hierarchy.endsWith(""String_Node_Str"")) {
    hierarchy=hierarchy.substring(1,hierarchy.length() - 1);
  }
  Object po=getParentObject();
  if (po == null) {
    return hlevels;
  }
  MondrianGuiDef.CubeGrant parent=(MondrianGuiDef.CubeGrant)po;
  if (parent.cube == null || parent.cube.equals(""String_Node_Str"")) {
    return hlevels;
  }
  if (cacheCube.equals(parent.cube) && cacheHierarchy.equals(hierarchy)) {
    return hlevels;
  }
  hlevels=new ArrayList<String>();
  cacheCube=parent.cube;
  cacheHierarchy=hierarchy;
  MondrianGuiDef.Schema s=getSchema();
  if (s == null) {
    return hlevels;
  }
  for (int i=0; i < s.cubes.length; i++) {
    final MondrianGuiDef.Cube cube=s.cubes[i];
    if (!cube.name.equals(parent.cube)) {
      continue;
    }
    for (int j=0; j < cube.dimensions.length; j++) {
      final MondrianGuiDef.CubeDimension dimension=cube.dimensions[j];
      if (!dimension.name.equals(hierarchy)) {
        continue;
      }
      MondrianGuiDef.Dimension d=lookupDimension(s,dimension);
      final MondrianGuiDef.Hierarchy hierarchy1=d.hierarchies[0];
      if (hierarchy1 != null) {
        for (int k=0; k < hierarchy1.levels.length; k++) {
          hlevels.add(hierarchy1.levels[k].name);
        }
      }
      break;
    }
    break;
  }
  return hlevels;
}","private List<String> getLevels(String hierarchy){
  if (hierarchy == null || hierarchy.equals(""String_Node_Str"")) {
    return hlevels;
  }
  List<Id.Segment> segments=Util.parseIdentifier(hierarchy);
  if (segments == null || segments.size() == 0) {
    return hlevels;
  }
  if (!MondrianProperties.instance().SsasCompatibleNaming.get()) {
    String data=((Id.NameSegment)segments.get(0)).getName();
    if (data.indexOf(""String_Node_Str"") >= 0) {
      Id.Segment segment=segments.get(0);
      segments.clear();
      segments.add(new Id.NameSegment(data.substring(0,data.indexOf(""String_Node_Str"")),segment.getQuoting()));
      segments.add(new Id.NameSegment(data.substring(data.indexOf(""String_Node_Str"") + 1),segment.getQuoting()));
    }
  }
  Object po=getParentObject();
  if (po == null) {
    return hlevels;
  }
  MondrianGuiDef.CubeGrant parent=(MondrianGuiDef.CubeGrant)po;
  if (parent.cube == null || parent.cube.equals(""String_Node_Str"")) {
    return hlevels;
  }
  if (cacheCube.equals(parent.cube) && cacheHierarchy.equals(hierarchy)) {
    return hlevels;
  }
  hlevels=new ArrayList<String>();
  cacheCube=parent.cube;
  cacheHierarchy=hierarchy;
  MondrianGuiDef.Schema s=getSchema();
  if (s == null) {
    return hlevels;
  }
  for (int i=0; i < s.cubes.length; i++) {
    final MondrianGuiDef.Cube cube=s.cubes[i];
    if (!cube.name.equals(parent.cube)) {
      continue;
    }
    for (int j=0; j < cube.dimensions.length; j++) {
      final MondrianGuiDef.CubeDimension dimension=cube.dimensions[j];
      if (!segments.get(0).matches(dimension.name)) {
        continue;
      }
      MondrianGuiDef.Dimension d=lookupDimension(s,dimension);
      NodeDef[] children=d.getChildren();
      MondrianGuiDef.Hierarchy hierarchyObj=null;
      for (int k=0; k < children.length; k++) {
        if (children[k] instanceof Hierarchy) {
          if ((segments.size() == 1 && ((Hierarchy)children[k]).name == null) || (segments.size() != 0 && segments.get(1).matches(((Hierarchy)children[k]).name))) {
            hierarchyObj=(Hierarchy)children[k];
            break;
          }
        }
      }
      if (hierarchyObj != null) {
        for (int k=0; k < hierarchyObj.levels.length; k++) {
          hlevels.add(hierarchy + ""String_Node_Str"" + Util.quoteMdxIdentifier(hierarchyObj.levels[k].name));
        }
      }
    }
    break;
  }
  return hlevels;
}",0.630737493553378
50902,"private List<String> getHierarchies(){
  List<String> hiers=new ArrayList<String>();
  Object po=getParentObject();
  if (po != null) {
    MondrianGuiDef.CubeGrant parent=(MondrianGuiDef.CubeGrant)po;
    if (!(parent.cube == null || parent.cube.equals(""String_Node_Str""))) {
      MondrianGuiDef.Schema s=getSchema();
      if (s != null) {
        for (int i=0; i < s.cubes.length; i++) {
          if (s.cubes[i].name.equals(parent.cube)) {
            for (int j=0; j < s.cubes[i].dimensions.length; j++) {
              NodeDef[] children=s.cubes[i].dimensions[j].getChildren();
              for (int k=0; k < children.length; k++) {
                if (children[k] instanceof Hierarchy && (((Hierarchy)children[k]).name != null)) {
                  hiers.add(((Hierarchy)children[k]).name);
                }
              }
            }
            break;
          }
        }
      }
    }
  }
  return hiers;
}","private List<String> getHierarchies(){
  List<String> hiers=new ArrayList<String>();
  Object po=getParentObject();
  if (po != null) {
    MondrianGuiDef.CubeGrant parent=(MondrianGuiDef.CubeGrant)po;
    if (!(parent.cube == null || parent.cube.equals(""String_Node_Str""))) {
      MondrianGuiDef.Schema s=getSchema();
      if (s != null) {
        for (int i=0; i < s.cubes.length; i++) {
          if (s.cubes[i].name.equals(parent.cube)) {
            for (int j=0; j < s.cubes[i].dimensions.length; j++) {
              MondrianGuiDef.Dimension sharedDim=lookupDimension(s,s.cubes[i].dimensions[j]);
              NodeDef[] children=sharedDim.getChildren();
              for (int k=0; k < children.length; k++) {
                if (children[k] instanceof Hierarchy) {
                  String hname=((Hierarchy)children[k]).name;
                  if (hname != null) {
                    if (MondrianProperties.instance().SsasCompatibleNaming.get()) {
                      hiers.add(Util.quoteMdxIdentifier(s.cubes[i].dimensions[j].name) + ""String_Node_Str"" + Util.quoteMdxIdentifier(hname));
                    }
 else {
                      hiers.add(Util.quoteMdxIdentifier(s.cubes[i].dimensions[j].name + ""String_Node_Str"" + hname));
                    }
                  }
 else {
                    hiers.add(Util.quoteMdxIdentifier(s.cubes[i].dimensions[j].name));
                  }
                }
              }
            }
            break;
          }
        }
      }
    }
  }
  return hiers;
}",0.6370672097759674
50903,"/** 
 * Reads formatString up to the first semi-colon, or to the end if there are no semi-colons.  Adds a format to alternateFormatList, and returns the remains of formatString.
 */
private String parseFormatString(String formatString,List<BasicFormat> alternateFormatList,FormatType[] formatTypeOut){
  final String originalFormatString=formatString;
  int numberState=NOT_IN_A_NUMBER;
  StringBuilder ignored=new StringBuilder();
  String prevIgnored=null;
  boolean haveSeenNumber=false;
  int digitsLeftOfPoint=0, digitsRightOfPoint=0, digitsRightOfExp=0, zeroesLeftOfPoint=0, zeroesRightOfPoint=0, zeroesRightOfExp=0;
  boolean useDecimal=false, useThouSep=false, fillFromRight=true;
  int expFormat=FORMAT_NULL;
  if (macroTokenMap.containsKey(formatString)) {
    MacroToken macroToken=macroTokenMap.get(formatString);
    if (macroToken.translation == null) {
      if (macroToken.name.equals(""String_Node_Str"")) {
        formatString=locale.currencyFormat + ""String_Node_Str"" + locale.currencyFormat+ ""String_Node_Str"";
      }
 else {
        throw new Error(""String_Node_Str"" + macroToken.name + ""String_Node_Str"");
      }
    }
 else {
      formatString=macroToken.translation;
    }
  }
  if (!formatString.endsWith(""String_Node_Str"")) {
    formatString=formatString + ""String_Node_Str"";
  }
  List<BasicFormat> formatList=new ArrayList<BasicFormat>();
  loop:   while (formatString.length() > 0) {
    BasicFormat format=null;
    String newFormatString=null;
    boolean ignoreToken=false;
    for (int i=tokens.length - 1; i > 0; i--) {
      Token token=tokens[i];
      if (!formatString.startsWith(token.token)) {
        continue;
      }
      if (!token.compatibleWith(formatTypeOut[0])) {
        continue;
      }
      String matched=token.token;
      newFormatString=formatString.substring(matched.length());
      if (token.isSpecial()) {
switch (token.code) {
case FORMAT_SEMI:
          formatString=newFormatString;
        break loop;
case FORMAT_POUND:
switch (numberState) {
case NOT_IN_A_NUMBER:
        numberState=LEFT_OF_POINT;
case LEFT_OF_POINT:
      digitsLeftOfPoint++;
    break;
case RIGHT_OF_POINT:
  digitsRightOfPoint++;
break;
case RIGHT_OF_EXP:
digitsRightOfExp++;
break;
default :
throw new Error();
}
break;
case FORMAT_0:
switch (numberState) {
case NOT_IN_A_NUMBER:
numberState=LEFT_OF_POINT;
case LEFT_OF_POINT:
zeroesLeftOfPoint++;
break;
case RIGHT_OF_POINT:
zeroesRightOfPoint++;
break;
case RIGHT_OF_EXP:
zeroesRightOfExp++;
break;
default :
throw new Error();
}
break;
case FORMAT_M:
case FORMAT_MM:
{
boolean theyMeantMinute=false;
int j=formatList.size() - 1;
while (j >= 0) {
BasicFormat prevFormat=formatList.get(j);
if (prevFormat instanceof LiteralFormat) {
j--;
}
 else if (prevFormat.code == FORMAT_H || prevFormat.code == FORMAT_HH) {
theyMeantMinute=true;
break;
}
 else {
theyMeantMinute=false;
break;
}
}
if (theyMeantMinute) {
format=new DateFormat((token.code == FORMAT_M ? FORMAT_N : FORMAT_NN),matched,locale,false);
}
 else {
format=token.makeFormat(locale);
}
break;
}
case FORMAT_DECIMAL:
{
numberState=RIGHT_OF_POINT;
useDecimal=true;
break;
}
case FORMAT_THOUSEP:
{
if (numberState == LEFT_OF_POINT) {
useThouSep=true;
}
 else {
format=token.makeFormat(locale);
}
break;
}
case FORMAT_TIMESEP:
{
format=new LiteralFormat(locale.timeSeparator);
break;
}
case FORMAT_DATESEP:
{
format=new LiteralFormat(locale.dateSeparator);
break;
}
case FORMAT_BACKSLASH:
{
String s;
if (formatString.length() == 1) {
s=""String_Node_Str"";
newFormatString=""String_Node_Str"";
}
 else {
s=formatString.substring(1,2);
newFormatString=formatString.substring(2);
}
format=new LiteralFormat(s);
break;
}
case FORMAT_E_MINUS_UPPER:
case FORMAT_E_PLUS_UPPER:
case FORMAT_E_MINUS_LOWER:
case FORMAT_E_PLUS_LOWER:
{
numberState=RIGHT_OF_EXP;
expFormat=token.code;
if (zeroesLeftOfPoint == 0 && zeroesRightOfPoint == 0) {
zeroesLeftOfPoint=1;
}
break;
}
case FORMAT_QUOTE:
{
String s;
int j=formatString.indexOf(""String_Node_Str"",1);
if (j == -1) {
s=formatString.substring(1);
newFormatString=""String_Node_Str"";
}
 else {
s=formatString.substring(1,j);
newFormatString=formatString.substring(j + 1);
}
format=new LiteralFormat(s);
break;
}
case FORMAT_UPPER:
{
format=new StringFormat(StringCase.UPPER,""String_Node_Str"",locale.locale);
break;
}
case FORMAT_LOWER:
{
format=new StringFormat(StringCase.LOWER,""String_Node_Str"",locale.locale);
break;
}
case FORMAT_FILL_FROM_LEFT:
{
fillFromRight=false;
break;
}
case FORMAT_GENERAL_NUMBER:
{
format=new JavaFormat(locale.locale);
break;
}
case FORMAT_GENERAL_DATE:
{
format=new JavaFormat(locale.locale);
break;
}
case FORMAT_INTL_CURRENCY:
{
format=new LiteralFormat(locale.currencySymbol);
break;
}
default :
throw new Error();
}
if (formatTypeOut[0] == null) {
formatTypeOut[0]=token.getFormatType();
}
if (format == null) {
ignoreToken=true;
ignored.append(matched);
}
 else {
prevIgnored=ignored.toString();
ignored.setLength(0);
}
}
 else {
format=token.makeFormat(locale);
}
break;
}
if (format == null && !ignoreToken) {
format=new LiteralFormat(formatString.substring(0,1));
newFormatString=formatString.substring(1);
}
if (format != null) {
if (numberState != NOT_IN_A_NUMBER) {
NumericFormat numericFormat=new NumericFormat(prevIgnored,locale,expFormat,digitsLeftOfPoint,zeroesLeftOfPoint,digitsRightOfPoint,zeroesRightOfPoint,digitsRightOfExp,zeroesRightOfExp,useDecimal,useThouSep,originalFormatString);
formatList.add(numericFormat);
numberState=NOT_IN_A_NUMBER;
haveSeenNumber=true;
}
formatList.add(format);
if (formatTypeOut[0] == null) {
formatTypeOut[0]=format.getFormatType();
}
}
formatString=newFormatString;
}
if (numberState != NOT_IN_A_NUMBER) {
NumericFormat numericFormat=new NumericFormat(prevIgnored,locale,expFormat,digitsLeftOfPoint,zeroesLeftOfPoint,digitsRightOfPoint,zeroesRightOfPoint,digitsRightOfExp,zeroesRightOfExp,useDecimal,useThouSep,originalFormatString);
formatList.add(numericFormat);
numberState=NOT_IN_A_NUMBER;
haveSeenNumber=true;
}
boolean twelveHourClock=false;
int decimalShift=0;
for (int i=0; i < formatList.size(); i++) {
switch (formatList.get(i).code) {
case FORMAT_UPPER_AM_SOLIDUS_PM:
case FORMAT_LOWER_AM_SOLIDUS_PM:
case FORMAT_UPPER_A_SOLIDUS_P:
case FORMAT_LOWER_A_SOLIDUS_P:
case FORMAT_AMPM:
twelveHourClock=true;
break;
case FORMAT_PERCENT:
decimalShift+=2;
break;
case FORMAT_THOUSEP:
if (haveSeenNumber && i + 1 < formatList.size()) {
final BasicFormat nextFormat=formatList.get(i + 1);
if (nextFormat.code != FORMAT_THOUSEP && nextFormat.code != FORMAT_0 && nextFormat.code != FORMAT_POUND) {
for (int j=i; j >= 0 && formatList.get(j).code == FORMAT_THOUSEP; j--) {
decimalShift-=3;
formatList.remove(j);
--i;
}
}
}
break;
default :
}
}
if (twelveHourClock) {
for (int i=0; i < formatList.size(); i++) {
if (formatList.get(i) instanceof DateFormat) {
((DateFormat)formatList.get(i)).setTwelveHourClock(true);
}
}
}
if (decimalShift != 0) {
for (int i=0; i < formatList.size(); i++) {
if (formatList.get(i) instanceof NumericFormat) {
((NumericFormat)formatList.get(i)).decimalShift=decimalShift;
}
}
}
for (int i=0; i < formatList.size(); ++i) {
if (i > 0 && formatList.get(i) instanceof LiteralFormat && formatList.get(i - 1) instanceof LiteralFormat) {
formatList.set(i - 1,new LiteralFormat(((LiteralFormat)formatList.get(i - 1)).s + ((LiteralFormat)formatList.get(i)).s));
formatList.remove(i);
--i;
}
}
BasicFormat alternateFormat;
switch (formatList.size()) {
case 0:
alternateFormat=null;
break;
case 1:
alternateFormat=formatList.get(0);
break;
default :
alternateFormat=new CompoundFormat(formatList.toArray(new BasicFormat[formatList.size()]));
break;
}
alternateFormatList.add(alternateFormat);
return formatString;
}","/** 
 * Reads formatString up to the first semi-colon, or to the end if there are no semi-colons.  Adds a format to alternateFormatList, and returns the remains of formatString.
 */
private String parseFormatString(String formatString,List<BasicFormat> alternateFormatList,FormatType[] formatTypeOut){
  final String originalFormatString=formatString;
  int numberState=NOT_IN_A_NUMBER;
  StringBuilder ignored=new StringBuilder();
  String prevIgnored=null;
  boolean haveSeenNumber=false;
  int digitsLeftOfPoint=0, digitsRightOfPoint=0, digitsRightOfExp=0, zeroesLeftOfPoint=0, zeroesRightOfPoint=0, zeroesRightOfExp=0;
  boolean useDecimal=false, useThouSep=false, fillFromRight=true;
  int expFormat=FORMAT_NULL;
  if (macroTokenMap.containsKey(formatString)) {
    MacroToken macroToken=macroTokenMap.get(formatString);
    if (macroToken.translation == null) {
      if (macroToken.name.equals(""String_Node_Str"")) {
        formatString=locale.currencyFormat + ""String_Node_Str"" + locale.currencyFormat+ ""String_Node_Str"";
      }
 else {
        throw new Error(""String_Node_Str"" + macroToken.name + ""String_Node_Str"");
      }
    }
 else {
      formatString=macroToken.translation;
    }
  }
  if (!formatString.endsWith(""String_Node_Str"")) {
    formatString=formatString + ""String_Node_Str"";
  }
  List<BasicFormat> formatList=new ArrayList<BasicFormat>();
  List<Integer> thousands=new ArrayList<Integer>();
  int decimalShift=0;
  loop:   while (formatString.length() > 0) {
    BasicFormat format=null;
    String newFormatString;
    final Token token=findToken(formatString,formatTypeOut[0]);
    if (token != null) {
      String matched=token.token;
      newFormatString=formatString.substring(matched.length());
      if (token.isSpecial()) {
switch (token.code) {
case FORMAT_SEMI:
          break loop;
case FORMAT_POUND:
switch (numberState) {
case NOT_IN_A_NUMBER:
          numberState=LEFT_OF_POINT;
case LEFT_OF_POINT:
        digitsLeftOfPoint++;
      break;
case RIGHT_OF_POINT:
    digitsRightOfPoint++;
  break;
case RIGHT_OF_EXP:
digitsRightOfExp++;
break;
default :
throw new Error();
}
break;
case FORMAT_0:
switch (numberState) {
case NOT_IN_A_NUMBER:
numberState=LEFT_OF_POINT;
case LEFT_OF_POINT:
zeroesLeftOfPoint++;
break;
case RIGHT_OF_POINT:
zeroesRightOfPoint++;
break;
case RIGHT_OF_EXP:
zeroesRightOfExp++;
break;
default :
throw new Error();
}
break;
case FORMAT_M:
case FORMAT_MM:
{
boolean theyMeantMinute=false;
int j=formatList.size() - 1;
while (j >= 0) {
BasicFormat prevFormat=formatList.get(j);
if (prevFormat instanceof LiteralFormat) {
j--;
}
 else if (prevFormat.code == FORMAT_H || prevFormat.code == FORMAT_HH) {
theyMeantMinute=true;
break;
}
 else {
theyMeantMinute=false;
break;
}
}
if (theyMeantMinute) {
format=new DateFormat((token.code == FORMAT_M ? FORMAT_N : FORMAT_NN),matched,locale,false);
}
 else {
format=token.makeFormat(locale);
}
break;
}
case FORMAT_DECIMAL:
{
if (numberState == LEFT_OF_POINT) {
decimalShift=fixThousands(thousands,formatString,decimalShift);
}
numberState=RIGHT_OF_POINT;
useDecimal=true;
break;
}
case FORMAT_THOUSEP:
{
if (numberState == LEFT_OF_POINT) {
useThouSep=true;
thousands.add(formatString.length());
}
 else {
format=token.makeFormat(locale);
}
break;
}
case FORMAT_TIMESEP:
{
format=new LiteralFormat(locale.timeSeparator);
break;
}
case FORMAT_DATESEP:
{
format=new LiteralFormat(locale.dateSeparator);
break;
}
case FORMAT_BACKSLASH:
{
String s;
if (formatString.length() == 1) {
s=""String_Node_Str"";
newFormatString=""String_Node_Str"";
}
 else {
s=formatString.substring(1,2);
newFormatString=formatString.substring(2);
}
format=new LiteralFormat(s);
break;
}
case FORMAT_E_MINUS_UPPER:
case FORMAT_E_PLUS_UPPER:
case FORMAT_E_MINUS_LOWER:
case FORMAT_E_PLUS_LOWER:
{
if (numberState == LEFT_OF_POINT) {
decimalShift=fixThousands(thousands,formatString,decimalShift);
}
numberState=RIGHT_OF_EXP;
expFormat=token.code;
if (zeroesLeftOfPoint == 0 && zeroesRightOfPoint == 0) {
zeroesLeftOfPoint=1;
}
break;
}
case FORMAT_QUOTE:
{
String s;
int j=formatString.indexOf(""String_Node_Str"",1);
if (j == -1) {
s=formatString.substring(1);
newFormatString=""String_Node_Str"";
}
 else {
s=formatString.substring(1,j);
newFormatString=formatString.substring(j + 1);
}
format=new LiteralFormat(s);
break;
}
case FORMAT_UPPER:
{
format=new StringFormat(StringCase.UPPER,""String_Node_Str"",locale.locale);
break;
}
case FORMAT_LOWER:
{
format=new StringFormat(StringCase.LOWER,""String_Node_Str"",locale.locale);
break;
}
case FORMAT_FILL_FROM_LEFT:
{
fillFromRight=false;
break;
}
case FORMAT_GENERAL_NUMBER:
{
format=new JavaFormat(locale.locale);
break;
}
case FORMAT_GENERAL_DATE:
{
format=new JavaFormat(locale.locale);
break;
}
case FORMAT_INTL_CURRENCY:
{
format=new LiteralFormat(locale.currencySymbol);
break;
}
default :
throw new Error();
}
if (formatTypeOut[0] == null) {
formatTypeOut[0]=token.getFormatType();
}
if (format == null) {
ignored.append(matched);
}
 else {
prevIgnored=ignored.toString();
ignored.setLength(0);
}
}
 else {
format=token.makeFormat(locale);
}
}
 else {
format=new LiteralFormat(formatString.substring(0,1));
newFormatString=formatString.substring(1);
}
if (format != null) {
if (numberState != NOT_IN_A_NUMBER) {
if (numberState == LEFT_OF_POINT) {
decimalShift=fixThousands(thousands,formatString,decimalShift);
}
NumericFormat numericFormat=new NumericFormat(prevIgnored,locale,expFormat,digitsLeftOfPoint,zeroesLeftOfPoint,digitsRightOfPoint,zeroesRightOfPoint,digitsRightOfExp,zeroesRightOfExp,useDecimal,useThouSep,originalFormatString);
formatList.add(numericFormat);
numberState=NOT_IN_A_NUMBER;
haveSeenNumber=true;
}
formatList.add(format);
if (formatTypeOut[0] == null) {
formatTypeOut[0]=format.getFormatType();
}
}
formatString=newFormatString;
}
if (numberState != NOT_IN_A_NUMBER) {
if (numberState == LEFT_OF_POINT) {
decimalShift=fixThousands(thousands,formatString,decimalShift);
}
NumericFormat numericFormat=new NumericFormat(prevIgnored,locale,expFormat,digitsLeftOfPoint,zeroesLeftOfPoint,digitsRightOfPoint,zeroesRightOfPoint,digitsRightOfExp,zeroesRightOfExp,useDecimal,useThouSep,originalFormatString);
formatList.add(numericFormat);
numberState=NOT_IN_A_NUMBER;
haveSeenNumber=true;
}
if (formatString.startsWith(""String_Node_Str"")) {
formatString=formatString.substring(1);
}
boolean twelveHourClock=false;
for (int i=0; i < formatList.size(); i++) {
switch (formatList.get(i).code) {
case FORMAT_UPPER_AM_SOLIDUS_PM:
case FORMAT_LOWER_AM_SOLIDUS_PM:
case FORMAT_UPPER_A_SOLIDUS_P:
case FORMAT_LOWER_A_SOLIDUS_P:
case FORMAT_AMPM:
twelveHourClock=true;
break;
case FORMAT_PERCENT:
decimalShift+=2;
break;
case FORMAT_THOUSEP:
if (haveSeenNumber && i + 1 < formatList.size()) {
final BasicFormat nextFormat=formatList.get(i + 1);
if (nextFormat.code != FORMAT_THOUSEP && nextFormat.code != FORMAT_0 && nextFormat.code != FORMAT_POUND) {
for (int j=i; j >= 0 && formatList.get(j).code == FORMAT_THOUSEP; j--) {
decimalShift-=3;
formatList.remove(j);
--i;
}
}
}
break;
default :
}
}
if (twelveHourClock) {
for (int i=0; i < formatList.size(); i++) {
if (formatList.get(i) instanceof DateFormat) {
((DateFormat)formatList.get(i)).setTwelveHourClock(true);
}
}
}
if (decimalShift != 0) {
for (int i=0; i < formatList.size(); i++) {
if (formatList.get(i) instanceof NumericFormat) {
((NumericFormat)formatList.get(i)).decimalShift=decimalShift;
}
}
}
for (int i=0; i < formatList.size(); ++i) {
if (i > 0 && formatList.get(i) instanceof LiteralFormat && formatList.get(i - 1) instanceof LiteralFormat) {
formatList.set(i - 1,new LiteralFormat(((LiteralFormat)formatList.get(i - 1)).s + ((LiteralFormat)formatList.get(i)).s));
formatList.remove(i);
--i;
}
}
BasicFormat alternateFormat;
switch (formatList.size()) {
case 0:
alternateFormat=null;
break;
case 1:
alternateFormat=formatList.get(0);
break;
default :
alternateFormat=new CompoundFormat(formatList.toArray(new BasicFormat[formatList.size()]));
break;
}
alternateFormatList.add(alternateFormat);
return formatString;
}",0.9342314291160958
50904,"protected boolean acceptsConnection(Connection connection){
  try {
    return super.acceptsConnection(connection) && !isGreenplum(connection.getMetaData());
  }
 catch (  SQLException e) {
    throw Util.newError(e,""String_Node_Str"");
  }
}","protected boolean acceptsConnection(Connection connection){
  try {
    return super.acceptsConnection(connection) && !isGreenplum(connection.getMetaData()) && !isNetezza(connection.getMetaData());
  }
 catch (  SQLException e) {
    throw Util.newError(e,""String_Node_Str"");
  }
}",0.9233716475095786
50905,"public void flushSchemaCache(){
  RolapSchema.Pool.instance().clear();
}","public void flushSchemaCache(){
  RolapSchema.Pool.instance().clear();
  connection.getSchema().finalCleanUp();
}",0.7783783783783784
50906,"/** 
 * Resolves any pending cell reads using the cache. After calling this method, all cells requested in a given batch are loaded into this statement's local cache. <p>The method is implemented by making an asynchronous call to the cache manager. The result is a list of segments that satisfies every cell request.</p> <p>The client should put the resulting segments into its ""query local"" cache, to ensure that future cells in that segment can be answered without a call to the cache manager. (That is probably 1000x faster.)</p> <p>The cache manager does not inform where client where each segment came from. There are several possibilities:</p> <ul> <li>Segment was already in cache (header and body)</li> <li>Segment is in the process of being loaded by executing a SQL statement (probably due to a request from another client)</li> <li>Segment is in an external cache (that is, header is in the cache, body is not yet)</li> <li>Segment can be created by rolling up one or more cache segments. (And of course each of these segments might be ""paged out"".)</li> <li>By executing a SQL   {@code GROUP BY} statement</li></ul> <p>Furthermore, segments in external cache may take some time to retrieve (a LAN round trip, say 1 millisecond, is a reasonable guess); and the request may fail. (It depends on the cache, but caches are at liberty to 'forget' segments.) So, any strategy that relies on cache segments should be able to fall back. Even if there are fall backs, only one call needs to be made to the cache manager.</p>
 * @return Whether any aggregations were loaded.
 */
boolean loadAggregations(){
  if (!isDirty()) {
    return false;
  }
  final List<Future<Map<Segment,SegmentWithData>>> sqlSegmentMapFutures=new ArrayList<Future<Map<Segment,SegmentWithData>>>();
  final List<CellRequest> cellRequests1=new ArrayList<CellRequest>(cellRequests);
  for (int iteration=0; ; ++iteration) {
    final BatchLoader.LoadBatchResponse response=cacheMgr.execute(new BatchLoader.LoadBatchCommand(Locus.peek(),cacheMgr,getDialect(),cube,Collections.unmodifiableList(cellRequests1)));
    int failureCount=0;
    Map<SegmentHeader,SegmentBody> headerBodies=new HashMap<SegmentHeader,SegmentBody>();
    final Set<SegmentHeader> failedSegments=new HashSet<SegmentHeader>();
    for (    SegmentHeader header : response.cacheSegments) {
      final SegmentBody body=cacheMgr.compositeCache.get(header);
      if (body == null) {
        cacheMgr.remove(cube.getStar(),header);
        failedSegments.add(header);
        ++failureCount;
        continue;
      }
      headerBodies.put(header,body);
      final SegmentWithData segmentWithData=response.convert(header,body);
      segmentWithData.getStar().register(segmentWithData);
    }
    final Map<SegmentHeader,SegmentBody> succeededRollups=new HashMap<SegmentHeader,SegmentBody>();
    for (    final BatchLoader.RollupInfo rollup : response.rollups) {
      Map<SegmentHeader,SegmentBody> map=findResidentRollupCandidate(headerBodies,rollup);
      if (map == null) {
        continue;
      }
      final Set<String> keepColumns=new HashSet<String>();
      for (      RolapStar.Column column : rollup.constrainedColumns) {
        keepColumns.add(column.getExpression().getGenericExpression());
      }
      Pair<SegmentHeader,SegmentBody> rollupHeaderBody=SegmentBuilder.rollup(map,keepColumns,rollup.constrainedColumnsBitKey,rollup.measure.getAggregator().getRollup());
      final SegmentHeader header=rollupHeaderBody.left;
      final SegmentBody body=rollupHeaderBody.right;
      if (headerBodies.containsKey(header)) {
        continue;
      }
      headerBodies.put(header,body);
      succeededRollups.put(header,body);
      final SegmentWithData segmentWithData=response.convert(header,body);
      final Locus locus=Locus.peek();
      cacheMgr.execute(new SegmentCacheManager.Command<Void>(){
        public Void call() throws Exception {
          SegmentCacheIndex index=cacheMgr.getIndexRegistry().getIndex(segmentWithData.getStar());
          index.add(segmentWithData.getHeader(),true,response.converterMap.get(SegmentCacheIndexImpl.makeConverterKey(segmentWithData.getHeader())));
          ((SlotFuture<SegmentBody>)index.getFuture(segmentWithData.getHeader())).put(body);
          return null;
        }
        public Locus getLocus(){
          return locus;
        }
      }
);
      segmentWithData.getStar().register(segmentWithData);
    }
    sqlSegmentMapFutures.addAll(response.sqlSegmentMapFutures);
    if (failureCount == 0 || iteration > 0) {
      for (      Map.Entry<SegmentHeader,Future<SegmentBody>> entry : response.futures.entrySet()) {
        final SegmentHeader header=entry.getKey();
        final Future<SegmentBody> bodyFuture=entry.getValue();
        final SegmentBody body=Util.safeGet(bodyFuture,""String_Node_Str"");
        final SegmentWithData segmentWithData=response.convert(header,body);
        segmentWithData.getStar().register(segmentWithData);
      }
      for (      Future<Map<Segment,SegmentWithData>> sqlSegmentMapFuture : sqlSegmentMapFutures) {
        final Map<Segment,SegmentWithData> segmentMap=Util.safeGet(sqlSegmentMapFuture,""String_Node_Str"");
        for (        SegmentWithData segmentWithData : segmentMap.values()) {
          segmentWithData.getStar().register(segmentWithData);
        }
      }
    }
    if (failureCount == 0) {
      break;
    }
    @SuppressWarnings(""String_Node_Str"") List<CellRequest> old=new ArrayList<CellRequest>(cellRequests1);
    cellRequests1.clear();
    for (    CellRequest cellRequest : old) {
      if (cellRequest.getMeasure().getStar().getCellFromCache(cellRequest,null) == null) {
        cellRequests1.add(cellRequest);
      }
    }
    if (cellRequests1.isEmpty()) {
      break;
    }
    if (cellRequests1.size() >= old.size() && iteration > 10) {
      throw Util.newError(""String_Node_Str"" + ""String_Node_Str"" + iteration + ""String_Node_Str""+ cellRequests1.size()+ ""String_Node_Str""+ response.cacheSegments.size()+ ""String_Node_Str""+ response.rollups.size()+ ""String_Node_Str""+ response.sqlSegmentMapFutures.size());
    }
  }
  dirty=false;
  cellRequests.clear();
  return true;
}","/** 
 * Resolves any pending cell reads using the cache. After calling this method, all cells requested in a given batch are loaded into this statement's local cache. <p>The method is implemented by making an asynchronous call to the cache manager. The result is a list of segments that satisfies every cell request.</p> <p>The client should put the resulting segments into its ""query local"" cache, to ensure that future cells in that segment can be answered without a call to the cache manager. (That is probably 1000x faster.)</p> <p>The cache manager does not inform where client where each segment came from. There are several possibilities:</p> <ul> <li>Segment was already in cache (header and body)</li> <li>Segment is in the process of being loaded by executing a SQL statement (probably due to a request from another client)</li> <li>Segment is in an external cache (that is, header is in the cache, body is not yet)</li> <li>Segment can be created by rolling up one or more cache segments. (And of course each of these segments might be ""paged out"".)</li> <li>By executing a SQL   {@code GROUP BY} statement</li></ul> <p>Furthermore, segments in external cache may take some time to retrieve (a LAN round trip, say 1 millisecond, is a reasonable guess); and the request may fail. (It depends on the cache, but caches are at liberty to 'forget' segments.) So, any strategy that relies on cache segments should be able to fall back. Even if there are fall backs, only one call needs to be made to the cache manager.</p>
 * @return Whether any aggregations were loaded.
 */
boolean loadAggregations(){
  if (!isDirty()) {
    return false;
  }
  final List<Future<Map<Segment,SegmentWithData>>> sqlSegmentMapFutures=new ArrayList<Future<Map<Segment,SegmentWithData>>>();
  final List<CellRequest> cellRequests1=new ArrayList<CellRequest>(cellRequests);
  for (int iteration=0; ; ++iteration) {
    final BatchLoader.LoadBatchResponse response=cacheMgr.execute(new BatchLoader.LoadBatchCommand(Locus.peek(),cacheMgr,getDialect(),cube,Collections.unmodifiableList(cellRequests1)));
    int failureCount=0;
    Map<SegmentHeader,SegmentBody> headerBodies=new HashMap<SegmentHeader,SegmentBody>();
    final Set<SegmentHeader> failedSegments=new HashSet<SegmentHeader>();
    for (    SegmentHeader header : response.cacheSegments) {
      final SegmentBody body=cacheMgr.compositeCache.get(header);
      if (body == null) {
        cacheMgr.remove(cube.getStar(),header);
        failedSegments.add(header);
        ++failureCount;
        continue;
      }
      headerBodies.put(header,body);
      final SegmentWithData segmentWithData=response.convert(header,body);
      segmentWithData.getStar().register(segmentWithData);
    }
    final Map<SegmentHeader,SegmentBody> succeededRollups=new HashMap<SegmentHeader,SegmentBody>();
    for (    final BatchLoader.RollupInfo rollup : response.rollups) {
      Map<SegmentHeader,SegmentBody> map=findResidentRollupCandidate(headerBodies,rollup);
      if (map == null) {
        continue;
      }
      final Set<String> keepColumns=new HashSet<String>();
      for (      RolapStar.Column column : rollup.constrainedColumns) {
        keepColumns.add(column.getExpression().getGenericExpression());
      }
      Pair<SegmentHeader,SegmentBody> rollupHeaderBody=SegmentBuilder.rollup(map,keepColumns,rollup.constrainedColumnsBitKey,rollup.measure.getAggregator().getRollup());
      final SegmentHeader header=rollupHeaderBody.left;
      final SegmentBody body=rollupHeaderBody.right;
      if (headerBodies.containsKey(header)) {
        continue;
      }
      headerBodies.put(header,body);
      succeededRollups.put(header,body);
      final SegmentWithData segmentWithData=response.convert(header,body);
      final Locus locus=Locus.peek();
      cacheMgr.execute(new SegmentCacheManager.Command<Void>(){
        public Void call() throws Exception {
          SegmentCacheIndex index=cacheMgr.getIndexRegistry().getIndex(segmentWithData.getStar());
          boolean added=index.add(segmentWithData.getHeader(),true,response.converterMap.get(SegmentCacheIndexImpl.makeConverterKey(segmentWithData.getHeader())));
          if (added) {
            ((SlotFuture<SegmentBody>)index.getFuture(segmentWithData.getHeader())).put(body);
          }
          return null;
        }
        public Locus getLocus(){
          return locus;
        }
      }
);
      segmentWithData.getStar().register(segmentWithData);
    }
    sqlSegmentMapFutures.addAll(response.sqlSegmentMapFutures);
    if (failureCount == 0 || iteration > 0) {
      for (      Map.Entry<SegmentHeader,Future<SegmentBody>> entry : response.futures.entrySet()) {
        final SegmentHeader header=entry.getKey();
        final Future<SegmentBody> bodyFuture=entry.getValue();
        final SegmentBody body=Util.safeGet(bodyFuture,""String_Node_Str"");
        final SegmentWithData segmentWithData=response.convert(header,body);
        segmentWithData.getStar().register(segmentWithData);
      }
      for (      Future<Map<Segment,SegmentWithData>> sqlSegmentMapFuture : sqlSegmentMapFutures) {
        final Map<Segment,SegmentWithData> segmentMap=Util.safeGet(sqlSegmentMapFuture,""String_Node_Str"");
        for (        SegmentWithData segmentWithData : segmentMap.values()) {
          segmentWithData.getStar().register(segmentWithData);
        }
      }
    }
    if (failureCount == 0) {
      break;
    }
    @SuppressWarnings(""String_Node_Str"") List<CellRequest> old=new ArrayList<CellRequest>(cellRequests1);
    cellRequests1.clear();
    for (    CellRequest cellRequest : old) {
      if (cellRequest.getMeasure().getStar().getCellFromCache(cellRequest,null) == null) {
        cellRequests1.add(cellRequest);
      }
    }
    if (cellRequests1.isEmpty()) {
      break;
    }
    if (cellRequests1.size() >= old.size() && iteration > 10) {
      throw Util.newError(""String_Node_Str"" + ""String_Node_Str"" + iteration + ""String_Node_Str""+ cellRequests1.size()+ ""String_Node_Str""+ response.cacheSegments.size()+ ""String_Node_Str""+ response.rollups.size()+ ""String_Node_Str""+ response.sqlSegmentMapFutures.size());
    }
  }
  dirty=false;
  cellRequests.clear();
  return true;
}",0.9958894172644476
50907,"/** 
 * Returns an API with which to explicitly manage the contents of the cache.
 * @param connection Server whose cache to control
 * @param pw Print writer, for tracing
 * @return CacheControl API
 */
public CacheControl getCacheControl(RolapConnection connection,final PrintWriter pw){
  return new CacheControlImpl(connection){
    protected void flushNonUnion(    final CellRegion region){
      final SegmentCacheManager.FlushResult result=cacheMgr.execute(new SegmentCacheManager.FlushCommand(Locus.peek(),cacheMgr,region,this));
      final List<Future<Boolean>> futures=new ArrayList<Future<Boolean>>();
      for (      Callable<Boolean> task : result.tasks) {
        futures.add(cacheMgr.cacheExecutor.submit(task));
      }
      for (      Future<Boolean> future : futures) {
        Util.discard(Util.safeGet(future,""String_Node_Str""));
      }
    }
    public void flush(    final CellRegion region){
      if (pw != null) {
        pw.println(""String_Node_Str"");
        printCacheState(pw,region);
        pw.println();
      }
      super.flush(region);
      if (pw != null) {
        pw.println(""String_Node_Str"");
        printCacheState(pw,region);
        pw.println();
      }
    }
    public void trace(    final String message){
      if (pw != null) {
        pw.println(message);
      }
    }
  }
;
}","/** 
 * Returns an API with which to explicitly manage the contents of the cache.
 * @param connection Server whose cache to control
 * @param pw Print writer, for tracing
 * @return CacheControl API
 */
public CacheControl getCacheControl(RolapConnection connection,final PrintWriter pw){
  return new CacheControlImpl(connection){
    protected void flushNonUnion(    final CellRegion region){
      final SegmentCacheManager.FlushResult result=cacheMgr.execute(new SegmentCacheManager.FlushCommand(Locus.peek(),cacheMgr,region,this));
      final List<Future<Boolean>> futures=new ArrayList<Future<Boolean>>();
      for (      Callable<Boolean> task : result.tasks) {
        futures.add(cacheMgr.cacheExecutor.submit(task));
      }
      for (      Future<Boolean> future : futures) {
        Util.discard(Util.safeGet(future,""String_Node_Str""));
      }
    }
    public void flush(    final CellRegion region){
      if (pw != null) {
        pw.println(""String_Node_Str"");
        printCacheState(pw,region);
        pw.println();
      }
      super.flush(region);
      if (pw != null) {
        pw.println(""String_Node_Str"");
        printCacheState(pw,region);
        pw.println();
      }
    }
    public void trace(    final String message){
      if (pw != null) {
        pw.println(message);
      }
    }
    public boolean isTraceEnabled(){
      return pw != null;
    }
  }
;
}",0.9751280175566936
50908,"public PeekResponse call(){
  final RolapStar.Measure measure=request.getMeasure();
  final RolapStar star=measure.getStar();
  final RolapSchema schema=star.getSchema();
  final AggregationKey key=new AggregationKey(request);
  final List<SegmentHeader> headers=indexRegistry.getIndex(star).locate(schema.getName(),schema.getChecksum(),measure.getCubeName(),measure.getName(),star.getFactTable().getAlias(),request.getConstrainedColumnsBitKey(),request.getMappedCellValues(),AggregationKey.getCompoundPredicateStringList(star,key.getCompoundPredicateList()));
  final Map<SegmentHeader,Future<SegmentBody>> headerMap=new HashMap<SegmentHeader,Future<SegmentBody>>();
  final Map<List,SegmentBuilder.SegmentConverter> converterMap=new HashMap<List,SegmentBuilder.SegmentConverter>();
  for (  final SegmentHeader header : headers) {
    final Future<SegmentBody> bodyFuture=indexRegistry.getIndex(star).getFuture(header);
    if (bodyFuture != null) {
      if (star.getChangeListener() != null && star.getChangeListener().isAggregationChanged(key)) {
        indexRegistry.getIndex(star).remove(header);
        Util.safeGet(cacheExecutor.submit(new Runnable(){
          public void run(){
            try {
              compositeCache.remove(header);
            }
 catch (            Throwable e) {
              LOGGER.warn(""String_Node_Str"" + header,e);
            }
          }
        }
),""String_Node_Str"");
      }
      converterMap.put(SegmentCacheIndexImpl.makeConverterKey(header),getConverter(star,header));
      headerMap.put(header,bodyFuture);
    }
  }
  return new PeekResponse(headerMap,converterMap);
}","public PeekResponse call(){
  final RolapStar.Measure measure=request.getMeasure();
  final RolapStar star=measure.getStar();
  final RolapSchema schema=star.getSchema();
  final AggregationKey key=new AggregationKey(request);
  final List<SegmentHeader> headers=indexRegistry.getIndex(star).locate(schema.getName(),schema.getChecksum(),measure.getCubeName(),measure.getName(),star.getFactTable().getAlias(),request.getConstrainedColumnsBitKey(),request.getMappedCellValues(),AggregationKey.getCompoundPredicateStringList(star,key.getCompoundPredicateList()));
  final Map<SegmentHeader,Future<SegmentBody>> headerMap=new HashMap<SegmentHeader,Future<SegmentBody>>();
  final Map<List,SegmentBuilder.SegmentConverter> converterMap=new HashMap<List,SegmentBuilder.SegmentConverter>();
  for (  final SegmentHeader header : headers) {
    final Future<SegmentBody> bodyFuture=indexRegistry.getIndex(star).getFuture(header);
    if (bodyFuture != null) {
      if (star.getChangeListener() != null && star.getChangeListener().isAggregationChanged(key)) {
        indexRegistry.getIndex(star).remove(header);
        Util.safeGet(cacheExecutor.submit(new Runnable(){
          public void run(){
            try {
              compositeCache.remove(header);
            }
 catch (            Throwable e) {
              LOGGER.warn(""String_Node_Str"" + header,e);
            }
          }
        }
),""String_Node_Str"");
        continue;
      }
      converterMap.put(SegmentCacheIndexImpl.makeConverterKey(header),getConverter(star,header));
      headerMap.put(header,bodyFuture);
    }
  }
  return new PeekResponse(headerMap,converterMap);
}",0.9944987775061124
50909,"/** 
 * Adds a header to the index. <p>If   {@code loading} is true, there must follow a call to{@link #loadSucceeded} or {@link #loadFailed}.</p>
 * @param header Segment header
 * @param loading Whether segment is pending a load from SQL
 * @param converter Segment converter
 */
void add(SegmentHeader header,boolean loading,SegmentBuilder.SegmentConverter converter);","/** 
 * Adds a header to the index. <p>If   {@code loading} is true, there must follow a call to{@link #loadSucceeded} or {@link #loadFailed}.</p>
 * @param header Segment header
 * @param loading Whether segment is pending a load from SQL
 * @param converter Segment converter
 * @return True or false, if a new element was inserted into the index.
 */
boolean add(SegmentHeader header,boolean loading,SegmentBuilder.SegmentConverter converter);",0.8984088127294981
50910,"public void add(SegmentHeader header,boolean loading,SegmentBuilder.SegmentConverter converter){
  checkThread();
  final HeaderInfo headerInfo=headerMap.get(header);
  if (headerInfo != null) {
    if (loading && headerInfo.slot == null) {
      headerInfo.slot=new SlotFuture<SegmentBody>();
    }
    return;
  }
  headerMap.put(header,new HeaderInfo(loading ? new SlotFuture<SegmentBody>() : null));
  final List bitkeyKey=makeBitkeyKey(header);
  List<SegmentHeader> headerList=bitkeyMap.get(bitkeyKey);
  if (headerList == null) {
    headerList=new ArrayList<SegmentHeader>();
    bitkeyMap.put(bitkeyKey,headerList);
  }
  headerList.add(header);
  final List factKey=makeFactKey(header);
  FactInfo factInfo=factMap.get(factKey);
  if (factInfo == null) {
    factInfo=new FactInfo();
    factMap.put(factKey,factInfo);
  }
  factInfo.headerList.add(header);
  factInfo.bitkeyPoset.add(header.getConstrainedColumnsBitKey());
  if (converter != null) {
    factInfo.converter=converter;
  }
  final List fuzzyFactKey=makeFuzzyFactKey(header);
  FuzzyFactInfo fuzzyFactInfo=fuzzyFactMap.get(fuzzyFactKey);
  if (fuzzyFactInfo == null) {
    fuzzyFactInfo=new FuzzyFactInfo();
    fuzzyFactMap.put(fuzzyFactKey,fuzzyFactInfo);
  }
  fuzzyFactInfo.headerList.add(header);
}","public boolean add(SegmentHeader header,boolean loading,SegmentBuilder.SegmentConverter converter){
  checkThread();
  final HeaderInfo headerInfo=headerMap.get(header);
  if (headerInfo != null) {
    if (loading && headerInfo.slot == null) {
      headerInfo.slot=new SlotFuture<SegmentBody>();
      return true;
    }
    return false;
  }
  headerMap.put(header,new HeaderInfo(loading ? new SlotFuture<SegmentBody>() : null));
  final List bitkeyKey=makeBitkeyKey(header);
  List<SegmentHeader> headerList=bitkeyMap.get(bitkeyKey);
  if (headerList == null) {
    headerList=new ArrayList<SegmentHeader>();
    bitkeyMap.put(bitkeyKey,headerList);
  }
  headerList.add(header);
  final List factKey=makeFactKey(header);
  FactInfo factInfo=factMap.get(factKey);
  if (factInfo == null) {
    factInfo=new FactInfo();
    factMap.put(factKey,factInfo);
  }
  factInfo.headerList.add(header);
  factInfo.bitkeyPoset.add(header.getConstrainedColumnsBitKey());
  if (converter != null) {
    factInfo.converter=converter;
  }
  final List fuzzyFactKey=makeFuzzyFactKey(header);
  FuzzyFactInfo fuzzyFactInfo=fuzzyFactMap.get(fuzzyFactKey);
  if (fuzzyFactInfo == null) {
    fuzzyFactInfo=new FuzzyFactInfo();
    fuzzyFactMap.put(fuzzyFactKey,fuzzyFactInfo);
  }
  fuzzyFactInfo.headerList.add(header);
  return true;
}",0.9803770681031164
50911,"public boolean isDone(){
  stateLock.readLock().lock();
  try {
    return done;
  }
  finally {
    stateLock.readLock().unlock();
  }
}","public boolean isDone(){
  stateLock.readLock().lock();
  try {
    return done || cancelled || throwable != null;
  }
  finally {
    stateLock.readLock().unlock();
  }
}",0.8896103896103896
50912,"protected GroupingSet getGroupingSet(Execution execution,String[] tableNames,String[] fieldNames,String[][] fieldValues,String cubeName,String measure){
  final RolapCube cube=getCube(cubeName);
  final BatchLoader fbcr=new BatchLoader(Locus.peek(),execution.getMondrianStatement().getMondrianConnection().getServer().getAggregationManager().cacheMgr,cube.getStar().getSqlQueryDialect(),cube);
  BatchLoader.Batch batch=createBatch(fbcr,tableNames,fieldNames,fieldValues,cubeName,measure);
  GroupingSetsCollector collector=new GroupingSetsCollector(true);
  final List<Future<Map<Segment,SegmentWithData>>> segmentFutures=new ArrayList<Future<Map<Segment,SegmentWithData>>>();
  batch.loadAggregation(collector,segmentFutures);
  return collector.getGroupingSets().get(0);
}","protected GroupingSet getGroupingSet(final String[] tableNames,final String[] fieldNames,final String[][] fieldValues,final String cubeName,final String measure){
  return Locus.execute(((RolapConnection)getConnection()),""String_Node_Str"",new Locus.Action<GroupingSet>(){
    public GroupingSet execute(){
      final RolapCube cube=getCube(cubeName);
      final BatchLoader fbcr=new BatchLoader(Locus.peek(),((RolapConnection)getConnection()).getServer().getAggregationManager().cacheMgr,cube.getStar().getSqlQueryDialect(),cube);
      BatchLoader.Batch batch=createBatch(fbcr,tableNames,fieldNames,fieldValues,cubeName,measure);
      GroupingSetsCollector collector=new GroupingSetsCollector(true);
      final List<Future<Map<Segment,SegmentWithData>>> segmentFutures=new ArrayList<Future<Map<Segment,SegmentWithData>>>();
      batch.loadAggregation(collector,segmentFutures);
      return collector.getGroupingSets().get(0);
    }
  }
);
}",0.8176538908246226
50913,"/** 
 * Finds rollup candidates among a list of headers with the same dimensionality. <p>For each column that is being aggregated away, we need to ensure that we have all values of that column. If the column is wildcarded, it's easy. For example, if we wish to roll up to create Segment1:</p> <pre>Segment1(Year=1997, MaritalStatus=*)</pre> <p>then clearly Segment2:</p> <pre>Segment2(Year=1997, MaritalStatus=*, Gender=*, Nation=*)</pre> <p>has all gender and Nation values. If the values are specified as a list:</p> <pre>Segment3(Year=1997, MaritalStatus=*, Gender={M, F}, Nation=*)</pre> <p>then we need to check the metadata. We see that Gender has two distinct values in the database, and we have two values, therefore we have all of them.</p> <p>What if we have multiple non-wildcard columns? Consider:</p> <pre> Segment4(Year=1997, MaritalStatus=*, Gender={M}, Nation={Mexico, USA}) Segment5(Year=1997, MaritalStatus=*, Gender={F}, Nation={USA}) Segment6(Year=1997, MaritalStatus=*, Gender={F, M}, Nation={Canada, Mexico, Honduras, Belize}) </pre> <p>The problem is similar to finding whether a collection of rectangular regions covers a rectangle (or, generalizing to n dimensions, an n-cube). Or better, find a minimal collection of regions.</p> <p>Our algorithm solves it by iterating over all combinations of values. Those combinations are exponential in theory, but tractible in practice, using the following trick. The algorithm reduces the number of combinations by looking for values that are always treated the same. In the above, Canada, Honduras and Belize are always treated the same, so to prove covering, it is sufficient to prove that all combinations involving Canada are covered.</p>
 * @param coordinates Coordinates
 * @param list List to write candidates to
 * @param headers Headers of candidate segments
 */
private void findRollupCandidatesAmong(Map<String,Comparable> coordinates,List<List<SegmentHeader>> list,List<SegmentHeader> headers){
  final List<Pair<SegmentHeader,List<SegmentColumn>>> matchingHeaders=new ArrayList<Pair<SegmentHeader,List<SegmentColumn>>>();
  headerLoop:   for (  SegmentHeader header : headers) {
    if (!header.getExcludedRegions().isEmpty()) {
      continue;
    }
    List<SegmentColumn> nonWildcards=new ArrayList<SegmentColumn>();
    for (    SegmentColumn column : header.getConstrainedColumns()) {
      final SegmentColumn constrainedColumn=header.getConstrainedColumn(column.columnExpression);
      if (coordinates.containsKey(column.columnExpression)) {
        Comparable value=coordinates.get(column.columnExpression);
        if (value == null) {
          value=RolapUtil.sqlNullValue;
        }
        if (constrainedColumn.values != null && !constrainedColumn.values.contains(value)) {
          continue headerLoop;
        }
      }
 else {
        if (constrainedColumn.values != null) {
          nonWildcards.add(constrainedColumn);
        }
      }
    }
    if (nonWildcards.isEmpty()) {
      list.add(Collections.singletonList(header));
    }
 else {
      matchingHeaders.add(Pair.of(header,nonWildcards));
    }
  }
  if (matchingHeaders.size() < 2) {
    return;
  }
  final List<SegmentColumn> columnList=new ArrayList<SegmentColumn>();
  final List<String> columnNameList=new ArrayList<String>();
  for (  Pair<SegmentHeader,List<SegmentColumn>> pair : matchingHeaders) {
    for (    SegmentColumn column : pair.right) {
      if (!columnNameList.contains(column.columnExpression)) {
        final int valueCount=column.getValueCount();
        if (valueCount <= 0) {
          return;
        }
        columnList.add(column);
        columnNameList.add(column.columnExpression);
      }
    }
  }
  final List<List<Comparable>> valueLists=new ArrayList<List<Comparable>>();
  for (  SegmentColumn column : columnList) {
    final SortedMap<Comparable,BitSet> valueMap=new TreeMap<Comparable,BitSet>(RolapUtil.ROLAP_COMPARATOR);
    int h=-1;
    for (    SegmentHeader header : Pair.leftIter(matchingHeaders)) {
      ++h;
      final SegmentColumn column1=header.getConstrainedColumn(column.columnExpression);
      if (column1.getValues() == null) {
        for (        Entry<Comparable,BitSet> entry : valueMap.entrySet()) {
          for (int pos=0; pos < entry.getValue().cardinality(); pos++) {
            entry.getValue().set(pos);
          }
        }
      }
 else {
        for (        Comparable value : column1.getValues()) {
          BitSet bitSet=valueMap.get(value);
          if (bitSet == null) {
            bitSet=new BitSet();
            valueMap.put(value,bitSet);
          }
          bitSet.set(h);
        }
      }
    }
    if (valueMap.size() < column.valueCount) {
      return;
    }
    final Map<BitSet,Comparable> eqclassPrimaryValues=new HashMap<BitSet,Comparable>();
    for (    Map.Entry<Comparable,BitSet> entry : valueMap.entrySet()) {
      final BitSet bitSet=entry.getValue();
      if (!eqclassPrimaryValues.containsKey(bitSet)) {
        final Comparable value=entry.getKey();
        eqclassPrimaryValues.put(bitSet,value);
      }
    }
    valueLists.add(new ArrayList<Comparable>(eqclassPrimaryValues.values()));
  }
  final CartesianProductList<Comparable> tuples=new CartesianProductList<Comparable>(valueLists);
  final List<SegmentHeader> usedSegments=new ArrayList<SegmentHeader>();
  final List<SegmentHeader> unusedSegments=new ArrayList<SegmentHeader>(headers);
  tupleLoop:   for (  List<Comparable> tuple : tuples) {
    for (    SegmentHeader segment : usedSegments) {
      if (contains(segment,tuple,columnNameList)) {
        continue tupleLoop;
      }
    }
    for (    SegmentHeader segment : unusedSegments) {
      if (contains(segment,tuple,columnNameList)) {
        unusedSegments.remove(segment);
        usedSegments.add(segment);
        continue tupleLoop;
      }
    }
    return;
  }
  list.add(usedSegments);
}","/** 
 * Finds rollup candidates among a list of headers with the same dimensionality. <p>For each column that is being aggregated away, we need to ensure that we have all values of that column. If the column is wildcarded, it's easy. For example, if we wish to roll up to create Segment1:</p> <pre>Segment1(Year=1997, MaritalStatus=*)</pre> <p>then clearly Segment2:</p> <pre>Segment2(Year=1997, MaritalStatus=*, Gender=*, Nation=*)</pre> <p>has all gender and Nation values. If the values are specified as a list:</p> <pre>Segment3(Year=1997, MaritalStatus=*, Gender={M, F}, Nation=*)</pre> <p>then we need to check the metadata. We see that Gender has two distinct values in the database, and we have two values, therefore we have all of them.</p> <p>What if we have multiple non-wildcard columns? Consider:</p> <pre> Segment4(Year=1997, MaritalStatus=*, Gender={M}, Nation={Mexico, USA}) Segment5(Year=1997, MaritalStatus=*, Gender={F}, Nation={USA}) Segment6(Year=1997, MaritalStatus=*, Gender={F, M}, Nation={Canada, Mexico, Honduras, Belize}) </pre> <p>The problem is similar to finding whether a collection of rectangular regions covers a rectangle (or, generalizing to n dimensions, an n-cube). Or better, find a minimal collection of regions.</p> <p>Our algorithm solves it by iterating over all combinations of values. Those combinations are exponential in theory, but tractible in practice, using the following trick. The algorithm reduces the number of combinations by looking for values that are always treated the same. In the above, Canada, Honduras and Belize are always treated the same, so to prove covering, it is sufficient to prove that all combinations involving Canada are covered.</p>
 * @param coordinates Coordinates
 * @param list List to write candidates to
 * @param headers Headers of candidate segments
 */
private void findRollupCandidatesAmong(Map<String,Comparable> coordinates,List<List<SegmentHeader>> list,List<SegmentHeader> headers){
  final List<Pair<SegmentHeader,List<SegmentColumn>>> matchingHeaders=new ArrayList<Pair<SegmentHeader,List<SegmentColumn>>>();
  headerLoop:   for (  SegmentHeader header : headers) {
    if (!header.getExcludedRegions().isEmpty()) {
      continue;
    }
    List<SegmentColumn> nonWildcards=new ArrayList<SegmentColumn>();
    for (    SegmentColumn column : header.getConstrainedColumns()) {
      final SegmentColumn constrainedColumn=header.getConstrainedColumn(column.columnExpression);
      if (coordinates.containsKey(column.columnExpression)) {
        Comparable value=coordinates.get(column.columnExpression);
        if (value == null) {
          value=RolapUtil.sqlNullValue;
        }
        if (constrainedColumn.values != null && !constrainedColumn.values.contains(value)) {
          continue headerLoop;
        }
      }
 else {
        if (constrainedColumn.values != null) {
          nonWildcards.add(constrainedColumn);
        }
      }
    }
    if (nonWildcards.isEmpty()) {
      list.add(Collections.singletonList(header));
    }
 else {
      matchingHeaders.add(Pair.of(header,nonWildcards));
    }
  }
  if (matchingHeaders.size() < 2) {
    return;
  }
  final List<SegmentColumn> columnList=new ArrayList<SegmentColumn>();
  final List<String> columnNameList=new ArrayList<String>();
  for (  Pair<SegmentHeader,List<SegmentColumn>> pair : matchingHeaders) {
    for (    SegmentColumn column : pair.right) {
      if (!columnNameList.contains(column.columnExpression)) {
        final int valueCount=column.getValueCount();
        if (valueCount <= 0) {
          return;
        }
        columnList.add(column);
        columnNameList.add(column.columnExpression);
      }
    }
  }
  final List<List<Comparable>> valueLists=new ArrayList<List<Comparable>>();
  for (  SegmentColumn column : columnList) {
    final SortedMap<Comparable,BitSet> valueMap=new TreeMap<Comparable,BitSet>(RolapUtil.ROLAP_COMPARATOR);
    int h=-1;
    for (    SegmentHeader header : Pair.leftIter(matchingHeaders)) {
      ++h;
      final SegmentColumn column1=header.getConstrainedColumn(column.columnExpression);
      if (column1.getValues() == null) {
        for (        Entry<Comparable,BitSet> entry : valueMap.entrySet()) {
          for (int pos=0; pos < entry.getValue().cardinality(); pos++) {
            entry.getValue().set(pos);
          }
        }
      }
 else {
        for (        Comparable value : column1.getValues()) {
          BitSet bitSet=valueMap.get(value);
          if (bitSet == null) {
            bitSet=new BitSet();
            valueMap.put(value,bitSet);
          }
          bitSet.set(h);
        }
      }
    }
    if (valueMap.size() < column.valueCount) {
      return;
    }
    final Map<BitSet,Comparable> eqclassPrimaryValues=new HashMap<BitSet,Comparable>();
    for (    Map.Entry<Comparable,BitSet> entry : valueMap.entrySet()) {
      final BitSet bitSet=entry.getValue();
      if (!eqclassPrimaryValues.containsKey(bitSet)) {
        final Comparable value=entry.getKey();
        eqclassPrimaryValues.put(bitSet,value);
      }
    }
    valueLists.add(new ArrayList<Comparable>(eqclassPrimaryValues.values()));
  }
  final CartesianProductList<Comparable> tuples=new CartesianProductList<Comparable>(valueLists);
  final List<SegmentHeader> usedSegments=new ArrayList<SegmentHeader>();
  final List<SegmentHeader> unusedSegments=new ArrayList<SegmentHeader>(Pair.left(matchingHeaders));
  tupleLoop:   for (  List<Comparable> tuple : tuples) {
    for (    SegmentHeader segment : usedSegments) {
      if (contains(segment,tuple,columnNameList)) {
        continue tupleLoop;
      }
    }
    for (    SegmentHeader segment : unusedSegments) {
      if (contains(segment,tuple,columnNameList)) {
        unusedSegments.remove(segment);
        usedSegments.add(segment);
        continue tupleLoop;
      }
    }
    return;
  }
  list.add(usedSegments);
}",0.9972055212126344
50914,"public void remove(){
  iterator.remove();
}","public R remove(int index){
  Pair<L,R> pair=list.remove(index);
  return pair == null ? null : pair.right;
}",0.4444444444444444
50915,"/** 
 * Given a collection of segments, all of the same dimensionality, rolls up to create a segment with reduced dimensionality.
 * @param map Source segment headers and bodies
 * @param keepColumns A list of column names to keep as part ofthe rolled up segment.
 * @param targetBitkey The column bit key to match with theresulting segment.
 * @param rollupAggregator The aggregator to use to rollup.
 * @return Segment header and body of requested dimensionality
 */
public static Pair<SegmentHeader,SegmentBody> rollup(Map<SegmentHeader,SegmentBody> map,Set<String> keepColumns,BitKey targetBitkey,Aggregator rollupAggregator){
class AxisInfo {
    SegmentColumn column;
    SortedSet<Comparable> requestedValues;
    SortedSet<Comparable> valueSet;
    Comparable[] values;
    boolean hasNull;
    int src;
    boolean lostPredicate;
  }
  final SegmentHeader firstHeader=map.keySet().iterator().next();
  final AxisInfo[] axes=new AxisInfo[keepColumns.size()];
  int z=0, j=0;
  for (  SegmentColumn column : firstHeader.getConstrainedColumns()) {
    if (keepColumns.contains(column.columnExpression)) {
      final AxisInfo axisInfo=axes[z++]=new AxisInfo();
      axisInfo.src=j;
      axisInfo.column=column;
      axisInfo.requestedValues=column.values;
    }
    j++;
  }
  for (  Map.Entry<SegmentHeader,SegmentBody> entry : map.entrySet()) {
    final SegmentHeader header=entry.getKey();
    for (    AxisInfo axis : axes) {
      final SortedSet<Comparable> values=entry.getValue().getAxisValueSets()[axis.src];
      final SegmentColumn headerColumn=header.getConstrainedColumn(axis.column.columnExpression);
      final boolean hasNull=entry.getValue().getNullAxisFlags()[axis.src];
      final SortedSet<Comparable> requestedValues=headerColumn.getValues();
      if (axis.valueSet == null) {
        axis.valueSet=new TreeSet<Comparable>(values);
        axis.hasNull=hasNull;
        axis.requestedValues=requestedValues;
      }
 else {
        final SortedSet<Comparable> filteredValues;
        final boolean filteredHasNull;
        if (axis.requestedValues == null) {
          filteredValues=values;
          filteredHasNull=hasNull;
        }
 else {
          filteredValues=Util.intersect(values,axis.requestedValues);
          filteredHasNull=false;
        }
        axis.valueSet.addAll(filteredValues);
        axis.hasNull=axis.hasNull || filteredHasNull;
        if (!Util.equals(axis.requestedValues,requestedValues)) {
          if (axis.requestedValues == null) {
            axis.requestedValues=requestedValues;
          }
 else {
            axis.lostPredicate=true;
          }
        }
      }
    }
  }
  for (  AxisInfo axis : axes) {
    axis.values=axis.valueSet.toArray(new Comparable[axis.valueSet.size()]);
  }
  final Map<CellKey,List<Object>> cellValues=new HashMap<CellKey,List<Object>>();
  for (  Map.Entry<SegmentHeader,SegmentBody> entry : map.entrySet()) {
    final int[] pos=new int[axes.length];
    final Comparable[][] valueArrays=new Comparable[firstHeader.getConstrainedColumns().size()][];
    final SegmentBody body=entry.getValue();
    z=0;
    for (    SortedSet<Comparable> set : body.getAxisValueSets()) {
      valueArrays[z]=keepColumns.contains(firstHeader.getConstrainedColumns().get(z).columnExpression) ? set.toArray(new Comparable[set.size()]) : null;
      ++z;
    }
    Map<CellKey,Object> v=body.getValueMap();
    for (    Map.Entry<CellKey,Object> vEntry : v.entrySet()) {
      z=0;
      for (int i=0; i < vEntry.getKey().size(); i++) {
        final Comparable[] valueArray=valueArrays[i];
        if (valueArray == null) {
          continue;
        }
        final int ordinal=vEntry.getKey().getOrdinals()[i];
        final Comparable value=valueArray[ordinal];
        int targetOrdinal;
        if (value == null) {
          targetOrdinal=axes[z].valueSet.size();
        }
 else {
          targetOrdinal=Util.binarySearch(axes[z].values,0,axes[z].values.length,value);
        }
        pos[z++]=targetOrdinal;
      }
      final CellKey ck=CellKey.Generator.newCellKey(pos);
      if (!cellValues.containsKey(ck)) {
        cellValues.put(ck,new ArrayList<Object>());
      }
      cellValues.get(ck).add(vEntry.getValue());
    }
  }
  final List<Pair<SortedSet<Comparable>,Boolean>> axisList=new ArrayList<Pair<SortedSet<Comparable>,Boolean>>();
  final BitSet nullIndicators=new BitSet(axes.length);
  int nbValues=1;
  for (int i=0; i < axes.length; i++) {
    axisList.add(new Pair<SortedSet<Comparable>,Boolean>(axes[i].valueSet,axes[i].hasNull));
    nullIndicators.set(i,axes[i].hasNull);
    nbValues*=axes[i].values.length;
  }
  final int[] axisMultipliers=computeAxisMultipliers(axisList);
  final SegmentBody body;
  if (cellValues.size() == 0) {
    body=new DenseObjectSegmentBody(new Object[0],axisList);
  }
 else   if (SegmentLoader.useSparse(cellValues.size(),cellValues.size() - nullIndicators.cardinality())) {
    final Map<CellKey,Object> data=new HashMap<CellKey,Object>();
    for (    Entry<CellKey,List<Object>> entry : cellValues.entrySet()) {
      data.put(CellKey.Generator.newCellKey(entry.getKey().getOrdinals()),rollupAggregator.aggregate(entry.getValue()));
    }
    body=new SparseSegmentBody(data,axisList);
  }
 else {
    final Object peek=cellValues.entrySet().iterator().next().getValue().get(0);
    if (peek instanceof Double) {
      final double[] data=new double[nbValues];
      for (      Entry<CellKey,List<Object>> entry : cellValues.entrySet()) {
        final int offset=CellKey.Generator.getOffset(entry.getKey().getOrdinals(),axisMultipliers);
        data[offset]=(Double)rollupAggregator.aggregate(entry.getValue());
      }
      body=new DenseDoubleSegmentBody(nullIndicators,data,axisList);
    }
 else     if (peek instanceof Integer) {
      final int[] data=new int[cellValues.size()];
      for (      Entry<CellKey,List<Object>> entry : cellValues.entrySet()) {
        final int offset=CellKey.Generator.getOffset(entry.getKey().getOrdinals(),axisMultipliers);
        data[offset]=(Integer)rollupAggregator.aggregate(entry.getValue());
      }
      body=new DenseIntSegmentBody(nullIndicators,data,axisList);
    }
 else {
      final Object[] data=new Object[cellValues.size()];
      for (      Entry<CellKey,List<Object>> entry : cellValues.entrySet()) {
        final int offset=CellKey.Generator.getOffset(entry.getKey().getOrdinals(),axisMultipliers);
        data[offset]=(Object)rollupAggregator.aggregate(entry.getValue());
      }
      body=new DenseObjectSegmentBody(data,axisList);
    }
  }
  final List<SegmentColumn> constrainedColumns=new ArrayList<SegmentColumn>();
  for (int i=0; i < axes.length; i++) {
    AxisInfo axisInfo=axes[i];
    constrainedColumns.add(new SegmentColumn(axisInfo.column.getColumnExpression(),axisInfo.column.getValueCount(),axisInfo.lostPredicate ? axisList.get(i).left : axisInfo.column.values));
  }
  final SegmentHeader header=new SegmentHeader(firstHeader.schemaName,firstHeader.schemaChecksum,firstHeader.cubeName,firstHeader.measureName,constrainedColumns,firstHeader.compoundPredicates,firstHeader.rolapStarFactTableName,targetBitkey,Collections.<SegmentColumn>emptyList());
  return Pair.of(header,body);
}","/** 
 * Given a collection of segments, all of the same dimensionality, rolls up to create a segment with reduced dimensionality.
 * @param map Source segment headers and bodies
 * @param keepColumns A list of column names to keep as part ofthe rolled up segment.
 * @param targetBitkey The column bit key to match with theresulting segment.
 * @param rollupAggregator The aggregator to use to rollup.
 * @return Segment header and body of requested dimensionality
 */
public static Pair<SegmentHeader,SegmentBody> rollup(Map<SegmentHeader,SegmentBody> map,Set<String> keepColumns,BitKey targetBitkey,Aggregator rollupAggregator){
class AxisInfo {
    SegmentColumn column;
    SortedSet<Comparable> requestedValues;
    SortedSet<Comparable> valueSet;
    Comparable[] values;
    boolean hasNull;
    int src;
    boolean lostPredicate;
  }
  final SegmentHeader firstHeader=map.keySet().iterator().next();
  final AxisInfo[] axes=new AxisInfo[keepColumns.size()];
  int z=0, j=0;
  for (  SegmentColumn column : firstHeader.getConstrainedColumns()) {
    if (keepColumns.contains(column.columnExpression)) {
      final AxisInfo axisInfo=axes[z++]=new AxisInfo();
      axisInfo.src=j;
      axisInfo.column=column;
      axisInfo.requestedValues=column.values;
    }
    j++;
  }
  for (  Map.Entry<SegmentHeader,SegmentBody> entry : map.entrySet()) {
    final SegmentHeader header=entry.getKey();
    for (    AxisInfo axis : axes) {
      final SortedSet<Comparable> values=entry.getValue().getAxisValueSets()[axis.src];
      final SegmentColumn headerColumn=header.getConstrainedColumn(axis.column.columnExpression);
      final boolean hasNull=entry.getValue().getNullAxisFlags()[axis.src];
      final SortedSet<Comparable> requestedValues=headerColumn.getValues();
      if (axis.valueSet == null) {
        axis.valueSet=new TreeSet<Comparable>(values);
        axis.hasNull=hasNull;
        axis.requestedValues=requestedValues;
      }
 else {
        final SortedSet<Comparable> filteredValues;
        final boolean filteredHasNull;
        if (axis.requestedValues == null) {
          filteredValues=values;
          filteredHasNull=hasNull;
        }
 else {
          filteredValues=Util.intersect(values,axis.requestedValues);
          filteredHasNull=false;
        }
        axis.valueSet.addAll(filteredValues);
        axis.hasNull=axis.hasNull || filteredHasNull;
        if (!Util.equals(axis.requestedValues,requestedValues)) {
          if (axis.requestedValues == null) {
            axis.requestedValues=requestedValues;
          }
 else {
            axis.lostPredicate=true;
          }
        }
      }
    }
  }
  for (  AxisInfo axis : axes) {
    axis.values=axis.valueSet.toArray(new Comparable[axis.valueSet.size()]);
  }
  final Map<CellKey,List<Object>> cellValues=new HashMap<CellKey,List<Object>>();
  for (  Map.Entry<SegmentHeader,SegmentBody> entry : map.entrySet()) {
    final int[] pos=new int[axes.length];
    final Comparable[][] valueArrays=new Comparable[firstHeader.getConstrainedColumns().size()][];
    final SegmentBody body=entry.getValue();
    z=0;
    for (    SortedSet<Comparable> set : body.getAxisValueSets()) {
      valueArrays[z]=keepColumns.contains(firstHeader.getConstrainedColumns().get(z).columnExpression) ? set.toArray(new Comparable[set.size()]) : null;
      ++z;
    }
    Map<CellKey,Object> v=body.getValueMap();
    for (    Map.Entry<CellKey,Object> vEntry : v.entrySet()) {
      z=0;
      for (int i=0; i < vEntry.getKey().size(); i++) {
        final Comparable[] valueArray=valueArrays[i];
        if (valueArray == null) {
          continue;
        }
        final int ordinal=vEntry.getKey().getOrdinals()[i];
        final int targetOrdinal;
        if (axes[z].hasNull && ordinal == valueArray.length) {
          targetOrdinal=axes[z].valueSet.size();
        }
 else {
          final Comparable value=valueArray[ordinal];
          if (value == null) {
            targetOrdinal=axes[z].valueSet.size();
          }
 else {
            targetOrdinal=Util.binarySearch(axes[z].values,0,axes[z].values.length,value);
          }
        }
        pos[z++]=targetOrdinal;
      }
      final CellKey ck=CellKey.Generator.newCellKey(pos);
      if (!cellValues.containsKey(ck)) {
        cellValues.put(ck,new ArrayList<Object>());
      }
      cellValues.get(ck).add(vEntry.getValue());
    }
  }
  final List<Pair<SortedSet<Comparable>,Boolean>> axisList=new ArrayList<Pair<SortedSet<Comparable>,Boolean>>();
  final BitSet nullIndicators=new BitSet(axes.length);
  int nbValues=1;
  for (int i=0; i < axes.length; i++) {
    axisList.add(new Pair<SortedSet<Comparable>,Boolean>(axes[i].valueSet,axes[i].hasNull));
    nullIndicators.set(i,axes[i].hasNull);
    nbValues*=axes[i].hasNull ? axes[i].values.length + 1 : axes[i].values.length;
  }
  final int[] axisMultipliers=computeAxisMultipliers(axisList);
  final SegmentBody body;
  if (cellValues.size() == 0) {
    body=new DenseObjectSegmentBody(new Object[0],axisList);
  }
 else   if (SegmentLoader.useSparse(cellValues.size(),cellValues.size() - nullIndicators.cardinality())) {
    final Map<CellKey,Object> data=new HashMap<CellKey,Object>();
    for (    Entry<CellKey,List<Object>> entry : cellValues.entrySet()) {
      data.put(CellKey.Generator.newCellKey(entry.getKey().getOrdinals()),rollupAggregator.aggregate(entry.getValue()));
    }
    body=new SparseSegmentBody(data,axisList);
  }
 else {
    final Object peek=cellValues.entrySet().iterator().next().getValue().get(0);
    if (peek instanceof Double) {
      final double[] data=new double[nbValues];
      for (      Entry<CellKey,List<Object>> entry : cellValues.entrySet()) {
        final int offset=CellKey.Generator.getOffset(entry.getKey().getOrdinals(),axisMultipliers);
        data[offset]=(Double)rollupAggregator.aggregate(entry.getValue());
      }
      body=new DenseDoubleSegmentBody(nullIndicators,data,axisList);
    }
 else     if (peek instanceof Integer) {
      final int[] data=new int[nbValues];
      for (      Entry<CellKey,List<Object>> entry : cellValues.entrySet()) {
        final int offset=CellKey.Generator.getOffset(entry.getKey().getOrdinals(),axisMultipliers);
        data[offset]=(Integer)rollupAggregator.aggregate(entry.getValue());
      }
      body=new DenseIntSegmentBody(nullIndicators,data,axisList);
    }
 else {
      final Object[] data=new Object[nbValues];
      for (      Entry<CellKey,List<Object>> entry : cellValues.entrySet()) {
        final int offset=CellKey.Generator.getOffset(entry.getKey().getOrdinals(),axisMultipliers);
        data[offset]=(Object)rollupAggregator.aggregate(entry.getValue());
      }
      body=new DenseObjectSegmentBody(data,axisList);
    }
  }
  final List<SegmentColumn> constrainedColumns=new ArrayList<SegmentColumn>();
  for (int i=0; i < axes.length; i++) {
    AxisInfo axisInfo=axes[i];
    constrainedColumns.add(new SegmentColumn(axisInfo.column.getColumnExpression(),axisInfo.column.getValueCount(),axisInfo.lostPredicate ? axisList.get(i).left : axisInfo.column.values));
  }
  final SegmentHeader header=new SegmentHeader(firstHeader.schemaName,firstHeader.schemaChecksum,firstHeader.cubeName,firstHeader.measureName,constrainedColumns,firstHeader.compoundPredicates,firstHeader.rolapStarFactTableName,targetBitkey,Collections.<SegmentColumn>emptyList());
  return Pair.of(header,body);
}",0.9662844662844664
50916,"/** 
 * Computes an expression for each element of a list, and aggregates the result according to the evaluation context's current aggregation strategy.
 * @param calc Compiled expression to evaluate a scalar
 * @param evaluator Evaluation context
 * @param tupleList List of members or tuples
 * @return Aggregated result
 */
public static Object aggregate(Calc calc,Evaluator evaluator,TupleList tupleList){
  Aggregator aggregator=(Aggregator)evaluator.getProperty(Property.AGGREGATION_TYPE.name,null);
  if (aggregator == null) {
    throw newEvalException(null,""String_Node_Str"");
  }
  Aggregator rollup=aggregator.getRollup();
  if (rollup == null) {
    throw newEvalException(null,""String_Node_Str"" + aggregator + ""String_Node_Str"");
  }
  if (aggregator != RolapAggregator.DistinctCount) {
    final int savepoint=evaluator.savepoint();
    evaluator.setNonEmpty(false);
    final Object o=rollup.aggregate(evaluator,tupleList,calc);
    evaluator.restore(savepoint);
    return o;
  }
  if (tupleList.size() == 0) {
    return DoubleNull;
  }
  if (evaluator instanceof RolapEvaluator && ((RolapEvaluator)evaluator).getDialect().supportsUnlimitedValueList()) {
  }
 else {
    tupleList=optimizeTupleList(evaluator,tupleList);
  }
  Evaluator evaluator2=evaluator.pushAggregation(tupleList);
  evaluator2.setNonEmpty(false);
  return evaluator2.evaluateCurrent();
}","/** 
 * Computes an expression for each element of a list, and aggregates the result according to the evaluation context's current aggregation strategy.
 * @param calc Compiled expression to evaluate a scalar
 * @param evaluator Evaluation context
 * @param tupleList List of members or tuples
 * @return Aggregated result
 */
public static Object aggregate(Calc calc,Evaluator evaluator,TupleList tupleList){
  Aggregator aggregator=(Aggregator)evaluator.getProperty(Property.AGGREGATION_TYPE.name,null);
  if (aggregator == null) {
    throw newEvalException(null,""String_Node_Str"");
  }
  Aggregator rollup=aggregator.getRollup();
  if (rollup == null) {
    throw newEvalException(null,""String_Node_Str"" + aggregator + ""String_Node_Str"");
  }
  if (aggregator != RolapAggregator.DistinctCount) {
    final int savepoint=evaluator.savepoint();
    evaluator.setNonEmpty(false);
    final Object o=rollup.aggregate(evaluator,tupleList,calc);
    evaluator.restore(savepoint);
    return o;
  }
  if (tupleList.size() == 0) {
    return DoubleNull;
  }
  if (evaluator instanceof RolapEvaluator && ((RolapEvaluator)evaluator).getDialect().supportsUnlimitedValueList()) {
  }
 else {
    tupleList=optimizeTupleList(evaluator,tupleList,true);
  }
  Evaluator evaluator2=evaluator.pushAggregation(tupleList);
  evaluator2.setNonEmpty(false);
  return evaluator2.evaluateCurrent();
}",0.9981864345302864
50917,"public static TupleList optimizeTupleList(Evaluator evaluator,TupleList tupleList){
  if (!canOptimize(evaluator,tupleList)) {
    return tupleList;
  }
  if (false) {
    tupleList=removeOverlappingTupleEntries(tupleList);
  }
  tupleList=optimizeChildren(tupleList,evaluator.getSchemaReader(),evaluator.getMeasureCube());
  checkIfAggregationSizeIsTooLarge(tupleList);
  return tupleList;
}","public static TupleList optimizeTupleList(Evaluator evaluator,TupleList tupleList,boolean checkSize){
  if (!canOptimize(evaluator,tupleList)) {
    return tupleList;
  }
  if (false) {
    tupleList=removeOverlappingTupleEntries(tupleList);
  }
  tupleList=optimizeChildren(tupleList,evaluator.getSchemaReader(),evaluator.getMeasureCube());
  if (checkSize) {
    checkIfAggregationSizeIsTooLarge(tupleList);
  }
  return tupleList;
}",0.9480048367593712
50918,"/** 
 * Creates a RolapResult.
 * @param execution Execution of a statement
 * @param execute Whether to execute the query
 */
RolapResult(final Execution execution,boolean execute){
  super(execution,null);
  this.point=CellKey.Generator.newCellKey(axes.length);
  final AggregationManager aggMgr=execution.getMondrianStatement().getMondrianConnection().getServer().getAggregationManager();
  this.aggregatingReader=aggMgr.getCacheCellReader();
  final int expDeps=MondrianProperties.instance().TestExpDependencies.get();
  if (expDeps > 0) {
    this.evaluator=new RolapDependencyTestingEvaluator(this,expDeps);
  }
 else {
    final RolapEvaluatorRoot root=new RolapResultEvaluatorRoot(this);
    if (statement.getProfileHandler() != null) {
      this.evaluator=new RolapProfilingEvaluator(root);
    }
 else {
      this.evaluator=new RolapEvaluator(root);
    }
  }
  RolapCube cube=(RolapCube)query.getCube();
  this.batchingReader=new FastBatchingCellReader(execution,cube,aggMgr);
  this.cellInfos=(query.axes.length > 4) ? new CellInfoMap(point) : new CellInfoPool(query.axes.length);
  if (!execute) {
    return;
  }
  boolean normalExecution=true;
  try {
    cube.clearCachedAggregations();
    final AxisMember axisMembers=new AxisMember();
    final List<Member> nonDefaultAllMembers=new ArrayList<Member>();
    List<List<Member>> nonAllMembers=new ArrayList<List<Member>>();
    final List<Member> measureMembers=new ArrayList<Member>();
    loadSpecialMembers(nonDefaultAllMembers,nonAllMembers,measureMembers);
    query.clearEvalCache();
    query.putEvalCache(""String_Node_Str"",nonDefaultAllMembers);
    final List<List<Member>> emptyNonAllMembers=Collections.emptyList();
    slicerEvaluator=evaluator.push();
    axisMembers.setSlicer(true);
    loadMembers(emptyNonAllMembers,evaluator,query.getSlicerAxis(),query.slicerCalc,axisMembers);
    axisMembers.setSlicer(false);
    final RolapEvaluator savedEvaluator=evaluator.push();
    if (!axisMembers.isEmpty()) {
      for (      Member m : axisMembers) {
        if (m == null) {
          break;
        }
        evaluator.setSlicerContext(m);
        if (m.isMeasure()) {
          measureMembers.clear();
        }
      }
      replaceNonAllMembers(nonAllMembers,axisMembers);
      axisMembers.clearMembers();
    }
    slicerEvaluator=evaluator.push();
    boolean changed=false;
    axisMembers.clearTotalCellCount();
    for (int i=0; i < axes.length; i++) {
      final QueryAxis axis=query.axes[i];
      final Calc calc=query.axisCalcs[i];
      loadMembers(emptyNonAllMembers,evaluator,axis,calc,axisMembers);
    }
    if (!axisMembers.isEmpty()) {
      for (      Member m : axisMembers) {
        if (m.isMeasure()) {
          measureMembers.clear();
        }
      }
      changed=replaceNonAllMembers(nonAllMembers,axisMembers);
      axisMembers.clearMembers();
    }
    if (changed) {
      axisMembers.countOnly(true);
      axisMembers.clearTotalCellCount();
      final int savepoint=evaluator.savepoint();
      for (int i=0; i < axes.length; i++) {
        final QueryAxis axis=query.axes[i];
        final Calc calc=query.axisCalcs[i];
        loadMembers(nonAllMembers,evaluator,axis,calc,axisMembers);
        evaluator.restore(savepoint);
      }
    }
    axisMembers.checkLimit();
    RolapEvaluator slicerEvaluator;
    do {
      TupleIterable tupleIterable=evalExecute(nonAllMembers,nonAllMembers.size() - 1,savedEvaluator,query.getSlicerAxis(),query.slicerCalc);
      TupleList tupleList=TupleCollections.materialize(tupleIterable,true);
      this.slicerAxis=new RolapAxis(tupleList);
      slicerEvaluator=this.evaluator;
      if (tupleList.size() > 1) {
        tupleList=AggregateFunDef.AggregateCalc.optimizeTupleList(slicerEvaluator,tupleList);
        final Calc valueCalc=new ValueCalc(new DummyExp(new ScalarType()));
        final TupleList tupleList1=tupleList;
        final Calc calc=new GenericCalc(new DummyExp(query.slicerCalc.getType())){
          public Object evaluate(          Evaluator evaluator){
            return AggregateFunDef.AggregateCalc.aggregate(valueCalc,evaluator,tupleList1);
          }
        }
;
        final List<RolapHierarchy> hierarchyList=new AbstractList<RolapHierarchy>(){
          final List<Member> pos0=tupleList1.get(0);
          public RolapHierarchy get(          int index){
            return ((RolapMember)pos0.get(index)).getHierarchy();
          }
          public int size(){
            return pos0.size();
          }
        }
;
        evaluator.addCalculation(new RolapTupleCalculation(hierarchyList,calc),true);
      }
    }
 while (phase());
    final int savepoint=evaluator.savepoint();
    do {
      try {
        boolean redo;
        do {
          evaluator.restore(savepoint);
          redo=false;
          for (int i=0; i < axes.length; i++) {
            QueryAxis axis=query.axes[i];
            final Calc calc=query.axisCalcs[i];
            TupleIterable tupleIterable=evalExecute(nonAllMembers,nonAllMembers.size() - 1,evaluator,axis,calc);
            if (!nonAllMembers.isEmpty()) {
              final TupleIterator tupleIterator=tupleIterable.tupleIterator();
              if (tupleIterator.hasNext()) {
                List<Member> tuple0=tupleIterator.next();
                for (                Member m : tuple0) {
                  if (m.isCalculated()) {
                    CalculatedMeasureVisitor visitor=new CalculatedMeasureVisitor();
                    m.getExpression().accept(visitor);
                    Dimension dimension=visitor.dimension;
                    if (removeDimension(dimension,nonAllMembers)) {
                      redo=true;
                    }
                  }
                }
              }
            }
            this.axes[i]=new RolapAxis(TupleCollections.materialize(tupleIterable,false));
          }
        }
 while (redo);
      }
 catch (      CellRequestQuantumExceededException e) {
      }
    }
 while (phase());
    evaluator.restore(savepoint);
    final Locus locus=new Locus(execution,null,""String_Node_Str"");
    Locus.push(locus);
    try {
      executeBody(slicerEvaluator,query,new int[axes.length]);
    }
  finally {
      Locus.pop(locus);
    }
    if (this.cellInfos.size() > 10000) {
      this.cellInfos.trimToSize();
    }
  }
 catch (  ResultLimitExceededException ex) {
    normalExecution=false;
    evaluator=null;
    slicerEvaluator=null;
    cellInfos=null;
    batchingReader=null;
    for (int i=0; i < axes.length; i++) {
      axes[i]=null;
    }
    slicerAxis=null;
    query.clearEvalCache();
    throw ex;
  }
 finally {
    if (normalExecution) {
      evaluator.clearExpResultCache(true);
    }
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug(""String_Node_Str"" + Util.printMemory());
    }
  }
}","/** 
 * Creates a RolapResult.
 * @param execution Execution of a statement
 * @param execute Whether to execute the query
 */
RolapResult(final Execution execution,boolean execute){
  super(execution,null);
  this.point=CellKey.Generator.newCellKey(axes.length);
  final AggregationManager aggMgr=execution.getMondrianStatement().getMondrianConnection().getServer().getAggregationManager();
  this.aggregatingReader=aggMgr.getCacheCellReader();
  final int expDeps=MondrianProperties.instance().TestExpDependencies.get();
  if (expDeps > 0) {
    this.evaluator=new RolapDependencyTestingEvaluator(this,expDeps);
  }
 else {
    final RolapEvaluatorRoot root=new RolapResultEvaluatorRoot(this);
    if (statement.getProfileHandler() != null) {
      this.evaluator=new RolapProfilingEvaluator(root);
    }
 else {
      this.evaluator=new RolapEvaluator(root);
    }
  }
  RolapCube cube=(RolapCube)query.getCube();
  this.batchingReader=new FastBatchingCellReader(execution,cube,aggMgr);
  this.cellInfos=(query.axes.length > 4) ? new CellInfoMap(point) : new CellInfoPool(query.axes.length);
  if (!execute) {
    return;
  }
  boolean normalExecution=true;
  try {
    cube.clearCachedAggregations();
    final AxisMember axisMembers=new AxisMember();
    final List<Member> nonDefaultAllMembers=new ArrayList<Member>();
    List<List<Member>> nonAllMembers=new ArrayList<List<Member>>();
    final List<Member> measureMembers=new ArrayList<Member>();
    loadSpecialMembers(nonDefaultAllMembers,nonAllMembers,measureMembers);
    query.clearEvalCache();
    query.putEvalCache(""String_Node_Str"",nonDefaultAllMembers);
    final List<List<Member>> emptyNonAllMembers=Collections.emptyList();
    slicerEvaluator=evaluator.push();
    axisMembers.setSlicer(true);
    loadMembers(emptyNonAllMembers,evaluator,query.getSlicerAxis(),query.slicerCalc,axisMembers);
    axisMembers.setSlicer(false);
    final RolapEvaluator savedEvaluator=evaluator.push();
    if (!axisMembers.isEmpty()) {
      for (      Member m : axisMembers) {
        if (m == null) {
          break;
        }
        evaluator.setSlicerContext(m);
        if (m.isMeasure()) {
          measureMembers.clear();
        }
      }
      replaceNonAllMembers(nonAllMembers,axisMembers);
      axisMembers.clearMembers();
    }
    slicerEvaluator=evaluator.push();
    boolean changed=false;
    axisMembers.clearTotalCellCount();
    for (int i=0; i < axes.length; i++) {
      final QueryAxis axis=query.axes[i];
      final Calc calc=query.axisCalcs[i];
      loadMembers(emptyNonAllMembers,evaluator,axis,calc,axisMembers);
    }
    if (!axisMembers.isEmpty()) {
      for (      Member m : axisMembers) {
        if (m.isMeasure()) {
          measureMembers.clear();
        }
      }
      changed=replaceNonAllMembers(nonAllMembers,axisMembers);
      axisMembers.clearMembers();
    }
    if (changed) {
      axisMembers.countOnly(true);
      axisMembers.clearTotalCellCount();
      final int savepoint=evaluator.savepoint();
      for (int i=0; i < axes.length; i++) {
        final QueryAxis axis=query.axes[i];
        final Calc calc=query.axisCalcs[i];
        loadMembers(nonAllMembers,evaluator,axis,calc,axisMembers);
        evaluator.restore(savepoint);
      }
    }
    axisMembers.checkLimit();
    RolapEvaluator slicerEvaluator;
    do {
      TupleIterable tupleIterable=evalExecute(nonAllMembers,nonAllMembers.size() - 1,savedEvaluator,query.getSlicerAxis(),query.slicerCalc);
      TupleList tupleList=TupleCollections.materialize(tupleIterable,true);
      this.slicerAxis=new RolapAxis(tupleList);
      slicerEvaluator=this.evaluator;
      if (tupleList.size() > 1) {
        tupleList=AggregateFunDef.AggregateCalc.optimizeTupleList(slicerEvaluator,tupleList,false);
        final Calc valueCalc=new ValueCalc(new DummyExp(new ScalarType()));
        final TupleList tupleList1=tupleList;
        final Calc calc=new GenericCalc(new DummyExp(query.slicerCalc.getType())){
          public Object evaluate(          Evaluator evaluator){
            return AggregateFunDef.AggregateCalc.aggregate(valueCalc,evaluator,tupleList1);
          }
        }
;
        final List<RolapHierarchy> hierarchyList=new AbstractList<RolapHierarchy>(){
          final List<Member> pos0=tupleList1.get(0);
          public RolapHierarchy get(          int index){
            return ((RolapMember)pos0.get(index)).getHierarchy();
          }
          public int size(){
            return pos0.size();
          }
        }
;
        evaluator.addCalculation(new RolapTupleCalculation(hierarchyList,calc),true);
      }
    }
 while (phase());
    final int savepoint=evaluator.savepoint();
    do {
      try {
        boolean redo;
        do {
          evaluator.restore(savepoint);
          redo=false;
          for (int i=0; i < axes.length; i++) {
            QueryAxis axis=query.axes[i];
            final Calc calc=query.axisCalcs[i];
            TupleIterable tupleIterable=evalExecute(nonAllMembers,nonAllMembers.size() - 1,evaluator,axis,calc);
            if (!nonAllMembers.isEmpty()) {
              final TupleIterator tupleIterator=tupleIterable.tupleIterator();
              if (tupleIterator.hasNext()) {
                List<Member> tuple0=tupleIterator.next();
                for (                Member m : tuple0) {
                  if (m.isCalculated()) {
                    CalculatedMeasureVisitor visitor=new CalculatedMeasureVisitor();
                    m.getExpression().accept(visitor);
                    Dimension dimension=visitor.dimension;
                    if (removeDimension(dimension,nonAllMembers)) {
                      redo=true;
                    }
                  }
                }
              }
            }
            this.axes[i]=new RolapAxis(TupleCollections.materialize(tupleIterable,false));
          }
        }
 while (redo);
      }
 catch (      CellRequestQuantumExceededException e) {
      }
    }
 while (phase());
    evaluator.restore(savepoint);
    final Locus locus=new Locus(execution,null,""String_Node_Str"");
    Locus.push(locus);
    try {
      executeBody(slicerEvaluator,query,new int[axes.length]);
    }
  finally {
      Locus.pop(locus);
    }
    if (this.cellInfos.size() > 10000) {
      this.cellInfos.trimToSize();
    }
  }
 catch (  ResultLimitExceededException ex) {
    normalExecution=false;
    evaluator=null;
    slicerEvaluator=null;
    cellInfos=null;
    batchingReader=null;
    for (int i=0; i < axes.length; i++) {
      axes[i]=null;
    }
    slicerAxis=null;
    query.clearEvalCache();
    throw ex;
  }
 finally {
    if (normalExecution) {
      evaluator.clearExpResultCache(true);
    }
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug(""String_Node_Str"" + Util.printMemory());
    }
  }
}",0.9995597299677136
50919,"public void testAggregationOverLargeListGeneratesError(){
  int origMaxConstraint=props.MaxConstraints.get();
  props.MaxConstraints.set(7);
  String result;
  final Dialect dialect=getTestContext().getDialect();
  if (dialect.getDatabaseProduct() == Dialect.DatabaseProduct.LUCIDDB) {
    result=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
 else {
    result=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
  assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",result);
  props.MaxConstraints.set(origMaxConstraint);
}","public void testAggregationOverLargeListGeneratesError(){
  propSaver.set(props.MaxConstraints,7);
  final boolean isLuciddb=getTestContext().getDialect().getDatabaseProduct() == Dialect.DatabaseProduct.LUCIDDB;
  assertQueryReturns(makeQuery(""String_Node_Str""),isLuciddb ? ""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" : ""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertQueryReturns(makeQuery(""String_Node_Str""),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.1893158388003749
50920,"/** 
 * For every restricting member in the current context, generates a WHERE condition and a join to the fact table.
 * @param sqlQuery the query to modify
 * @param aggStar Aggregate table, or null if query is against fact table
 * @param restrictMemberTypes defines the behavior if the current contextcontains calculated members. If true, thows an exception.
 * @param evaluator Evaluator
 */
public static void addContextConstraint(SqlQuery sqlQuery,AggStar aggStar,Evaluator evaluator,boolean restrictMemberTypes){
  Member[] members=evaluator.getNonAllMembers();
  RolapCube baseCube=null;
  if (evaluator instanceof RolapEvaluator)   baseCube=((RolapEvaluator)evaluator).getCube();
  Map<RelationOrJoin,Set<RolapMember>> mapOfSlicerMembers=new HashMap<RelationOrJoin,Set<RolapMember>>();
  Map<RelationOrJoin,Boolean> done=new HashMap<RelationOrJoin,Boolean>();
  if (restrictMemberTypes) {
    if (containsCalculatedMember(members)) {
      throw Util.newInternal(""String_Node_Str"");
    }
    if (hasMultiPositionSlicer(evaluator)) {
      List<Member> slicerMembers=((RolapEvaluator)evaluator).getSlicerMembers();
      for (      Member slicerMember : slicerMembers) {
        RelationOrJoin rel=((RolapCubeHierarchy)slicerMember.getHierarchy()).getRelation();
        if (!mapOfSlicerMembers.containsKey(rel)) {
          mapOfSlicerMembers.put(rel,new HashSet<RolapMember>());
        }
        mapOfSlicerMembers.get(rel).add((RolapMember)slicerMember);
      }
    }
  }
 else {
    members=removeCalculatedAndDefaultMembers(members);
    members=removeMultiPositionSlicerMembers(members,evaluator);
  }
  final CellRequest request=RolapAggregationManager.makeRequest(members);
  if (request == null) {
    if (restrictMemberTypes) {
      throw Util.newInternal(""String_Node_Str"");
    }
    return;
  }
  RolapStar.Column[] columns=request.getConstrainedColumns();
  Object[] values=request.getSingleValues();
  int arity=columns.length;
  for (int i=0; i < arity; i++) {
    RolapStar.Column column=columns[i];
    String expr;
    if (aggStar != null) {
      int bitPos=column.getBitPosition();
      AggStar.Table.Column aggColumn=aggStar.lookupColumn(bitPos);
      AggStar.Table table=aggColumn.getTable();
      table.addToFrom(sqlQuery,false,true);
      expr=aggColumn.generateExprString(sqlQuery);
    }
 else {
      RolapStar.Table table=column.getTable();
      table.addToFrom(sqlQuery,false,true);
      expr=column.generateExprString(sqlQuery);
    }
    final String value=String.valueOf(values[i]);
    if ((RolapUtil.mdxNullLiteral().equalsIgnoreCase(value)) || (value.equalsIgnoreCase(RolapUtil.sqlNullValue.toString()))) {
      sqlQuery.addWhere(expr,""String_Node_Str"",RolapUtil.sqlNullLiteral);
    }
 else {
      if (column.getDatatype().isNumeric()) {
        Double.valueOf(value);
      }
      if (mapOfSlicerMembers.containsKey(column.getTable().getRelation())) {
        if (!done.containsKey(column.getTable().getRelation())) {
          Set<RolapMember> slicerMembersArray=mapOfSlicerMembers.get(column.getTable().getRelation());
          List<RolapMember> slicerMembers=new ArrayList<RolapMember>(slicerMembersArray);
          final String where=generateMultiValueInExpr(sqlQuery,baseCube,aggStar,slicerMembers,(RolapLevel)slicerMembers.get(0).getHierarchy().getLevels()[0],restrictMemberTypes,null);
          sqlQuery.addWhere(where);
          done.put(column.getTable().getRelation(),Boolean.TRUE);
        }
      }
 else {
        final StringBuilder buf=new StringBuilder();
        sqlQuery.getDialect().quote(buf,value,column.getDatatype());
        sqlQuery.addWhere(expr,""String_Node_Str"",buf.toString());
      }
    }
  }
}","/** 
 * For every restricting member in the current context, generates a WHERE condition and a join to the fact table.
 * @param sqlQuery the query to modify
 * @param aggStar Aggregate table, or null if query is against fact table
 * @param restrictMemberTypes defines the behavior if the current contextcontains calculated members. If true, thows an exception.
 * @param evaluator Evaluator
 */
public static void addContextConstraint(SqlQuery sqlQuery,AggStar aggStar,Evaluator evaluator,boolean restrictMemberTypes){
  Member[] members=evaluator.getNonAllMembers();
  RolapCube baseCube=null;
  if (evaluator instanceof RolapEvaluator)   baseCube=((RolapEvaluator)evaluator).getCube();
  Map<RelationOrJoin,Set<RolapMember>> mapOfSlicerMembers=new HashMap<RelationOrJoin,Set<RolapMember>>();
  Map<RelationOrJoin,Boolean> done=new HashMap<RelationOrJoin,Boolean>();
  if (restrictMemberTypes) {
    if (containsCalculatedMember(members)) {
      throw Util.newInternal(""String_Node_Str"");
    }
    if (hasMultiPositionSlicer(evaluator)) {
      List<Member> slicerMembers=((RolapEvaluator)evaluator).getSlicerMembers();
      for (      Member slicerMember : slicerMembers) {
        RelationOrJoin rel=((RolapCubeHierarchy)slicerMember.getHierarchy()).getRelation();
        if (!mapOfSlicerMembers.containsKey(rel)) {
          mapOfSlicerMembers.put(rel,new HashSet<RolapMember>());
        }
        mapOfSlicerMembers.get(rel).add((RolapMember)slicerMember);
      }
    }
  }
 else {
    members=removeCalculatedAndDefaultMembers(members);
    members=removeMultiPositionSlicerMembers(members,evaluator);
  }
  final CellRequest request=RolapAggregationManager.makeRequest(members);
  if (request == null) {
    if (restrictMemberTypes) {
      throw Util.newInternal(""String_Node_Str"");
    }
    return;
  }
  RolapStar.Column[] columns=request.getConstrainedColumns();
  Object[] values=request.getSingleValues();
  int arity=columns.length;
  for (int i=0; i < arity; i++) {
    RolapStar.Column column=columns[i];
    String expr;
    if (aggStar != null) {
      int bitPos=column.getBitPosition();
      AggStar.Table.Column aggColumn=aggStar.lookupColumn(bitPos);
      AggStar.Table table=aggColumn.getTable();
      table.addToFrom(sqlQuery,false,true);
      expr=aggColumn.generateExprString(sqlQuery);
    }
 else {
      RolapStar.Table table=column.getTable();
      table.addToFrom(sqlQuery,false,true);
      expr=column.generateExprString(sqlQuery);
    }
    final String value=String.valueOf(values[i]);
    if ((RolapUtil.mdxNullLiteral().equalsIgnoreCase(value)) || (value.equalsIgnoreCase(RolapUtil.sqlNullValue.toString()))) {
      sqlQuery.addWhere(expr,""String_Node_Str"",RolapUtil.sqlNullLiteral);
    }
 else {
      if (column.getDatatype().isNumeric()) {
        Double.valueOf(value);
      }
      if (mapOfSlicerMembers.containsKey(column.getTable().getRelation())) {
        if (!done.containsKey(column.getTable().getRelation())) {
          Set<RolapMember> slicerMembersArray=mapOfSlicerMembers.get(column.getTable().getRelation());
          List<RolapMember> slicerMembers=new ArrayList<RolapMember>(slicerMembersArray);
          RolapMember allMember=null;
          for (          RolapMember slicerMember : slicerMembers) {
            if (slicerMember.isAll()) {
              allMember=slicerMember;
              break;
            }
          }
          if (allMember != null) {
            slicerMembers.remove(allMember);
          }
          if (slicerMembers.size() > 0) {
            final String where=generateMultiValueInExpr(sqlQuery,baseCube,aggStar,slicerMembers,(RolapLevel)slicerMembers.get(0).getHierarchy().getLevels()[0],restrictMemberTypes,null);
            sqlQuery.addWhere(where);
          }
 else {
            final StringBuilder buf=new StringBuilder();
            sqlQuery.getDialect().quote(buf,value,column.getDatatype());
            sqlQuery.addWhere(expr,""String_Node_Str"",buf.toString());
          }
          done.put(column.getTable().getRelation(),Boolean.TRUE);
        }
      }
 else {
        final StringBuilder buf=new StringBuilder();
        sqlQuery.getDialect().quote(buf,value,column.getDatatype());
        sqlQuery.addWhere(expr,""String_Node_Str"",buf.toString());
      }
    }
  }
}",0.9245803056877976
50921,"/** 
 * Given a usage of type level, create a Level column.
 * @param usage
 */
private void loadLevel(final JdbcSchema.Table.Column.Usage usage){
  String name=usage.getSymbolicName();
  MondrianDef.Expression expression=new MondrianDef.Column(getName(),usage.levelColumnName);
  int bitPosition=usage.rColumn.getBitPosition();
  Level level=new Level(name,expression,bitPosition,usage.rColumn,usage.collapsed);
  addLevel(level);
  if (!usage.collapsed) {
    RolapLevel parentLevel=(RolapLevel)usage.level.getParentLevel();
    while (!parentLevel.isAll()) {
      final BitKey bk=AggStar.this.star.getBitKey(new String[]{parentLevel.getKeyExp().getTableAlias()},new String[]{((MondrianDef.Column)parentLevel.getKeyExp()).getColumnName()});
      final int bitPos=bk.nextSetBit(0);
      if (bitPos == -1) {
        throw new MondrianException(""String_Node_Str"");
      }
      DimTable columnTable=convertTable(AggStar.this.star.getColumn(bitPosition).getTable(),null);
      while (columnTable.getChildTables().size() > 0) {
        columnTable=columnTable.getChildTables().get(0);
      }
      final DimTable finalColumnTable=columnTable;
      levelColumnsToJoin.put(bitPos,new Column(((MondrianDef.Column)parentLevel.getKeyExp()).getColumnName(),parentLevel.getKeyExp(),AggStar.this.star.getColumn(bitPos).getDatatype(),bitPos){
        public Table getTable(){
          return finalColumnTable;
        }
      }
);
      parentLevel=(RolapLevel)parentLevel.getParentLevel();
    }
  }
}","/** 
 * Given a usage of type level, create a Level column.
 * @param usage
 */
private void loadLevel(final JdbcSchema.Table.Column.Usage usage){
  String name=usage.getSymbolicName();
  MondrianDef.Expression expression=new MondrianDef.Column(getName(),usage.levelColumnName);
  int bitPosition=usage.rColumn.getBitPosition();
  Level level=new Level(name,expression,bitPosition,usage.rColumn,usage.collapsed);
  addLevel(level);
  if (!usage.collapsed) {
    RolapLevel parentLevel=(RolapLevel)usage.level.getParentLevel();
    while (!parentLevel.isAll()) {
      final BitKey bk=AggStar.this.star.getBitKey(new String[]{parentLevel.getKeyExp().getTableAlias()},new String[]{((MondrianDef.Column)parentLevel.getKeyExp()).getColumnName()});
      final int bitPos=bk.nextSetBit(0);
      if (bitPos == -1) {
        throw new MondrianException(""String_Node_Str"");
      }
      DimTable columnTable=convertTable(AggStar.this.star.getColumn(bitPosition).getTable(),usage.levelColumnName);
      while (columnTable.getChildTables().size() > 0) {
        columnTable=columnTable.getChildTables().get(0);
      }
      final DimTable finalColumnTable=columnTable;
      levelColumnsToJoin.put(bitPos,new Column(((MondrianDef.Column)parentLevel.getKeyExp()).getColumnName(),parentLevel.getKeyExp(),AggStar.this.star.getColumn(bitPos).getDatatype(),bitPos){
        public Table getTable(){
          return finalColumnTable;
        }
      }
);
      parentLevel=(RolapLevel)parentLevel.getParentLevel();
    }
  }
}",0.991702621971457
50922,"public void testD2() throws Exception {
  if (!isApplicable()) {
    return;
  }
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  getCubeTestContext().assertQueryReturns(mdx,RESULTS);
}","public void testD2() throws Exception {
  if (!isApplicable()) {
    return;
  }
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  getTestContext().assertQueryReturns(mdx,RESULTS);
}",0.9929577464788732
50923,"public void testD1() throws Exception {
  if (!isApplicable()) {
    return;
  }
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Result result=getCubeTestContext().executeQuery(mdx);
  String resultString=TestContext.toString(result);
  assertEquals(resultString,RESULTS);
}","public void testD1() throws Exception {
  if (!isApplicable()) {
    return;
  }
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Result result=getTestContext().executeQuery(mdx);
  String resultString=TestContext.toString(result);
  assertEquals(resultString,RESULTS);
}",0.9946524064171124
50924,"public void testAll() throws Exception {
  if (!isApplicable()) {
    return;
  }
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  getCubeTestContext().assertQueryReturns(mdx,RESULTS_ALL);
}","public void testAll() throws Exception {
  if (!isApplicable()) {
    return;
  }
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  getTestContext().assertQueryReturns(mdx,RESULTS_ALL);
}",0.9930795847750864
50925,"/** 
 * This ought to give the same result as the above testD2() method. In this case, the FT2Extra cube has a default measure with no data (null) for all members. This default measure is used in the evaluation even though there is an implicit use of the measure [Measures].[Value].
 * @throws Exception
 */
public void _testNullDefaultMeasure() throws Exception {
  if (!isApplicable()) {
    return;
  }
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Result result=getCubeTestContext().executeQuery(mdx);
  String resultString=TestContext.toString(result);
  assertTrue(resultString.equals(RESULTS));
}","/** 
 * This ought to give the same result as the above testD2() method. In this case, the FT2Extra cube has a default measure with no data (null) for all members. This default measure is used in the evaluation even though there is an implicit use of the measure [Measures].[Value].
 * @throws Exception
 */
public void _testNullDefaultMeasure() throws Exception {
  if (!isApplicable()) {
    return;
  }
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Result result=getTestContext().executeQuery(mdx);
  String resultString=TestContext.toString(result);
  assertTrue(resultString.equals(RESULTS));
}",0.997163120567376
50926,"public void testTotalAmount() throws Exception {
  if (!isApplicable()) {
    return;
  }
  MondrianProperties props=MondrianProperties.instance();
  propSaver.set(props.UseAggregates,false);
  String mdx=""String_Node_Str"";
  Result result=getCubeTestContext().executeQuery(mdx);
  Object v=result.getCell(new int[]{0}).getValue();
  propSaver.set(props.UseAggregates,false);
  Result result1=getCubeTestContext().executeQuery(mdx);
  Object v1=result1.getCell(new int[]{0}).getValue();
  assertTrue(v.equals(v1));
}","public void testTotalAmount() throws Exception {
  if (!isApplicable()) {
    return;
  }
  MondrianProperties props=MondrianProperties.instance();
  propSaver.set(props.UseAggregates,false);
  String mdx=""String_Node_Str"";
  Result result=getTestContext().executeQuery(mdx);
  Object v=result.getCell(new int[]{0}).getValue();
  propSaver.set(props.UseAggregates,false);
  Result result1=getTestContext().executeQuery(mdx);
  Object v1=result1.getCell(new int[]{0}).getValue();
  assertTrue(v.equals(v1));
}",0.9921875
50927,"public void testStoreCount() throws Exception {
  if (!isApplicable()) {
    return;
  }
  MondrianProperties props=MondrianProperties.instance();
  propSaver.set(props.UseAggregates,false);
  String mdx=""String_Node_Str"";
  Result result=getCubeTestContext().executeQuery(mdx);
  Object v=result.getCell(new int[]{0}).getValue();
  propSaver.set(props.UseAggregates,true);
  Result result1=getCubeTestContext().executeQuery(mdx);
  Object v1=result1.getCell(new int[]{0}).getValue();
  assertTrue(v.equals(v1));
}","public void testStoreCount() throws Exception {
  if (!isApplicable()) {
    return;
  }
  MondrianProperties props=MondrianProperties.instance();
  propSaver.set(props.UseAggregates,false);
  String mdx=""String_Node_Str"";
  Result result=getTestContext().executeQuery(mdx);
  Object v=result.getCell(new int[]{0}).getValue();
  propSaver.set(props.UseAggregates,true);
  Result result1=getTestContext().executeQuery(mdx);
  Object v1=result1.getCell(new int[]{0}).getValue();
  assertTrue(v.equals(v1));
}",0.992156862745098
50928,"public void testSalesCount() throws Exception {
  if (!isApplicable()) {
    return;
  }
  MondrianProperties props=MondrianProperties.instance();
  propSaver.set(props.UseAggregates,false);
  String mdx=""String_Node_Str"";
  Result result=getCubeTestContext().executeQuery(mdx);
  Object v=result.getCell(new int[]{0}).getValue();
  propSaver.set(props.UseAggregates,true);
  Result result1=getCubeTestContext().executeQuery(mdx);
  Object v1=result1.getCell(new int[]{0}).getValue();
  assertTrue(v.equals(v1));
}","public void testSalesCount() throws Exception {
  if (!isApplicable()) {
    return;
  }
  MondrianProperties props=MondrianProperties.instance();
  propSaver.set(props.UseAggregates,false);
  String mdx=""String_Node_Str"";
  Result result=getTestContext().executeQuery(mdx);
  Object v=result.getCell(new int[]{0}).getValue();
  propSaver.set(props.UseAggregates,true);
  Result result1=getTestContext().executeQuery(mdx);
  Object v1=result1.getCell(new int[]{0}).getValue();
  assertTrue(v.equals(v1));
}",0.992156862745098
50929,"public void testBug1541077() throws Exception {
  if (!isApplicable()) {
    return;
  }
  MondrianProperties props=MondrianProperties.instance();
  propSaver.set(props.UseAggregates,false);
  String mdx=""String_Node_Str"";
  Result result=getCubeTestContext().executeQuery(mdx);
  Object v=result.getCell(new int[]{0}).getFormattedValue();
  propSaver.set(props.UseAggregates,true);
  Result result1=getCubeTestContext().executeQuery(mdx);
  Object v1=result1.getCell(new int[]{0}).getFormattedValue();
  assertTrue(v.equals(v1));
}","public void testBug1541077() throws Exception {
  if (!isApplicable()) {
    return;
  }
  MondrianProperties props=MondrianProperties.instance();
  propSaver.set(props.UseAggregates,false);
  String mdx=""String_Node_Str"";
  Result result=getTestContext().executeQuery(mdx);
  Object v=result.getCell(new int[]{0}).getFormattedValue();
  propSaver.set(props.UseAggregates,true);
  Result result1=getTestContext().executeQuery(mdx);
  Object v1=result1.getCell(new int[]{0}).getFormattedValue();
  assertTrue(v.equals(v1));
}",0.9924242424242424
50930,"public void testCrossJoin() throws Exception {
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  propSaver.set(MondrianProperties.instance().CrossJoinOptimizerSize,Integer.MAX_VALUE);
  Result result1=getCubeTestContext().executeQuery(mdx);
  String resultString1=TestContext.toString(result1);
  propSaver.set(MondrianProperties.instance().CrossJoinOptimizerSize,Integer.MAX_VALUE);
  Result result2=getCubeTestContext().executeQuery(mdx);
  String resultString2=TestContext.toString(result2);
  assertEquals(resultString1,resultString2);
}","public void testCrossJoin() throws Exception {
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  propSaver.set(MondrianProperties.instance().CrossJoinOptimizerSize,Integer.MAX_VALUE);
  Result result1=getTestContext().executeQuery(mdx);
  String resultString1=TestContext.toString(result1);
  propSaver.set(MondrianProperties.instance().CrossJoinOptimizerSize,Integer.MAX_VALUE);
  Result result2=getTestContext().executeQuery(mdx);
  String resultString2=TestContext.toString(result2);
  assertEquals(resultString1,resultString2);
}",0.9935275080906149
50931,"public void testImplicitMember() throws Exception {
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Result result1=getCubeTestContext().executeQuery(mdx);
  String resultString1=TestContext.toString(result1);
  Result result2=getCubeTestContext().executeQuery(mdx);
  String resultString2=TestContext.toString(result2);
  assertEquals(resultString1,resultString2);
}","public void testImplicitMember() throws Exception {
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Result result1=getTestContext().executeQuery(mdx);
  String resultString1=TestContext.toString(result1);
  Result result2=getTestContext().executeQuery(mdx);
  String resultString2=TestContext.toString(result2);
  assertEquals(resultString1,resultString2);
}",0.9920318725099602
50932,"public void testTupleSelection() throws Exception {
  if (!isApplicable()) {
    return;
  }
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  getCubeTestContext().assertQueryReturns(mdx,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testTupleSelection() throws Exception {
  if (!isApplicable()) {
    return;
  }
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  getTestContext().assertQueryReturns(mdx,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9950372208436724
50933,"public void testTotal() throws Exception {
  if (!isApplicable()) {
    return;
  }
  MondrianProperties props=MondrianProperties.instance();
  propSaver.set(props.UseAggregates,false);
  propSaver.set(props.ReadAggregates,false);
  String mdx=""String_Node_Str"";
  Result result=getCubeTestContext().executeQuery(mdx);
  Object v=result.getCell(new int[]{0}).getValue();
  String mdx2=""String_Node_Str"" + ""String_Node_Str"";
  Result aresult=getCubeTestContext().executeQuery(mdx2);
  Object av=aresult.getCell(new int[]{0}).getValue();
  propSaver.set(props.UseAggregates,true);
  propSaver.set(props.ReadAggregates,false);
  Result result1=getCubeTestContext().executeQuery(mdx);
  Object v1=result1.getCell(new int[]{0}).getValue();
  assertTrue(v.equals(v1));
  Result aresult2=getCubeTestContext().executeQuery(mdx2);
  Object av1=aresult2.getCell(new int[]{0}).getValue();
  assertTrue(av.equals(av1));
}","public void testTotal() throws Exception {
  if (!isApplicable()) {
    return;
  }
  MondrianProperties props=MondrianProperties.instance();
  propSaver.set(props.UseAggregates,false);
  propSaver.set(props.ReadAggregates,false);
  String mdx=""String_Node_Str"";
  Result result=getTestContext().executeQuery(mdx);
  Object v=result.getCell(new int[]{0}).getValue();
  String mdx2=""String_Node_Str"" + ""String_Node_Str"";
  Result aresult=getTestContext().executeQuery(mdx2);
  Object av=aresult.getCell(new int[]{0}).getValue();
  propSaver.set(props.UseAggregates,true);
  propSaver.set(props.ReadAggregates,false);
  Result result1=getTestContext().executeQuery(mdx);
  Object v1=result1.getCell(new int[]{0}).getValue();
  assertTrue(v.equals(v1));
  Result aresult2=getTestContext().executeQuery(mdx2);
  Object av1=aresult2.getCell(new int[]{0}).getValue();
  assertTrue(av.equals(av1));
}",0.9911209766925638
50934,"public void testChildSelection() throws Exception {
  if (!isApplicable()) {
    return;
  }
  String mdx=""String_Node_Str"" + ""String_Node_Str"";
  getCubeTestContext().assertQueryReturns(mdx,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testChildSelection() throws Exception {
  if (!isApplicable()) {
    return;
  }
  String mdx=""String_Node_Str"" + ""String_Node_Str"";
  getTestContext().assertQueryReturns(mdx,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9945054945054944
50935,"public void testComplexJoin() throws Exception {
  if (!isApplicable()) {
    return;
  }
  final String mdx=""String_Node_Str"";
  final TestContext context=getCubeTestContext();
  context.assertQueryReturns(mdx,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  final String mdx2=""String_Node_Str"";
  context.assertQueryReturns(mdx2,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testComplexJoin() throws Exception {
  if (!isApplicable()) {
    return;
  }
  final String mdx=""String_Node_Str"";
  final TestContext context=getTestContext();
  context.assertQueryReturns(mdx,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  final String mdx2=""String_Node_Str"";
  context.assertQueryReturns(mdx2,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9968304278922344
50936,"public void testSingleJoin() throws Exception {
  if (!isApplicable()) {
    return;
  }
  final String mdx=""String_Node_Str"";
  final TestContext context=getCubeTestContext();
  context.assertQueryReturns(mdx,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testSingleJoin() throws Exception {
  if (!isApplicable()) {
    return;
  }
  final String mdx=""String_Node_Str"";
  final TestContext context=getTestContext();
  context.assertQueryReturns(mdx,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9947780678851176
50937,"public void testComplexJoinDefaultRecognizer() throws Exception {
  if (!isApplicable()) {
    return;
  }
  final TestContext context=getCubeTestContext();
  final String mdx=""String_Node_Str"";
  context.assertQueryReturns(mdx,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  final String mdx2=""String_Node_Str"";
  context.assertQueryReturns(mdx2,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testComplexJoinDefaultRecognizer() throws Exception {
  if (!isApplicable()) {
    return;
  }
  final TestContext context=getTestContext();
  final String mdx=""String_Node_Str"";
  context.assertQueryReturns(mdx,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  final String mdx2=""String_Node_Str"";
  context.assertQueryReturns(mdx2,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9969135802469136
50938,"public CellProperty(Object name){
  this.name=name.toString();
}","public CellProperty(List<Id.Segment> segments){
  this.name=Util.implode(segments);
}",0.6040268456375839
50939,"/** 
 * Finds a hierarchy whose name (or unique name, if <code>unique</code> is true) equals <code>s</code>.
 */
Hierarchy lookupHierarchy(Id.Segment s,boolean unique);","/** 
 * Finds a hierarchy whose name (or unique name, if <code>unique</code> is true) equals <code>s</code>.
 */
Hierarchy lookupHierarchy(Id.NameSegment s,boolean unique);",0.9882352941176472
50940,"/** 
 * Adds  restricted hierarchy or limited member based on bMember
 */
public void addGrantCubeSlicer(String sHierarchy,String sMember,boolean bMember){
  if (bMember) {
    boolean fail=false;
    List<Id.Segment> sMembers=Util.parseIdentifier(sMember);
    SchemaReader schemaReader=mdxCube.getSchemaReader(null);
    Member member=schemaReader.getMemberByUniqueName(sMembers,fail);
    if (member == null) {
      throw MondrianResource.instance().MdxCubeSlicerMemberError.ex(sMember,sHierarchy,mdxCube.getUniqueName());
    }
    if (getLimitedMemberForHierarchy(member.getHierarchy()) == null) {
      memberList.add(member);
    }
  }
 else {
    boolean fail=false;
    Hierarchy hierarchy=mdxCube.lookupHierarchy(new Id.Segment(sHierarchy,Id.Quoting.UNQUOTED),fail);
    if (hierarchy == null) {
      throw MondrianResource.instance().MdxCubeSlicerHierarchyError.ex(sHierarchy,mdxCube.getUniqueName());
    }
    hierarchyList.add(hierarchy);
  }
}","/** 
 * Adds  restricted hierarchy or limited member based on bMember
 */
public void addGrantCubeSlicer(String sHierarchy,String sMember,boolean bMember){
  if (bMember) {
    boolean fail=false;
    List<Id.Segment> sMembers=Util.parseIdentifier(sMember);
    SchemaReader schemaReader=mdxCube.getSchemaReader(null);
    Member member=schemaReader.getMemberByUniqueName(sMembers,fail);
    if (member == null) {
      throw MondrianResource.instance().MdxCubeSlicerMemberError.ex(sMember,sHierarchy,mdxCube.getUniqueName());
    }
    if (getLimitedMemberForHierarchy(member.getHierarchy()) == null) {
      memberList.add(member);
    }
  }
 else {
    boolean fail=false;
    Hierarchy hierarchy=mdxCube.lookupHierarchy(new Id.NameSegment(sHierarchy),fail);
    if (hierarchy == null) {
      throw MondrianResource.instance().MdxCubeSlicerHierarchyError.ex(sHierarchy,mdxCube.getUniqueName());
    }
    hierarchyList.add(hierarchy);
  }
}",0.9873949579831932
50941,"public Hierarchy lookupHierarchy(Id.Segment s,boolean unique){
  for (  Dimension dimension : dimensions) {
    Hierarchy[] hierarchies=dimension.getHierarchies();
    for (    Hierarchy hierarchy : hierarchies) {
      String name=unique ? hierarchy.getUniqueName() : hierarchy.getName();
      if (name.equals(s.name)) {
        return hierarchy;
      }
    }
  }
  return null;
}","public Hierarchy lookupHierarchy(Id.NameSegment s,boolean unique){
  for (  Dimension dimension : dimensions) {
    Hierarchy[] hierarchies=dimension.getHierarchies();
    for (    Hierarchy hierarchy : hierarchies) {
      String name=unique ? hierarchy.getUniqueName() : hierarchy.getName();
      if (name.equals(s.getName())) {
        return hierarchy;
      }
    }
  }
  return null;
}",0.9780645161290322
50942,"/** 
 * Looks up a dimension in this cube based on a component of its name.
 * @param s Name segment
 * @return Dimension, or null if not found
 */
public Dimension lookupDimension(Id.Segment s){
  for (  Dimension dimension : dimensions) {
    if (Util.equalName(dimension.getName(),s.name)) {
      return dimension;
    }
  }
  return null;
}","/** 
 * Looks up a dimension in this cube based on a component of its name.
 * @param s Name segment
 * @return Dimension, or null if not found
 */
public Dimension lookupDimension(Id.Segment s){
  if (!(s instanceof Id.NameSegment)) {
    return null;
  }
  final Id.NameSegment nameSegment=(Id.NameSegment)s;
  for (  Dimension dimension : dimensions) {
    if (Util.equalName(dimension.getName(),nameSegment.name)) {
      return dimension;
    }
  }
  return null;
}",0.8441717791411043
50943,"public OlapElement lookupChild(SchemaReader schemaReader,Id.Segment s,MatchType matchType){
  Dimension mdxDimension=lookupDimension(s);
  if (mdxDimension != null) {
    return mdxDimension;
  }
  final List<Dimension> dimensions=schemaReader.getCubeDimensions(this);
  if (MondrianProperties.instance().SsasCompatibleNaming.get() && s.name.contains(""String_Node_Str"")) {
    for (    Dimension dimension : dimensions) {
      if (!s.name.startsWith(dimension.getName())) {
        continue;
      }
      for (      Hierarchy hierarchy : schemaReader.getDimensionHierarchies(dimension)) {
        if (Util.equalName(s.name,dimension.getName() + ""String_Node_Str"" + hierarchy.getName())) {
          return hierarchy;
        }
      }
    }
  }
  for (  Dimension dimension : dimensions) {
    OlapElement mdxElement=dimension.lookupChild(schemaReader,s,matchType);
    if (mdxElement != null) {
      if (mdxElement instanceof Member && MondrianProperties.instance().NeedDimensionPrefix.get()) {
        continue;
      }
      return mdxElement;
    }
  }
  return null;
}","public OlapElement lookupChild(SchemaReader schemaReader,Id.Segment s,MatchType matchType){
  Dimension mdxDimension=lookupDimension(s);
  if (mdxDimension != null) {
    return mdxDimension;
  }
  final List<Dimension> dimensions=schemaReader.getCubeDimensions(this);
  if (MondrianProperties.instance().SsasCompatibleNaming.get() && s instanceof Id.NameSegment && ((Id.NameSegment)s).name.contains(""String_Node_Str"")) {
    for (    Dimension dimension : dimensions) {
      if (!((Id.NameSegment)s).name.startsWith(dimension.getName())) {
        continue;
      }
      for (      Hierarchy hierarchy : schemaReader.getDimensionHierarchies(dimension)) {
        if (Util.equalName(((Id.NameSegment)s).name,dimension.getName() + ""String_Node_Str"" + hierarchy.getName())) {
          return hierarchy;
        }
      }
    }
  }
  for (  Dimension dimension : dimensions) {
    OlapElement mdxElement=dimension.lookupChild(schemaReader,s,matchType);
    if (mdxElement != null) {
      if (mdxElement instanceof Member && MondrianProperties.instance().NeedDimensionPrefix.get()) {
        continue;
      }
      return mdxElement;
    }
  }
  return null;
}",0.9602145730889584
50944,"private Hierarchy lookupHierarchy(Id.Segment s){
  for (  Hierarchy hierarchy : hierarchies) {
    if (Util.equalName(hierarchy.getName(),s.name)) {
      return hierarchy;
    }
  }
  return null;
}","private Hierarchy lookupHierarchy(Id.NameSegment s){
  for (  Hierarchy hierarchy : hierarchies) {
    if (Util.equalName(hierarchy.getName(),s.getName())) {
      return hierarchy;
    }
  }
  return null;
}",0.9582309582309584
50945,"public OlapElement lookupChild(SchemaReader schemaReader,Id.Segment s,MatchType matchType){
  OlapElement oe=lookupHierarchy(s);
  if (!MondrianProperties.instance().SsasCompatibleNaming.get()) {
    if (oe == null || oe.getName().equalsIgnoreCase(getName())) {
      OlapElement oeLevel=getHierarchy().lookupChild(schemaReader,s,matchType);
      if (oeLevel != null) {
        return oeLevel;
      }
    }
    return oe;
  }
 else {
    if (oe != null) {
      return oe;
    }
    final List<Hierarchy> hierarchyList=schemaReader.getDimensionHierarchies(this);
    for (    Hierarchy hierarchy : hierarchyList) {
      oe=hierarchy.lookupChild(schemaReader,s,matchType);
      if (oe != null) {
        return oe;
      }
    }
    return null;
  }
}","public OlapElement lookupChild(SchemaReader schemaReader,Id.Segment s,MatchType matchType){
  OlapElement oe=null;
  if (s instanceof Id.NameSegment) {
    oe=lookupHierarchy((Id.NameSegment)s);
  }
  if (!MondrianProperties.instance().SsasCompatibleNaming.get()) {
    if (oe == null || oe.getName().equalsIgnoreCase(getName())) {
      OlapElement oeLevel=getHierarchy().lookupChild(schemaReader,s,matchType);
      if (oeLevel != null) {
        return oeLevel;
      }
    }
    return oe;
  }
 else {
    if (oe != null) {
      return oe;
    }
    final List<Hierarchy> hierarchyList=schemaReader.getDimensionHierarchies(this);
    for (    Hierarchy hierarchy : hierarchyList) {
      oe=hierarchy.lookupChild(schemaReader,s,matchType);
      if (oe != null) {
        return oe;
      }
    }
    return null;
  }
}",0.9518377693282636
50946,"/** 
 * Changes the last part of the name to <code>newName</code>. For example, <code>[Abc].[Def].[Ghi]</code> becomes <code>[Abc].[Def].[Xyz]</code>; and the member or set is renamed from <code>Ghi</code> to <code>Xyz</code>.
 */
void rename(String newName){
  String oldName=getElement().getName();
  final List<Id.Segment> segments=this.id.getSegments();
  Util.assertTrue(segments.get(segments.size() - 1).name.equalsIgnoreCase(oldName));
  segments.set(segments.size() - 1,new Id.Segment(newName,Id.Quoting.QUOTED));
  if (isMember) {
    mdxMember.setName(newName);
  }
 else {
    mdxSet.setName(newName);
  }
}","/** 
 * Changes the last part of the name to <code>newName</code>. For example, <code>[Abc].[Def].[Ghi]</code> becomes <code>[Abc].[Def].[Xyz]</code>; and the member or set is renamed from <code>Ghi</code> to <code>Xyz</code>.
 */
void rename(String newName){
}",0.5938566552901023
50947,"public OlapElement lookupChild(SchemaReader schemaReader,Id.Segment s,MatchType matchType){
  OlapElement oe=Util.lookupHierarchyLevel(this,s.name);
  if (oe == null) {
    oe=Util.lookupHierarchyRootMember(schemaReader,this,s,matchType);
  }
  if (getLogger().isDebugEnabled()) {
    StringBuilder buf=new StringBuilder(64);
    buf.append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
    buf.append(getName());
    buf.append(""String_Node_Str"");
    buf.append(s);
    if (oe == null) {
      buf.append(""String_Node_Str"");
    }
 else {
      buf.append(""String_Node_Str"").append(oe.getName());
    }
    getLogger().debug(buf.toString());
  }
  return oe;
}","public OlapElement lookupChild(SchemaReader schemaReader,Id.Segment s,MatchType matchType){
  OlapElement oe;
  if (s instanceof Id.NameSegment) {
    Id.NameSegment nameSegment=(Id.NameSegment)s;
    oe=Util.lookupHierarchyLevel(this,nameSegment.getName());
    if (oe == null) {
      oe=Util.lookupHierarchyRootMember(schemaReader,this,nameSegment,matchType);
    }
  }
 else {
    final Id.KeySegment keySegment=(Id.KeySegment)s;
    oe=levels[levels.length - 1].lookupChild(schemaReader,keySegment,matchType);
  }
  if (getLogger().isDebugEnabled()) {
    StringBuilder buf=new StringBuilder(64);
    buf.append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
    buf.append(getName());
    buf.append(""String_Node_Str"");
    buf.append(s);
    if (oe == null) {
      buf.append(""String_Node_Str"");
    }
 else {
      buf.append(""String_Node_Str"").append(oe.getName());
    }
    getLogger().debug(buf.toString());
  }
  return oe;
}",0.8170580964153276
50948,"/** 
 * Returns an object with which to explicitly control the contents of the cache.
 * @param pw Writer to which to write logging information; may be null
 */
CacheControl getCacheControl(@Null PrintWriter pw);","/** 
 * Returns an object with which to explicitly control the contents of the cache.
 * @param pw Writer to which to write logging information; may be null
 */
CacheControl getCacheControl(PrintWriter pw);",0.985645933014354
50949,"/** 
 * Creates a member reader which enforces the access-control profile of <code>role</code>. <p>This method may not be efficient, so the caller should take care not to call it too often. A cache is a good idea.
 * @param role Role
 * @return Member reader that implements access control
 * @pre role != null
 * @post return != null
 */
MemberReader createMemberReader(Role role){
  final Access access=role.getAccess(this);
switch (access) {
case NONE:
    role.getAccess(this);
  throw Util.newInternal(""String_Node_Str"" + this);
case ALL:
return (isRagged()) ? new RestrictedMemberReader(getMemberReader(),role) : getMemberReader();
case CUSTOM:
final Role.HierarchyAccess hierarchyAccess=role.getAccessDetails(this);
final Role.RollupPolicy rollupPolicy=hierarchyAccess.getRollupPolicy();
final NumericType returnType=new NumericType();
switch (rollupPolicy) {
case FULL:
return new RestrictedMemberReader(getMemberReader(),role);
case PARTIAL:
Type memberType1=new mondrian.olap.type.MemberType(getDimension(),this,null,null);
SetType setType=new SetType(memberType1);
ListCalc listCalc=new AbstractListCalc(new DummyExp(setType),new Calc[0]){
public TupleList evaluateList(Evaluator evaluator){
return new UnaryTupleList(FunUtil.getNonEmptyMemberChildren(evaluator,((RolapEvaluator)evaluator).getExpanding()));
}
public boolean dependsOn(Hierarchy hierarchy){
return true;
}
}
;
final Calc partialCalc=new LimitedRollupAggregateCalc(returnType,listCalc);
final Exp partialExp=new ResolvedFunCall(new FunDefBase(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
public Calc compileCall(ResolvedFunCall call,ExpCompiler compiler){
return partialCalc;
}
public void unparse(Exp[] args,PrintWriter pw){
pw.print(""String_Node_Str"");
}
}
,new Exp[0],returnType);
return new LimitedRollupSubstitutingMemberReader(getMemberReader(),role,hierarchyAccess,partialExp);
case HIDDEN:
Exp hiddenExp=new ResolvedFunCall(new FunDefBase(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
public Calc compileCall(ResolvedFunCall call,ExpCompiler compiler){
return new ConstantCalc(returnType,null);
}
public void unparse(Exp[] args,PrintWriter pw){
pw.print(""String_Node_Str"");
}
}
,new Exp[0],returnType);
return new LimitedRollupSubstitutingMemberReader(getMemberReader(),role,hierarchyAccess,hiddenExp);
default :
throw Util.unexpected(rollupPolicy);
}
default :
throw Util.badValue(access);
}
}","/** 
 * Creates a member reader which enforces the access-control profile of <code>role</code>. <p>This method may not be efficient, so the caller should take care not to call it too often. A cache is a good idea.
 * @param role Role
 * @return Member reader that implements access control
 * @pre role != null
 * @post return != null
 */
MemberReader createMemberReader(Role role){
  final Access access=role.getAccess(this);
switch (access) {
case NONE:
    role.getAccess(this);
  throw Util.newInternal(""String_Node_Str"" + this);
case ALL:
return (isRagged()) ? new RestrictedMemberReader(getMemberReader(),role) : getMemberReader();
case CUSTOM:
final Role.HierarchyAccess hierarchyAccess=role.getAccessDetails(this);
final Role.RollupPolicy rollupPolicy=hierarchyAccess.getRollupPolicy();
final NumericType returnType=new NumericType();
switch (rollupPolicy) {
case FULL:
return new RestrictedMemberReader(getMemberReader(),role);
case PARTIAL:
Type memberType1=new mondrian.olap.type.MemberType(getDimension(),this,null,null);
SetType setType=new SetType(memberType1);
ListCalc listCalc=new AbstractListCalc(new DummyExp(setType),new Calc[0]){
public TupleList evaluateList(Evaluator evaluator){
return new UnaryTupleList(getLowestMembersForAccess(evaluator,hierarchyAccess,null));
}
public boolean dependsOn(Hierarchy hierarchy){
return true;
}
}
;
final Calc partialCalc=new LimitedRollupAggregateCalc(returnType,listCalc);
final Exp partialExp=new ResolvedFunCall(new FunDefBase(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
public Calc compileCall(ResolvedFunCall call,ExpCompiler compiler){
return partialCalc;
}
public void unparse(Exp[] args,PrintWriter pw){
pw.print(""String_Node_Str"");
}
}
,new Exp[0],returnType);
return new LimitedRollupSubstitutingMemberReader(getMemberReader(),role,hierarchyAccess,partialExp);
case HIDDEN:
Exp hiddenExp=new ResolvedFunCall(new FunDefBase(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""){
public Calc compileCall(ResolvedFunCall call,ExpCompiler compiler){
return new ConstantCalc(returnType,null);
}
public void unparse(Exp[] args,PrintWriter pw){
pw.print(""String_Node_Str"");
}
}
,new Exp[0],returnType);
return new LimitedRollupSubstitutingMemberReader(getMemberReader(),role,hierarchyAccess,hiddenExp);
default :
throw Util.unexpected(rollupPolicy);
}
default :
throw Util.badValue(access);
}
}",0.975251677852349
50950,"public TupleList evaluateList(Evaluator evaluator){
  return new UnaryTupleList(FunUtil.getNonEmptyMemberChildren(evaluator,((RolapEvaluator)evaluator).getExpanding()));
}","public TupleList evaluateList(Evaluator evaluator){
  return new UnaryTupleList(getLowestMembersForAccess(evaluator,hierarchyAccess,null));
}",0.7115384615384616
50951,"/** 
 * Finds rollup candidates among a list of headers with the same dimensionality. <p>For each column that is being aggregated away, we need to ensure that we have all values of that column. If the column is wildcarded, it's easy. For example, if we wish to roll up to create Segment1:</p> <pre>Segment1(Year=1997, MaritalStatus=*)</pre> <p>then clearly Segment2:</p> <pre>Segment2(Year=1997, MaritalStatus=*, Gender=*, Nation=*)</pre> <p>has all gender and Nation values. If the values are specified as a list:</p> <pre>Segment3(Year=1997, MaritalStatus=*, Gender={M, F}, Nation=*)</pre> <p>then we need to check the metadata. We see that Gender has two distinct values in the database, and we have two values, therefore we have all of them.</p> <p>What if we have multiple non-wildcard columns? Consider:</p> <pre> Segment4(Year=1997, MaritalStatus=*, Gender={M}, Nation={Mexico, USA}) Segment5(Year=1997, MaritalStatus=*, Gender={F}, Nation={USA}) Segment6(Year=1997, MaritalStatus=*, Gender={F, M}, Nation={Canada, Mexico, Honduras, Belize}) </pre> <p>The problem is similar to finding whether a collection of rectangular regions covers a rectangle (or, generalizing to n dimensions, an n-cube). Or better, find a minimal collection of regions.</p> <p>Our algorithm solves it by iterating over all combinations of values. Those combinations are exponential in theory, but tractible in practice, using the following trick. The algorithm reduces the number of combinations by looking for values that are always treated the same. In the above, Canada, Honduras and Belize are always treated the same, so to prove covering, it is sufficient to prove that all combinations involving Canada are covered.</p>
 * @param coordinates Coordinates
 * @param list List to write candidates to
 * @param headers Headers of candidate segments
 */
private void findRollupCandidatesAmong(Map<String,Comparable> coordinates,List<List<SegmentHeader>> list,List<SegmentHeader> headers){
  final List<Pair<SegmentHeader,List<SegmentColumn>>> matchingHeaders=new ArrayList<Pair<SegmentHeader,List<SegmentColumn>>>();
  headerLoop:   for (  SegmentHeader header : headers) {
    if (!header.getExcludedRegions().isEmpty()) {
      continue;
    }
    List<SegmentColumn> nonWildcards=new ArrayList<SegmentColumn>();
    for (    SegmentColumn column : header.getConstrainedColumns()) {
      final SegmentColumn constrainedColumn=header.getConstrainedColumn(column.columnExpression);
      if (coordinates.containsKey(column.columnExpression)) {
        Comparable value=coordinates.get(column.columnExpression);
        if (value == null) {
          value=RolapUtil.sqlNullValue;
        }
        if (constrainedColumn.values != null && !constrainedColumn.values.contains(value)) {
          continue headerLoop;
        }
      }
 else {
        if (constrainedColumn.values != null) {
          nonWildcards.add(constrainedColumn);
        }
      }
    }
    if (nonWildcards.isEmpty()) {
      list.add(Collections.singletonList(header));
    }
 else {
      matchingHeaders.add(Pair.of(header,nonWildcards));
    }
  }
  if (matchingHeaders.size() < 2) {
    return;
  }
  final List<SegmentColumn> columnList=new ArrayList<SegmentColumn>();
  final List<String> columnNameList=new ArrayList<String>();
  for (  Pair<SegmentHeader,List<SegmentColumn>> pair : matchingHeaders) {
    for (    SegmentColumn column : pair.right) {
      if (!columnNameList.contains(column.columnExpression)) {
        final int valueCount=column.getValueCount();
        if (valueCount <= 0) {
          return;
        }
        columnList.add(column);
        columnNameList.add(column.columnExpression);
      }
    }
  }
  final List<List<Comparable>> valueLists=new ArrayList<List<Comparable>>();
  for (  SegmentColumn column : columnList) {
    final SortedMap<Comparable,BitSet> valueMap=new TreeMap<Comparable,BitSet>();
    int h=-1;
    for (    SegmentHeader header : Pair.leftIter(matchingHeaders)) {
      ++h;
      final SegmentColumn column1=header.getConstrainedColumn(column.columnExpression);
      if (column1.getValues() == null) {
        for (        Entry<Comparable,BitSet> entry : valueMap.entrySet()) {
          for (int pos=0; pos < entry.getValue().cardinality(); pos++) {
            entry.getValue().set(pos);
          }
        }
      }
 else {
        for (        Comparable value : column1.getValues()) {
          BitSet bitSet=valueMap.get(value);
          if (bitSet == null) {
            bitSet=new BitSet();
            valueMap.put(value,bitSet);
          }
          bitSet.set(h);
        }
      }
    }
    if (valueMap.size() < column.valueCount) {
      return;
    }
    final Map<BitSet,Comparable> eqclassPrimaryValues=new HashMap<BitSet,Comparable>();
    for (    Map.Entry<Comparable,BitSet> entry : valueMap.entrySet()) {
      final BitSet bitSet=entry.getValue();
      if (!eqclassPrimaryValues.containsKey(bitSet)) {
        final Comparable value=entry.getKey();
        eqclassPrimaryValues.put(bitSet,value);
      }
    }
    valueLists.add(new ArrayList<Comparable>(eqclassPrimaryValues.values()));
  }
  final CartesianProductList<Comparable> tuples=new CartesianProductList<Comparable>(valueLists);
  final List<SegmentHeader> usedSegments=new ArrayList<SegmentHeader>();
  final List<SegmentHeader> unusedSegments=new ArrayList<SegmentHeader>(headers);
  tupleLoop:   for (  List<Comparable> tuple : tuples) {
    for (    SegmentHeader segment : usedSegments) {
      if (contains(segment,tuple,columnNameList)) {
        continue tupleLoop;
      }
    }
    for (    SegmentHeader segment : unusedSegments) {
      if (contains(segment,tuple,columnNameList)) {
        unusedSegments.remove(segment);
        usedSegments.add(segment);
        continue tupleLoop;
      }
    }
    return;
  }
  list.add(usedSegments);
}","/** 
 * Finds rollup candidates among a list of headers with the same dimensionality. <p>For each column that is being aggregated away, we need to ensure that we have all values of that column. If the column is wildcarded, it's easy. For example, if we wish to roll up to create Segment1:</p> <pre>Segment1(Year=1997, MaritalStatus=*)</pre> <p>then clearly Segment2:</p> <pre>Segment2(Year=1997, MaritalStatus=*, Gender=*, Nation=*)</pre> <p>has all gender and Nation values. If the values are specified as a list:</p> <pre>Segment3(Year=1997, MaritalStatus=*, Gender={M, F}, Nation=*)</pre> <p>then we need to check the metadata. We see that Gender has two distinct values in the database, and we have two values, therefore we have all of them.</p> <p>What if we have multiple non-wildcard columns? Consider:</p> <pre> Segment4(Year=1997, MaritalStatus=*, Gender={M}, Nation={Mexico, USA}) Segment5(Year=1997, MaritalStatus=*, Gender={F}, Nation={USA}) Segment6(Year=1997, MaritalStatus=*, Gender={F, M}, Nation={Canada, Mexico, Honduras, Belize}) </pre> <p>The problem is similar to finding whether a collection of rectangular regions covers a rectangle (or, generalizing to n dimensions, an n-cube). Or better, find a minimal collection of regions.</p> <p>Our algorithm solves it by iterating over all combinations of values. Those combinations are exponential in theory, but tractible in practice, using the following trick. The algorithm reduces the number of combinations by looking for values that are always treated the same. In the above, Canada, Honduras and Belize are always treated the same, so to prove covering, it is sufficient to prove that all combinations involving Canada are covered.</p>
 * @param coordinates Coordinates
 * @param list List to write candidates to
 * @param headers Headers of candidate segments
 */
private void findRollupCandidatesAmong(Map<String,Comparable> coordinates,List<List<SegmentHeader>> list,List<SegmentHeader> headers){
  final List<Pair<SegmentHeader,List<SegmentColumn>>> matchingHeaders=new ArrayList<Pair<SegmentHeader,List<SegmentColumn>>>();
  headerLoop:   for (  SegmentHeader header : headers) {
    if (!header.getExcludedRegions().isEmpty()) {
      continue;
    }
    List<SegmentColumn> nonWildcards=new ArrayList<SegmentColumn>();
    for (    SegmentColumn column : header.getConstrainedColumns()) {
      final SegmentColumn constrainedColumn=header.getConstrainedColumn(column.columnExpression);
      if (coordinates.containsKey(column.columnExpression)) {
        Comparable value=coordinates.get(column.columnExpression);
        if (value == null) {
          value=RolapUtil.sqlNullValue;
        }
        if (constrainedColumn.values != null && !constrainedColumn.values.contains(value)) {
          continue headerLoop;
        }
      }
 else {
        if (constrainedColumn.values != null) {
          nonWildcards.add(constrainedColumn);
        }
      }
    }
    if (nonWildcards.isEmpty()) {
      list.add(Collections.singletonList(header));
    }
 else {
      matchingHeaders.add(Pair.of(header,nonWildcards));
    }
  }
  if (matchingHeaders.size() < 2) {
    return;
  }
  final List<SegmentColumn> columnList=new ArrayList<SegmentColumn>();
  final List<String> columnNameList=new ArrayList<String>();
  for (  Pair<SegmentHeader,List<SegmentColumn>> pair : matchingHeaders) {
    for (    SegmentColumn column : pair.right) {
      if (!columnNameList.contains(column.columnExpression)) {
        final int valueCount=column.getValueCount();
        if (valueCount <= 0) {
          return;
        }
        columnList.add(column);
        columnNameList.add(column.columnExpression);
      }
    }
  }
  final List<List<Comparable>> valueLists=new ArrayList<List<Comparable>>();
  for (  SegmentColumn column : columnList) {
    final SortedMap<Comparable,BitSet> valueMap=new TreeMap<Comparable,BitSet>(RolapUtil.ROLAP_COMPARATOR);
    int h=-1;
    for (    SegmentHeader header : Pair.leftIter(matchingHeaders)) {
      ++h;
      final SegmentColumn column1=header.getConstrainedColumn(column.columnExpression);
      if (column1.getValues() == null) {
        for (        Entry<Comparable,BitSet> entry : valueMap.entrySet()) {
          for (int pos=0; pos < entry.getValue().cardinality(); pos++) {
            entry.getValue().set(pos);
          }
        }
      }
 else {
        for (        Comparable value : column1.getValues()) {
          BitSet bitSet=valueMap.get(value);
          if (bitSet == null) {
            bitSet=new BitSet();
            valueMap.put(value,bitSet);
          }
          bitSet.set(h);
        }
      }
    }
    if (valueMap.size() < column.valueCount) {
      return;
    }
    final Map<BitSet,Comparable> eqclassPrimaryValues=new HashMap<BitSet,Comparable>();
    for (    Map.Entry<Comparable,BitSet> entry : valueMap.entrySet()) {
      final BitSet bitSet=entry.getValue();
      if (!eqclassPrimaryValues.containsKey(bitSet)) {
        final Comparable value=entry.getKey();
        eqclassPrimaryValues.put(bitSet,value);
      }
    }
    valueLists.add(new ArrayList<Comparable>(eqclassPrimaryValues.values()));
  }
  final CartesianProductList<Comparable> tuples=new CartesianProductList<Comparable>(valueLists);
  final List<SegmentHeader> usedSegments=new ArrayList<SegmentHeader>();
  final List<SegmentHeader> unusedSegments=new ArrayList<SegmentHeader>(headers);
  tupleLoop:   for (  List<Comparable> tuple : tuples) {
    for (    SegmentHeader segment : usedSegments) {
      if (contains(segment,tuple,columnNameList)) {
        continue tupleLoop;
      }
    }
    for (    SegmentHeader segment : unusedSegments) {
      if (contains(segment,tuple,columnNameList)) {
        unusedSegments.remove(segment);
        usedSegments.add(segment);
        continue tupleLoop;
      }
    }
    return;
  }
  list.add(usedSegments);
}",0.9977898673920436
50952,"public <T extends Comparable<T>>int binarySearch(T[] ts,int start,int end,T t){
  return Collections.binarySearch(Arrays.asList(ts).subList(start,end),t,new Comparator<T>(){
    public int compare(    T o1,    T o2){
      if (o1 instanceof RolapUtilComparable) {
        return -1;
      }
      if (o2 instanceof RolapUtilComparable) {
        return 1;
      }
      return o1.compareTo(o2);
    }
  }
);
}","public <T extends Comparable<T>>int binarySearch(T[] ts,int start,int end,T t){
  return Collections.binarySearch(Arrays.asList(ts).subList(start,end),t,RolapUtil.ROLAP_COMPARATOR);
}",0.5709459459459459
50953,"public <T extends Comparable<T>>int binarySearch(T[] ts,int start,int end,T t){
  final int i=Collections.binarySearch(Arrays.asList(ts).subList(start,end),t,new Comparator<T>(){
    public int compare(    T o1,    T o2){
      if (o1 instanceof RolapUtilComparable) {
        return -1;
      }
      if (o2 instanceof RolapUtilComparable) {
        return 1;
      }
      return o1.compareTo(o2);
    }
  }
);
  return (i < 0) ? (i - start) : (i + start);
}","public <T extends Comparable<T>>int binarySearch(T[] ts,int start,int end,T t){
  final int i=Collections.binarySearch(Arrays.asList(ts).subList(start,end),t,RolapUtil.ROLAP_COMPARATOR);
  return (i < 0) ? (i - start) : (i + start);
}",0.6282420749279539
50954,"public <T extends Comparable<T>>int binarySearch(T[] ts,int start,int end,T t){
  return Arrays.binarySearch(ts,start,end,t,new Comparator<T>(){
    public int compare(    T o1,    T o2){
      if (o1 instanceof RolapUtilComparable) {
        return -1;
      }
      if (o2 instanceof RolapUtilComparable) {
        return 1;
      }
      return o1.compareTo(o2);
    }
  }
);
}","public <T extends Comparable<T>>int binarySearch(T[] ts,int start,int end,T t){
  return Arrays.binarySearch(ts,start,end,t,RolapUtil.ROLAP_COMPARATOR);
}",0.5243445692883895
50955,"protected void loadMembers(List<List<Member>> nonAllMembers,RolapEvaluator evaluator,QueryAxis axis,Calc calc,AxisMember axisMembers){
  int attempt=0;
  evaluator.setCellReader(batchingReader);
  while (true) {
    axisMembers.clearAxisCount();
    try {
      evalLoad(nonAllMembers,nonAllMembers.size() - 1,evaluator,axis,calc,axisMembers);
    }
 catch (    CellRequestQuantumExceededException e) {
      --attempt;
    }
    if (!phase()) {
      break;
    }
 else {
      evaluator.clearExpResultCache(false);
    }
    if (attempt++ > maxEvalDepth) {
      throw Util.newInternal(""String_Node_Str"" + maxEvalDepth + ""String_Node_Str"");
    }
  }
}","protected void loadMembers(List<List<Member>> nonAllMembers,RolapEvaluator evaluator,QueryAxis axis,Calc calc,AxisMember axisMembers){
  int attempt=0;
  evaluator.setCellReader(batchingReader);
  while (true) {
    axisMembers.clearAxisCount();
    final int savepoint=evaluator.savepoint();
    try {
      evalLoad(nonAllMembers,nonAllMembers.size() - 1,evaluator,axis,calc,axisMembers);
    }
 catch (    CellRequestQuantumExceededException e) {
      --attempt;
    }
 finally {
      evaluator.restore(savepoint);
    }
    if (!phase()) {
      break;
    }
 else {
      evaluator.clearExpResultCache(false);
    }
    if (attempt++ > maxEvalDepth) {
      throw Util.newInternal(""String_Node_Str"" + maxEvalDepth + ""String_Node_Str"");
    }
  }
}",0.9289772727272728
50956,"/** 
 * Creates a CellCacheSegmentCreateEvent.
 * @param timestamp Timestamp
 * @param locus Locus
 * @param coordinateCount Number of coordinates of segment header
 * @param actualCellCount Number of cells in body (or 0 if body not yetpresent)
 * @param source Source of segment
 */
public CellCacheSegmentCreateEvent(long timestamp,int serverId,int connectionId,long statementId,long executionId,int coordinateCount,int actualCellCount,Source source){
  super(timestamp,serverId,connectionId,statementId,executionId,source);
  this.coordinateCount=coordinateCount;
  this.actualCellCount=actualCellCount;
}","/** 
 * Creates a CellCacheSegmentCreateEvent.
 * @param timestamp Timestamp
 * @param serverId ID of the server from which the event originates.
 * @param connectionId ID of the connection from which the eventoriginates.
 * @param statementId ID of the statement from which the event originates.
 * @param executionId ID of the execution from which the event originates.
 * @param coordinateCount Number of coordinates of segment header
 * @param actualCellCount Number of cells in body (or 0 if body not yetpresent)
 * @param source Source of segment
 */
public CellCacheSegmentCreateEvent(long timestamp,int serverId,int connectionId,long statementId,long executionId,int coordinateCount,int actualCellCount,Source source){
  super(timestamp,serverId,connectionId,statementId,executionId,source);
  this.coordinateCount=coordinateCount;
  this.actualCellCount=actualCellCount;
}",0.8018804566823371
50957,"/** 
 * Creates a CellCacheSegmentCreateEvent.
 * @param timestamp Timestamp
 * @param locus Locus
 * @param coordinateCount Number of coordinates of segment header
 */
public CellCacheSegmentDeleteEvent(long timestamp,int serverId,int connectionId,long statementId,long executionId,int coordinateCount,Source source){
  super(timestamp,serverId,connectionId,statementId,executionId,source);
  this.coordinateCount=coordinateCount;
}","/** 
 * Creates a CellCacheSegmentCreateEvent.
 * @param timestamp Timestamp
 * @param serverId ID of the server from which the event originates.
 * @param connectionId ID of the connection from which the eventoriginates.
 * @param statementId ID of the statement from which the event originates.
 * @param executionId ID of the execution from which the event originates.
 * @param coordinateCount Number of coordinates of segment header
 * @param source Source of segment
 */
public CellCacheSegmentDeleteEvent(long timestamp,int serverId,int connectionId,long statementId,long executionId,int coordinateCount,Source source){
  super(timestamp,serverId,connectionId,statementId,executionId,source);
  this.coordinateCount=coordinateCount;
}",0.7189097103918228
50958,"/** 
 * test case for bug #2477623, Closure Tables not working with Virtual Cubes
 */
public void testClosureTableInVirtualCube(){
  final TestContext testContext=TestContext.instance().create(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null,null,null);
  testContext.assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Test case for <a href=""http://jira.pentaho.org/browse/MONDRIAN-488"">MONDRIAN-488, ""Closure Tables not working with Virtual Cubes""</a>.
 */
public void testClosureTableInVirtualCube(){
  final TestContext testContext=TestContext.instance().create(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null,null,null);
  testContext.assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9629959875167188
50959,"/** 
 * Tests snow flake closure combination. bug #1675125 - now fixed.
 */
public void testSnowflakeClosure(){
  getEmpSnowFlakeClosureTestContext().assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Tests snow flake closure combination. <p>Test case for <a href=""http://jira.pentaho.org/browse/MONDRIAN-266"">MONDRIAN-266, ""Closure tables do not work in a Snowflake Dimension""</a>.
 */
public void testSnowflakeClosure(){
  getEmpSnowFlakeClosureTestContext().assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.8579136690647482
50960,"public void testDistinctAll(){
  assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Test case for <a href=""http://jira.pentaho.org/browse/MONDRIAN-75"">MONDRIAN-75, ""'distinct count' measure cause exception in parent/child""</a>.
 */
public void testDistinctAll(){
  assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.8296943231441049
50961,"/** 
 * Test case for bug #1708327
 */
public void _testNonClosureParentChildHierarchy(){
  getEmpNonClosureTestContext().assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Test case for <a href=""http://jira.pentaho.org/browse/MONDRIAN-284"">MONDRIAN-284, ""Parent child hierarchies without closures are broken""</a>.
 */
public void _testNonClosureParentChildHierarchy(){
  getEmpNonClosureTestContext().assertQueryReturns(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.8946135831381733
50962,"/** 
 * Converts a product name and version (per the JDBC driver) into a product enumeration.
 * @param productName Product name
 * @param productVersion Product version
 * @return database product
 */
public static DatabaseProduct getProduct(String productName,String productVersion){
  final String upperProductName=productName.toUpperCase();
  if (productName.equals(""String_Node_Str"")) {
    return DatabaseProduct.ACCESS;
  }
 else   if (upperProductName.trim().equals(""String_Node_Str"")) {
    return DatabaseProduct.DERBY;
  }
 else   if (upperProductName.trim().equals(""String_Node_Str"")) {
    return DatabaseProduct.DERBY;
  }
 else   if (productName.startsWith(""String_Node_Str"")) {
    if (productName.startsWith(""String_Node_Str"")) {
      String[] version_release=productVersion.split(""String_Node_Str"",3);
      if (""String_Node_Str"".compareTo(version_release[0]) >= 0) {
        return DatabaseProduct.DB2_OLD_AS400;
      }
 else {
        return DatabaseProduct.DB2_AS400;
      }
    }
 else {
      return DatabaseProduct.DB2;
    }
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.FIREBIRD;
  }
 else   if (productName.startsWith(""String_Node_Str"")) {
    return DatabaseProduct.INFORMIX;
  }
 else   if (upperProductName.equals(""String_Node_Str"")) {
    return DatabaseProduct.INGRES;
  }
 else   if (productName.equals(""String_Node_Str"")) {
    return DatabaseProduct.INTERBASE;
  }
 else   if (upperProductName.equals(""String_Node_Str"")) {
    return DatabaseProduct.LUCIDDB;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.MSSQL;
  }
 else   if (productName.equals(""String_Node_Str"")) {
    return DatabaseProduct.ORACLE;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.POSTGRESQL;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.NETEZZA;
  }
 else   if (upperProductName.equals(""String_Node_Str"")) {
    return DatabaseProduct.INFOBRIGHT;
  }
 else   if (upperProductName.equals(""String_Node_Str"")) {
    return DatabaseProduct.MYSQL;
  }
 else   if (upperProductName.equals(""String_Node_Str"")) {
    return DatabaseProduct.VERTICA;
  }
 else   if (upperProductName.equals(""String_Node_Str"")) {
    return DatabaseProduct.VECTORWISE;
  }
 else   if (productName.startsWith(""String_Node_Str"")) {
    return DatabaseProduct.NEOVIEW;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0 || upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.SYBASE;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.TERADATA;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.HSQLDB;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.VERTICA;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.VECTORWISE;
  }
 else {
    return DatabaseProduct.UNKNOWN;
  }
}","/** 
 * Converts a product name and version (per the JDBC driver) into a product enumeration.
 * @param productName Product name
 * @param productVersion Product version
 * @return database product
 */
public static DatabaseProduct getProduct(String productName,String productVersion){
  final String upperProductName=productName.toUpperCase();
  if (productName.equals(""String_Node_Str"")) {
    return DatabaseProduct.ACCESS;
  }
 else   if (upperProductName.trim().equals(""String_Node_Str"")) {
    return DatabaseProduct.DERBY;
  }
 else   if (upperProductName.trim().equals(""String_Node_Str"")) {
    return DatabaseProduct.DERBY;
  }
 else   if (productName.startsWith(""String_Node_Str"")) {
    if (productName.startsWith(""String_Node_Str"")) {
      String[] version_release=productVersion.split(""String_Node_Str"",3);
      if (""String_Node_Str"".compareTo(version_release[0]) >= 0) {
        return DatabaseProduct.DB2_OLD_AS400;
      }
 else {
        return DatabaseProduct.DB2_AS400;
      }
    }
 else {
      return DatabaseProduct.DB2;
    }
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.FIREBIRD;
  }
 else   if (productName.startsWith(""String_Node_Str"")) {
    return DatabaseProduct.INFORMIX;
  }
 else   if (upperProductName.equals(""String_Node_Str"")) {
    return DatabaseProduct.INGRES;
  }
 else   if (productName.equals(""String_Node_Str"")) {
    return DatabaseProduct.INTERBASE;
  }
 else   if (upperProductName.equals(""String_Node_Str"")) {
    return DatabaseProduct.LUCIDDB;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.MSSQL;
  }
 else   if (productName.equals(""String_Node_Str"")) {
    return DatabaseProduct.ORACLE;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.POSTGRESQL;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.NETEZZA;
  }
 else   if (upperProductName.equals(""String_Node_Str"")) {
    return DatabaseProduct.INFOBRIGHT;
  }
 else   if (upperProductName.equals(""String_Node_Str"")) {
    return DatabaseProduct.MYSQL;
  }
 else   if (upperProductName.equals(""String_Node_Str"") || upperProductName.equals(""String_Node_Str"")) {
    return DatabaseProduct.VERTICA;
  }
 else   if (upperProductName.equals(""String_Node_Str"")) {
    return DatabaseProduct.VECTORWISE;
  }
 else   if (productName.startsWith(""String_Node_Str"")) {
    return DatabaseProduct.NEOVIEW;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0 || upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.SYBASE;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.TERADATA;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.HSQLDB;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.VERTICA;
  }
 else   if (upperProductName.indexOf(""String_Node_Str"") >= 0) {
    return DatabaseProduct.VECTORWISE;
  }
 else {
    return DatabaseProduct.UNKNOWN;
  }
}",0.9925662572721397
50963,"private Exp getFormula(Member member){
  return (Exp)member.getPropertyValue(Property.FORMAT_EXP.name);
}","private Exp getFormula(Member member){
  return (Exp)member.getPropertyValue(Property.FORMAT_EXP_PARSED.name);
}",0.967741935483871
50964,"/** 
 * Returns whether this property is standard.
 */
public boolean isStandard(){
  return ordinal <= VALUE_ORDINAL;
}","/** 
 * Returns whether this property is standard.
 */
public boolean isStandard(){
  return ordinal < MAX_ORDINAL;
}",0.9704641350210972
50965,"/** 
 * Returns whether this property is a standard member property.
 */
public boolean isCellProperty(){
  return cell && ordinal <= VALUE_ORDINAL;
}","/** 
 * Returns whether this property is a standard cell property.
 */
public boolean isCellProperty(){
  return cell && isStandard();
}",0.8601398601398601
50966,"public int compare(Comparable<?> o1,Comparable<?> o2){
  if (o1 == RolapUtil.sqlNullValue) {
    return -1;
  }
  if (o2 == RolapUtil.sqlNullValue) {
    return 1;
  }
  return ((Comparable)o1).compareTo(o2);
}","public int compare(Comparable o1,Comparable o2){
  if (o1 == RolapUtil.sqlNullValue) {
    return -1;
  }
  if (o2 == RolapUtil.sqlNullValue) {
    return 1;
  }
  return o1.compareTo(o2);
}",0.95
50967,"/** 
 * Creates a MondrianOlap4jCellSetAxisMetaData.
 * @param cellSetMetaData Cell set axis metadata
 * @param queryAxis Query axis
 */
MondrianOlap4jCellSetAxisMetaData(MondrianOlap4jCellSetMetaData cellSetMetaData,QueryAxis queryAxis){
  if (queryAxis == null) {
    queryAxis=new QueryAxis(false,null,AxisOrdinal.StandardAxisOrdinal.SLICER,QueryAxis.SubtotalVisibility.Undefined);
  }
  this.queryAxis=queryAxis;
  this.cellSetMetaData=cellSetMetaData;
  for (  Id id : queryAxis.getDimensionProperties()) {
    final String[] names=id.toStringArray();
    Property olap4jProperty=null;
    if (names.length == 1) {
      olap4jProperty=Util.lookup(Property.StandardMemberProperty.class,names[0]);
    }
    if (olap4jProperty == null) {
      final UnresolvedFunCall call=(UnresolvedFunCall)Util.lookup(cellSetMetaData.query,id.getSegments(),true);
      olap4jProperty=new MondrianOlap4jProperty(Util.lookupProperty(((LevelExpr)call.getArg(0)).getLevel(),call.getFunName()));
    }
    propertyList.add(olap4jProperty);
  }
}","/** 
 * Creates a MondrianOlap4jCellSetAxisMetaData.
 * @param cellSetMetaData Cell set axis metadata
 * @param queryAxis Query axis
 */
MondrianOlap4jCellSetAxisMetaData(MondrianOlap4jCellSetMetaData cellSetMetaData,QueryAxis queryAxis){
  if (queryAxis == null) {
    queryAxis=new QueryAxis(false,null,AxisOrdinal.StandardAxisOrdinal.SLICER,QueryAxis.SubtotalVisibility.Undefined);
  }
  this.queryAxis=queryAxis;
  this.cellSetMetaData=cellSetMetaData;
  for (  Id id : queryAxis.getDimensionProperties()) {
    final String[] names=id.toStringArray();
    Property olap4jProperty=null;
    if (names.length == 1) {
      olap4jProperty=Util.lookup(Property.StandardMemberProperty.class,names[0]);
      if (olap4jProperty == null) {
        olap4jProperty=MondrianOlap4jProperty.MEMBER_EXTENSIONS.get(names[0]);
      }
    }
    if (olap4jProperty == null) {
      final UnresolvedFunCall call=(UnresolvedFunCall)Util.lookup(cellSetMetaData.query,id.getSegments(),true);
      olap4jProperty=new MondrianOlap4jProperty(Util.lookupProperty(((LevelExpr)call.getArg(0)).getLevel(),call.getFunName()));
    }
    propertyList.add(olap4jProperty);
  }
}",0.940045766590389
50968,"public NamedList<Property> getCellProperties(){
  final ArrayNamedListImpl<Property> list=new ArrayNamedListImpl<Property>(){
    protected String getName(    Property property){
      return property.getName();
    }
  }
;
  for (  Property.StandardCellProperty property : Property.StandardCellProperty.values()) {
    if (query.hasCellProperty(property.getName())) {
      list.add(property);
    }
  }
  return list;
}","public NamedList<Property> getCellProperties(){
  final ArrayNamedListImpl<Property> list=new ArrayNamedListImpl<Property>(){
    protected String getName(    Property property){
      return property.getName();
    }
  }
;
  for (  Property property : Property.StandardCellProperty.values()) {
    if (query.hasCellProperty(property.getName())) {
      list.add(property);
    }
  }
  for (  Property property : MondrianOlap4jProperty.CELL_EXTENSIONS.values()) {
    if (query.hasCellProperty(property.getName())) {
      list.add(property);
    }
  }
  return list;
}",0.7333333333333333
50969,"/** 
 * Creates an exception with a given cause.
 * @param msg Message
 * @param cause Causing exception
 * @return New exception
 */
OlapException createException(String msg,Throwable cause){
  return new OlapException(msg,cause);
}","/** 
 * Creates an exception with a given cause.
 * @param msg Message
 * @param cause Causing exception
 * @return New exception
 */
OlapException createException(String msg,Throwable cause){
}",0.9086651053864168
50970,"/** 
 * Tests performance of a larger schema with a large number of result cells. Runs in 186 seconds without nonAllPositions array in RolapEvaluator. Runs in 14 seconds when RolapEvaluator.getProperty uses getNonAllMembers. The performance boost gets more significant as the schema size grows.
 */
public void testBigResultsWithBigSchemaPerforms(){
  if (!LOGGER.isDebugEnabled()) {
    return;
  }
  TestContext testContext=TestContext.instance().createSubstitutingCube(""String_Node_Str"",extraGenders(1000),null);
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  long start=System.currentTimeMillis();
  testContext.executeQuery(mdx);
  printDuration(""String_Node_Str"",start);
}","/** 
 * Tests performance of a larger schema with a large number of result cells. Runs in 186 seconds without nonAllPositions array in RolapEvaluator. Runs in 14 seconds when RolapEvaluator.getProperty uses getNonAllMembers. The performance boost gets more significant as the schema size grows.
 */
public void testBigResultsWithBigSchemaPerforms(){
  if (!LOGGER.isDebugEnabled()) {
    return;
  }
  TestContext testContext=TestContext.instance().createSubstitutingCube(""String_Node_Str"",TestContext.repeatString(1000,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),null);
  String mdx=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  long start=System.currentTimeMillis();
  testContext.executeQuery(mdx);
  printDuration(""String_Node_Str"",start);
}",0.9212384573601304
50971,"public Object getValue(){
  final Object value=lockBox.map.get(moniker);
  if (value == null) {
    throw new RuntimeException(""String_Node_Str"" + moniker + ""String_Node_Str"");
  }
  return unwrap(value);
}","public Object getValue(){
  final Object value=lockBox.map.get(this);
  if (value == null) {
    throw new RuntimeException(""String_Node_Str"" + moniker + ""String_Node_Str"");
  }
  return unwrap(value);
}",0.9731051344743276
50972,"/** 
 * Retrieves an entry using its string moniker. Returns null if there is no entry with that moniker. <p>Successive calls for the same moniker do not necessarily return the same   {@code Entry} object, but those entries'{@link LockBox.Entry#getValue()} will nevertheless return the samevalue.</p>
 * @param moniker Moniker of the lock box entry
 * @return Entry, or null if there is no entry with this moniker
 */
public synchronized Entry get(String moniker){
  if (map.containsKey(moniker)) {
    return new LockBoxEntryImpl(this,moniker);
  }
 else {
    return null;
  }
}","/** 
 * Retrieves an entry using its string moniker. Returns null if there is no entry with that moniker. <p>Successive calls for the same moniker do not necessarily return the same   {@code Entry} object, but those entries'{@link LockBox.Entry#getValue()} will nevertheless return the samevalue.</p>
 * @param moniker Moniker of the lock box entry
 * @return Entry, or null if there is no entry with this moniker
 */
public synchronized Entry get(String moniker){
  for (  LockBoxEntryImpl entry : map.keySet()) {
    if (entry.moniker.equals(moniker)) {
      return entry;
    }
  }
  return null;
}",0.8730964467005076
50973,"/** 
 * Removes an entry from the lock box. <p>It is safe to call this method multiple times.
 * @param entry Entry to deregister
 * @return Whether the object was removed
 */
public synchronized boolean deregister(Entry entry){
  return map.remove(entry.getMoniker()) != null;
}","/** 
 * Removes an entry from the lock box. <p>It is safe to call this method multiple times.
 * @param entry Entry to deregister
 * @return Whether the object was removed
 */
public synchronized boolean deregister(Entry entry){
  return map.remove(entry) != null;
}",0.9761467889908256
50974,"public boolean isRegistered(){
  return lockBox.map.containsKey(moniker);
}","public boolean isRegistered(){
  return lockBox.map.containsKey(this);
}",0.9387755102040816
50975,"/** 
 * Adds an object to the lock box, and returns a key for it. <p>The object may be null. The same object may be registered multiple times; each time it is registered, a new entry with a new string moniker is generated.
 * @param o Object to register. May be null.
 * @return Entry containing the object's string key and the object itself
 */
public synchronized Entry register(Object o){
  String moniker=generateMoniker();
  final LockBoxEntryImpl entry=new LockBoxEntryImpl(this,moniker);
  map.put(moniker,wrap(o));
  return entry;
}","/** 
 * Adds an object to the lock box, and returns a key for it. <p>The object may be null. The same object may be registered multiple times; each time it is registered, a new entry with a new string moniker is generated.
 * @param o Object to register. May be null.
 * @return Entry containing the object's string key and the object itself
 */
public synchronized Entry register(Object o){
  String moniker=generateMoniker();
  final LockBoxEntryImpl entry=new LockBoxEntryImpl(this,moniker);
  map.put(entry,wrap(o));
  return entry;
}",0.9888682745825604
50976,"/** 
 * Unit test for   {@link mondrian.util.LockBox}.
 */
public void testLockBox(){
  final LockBox box=new LockBox();
  final String abc=""String_Node_Str"";
  final String xy=""String_Node_Str"";
  final LockBox.Entry abcEntry0=box.register(abc);
  assertNotNull(abcEntry0);
  assertSame(abc,abcEntry0.getValue());
  checkMonikerValid(abcEntry0.getMoniker());
  final LockBox.Entry xyEntry=box.register(xy);
  checkMonikerValid(xyEntry.getMoniker());
  assertNotSame(abcEntry0.getMoniker(),xyEntry.getMoniker());
  final LockBox.Entry abcEntry1=box.register(abc);
  checkMonikerValid(abcEntry1.getMoniker());
  assertFalse(abcEntry1.getMoniker().equals(abcEntry0.getMoniker()));
  assertSame(abcEntry1.getValue(),abc);
  final LockBox.Entry abcEntry0b=box.get(abcEntry0.getMoniker());
  assertNotNull(abcEntry0b);
  assertEquals(abcEntry0b.getMoniker(),abcEntry0.getMoniker());
  assertNotSame(abcEntry0b,abcEntry1);
  assertTrue(!abcEntry0b.getMoniker().equals(abcEntry1.getMoniker()));
  assertNull(box.get(""String_Node_Str""));
  assertTrue(abcEntry0b.isRegistered());
  final boolean b=box.deregister(abcEntry0b);
  assertTrue(b);
  assertFalse(abcEntry0b.isRegistered());
  assertNull(box.get(abcEntry0.getMoniker()));
  assertFalse(abcEntry0.isRegistered());
  assertTrue(abcEntry1.isRegistered());
  final boolean b2=box.deregister(abcEntry0b);
  assertFalse(b2);
  assertFalse(abcEntry0b.isRegistered());
  assertFalse(abcEntry0.isRegistered());
  assertNull(box.get(abcEntry0.getMoniker()));
  try {
    Object value=abcEntry0.getValue();
    fail(""String_Node_Str"" + value);
  }
 catch (  RuntimeException e) {
    assertTrue(e.getMessage().startsWith(""String_Node_Str""));
  }
  assertNotNull(abcEntry0.getMoniker());
  final LockBox.Entry abcEntry1b=box.get(abcEntry1.getMoniker());
  assertNotNull(abcEntry1b);
  assertSame(abcEntry1b.getValue(),abc);
  assertSame(abcEntry1.getValue(),abc);
  final LockBox.Entry xyEntry2=box.get(xyEntry.getMoniker());
  assertNotNull(xyEntry2);
  assertSame(xyEntry2.getValue(),xy);
  assertSame(xyEntry.getValue(),xy);
  final LockBox.Entry abcEntry3=box.register(abc);
  checkMonikerValid(abcEntry3.getMoniker());
  assertFalse(abcEntry3.getMoniker().equals(abcEntry0.getMoniker()));
  assertFalse(abcEntry3.getMoniker().equals(abcEntry1.getMoniker()));
  assertFalse(abcEntry3.getMoniker().equals(abcEntry0b.getMoniker()));
  assertTrue(abcEntry1.isRegistered());
  assertFalse(abcEntry0.isRegistered());
}","/** 
 * Unit test for   {@link mondrian.util.LockBox}.
 */
public void testLockBox(){
  final LockBox box=new LockBox();
  final String abc=""String_Node_Str"";
  final String xy=""String_Node_Str"";
  final LockBox.Entry abcEntry0=box.register(abc);
  assertNotNull(abcEntry0);
  assertSame(abc,abcEntry0.getValue());
  checkMonikerValid(abcEntry0.getMoniker());
  final LockBox.Entry xyEntry=box.register(xy);
  checkMonikerValid(xyEntry.getMoniker());
  assertNotSame(abcEntry0.getMoniker(),xyEntry.getMoniker());
  final LockBox.Entry abcEntry1=box.register(abc);
  checkMonikerValid(abcEntry1.getMoniker());
  assertFalse(abcEntry1.getMoniker().equals(abcEntry0.getMoniker()));
  assertSame(abcEntry1.getValue(),abc);
  final LockBox.Entry abcEntry0b=box.get(abcEntry0.getMoniker());
  assertNotNull(abcEntry0b);
  assertEquals(abcEntry0b.getMoniker(),abcEntry0.getMoniker());
  assertSame(abcEntry0,abcEntry0b);
  assertNotSame(abcEntry0b,abcEntry1);
  assertTrue(!abcEntry0b.getMoniker().equals(abcEntry1.getMoniker()));
  assertNull(box.get(""String_Node_Str""));
  assertTrue(abcEntry0b.isRegistered());
  final boolean b=box.deregister(abcEntry0b);
  assertTrue(b);
  assertFalse(abcEntry0b.isRegistered());
  assertNull(box.get(abcEntry0.getMoniker()));
  assertFalse(abcEntry0.isRegistered());
  assertTrue(abcEntry1.isRegistered());
  final boolean b2=box.deregister(abcEntry0b);
  assertFalse(b2);
  assertFalse(abcEntry0b.isRegistered());
  assertFalse(abcEntry0.isRegistered());
  assertNull(box.get(abcEntry0.getMoniker()));
  try {
    Object value=abcEntry0.getValue();
    fail(""String_Node_Str"" + value);
  }
 catch (  RuntimeException e) {
    assertTrue(e.getMessage().startsWith(""String_Node_Str""));
  }
  assertNotNull(abcEntry0.getMoniker());
  final LockBox.Entry abcEntry1b=box.get(abcEntry1.getMoniker());
  assertNotNull(abcEntry1b);
  assertSame(abcEntry1b,abcEntry1);
  assertSame(abcEntry1b.getValue(),abc);
  assertSame(abcEntry1.getValue(),abc);
  final LockBox.Entry xyEntry2=box.get(xyEntry.getMoniker());
  assertNotNull(xyEntry2);
  assertSame(xyEntry2,xyEntry);
  assertSame(xyEntry2.getValue(),xy);
  assertSame(xyEntry.getValue(),xy);
  final LockBox.Entry abcEntry3=box.register(abc);
  checkMonikerValid(abcEntry3.getMoniker());
  assertFalse(abcEntry3.getMoniker().equals(abcEntry0.getMoniker()));
  assertFalse(abcEntry3.getMoniker().equals(abcEntry1.getMoniker()));
  assertFalse(abcEntry3.getMoniker().equals(abcEntry0b.getMoniker()));
  assertTrue(abcEntry1.isRegistered());
  assertFalse(abcEntry0.isRegistered());
}",0.9792663476874004
50977,"private void recordCellRequest2(final CellRequest request){
  final AggregationKey key=new AggregationKey(request);
  final Map<String,Comparable<?>> mappedCellValues=request.getMappedCellValues();
  final List<String> compoundPredicates=AggregationKey.getCompoundPredicateStringList(key.getStar(),key.getCompoundPredicateList());
  for (  SegmentHeader header : cacheHeaders) {
    if (SegmentCacheIndexImpl.matches(header,mappedCellValues,compoundPredicates)) {
      return;
    }
  }
  final RolapStar.Measure measure=request.getMeasure();
  final RolapStar star=measure.getStar();
  final RolapSchema schema=star.getSchema();
  final List<SegmentHeader> headersInCache=cacheMgr.segmentIndex.locate(schema.getName(),schema.getChecksum(),measure.getCubeName(),measure.getName(),star.getFactTable().getAlias(),request.getConstrainedColumnsBitKey(),mappedCellValues,compoundPredicates);
  final SegmentBuilder.SegmentConverterImpl converter=new SegmentBuilder.SegmentConverterImpl(key,request);
  if (!headersInCache.isEmpty()) {
    final SegmentHeader headerInCache=headersInCache.get(0);
    final Future<SegmentBody> future=cacheMgr.segmentIndex.getFuture(headerInCache);
    if (future != null) {
      futures.add(future);
    }
 else {
      cacheHeaders.add(headerInCache);
    }
    cacheMgr.segmentIndex.setConverter(headerInCache.schemaName,headerInCache.schemaChecksum,headerInCache.cubeName,headerInCache.rolapStarFactTableName,headerInCache.measureName,headerInCache.compoundPredicates,converter);
    converterMap.put(SegmentCacheIndexImpl.makeConverterKey(request,key),converter);
    return;
  }
  if (measure.getAggregator().getRollup().supportsFastAggregates(measure.getDatatype()) && !rollupBitmaps.contains(request.getConstrainedColumnsBitKey())) {
    final List<List<SegmentHeader>> rollup=cacheMgr.segmentIndex.findRollupCandidates(schema.getName(),schema.getChecksum(),measure.getCubeName(),measure.getName(),star.getFactTable().getAlias(),request.getConstrainedColumnsBitKey(),mappedCellValues,AggregationKey.getCompoundPredicateStringList(star,key.getCompoundPredicateList()));
    if (!rollup.isEmpty()) {
      rollups.add(new RollupInfo(request,rollup));
      rollupBitmaps.add(request.getConstrainedColumnsBitKey());
      converterMap.put(SegmentCacheIndexImpl.makeConverterKey(request,key),new SegmentBuilder.StarSegmentConverter(measure,key.getCompoundPredicateList()));
      return;
    }
  }
  Batch batch=batches.get(key);
  if (batch == null) {
    batch=new Batch(request);
    batches.put(key,batch);
    converterMap.put(SegmentCacheIndexImpl.makeConverterKey(request,key),converter);
    if (LOGGER.isDebugEnabled()) {
      StringBuilder buf=new StringBuilder(100);
      buf.append(""String_Node_Str"");
      buf.append(request.getConstrainedColumnsBitKey());
      buf.append(Util.nl);
      for (      RolapStar.Column column : request.getConstrainedColumns()) {
        buf.append(""String_Node_Str"");
        buf.append(column);
        buf.append(Util.nl);
      }
      LOGGER.debug(buf.toString());
    }
  }
  batch.add(request);
}","private void recordCellRequest2(final CellRequest request){
  final AggregationKey key=new AggregationKey(request);
  final Map<String,Comparable<?>> mappedCellValues=request.getMappedCellValues();
  final List<String> compoundPredicates=AggregationKey.getCompoundPredicateStringList(key.getStar(),key.getCompoundPredicateList());
  for (  SegmentHeader header : cacheHeaders) {
    if (SegmentCacheIndexImpl.matches(header,mappedCellValues,compoundPredicates)) {
      return;
    }
  }
  final RolapStar.Measure measure=request.getMeasure();
  final RolapStar star=measure.getStar();
  final RolapSchema schema=star.getSchema();
  final List<SegmentHeader> headersInCache=cacheMgr.segmentIndex.locate(schema.getName(),schema.getChecksum(),measure.getCubeName(),measure.getName(),star.getFactTable().getAlias(),request.getConstrainedColumnsBitKey(),mappedCellValues,compoundPredicates);
  final SegmentBuilder.SegmentConverterImpl converter=new SegmentBuilder.SegmentConverterImpl(key,request);
  if (!headersInCache.isEmpty()) {
    final SegmentHeader headerInCache=headersInCache.get(0);
    final Future<SegmentBody> future=cacheMgr.segmentIndex.getFuture(headerInCache);
    if (future != null) {
      futures.put(headerInCache,future);
    }
 else {
      cacheHeaders.add(headerInCache);
    }
    cacheMgr.segmentIndex.setConverter(headerInCache.schemaName,headerInCache.schemaChecksum,headerInCache.cubeName,headerInCache.rolapStarFactTableName,headerInCache.measureName,headerInCache.compoundPredicates,converter);
    converterMap.put(SegmentCacheIndexImpl.makeConverterKey(request,key),converter);
    return;
  }
  if (measure.getAggregator().getRollup().supportsFastAggregates(measure.getDatatype()) && !rollupBitmaps.contains(request.getConstrainedColumnsBitKey())) {
    final List<List<SegmentHeader>> rollup=cacheMgr.segmentIndex.findRollupCandidates(schema.getName(),schema.getChecksum(),measure.getCubeName(),measure.getName(),star.getFactTable().getAlias(),request.getConstrainedColumnsBitKey(),mappedCellValues,AggregationKey.getCompoundPredicateStringList(star,key.getCompoundPredicateList()));
    if (!rollup.isEmpty()) {
      rollups.add(new RollupInfo(request,rollup));
      rollupBitmaps.add(request.getConstrainedColumnsBitKey());
      converterMap.put(SegmentCacheIndexImpl.makeConverterKey(request,key),new SegmentBuilder.StarSegmentConverter(measure,key.getCompoundPredicateList()));
      return;
    }
  }
  Batch batch=batches.get(key);
  if (batch == null) {
    batch=new Batch(request);
    batches.put(key,batch);
    converterMap.put(SegmentCacheIndexImpl.makeConverterKey(request,key),converter);
    if (LOGGER.isDebugEnabled()) {
      StringBuilder buf=new StringBuilder(100);
      buf.append(""String_Node_Str"");
      buf.append(request.getConstrainedColumnsBitKey());
      buf.append(Util.nl);
      for (      RolapStar.Column column : request.getConstrainedColumns()) {
        buf.append(""String_Node_Str"");
        buf.append(column);
        buf.append(Util.nl);
      }
      LOGGER.debug(buf.toString());
    }
  }
  batch.add(request);
}",0.99644128113879
50978,"LoadBatchResponse(List<CellRequest> cellRequests,List<SegmentHeader> cacheSegments,List<RollupInfo> rollups,Map<List,SegmentBuilder.SegmentConverter> converterMap,List<Future<Map<Segment,SegmentWithData>>> sqlSegmentMapFutures){
  this.cellRequests=cellRequests;
  this.sqlSegmentMapFutures=sqlSegmentMapFutures;
  this.cacheSegments=cacheSegments;
  this.rollups=rollups;
  this.converterMap=converterMap;
}","LoadBatchResponse(List<CellRequest> cellRequests,List<SegmentHeader> cacheSegments,List<RollupInfo> rollups,Map<List,SegmentBuilder.SegmentConverter> converterMap,List<Future<Map<Segment,SegmentWithData>>> sqlSegmentMapFutures,Map<SegmentHeader,Future<SegmentBody>> futures){
  this.cellRequests=cellRequests;
  this.sqlSegmentMapFutures=sqlSegmentMapFutures;
  this.cacheSegments=cacheSegments;
  this.rollups=rollups;
  this.converterMap=converterMap;
  this.futures=futures;
}",0.9199549041713642
50979,"/** 
 * Resolves any pending cell reads using the cache. After calling this method, all cells requested in a given batch are loaded into this statement's local cache. <p>The method is implemented by making an asynchronous call to the cache manager. The result is a list of segments that satisfies every cell request.</p> <p>The client should put the resulting segments into its ""query local"" cache, to ensure that future cells in that segment can be answered without a call to the cache manager. (That is probably 1000x faster.)</p> <p>The cache manager does not inform where client where each segment came from. There are several possibilities:</p> <ul> <li>Segment was already in cache (header and body)</li> <li>Segment is in the process of being loaded by executing a SQL statement (probably due to a request from another client)</li> <li>Segment is in an external cache (that is, header is in the cache, body is not yet)</li> <li>Segment can be created by rolling up one or more cache segments. (And of course each of these segments might be ""paged out"".)</li> <li>By executing a SQL   {@code GROUP BY} statement</li></ul> <p>Furthermore, segments in external cache may take some time to retrieve (a LAN round trip, say 1 millisecond, is a reasonable guess); and the request may fail. (It depends on the cache, but caches are at liberty to 'forget' segments.) So, any strategy that relies on cache segments should be able to fall back. Even if there are fall backs, only one call needs to be made to the cache manager.</p>
 * @return Whether any aggregations were loaded.
 */
boolean loadAggregations(){
  if (!isDirty()) {
    return false;
  }
  BatchLoader.LoadBatchResponse response=cacheMgr.execute(new BatchLoader.LoadBatchCommand(Locus.peek(),cacheMgr,getDialect(),cube,new ArrayList<CellRequest>(cellRequests)));
  for (; ; ) {
    int failureCount=0;
    Map<SegmentHeader,SegmentBody> headerBodies=new HashMap<SegmentHeader,SegmentBody>();
    final Set<SegmentHeader> failedSegments=new HashSet<SegmentHeader>();
    for (    SegmentHeader header : response.cacheSegments) {
      final SegmentBody body=cacheMgr.compositeCache.get(header);
      if (body == null) {
        failedSegments.add(header);
        ++failureCount;
        continue;
      }
      headerBodies.put(header,body);
      final SegmentWithData segmentWithData=response.convert(header,body);
      segmentWithData.getStar().register(segmentWithData);
    }
    final List<BatchLoader.RollupInfo> failedRollups=new ArrayList<BatchLoader.RollupInfo>();
    final Map<SegmentHeader,SegmentBody> succeededRollups=new HashMap<SegmentHeader,SegmentBody>();
    for (    BatchLoader.RollupInfo rollup : response.rollups) {
      Map<SegmentHeader,SegmentBody> map=findResidentRollupCandidate(headerBodies,rollup);
      if (map == null) {
        failedRollups.add(rollup);
        ++failureCount;
        continue;
      }
      final Set<String> keepColumns=new HashSet<String>();
      for (      RolapStar.Column column : rollup.constrainedColumns) {
        keepColumns.add(column.getExpression().getGenericExpression());
      }
      Pair<SegmentHeader,SegmentBody> rollupHeaderBody=SegmentBuilder.rollup(map,keepColumns,rollup.constrainedColumnsBitKey,rollup.measure.getAggregator().getRollup());
      final SegmentHeader header=rollupHeaderBody.left;
      final SegmentBody body=rollupHeaderBody.right;
      if (headerBodies.containsKey(header)) {
        continue;
      }
      headerBodies.put(header,body);
      succeededRollups.put(header,body);
      final SegmentWithData segmentWithData=response.convert(header,body);
      segmentWithData.getStar().register(segmentWithData);
    }
    if (failureCount == 0) {
      for (      Future<Map<Segment,SegmentWithData>> sqlSegmentMapFuture : response.sqlSegmentMapFutures) {
        final Map<Segment,SegmentWithData> segmentMap=Util.safeGet(sqlSegmentMapFuture,""String_Node_Str"");
        for (        SegmentWithData segmentWithData : segmentMap.values()) {
          segmentWithData.getStar().register(segmentWithData);
        }
      }
    }
    if (failureCount == 0) {
      break;
    }
    List<CellRequest> unsatisfied=new ArrayList<CellRequest>();
    for (    CellRequest cellRequest : cellRequests) {
      if (cellRequest.getMeasure().getStar().getCellFromCache(cellRequest,null) == null) {
        unsatisfied.add(cellRequest);
      }
    }
    if (unsatisfied.isEmpty()) {
      break;
    }
    throw new UnsupportedOperationException();
  }
  dirty=false;
  cellRequests.clear();
  return true;
}","/** 
 * Resolves any pending cell reads using the cache. After calling this method, all cells requested in a given batch are loaded into this statement's local cache. <p>The method is implemented by making an asynchronous call to the cache manager. The result is a list of segments that satisfies every cell request.</p> <p>The client should put the resulting segments into its ""query local"" cache, to ensure that future cells in that segment can be answered without a call to the cache manager. (That is probably 1000x faster.)</p> <p>The cache manager does not inform where client where each segment came from. There are several possibilities:</p> <ul> <li>Segment was already in cache (header and body)</li> <li>Segment is in the process of being loaded by executing a SQL statement (probably due to a request from another client)</li> <li>Segment is in an external cache (that is, header is in the cache, body is not yet)</li> <li>Segment can be created by rolling up one or more cache segments. (And of course each of these segments might be ""paged out"".)</li> <li>By executing a SQL   {@code GROUP BY} statement</li></ul> <p>Furthermore, segments in external cache may take some time to retrieve (a LAN round trip, say 1 millisecond, is a reasonable guess); and the request may fail. (It depends on the cache, but caches are at liberty to 'forget' segments.) So, any strategy that relies on cache segments should be able to fall back. Even if there are fall backs, only one call needs to be made to the cache manager.</p>
 * @return Whether any aggregations were loaded.
 */
boolean loadAggregations(){
  if (!isDirty()) {
    return false;
  }
  final List<Future<Map<Segment,SegmentWithData>>> sqlSegmentMapFutures=new ArrayList<Future<Map<Segment,SegmentWithData>>>();
  final List<CellRequest> cellRequests1=new ArrayList<CellRequest>(cellRequests);
  for (int iteration=0; ; ++iteration) {
    final BatchLoader.LoadBatchResponse response=cacheMgr.execute(new BatchLoader.LoadBatchCommand(Locus.peek(),cacheMgr,getDialect(),cube,Collections.unmodifiableList(cellRequests1)));
    int failureCount=0;
    Map<SegmentHeader,SegmentBody> headerBodies=new HashMap<SegmentHeader,SegmentBody>();
    final Set<SegmentHeader> failedSegments=new HashSet<SegmentHeader>();
    for (    SegmentHeader header : response.cacheSegments) {
      final SegmentBody body=cacheMgr.compositeCache.get(header);
      if (body == null) {
        cacheMgr.remove(header);
        failedSegments.add(header);
        ++failureCount;
        continue;
      }
      headerBodies.put(header,body);
      final SegmentWithData segmentWithData=response.convert(header,body);
      segmentWithData.getStar().register(segmentWithData);
    }
    final List<BatchLoader.RollupInfo> failedRollups=new ArrayList<BatchLoader.RollupInfo>();
    final Map<SegmentHeader,SegmentBody> succeededRollups=new HashMap<SegmentHeader,SegmentBody>();
    for (    BatchLoader.RollupInfo rollup : response.rollups) {
      Map<SegmentHeader,SegmentBody> map=findResidentRollupCandidate(headerBodies,rollup);
      if (map == null) {
        failedRollups.add(rollup);
        ++failureCount;
        continue;
      }
      final Set<String> keepColumns=new HashSet<String>();
      for (      RolapStar.Column column : rollup.constrainedColumns) {
        keepColumns.add(column.getExpression().getGenericExpression());
      }
      Pair<SegmentHeader,SegmentBody> rollupHeaderBody=SegmentBuilder.rollup(map,keepColumns,rollup.constrainedColumnsBitKey,rollup.measure.getAggregator().getRollup());
      final SegmentHeader header=rollupHeaderBody.left;
      final SegmentBody body=rollupHeaderBody.right;
      if (headerBodies.containsKey(header)) {
        continue;
      }
      headerBodies.put(header,body);
      succeededRollups.put(header,body);
      final SegmentWithData segmentWithData=response.convert(header,body);
      segmentWithData.getStar().register(segmentWithData);
    }
    sqlSegmentMapFutures.addAll(response.sqlSegmentMapFutures);
    if (failureCount == 0 || iteration > 0) {
      for (      Map.Entry<SegmentHeader,Future<SegmentBody>> entry : response.futures.entrySet()) {
        final SegmentHeader header=entry.getKey();
        final Future<SegmentBody> bodyFuture=entry.getValue();
        final SegmentBody body=Util.safeGet(bodyFuture,""String_Node_Str"");
        final SegmentWithData segmentWithData=response.convert(header,body);
        segmentWithData.getStar().register(segmentWithData);
      }
      for (      Future<Map<Segment,SegmentWithData>> sqlSegmentMapFuture : sqlSegmentMapFutures) {
        final Map<Segment,SegmentWithData> segmentMap=Util.safeGet(sqlSegmentMapFuture,""String_Node_Str"");
        for (        SegmentWithData segmentWithData : segmentMap.values()) {
          segmentWithData.getStar().register(segmentWithData);
        }
      }
    }
    if (failureCount == 0) {
      break;
    }
    @SuppressWarnings(""String_Node_Str"") List<CellRequest> old=new ArrayList<CellRequest>(cellRequests1);
    cellRequests1.clear();
    for (    CellRequest cellRequest : old) {
      if (cellRequest.getMeasure().getStar().getCellFromCache(cellRequest,null) == null) {
        cellRequests1.add(cellRequest);
      }
    }
    if (cellRequests1.isEmpty()) {
      break;
    }
    if (cellRequests1.size() >= old.size() && iteration > 10) {
      throw Util.newError(""String_Node_Str"" + ""String_Node_Str"" + iteration + ""String_Node_Str""+ cellRequests1.size()+ ""String_Node_Str""+ response.cacheSegments.size()+ ""String_Node_Str""+ response.rollups.size()+ ""String_Node_Str""+ response.sqlSegmentMapFutures.size());
    }
  }
  dirty=false;
  cellRequests.clear();
  return true;
}",0.8394821376423635
50980,"private SegmentBody loadSegmentFromCache(Map<SegmentHeader,SegmentBody> headerBodies,SegmentHeader header){
  SegmentBody body=headerBodies.get(header);
  if (body != null) {
    return body;
  }
  body=cacheMgr.compositeCache.get(header);
  if (body != null) {
    headerBodies.put(header,body);
  }
  return body;
}","private SegmentBody loadSegmentFromCache(Map<SegmentHeader,SegmentBody> headerBodies,SegmentHeader header){
  SegmentBody body=headerBodies.get(header);
  if (body != null) {
    return body;
  }
  body=cacheMgr.compositeCache.get(header);
  if (body == null) {
    cacheMgr.remove(header);
    return null;
  }
  headerBodies.put(header,body);
  return body;
}",0.8820058997050148
50981,"public PeekResponse call(){
  final RolapStar.Measure measure=request.getMeasure();
  final RolapStar star=measure.getStar();
  final RolapSchema schema=star.getSchema();
  final AggregationKey key=new AggregationKey(request);
  final List<SegmentHeader> headers=segmentIndex.locate(schema.getName(),schema.getChecksum(),measure.getCubeName(),measure.getName(),star.getFactTable().getAlias(),request.getConstrainedColumnsBitKey(),request.getMappedCellValues(),AggregationKey.getCompoundPredicateStringList(star,key.getCompoundPredicateList()));
  final Map<SegmentHeader,Future<SegmentBody>> headerMap=new HashMap<SegmentHeader,Future<SegmentBody>>();
  final Map<List,SegmentBuilder.SegmentConverter> converterMap=new HashMap<List,SegmentBuilder.SegmentConverter>();
  for (  SegmentHeader header : headers) {
    converterMap.put(SegmentCacheIndexImpl.makeConverterKey(header),getConverter(header));
    headerMap.put(header,segmentIndex.getFuture(header));
  }
  return new PeekResponse(headerMap,converterMap);
}","public PeekResponse call(){
  final RolapStar.Measure measure=request.getMeasure();
  final RolapStar star=measure.getStar();
  final RolapSchema schema=star.getSchema();
  final AggregationKey key=new AggregationKey(request);
  final List<SegmentHeader> headers=segmentIndex.locate(schema.getName(),schema.getChecksum(),measure.getCubeName(),measure.getName(),star.getFactTable().getAlias(),request.getConstrainedColumnsBitKey(),request.getMappedCellValues(),AggregationKey.getCompoundPredicateStringList(star,key.getCompoundPredicateList()));
  final Map<SegmentHeader,Future<SegmentBody>> headerMap=new HashMap<SegmentHeader,Future<SegmentBody>>();
  final Map<List,SegmentBuilder.SegmentConverter> converterMap=new HashMap<List,SegmentBuilder.SegmentConverter>();
  for (  SegmentHeader header : headers) {
    final Future<SegmentBody> bodyFuture=segmentIndex.getFuture(header);
    if (bodyFuture != null) {
      converterMap.put(SegmentCacheIndexImpl.makeConverterKey(header),getConverter(header));
      headerMap.put(header,bodyFuture);
    }
  }
  return new PeekResponse(headerMap,converterMap);
}",0.9138823529411764
50982,"/** 
 * Loads data for all the segments of the GroupingSets. If the grouping sets list contains more than one Grouping Set then data is loaded using the GROUP BY GROUPING SETS sql. Else if only one grouping set is passed in the list data is loaded without using GROUP BY GROUPING SETS sql. If the database does not support grouping sets  {@link mondrian.spi.Dialect#supportsGroupingSets()} thengrouping sets list should always have only one element in it. <p>For example, if list has 2 grouping sets with columns A, B, C and B, C respectively, then the SQL will be ""GROUP BY GROUPING SETS ((A, B, C), (B, C))"". <p>Else if the list has only one grouping set then sql would be without grouping sets. <p>The <code>groupingSets</code> list should be topological order, with more detailed higher-level grouping sets occurring first. In other words, the first element of the list should always be the detailed grouping set (default grouping set), followed by grouping sets which can be rolled-up on this detailed grouping set. In the example (A, B, C) is the detailed grouping set and (B, C) is rolled-up using the detailed. <p>Grouping sets are removed from the  {@code groupingSets} list as theyare loaded.</p>
 * @param cellRequestCount Number of missed cells that led to this request
 * @param groupingSets   List of grouping sets whose segments are loaded
 * @param compoundPredicateList Compound predicates
 * @param segmentFutures List of futures wherein each statement will placea list of the segments it has loaded, when it completes
 */
public void load(int cellRequestCount,List<GroupingSet> groupingSets,List<StarPredicate> compoundPredicateList,List<Future<Map<Segment,SegmentWithData>>> segmentFutures){
  for (  GroupingSet groupingSet : groupingSets) {
    for (    Segment segment : groupingSet.getSegments()) {
      cacheMgr.segmentIndex.add(segment.getHeader(),new SlotFuture<SegmentBody>(),new SegmentBuilder.StarSegmentConverter(segment.measure,compoundPredicateList));
    }
  }
  try {
    segmentFutures.add(cacheMgr.sqlExecutor.submit(new SegmentLoadCommand(Locus.peek(),this,cellRequestCount,groupingSets,compoundPredicateList)));
  }
 catch (  Exception e) {
    throw new MondrianException(e);
  }
}","/** 
 * Loads data for all the segments of the GroupingSets. If the grouping sets list contains more than one Grouping Set then data is loaded using the GROUP BY GROUPING SETS sql. Else if only one grouping set is passed in the list data is loaded without using GROUP BY GROUPING SETS sql. If the database does not support grouping sets  {@link mondrian.spi.Dialect#supportsGroupingSets()} thengrouping sets list should always have only one element in it. <p>For example, if list has 2 grouping sets with columns A, B, C and B, C respectively, then the SQL will be ""GROUP BY GROUPING SETS ((A, B, C), (B, C))"". <p>Else if the list has only one grouping set then sql would be without grouping sets. <p>The <code>groupingSets</code> list should be topological order, with more detailed higher-level grouping sets occurring first. In other words, the first element of the list should always be the detailed grouping set (default grouping set), followed by grouping sets which can be rolled-up on this detailed grouping set. In the example (A, B, C) is the detailed grouping set and (B, C) is rolled-up using the detailed. <p>Grouping sets are removed from the  {@code groupingSets} list as theyare loaded.</p>
 * @param cellRequestCount Number of missed cells that led to this request
 * @param groupingSets   List of grouping sets whose segments are loaded
 * @param compoundPredicateList Compound predicates
 * @param segmentFutures List of futures wherein each statement will placea list of the segments it has loaded, when it completes
 */
public void load(int cellRequestCount,List<GroupingSet> groupingSets,List<StarPredicate> compoundPredicateList,List<Future<Map<Segment,SegmentWithData>>> segmentFutures){
  for (  GroupingSet groupingSet : groupingSets) {
    for (    Segment segment : groupingSet.getSegments()) {
      cacheMgr.segmentIndex.add(segment.getHeader(),true,new SegmentBuilder.StarSegmentConverter(segment.measure,compoundPredicateList));
    }
  }
  try {
    segmentFutures.add(cacheMgr.sqlExecutor.submit(new SegmentLoadCommand(Locus.peek(),this,cellRequestCount,groupingSets,compoundPredicateList)));
  }
 catch (  Exception e) {
    throw new MondrianException(e);
  }
}",0.992532247114732
50983,"/** 
 * Adds a header to the index.
 * @param header Segment header
 * @param bodyFuture Future that will be informed when the segment has
 * @param converter Segment converter
 */
void add(SegmentHeader header,SlotFuture<SegmentBody> bodyFuture,SegmentBuilder.SegmentConverter converter);","/** 
 * Adds a header to the index. <p>If   {@code loading} is true, there must follow a call to{@link #loadSucceeded} or {@link #loadFailed}.</p>
 * @param header Segment header
 * @param loading Whether segment is pending a load from SQL
 * @param converter Segment converter
 */
void add(SegmentHeader header,boolean loading,SegmentBuilder.SegmentConverter converter);",0.2454545454545454
50984,"public T get(int index){
switch (index) {
case 0:
    return t0;
case 1:
  return t1;
case 2:
return t2;
default :
throw new IndexOutOfBoundsException(""String_Node_Str"" + index);
}
}",Usage get();,0.0721649484536082
50985,"/** 
 * Creates a DynamicContentFinder.
 * @param dataSourcesConfigUrl URL of repository
 */
public DynamicContentFinder(String dataSourcesConfigUrl){
  super(dataSourcesConfigUrl);
  reloadDataSources();
  timer=new Timer(""String_Node_Str"",true);
  timer.scheduleAtFixedRate(new TimerTask(){
    public void run(){
      reloadDataSources();
    }
  }
,MondrianProperties.instance().XmlaSchemaRefreshInterval.get(),MondrianProperties.instance().XmlaSchemaRefreshInterval.get());
}","/** 
 * Creates a DynamicContentFinder.
 * @param dataSourcesConfigUrl URL of repository
 */
public DynamicContentFinder(String dataSourcesConfigUrl){
  super(dataSourcesConfigUrl);
  reloadDataSources();
  timer=Util.newTimer(""String_Node_Str"",true);
  timer.scheduleAtFixedRate(new TimerTask(){
    public void run(){
      reloadDataSources();
    }
  }
,MondrianProperties.instance().XmlaSchemaRefreshInterval.get(),MondrianProperties.instance().XmlaSchemaRefreshInterval.get());
}",0.9937888198757764
50986,<T>void threadLocalRemove(ThreadLocal<T> threadLocal);,"/** 
 * Removes a thread local from the current thread. <p>From JDK 1.5 onwards, calls   {@link ThreadLocal#remove()}; before that, no-ops.</p>
 * @param threadLocal Thread local
 * @param < T > Type
 */
<T>void threadLocalRemove(ThreadLocal<T> threadLocal);",0.3461538461538461
50987,"public List<Member> slice(final int column){
  return new AbstractList<Member>(){
    @Override public Member get(    int index){
      return list.get(column).get(index);
    }
    @Override public int size(){
      return list.get(column).size();
    }
    public Member set(    int index,    Member element){
      return list.get(column).set(index,element);
    }
  }
;
}","public List<Member> slice(final int column){
  return new AbstractList<Member>(){
    @Override public Member get(    int index){
      return list.get(index).get(column);
    }
    @Override public int size(){
      return list.size();
    }
    public Member set(    int index,    Member element){
      return list.get(index).set(column,element);
    }
  }
;
}",0.924119241192412
50988,"private int getMemberCount(RolapLevel level,DataSource dataSource){
  boolean[] mustCount=new boolean[1];
  String sql=makeLevelMemberCountSql(level,dataSource,mustCount);
  final SqlStatement stmt=RolapUtil.executeQuery(dataSource,sql,new Locus(Locus.peek().execution,""String_Node_Str"",""String_Node_Str"" + level));
  try {
    ResultSet resultSet=stmt.getResultSet();
    int count;
    if (!mustCount[0]) {
      Util.assertTrue(resultSet.next());
      ++stmt.rowCount;
      count=resultSet.getInt(1);
    }
 else {
      ResultSetMetaData rmd=resultSet.getMetaData();
      int nColumns=rmd.getColumnCount();
      String[] colStrings=new String[nColumns];
      count=0;
      while (resultSet.next()) {
        ++stmt.rowCount;
        boolean isEqual=true;
        for (int i=0; i < nColumns; i++) {
          String colStr=resultSet.getString(i + 1);
          if (!colStr.equals(colStrings[i])) {
            isEqual=false;
          }
          colStrings[i]=colStr;
        }
        if (!isEqual) {
          count++;
        }
      }
    }
    return count;
  }
 catch (  SQLException e) {
    throw stmt.handle(e);
  }
 finally {
    stmt.close();
  }
}","private int getMemberCount(RolapLevel level,DataSource dataSource){
  boolean[] mustCount=new boolean[1];
  String sql=makeLevelMemberCountSql(level,dataSource,mustCount);
  final SqlStatement stmt=RolapUtil.executeQuery(dataSource,sql,new Locus(Locus.peek().execution,""String_Node_Str"",""String_Node_Str"" + level));
  try {
    ResultSet resultSet=stmt.getResultSet();
    int count;
    if (!mustCount[0]) {
      Util.assertTrue(resultSet.next());
      ++stmt.rowCount;
      count=resultSet.getInt(1);
    }
 else {
      ResultSetMetaData rmd=resultSet.getMetaData();
      int nColumns=rmd.getColumnCount();
      String[] colStrings=new String[nColumns];
      count=0;
      while (resultSet.next()) {
        ++stmt.rowCount;
        boolean isEqual=true;
        for (int i=0; i < nColumns; i++) {
          String colStr=resultSet.getString(i + 1);
          if (!Util.equals(colStr,colStrings[i])) {
            isEqual=false;
          }
          colStrings[i]=colStr;
        }
        if (!isEqual) {
          count++;
        }
      }
    }
    return count;
  }
 catch (  SQLException e) {
    throw stmt.handle(e);
  }
 finally {
    stmt.close();
  }
}",0.9927443448570208
50989,"/** 
 * Generates the SQL statement to count the members in <code>level</code>. For example, <blockquote> <pre>SELECT count(*) FROM ( SELECT DISTINCT ""country"", ""state_province"" FROM ""customer"") AS ""init""</pre> </blockquote> counts the non-leaf ""state_province"" level. MySQL doesn't allow SELECT-in-FROM, so we use the syntax<blockquote> <pre>SELECT count(DISTINCT ""country"", ""state_province"") FROM ""customer""</pre> </blockquote>. The leaf level requires a different query:<blockquote> <pre>SELECT count(*) FROM ""customer""</pre> </blockquote> counts the leaf ""name"" level of the ""customer"" hierarchy.
 */
private String makeLevelMemberCountSql(RolapLevel level,DataSource dataSource,boolean[] mustCount){
  mustCount[0]=false;
  SqlQuery sqlQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + level);
  int levelDepth=level.getDepth();
  RolapLevel[] levels=(RolapLevel[])hierarchy.getLevels();
  if (levelDepth == levels.length) {
    sqlQuery.addSelect(""String_Node_Str"",null);
    hierarchy.addToFrom(sqlQuery,level.getKeyExp());
    return sqlQuery.toString();
  }
  if (!sqlQuery.getDialect().allowsFromQuery()) {
    List<String> columnList=new ArrayList<String>();
    int columnCount=0;
    for (int i=levelDepth; i >= 0; i--) {
      RolapLevel level2=levels[i];
      if (level2.isAll()) {
        continue;
      }
      if (columnCount > 0) {
        if (sqlQuery.getDialect().allowsCompoundCountDistinct()) {
        }
 else         if (true) {
          mustCount[0]=true;
        }
      }
      hierarchy.addToFrom(sqlQuery,level2.getKeyExp());
      String keyExp=level2.getKeyExp().getExpression(sqlQuery);
      if (columnCount > 0 && !sqlQuery.getDialect().allowsCompoundCountDistinct() && sqlQuery.getDialect().getDatabaseProduct() == Dialect.DatabaseProduct.SYBASE) {
        keyExp=""String_Node_Str"" + columnList + ""String_Node_Str"";
      }
      columnList.add(keyExp);
      if (level2.isUnique()) {
        break;
      }
      ++columnCount;
    }
    if (mustCount[0]) {
      for (      String colDef : columnList) {
        sqlQuery.addSelect(colDef,null);
        sqlQuery.addOrderBy(colDef,true,false,true);
      }
    }
 else {
      int i=0;
      StringBuilder sb=new StringBuilder();
      for (      String colDef : columnList) {
        if (i > 0) {
          sb.append(""String_Node_Str"");
        }
        sb.append(colDef);
      }
      sqlQuery.addSelect(""String_Node_Str"" + sb.toString() + ""String_Node_Str"",null);
    }
    return sqlQuery.toString();
  }
 else {
    sqlQuery.setDistinct(true);
    for (int i=levelDepth; i >= 0; i--) {
      RolapLevel level2=levels[i];
      if (level2.isAll()) {
        continue;
      }
      MondrianDef.Expression keyExp=level2.getKeyExp();
      hierarchy.addToFrom(sqlQuery,keyExp);
      sqlQuery.addSelect(keyExp.getExpression(sqlQuery),null);
      if (level2.isUnique()) {
        break;
      }
    }
    SqlQuery outerQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + level);
    outerQuery.addSelect(""String_Node_Str"",null);
    boolean failIfExists=true;
    outerQuery.addFrom(sqlQuery,""String_Node_Str"",failIfExists);
    return outerQuery.toString();
  }
}","/** 
 * Generates the SQL statement to count the members in <code>level</code>. For example, <blockquote> <pre>SELECT count(*) FROM ( SELECT DISTINCT ""country"", ""state_province"" FROM ""customer"") AS ""init""</pre> </blockquote> counts the non-leaf ""state_province"" level. MySQL doesn't allow SELECT-in-FROM, so we use the syntax<blockquote> <pre>SELECT count(DISTINCT ""country"", ""state_province"") FROM ""customer""</pre> </blockquote>. The leaf level requires a different query:<blockquote> <pre>SELECT count(*) FROM ""customer""</pre> </blockquote> counts the leaf ""name"" level of the ""customer"" hierarchy.
 */
private String makeLevelMemberCountSql(RolapLevel level,DataSource dataSource,boolean[] mustCount){
  mustCount[0]=false;
  SqlQuery sqlQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + level);
  int levelDepth=level.getDepth();
  RolapLevel[] levels=(RolapLevel[])hierarchy.getLevels();
  if (levelDepth == levels.length) {
    sqlQuery.addSelect(""String_Node_Str"",null);
    hierarchy.addToFrom(sqlQuery,level.getKeyExp());
    return sqlQuery.toString();
  }
  if (!sqlQuery.getDialect().allowsFromQuery()) {
    List<String> columnList=new ArrayList<String>();
    int columnCount=0;
    for (int i=levelDepth; i >= 0; i--) {
      RolapLevel level2=levels[i];
      if (level2.isAll()) {
        continue;
      }
      if (columnCount > 0) {
        if (sqlQuery.getDialect().allowsCompoundCountDistinct()) {
        }
 else         if (true) {
          mustCount[0]=true;
        }
      }
      hierarchy.addToFrom(sqlQuery,level2.getKeyExp());
      String keyExp=level2.getKeyExp().getExpression(sqlQuery);
      if (columnCount > 0 && !sqlQuery.getDialect().allowsCompoundCountDistinct() && sqlQuery.getDialect().getDatabaseProduct() == Dialect.DatabaseProduct.SYBASE) {
        keyExp=""String_Node_Str"" + columnList + ""String_Node_Str"";
      }
      columnList.add(keyExp);
      if (level2.isUnique()) {
        break;
      }
      ++columnCount;
    }
    if (mustCount[0]) {
      for (      String colDef : columnList) {
        final String exp=sqlQuery.getDialect().generateCountExpression(colDef);
        sqlQuery.addSelect(exp,null);
        sqlQuery.addOrderBy(exp,true,false,true);
      }
    }
 else {
      int i=0;
      StringBuilder sb=new StringBuilder();
      for (      String colDef : columnList) {
        if (i > 0) {
          sb.append(""String_Node_Str"");
        }
        sb.append(sqlQuery.getDialect().generateCountExpression(colDef));
      }
      sqlQuery.addSelect(""String_Node_Str"" + sb.toString() + ""String_Node_Str"",null);
    }
    return sqlQuery.toString();
  }
 else {
    sqlQuery.setDistinct(true);
    for (int i=levelDepth; i >= 0; i--) {
      RolapLevel level2=levels[i];
      if (level2.isAll()) {
        continue;
      }
      MondrianDef.Expression keyExp=level2.getKeyExp();
      hierarchy.addToFrom(sqlQuery,keyExp);
      sqlQuery.addSelect(keyExp.getExpression(sqlQuery),null);
      if (level2.isUnique()) {
        break;
      }
    }
    SqlQuery outerQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + level);
    outerQuery.addSelect(""String_Node_Str"",null);
    boolean failIfExists=true;
    outerQuery.addFrom(sqlQuery,""String_Node_Str"",failIfExists);
    return outerQuery.toString();
  }
}",0.9704013637068032
50990,"/** 
 * Generates the SQL statement to access the children of <code>member</code>. For example, <blockquote> <pre>SELECT ""city"" FROM ""customer"" WHERE ""country"" = 'USA' AND ""state_province"" = 'BC' GROUP BY ""city""</pre> </blockquote> retrieves the children of the member <code>[Canada].[BC]</code>. <p>Note that this method is never called in the context of virtual cubes, it is only called on regular cubes. <p>See also   {@link SqlTupleReader#makeLevelMembersSql}.
 */
Pair<String,List<SqlStatement.Type>> makeChildMemberSql(RolapMember member,DataSource dataSource,MemberChildrenConstraint constraint){
  SqlQuery sqlQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + member);
  AggStar aggStar=chooseAggStar(constraint,member);
  constraint.addMemberConstraint(sqlQuery,null,aggStar,member);
  RolapLevel level=(RolapLevel)member.getLevel().getChildLevel();
  boolean levelCollapsed=(aggStar != null) && isLevelCollapsed(aggStar,(RolapCubeLevel)level);
  boolean multipleCols=SqlMemberSource.levelContainsMultipleColumns(level);
  if (levelCollapsed && !multipleCols) {
    RolapStar.Column starColumn=((RolapCubeLevel)level).getStarKeyColumn();
    int bitPos=starColumn.getBitPosition();
    AggStar.Table.Column aggColumn=aggStar.lookupColumn(bitPos);
    String q=aggColumn.generateExprString(sqlQuery);
    sqlQuery.addSelectGroupBy(q,starColumn.getInternalType());
    sqlQuery.addOrderBy(q,true,false,true);
    aggColumn.getTable().addToFrom(sqlQuery,false,true);
    return sqlQuery.toSqlAndTypes();
  }
  hierarchy.addToFrom(sqlQuery,level.getKeyExp());
  String q=level.getKeyExp().getExpression(sqlQuery);
  sqlQuery.addSelectGroupBy(q,level.getInternalType());
  constraint.addLevelConstraint(sqlQuery,null,aggStar,level);
  if (levelCollapsed) {
    RolapStar.Column starColumn=((RolapCubeLevel)level).getStarKeyColumn();
    int bitPos=starColumn.getBitPosition();
    AggStar.Table.Column aggColumn=aggStar.lookupColumn(bitPos);
    RolapStar.Condition condition=new RolapStar.Condition(level.getKeyExp(),aggColumn.getExpression());
    sqlQuery.addWhere(condition.toString(sqlQuery));
    hierarchy.addToFromInverse(sqlQuery,level.getKeyExp());
    RolapCubeLevel parentLevel=(RolapCubeLevel)level.getParentLevel();
    boolean isUnique=level.isUnique();
    while (parentLevel != null && !parentLevel.isAll() && !isUnique) {
      hierarchy.addToFromInverse(sqlQuery,parentLevel.getKeyExp());
      starColumn=parentLevel.getStarKeyColumn();
      bitPos=starColumn.getBitPosition();
      aggColumn=aggStar.lookupColumn(bitPos);
      condition=new RolapStar.Condition(parentLevel.getKeyExp(),aggColumn.getExpression());
      sqlQuery.addWhere(condition.toString(sqlQuery));
      parentLevel=parentLevel.getParentLevel();
    }
  }
  if (level.hasCaptionColumn()) {
    MondrianDef.Expression captionExp=level.getCaptionExp();
    if (!levelCollapsed) {
      hierarchy.addToFrom(sqlQuery,captionExp);
    }
    String captionSql=captionExp.getExpression(sqlQuery);
    sqlQuery.addSelectGroupBy(captionSql,null);
  }
  if (!levelCollapsed) {
    hierarchy.addToFrom(sqlQuery,level.getOrdinalExp());
  }
  String orderBy=level.getOrdinalExp().getExpression(sqlQuery);
  sqlQuery.addOrderBy(orderBy,true,false,true);
  if (!orderBy.equals(q)) {
    sqlQuery.addSelectGroupBy(orderBy,null);
  }
  RolapProperty[] properties=level.getProperties();
  for (  RolapProperty property : properties) {
    final MondrianDef.Expression exp=property.getExp();
    if (!levelCollapsed) {
      hierarchy.addToFrom(sqlQuery,exp);
    }
    final String s=exp.getExpression(sqlQuery);
    String alias=sqlQuery.addSelect(s,null,null);
    if (!sqlQuery.getDialect().allowsSelectNotInGroupBy() || !property.dependsOnLevelValue()) {
      sqlQuery.addGroupBy(s,alias);
    }
  }
  return sqlQuery.toSqlAndTypes();
}","/** 
 * Generates the SQL statement to access the children of <code>member</code>. For example, <blockquote> <pre>SELECT ""city"" FROM ""customer"" WHERE ""country"" = 'USA' AND ""state_province"" = 'BC' GROUP BY ""city""</pre> </blockquote> retrieves the children of the member <code>[Canada].[BC]</code>. <p>Note that this method is never called in the context of virtual cubes, it is only called on regular cubes. <p>See also   {@link SqlTupleReader#makeLevelMembersSql}.
 */
Pair<String,List<SqlStatement.Type>> makeChildMemberSql(RolapMember member,DataSource dataSource,MemberChildrenConstraint constraint){
  SqlQuery sqlQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + member);
  AggStar aggStar=chooseAggStar(constraint,member);
  constraint.addMemberConstraint(sqlQuery,null,aggStar,member);
  RolapLevel level=(RolapLevel)member.getLevel().getChildLevel();
  boolean levelCollapsed=(aggStar != null) && isLevelCollapsed(aggStar,(RolapCubeLevel)level);
  boolean multipleCols=SqlMemberSource.levelContainsMultipleColumns(level);
  if (levelCollapsed && !multipleCols) {
    RolapStar.Column starColumn=((RolapCubeLevel)level).getStarKeyColumn();
    int bitPos=starColumn.getBitPosition();
    AggStar.Table.Column aggColumn=aggStar.lookupColumn(bitPos);
    String q=aggColumn.generateExprString(sqlQuery);
    sqlQuery.addSelectGroupBy(q,starColumn.getInternalType());
    sqlQuery.addOrderBy(q,true,false,true);
    aggColumn.getTable().addToFrom(sqlQuery,false,true);
    return sqlQuery.toSqlAndTypes();
  }
  hierarchy.addToFrom(sqlQuery,level.getKeyExp());
  String q=level.getKeyExp().getExpression(sqlQuery);
  sqlQuery.addSelectGroupBy(q,level.getInternalType());
  constraint.addLevelConstraint(sqlQuery,null,aggStar,level);
  if (levelCollapsed) {
    RolapStar.Column starColumn=((RolapCubeLevel)level).getStarKeyColumn();
    int bitPos=starColumn.getBitPosition();
    AggStar.Table.Column aggColumn=aggStar.lookupColumn(bitPos);
    RolapStar.Condition condition=new RolapStar.Condition(level.getKeyExp(),aggColumn.getExpression());
    sqlQuery.addWhere(condition.toString(sqlQuery));
    hierarchy.addToFromInverse(sqlQuery,level.getKeyExp());
    RolapCubeLevel parentLevel=(RolapCubeLevel)level.getParentLevel();
    boolean isUnique=level.isUnique();
    while (parentLevel != null && !parentLevel.isAll() && !isUnique) {
      hierarchy.addToFromInverse(sqlQuery,parentLevel.getKeyExp());
      starColumn=parentLevel.getStarKeyColumn();
      bitPos=starColumn.getBitPosition();
      aggColumn=aggStar.lookupColumn(bitPos);
      condition=new RolapStar.Condition(parentLevel.getKeyExp(),aggColumn.getExpression());
      sqlQuery.addWhere(condition.toString(sqlQuery));
      parentLevel=parentLevel.getParentLevel();
    }
  }
  if (level.hasCaptionColumn()) {
    MondrianDef.Expression captionExp=level.getCaptionExp();
    if (!levelCollapsed) {
      hierarchy.addToFrom(sqlQuery,captionExp);
    }
    String captionSql=captionExp.getExpression(sqlQuery);
    sqlQuery.addSelectGroupBy(captionSql,null);
  }
  if (!levelCollapsed) {
    hierarchy.addToFrom(sqlQuery,level.getOrdinalExp());
  }
  String orderBy=level.getOrdinalExp().getExpression(sqlQuery);
  sqlQuery.addOrderBy(orderBy,true,false,true);
  if (!orderBy.equals(q)) {
    sqlQuery.addSelectGroupBy(orderBy,null);
  }
  RolapProperty[] properties=level.getProperties();
  for (  RolapProperty property : properties) {
    final MondrianDef.Expression exp=property.getExp();
    if (!levelCollapsed) {
      hierarchy.addToFrom(sqlQuery,exp);
    }
    final String s=exp.getExpression(sqlQuery);
    String alias=sqlQuery.addSelect(s,null);
    if (!sqlQuery.getDialect().allowsSelectNotInGroupBy() || !property.dependsOnLevelValue()) {
      sqlQuery.addGroupBy(s,alias);
    }
  }
  return sqlQuery.toSqlAndTypes();
}",0.9993461488165294
50991,"public boolean allowsCountDistinct(){
  return false;
}","public boolean allowsCountDistinct(){
  return true;
}",0.9357798165137616
50992,"public boolean allowsFromQuery(){
  return true;
}","public boolean allowsFromQuery(){
  return false;
}",0.9306930693069309
50993,"protected String dialectize(Dialect.DatabaseProduct d,String sql){
  sql=sql.replaceAll(""String_Node_Str"",""String_Node_Str"");
switch (d) {
case ORACLE:
    return sql.replaceAll(""String_Node_Str"",""String_Node_Str"");
case TERADATA:
  return sql.replaceAll(""String_Node_Str"",""String_Node_Str"");
case DERBY:
return sql.replaceAll(""String_Node_Str"",""String_Node_Str"");
case ACCESS:
return sql.replaceAll(""String_Node_Str"",""String_Node_Str"");
default :
return sql;
}
}","protected String dialectize(Dialect.DatabaseProduct d,String sql){
  sql=sql.replaceAll(""String_Node_Str"",""String_Node_Str"");
switch (d) {
case ORACLE:
    return sql.replaceAll(""String_Node_Str"",""String_Node_Str"");
case GREENPLUM:
case POSTGRESQL:
case TERADATA:
  return sql.replaceAll(""String_Node_Str"",""String_Node_Str"");
case DERBY:
return sql.replaceAll(""String_Node_Str"",""String_Node_Str"");
case ACCESS:
return sql.replaceAll(""String_Node_Str"",""String_Node_Str"");
default :
return sql;
}
}",0.9655891553701772
50994,"public void testDoesDBSupportGroupingSets(){
  final Dialect dialect=getTestContext().getDialect();
  FastBatchingCellReader fbcr=new FastBatchingCellReader(salesCube){
    Dialect getDialect(){
      return dialect;
    }
  }
;
switch (dialect.getDatabaseProduct()) {
case ORACLE:
case TERADATA:
case DB2:
case DB2_AS400:
case DB2_OLD_AS400:
    assertTrue(fbcr.doesDBSupportGroupingSets());
  break;
default :
assertFalse(fbcr.doesDBSupportGroupingSets());
break;
}
}","public void testDoesDBSupportGroupingSets(){
  final Dialect dialect=getTestContext().getDialect();
  FastBatchingCellReader fbcr=new FastBatchingCellReader(salesCube){
    Dialect getDialect(){
      return dialect;
    }
  }
;
switch (dialect.getDatabaseProduct()) {
case ORACLE:
case TERADATA:
case DB2:
case DB2_AS400:
case DB2_OLD_AS400:
case GREENPLUM:
    assertTrue(fbcr.doesDBSupportGroupingSets());
  break;
default :
assertFalse(fbcr.doesDBSupportGroupingSets());
break;
}
}",0.9832285115303984
50995,"/** 
 * Checks that in dialects that request it (e.g. LucidDB), distinct aggregates based on SQL expressions, e.g. <code>count(distinct ""col1"" + ""col2""), count(distinct query)</code>, are loaded individually, and separately from the other aggregates.
 */
public void testLoadDistinctSqlMeasure(){
  final Dialect dialect=getTestContext().getDialect();
switch (dialect.getDatabaseProduct()) {
case ORACLE:
case ACCESS:
case TERADATA:
case NEOVIEW:
case NETEZZA:
    return;
}
String cube=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
cube=cube.replaceAll(""String_Node_Str"",dialect.getQuoteIdentifierString());
if (dialect.getDatabaseProduct() == Dialect.DatabaseProduct.ORACLE) {
  cube=cube.replaceAll(""String_Node_Str"",""String_Node_Str"");
}
String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
TestContext testContext=TestContext.instance().create(null,cube,null,null,null,null);
String desiredResult=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
testContext.assertQueryReturns(query,desiredResult);
String loadCountDistinct_luciddb1=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
String loadCountDistinct_luciddb2=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
String loadOtherAggs_luciddb=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
String loadCountDistinct_derby1=""String_Node_Str"";
String loadCountDistinct_derby2=""String_Node_Str"";
String loadCountDistinct_derby3=""String_Node_Str"";
String loadOtherAggs_derby=""String_Node_Str"";
String load_mysql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
SqlPattern[] patterns={new SqlPattern(Dialect.DatabaseProduct.LUCIDDB,loadCountDistinct_luciddb1,loadCountDistinct_luciddb1),new SqlPattern(Dialect.DatabaseProduct.LUCIDDB,loadCountDistinct_luciddb2,loadCountDistinct_luciddb2),new SqlPattern(Dialect.DatabaseProduct.LUCIDDB,loadOtherAggs_luciddb,loadOtherAggs_luciddb),new SqlPattern(Dialect.DatabaseProduct.DERBY,loadCountDistinct_derby1,loadCountDistinct_derby1),new SqlPattern(Dialect.DatabaseProduct.DERBY,loadCountDistinct_derby2,loadCountDistinct_derby2),new SqlPattern(Dialect.DatabaseProduct.DERBY,loadCountDistinct_derby3,loadCountDistinct_derby3),new SqlPattern(Dialect.DatabaseProduct.DERBY,loadOtherAggs_derby,loadOtherAggs_derby),new SqlPattern(Dialect.DatabaseProduct.MYSQL,load_mysql,load_mysql)};
assertQuerySql(testContext,query,patterns);
}","/** 
 * Checks that in dialects that request it (e.g. LucidDB), distinct aggregates based on SQL expressions, e.g. <code>count(distinct ""col1"" + ""col2""), count(distinct query)</code>, are loaded individually, and separately from the other aggregates.
 */
public void testLoadDistinctSqlMeasure(){
  final Dialect dialect=getTestContext().getDialect();
switch (dialect.getDatabaseProduct()) {
case ORACLE:
case ACCESS:
case TERADATA:
case NEOVIEW:
case NETEZZA:
case GREENPLUM:
    return;
}
String cube=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
cube=cube.replaceAll(""String_Node_Str"",dialect.getQuoteIdentifierString());
if (dialect.getDatabaseProduct() == Dialect.DatabaseProduct.ORACLE) {
  cube=cube.replaceAll(""String_Node_Str"",""String_Node_Str"");
}
String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
TestContext testContext=TestContext.instance().create(null,cube,null,null,null,null);
String desiredResult=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
testContext.assertQueryReturns(query,desiredResult);
String loadCountDistinct_luciddb1=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
String loadCountDistinct_luciddb2=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
String loadOtherAggs_luciddb=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
String loadCountDistinct_derby1=""String_Node_Str"";
String loadCountDistinct_derby2=""String_Node_Str"";
String loadCountDistinct_derby3=""String_Node_Str"";
String loadOtherAggs_derby=""String_Node_Str"";
String load_mysql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
SqlPattern[] patterns={new SqlPattern(Dialect.DatabaseProduct.LUCIDDB,loadCountDistinct_luciddb1,loadCountDistinct_luciddb1),new SqlPattern(Dialect.DatabaseProduct.LUCIDDB,loadCountDistinct_luciddb2,loadCountDistinct_luciddb2),new SqlPattern(Dialect.DatabaseProduct.LUCIDDB,loadOtherAggs_luciddb,loadOtherAggs_luciddb),new SqlPattern(Dialect.DatabaseProduct.DERBY,loadCountDistinct_derby1,loadCountDistinct_derby1),new SqlPattern(Dialect.DatabaseProduct.DERBY,loadCountDistinct_derby2,loadCountDistinct_derby2),new SqlPattern(Dialect.DatabaseProduct.DERBY,loadCountDistinct_derby3,loadCountDistinct_derby3),new SqlPattern(Dialect.DatabaseProduct.DERBY,loadOtherAggs_derby,loadOtherAggs_derby),new SqlPattern(Dialect.DatabaseProduct.MYSQL,load_mysql,load_mysql)};
assertQuerySql(testContext,query,patterns);
}",0.9982078853046596
50996,"/** 
 * Generates the SQL statement to count the members in <code>level</code>. For example, <blockquote> <pre>SELECT count(*) FROM ( SELECT DISTINCT ""country"", ""state_province"" FROM ""customer"") AS ""init""</pre> </blockquote> counts the non-leaf ""state_province"" level. MySQL doesn't allow SELECT-in-FROM, so we use the syntax<blockquote> <pre>SELECT count(DISTINCT ""country"", ""state_province"") FROM ""customer""</pre> </blockquote>. The leaf level requires a different query:<blockquote> <pre>SELECT count(*) FROM ""customer""</pre> </blockquote> counts the leaf ""name"" level of the ""customer"" hierarchy.
 */
private String makeLevelMemberCountSql(RolapLevel level,DataSource dataSource,boolean[] mustCount){
  mustCount[0]=false;
  SqlQuery sqlQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + level);
  int levelDepth=level.getDepth();
  RolapLevel[] levels=(RolapLevel[])hierarchy.getLevels();
  if (levelDepth == levels.length) {
    sqlQuery.addSelect(""String_Node_Str"",null);
    hierarchy.addToFrom(sqlQuery,level.getKeyExp());
    return sqlQuery.toString();
  }
  if (!sqlQuery.getDialect().allowsFromQuery()) {
    String columnList=""String_Node_Str"";
    int columnCount=0;
    for (int i=levelDepth; i >= 0; i--) {
      RolapLevel level2=levels[i];
      if (level2.isAll()) {
        continue;
      }
      if (columnCount > 0) {
        if (sqlQuery.getDialect().allowsCompoundCountDistinct()) {
          columnList+=""String_Node_Str"";
        }
 else         if (true) {
          mustCount[0]=true;
        }
 else         if (sqlQuery.getDialect().getDatabaseProduct() == Dialect.DatabaseProduct.SYBASE) {
          if (columnCount == 1) {
            columnList=""String_Node_Str"" + columnList + ""String_Node_Str"";
          }
          columnList+=""String_Node_Str"";
        }
 else {
          throw Util.newInternal(""String_Node_Str"" + level.getUniqueName() + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
      hierarchy.addToFrom(sqlQuery,level2.getKeyExp());
      String keyExp=level2.getKeyExp().getExpression(sqlQuery);
      if (columnCount > 0 && !sqlQuery.getDialect().allowsCompoundCountDistinct() && sqlQuery.getDialect().getDatabaseProduct() == Dialect.DatabaseProduct.SYBASE) {
        keyExp=""String_Node_Str"" + columnList + ""String_Node_Str"";
      }
      columnList+=keyExp;
      if (level2.isUnique()) {
        break;
      }
      ++columnCount;
    }
    if (mustCount[0]) {
      sqlQuery.addSelect(columnList,null);
      sqlQuery.addOrderBy(columnList,true,false,true);
    }
 else {
      sqlQuery.addSelect(""String_Node_Str"" + columnList + ""String_Node_Str"",null);
    }
    return sqlQuery.toString();
  }
 else {
    sqlQuery.setDistinct(true);
    for (int i=levelDepth; i >= 0; i--) {
      RolapLevel level2=levels[i];
      if (level2.isAll()) {
        continue;
      }
      MondrianDef.Expression keyExp=level2.getKeyExp();
      hierarchy.addToFrom(sqlQuery,keyExp);
      sqlQuery.addSelect(keyExp.getExpression(sqlQuery),null);
      if (level2.isUnique()) {
        break;
      }
    }
    SqlQuery outerQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + level);
    outerQuery.addSelect(""String_Node_Str"",null);
    boolean failIfExists=true;
    outerQuery.addFrom(sqlQuery,""String_Node_Str"",failIfExists);
    return outerQuery.toString();
  }
}","/** 
 * Generates the SQL statement to count the members in <code>level</code>. For example, <blockquote> <pre>SELECT count(*) FROM ( SELECT DISTINCT ""country"", ""state_province"" FROM ""customer"") AS ""init""</pre> </blockquote> counts the non-leaf ""state_province"" level. MySQL doesn't allow SELECT-in-FROM, so we use the syntax<blockquote> <pre>SELECT count(DISTINCT ""country"", ""state_province"") FROM ""customer""</pre> </blockquote>. The leaf level requires a different query:<blockquote> <pre>SELECT count(*) FROM ""customer""</pre> </blockquote> counts the leaf ""name"" level of the ""customer"" hierarchy.
 */
private String makeLevelMemberCountSql(RolapLevel level,DataSource dataSource,boolean[] mustCount){
  mustCount[0]=false;
  SqlQuery sqlQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + level);
  int levelDepth=level.getDepth();
  RolapLevel[] levels=(RolapLevel[])hierarchy.getLevels();
  if (levelDepth == levels.length) {
    sqlQuery.addSelect(""String_Node_Str"",null);
    hierarchy.addToFrom(sqlQuery,level.getKeyExp());
    return sqlQuery.toString();
  }
  if (!sqlQuery.getDialect().allowsFromQuery()) {
    List<String> columnList=new ArrayList<String>();
    int columnCount=0;
    for (int i=levelDepth; i >= 0; i--) {
      RolapLevel level2=levels[i];
      if (level2.isAll()) {
        continue;
      }
      if (columnCount > 0) {
        if (sqlQuery.getDialect().allowsCompoundCountDistinct()) {
        }
 else         if (true) {
          mustCount[0]=true;
        }
      }
      hierarchy.addToFrom(sqlQuery,level2.getKeyExp());
      String keyExp=level2.getKeyExp().getExpression(sqlQuery);
      if (columnCount > 0 && !sqlQuery.getDialect().allowsCompoundCountDistinct() && sqlQuery.getDialect().getDatabaseProduct() == Dialect.DatabaseProduct.SYBASE) {
        keyExp=""String_Node_Str"" + columnList + ""String_Node_Str"";
      }
      columnList.add(keyExp);
      if (level2.isUnique()) {
        break;
      }
      ++columnCount;
    }
    if (mustCount[0]) {
      for (      String colDef : columnList) {
        sqlQuery.addSelect(colDef,null);
        sqlQuery.addOrderBy(colDef,true,false,true);
      }
    }
 else {
      int i=0;
      StringBuilder sb=new StringBuilder();
      for (      String colDef : columnList) {
        if (i > 0) {
          sb.append(""String_Node_Str"");
        }
        sb.append(colDef);
      }
      sqlQuery.addSelect(""String_Node_Str"" + sb.toString() + ""String_Node_Str"",null);
    }
    return sqlQuery.toString();
  }
 else {
    sqlQuery.setDistinct(true);
    for (int i=levelDepth; i >= 0; i--) {
      RolapLevel level2=levels[i];
      if (level2.isAll()) {
        continue;
      }
      MondrianDef.Expression keyExp=level2.getKeyExp();
      hierarchy.addToFrom(sqlQuery,keyExp);
      sqlQuery.addSelect(keyExp.getExpression(sqlQuery),null);
      if (level2.isUnique()) {
        break;
      }
    }
    SqlQuery outerQuery=SqlQuery.newQuery(dataSource,""String_Node_Str"" + level);
    outerQuery.addSelect(""String_Node_Str"",null);
    boolean failIfExists=true;
    outerQuery.addFrom(sqlQuery,""String_Node_Str"",failIfExists);
    return outerQuery.toString();
  }
}",0.7796766743648961
50997,"public void close(){
  if (closed) {
    return;
  }
  this.closed=true;
  final ProfileHandler profileHandler=olap4jStatement.getProfileHandler();
  if (profileHandler != null) {
    final StringWriter stringWriter=new StringWriter();
    final PrintWriter printWriter=new PrintWriter(stringWriter);
    olap4jStatement.getQuery().explain(printWriter);
    printWriter.close();
    profileHandler.explain(stringWriter.toString(),getQueryTiming());
  }
  this.result.close();
}","public void close(){
  if (closed) {
    return;
  }
  this.closed=true;
  final ProfileHandler profileHandler=olap4jStatement.getProfileHandler();
  if (profileHandler != null) {
    final StringWriter stringWriter=new StringWriter();
    final PrintWriter printWriter=new PrintWriter(stringWriter);
    olap4jStatement.getQuery().explain(printWriter);
    printWriter.close();
    profileHandler.explain(stringWriter.toString(),getQueryTiming());
  }
  if (this.result != null) {
    this.result.close();
  }
}",0.9646107178968656
50998,"private synchronized static void initCache(){
  final String cacheName=MondrianProperties.instance().SegmentCache.get();
  if (cacheName != null) {
    setCache(cacheName);
  }
  if (segmentCache == null) {
    final List<Class<SegmentCache>> implementors=serviceDiscovery.getImplementor();
    if (implementors.size() > 0) {
      setCache(implementors.get(0).getName());
    }
  }
}","private synchronized static void initCache(){
  boolean segmentCacheFound=false;
  final String cacheName=MondrianProperties.instance().SegmentCache.get();
  if (cacheName != null) {
    segmentCacheFound=true;
    setCache(cacheName);
  }
  if (segmentCache == null) {
    final List<Class<SegmentCache>> implementors=serviceDiscovery.getImplementor();
    if (implementors.size() > 0) {
      segmentCacheFound=true;
      setCache(implementors.get(0).getName());
    }
  }
  if (!segmentCacheFound) {
    setCache(null);
  }
}",0.8411829134720701
50999,"private Result executeInternal(final Execution execution){
  final Statement statement=execution.getMondrianStatement();
  final Query query=statement.getQuery();
  final MemoryMonitor.Listener listener=new MemoryMonitor.Listener(){
    public void memoryUsageNotification(    long used,    long max){
      execution.setOutOfMemory(""String_Node_Str"" + used + ""String_Node_Str""+ max+ ""String_Node_Str""+ getConnectString());
    }
  }
;
  MemoryMonitor mm=MemoryMonitorFactory.getMemoryMonitor();
  final long currId=execution.getId();
  try {
    mm.addListener(listener);
    execution.checkCancelOrTimeout();
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug(Util.unparse(query));
    }
    if (RolapUtil.MDX_LOGGER.isDebugEnabled()) {
      RolapUtil.MDX_LOGGER.debug(currId + ""String_Node_Str"" + Util.unparse(query));
    }
    statement.start(execution);
    final Locus locus=new Locus(execution,null,""String_Node_Str"");
    Locus.push(locus);
    Result result;
    try {
      result=new RolapResult(execution,true);
      int i=0;
      for (      QueryAxis axis : query.getAxes()) {
        if (axis.isNonEmpty()) {
          result=new NonEmptyResult(result,execution,i);
        }
        ++i;
      }
    }
  finally {
      Locus.pop(locus);
    }
    statement.end(execution);
    return result;
  }
 catch (  ResultLimitExceededException e) {
    throw e;
  }
catch (  Exception e) {
    statement.end(execution);
    String queryString;
    try {
      queryString=Util.unparse(query);
    }
 catch (    Exception e1) {
      queryString=""String_Node_Str"";
    }
    throw Util.newError(e,""String_Node_Str"" + queryString + ""String_Node_Str"");
  }
 finally {
    mm.removeListener(listener);
    if (RolapUtil.MDX_LOGGER.isDebugEnabled()) {
      final long elapsed=execution.getElapsedMillis();
      RolapUtil.MDX_LOGGER.debug(currId + ""String_Node_Str"" + elapsed+ ""String_Node_Str"");
    }
  }
}","private Result executeInternal(final Execution execution){
  final Statement statement=execution.getMondrianStatement();
synchronized (statement) {
    final Execution previousExecution=statement.getCurrentExecution();
    if (previousExecution != null) {
      statement.end(previousExecution);
    }
  }
  final Query query=statement.getQuery();
  final MemoryMonitor.Listener listener=new MemoryMonitor.Listener(){
    public void memoryUsageNotification(    long used,    long max){
      execution.setOutOfMemory(""String_Node_Str"" + used + ""String_Node_Str""+ max+ ""String_Node_Str""+ getConnectString());
    }
  }
;
  MemoryMonitor mm=MemoryMonitorFactory.getMemoryMonitor();
  final long currId=execution.getId();
  try {
    mm.addListener(listener);
    execution.checkCancelOrTimeout();
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug(Util.unparse(query));
    }
    if (RolapUtil.MDX_LOGGER.isDebugEnabled()) {
      RolapUtil.MDX_LOGGER.debug(currId + ""String_Node_Str"" + Util.unparse(query));
    }
    statement.start(execution);
    final Locus locus=new Locus(execution,null,""String_Node_Str"");
    Locus.push(locus);
    Result result;
    try {
      result=new RolapResult(execution,true);
      int i=0;
      for (      QueryAxis axis : query.getAxes()) {
        if (axis.isNonEmpty()) {
          result=new NonEmptyResult(result,execution,i);
        }
        ++i;
      }
    }
  finally {
      Locus.pop(locus);
    }
    statement.end(execution);
    return result;
  }
 catch (  ResultLimitExceededException e) {
    throw e;
  }
catch (  Exception e) {
    try {
      statement.end(execution);
    }
 catch (    Exception e1) {
    }
    String queryString;
    try {
      queryString=Util.unparse(query);
    }
 catch (    Exception e1) {
      queryString=""String_Node_Str"";
    }
    throw Util.newError(e,""String_Node_Str"" + queryString + ""String_Node_Str"");
  }
 finally {
    mm.removeListener(listener);
    if (RolapUtil.MDX_LOGGER.isDebugEnabled()) {
      final long elapsed=execution.getElapsedMillis();
      RolapUtil.MDX_LOGGER.debug(currId + ""String_Node_Str"" + elapsed+ ""String_Node_Str"");
    }
  }
}",0.929535968573533
51000,"/** 
 * Creates a MondrianOlap4jDriver.
 */
MondrianOlap4jDriver(){
  this.factory=createFactory();
}","/** 
 * Creates a MondrianOlap4jDriver.
 */
public MondrianOlap4jDriver(){
  this.factory=createFactory();
}",0.9665071770334928
