record_number,buggy_code,fixed_code,code_similarity
1001,"public void setUsingContentHeight(boolean usingContentHeight){
  this.usingContentHeight=usingContentHeight;
}","public RelativeLayoutHint setUsingContentHeight(boolean value){
  this.usingContentHeight=value;
  return this;
}",0.6905829596412556
1002,"/** 
 * Registers an object as a command provider - all methods annotated with @Command will be made available on the console.
 * @param provider
 */
@Override public void registerCommandProvider(Object provider){
  Predicate<? super Method> predicate=Predicates.<Method>and(withModifier(Modifier.PUBLIC),ReflectionUtils.withAnnotation(Command.class));
  Set<Method> commandMethods=ReflectionUtils.getAllMethods(provider.getClass(),predicate);
  if (!commandMethods.isEmpty()) {
    for (    Method method : commandMethods) {
      CommandInfo command=new CommandInfo(method,provider);
      commands.add(command);
      commandLookup.put(command.getName(),command.getParameterCount(),command);
    }
    commandsSorted=false;
  }
}","/** 
 * Registers an object as a command provider - all methods annotated with @Command will be made available on the console.
 * @param provider
 */
@Override public void registerCommandProvider(Object provider){
  Predicate<? super Method> predicate=Predicates.<Method>and(withModifier(Modifier.PUBLIC),ReflectionUtils.withAnnotation(Command.class));
  Set<Method> commandMethods=ReflectionUtils.getAllMethods(provider.getClass(),predicate);
  if (!commandMethods.isEmpty()) {
    for (    Method method : commandMethods) {
      CommandInfo command=new CommandInfo(method,provider);
      if (commandLookup.contains(command.getName(),command.getParameterCount())) {
        logger.warn(""String_Node_Str"",command.getName(),command.getParameterCount());
      }
 else {
        commands.add(command);
        commandLookup.put(command.getName(),command.getParameterCount(),command);
      }
    }
    commandsSorted=false;
  }
}",0.8236002408187839
1003,"private BehaviorTreeData buildSample(){
  SequenceNode sequence=new SequenceNode();
  sequence.children().add(new CounterNode(1));
  sequence.children().add(new RepeatNode(new CounterNode(2)));
  ParallelNode parallel=new ParallelNode(ParallelNode.Policy.RequireAll,ParallelNode.Policy.RequireAll);
  sequence.children().add(parallel);
  parallel.children().add(new MonitorNode());
  parallel.children().add(new CounterNode(3));
  BehaviorTreeData tree=new BehaviorTreeData();
  tree.setRoot(sequence);
  tree.createRenderable();
  return tree;
}","private BehaviorTreeData buildSample(){
  SequenceNode sequence=new SequenceNode();
  sequence.children().add(new CounterNode(1));
  sequence.children().add(new RepeatNode(new CounterNode(2)));
  ParallelNode parallel=new ParallelNode(ParallelNode.Policy.RequireAll,ParallelNode.Policy.RequireAll);
  sequence.children().add(parallel);
  parallel.children().add(new MonitorNode());
  parallel.children().add(new CounterNode(3));
  BehaviorTreeData tree=new BehaviorTreeData();
  tree.setRoot(sequence);
  tree.createRenderable();
  tree.layout(null);
  return tree;
}",0.981132075471698
1004,"@Test public void testSaveLoad() throws IOException {
  AssetManager assetManager=mock(AssetManager.class);
  CoreRegistry.put(AssetManager.class,assetManager);
  BehaviorTreeLoader loader=new BehaviorTreeLoader();
  BehaviorTreeData data=buildSample();
  OutputStream os=new ByteArrayOutputStream(10000);
  loader.save(os,data);
  String jsonExpected=os.toString();
  data=loader.load(null,new ByteArrayInputStream(jsonExpected.getBytes()),null);
  os=new ByteArrayOutputStream(10000);
  loader=new BehaviorTreeLoader();
  loader.save(os,data);
  String jsonActual=os.toString();
  Assert.assertEquals(jsonActual,jsonExpected);
  System.out.println(jsonActual);
}","@Test public void testSaveLoad() throws IOException {
  AssetManager assetManager=mock(AssetManager.class);
  CoreRegistry.put(AssetManager.class,assetManager);
  BehaviorNodeFactory nodeFactory=mock(BehaviorNodeFactory.class);
  CoreRegistry.put(BehaviorNodeFactory.class,nodeFactory);
  BehaviorTreeLoader loader=new BehaviorTreeLoader();
  BehaviorTreeData data=buildSample();
  OutputStream os=new ByteArrayOutputStream(10000);
  loader.save(os,data);
  String jsonExpected=os.toString();
  data=loader.load(null,new ByteArrayInputStream(jsonExpected.getBytes()),null);
  os=new ByteArrayOutputStream(10000);
  loader=new BehaviorTreeLoader();
  loader.save(os,data);
  String jsonActual=os.toString();
  Assert.assertEquals(jsonActual,jsonExpected);
}",0.8873239436619719
1005,"@Override public Node read(JsonReader in) throws IOException {
  int id=in.nextInt();
  return treeGson.getNode(id);
}","@Override public RenderableNode read(JsonReader in) throws IOException {
  in.beginObject();
  nextName(in,""String_Node_Str"");
  int id=in.nextInt();
  Node node=treeGson.getNode(id);
  RenderableNode renderableNode=new RenderableNode(CoreRegistry.get(BehaviorNodeFactory.class).getNodeComponent(node));
  renderableNode.setNode(node);
  nextName(in,""String_Node_Str"");
  in.beginArray();
  float x=(float)in.nextDouble();
  float y=(float)in.nextDouble();
  in.endArray();
  renderableNode.setPosition(x,y);
  nextName(in,""String_Node_Str"");
  in.beginArray();
  x=(float)in.nextDouble();
  y=(float)in.nextDouble();
  in.endArray();
  renderableNode.setSize(new Vector2f(x,y));
  nextName(in,""String_Node_Str"");
  in.beginArray();
  int i=0;
  while (in.hasNext()) {
    RenderableNode child=gsonNode.fromJson(in,RenderableNode.class);
    renderableNode.setChild(i,child);
    i++;
  }
  in.endArray();
  in.endObject();
  return renderableNode;
}",0.1685393258426966
1006,"private RenderableBehaviorTreeGson(){
  gsonNode=new GsonBuilder().setPrettyPrinting().registerTypeHierarchyAdapter(Node.class,new NodeTypeAdapter()).create();
}","private RenderableBehaviorTreeGson(){
  gsonNode=new GsonBuilder().setPrettyPrinting().registerTypeHierarchyAdapter(Node.class,new NodeTypeAdapter()).registerTypeHierarchyAdapter(RenderableNode.class,new RenderableNodeTypeAdapter()).create();
}",0.7950617283950617
1007,"@Override public void write(JsonWriter out,Node value) throws IOException {
  int id=treeGson.getId(value);
  out.value(id);
}","@Override public void write(JsonWriter out,RenderableNode value) throws IOException {
  out.beginObject().name(""String_Node_Str"").value(treeGson.getId(value.getNode())).name(""String_Node_Str"").beginArray().value(value.getPosition().x).value(value.getPosition().y).endArray().name(""String_Node_Str"").beginArray().value(value.getSize().x).value(value.getSize().y).endArray().name(""String_Node_Str"");
  gsonNode.toJson(value.children(),List.class,out);
  out.endObject();
}",0.3590604026845637
1008,"@Override public void onInitialize(){
  count=Math.max(1,getNode().limit);
}","@Override public void onInitialize(){
  count=getNode().limit;
}",0.9142857142857144
1009,"public void tick(float dt){
  if (debugger == null || debugger.beforeTick()) {
    while (step(dt)) {
      continue;
    }
    if (debugger != null) {
      debugger.afterTick();
    }
  }
}","public void tick(float dt){
  if (debugger == null || debugger.beforeTick()) {
    startedNodes.clear();
    while (step(dt)) {
      continue;
    }
    if (debugger != null) {
      debugger.afterTick();
    }
  }
}",0.9362745098039216
1010,"public void stop(Task task,Status result){
  task.setStatus(result);
  Task.Observer observer=task.getObserver();
  if (observer != null) {
    observer.handle(result);
  }
}","public void stop(Task task,Status result){
  task.setStatus(result);
  Task.Observer observer=task.getObserver();
  if (observer != null) {
    observer.handle(result);
  }
  tasks.remove(task);
  if (debugger != null) {
    debugger.nodeFinished(task.getNode(),result);
  }
}",0.7733333333333333
1011,"public boolean step(float dt){
  Task current=tasks.pollFirst();
  if (current == TERMINAL) {
    tasks.addLast(TERMINAL);
    return false;
  }
  current.tick(dt);
  if (current.getStatus() != Status.RUNNING && current.getObserver() != null) {
    logger.info(""String_Node_Str"" + current + ""String_Node_Str""+ current.getStatus());
    if (debugger != null) {
      debugger.nodeFinished(current.getNode(),current.getStatus());
    }
    current.getObserver().handle(current.getStatus());
  }
 else {
    tasks.addLast(current);
    if (debugger != null) {
      debugger.nodeUpdated(current.getNode(),current.getStatus());
    }
  }
  return true;
}","public boolean step(float dt){
  Task current=tasks.pollFirst();
  if (current == TERMINAL) {
    tasks.addLast(TERMINAL);
    return false;
  }
  if (startedNodes.contains(current.getNode())) {
    tasks.addLast(current);
    return true;
  }
  startedNodes.add(current.getNode());
  current.tick(dt);
  if (current.getStatus() != Status.RUNNING && current.getObserver() != null) {
    if (debugger != null) {
      debugger.nodeFinished(current.getNode(),current.getStatus());
    }
    current.getObserver().handle(current.getStatus());
  }
 else {
    tasks.addLast(current);
    if (debugger != null) {
      debugger.nodeUpdated(current.getNode(),current.getStatus());
    }
  }
  return true;
}",0.8334566987416728
1012,"@Override public void onInitialize(){
  interpreter().start(getNode().child,this);
}","@Override public void onInitialize(){
  if (getNode().child != null) {
    interpreter().start(getNode().child,this);
  }
}",0.8115942028985508
1013,"@Override public void handle(Status result){
  if (result == Status.FAILURE) {
    interpreter().stop(this,Status.FAILURE);
    return;
  }
  interpreter().start(getNode().child,this);
}","@Override public void handle(Status result){
  if (result == Status.FAILURE) {
    interpreter().stop(this,Status.FAILURE);
    return;
  }
  if (getNode().child != null) {
    interpreter().start(getNode().child,this);
  }
}",0.8175182481751825
1014,"public PropertyProvider(T target){
  factories.put(Range.class,new RangePropertyFactory());
  factories.put(Checkbox.class,new CheckboxPropertyFactory());
  factories.put(OneOf.List.class,new OneOfListPropertyFactory());
  factories.put(TextField.class,new TextPropertyFactory());
  try {
    this.target=target;
    Class<?> type=target.getClass();
    ReflectFactory reflectFactory=CoreRegistry.get(ReflectFactory.class);
    CopyStrategyLibrary copyStrategies=new CopyStrategyLibrary(reflectFactory);
    ClassMetadata<?,?> classMetadata=new DefaultClassMetadata<>(new SimpleUri(),type,reflectFactory,copyStrategies);
    for (    Field field : getAllFields(type)) {
      Annotation annotation=getFactory(field);
      if (annotation != null) {
        FieldMetadata<Object,?> fieldMetadata=(FieldMetadata<Object,?>)classMetadata.getField(field.getName());
        PropertyFactory factory=factories.get(annotation.annotationType());
        Property property=factory.create(fieldMetadata,field.getName(),annotation);
        properties.add(property);
      }
    }
  }
 catch (  NoSuchMethodException e) {
    throw new RuntimeException(e);
  }
}","public PropertyProvider(T target){
  factories.put(Range.class,new RangePropertyFactory());
  factories.put(Checkbox.class,new CheckboxPropertyFactory());
  factories.put(OneOf.List.class,new OneOfListPropertyFactory());
  factories.put(OneOf.Enum.class,new OneOfEnumPropertyFactory());
  factories.put(TextField.class,new TextPropertyFactory());
  try {
    this.target=target;
    Class<?> type=target.getClass();
    ReflectFactory reflectFactory=CoreRegistry.get(ReflectFactory.class);
    CopyStrategyLibrary copyStrategies=new CopyStrategyLibrary(reflectFactory);
    ClassMetadata<?,?> classMetadata=new DefaultClassMetadata<>(new SimpleUri(),type,reflectFactory,copyStrategies);
    for (    Field field : getAllFields(type)) {
      Annotation annotation=getFactory(field);
      if (annotation != null) {
        FieldMetadata<Object,?> fieldMetadata=(FieldMetadata<Object,?>)classMetadata.getField(field.getName());
        PropertyFactory factory=factories.get(annotation.annotationType());
        Property property=factory.create(fieldMetadata,field.getName(),annotation);
        properties.add(property);
      }
    }
  }
 catch (  NoSuchMethodException e) {
    throw new RuntimeException(e);
  }
}",0.9721048182586643
1015,"/** 
 * Note: Keep an eye out for recursive delete being added to the core Java API in the future - there are certain circumstances in which this can be unsafe.
 * @param path
 * @throws IOException
 */
public static void recursiveDelete(Path path) throws IOException {
  Files.walkFileTree(path,new SimpleFileVisitor<Path>(){
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attrs) throws IOException {
      Files.delete(file);
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult visitFileFailed(    Path file,    IOException exc) throws IOException {
      Files.delete(file);
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult postVisitDirectory(    Path dir,    IOException exc) throws IOException {
      if (exc == null) {
        Files.delete(dir);
        return FileVisitResult.CONTINUE;
      }
 else {
        throw exc;
      }
    }
  }
);
}","/** 
 * Note: Keep an eye out for recursive delete being added to the core Java API in the future - there are certain circumstances in which this can be unsafe.
 * @param path
 * @throws IOException
 */
public static void recursiveDelete(Path path) throws IOException {
  if (Files.isDirectory(path)) {
    Files.walkFileTree(path,new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult visitFile(      Path file,      BasicFileAttributes attrs) throws IOException {
        Files.delete(file);
        return FileVisitResult.CONTINUE;
      }
      @Override public FileVisitResult visitFileFailed(      Path file,      IOException exc) throws IOException {
        Files.delete(file);
        return FileVisitResult.CONTINUE;
      }
      @Override public FileVisitResult postVisitDirectory(      Path dir,      IOException exc) throws IOException {
        if (exc == null) {
          Files.delete(dir);
          return FileVisitResult.CONTINUE;
        }
 else {
          throw exc;
        }
      }
    }
);
  }
}",0.9572649572649572
1016,"@Override public void purgeChunks(){
  ChunkMonitor.fireChunkProviderDisposed(this);
  pipeline.shutdown();
  unloadRequestTaskMaster.shutdown(new ChunkUnloadRequest(),true);
  for (  ChunkImpl chunk : nearCache.values()) {
    worldEntity.send(new BeforeChunkUnload(chunk.getPos()));
    chunk.dispose();
    ChunkStore store=storageManager.createChunkStoreForSave(chunk);
    store.storeAllEntities();
    store.save();
  }
  nearCache.clear();
  storageManager.purgeChunks();
  this.pipeline=new ChunkGenerationPipeline(this,generator,new ChunkTaskRelevanceComparator());
  this.unloadRequestTaskMaster=TaskMaster.createFIFOTaskMaster(""String_Node_Str"",8);
  ChunkMonitor.fireChunkProviderInitialized(this);
  for (  ChunkRelevanceRegion chunkRelevanceRegion : regions.values()) {
    pipeline.requestProduction(chunkRelevanceRegion.getRegion().expand(new Vector3i(2,0,2)));
    chunkRelevanceRegion.setUpToDate();
  }
}","@Override public void purgeChunks(){
  ChunkMonitor.fireChunkProviderDisposed(this);
  pipeline.shutdown();
  unloadRequestTaskMaster.shutdown(new ChunkUnloadRequest(),true);
  for (  ChunkImpl chunk : nearCache.values()) {
    if (chunk.getChunkState() == ChunkImpl.State.COMPLETE && chunk.isReady()) {
      worldEntity.send(new BeforeChunkUnload(chunk.getPos()));
    }
    chunk.dispose();
    ChunkStore store=storageManager.createChunkStoreForSave(chunk);
    store.storeAllEntities();
    store.save();
  }
  nearCache.clear();
  storageManager.purgeChunks();
  this.pipeline=new ChunkGenerationPipeline(this,generator,new ChunkTaskRelevanceComparator());
  this.unloadRequestTaskMaster=TaskMaster.createFIFOTaskMaster(""String_Node_Str"",8);
  ChunkMonitor.fireChunkProviderInitialized(this);
  for (  ChunkRelevanceRegion chunkRelevanceRegion : regions.values()) {
    pipeline.requestProduction(chunkRelevanceRegion.getRegion().expand(new Vector3i(2,0,2)));
    chunkRelevanceRegion.setUpToDate();
  }
}",0.954498448810755
1017,"public ModuleClassLoader(URL[] urls,ClassLoader parent,ModuleSecurityManager securityManager){
  super(urls,parent);
  this.securityManager=securityManager;
  pool=new ClassPool(ClassPool.getDefault());
  for (  URL url : urls) {
    try {
      pool.appendClassPath(url.getFile());
    }
 catch (    NotFoundException e) {
      logger.error(""String_Node_Str"",url);
    }
  }
}","public ModuleClassLoader(URL[] urls,ClassLoader parent,ModuleSecurityManager securityManager){
  super(urls,parent);
  this.securityManager=securityManager;
  pool=new ClassPool(ClassPool.getDefault());
  for (  URL url : urls) {
    try {
      pool.appendClassPath(Paths.get(url.toURI()).toString());
    }
 catch (    NotFoundException|URISyntaxException e) {
      logger.error(""String_Node_Str"",url);
    }
  }
}",0.9232704402515725
1018,"private void initConfig(){
  if (Files.isRegularFile(Config.getConfigFile())) {
    try {
      config=Config.load(Config.getConfigFile());
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"",e);
      config=new Config();
    }
  }
 else {
    config=new Config();
  }
  if (!config.getDefaultModSelection().hasModule(""String_Node_Str"")) {
    config.getDefaultModSelection().addModule(""String_Node_Str"");
  }
  if (config.getSecurity().getServerPrivateCertificate() == null) {
    CertificateGenerator generator=new CertificateGenerator();
    CertificatePair serverIdentity=generator.generateSelfSigned();
    config.getSecurity().setServerCredentials(serverIdentity.getPublicCert(),serverIdentity.getPrivateCert());
    config.save();
  }
  logger.info(""String_Node_Str"" + config.getRendering().toString());
  logger.info(""String_Node_Str"" + config.getRendering().getDebug().toString());
  CoreRegistry.putPermanently(Config.class,config);
}","private void initConfig(){
  if (Files.isRegularFile(Config.getConfigFile())) {
    try {
      config=Config.load(Config.getConfigFile());
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"",e);
      config=new Config();
    }
  }
 else {
    config=new Config();
  }
  if (!config.getDefaultModSelection().hasModule(""String_Node_Str"")) {
    config.getDefaultModSelection().addModule(""String_Node_Str"");
  }
  if (config.getSecurity().getServerPrivateCertificate() == null) {
    CertificateGenerator generator=new CertificateGenerator();
    CertificatePair serverIdentity=generator.generateSelfSigned();
    config.getSecurity().setServerCredentials(serverIdentity.getPublicCert(),serverIdentity.getPrivateCert());
    config.save();
  }
  logger.info(""String_Node_Str"" + config.getRendering().toString());
  CoreRegistry.putPermanently(Config.class,config);
}",0.9524324324324324
1019,"public UIMenuConfigVideo(){
  setId(""String_Node_Str"");
  setBackgroundImage(""String_Node_Str"");
  setModal(true);
  maximize();
  title=new UIImage(Assets.getTexture(""String_Node_Str""));
  title.setHorizontalAlign(EHorizontalAlign.CENTER);
  title.setPosition(new Vector2f(0f,128f));
  title.setVisible(true);
  title.setSize(new Vector2f(512f,128f));
  version=new UILabel(""String_Node_Str"");
  version.setHorizontalAlign(EHorizontalAlign.CENTER);
  version.setPosition(new Vector2f(0f,230f));
  version.setVisible(true);
  graphicsQualityButton=new UIStateButton(new Vector2f(256f,32f));
  StateButtonAction graphicsQualityStateAction=new StateButtonAction(){
    @Override public void action(    UIDisplayElement element){
      UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
        config.getRendering().setFlickeringLight(true);
      config.getRendering().setVignette(true);
    config.getRendering().setEyeAdaptation(true);
  config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(false);
config.getRendering().setMotionBlur(false);
config.getRendering().setSsao(false);
config.getRendering().setLightShafts(false);
config.getRendering().setCloudShadows(false);
break;
case 1:
config.getRendering().setFlickeringLight(true);
config.getRendering().setVignette(true);
config.getRendering().setEyeAdaptation(true);
config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(true);
config.getRendering().setSsao(false);
config.getRendering().setMotionBlur(false);
config.getRendering().setLightShafts(false);
config.getRendering().setCloudShadows(false);
break;
case 2:
config.getRendering().setFlickeringLight(true);
config.getRendering().setVignette(true);
config.getRendering().setEyeAdaptation(true);
config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(true);
config.getRendering().setMotionBlur(true);
config.getRendering().setLightShafts(true);
config.getRendering().setCloudShadows(true);
config.getRendering().setSsao(false);
break;
case 3:
config.getRendering().setFlickeringLight(true);
config.getRendering().setVignette(true);
config.getRendering().setEyeAdaptation(true);
config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(true);
config.getRendering().setMotionBlur(true);
config.getRendering().setSsao(true);
config.getRendering().setLightShafts(true);
config.getRendering().setCloudShadows(true);
break;
}
}
}
;
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addClickListener(clickAction);
graphicsQualityButton.setHorizontalAlign(EHorizontalAlign.CENTER);
graphicsQualityButton.setPosition(new Vector2f(-graphicsQualityButton.getSize().x / 2f - 10f,300f));
graphicsQualityButton.setVisible(true);
viewingDistanceButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction viewingDistanceStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setViewDistance(ViewDistance.forIndex(button.getState()));
}
}
;
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addClickListener(clickAction);
viewingDistanceButton.setHorizontalAlign(EHorizontalAlign.CENTER);
viewingDistanceButton.setPosition(new Vector2f(-viewingDistanceButton.getSize().x / 2f - 10f,300f + 40f));
viewingDistanceButton.setVisible(true);
fovButton=new UISlider(new Vector2f(256f,32f),75,130);
fovButton.addChangedListener(new ChangedListener(){
@Override public void changed(UIDisplayElement element){
UISlider slider=(UISlider)element;
slider.setText(""String_Node_Str"" + String.valueOf(slider.getValue()));
config.getRendering().setFieldOfView(slider.getValue());
}
}
);
fovButton.setHorizontalAlign(EHorizontalAlign.CENTER);
fovButton.setPosition(new Vector2f(-fovButton.getSize().x / 2f - 10f,300f + 2 * 40f));
fovButton.setVisible(true);
bobbingButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction bobbingStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setCameraBobbing(button.getState() != 0);
}
}
;
bobbingButton.addState(""String_Node_Str"",bobbingStateAction);
bobbingButton.addState(""String_Node_Str"",bobbingStateAction);
bobbingButton.addClickListener(clickAction);
bobbingButton.setHorizontalAlign(EHorizontalAlign.CENTER);
bobbingButton.setPosition(new Vector2f(-bobbingButton.getSize().x / 2f - 10f,300f + 3 * 40f));
bobbingButton.setVisible(true);
reflectiveWaterButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction reflectiveWaterStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
config.getRendering().setReflectiveWater(false);
config.getRendering().setLocalReflections(false);
break;
case 1:
config.getRendering().setReflectiveWater(false);
config.getRendering().setLocalReflections(true);
break;
case 2:
config.getRendering().setReflectiveWater(true);
config.getRendering().setLocalReflections(true);
break;
}
}
}
;
reflectiveWaterButton.addState(""String_Node_Str"",reflectiveWaterStateAction);
reflectiveWaterButton.addState(""String_Node_Str"",reflectiveWaterStateAction);
reflectiveWaterButton.addState(""String_Node_Str"",reflectiveWaterStateAction);
reflectiveWaterButton.addClickListener(clickAction);
reflectiveWaterButton.setHorizontalAlign(EHorizontalAlign.CENTER);
reflectiveWaterButton.setPosition(new Vector2f(reflectiveWaterButton.getSize().x / 2f,300f + 40f));
reflectiveWaterButton.setVisible(true);
blurIntensityButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction blurIntensityStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setBlurIntensity(button.getState());
}
}
;
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addClickListener(clickAction);
blurIntensityButton.setHorizontalAlign(EHorizontalAlign.CENTER);
blurIntensityButton.setPosition(new Vector2f(blurIntensityButton.getSize().x / 2f,300f + 2 * 40f));
blurIntensityButton.setVisible(true);
fullscreenButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction fullscreenStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
TerasologyEngine te=(TerasologyEngine)CoreRegistry.get(GameEngine.class);
if (button.getState() == 0) {
te.setFullscreen(false);
}
 else {
te.setFullscreen(true);
}
}
}
;
fullscreenButton.addState(""String_Node_Str"",fullscreenStateAction);
fullscreenButton.addState(""String_Node_Str"",fullscreenStateAction);
fullscreenButton.addClickListener(clickAction);
fullscreenButton.setHorizontalAlign(EHorizontalAlign.CENTER);
fullscreenButton.setPosition(new Vector2f(fullscreenButton.getSize().x / 2f,300f + 3 * 40f));
fullscreenButton.setVisible(true);
outlineButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction outlineStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setOutline(button.getState() != 0);
}
}
;
outlineButton.addState(""String_Node_Str"",outlineStateAction);
outlineButton.addState(""String_Node_Str"",outlineStateAction);
outlineButton.addClickListener(clickAction);
outlineButton.setHorizontalAlign(EHorizontalAlign.CENTER);
outlineButton.setPosition(new Vector2f(outlineButton.getSize().x / 2f,300f + 4 * 40f));
outlineButton.setVisible(true);
shadowButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction shadowStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
config.getRendering().setDynamicShadowsPcfFiltering(false);
config.getRendering().setDynamicShadows(false);
break;
case 1:
config.getRendering().setDynamicShadowsPcfFiltering(false);
config.getRendering().setDynamicShadows(true);
break;
case 2:
config.getRendering().setDynamicShadowsPcfFiltering(true);
config.getRendering().setDynamicShadows(true);
break;
}
}
}
;
shadowButton.addState(""String_Node_Str"",shadowStateAction);
shadowButton.addState(""String_Node_Str"",shadowStateAction);
shadowButton.addState(""String_Node_Str"",shadowStateAction);
shadowButton.addClickListener(clickAction);
shadowButton.setHorizontalAlign(EHorizontalAlign.CENTER);
shadowButton.setPosition(new Vector2f(-shadowButton.getSize().x / 2f - 10f,300f + 4 * 40f));
shadowButton.setVisible(true);
environmentEffectsButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction environmentEffectsStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
config.getRendering().setVolumetricLighting(false);
config.getRendering().setVolumetricFog(false);
config.getRendering().setAnimateGrass(false);
config.getRendering().setAnimateWater(false);
break;
case 1:
config.getRendering().setVolumetricLighting(false);
config.getRendering().setAnimateWater(false);
config.getRendering().setVolumetricFog(true);
config.getRendering().setAnimateGrass(true);
break;
case 2:
config.getRendering().setVolumetricLighting(false);
config.getRendering().setAnimateWater(true);
config.getRendering().setVolumetricFog(true);
config.getRendering().setAnimateGrass(true);
break;
case 3:
config.getRendering().setVolumetricLighting(true);
config.getRendering().setAnimateWater(true);
config.getRendering().setVolumetricFog(true);
config.getRendering().setAnimateGrass(true);
break;
}
}
}
;
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addClickListener(clickAction);
environmentEffectsButton.setHorizontalAlign(EHorizontalAlign.CENTER);
environmentEffectsButton.setPosition(new Vector2f(environmentEffectsButton.getSize().x / 2f,300f));
environmentEffectsButton.setVisible(true);
vSyncButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction vSyncStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
TerasologyEngine te=(TerasologyEngine)CoreRegistry.get(GameEngine.class);
if (button.getState() == 0) {
te.setVSync(false);
}
 else {
te.setVSync(true);
}
}
}
;
vSyncButton.addState(""String_Node_Str"",vSyncStateAction);
vSyncButton.addState(""String_Node_Str"",vSyncStateAction);
vSyncButton.addClickListener(clickAction);
vSyncButton.setHorizontalAlign(EHorizontalAlign.CENTER);
vSyncButton.setPosition(new Vector2f(-vSyncButton.getSize().x / 2f - 10f,300f + 5 * 40f));
vSyncButton.setVisible(true);
backToConfigMenuButton=new UIButton(new Vector2f(256f,32f),UIButton.ButtonType.NORMAL);
backToConfigMenuButton.getLabel().setText(""String_Node_Str"");
backToConfigMenuButton.setHorizontalAlign(EHorizontalAlign.CENTER);
backToConfigMenuButton.setPosition(new Vector2f(0f,300f + 7 * 40f));
backToConfigMenuButton.setVisible(true);
backToConfigMenuButton.addClickListener(new ClickListener(){
@Override public void click(UIDisplayElement element,int button){
logger.info(""String_Node_Str"" + config.getRendering().toString());
logger.info(""String_Node_Str"" + config.getRendering().getDebug().toString());
CoreRegistry.get(ShaderManager.class).recompileAllShaders();
getGUIManager().openWindow(""String_Node_Str"");
}
}
);
addDisplayElement(title);
addDisplayElement(version);
addDisplayElement(graphicsQualityButton);
addDisplayElement(fovButton);
addDisplayElement(viewingDistanceButton);
addDisplayElement(reflectiveWaterButton);
addDisplayElement(blurIntensityButton);
addDisplayElement(bobbingButton);
addDisplayElement(backToConfigMenuButton);
addDisplayElement(fullscreenButton);
addDisplayElement(outlineButton);
addDisplayElement(shadowButton);
addDisplayElement(environmentEffectsButton);
addDisplayElement(vSyncButton);
setup();
}","public UIMenuConfigVideo(){
  setId(""String_Node_Str"");
  setBackgroundImage(""String_Node_Str"");
  setModal(true);
  maximize();
  title=new UIImage(Assets.getTexture(""String_Node_Str""));
  title.setHorizontalAlign(EHorizontalAlign.CENTER);
  title.setPosition(new Vector2f(0f,128f));
  title.setVisible(true);
  title.setSize(new Vector2f(512f,128f));
  version=new UILabel(""String_Node_Str"");
  version.setHorizontalAlign(EHorizontalAlign.CENTER);
  version.setPosition(new Vector2f(0f,230f));
  version.setVisible(true);
  graphicsQualityButton=new UIStateButton(new Vector2f(256f,32f));
  StateButtonAction graphicsQualityStateAction=new StateButtonAction(){
    @Override public void action(    UIDisplayElement element){
      UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
        config.getRendering().setFlickeringLight(true);
      config.getRendering().setVignette(true);
    config.getRendering().setEyeAdaptation(true);
  config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(false);
config.getRendering().setMotionBlur(false);
config.getRendering().setSsao(false);
config.getRendering().setLightShafts(false);
config.getRendering().setCloudShadows(false);
break;
case 1:
config.getRendering().setFlickeringLight(true);
config.getRendering().setVignette(true);
config.getRendering().setEyeAdaptation(true);
config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(true);
config.getRendering().setSsao(false);
config.getRendering().setMotionBlur(false);
config.getRendering().setLightShafts(false);
config.getRendering().setCloudShadows(false);
break;
case 2:
config.getRendering().setFlickeringLight(true);
config.getRendering().setVignette(true);
config.getRendering().setEyeAdaptation(true);
config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(true);
config.getRendering().setMotionBlur(true);
config.getRendering().setLightShafts(true);
config.getRendering().setCloudShadows(true);
config.getRendering().setSsao(false);
break;
case 3:
config.getRendering().setFlickeringLight(true);
config.getRendering().setVignette(true);
config.getRendering().setEyeAdaptation(true);
config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(true);
config.getRendering().setMotionBlur(true);
config.getRendering().setSsao(true);
config.getRendering().setLightShafts(true);
config.getRendering().setCloudShadows(true);
break;
}
}
}
;
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addClickListener(clickAction);
graphicsQualityButton.setHorizontalAlign(EHorizontalAlign.CENTER);
graphicsQualityButton.setPosition(new Vector2f(-graphicsQualityButton.getSize().x / 2f - 10f,300f));
graphicsQualityButton.setVisible(true);
viewingDistanceButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction viewingDistanceStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setViewDistance(ViewDistance.forIndex(button.getState()));
}
}
;
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addClickListener(clickAction);
viewingDistanceButton.setHorizontalAlign(EHorizontalAlign.CENTER);
viewingDistanceButton.setPosition(new Vector2f(-viewingDistanceButton.getSize().x / 2f - 10f,300f + 40f));
viewingDistanceButton.setVisible(true);
fovButton=new UISlider(new Vector2f(256f,32f),75,130);
fovButton.addChangedListener(new ChangedListener(){
@Override public void changed(UIDisplayElement element){
UISlider slider=(UISlider)element;
slider.setText(""String_Node_Str"" + String.valueOf(slider.getValue()));
config.getRendering().setFieldOfView(slider.getValue());
}
}
);
fovButton.setHorizontalAlign(EHorizontalAlign.CENTER);
fovButton.setPosition(new Vector2f(-fovButton.getSize().x / 2f - 10f,300f + 2 * 40f));
fovButton.setVisible(true);
bobbingButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction bobbingStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setCameraBobbing(button.getState() != 0);
}
}
;
bobbingButton.addState(""String_Node_Str"",bobbingStateAction);
bobbingButton.addState(""String_Node_Str"",bobbingStateAction);
bobbingButton.addClickListener(clickAction);
bobbingButton.setHorizontalAlign(EHorizontalAlign.CENTER);
bobbingButton.setPosition(new Vector2f(-bobbingButton.getSize().x / 2f - 10f,300f + 3 * 40f));
bobbingButton.setVisible(true);
reflectiveWaterButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction reflectiveWaterStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
config.getRendering().setReflectiveWater(false);
config.getRendering().setLocalReflections(false);
break;
case 1:
config.getRendering().setReflectiveWater(false);
config.getRendering().setLocalReflections(true);
break;
case 2:
config.getRendering().setReflectiveWater(true);
config.getRendering().setLocalReflections(true);
break;
}
}
}
;
reflectiveWaterButton.addState(""String_Node_Str"",reflectiveWaterStateAction);
reflectiveWaterButton.addState(""String_Node_Str"",reflectiveWaterStateAction);
reflectiveWaterButton.addState(""String_Node_Str"",reflectiveWaterStateAction);
reflectiveWaterButton.addClickListener(clickAction);
reflectiveWaterButton.setHorizontalAlign(EHorizontalAlign.CENTER);
reflectiveWaterButton.setPosition(new Vector2f(reflectiveWaterButton.getSize().x / 2f,300f + 40f));
reflectiveWaterButton.setVisible(true);
blurIntensityButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction blurIntensityStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setBlurIntensity(button.getState());
}
}
;
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addClickListener(clickAction);
blurIntensityButton.setHorizontalAlign(EHorizontalAlign.CENTER);
blurIntensityButton.setPosition(new Vector2f(blurIntensityButton.getSize().x / 2f,300f + 2 * 40f));
blurIntensityButton.setVisible(true);
fullscreenButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction fullscreenStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
TerasologyEngine te=(TerasologyEngine)CoreRegistry.get(GameEngine.class);
if (button.getState() == 0) {
te.setFullscreen(false);
}
 else {
te.setFullscreen(true);
}
}
}
;
fullscreenButton.addState(""String_Node_Str"",fullscreenStateAction);
fullscreenButton.addState(""String_Node_Str"",fullscreenStateAction);
fullscreenButton.addClickListener(clickAction);
fullscreenButton.setHorizontalAlign(EHorizontalAlign.CENTER);
fullscreenButton.setPosition(new Vector2f(fullscreenButton.getSize().x / 2f,300f + 3 * 40f));
fullscreenButton.setVisible(true);
outlineButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction outlineStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setOutline(button.getState() != 0);
}
}
;
outlineButton.addState(""String_Node_Str"",outlineStateAction);
outlineButton.addState(""String_Node_Str"",outlineStateAction);
outlineButton.addClickListener(clickAction);
outlineButton.setHorizontalAlign(EHorizontalAlign.CENTER);
outlineButton.setPosition(new Vector2f(outlineButton.getSize().x / 2f,300f + 4 * 40f));
outlineButton.setVisible(true);
shadowButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction shadowStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
config.getRendering().setDynamicShadowsPcfFiltering(false);
config.getRendering().setDynamicShadows(false);
break;
case 1:
config.getRendering().setDynamicShadowsPcfFiltering(false);
config.getRendering().setDynamicShadows(true);
break;
case 2:
config.getRendering().setDynamicShadowsPcfFiltering(true);
config.getRendering().setDynamicShadows(true);
break;
}
}
}
;
shadowButton.addState(""String_Node_Str"",shadowStateAction);
shadowButton.addState(""String_Node_Str"",shadowStateAction);
shadowButton.addState(""String_Node_Str"",shadowStateAction);
shadowButton.addClickListener(clickAction);
shadowButton.setHorizontalAlign(EHorizontalAlign.CENTER);
shadowButton.setPosition(new Vector2f(-shadowButton.getSize().x / 2f - 10f,300f + 4 * 40f));
shadowButton.setVisible(true);
environmentEffectsButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction environmentEffectsStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
config.getRendering().setVolumetricLighting(false);
config.getRendering().setVolumetricFog(false);
config.getRendering().setAnimateGrass(false);
config.getRendering().setAnimateWater(false);
break;
case 1:
config.getRendering().setVolumetricLighting(false);
config.getRendering().setAnimateWater(false);
config.getRendering().setVolumetricFog(true);
config.getRendering().setAnimateGrass(true);
break;
case 2:
config.getRendering().setVolumetricLighting(false);
config.getRendering().setAnimateWater(true);
config.getRendering().setVolumetricFog(true);
config.getRendering().setAnimateGrass(true);
break;
case 3:
config.getRendering().setVolumetricLighting(true);
config.getRendering().setAnimateWater(true);
config.getRendering().setVolumetricFog(true);
config.getRendering().setAnimateGrass(true);
break;
}
}
}
;
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addClickListener(clickAction);
environmentEffectsButton.setHorizontalAlign(EHorizontalAlign.CENTER);
environmentEffectsButton.setPosition(new Vector2f(environmentEffectsButton.getSize().x / 2f,300f));
environmentEffectsButton.setVisible(true);
vSyncButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction vSyncStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
TerasologyEngine te=(TerasologyEngine)CoreRegistry.get(GameEngine.class);
if (button.getState() == 0) {
te.setVSync(false);
}
 else {
te.setVSync(true);
}
}
}
;
vSyncButton.addState(""String_Node_Str"",vSyncStateAction);
vSyncButton.addState(""String_Node_Str"",vSyncStateAction);
vSyncButton.addClickListener(clickAction);
vSyncButton.setHorizontalAlign(EHorizontalAlign.CENTER);
vSyncButton.setPosition(new Vector2f(-vSyncButton.getSize().x / 2f - 10f,300f + 5 * 40f));
vSyncButton.setVisible(true);
backToConfigMenuButton=new UIButton(new Vector2f(256f,32f),UIButton.ButtonType.NORMAL);
backToConfigMenuButton.getLabel().setText(""String_Node_Str"");
backToConfigMenuButton.setHorizontalAlign(EHorizontalAlign.CENTER);
backToConfigMenuButton.setPosition(new Vector2f(0f,300f + 7 * 40f));
backToConfigMenuButton.setVisible(true);
backToConfigMenuButton.addClickListener(new ClickListener(){
@Override public void click(UIDisplayElement element,int button){
logger.info(""String_Node_Str"" + config.getRendering().toString());
CoreRegistry.get(ShaderManager.class).recompileAllShaders();
getGUIManager().openWindow(""String_Node_Str"");
}
}
);
addDisplayElement(title);
addDisplayElement(version);
addDisplayElement(graphicsQualityButton);
addDisplayElement(fovButton);
addDisplayElement(viewingDistanceButton);
addDisplayElement(reflectiveWaterButton);
addDisplayElement(blurIntensityButton);
addDisplayElement(bobbingButton);
addDisplayElement(backToConfigMenuButton);
addDisplayElement(fullscreenButton);
addDisplayElement(outlineButton);
addDisplayElement(shadowButton);
addDisplayElement(environmentEffectsButton);
addDisplayElement(vSyncButton);
setup();
}",0.9970481380563124
1020,"@Override public void click(UIDisplayElement element,int button){
  logger.info(""String_Node_Str"" + config.getRendering().toString());
  logger.info(""String_Node_Str"" + config.getRendering().getDebug().toString());
  CoreRegistry.get(ShaderManager.class).recompileAllShaders();
  getGUIManager().openWindow(""String_Node_Str"");
}","@Override public void click(UIDisplayElement element,int button){
  logger.info(""String_Node_Str"" + config.getRendering().toString());
  CoreRegistry.get(ShaderManager.class).recompileAllShaders();
  getGUIManager().openWindow(""String_Node_Str"");
}",0.8611111111111112
1021,"@Override public void onButtonActivated(UIButton button){
  logger.info(""String_Node_Str"" + config.getRendering().toString());
  logger.info(""String_Node_Str"" + config.getRendering().getDebug().toString());
  CoreRegistry.get(ShaderManager.class).recompileAllShaders();
  TerasologyEngine te=(TerasologyEngine)engine;
  if (te.isFullscreen() != find(""String_Node_Str"",UICheckbox.class).isChecked()) {
    te.setFullscreen(!te.isFullscreen());
  }
  nuiManager.popScreen();
}","@Override public void onButtonActivated(UIButton button){
  logger.info(""String_Node_Str"" + config.getRendering().toString());
  CoreRegistry.get(ShaderManager.class).recompileAllShaders();
  TerasologyEngine te=(TerasologyEngine)engine;
  if (te.isFullscreen() != find(""String_Node_Str"",UICheckbox.class).isChecked()) {
    te.setFullscreen(!te.isFullscreen());
  }
  nuiManager.popScreen();
}",0.9078341013824884
1022,"@Override @SuppressWarnings(""String_Node_Str"") public void setContents(UIWidget contents){
  super.setContents(contents);
  UIDropdown<VideoQuality> videoQuality=find(""String_Node_Str"",UIDropdown.class);
  videoQuality.setOptions(Lists.newArrayList(VideoQuality.NICE,VideoQuality.EPIC,VideoQuality.INSANE,VideoQuality.UBER));
  videoQuality.bindSelection(new VideoQualityBinding(config.getRendering()));
  UIDropdown<EnvironmentalEffects> environmentalEffects=find(""String_Node_Str"",UIDropdown.class);
  environmentalEffects.setOptions(Lists.newArrayList(EnvironmentalEffects.OFF,EnvironmentalEffects.LOW,EnvironmentalEffects.MEDIUM,EnvironmentalEffects.HIGH));
  environmentalEffects.bindSelection(new EnvironmentEffectsBinding(config.getRendering()));
  UIDropdown<ViewDistance> viewDistance=find(""String_Node_Str"",UIDropdown.class);
  viewDistance.setOptions(Arrays.asList(ViewDistance.values()));
  viewDistance.bindSelection(BindHelper.bindBeanProperty(""String_Node_Str"",config.getRendering(),ViewDistance.class));
  UIDropdown<WaterReflection> waterReflection=find(""String_Node_Str"",UIDropdown.class);
  waterReflection.setOptions(Lists.newArrayList(WaterReflection.SKY,WaterReflection.LOCAL,WaterReflection.GLOBAL));
  waterReflection.bindSelection(new WaterReflectionBinding(config.getRendering()));
  UIDropdown<Integer> blur=find(""String_Node_Str"",UIDropdown.class);
  blur.setOptions(Lists.newArrayList(0,1,2,3));
  blur.bindSelection(BindHelper.bindBeanProperty(""String_Node_Str"",config.getRendering(),Integer.TYPE));
  blur.setOptionAdapter(new DisplayValueAdapter<Integer>(){
    @Override public String convert(    Integer value){
switch (value) {
case 1:
        return ""String_Node_Str"";
case 2:
      return ""String_Node_Str"";
case 3:
    return ""String_Node_Str"";
default :
  return ""String_Node_Str"";
}
}
}
);
UIDropdown<DynamicShadows> dynamicShadows=find(""String_Node_Str"",UIDropdown.class);
dynamicShadows.setOptions(Arrays.asList(DynamicShadows.values()));
dynamicShadows.bindSelection(new DynamicShadowsBinding(config.getRendering()));
UISlider fovSlider=find(""String_Node_Str"",UISlider.class);
fovSlider.setIncrement(5.0f);
fovSlider.setPrecision(0);
fovSlider.setMinimum(70);
fovSlider.setRange(50);
fovSlider.bindValue(BindHelper.bindBeanProperty(""String_Node_Str"",config.getRendering(),Float.TYPE));
find(""String_Node_Str"",UICheckbox.class).bindChecked(BindHelper.bindBeanProperty(""String_Node_Str"",engine,Boolean.TYPE));
find(""String_Node_Str"",UICheckbox.class).bindChecked(BindHelper.bindBeanProperty(""String_Node_Str"",config.getRendering(),Boolean.TYPE));
find(""String_Node_Str"",UICheckbox.class).bindChecked(BindHelper.bindBeanProperty(""String_Node_Str"",config.getRendering(),Boolean.TYPE));
find(""String_Node_Str"",UICheckbox.class).bindChecked(BindHelper.bindBeanProperty(""String_Node_Str"",config.getRendering(),Boolean.TYPE));
find(""String_Node_Str"",UIButton.class).subscribe(new ButtonEventListener(){
@Override public void onButtonActivated(UIButton button){
logger.info(""String_Node_Str"" + config.getRendering().toString());
logger.info(""String_Node_Str"" + config.getRendering().getDebug().toString());
CoreRegistry.get(ShaderManager.class).recompileAllShaders();
TerasologyEngine te=(TerasologyEngine)engine;
if (te.isFullscreen() != find(""String_Node_Str"",UICheckbox.class).isChecked()) {
te.setFullscreen(!te.isFullscreen());
}
nuiManager.popScreen();
}
}
);
}","@Override @SuppressWarnings(""String_Node_Str"") public void setContents(UIWidget contents){
  super.setContents(contents);
  UIDropdown<VideoQuality> videoQuality=find(""String_Node_Str"",UIDropdown.class);
  videoQuality.setOptions(Lists.newArrayList(VideoQuality.NICE,VideoQuality.EPIC,VideoQuality.INSANE,VideoQuality.UBER));
  videoQuality.bindSelection(new VideoQualityBinding(config.getRendering()));
  UIDropdown<EnvironmentalEffects> environmentalEffects=find(""String_Node_Str"",UIDropdown.class);
  environmentalEffects.setOptions(Lists.newArrayList(EnvironmentalEffects.OFF,EnvironmentalEffects.LOW,EnvironmentalEffects.MEDIUM,EnvironmentalEffects.HIGH));
  environmentalEffects.bindSelection(new EnvironmentEffectsBinding(config.getRendering()));
  UIDropdown<ViewDistance> viewDistance=find(""String_Node_Str"",UIDropdown.class);
  viewDistance.setOptions(Arrays.asList(ViewDistance.values()));
  viewDistance.bindSelection(BindHelper.bindBeanProperty(""String_Node_Str"",config.getRendering(),ViewDistance.class));
  UIDropdown<WaterReflection> waterReflection=find(""String_Node_Str"",UIDropdown.class);
  waterReflection.setOptions(Lists.newArrayList(WaterReflection.SKY,WaterReflection.LOCAL,WaterReflection.GLOBAL));
  waterReflection.bindSelection(new WaterReflectionBinding(config.getRendering()));
  UIDropdown<Integer> blur=find(""String_Node_Str"",UIDropdown.class);
  blur.setOptions(Lists.newArrayList(0,1,2,3));
  blur.bindSelection(BindHelper.bindBeanProperty(""String_Node_Str"",config.getRendering(),Integer.TYPE));
  blur.setOptionAdapter(new DisplayValueAdapter<Integer>(){
    @Override public String convert(    Integer value){
switch (value) {
case 1:
        return ""String_Node_Str"";
case 2:
      return ""String_Node_Str"";
case 3:
    return ""String_Node_Str"";
default :
  return ""String_Node_Str"";
}
}
}
);
UIDropdown<DynamicShadows> dynamicShadows=find(""String_Node_Str"",UIDropdown.class);
dynamicShadows.setOptions(Arrays.asList(DynamicShadows.values()));
dynamicShadows.bindSelection(new DynamicShadowsBinding(config.getRendering()));
UISlider fovSlider=find(""String_Node_Str"",UISlider.class);
fovSlider.setIncrement(5.0f);
fovSlider.setPrecision(0);
fovSlider.setMinimum(70);
fovSlider.setRange(50);
fovSlider.bindValue(BindHelper.bindBeanProperty(""String_Node_Str"",config.getRendering(),Float.TYPE));
find(""String_Node_Str"",UICheckbox.class).bindChecked(BindHelper.bindBeanProperty(""String_Node_Str"",engine,Boolean.TYPE));
find(""String_Node_Str"",UICheckbox.class).bindChecked(BindHelper.bindBeanProperty(""String_Node_Str"",config.getRendering(),Boolean.TYPE));
find(""String_Node_Str"",UICheckbox.class).bindChecked(BindHelper.bindBeanProperty(""String_Node_Str"",config.getRendering(),Boolean.TYPE));
find(""String_Node_Str"",UICheckbox.class).bindChecked(BindHelper.bindBeanProperty(""String_Node_Str"",config.getRendering(),Boolean.TYPE));
find(""String_Node_Str"",UIButton.class).subscribe(new ButtonEventListener(){
@Override public void onButtonActivated(UIButton button){
logger.info(""String_Node_Str"" + config.getRendering().toString());
CoreRegistry.get(ShaderManager.class).recompileAllShaders();
TerasologyEngine te=(TerasologyEngine)engine;
if (te.isFullscreen() != find(""String_Node_Str"",UICheckbox.class).isChecked()) {
te.setFullscreen(!te.isFullscreen());
}
nuiManager.popScreen();
}
}
);
}",0.9883997620464008
1023,"public FlatWorldGenerator(SimpleUri uri){
  super(uri);
  register(new FlatTerrainGenerator());
  register(new FloraGenerator());
  register(new LiquidsGenerator());
  ForestGenerator forestGenerator=new ForestGenerator();
  DefaultGenerators.AddDefaultForestGenerators(forestGenerator);
  register(forestGenerator);
}","public FlatWorldGenerator(SimpleUri uri){
  super(uri);
  register(new FlatTerrainGenerator());
  register(new FloraGenerator());
  register(new LiquidsGenerator());
  ForestGenerator forestGenerator=new ForestGenerator();
  DefaultGenerators.addDefaultForestGenerators(forestGenerator);
  register(forestGenerator);
}",0.9968553459119496
1024,"public HeightMapWorldGenerator(SimpleUri uri){
  super(uri);
  register(new BasicHMTerrainGenerator());
  register(new FloraGenerator());
  register(new LiquidsGenerator());
  ForestGenerator forestGenerator=new ForestGenerator();
  DefaultGenerators.AddDefaultForestGenerators(forestGenerator);
  register(forestGenerator);
}","public HeightMapWorldGenerator(SimpleUri uri){
  super(uri);
  register(new BasicHMTerrainGenerator());
  register(new FloraGenerator());
  register(new LiquidsGenerator());
  ForestGenerator forestGenerator=new ForestGenerator();
  DefaultGenerators.addDefaultForestGenerators(forestGenerator);
  register(forestGenerator);
}",0.9969325153374232
1025,"public MixedWorldGenerator(SimpleUri uri){
  super(uri);
  register(new MultiTerrainGenerator());
  register(new FloraGenerator());
  register(new LiquidsGenerator());
  ForestGenerator forestGenerator=new ForestGenerator();
  DefaultGenerators.AddDefaultForestGenerators(forestGenerator);
  register(forestGenerator);
}","public MixedWorldGenerator(SimpleUri uri){
  super(uri);
  register(new MultiTerrainGenerator());
  register(new FloraGenerator());
  register(new LiquidsGenerator());
  ForestGenerator forestGenerator=new ForestGenerator();
  DefaultGenerators.addDefaultForestGenerators(forestGenerator);
  register(forestGenerator);
}",0.996875
1026,"public PerlinWorldGenerator(SimpleUri uri){
  super(uri);
  register(new PerlinTerrainGenerator());
  register(new FloraGenerator());
  register(new LiquidsGenerator());
  ForestGenerator forestGenerator=new ForestGenerator();
  DefaultGenerators.AddDefaultForestGenerators(forestGenerator);
  register(forestGenerator);
}","public PerlinWorldGenerator(SimpleUri uri){
  super(uri);
  register(new PerlinTerrainGenerator());
  register(new FloraGenerator());
  register(new LiquidsGenerator());
  ForestGenerator forestGenerator=new ForestGenerator();
  DefaultGenerators.addDefaultForestGenerators(forestGenerator);
  register(forestGenerator);
}",0.9968944099378882
1027,"private Rect2i applyFixedSizesToRegion(Rect2i region){
  UIStyle style=getCurrentStyle();
  if (style.getFixedWidth() != 0 || style.getFixedHeight() != 0) {
    int newWidth=(style.getFixedWidth() != 0) ? style.getFixedWidth() : region.width();
    int newHeight=(style.getFixedHeight() != 0) ? style.getFixedHeight() : region.height();
    int newMinX=region.minX() + style.getHorizontalAlignment().getOffset(newWidth,region.width());
    int newMinY=region.minY() + style.getVerticalAlignment().getOffset(newHeight,region.height());
    return Rect2i.createFromMinAndSize(newMinX,newMinY,newWidth,newHeight);
  }
  return region;
}","private Rect2i applyFixedSizesToRegion(Rect2i region,UIStyle style){
  if (style.getFixedWidth() != 0 || style.getFixedHeight() != 0) {
    int newWidth=(style.getFixedWidth() != 0) ? style.getFixedWidth() : region.width();
    int newHeight=(style.getFixedHeight() != 0) ? style.getFixedHeight() : region.height();
    int newMinX=region.minX() + style.getHorizontalAlignment().getOffset(newWidth,region.width());
    int newMinY=region.minY() + style.getVerticalAlignment().getOffset(newHeight,region.height());
    return Rect2i.createFromMinAndSize(newMinX,newMinY,newWidth,newHeight);
  }
  return region;
}",0.9783132530120482
1028,"@Override public void drawElement(UIElement element,Rect2i region){
  UIStyle newStyle=state.skin.getStyleFor((element.getFamily() != null) ? element.getFamily() : state.family,element.getClass(),element.getMode());
  Rect2i regionArea=applyFixedSizesToRegion(region);
  try (SubRegion ignored=subRegion(regionArea,false)){
    state.element=element;
    if (element.getFamily() != null) {
      setFamily(element.getFamily());
    }
    setPart(""String_Node_Str"");
    setMode(element.getMode());
    if (newStyle.isBackgroundAutomaticallyDrawn()) {
      drawBackground();
    }
    element.onDraw(this);
  }
 }","@Override public void drawElement(UIElement element,Rect2i region){
  UIStyle newStyle=state.skin.getStyleFor((element.getFamily() != null) ? element.getFamily() : state.family,element.getClass(),element.getMode());
  Rect2i regionArea=applyFixedSizesToRegion(region,newStyle);
  try (SubRegion ignored=subRegion(regionArea,false)){
    state.element=element;
    if (element.getFamily() != null) {
      setFamily(element.getFamily());
    }
    setPart(""String_Node_Str"");
    setMode(element.getMode());
    if (newStyle.isBackgroundAutomaticallyDrawn()) {
      drawBackground();
    }
    element.onDraw(this);
  }
 }",0.9927125506072876
1029,"public BlockAppearance(Map<BlockPart,BlockMeshPart> blockParts,Map<BlockPart,Vector2f> textureAtlasPos){
  this.blockParts=blockParts;
  this.textureAtlasPos=textureAtlasPos;
  for (  BlockPart part : BlockPart.values()) {
    if (textureAtlasPos == null) {
      textureAtlasPos.put(part,new Vector2f());
    }
  }
}","public BlockAppearance(Map<BlockPart,BlockMeshPart> blockParts,Map<BlockPart,Vector2f> textureAtlasPos){
  Preconditions.checkNotNull(blockParts);
  Preconditions.checkNotNull(textureAtlasPos);
  this.blockParts=blockParts;
  this.textureAtlasPos.putAll(textureAtlasPos);
  for (  BlockPart part : BlockPart.values()) {
    Preconditions.checkNotNull(""String_Node_Str"" + part,textureAtlasPos.get(part));
  }
}",0.6887052341597796
1030,"public void renderWorld(Camera camera){
  if (config.getRendering().getDebug().isWireframe()) {
    glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);
  }
  DefaultRenderingProcess.getInstance().clear();
  DefaultRenderingProcess.getInstance().beginRenderSceneOpaque();
  camera.lookThroughNormalized();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  DefaultRenderingProcess.getInstance().beginRenderSceneSky();
  skysphere.render(camera);
  DefaultRenderingProcess.getInstance().endRenderSceneSky();
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  camera.lookThrough();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  for (  RenderSystem renderer : systemManager.iterateRenderSubscribers()) {
    renderer.renderOpaque();
  }
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  while (renderQueueChunksOpaque.size() > 0) {
    renderChunk(renderQueueChunksOpaque.poll(),ChunkMesh.RenderPhase.OPAQUE,camera,ChunkRenderMode.DEFAULT);
  }
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  while (renderQueueChunksAlphaReject.size() > 0) {
    renderChunk(renderQueueChunksAlphaReject.poll(),ChunkMesh.RenderPhase.ALPHA_REJECT,camera,ChunkRenderMode.DEFAULT);
  }
  PerformanceMonitor.endActivity();
  if (activeCamera != null && !config.getRendering().getDebug().isFirstPersonElementsHidden()) {
    PerformanceMonitor.startActivity(""String_Node_Str"");
    glPushMatrix();
    glLoadIdentity();
    activeCamera.updateMatrices(90f);
    activeCamera.loadProjectionMatrix();
    glDepthFunc(GL11.GL_ALWAYS);
    for (    RenderSystem renderer : systemManager.iterateRenderSubscribers()) {
      renderer.renderFirstPerson();
    }
    glDepthFunc(GL_LEQUAL);
    activeCamera.updateMatrices();
    activeCamera.loadProjectionMatrix();
    glPopMatrix();
    PerformanceMonitor.endActivity();
  }
  PerformanceMonitor.startActivity(""String_Node_Str"");
  for (  RenderSystem renderer : systemManager.iterateRenderSubscribers()) {
    renderer.renderOverlay();
  }
  PerformanceMonitor.endActivity();
  DefaultRenderingProcess.getInstance().endRenderSceneOpaque();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  DefaultRenderingProcess.getInstance().beginRenderLightGeometryStencilPass();
  Material program=Assets.getMaterial(""String_Node_Str"");
  program.enable();
  program.setCamera(camera);
  EntityManager entityManager=CoreRegistry.get(EntityManager.class);
  for (  EntityRef entity : entityManager.getEntitiesWith(LightComponent.class,LocationComponent.class)) {
    LocationComponent locationComponent=entity.getComponent(LocationComponent.class);
    LightComponent lightComponent=entity.getComponent(LightComponent.class);
    final Vector3f worldPosition=locationComponent.getWorldPosition();
    renderLightComponent(lightComponent,worldPosition,program,camera,true);
  }
  DefaultRenderingProcess.getInstance().endRenderLightGeometryStencilPass();
  DefaultRenderingProcess.getInstance().beginRenderLightGeometry();
  program=Assets.getMaterial(""String_Node_Str"");
  for (  EntityRef entity : entityManager.getEntitiesWith(LightComponent.class,LocationComponent.class)) {
    LocationComponent locationComponent=entity.getComponent(LocationComponent.class);
    LightComponent lightComponent=entity.getComponent(LightComponent.class);
    final Vector3f worldPosition=locationComponent.getWorldPosition();
    renderLightComponent(lightComponent,worldPosition,program,camera,false);
  }
  DefaultRenderingProcess.getInstance().endRenderLightGeometry();
  DefaultRenderingProcess.getInstance().beginRenderDirectionalLights();
  Vector3f sunlightWorldPosition=new Vector3f(skysphere.getSunDirection(true));
  sunlightWorldPosition.scale(50000f);
  sunlightWorldPosition.add(activeCamera.getPosition());
  renderLightComponent(mainDirectionalLight,sunlightWorldPosition,program,camera,false);
  DefaultRenderingProcess.getInstance().endRenderDirectionalLights();
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  DefaultRenderingProcess.getInstance().beginRenderSceneTransparent();
  boolean isHeadUnderWater=isHeadUnderWater();
  if (isHeadUnderWater) {
    glDisable(GL11.GL_CULL_FACE);
  }
  while (renderQueueChunksAlphaBlend.size() > 0) {
    renderChunk(renderQueueChunksAlphaBlend.poll(),ChunkMesh.RenderPhase.REFRACTIVE,camera,ChunkRenderMode.DEFAULT);
  }
  PerformanceMonitor.endActivity();
  if (isHeadUnderWater) {
    glEnable(GL11.GL_CULL_FACE);
  }
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  glDepthMask(false);
  for (  RenderSystem renderer : systemManager.iterateRenderSubscribers()) {
    renderer.renderAlphaBlend();
  }
  glDisable(GL_BLEND);
  glDepthMask(true);
  PerformanceMonitor.endActivity();
  DefaultRenderingProcess.getInstance().endRenderSceneTransparent();
  if (config.getRendering().getDebug().isWireframe()) {
    glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);
  }
}","public void renderWorld(Camera camera){
  if (config.getRendering().getDebug().isWireframe()) {
    glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);
  }
  DefaultRenderingProcess.getInstance().clear();
  DefaultRenderingProcess.getInstance().beginRenderSceneOpaque();
  camera.lookThroughNormalized();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  DefaultRenderingProcess.getInstance().beginRenderSceneSky();
  skysphere.render(camera);
  DefaultRenderingProcess.getInstance().endRenderSceneSky();
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  camera.lookThrough();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  for (  RenderSystem renderer : systemManager.iterateRenderSubscribers()) {
    renderer.renderOpaque();
  }
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  while (renderQueueChunksOpaque.size() > 0) {
    renderChunk(renderQueueChunksOpaque.poll(),ChunkMesh.RenderPhase.OPAQUE,camera,ChunkRenderMode.DEFAULT);
  }
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  while (renderQueueChunksAlphaReject.size() > 0) {
    renderChunk(renderQueueChunksAlphaReject.poll(),ChunkMesh.RenderPhase.ALPHA_REJECT,camera,ChunkRenderMode.DEFAULT);
  }
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  for (  RenderSystem renderer : systemManager.iterateRenderSubscribers()) {
    renderer.renderOverlay();
  }
  PerformanceMonitor.endActivity();
  if (activeCamera != null && !config.getRendering().getDebug().isFirstPersonElementsHidden()) {
    PerformanceMonitor.startActivity(""String_Node_Str"");
    glPushMatrix();
    glLoadIdentity();
    activeCamera.updateMatrices(90f);
    activeCamera.loadProjectionMatrix();
    glDepthFunc(GL11.GL_ALWAYS);
    for (    RenderSystem renderer : systemManager.iterateRenderSubscribers()) {
      renderer.renderFirstPerson();
    }
    glDepthFunc(GL_LEQUAL);
    activeCamera.updateMatrices();
    activeCamera.loadProjectionMatrix();
    glPopMatrix();
    PerformanceMonitor.endActivity();
  }
  DefaultRenderingProcess.getInstance().endRenderSceneOpaque();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  DefaultRenderingProcess.getInstance().beginRenderLightGeometryStencilPass();
  Material program=Assets.getMaterial(""String_Node_Str"");
  program.enable();
  program.setCamera(camera);
  EntityManager entityManager=CoreRegistry.get(EntityManager.class);
  for (  EntityRef entity : entityManager.getEntitiesWith(LightComponent.class,LocationComponent.class)) {
    LocationComponent locationComponent=entity.getComponent(LocationComponent.class);
    LightComponent lightComponent=entity.getComponent(LightComponent.class);
    final Vector3f worldPosition=locationComponent.getWorldPosition();
    renderLightComponent(lightComponent,worldPosition,program,camera,true);
  }
  DefaultRenderingProcess.getInstance().endRenderLightGeometryStencilPass();
  DefaultRenderingProcess.getInstance().beginRenderLightGeometry();
  program=Assets.getMaterial(""String_Node_Str"");
  for (  EntityRef entity : entityManager.getEntitiesWith(LightComponent.class,LocationComponent.class)) {
    LocationComponent locationComponent=entity.getComponent(LocationComponent.class);
    LightComponent lightComponent=entity.getComponent(LightComponent.class);
    final Vector3f worldPosition=locationComponent.getWorldPosition();
    renderLightComponent(lightComponent,worldPosition,program,camera,false);
  }
  DefaultRenderingProcess.getInstance().endRenderLightGeometry();
  DefaultRenderingProcess.getInstance().beginRenderDirectionalLights();
  Vector3f sunlightWorldPosition=new Vector3f(skysphere.getSunDirection(true));
  sunlightWorldPosition.scale(50000f);
  sunlightWorldPosition.add(activeCamera.getPosition());
  renderLightComponent(mainDirectionalLight,sunlightWorldPosition,program,camera,false);
  DefaultRenderingProcess.getInstance().endRenderDirectionalLights();
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  DefaultRenderingProcess.getInstance().beginRenderSceneTransparent();
  boolean isHeadUnderWater=isHeadUnderWater();
  if (isHeadUnderWater) {
    glDisable(GL11.GL_CULL_FACE);
  }
  while (renderQueueChunksAlphaBlend.size() > 0) {
    renderChunk(renderQueueChunksAlphaBlend.poll(),ChunkMesh.RenderPhase.REFRACTIVE,camera,ChunkRenderMode.DEFAULT);
  }
  PerformanceMonitor.endActivity();
  if (isHeadUnderWater) {
    glEnable(GL11.GL_CULL_FACE);
  }
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  glDepthMask(false);
  for (  RenderSystem renderer : systemManager.iterateRenderSubscribers()) {
    renderer.renderAlphaBlend();
  }
  glDisable(GL_BLEND);
  glDepthMask(true);
  PerformanceMonitor.endActivity();
  DefaultRenderingProcess.getInstance().endRenderSceneTransparent();
  if (config.getRendering().getDebug().isWireframe()) {
    glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);
  }
}",0.9605391678062122
1031,"public UIMenuConfigVideo(){
  setId(""String_Node_Str"");
  setBackgroundImage(""String_Node_Str"");
  setModal(true);
  maximize();
  title=new UIImage(Assets.getTexture(""String_Node_Str""));
  title.setHorizontalAlign(EHorizontalAlign.CENTER);
  title.setPosition(new Vector2f(0f,128f));
  title.setVisible(true);
  title.setSize(new Vector2f(512f,128f));
  version=new UILabel(""String_Node_Str"");
  version.setHorizontalAlign(EHorizontalAlign.CENTER);
  version.setPosition(new Vector2f(0f,230f));
  version.setVisible(true);
  graphicsQualityButton=new UIStateButton(new Vector2f(256f,32f));
  StateButtonAction graphicsQualityStateAction=new StateButtonAction(){
    @Override public void action(    UIDisplayElement element){
      UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
        config.getRendering().setFlickeringLight(true);
      config.getRendering().setVignette(true);
    config.getRendering().setEyeAdaptation(true);
  config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(false);
config.getRendering().setMotionBlur(false);
config.getRendering().setSsao(false);
config.getRendering().setLightShafts(false);
config.getRendering().setCloudShadows(false);
break;
case 1:
config.getRendering().setFlickeringLight(true);
config.getRendering().setVignette(true);
config.getRendering().setEyeAdaptation(true);
config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(true);
config.getRendering().setSsao(false);
config.getRendering().setMotionBlur(false);
config.getRendering().setLightShafts(false);
config.getRendering().setCloudShadows(false);
break;
case 2:
config.getRendering().setFlickeringLight(true);
config.getRendering().setVignette(true);
config.getRendering().setEyeAdaptation(true);
config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(true);
config.getRendering().setMotionBlur(true);
config.getRendering().setLightShafts(true);
config.getRendering().setCloudShadows(true);
config.getRendering().setSsao(false);
break;
case 3:
config.getRendering().setFlickeringLight(true);
config.getRendering().setVignette(true);
config.getRendering().setEyeAdaptation(true);
config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(true);
config.getRendering().setMotionBlur(true);
config.getRendering().setSsao(true);
config.getRendering().setLightShafts(true);
config.getRendering().setCloudShadows(true);
break;
}
}
}
;
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addClickListener(clickAction);
graphicsQualityButton.setHorizontalAlign(EHorizontalAlign.CENTER);
graphicsQualityButton.setPosition(new Vector2f(-graphicsQualityButton.getSize().x / 2f - 10f,300f));
graphicsQualityButton.setVisible(true);
viewingDistanceButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction viewingDistanceStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setViewDistance(ViewDistance.forIndex(button.getState()));
}
}
;
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addClickListener(clickAction);
viewingDistanceButton.setHorizontalAlign(EHorizontalAlign.CENTER);
viewingDistanceButton.setPosition(new Vector2f(-viewingDistanceButton.getSize().x / 2f - 10f,300f + 40f));
viewingDistanceButton.setVisible(true);
fovButton=new UISlider(new Vector2f(256f,32f),75,130);
fovButton.addChangedListener(new ChangedListener(){
@Override public void changed(UIDisplayElement element){
UISlider slider=(UISlider)element;
slider.setText(""String_Node_Str"" + String.valueOf(slider.getValue()));
config.getRendering().setFieldOfView(slider.getValue());
}
}
);
fovButton.setHorizontalAlign(EHorizontalAlign.CENTER);
fovButton.setPosition(new Vector2f(-fovButton.getSize().x / 2f - 10f,300f + 2 * 40f));
fovButton.setVisible(true);
bobbingButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction bobbingStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setCameraBobbing(button.getState() != 0);
}
}
;
bobbingButton.addState(""String_Node_Str"",bobbingStateAction);
bobbingButton.addState(""String_Node_Str"",bobbingStateAction);
bobbingButton.addClickListener(clickAction);
bobbingButton.setHorizontalAlign(EHorizontalAlign.CENTER);
bobbingButton.setPosition(new Vector2f(-bobbingButton.getSize().x / 2f - 10f,300f + 3 * 40f));
bobbingButton.setVisible(true);
reflectiveWaterButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction reflectiveWaterStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
config.getRendering().setReflectiveWater(false);
config.getRendering().setLocalReflections(false);
break;
case 1:
config.getRendering().setReflectiveWater(false);
config.getRendering().setLocalReflections(true);
break;
case 2:
config.getRendering().setReflectiveWater(true);
config.getRendering().setLocalReflections(true);
break;
}
}
}
;
reflectiveWaterButton.addState(""String_Node_Str"",reflectiveWaterStateAction);
reflectiveWaterButton.addState(""String_Node_Str"",reflectiveWaterStateAction);
reflectiveWaterButton.addState(""String_Node_Str"",reflectiveWaterStateAction);
reflectiveWaterButton.addClickListener(clickAction);
reflectiveWaterButton.setHorizontalAlign(EHorizontalAlign.CENTER);
reflectiveWaterButton.setPosition(new Vector2f(reflectiveWaterButton.getSize().x / 2f,300f + 40f));
reflectiveWaterButton.setVisible(true);
blurIntensityButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction blurIntensityStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setBlurIntensity(button.getState());
}
}
;
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addClickListener(clickAction);
blurIntensityButton.setHorizontalAlign(EHorizontalAlign.CENTER);
blurIntensityButton.setPosition(new Vector2f(blurIntensityButton.getSize().x / 2f,300f + 2 * 40f));
blurIntensityButton.setVisible(true);
fullscreenButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction fullscreenStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
TerasologyEngine te=(TerasologyEngine)CoreRegistry.get(GameEngine.class);
if (button.getState() == 0) {
te.setFullscreen(false);
}
 else {
te.setFullscreen(true);
}
}
}
;
fullscreenButton.addState(""String_Node_Str"",fullscreenStateAction);
fullscreenButton.addState(""String_Node_Str"",fullscreenStateAction);
fullscreenButton.addClickListener(clickAction);
fullscreenButton.setHorizontalAlign(EHorizontalAlign.CENTER);
fullscreenButton.setPosition(new Vector2f(fullscreenButton.getSize().x / 2f,300f + 3 * 40f));
fullscreenButton.setVisible(true);
outlineButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction outlineStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setOutline(button.getState() != 0);
}
}
;
outlineButton.addState(""String_Node_Str"",outlineStateAction);
outlineButton.addState(""String_Node_Str"",outlineStateAction);
outlineButton.addClickListener(clickAction);
outlineButton.setHorizontalAlign(EHorizontalAlign.CENTER);
outlineButton.setPosition(new Vector2f(outlineButton.getSize().x / 2f,300f + 4 * 40f));
outlineButton.setVisible(true);
shadowButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction shadowStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
config.getRendering().setDynamicShadowsPcfFiltering(false);
config.getRendering().setDynamicShadows(false);
break;
case 1:
config.getRendering().setDynamicShadowsPcfFiltering(false);
config.getRendering().setDynamicShadows(true);
break;
case 2:
config.getRendering().setDynamicShadowsPcfFiltering(true);
config.getRendering().setDynamicShadows(true);
break;
}
}
}
;
shadowButton.addState(""String_Node_Str"",shadowStateAction);
shadowButton.addState(""String_Node_Str"",shadowStateAction);
shadowButton.addState(""String_Node_Str"",shadowStateAction);
shadowButton.addClickListener(clickAction);
shadowButton.setHorizontalAlign(EHorizontalAlign.CENTER);
shadowButton.setPosition(new Vector2f(-shadowButton.getSize().x / 2f - 10f,300f + 4 * 40f));
shadowButton.setVisible(true);
environmentEffectsButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction environmentEffectsStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
config.getRendering().setVolumetricLighting(false);
config.getRendering().setVolumetricFog(false);
config.getRendering().setAnimateGrass(false);
config.getRendering().setAnimateWater(false);
break;
case 1:
config.getRendering().setVolumetricLighting(false);
config.getRendering().setAnimateWater(false);
config.getRendering().setVolumetricFog(true);
config.getRendering().setAnimateGrass(true);
break;
case 2:
config.getRendering().setVolumetricLighting(false);
config.getRendering().setAnimateWater(true);
config.getRendering().setVolumetricFog(true);
config.getRendering().setAnimateGrass(true);
break;
case 3:
config.getRendering().setVolumetricLighting(true);
config.getRendering().setAnimateWater(true);
config.getRendering().setVolumetricFog(true);
config.getRendering().setAnimateGrass(true);
break;
}
}
}
;
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addClickListener(clickAction);
environmentEffectsButton.setHorizontalAlign(EHorizontalAlign.CENTER);
environmentEffectsButton.setPosition(new Vector2f(environmentEffectsButton.getSize().x / 2f,300f));
environmentEffectsButton.setVisible(true);
vSyncButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction vSyncStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
TerasologyEngine te=(TerasologyEngine)CoreRegistry.get(GameEngine.class);
if (button.getState() == 0) {
te.setVSync(false);
}
 else {
te.setVSync(true);
}
}
}
;
vSyncButton.addState(""String_Node_Str"",vSyncStateAction);
vSyncButton.addState(""String_Node_Str"",vSyncStateAction);
vSyncButton.addClickListener(clickAction);
vSyncButton.setHorizontalAlign(EHorizontalAlign.CENTER);
vSyncButton.setPosition(new Vector2f(-vSyncButton.getSize().x / 2f - 10f,300f + 5 * 40f));
vSyncButton.setVisible(true);
backToConfigMenuButton=new UIButton(new Vector2f(256f,32f),UIButton.ButtonType.NORMAL);
backToConfigMenuButton.getLabel().setText(""String_Node_Str"");
backToConfigMenuButton.setHorizontalAlign(EHorizontalAlign.CENTER);
backToConfigMenuButton.setPosition(new Vector2f(0f,300f + 7 * 40f));
backToConfigMenuButton.setVisible(true);
backToConfigMenuButton.addClickListener(new ClickListener(){
@Override public void click(UIDisplayElement element,int button){
CoreRegistry.get(ShaderManager.class).recompileAllShaders();
getGUIManager().openWindow(""String_Node_Str"");
}
}
);
addDisplayElement(title);
addDisplayElement(version);
addDisplayElement(graphicsQualityButton);
addDisplayElement(fovButton);
addDisplayElement(viewingDistanceButton);
addDisplayElement(reflectiveWaterButton);
addDisplayElement(blurIntensityButton);
addDisplayElement(bobbingButton);
addDisplayElement(backToConfigMenuButton);
addDisplayElement(fullscreenButton);
addDisplayElement(outlineButton);
addDisplayElement(shadowButton);
addDisplayElement(environmentEffectsButton);
addDisplayElement(vSyncButton);
setup();
}","public UIMenuConfigVideo(){
  setId(""String_Node_Str"");
  setBackgroundImage(""String_Node_Str"");
  setModal(true);
  maximize();
  title=new UIImage(Assets.getTexture(""String_Node_Str""));
  title.setHorizontalAlign(EHorizontalAlign.CENTER);
  title.setPosition(new Vector2f(0f,128f));
  title.setVisible(true);
  title.setSize(new Vector2f(512f,128f));
  version=new UILabel(""String_Node_Str"");
  version.setHorizontalAlign(EHorizontalAlign.CENTER);
  version.setPosition(new Vector2f(0f,230f));
  version.setVisible(true);
  graphicsQualityButton=new UIStateButton(new Vector2f(256f,32f));
  StateButtonAction graphicsQualityStateAction=new StateButtonAction(){
    @Override public void action(    UIDisplayElement element){
      UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
        config.getRendering().setFlickeringLight(true);
      config.getRendering().setVignette(true);
    config.getRendering().setEyeAdaptation(true);
  config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(false);
config.getRendering().setMotionBlur(false);
config.getRendering().setSsao(false);
config.getRendering().setLightShafts(false);
config.getRendering().setCloudShadows(false);
break;
case 1:
config.getRendering().setFlickeringLight(true);
config.getRendering().setVignette(true);
config.getRendering().setEyeAdaptation(true);
config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(true);
config.getRendering().setSsao(false);
config.getRendering().setMotionBlur(false);
config.getRendering().setLightShafts(false);
config.getRendering().setCloudShadows(false);
break;
case 2:
config.getRendering().setFlickeringLight(true);
config.getRendering().setVignette(true);
config.getRendering().setEyeAdaptation(true);
config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(true);
config.getRendering().setMotionBlur(true);
config.getRendering().setLightShafts(true);
config.getRendering().setCloudShadows(true);
config.getRendering().setSsao(false);
break;
case 3:
config.getRendering().setFlickeringLight(true);
config.getRendering().setVignette(true);
config.getRendering().setEyeAdaptation(true);
config.getRendering().setFilmGrain(true);
config.getRendering().setBloom(true);
config.getRendering().setMotionBlur(true);
config.getRendering().setSsao(true);
config.getRendering().setLightShafts(true);
config.getRendering().setCloudShadows(true);
break;
}
}
}
;
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addState(""String_Node_Str"",graphicsQualityStateAction);
graphicsQualityButton.addClickListener(clickAction);
graphicsQualityButton.setHorizontalAlign(EHorizontalAlign.CENTER);
graphicsQualityButton.setPosition(new Vector2f(-graphicsQualityButton.getSize().x / 2f - 10f,300f));
graphicsQualityButton.setVisible(true);
viewingDistanceButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction viewingDistanceStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setViewDistance(ViewDistance.forIndex(button.getState()));
}
}
;
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addState(""String_Node_Str"",viewingDistanceStateAction);
viewingDistanceButton.addClickListener(clickAction);
viewingDistanceButton.setHorizontalAlign(EHorizontalAlign.CENTER);
viewingDistanceButton.setPosition(new Vector2f(-viewingDistanceButton.getSize().x / 2f - 10f,300f + 40f));
viewingDistanceButton.setVisible(true);
fovButton=new UISlider(new Vector2f(256f,32f),75,130);
fovButton.addChangedListener(new ChangedListener(){
@Override public void changed(UIDisplayElement element){
UISlider slider=(UISlider)element;
slider.setText(""String_Node_Str"" + String.valueOf(slider.getValue()));
config.getRendering().setFieldOfView(slider.getValue());
}
}
);
fovButton.setHorizontalAlign(EHorizontalAlign.CENTER);
fovButton.setPosition(new Vector2f(-fovButton.getSize().x / 2f - 10f,300f + 2 * 40f));
fovButton.setVisible(true);
bobbingButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction bobbingStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setCameraBobbing(button.getState() != 0);
}
}
;
bobbingButton.addState(""String_Node_Str"",bobbingStateAction);
bobbingButton.addState(""String_Node_Str"",bobbingStateAction);
bobbingButton.addClickListener(clickAction);
bobbingButton.setHorizontalAlign(EHorizontalAlign.CENTER);
bobbingButton.setPosition(new Vector2f(-bobbingButton.getSize().x / 2f - 10f,300f + 3 * 40f));
bobbingButton.setVisible(true);
reflectiveWaterButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction reflectiveWaterStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
config.getRendering().setReflectiveWater(false);
config.getRendering().setLocalReflections(false);
break;
case 1:
config.getRendering().setReflectiveWater(false);
config.getRendering().setLocalReflections(true);
break;
case 2:
config.getRendering().setReflectiveWater(true);
config.getRendering().setLocalReflections(true);
break;
}
}
}
;
reflectiveWaterButton.addState(""String_Node_Str"",reflectiveWaterStateAction);
reflectiveWaterButton.addState(""String_Node_Str"",reflectiveWaterStateAction);
reflectiveWaterButton.addState(""String_Node_Str"",reflectiveWaterStateAction);
reflectiveWaterButton.addClickListener(clickAction);
reflectiveWaterButton.setHorizontalAlign(EHorizontalAlign.CENTER);
reflectiveWaterButton.setPosition(new Vector2f(reflectiveWaterButton.getSize().x / 2f,300f + 40f));
reflectiveWaterButton.setVisible(true);
blurIntensityButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction blurIntensityStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setBlurIntensity(button.getState());
}
}
;
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addState(""String_Node_Str"",blurIntensityStateAction);
blurIntensityButton.addClickListener(clickAction);
blurIntensityButton.setHorizontalAlign(EHorizontalAlign.CENTER);
blurIntensityButton.setPosition(new Vector2f(blurIntensityButton.getSize().x / 2f,300f + 2 * 40f));
blurIntensityButton.setVisible(true);
fullscreenButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction fullscreenStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
TerasologyEngine te=(TerasologyEngine)CoreRegistry.get(GameEngine.class);
if (button.getState() == 0) {
te.setFullscreen(false);
}
 else {
te.setFullscreen(true);
}
}
}
;
fullscreenButton.addState(""String_Node_Str"",fullscreenStateAction);
fullscreenButton.addState(""String_Node_Str"",fullscreenStateAction);
fullscreenButton.addClickListener(clickAction);
fullscreenButton.setHorizontalAlign(EHorizontalAlign.CENTER);
fullscreenButton.setPosition(new Vector2f(fullscreenButton.getSize().x / 2f,300f + 3 * 40f));
fullscreenButton.setVisible(true);
outlineButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction outlineStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
config.getRendering().setOutline(button.getState() != 0);
}
}
;
outlineButton.addState(""String_Node_Str"",outlineStateAction);
outlineButton.addState(""String_Node_Str"",outlineStateAction);
outlineButton.addClickListener(clickAction);
outlineButton.setHorizontalAlign(EHorizontalAlign.CENTER);
outlineButton.setPosition(new Vector2f(outlineButton.getSize().x / 2f,300f + 4 * 40f));
outlineButton.setVisible(true);
shadowButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction shadowStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
config.getRendering().setDynamicShadowsPcfFiltering(false);
config.getRendering().setDynamicShadows(false);
break;
case 1:
config.getRendering().setDynamicShadowsPcfFiltering(false);
config.getRendering().setDynamicShadows(true);
break;
case 2:
config.getRendering().setDynamicShadowsPcfFiltering(true);
config.getRendering().setDynamicShadows(true);
break;
}
}
}
;
shadowButton.addState(""String_Node_Str"",shadowStateAction);
shadowButton.addState(""String_Node_Str"",shadowStateAction);
shadowButton.addState(""String_Node_Str"",shadowStateAction);
shadowButton.addClickListener(clickAction);
shadowButton.setHorizontalAlign(EHorizontalAlign.CENTER);
shadowButton.setPosition(new Vector2f(-shadowButton.getSize().x / 2f - 10f,300f + 4 * 40f));
shadowButton.setVisible(true);
environmentEffectsButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction environmentEffectsStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
switch (button.getState()) {
case 0:
config.getRendering().setVolumetricLighting(false);
config.getRendering().setVolumetricFog(false);
config.getRendering().setAnimateGrass(false);
config.getRendering().setAnimateWater(false);
break;
case 1:
config.getRendering().setVolumetricLighting(false);
config.getRendering().setAnimateWater(false);
config.getRendering().setVolumetricFog(true);
config.getRendering().setAnimateGrass(true);
break;
case 2:
config.getRendering().setVolumetricLighting(false);
config.getRendering().setAnimateWater(true);
config.getRendering().setVolumetricFog(true);
config.getRendering().setAnimateGrass(true);
break;
case 3:
config.getRendering().setVolumetricLighting(true);
config.getRendering().setAnimateWater(true);
config.getRendering().setVolumetricFog(true);
config.getRendering().setAnimateGrass(true);
break;
}
}
}
;
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addState(""String_Node_Str"",environmentEffectsStateAction);
environmentEffectsButton.addClickListener(clickAction);
environmentEffectsButton.setHorizontalAlign(EHorizontalAlign.CENTER);
environmentEffectsButton.setPosition(new Vector2f(environmentEffectsButton.getSize().x / 2f,300f));
environmentEffectsButton.setVisible(true);
vSyncButton=new UIStateButton(new Vector2f(256f,32f));
StateButtonAction vSyncStateAction=new StateButtonAction(){
@Override public void action(UIDisplayElement element){
UIStateButton button=(UIStateButton)element;
TerasologyEngine te=(TerasologyEngine)CoreRegistry.get(GameEngine.class);
if (button.getState() == 0) {
te.setVSync(false);
}
 else {
te.setVSync(true);
}
}
}
;
vSyncButton.addState(""String_Node_Str"",vSyncStateAction);
vSyncButton.addState(""String_Node_Str"",vSyncStateAction);
vSyncButton.addClickListener(clickAction);
vSyncButton.setHorizontalAlign(EHorizontalAlign.CENTER);
vSyncButton.setPosition(new Vector2f(-vSyncButton.getSize().x / 2f - 10f,300f + 5 * 40f));
vSyncButton.setVisible(true);
backToConfigMenuButton=new UIButton(new Vector2f(256f,32f),UIButton.ButtonType.NORMAL);
backToConfigMenuButton.getLabel().setText(""String_Node_Str"");
backToConfigMenuButton.setHorizontalAlign(EHorizontalAlign.CENTER);
backToConfigMenuButton.setPosition(new Vector2f(0f,300f + 7 * 40f));
backToConfigMenuButton.setVisible(true);
backToConfigMenuButton.addClickListener(new ClickListener(){
@Override public void click(UIDisplayElement element,int button){
CoreRegistry.get(ShaderManager.class).recompileAllShaders();
getGUIManager().openWindow(""String_Node_Str"");
}
}
);
addDisplayElement(title);
addDisplayElement(version);
addDisplayElement(graphicsQualityButton);
addDisplayElement(fovButton);
addDisplayElement(viewingDistanceButton);
addDisplayElement(reflectiveWaterButton);
addDisplayElement(blurIntensityButton);
addDisplayElement(bobbingButton);
addDisplayElement(backToConfigMenuButton);
addDisplayElement(fullscreenButton);
addDisplayElement(outlineButton);
addDisplayElement(shadowButton);
addDisplayElement(environmentEffectsButton);
addDisplayElement(vSyncButton);
setup();
}",0.9940128953024256
1032,"@Override public void render(){
  canvas.preRender();
  canvas.drawText(font,""String_Node_Str"");
  canvas.setOffset(15,100);
  canvas.drawTextShadowed(font,""String_Node_Str"",Color.BLACK);
  try (SubRegion ignored=canvas.subRegion(Rect2i.createFromMinAndMax(0,300,100,500),true)){
    canvas.drawText(font,""String_Node_Str"",300);
  }
   canvas.setOffset(0,150);
  canvas.drawText(font,""String_Node_Str"");
  canvas.postRender();
}","@Override public void render(){
  canvas.preRender();
  canvas.drawTexture(Assets.getTexture(""String_Node_Str""),Rect2i.createFromMinAndSize(0,0,400,400),ScaleMode.STRETCH);
  canvas.drawText(font,""String_Node_Str"");
  canvas.setOffset(15,100);
  canvas.drawTextShadowed(font,""String_Node_Str"",Color.BLACK);
  try (SubRegion ignored=canvas.subRegion(Rect2i.createFromMinAndMax(0,300,100,500),true)){
    canvas.drawText(font,""String_Node_Str"",300);
  }
   canvas.setOffset(0,150);
  canvas.drawText(font,""String_Node_Str"");
  canvas.postRender();
}",0.877948717948718
1033,"public LwjglSubRegion(Rect2i region,boolean crop){
  previousState=state;
  subregionStack.push(this);
  int left=region.minX() + state.region.minX();
  int right=region.maxX() + state.region.minX();
  int top=region.minY() + state.region.minY();
  int bottom=region.maxY() + state.region.minY();
  Rect2i subRegion=Rect2i.createFromMinAndMax(left,top,right,bottom);
  if (crop) {
    int cropLeft=Math.max(left,state.cropRegion.minX());
    int cropRight=Math.min(right,state.cropRegion.maxX());
    int cropTop=Math.max(top,state.cropRegion.minY());
    int cropBottom=Math.min(bottom,state.cropRegion.maxY());
    state=new CanvasState(subRegion,Rect2i.createFromMinAndMax(cropLeft,cropTop,cropRight,cropBottom));
    glScissor(cropLeft,cropTop,cropRight - cropLeft,cropBottom - cropTop);
  }
 else {
    state=new CanvasState(subRegion);
  }
}","public LwjglSubRegion(Rect2i region,boolean crop){
  previousState=state;
  subregionStack.push(this);
  int left=region.minX() + state.region.minX();
  int right=region.maxX() + state.region.minX();
  int top=region.minY() + state.region.minY();
  int bottom=region.maxY() + state.region.minY();
  Rect2i subRegion=Rect2i.createFromMinAndMax(left,top,right,bottom);
  if (crop) {
    int cropLeft=Math.max(left,state.cropRegion.minX());
    int cropRight=Math.min(right,state.cropRegion.maxX());
    int cropTop=Math.max(top,state.cropRegion.minY());
    int cropBottom=Math.min(bottom,state.cropRegion.maxY());
    state=new CanvasState(subRegion,Rect2i.createFromMinAndMax(cropLeft,cropTop,cropRight,cropBottom));
    glScissor(cropLeft,cropTop,cropRight - cropLeft,cropBottom - cropTop);
    croppingRegion=true;
  }
 else {
    state=new CanvasState(subRegion);
  }
}",0.985456660849331
1034,"public CanvasState(Rect2i region,Rect2i cropRegion){
  this.region=region;
  this.cropRegion=cropRegion;
  this.cropped=true;
}","public CanvasState(Rect2i region,Rect2i cropRegion){
  this.region=region;
  this.cropRegion=cropRegion;
}",0.9098712446351932
1035,"@Override public void close(){
  if (!disposed) {
    disposed=true;
    LwjglSubRegion region=subregionStack.pop();
    while (!region.equals(this)) {
      logger.error(""String_Node_Str"");
      region.close();
      region=subregionStack.pop();
    }
    if (state.cropped) {
      glScissor(previousState.region.minX(),previousState.region.minY(),previousState.region.width(),previousState.region.height());
    }
    state=previousState;
  }
}","@Override public void close(){
  if (!disposed) {
    disposed=true;
    LwjglSubRegion region=subregionStack.pop();
    while (!region.equals(this)) {
      logger.error(""String_Node_Str"");
      region.close();
      region=subregionStack.pop();
    }
    if (croppingRegion) {
      glScissor(previousState.region.minX(),previousState.region.minY(),previousState.region.width(),previousState.region.height());
    }
    state=previousState;
  }
}",0.9698996655518396
1036,"@Override public Map<Material,Mesh> createTextMesh(List<String> lines){
  Map<Material,MeshBuilder> meshBuilders=Maps.newLinkedHashMap();
  addLinesToMesh(lines,meshBuilders);
  Map<Material,Mesh> result=Maps.newLinkedHashMap();
  for (  Map.Entry<Material,MeshBuilder> entry : meshBuilders.entrySet()) {
    result.put(entry.getKey(),entry.getValue().getMesh());
  }
  return result;
}","@Override public Map<Material,Mesh> createTextMesh(List<String> lines){
  Map<Material,MeshBuilder> meshBuilders=Maps.newLinkedHashMap();
  addLinesToMesh(lines,meshBuilders);
  Map<Material,Mesh> result=Maps.newLinkedHashMap();
  for (  Map.Entry<Material,MeshBuilder> entry : meshBuilders.entrySet()) {
    result.put(entry.getKey(),entry.getValue().build());
  }
  return result;
}",0.9844155844155844
1037,"private void addLinesToMesh(List<String> lines,Map<Material,MeshBuilder> meshBuilders){
  int y=0;
  for (  String line : lines) {
    int x=0;
    for (    char c : line.toCharArray()) {
      FontCharacter character=data.getCharacter(c);
      if (character != null && character.getPage() != null) {
        MeshBuilder builder=meshBuilders.get(character.getPageMat());
        if (builder == null) {
          builder=new MeshBuilder();
          meshBuilders.put(character.getPageMat(),builder);
        }
        builder.addCharacter(character,x,y);
        x+=character.getxAdvance();
      }
    }
    y+=data.getLineHeight();
  }
}","private void addLinesToMesh(List<String> lines,Map<Material,MeshBuilder> meshBuilders){
  int y=0;
  for (  String line : lines) {
    int x=0;
    for (    char c : line.toCharArray()) {
      FontCharacter character=data.getCharacter(c);
      if (character != null && character.getPage() != null) {
        MeshBuilder builder=meshBuilders.get(character.getPageMat());
        if (builder == null) {
          builder=new MeshBuilder();
          meshBuilders.put(character.getPageMat(),builder);
        }
        addCharacter(builder,character,x,y);
        x+=character.getxAdvance();
      }
    }
    y+=data.getLineHeight();
  }
}",0.9780907668231612
1038,"public void addCharacter(FontCharacter character,int x,int y){
  float top=y + character.getyOffset();
  float bottom=top + character.getHeight();
  float left=x + character.getxOffset();
  float right=left + character.getWidth();
  float texTop=character.getY();
  float texBottom=texTop + character.getTexHeight();
  float texLeft=character.getX();
  float texRight=texLeft + character.getTexWidth();
  meshData.getVertices().add(left);
  meshData.getVertices().add(top);
  meshData.getVertices().add(0);
  meshData.getTexCoord0().add(texLeft);
  meshData.getTexCoord0().add(texTop);
  meshData.getVertices().add(right);
  meshData.getVertices().add(top);
  meshData.getVertices().add(0);
  meshData.getTexCoord0().add(texRight);
  meshData.getTexCoord0().add(texTop);
  meshData.getVertices().add(right);
  meshData.getVertices().add(bottom);
  meshData.getVertices().add(0);
  meshData.getTexCoord0().add(texRight);
  meshData.getTexCoord0().add(texBottom);
  meshData.getVertices().add(left);
  meshData.getVertices().add(bottom);
  meshData.getVertices().add(0);
  meshData.getTexCoord0().add(texLeft);
  meshData.getTexCoord0().add(texBottom);
  meshData.getIndices().add(vertCount);
  meshData.getIndices().add(vertCount + 1);
  meshData.getIndices().add(vertCount + 2);
  meshData.getIndices().add(vertCount);
  meshData.getIndices().add(vertCount + 2);
  meshData.getIndices().add(vertCount + 3);
  vertCount+=4;
}","public void addCharacter(MeshBuilder builder,FontCharacter character,int x,int y){
  float top=y + character.getyOffset();
  float bottom=top + character.getHeight();
  float left=x + character.getxOffset();
  float right=left + character.getWidth();
  float texTop=character.getY();
  float texBottom=texTop + character.getTexHeight();
  float texLeft=character.getX();
  float texRight=texLeft + character.getTexWidth();
  Vector3f v1=new Vector3f(left,top,0);
  Vector3f v2=new Vector3f(right,top,0);
  Vector3f v3=new Vector3f(right,bottom,0);
  Vector3f v4=new Vector3f(left,bottom,0);
  builder.addPoly(v1,v2,v3,v4);
  builder.addTexCoord(texLeft,texTop);
  builder.addTexCoord(texRight,texTop);
  builder.addTexCoord(texRight,texBottom);
  builder.addTexCoord(texLeft,texBottom);
}",0.3743218806509946
1039,"public static void generateInternalLighting(Chunk chunk){
  int top=Chunk.SIZE_Y - 1;
  short[] tops=new short[Chunk.SIZE_X * Chunk.SIZE_Z];
  byte sunlightMax=SUNLIGHT_RULES.getMaxValue();
  for (int x=0; x < Chunk.SIZE_X; x++) {
    for (int z=0; z < Chunk.SIZE_Z; z++) {
      Block lastBlock=BlockManager.getAir();
      int y=top;
      for (; y >= 0; y--) {
        Block block=chunk.getBlock(x,y,z);
        if (SUNLIGHT_RULES.propagateValue(sunlightMax,Side.BOTTOM,lastBlock) == sunlightMax && SUNLIGHT_RULES.canSpreadOutOf(lastBlock,Side.BOTTOM) && SUNLIGHT_RULES.canSpreadInto(block,Side.TOP)) {
          chunk.setSunlight(x,y,z,sunlightMax);
          lastBlock=block;
        }
      }
      tops[x + Chunk.SIZE_X * z]=(short)y;
    }
  }
  BatchPropagator lightPropagator=new BatchPropagator(LIGHT_RULES,new SingleChunkView(LIGHT_RULES,chunk));
  for (int x=0; x < Chunk.SIZE_X; x++) {
    for (int z=0; z < Chunk.SIZE_Z; z++) {
      if (tops[x + Chunk.SIZE_X * z] < top) {
        Block block=chunk.getBlock(x,tops[x + Chunk.SIZE_X * z] + 1,z);
        spreadSunlightInternal(chunk,x,tops[x + Chunk.SIZE_X * z] + 1,z,block);
      }
      for (int y=top; y >= 0; y--) {
        Block block=chunk.getBlock(x,y,z);
        if (y > tops[x + Chunk.SIZE_X * z] && ((x > 0 && tops[(x - 1) + Chunk.SIZE_X * z] >= y) || (x < Chunk.SIZE_X - 1 && tops[(x + 1) + Chunk.SIZE_X * z] >= y) || (z > 0 && tops[x + Chunk.SIZE_X * (z - 1)] >= y)|| (z < Chunk.SIZE_Z - 1 && tops[x + Chunk.SIZE_X * (z + 1)] >= y))) {
          spreadSunlightInternal(chunk,x,y,z,block);
        }
        if (block.getLuminance() > 0) {
          chunk.setLight(x,y,z,block.getLuminance());
          lightPropagator.propagateFrom(new Vector3i(x,y,z),block);
        }
      }
    }
  }
  lightPropagator.process();
}","public static void generateInternalLighting(Chunk chunk){
  int top=Chunk.SIZE_Y - 1;
  short[] tops=new short[Chunk.SIZE_X * Chunk.SIZE_Z];
  byte sunlightMax=SUNLIGHT_RULES.getMaxValue();
  for (int x=0; x < Chunk.SIZE_X; x++) {
    for (int z=0; z < Chunk.SIZE_Z; z++) {
      Block lastBlock=BlockManager.getAir();
      int y=top;
      for (; y >= 0; y--) {
        Block block=chunk.getBlock(x,y,z);
        if (SUNLIGHT_RULES.propagateValue(sunlightMax,Side.BOTTOM,lastBlock) == sunlightMax && SUNLIGHT_RULES.canSpreadOutOf(lastBlock,Side.BOTTOM) && SUNLIGHT_RULES.canSpreadInto(block,Side.TOP)) {
          chunk.setSunlight(x,y,z,sunlightMax);
          lastBlock=block;
        }
 else {
          break;
        }
      }
      tops[x + Chunk.SIZE_X * z]=(short)y;
    }
  }
  BatchPropagator lightPropagator=new BatchPropagator(LIGHT_RULES,new SingleChunkView(LIGHT_RULES,chunk));
  for (int x=0; x < Chunk.SIZE_X; x++) {
    for (int z=0; z < Chunk.SIZE_Z; z++) {
      if (tops[x + Chunk.SIZE_X * z] < top) {
        Block block=chunk.getBlock(x,tops[x + Chunk.SIZE_X * z] + 1,z);
        spreadSunlightInternal(chunk,x,tops[x + Chunk.SIZE_X * z] + 1,z,block);
      }
      for (int y=top; y >= 0; y--) {
        Block block=chunk.getBlock(x,y,z);
        if (y > tops[x + Chunk.SIZE_X * z] && ((x > 0 && tops[(x - 1) + Chunk.SIZE_X * z] >= y) || (x < Chunk.SIZE_X - 1 && tops[(x + 1) + Chunk.SIZE_X * z] >= y) || (z > 0 && tops[x + Chunk.SIZE_X * (z - 1)] >= y)|| (z < Chunk.SIZE_Z - 1 && tops[x + Chunk.SIZE_X * (z + 1)] >= y))) {
          spreadSunlightInternal(chunk,x,y,z,block);
        }
        if (block.getLuminance() > 1) {
          lightPropagator.propagateFrom(new Vector3i(x,y,z),block);
        }
      }
    }
  }
  lightPropagator.process();
}",0.9286713286713286
1040,"private static void spreadSunlightInternal(Chunk chunk,int x,int y,int z,Block block){
  byte lightValue=chunk.getSunlight(x,y,z);
  if (y > 0 && SUNLIGHT_RULES.canSpreadOutOf(block,Side.BOTTOM)) {
    Block adjBlock=chunk.getBlock(x,y - 1,z);
    if (chunk.getSunlight(x,y - 1,z) < lightValue - 1 && SUNLIGHT_RULES.canSpreadInto(adjBlock,Side.TOP)) {
      chunk.setSunlight(x,y - 1,z,(byte)(lightValue - 1));
      spreadSunlightInternal(chunk,x,y - 1,z,adjBlock);
    }
  }
  if (y < Chunk.SIZE_Y && lightValue < Chunk.MAX_LIGHT && SUNLIGHT_RULES.canSpreadOutOf(block,Side.TOP)) {
    Block adjBlock=chunk.getBlock(x,y + 1,z);
    if (chunk.getSunlight(x,y + 1,z) < lightValue - 1 && SUNLIGHT_RULES.canSpreadInto(adjBlock,Side.BOTTOM)) {
      chunk.setSunlight(x,y + 1,z,(byte)(lightValue - 1));
      spreadSunlightInternal(chunk,x,y + 1,z,adjBlock);
    }
  }
  if (lightValue <= 1) {
    return;
  }
  for (  Side adjDir : Side.horizontalSides()) {
    int adjX=x + adjDir.getVector3i().x;
    int adjZ=z + adjDir.getVector3i().z;
    if (chunk.isInBounds(adjX,y,adjZ) && SUNLIGHT_RULES.canSpreadOutOf(block,adjDir)) {
      byte adjLightValue=chunk.getSunlight(adjX,y,adjZ);
      Block adjBlock=chunk.getBlock(adjX,y,adjZ);
      if (adjLightValue < lightValue - 1 && SUNLIGHT_RULES.canSpreadInto(adjBlock,adjDir.reverse())) {
        chunk.setSunlight(adjX,y,adjZ,(byte)(lightValue - 1));
        spreadSunlightInternal(chunk,adjX,y,adjZ,adjBlock);
      }
    }
  }
}","private static void spreadSunlightInternal(Chunk chunk,int x,int y,int z,Block block){
  byte lightValue=chunk.getSunlight(x,y,z);
  if (lightValue <= 1) {
    return;
  }
  if (y > 0 && SUNLIGHT_RULES.canSpreadOutOf(block,Side.BOTTOM)) {
    Block adjBlock=chunk.getBlock(x,y - 1,z);
    if (chunk.getSunlight(x,y - 1,z) < lightValue - 1 && SUNLIGHT_RULES.canSpreadInto(adjBlock,Side.TOP)) {
      chunk.setSunlight(x,y - 1,z,(byte)(lightValue - 1));
      spreadSunlightInternal(chunk,x,y - 1,z,adjBlock);
    }
  }
  if (y < Chunk.SIZE_Y && lightValue < Chunk.MAX_LIGHT && SUNLIGHT_RULES.canSpreadOutOf(block,Side.TOP)) {
    Block adjBlock=chunk.getBlock(x,y + 1,z);
    if (chunk.getSunlight(x,y + 1,z) < lightValue - 1 && SUNLIGHT_RULES.canSpreadInto(adjBlock,Side.BOTTOM)) {
      chunk.setSunlight(x,y + 1,z,(byte)(lightValue - 1));
      spreadSunlightInternal(chunk,x,y + 1,z,adjBlock);
    }
  }
  for (  Side adjDir : Side.horizontalSides()) {
    int adjX=x + adjDir.getVector3i().x;
    int adjZ=z + adjDir.getVector3i().z;
    if (chunk.isInBounds(adjX,y,adjZ) && SUNLIGHT_RULES.canSpreadOutOf(block,adjDir)) {
      byte adjLightValue=chunk.getSunlight(adjX,y,adjZ);
      Block adjBlock=chunk.getBlock(adjX,y,adjZ);
      if (adjLightValue < lightValue - 1 && SUNLIGHT_RULES.canSpreadInto(adjBlock,adjDir.reverse())) {
        chunk.setSunlight(adjX,y,adjZ,(byte)(lightValue - 1));
        spreadSunlightInternal(chunk,adjX,y,adjZ,adjBlock);
      }
    }
  }
}",0.9722598105548038
1041,"public AssetUri resolve(AssetType type,String name){
  AssetUri uri=new AssetUri(type,name);
  if (uri.isValid()) {
    return uri;
  }
  List<AssetUri> possibilities=resolveAll(type,name);
switch (possibilities.size()) {
case 0:
    return null;
case 1:
  return possibilities.get(0);
default :
Module context=ModuleContext.getContext();
if (context != null) {
Set<String> dependencies=moduleManager.getDependencyNamesOf(context);
Iterator<AssetUri> iterator=possibilities.iterator();
while (iterator.hasNext()) {
  AssetUri possibleUri=iterator.next();
  if (context.getId().equals(possibleUri.getNormalisedModuleName())) {
    return possibleUri;
  }
  if (!dependencies.contains(possibleUri.getNormalisedModuleName())) {
    iterator.remove();
  }
}
if (possibilities.size() == 1) {
  return possibilities.get(0);
}
}
return null;
}
}","public AssetUri resolve(AssetType type,String name){
  List<AssetUri> possibilities=resolveAll(type,name);
switch (possibilities.size()) {
case 0:
    return null;
case 1:
  return possibilities.get(0);
default :
Module context=ModuleContext.getContext();
if (context != null) {
Set<String> dependencies=moduleManager.getDependencyNamesOf(context);
Iterator<AssetUri> iterator=possibilities.iterator();
while (iterator.hasNext()) {
  AssetUri possibleUri=iterator.next();
  if (context.getId().equals(possibleUri.getNormalisedModuleName())) {
    return possibleUri;
  }
  if (!dependencies.contains(possibleUri.getNormalisedModuleName())) {
    iterator.remove();
  }
}
if (possibilities.size() == 1) {
  return possibilities.get(0);
}
}
return null;
}
}",0.9478970495919647
1042,"public List<AssetUri> resolveAll(AssetType type,String name){
  return Lists.newArrayList(uriLookup.get(type).row(UriUtil.normalise(name)).values());
}","public List<AssetUri> resolveAll(AssetType type,String name){
  AssetUri uri=new AssetUri(type,name);
  if (uri.isValid()) {
    return Lists.newArrayList(uri);
  }
  return Lists.newArrayList(uriLookup.get(type).row(UriUtil.normalise(name)).values());
}",0.745679012345679
1043,"public void receiveFamilyRegistration(BlockUri familyUri,Map<String,Integer> registration){
  BlockFamily family;
  if (isFreeformFamily(familyUri.getRootFamilyUri())) {
    family=blockLoader.loadWithShape(familyUri);
  }
 else {
    family=getAvailableBlockFamily(familyUri);
  }
  if (family != null) {
    for (    Block block : family.getBlocks()) {
      Integer id=registration.get(block.getURI().toString());
      if (id != null) {
        block.setId((byte)id.intValue());
      }
 else {
        logger.error(""String_Node_Str"",block.getURI(),familyUri);
        block.setId(UNKNOWN_ID);
      }
      registerFamily(family);
    }
  }
 else {
    logger.error(""String_Node_Str"",familyUri);
  }
}","public void receiveFamilyRegistration(BlockUri familyUri,Map<String,Integer> registration){
  BlockFamily family;
  if (isFreeformFamily(familyUri)) {
    family=blockLoader.loadWithShape(familyUri);
  }
 else {
    family=getAvailableBlockFamily(familyUri);
  }
  if (family != null) {
    for (    Block block : family.getBlocks()) {
      Integer id=registration.get(block.getURI().toString());
      if (id != null) {
        block.setId((byte)id.intValue());
      }
 else {
        logger.error(""String_Node_Str"",block.getURI(),familyUri);
        block.setId(UNKNOWN_ID);
      }
      registerFamily(family);
    }
  }
 else {
    logger.error(""String_Node_Str"",familyUri);
  }
}",0.9863603732950468
1044,"@Override public boolean isFreeformFamily(BlockUri familyUri){
  return freeformBlockUris.contains(familyUri);
}","@Override public boolean isFreeformFamily(BlockUri familyUri){
  return freeformBlockUris.contains(familyUri.getRootFamilyUri());
}",0.9218106995884774
1045,"private boolean isSubtype(CtClass cc,Class parentType) throws NotFoundException {
  if (parentType.isInterface()) {
    for (    CtClass parentInterface : cc.getInterfaces()) {
      if (parentInterface.getName().equals(parentInterface.getName())) {
        return true;
      }
 else       if (isSubtype(parentInterface,parentType)) {
        return true;
      }
    }
    if (cc.getSuperclass() != null) {
      return isSubtype(cc,parentType);
    }
  }
  return false;
}","private boolean isSubtype(CtClass cc,Class parentType) throws NotFoundException {
  if (parentType.isInterface()) {
    for (    CtClass parentInterface : cc.getInterfaces()) {
      if (parentInterface.getName().equals(parentInterface.getName())) {
        return true;
      }
 else       if (isSubtype(parentInterface,parentType)) {
        return true;
      }
    }
    if (cc.getSuperclass() != null) {
      return isSubtype(cc.getSuperclass(),parentType);
    }
  }
  return false;
}",0.9834368530020704
1046,"@Override public void update(float delta){
  long startTime=1000 * Sys.getTime() / Sys.getTimerResolution();
  while (current != null && 1000 * Sys.getTime() / Sys.getTimerResolution() - startTime < 20) {
    if (current.step()) {
      popStep();
    }
 else {
      completedSteps++;
    }
  }
  if (current == null) {
    CoreRegistry.get(GUIManager.class).closeWindow(""String_Node_Str"");
    CoreRegistry.get(GameEngine.class).changeState(new StateIngame());
  }
 else {
    if (currentExpectedSteps > 0) {
      loadingScreen.updateStatus(current.getMessage(),100f * completedSteps / currentExpectedSteps);
    }
 else {
      loadingScreen.updateStatus(current.getMessage(),0);
    }
    guiManager.update();
  }
}","@Override public void update(float delta){
  long startTime=1000 * Sys.getTime() / Sys.getTimerResolution();
  while (current != null && 1000 * Sys.getTime() / Sys.getTimerResolution() - startTime < 20) {
    if (current.step()) {
      popStep();
    }
 else {
      completedSteps++;
    }
  }
  if (current == null) {
    CoreRegistry.get(GUIManager.class).closeWindow(""String_Node_Str"");
    CoreRegistry.get(GameEngine.class).changeState(new StateIngame());
  }
 else {
    if (currentExpectedSteps > 0) {
      loadingScreen.updateStatus(current.getMessage(),Math.min(100f,100f * completedSteps / currentExpectedSteps));
    }
 else {
      loadingScreen.updateStatus(current.getMessage(),0);
    }
    guiManager.update();
  }
}",0.9896907216494846
1047,"/** 
 * Set the value which the slider should have.
 * @param value The value. The range of the value should be greater or equal than the minimum value and lower or equal than the maximum value.
 */
public void setValue(int value){
  this.value=value;
  progressLine.updateProgress(value,range);
  notifyChangedListeners();
}","/** 
 * Set the value which the slider should have.
 * @param value The value. The range of the value should be greater or equal than the minimum value and lower or equal than the maximum value.
 */
public void setValue(int value){
  this.value=TeraMath.clamp(value,minValue,maxValue);
  progressLine.updateProgress(value,range);
  notifyChangedListeners();
}",0.935672514619883
1048,"@Override public void reload(MaterialData data){
  dispose();
  shader=(GLSLShader)data.getShader();
  recompile();
  for (  Map.Entry<String,Texture> entry : data.getTextures().entrySet()) {
    setTexture(entry.getKey(),entry.getValue());
  }
  for (  Map.Entry<String,Float> entry : data.getFloatParams().entrySet()) {
    setFloat(entry.getKey(),entry.getValue());
  }
  for (  Map.Entry<String,Integer> entry : data.getIntegerParams().entrySet()) {
    setInt(entry.getKey(),entry.getValue());
  }
  for (  Map.Entry<String,float[]> entry : data.getFloatArrayParams().entrySet()) {
switch (entry.getValue().length) {
case 1:
      setFloat(entry.getKey(),entry.getValue()[0]);
    break;
case 2:
  setFloat2(entry.getKey(),entry.getValue()[0],entry.getValue()[1]);
break;
case 3:
setFloat3(entry.getKey(),entry.getValue()[0],entry.getValue()[1],entry.getValue()[2]);
break;
case 4:
setFloat4(entry.getKey(),entry.getValue()[0],entry.getValue()[1],entry.getValue()[2],entry.getValue()[3]);
break;
}
}
}","@Override public void reload(MaterialData data){
  Util.checkGLError();
  dispose();
  shader=(GLSLShader)data.getShader();
  recompile();
  for (  Map.Entry<String,Texture> entry : data.getTextures().entrySet()) {
    setTexture(entry.getKey(),entry.getValue());
  }
  for (  Map.Entry<String,Float> entry : data.getFloatParams().entrySet()) {
    setFloat(entry.getKey(),entry.getValue());
  }
  for (  Map.Entry<String,Integer> entry : data.getIntegerParams().entrySet()) {
    setInt(entry.getKey(),entry.getValue());
  }
  for (  Map.Entry<String,float[]> entry : data.getFloatArrayParams().entrySet()) {
switch (entry.getValue().length) {
case 1:
      setFloat(entry.getKey(),entry.getValue()[0]);
    break;
case 2:
  setFloat2(entry.getKey(),entry.getValue()[0],entry.getValue()[1]);
break;
case 3:
setFloat3(entry.getKey(),entry.getValue()[0],entry.getValue()[1],entry.getValue()[2]);
break;
case 4:
setFloat4(entry.getKey(),entry.getValue()[0],entry.getValue()[1],entry.getValue()[2],entry.getValue()[3]);
break;
}
}
Util.checkGLError();
}",0.9785992217898832
1049,"@Override public void reload(ShaderData data){
  logger.debug(""String_Node_Str"",getURI());
  dispose();
  shaderProgramBase=data;
  parameters.clear();
  for (  ShaderParameterMetadata metadata : shaderProgramBase.getParameterMetadata()) {
    parameters.put(metadata.getName(),metadata);
  }
  updateAvailableFeatures();
  recompile();
}","@Override public void reload(ShaderData data){
  Util.checkGLError();
  logger.debug(""String_Node_Str"",getURI());
  dispose();
  shaderProgramBase=data;
  parameters.clear();
  for (  ShaderParameterMetadata metadata : shaderProgramBase.getParameterMetadata()) {
    parameters.put(metadata.getName(),metadata);
  }
  updateAvailableFeatures();
  recompile();
  Util.checkGLError();
}",0.9362880886426592
1050,"@Override public void reload(MeshData newData){
  dispose();
  buildMesh(newData);
}","@Override public void reload(MeshData newData){
  Util.checkGLError();
  dispose();
  buildMesh(newData);
  Util.checkGLError();
}",0.7850467289719626
1051,"@Override public void reload(SkeletalMeshData newData){
  dispose();
  this.data=newData;
  vboPosNormBuffer=VertexBufferObjectManager.getInstance().getVboId();
  IntBuffer indexBuffer=BufferUtils.createIntBuffer(newData.getIndices().size());
  indexBuffer.put(newData.getIndices().toArray());
  indexBuffer.flip();
  vboIndexBuffer=VertexBufferObjectManager.getInstance().getVboId();
  VertexBufferObjectManager.getInstance().bufferVboElementData(vboIndexBuffer,indexBuffer,GL15.GL_STATIC_DRAW);
  FloatBuffer uvBuffer=BufferUtils.createFloatBuffer(newData.getUVs().size() * 2);
  for (  Vector2f uv : newData.getUVs()) {
    uvBuffer.put(uv.x);
    uvBuffer.put(uv.y);
  }
  uvBuffer.flip();
  vboUVBuffer=VertexBufferObjectManager.getInstance().getVboId();
  VertexBufferObjectManager.getInstance().bufferVboData(vboUVBuffer,uvBuffer,GL15.GL_STATIC_DRAW);
}","@Override public void reload(SkeletalMeshData newData){
  Util.checkGLError();
  dispose();
  this.data=newData;
  vboPosNormBuffer=VertexBufferObjectManager.getInstance().getVboId();
  IntBuffer indexBuffer=BufferUtils.createIntBuffer(newData.getIndices().size());
  indexBuffer.put(newData.getIndices().toArray());
  indexBuffer.flip();
  vboIndexBuffer=VertexBufferObjectManager.getInstance().getVboId();
  VertexBufferObjectManager.getInstance().bufferVboElementData(vboIndexBuffer,indexBuffer,GL15.GL_STATIC_DRAW);
  FloatBuffer uvBuffer=BufferUtils.createFloatBuffer(newData.getUVs().size() * 2);
  for (  Vector2f uv : newData.getUVs()) {
    uvBuffer.put(uv.x);
    uvBuffer.put(uv.y);
  }
  uvBuffer.flip();
  vboUVBuffer=VertexBufferObjectManager.getInstance().getVboId();
  VertexBufferObjectManager.getInstance().bufferVboData(vboUVBuffer,uvBuffer,GL15.GL_STATIC_DRAW);
  Util.checkGLError();
}",0.9739524348810872
1052,"@Override public void reload(TextureData data){
  dispose();
  this.width=data.getWidth();
  this.height=data.getHeight();
  this.depth=data.getDepth();
  this.wrapMode=data.getWrapMode();
  this.filterMode=data.getFilterMode();
  this.textureType=data.getType();
  this.textureData=data;
switch (textureType) {
case TEXTURE2D:
    id=glGenTextures();
  logger.debug(""String_Node_Str"",getURI(),id);
glBindTexture(GL11.GL_TEXTURE_2D,id);
glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,wrapMode.getGLMode());
glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,wrapMode.getGLMode());
GL11.glTexParameteri(GL_TEXTURE_2D,GL11.GL_TEXTURE_MIN_FILTER,filterMode.getGlMinFilter());
GL11.glTexParameteri(GL_TEXTURE_2D,GL11.GL_TEXTURE_MAG_FILTER,filterMode.getGlMagFilter());
GL11.glPixelStorei(GL11.GL_UNPACK_ALIGNMENT,4);
GL11.glTexParameteri(GL11.GL_TEXTURE_2D,GL12.GL_TEXTURE_MAX_LEVEL,data.getBuffers().length - 1);
for (int i=0; i < data.getBuffers().length; i++) {
GL11.glTexImage2D(GL11.GL_TEXTURE_2D,i,GL11.GL_RGBA,width >> i,height >> i,0,GL11.GL_RGBA,GL11.GL_UNSIGNED_BYTE,data.getBuffers()[i]);
}
break;
case TEXTURE3D:
Util.checkGLError();
id=glGenTextures();
logger.debug(""String_Node_Str"",getURI(),id);
glBindTexture(GL12.GL_TEXTURE_3D,id);
glTexParameterf(GL12.GL_TEXTURE_3D,GL_TEXTURE_WRAP_S,wrapMode.getGLMode());
glTexParameterf(GL12.GL_TEXTURE_3D,GL_TEXTURE_WRAP_T,wrapMode.getGLMode());
glTexParameterf(GL12.GL_TEXTURE_3D,GL12.GL_TEXTURE_WRAP_R,wrapMode.getGLMode());
GL11.glTexParameteri(GL12.GL_TEXTURE_3D,GL11.GL_TEXTURE_MIN_FILTER,filterMode.getGlMinFilter());
GL11.glTexParameteri(GL12.GL_TEXTURE_3D,GL11.GL_TEXTURE_MAG_FILTER,filterMode.getGlMagFilter());
GL11.glPixelStorei(GL11.GL_UNPACK_ALIGNMENT,4);
GL11.glTexParameteri(GL12.GL_TEXTURE_3D,GL12.GL_TEXTURE_MAX_LEVEL,data.getBuffers().length - 1);
for (int i=0; i < data.getBuffers().length; i++) {
GL12.glTexImage3D(GL12.GL_TEXTURE_3D,i,GL11.GL_RGBA,width,height,depth,0,GL11.GL_RGBA,GL11.GL_UNSIGNED_BYTE,data.getBuffers()[i]);
}
Util.checkGLError();
break;
}
}","@Override public void reload(TextureData data){
  Util.checkGLError();
  dispose();
  this.width=data.getWidth();
  this.height=data.getHeight();
  this.depth=data.getDepth();
  this.wrapMode=data.getWrapMode();
  this.filterMode=data.getFilterMode();
  this.textureType=data.getType();
  this.textureData=data;
switch (textureType) {
case TEXTURE2D:
    id=glGenTextures();
  logger.debug(""String_Node_Str"",getURI(),id);
glBindTexture(GL11.GL_TEXTURE_2D,id);
glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,wrapMode.getGLMode());
glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,wrapMode.getGLMode());
GL11.glTexParameteri(GL_TEXTURE_2D,GL11.GL_TEXTURE_MIN_FILTER,filterMode.getGlMinFilter());
GL11.glTexParameteri(GL_TEXTURE_2D,GL11.GL_TEXTURE_MAG_FILTER,filterMode.getGlMagFilter());
GL11.glPixelStorei(GL11.GL_UNPACK_ALIGNMENT,4);
GL11.glTexParameteri(GL11.GL_TEXTURE_2D,GL12.GL_TEXTURE_MAX_LEVEL,data.getBuffers().length - 1);
for (int i=0; i < data.getBuffers().length; i++) {
GL11.glTexImage2D(GL11.GL_TEXTURE_2D,i,GL11.GL_RGBA,width >> i,height >> i,0,GL11.GL_RGBA,GL11.GL_UNSIGNED_BYTE,data.getBuffers()[i]);
}
break;
case TEXTURE3D:
id=glGenTextures();
logger.debug(""String_Node_Str"",getURI(),id);
glBindTexture(GL12.GL_TEXTURE_3D,id);
glTexParameterf(GL12.GL_TEXTURE_3D,GL_TEXTURE_WRAP_S,wrapMode.getGLMode());
glTexParameterf(GL12.GL_TEXTURE_3D,GL_TEXTURE_WRAP_T,wrapMode.getGLMode());
glTexParameterf(GL12.GL_TEXTURE_3D,GL12.GL_TEXTURE_WRAP_R,wrapMode.getGLMode());
GL11.glTexParameteri(GL12.GL_TEXTURE_3D,GL11.GL_TEXTURE_MIN_FILTER,filterMode.getGlMinFilter());
GL11.glTexParameteri(GL12.GL_TEXTURE_3D,GL11.GL_TEXTURE_MAG_FILTER,filterMode.getGlMagFilter());
GL11.glPixelStorei(GL11.GL_UNPACK_ALIGNMENT,4);
GL11.glTexParameteri(GL12.GL_TEXTURE_3D,GL12.GL_TEXTURE_MAX_LEVEL,data.getBuffers().length - 1);
for (int i=0; i < data.getBuffers().length; i++) {
GL12.glTexImage3D(GL12.GL_TEXTURE_3D,i,GL11.GL_RGBA,width,height,depth,0,GL11.GL_RGBA,GL11.GL_UNSIGNED_BYTE,data.getBuffers()[i]);
}
break;
}
Util.checkGLError();
}",0.9847365829640572
1053,"@Override public Prefab deserialize(EntityData.Value value){
  if (value.getStringCount() > 0) {
    return CoreRegistry.get(PrefabManager.class).getPrefab(value.getString(0));
  }
  return null;
}","@Override public Prefab deserialize(EntityData.Value value){
  if (value.getStringCount() > 0) {
    return Assets.getPrefab(value.getString(0));
  }
  return null;
}",0.9035812672176308
1054,"/** 
 * Deserializes a prefab, with a known uri. This uri will override any uri within the serialized prefab
 * @param prefabData
 * @return The deserialized prefab
 */
public PrefabData deserialize(EntityData.Prefab prefabData){
  PrefabData result=new PrefabData();
  result.setPersisted((prefabData.hasPersisted()) ? prefabData.getPersisted() : true);
  result.setAlwaysRelevant(prefabData.hasAlwaysRelevant() ? prefabData.getAlwaysRelevant() : false);
  if (prefabData.hasParentName()) {
    AssetUri parentUri=new AssetUri(AssetType.PREFAB,prefabData.getParentName());
    if (parentUri.isValid()) {
      result.setParent(Assets.get(parentUri,Prefab.class));
    }
  }
  if (result.getParent() != null) {
    for (    Component comp : result.getParent().iterateComponents()) {
      result.addComponent(componentLibrary.copy(comp));
    }
  }
  for (  String removedComponent : prefabData.getRemovedComponentList()) {
    ComponentMetadata<?> metadata=componentLibrary.getMetadata(removedComponent);
    if (metadata != null) {
      result.removeComponent(metadata.getType());
    }
  }
  for (  EntityData.Component componentData : prefabData.getComponentList()) {
    ComponentMetadata<?> metadata=componentLibrary.getMetadata(componentData.getType());
    if (metadata != null) {
      Component existing=result.getComponent(metadata.getType());
      if (existing != null) {
        componentSerializer.deserializeOnto(existing,componentData);
      }
 else {
        Component newComponent=componentSerializer.deserialize(componentData);
        if (newComponent != null) {
          result.addComponent(newComponent);
        }
      }
    }
  }
  return result;
}","/** 
 * Deserializes a prefab, with a known uri. This uri will override any uri within the serialized prefab
 * @param prefabData
 * @return The deserialized prefab
 */
public PrefabData deserialize(EntityData.Prefab prefabData){
  PrefabData result=new PrefabData();
  result.setPersisted((prefabData.hasPersisted()) ? prefabData.getPersisted() : true);
  result.setAlwaysRelevant(prefabData.hasAlwaysRelevant() ? prefabData.getAlwaysRelevant() : false);
  if (prefabData.hasParentName()) {
    AssetUri parentUri=new AssetUri(AssetType.PREFAB,prefabData.getParentName());
    if (parentUri.isValid()) {
      result.setParent(Assets.get(parentUri,Prefab.class));
    }
 else {
      logger.error(""String_Node_Str"",parentUri);
    }
  }
  if (result.getParent() != null) {
    for (    Component comp : result.getParent().iterateComponents()) {
      result.addComponent(componentLibrary.copy(comp));
    }
  }
  for (  String removedComponent : prefabData.getRemovedComponentList()) {
    ComponentMetadata<?> metadata=componentLibrary.getMetadata(removedComponent);
    if (metadata != null) {
      result.removeComponent(metadata.getType());
    }
  }
  for (  EntityData.Component componentData : prefabData.getComponentList()) {
    ComponentMetadata<?> metadata=componentLibrary.getMetadata(componentData.getType());
    if (metadata != null) {
      Component existing=result.getComponent(metadata.getType());
      if (existing != null) {
        componentSerializer.deserializeOnto(existing,componentData);
      }
 else {
        Component newComponent=componentSerializer.deserialize(componentData);
        if (newComponent != null) {
          result.addComponent(newComponent);
        }
      }
    }
  }
  return result;
}",0.9815627743634768
1055,"public boolean isUnderWater(){
  Vector3f cameraPos=new Vector3f(CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition());
  if (config.getRendering().isAnimateWater()) {
    cameraPos.y+=0.5f;
  }
  Block block=CoreRegistry.get(WorldProvider.class).getBlock(new Vector3f(cameraPos));
  return block.isLiquid();
}","public boolean isUnderWater(){
  Vector3f cameraPos=new Vector3f(CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition());
  if (config.getRendering().isAnimateWater()) {
    cameraPos.y+=0.5f;
  }
  if (worldProvider.isBlockRelevant(new Vector3f(cameraPos))) {
    Block block=worldProvider.getBlock(new Vector3f(cameraPos));
    return block.isLiquid();
  }
  return false;
}",0.841225626740947
1056,"protected OpenALException(String message,int errorCode){
  super(""String_Node_Str"" + errorCode + ""String_Node_Str""+ message+ ""String_Node_Str""+ AL10.alGetString(errorCode));
}","private OpenALException(String message,int errorCode){
  super(""String_Node_Str"" + errorCode + ""String_Node_Str""+ message+ ""String_Node_Str""+ AL10.alGetString(errorCode));
}",0.9770114942528736
1057,"public void loadSystems(String packageName,Reflections reflections,NetworkMode netMode){
  Set<Class<?>> systems=reflections.getTypesAnnotatedWith(RegisterSystem.class);
  for (  Class<?> system : systems) {
    if (!ComponentSystem.class.isAssignableFrom(system)) {
      logger.error(""String_Node_Str"",system.getSimpleName());
      continue;
    }
    RegisterSystem registerInfo=system.getAnnotation(RegisterSystem.class);
    if (registerInfo.value().isValidFor(netMode,false)) {
      String id=packageName + ""String_Node_Str"" + system.getSimpleName();
      logger.debug(""String_Node_Str"",id);
      try {
        ComponentSystem newSystem=(ComponentSystem)system.newInstance();
        Share share=system.getAnnotation(Share.class);
        if (share != null && share.value() != null) {
          for (          Class<?> interfaceType : share.value()) {
            sharedSystems.add(interfaceType);
            CoreRegistry.put((Class<Object>)interfaceType,newSystem);
          }
        }
        register(newSystem,id);
        logger.debug(""String_Node_Str"",id);
      }
 catch (      InstantiationException e) {
        logger.error(""String_Node_Str"",id,e);
      }
catch (      IllegalAccessException e) {
        logger.error(""String_Node_Str"",id,e);
      }
    }
  }
}","public void loadSystems(String packageName,Reflections reflections,NetworkMode netMode){
  Set<Class<?>> systems=reflections.getTypesAnnotatedWith(RegisterSystem.class);
  for (  Class<?> system : systems) {
    if (!ComponentSystem.class.isAssignableFrom(system)) {
      logger.error(""String_Node_Str"",system.getSimpleName());
      continue;
    }
    RegisterSystem registerInfo=system.getAnnotation(RegisterSystem.class);
    if (registerInfo.value().isValidFor(netMode,false)) {
      String id=packageName + ""String_Node_Str"" + system.getSimpleName();
      logger.debug(""String_Node_Str"",id);
      try {
        ComponentSystem newSystem=(ComponentSystem)system.newInstance();
        Share share=system.getAnnotation(Share.class);
        if (share != null && share.value() != null) {
          for (          Class<?> interfaceType : share.value()) {
            sharedSystems.add(interfaceType);
            CoreRegistry.put((Class<Object>)interfaceType,newSystem);
          }
        }
        register(newSystem,id);
        logger.debug(""String_Node_Str"",id);
      }
 catch (      InstantiationException|IllegalAccessException e) {
        logger.error(""String_Node_Str"",id,e);
      }
    }
  }
}",0.9528
1058,"public EngineEntityManager build(ModuleManager moduleManager,NetworkSystem networkSystem){
  PojoEntityManager entityManager=new PojoEntityManager();
  TypeHandlerLibrary typeHandlerLibrary=buildTypeLibrary(entityManager);
  EntitySystemLibrary library=new EntitySystemLibraryImpl(typeHandlerLibrary);
  CoreRegistry.put(EntitySystemLibrary.class,library);
  CoreRegistry.put(ComponentLibrary.class,library.getComponentLibrary());
  CoreRegistry.put(EventLibrary.class,library.getEventLibrary());
  entityManager.setEntitySystemLibrary(library);
  PrefabManager prefabManager=new PojoPrefabManager(library.getComponentLibrary());
  entityManager.setPrefabManager(prefabManager);
  CoreRegistry.put(PrefabManager.class,prefabManager);
  entityManager.setEventSystem(new EventSystemImpl(library.getEventLibrary(),networkSystem));
  CoreRegistry.put(EntityManager.class,entityManager);
  CoreRegistry.put(EventSystem.class,entityManager.getEventSystem());
  registerComponents(library.getComponentLibrary(),moduleManager);
  registerEvents(entityManager.getEventSystem(),moduleManager);
  return entityManager;
}","public EngineEntityManager build(ModuleManager moduleManager,NetworkSystem networkSystem){
  PojoEntityManager entityManager=new PojoEntityManager();
  TypeHandlerLibrary typeHandlerLibrary=buildTypeLibrary(entityManager);
  EntitySystemLibrary library=new EntitySystemLibraryImpl(typeHandlerLibrary);
  CoreRegistry.put(EntitySystemLibrary.class,library);
  CoreRegistry.put(ComponentLibrary.class,library.getComponentLibrary());
  CoreRegistry.put(EventLibrary.class,library.getEventLibrary());
  entityManager.setEntitySystemLibrary(library);
  PrefabManager prefabManager=new PojoPrefabManager();
  entityManager.setPrefabManager(prefabManager);
  CoreRegistry.put(PrefabManager.class,prefabManager);
  entityManager.setEventSystem(new EventSystemImpl(library.getEventLibrary(),networkSystem));
  CoreRegistry.put(EntityManager.class,entityManager);
  CoreRegistry.put(EventSystem.class,entityManager.getEventSystem());
  registerComponents(library.getComponentLibrary(),moduleManager);
  registerEvents(entityManager.getEventSystem(),moduleManager);
  return entityManager;
}",0.6697121973503883
1059,"@ReceiveEvent(components={ScrewdriverComponent.class}) public void rotateGate(ActivateEvent event,EntityRef screwdriver){
  final EntityRef target=event.getTarget();
  if (target.hasComponent(SignalGateComponent.class)) {
    final Vector3i targetLocation=new Vector3i(event.getTargetLocation());
    final Block block=worldProvider.getBlock(targetLocation);
    final BlockFamily blockFamily=block.getBlockFamily();
    if (blockFamily instanceof OneCrucialSideFamily) {
      final OneCrucialSideFamily gateBlockFamily=(OneCrucialSideFamily)blockFamily;
      final Side currentSide=gateBlockFamily.getBlockSide(block);
      final Side newSide=sideOrder.get(currentSide);
      if (worldProvider.setBlock(targetLocation,gateBlockFamily.getBlockForSide(newSide),block)) {
        logger.info(""String_Node_Str"");
        final EntityRef gateEntity=blockEntityRegistry.getBlockEntityAt(targetLocation);
        final SignalProducerComponent signalProducer=gateEntity.getComponent(SignalProducerComponent.class);
        gateEntity.removeComponent(SignalProducerComponent.class);
        final SignalConsumerComponent signalConsumer=gateEntity.getComponent(SignalConsumerComponent.class);
        gateEntity.removeComponent(SignalConsumerComponent.class);
        final byte newSideBit=SideBitFlag.getSide(newSide);
        signalProducer.connectionSides=newSideBit;
        signalConsumer.connectionSides=(byte)(63 - newSideBit);
        gateEntity.saveComponent(signalProducer);
        gateEntity.saveComponent(signalConsumer);
        if (newSide == Side.FRONT) {
          gateEntity.removeComponent(SignalGateRotatedComponent.class);
        }
 else {
          gateEntity.addComponent(new SignalGateRotatedComponent());
        }
      }
    }
  }
}","@ReceiveEvent(components={ScrewdriverComponent.class}) public void rotateGate(ActivateEvent event,EntityRef screwdriver){
  final EntityRef target=event.getTarget();
  if (target.hasComponent(SignalGateComponent.class)) {
    final Vector3i targetLocation=new Vector3i(event.getTargetLocation());
    final Block block=worldProvider.getBlock(targetLocation);
    final BlockFamily blockFamily=block.getBlockFamily();
    if (blockFamily instanceof OneCrucialSideFamily) {
      final OneCrucialSideFamily gateBlockFamily=(OneCrucialSideFamily)blockFamily;
      final Side currentSide=gateBlockFamily.getBlockSide(block);
      final Side newSide=sideOrder.get(currentSide);
      if (worldProvider.setBlock(targetLocation,gateBlockFamily.getBlockForSide(newSide),block)) {
        final EntityRef gateEntity=blockEntityRegistry.getBlockEntityAt(targetLocation);
        final SignalProducerComponent signalProducer=gateEntity.getComponent(SignalProducerComponent.class);
        final SignalConsumerComponent signalConsumer=gateEntity.getComponent(SignalConsumerComponent.class);
        signalConsumer.connectionSides=0;
        gateEntity.saveComponent(signalConsumer);
        final byte newSideBit=SideBitFlag.getSide(newSide);
        signalProducer.connectionSides=newSideBit;
        signalConsumer.connectionSides=(byte)(63 - newSideBit);
        gateEntity.saveComponent(signalProducer);
        gateEntity.saveComponent(signalConsumer);
        if (newSide == Side.FRONT) {
          gateEntity.removeComponent(SignalGateRotatedComponent.class);
        }
 else         if (!gateEntity.hasComponent(SignalGateRotatedComponent.class)) {
          gateEntity.addComponent(new SignalGateRotatedComponent());
        }
      }
    }
  }
}",0.8611428571428571
1060,"@ReceiveEvent(components={BlockComponent.class,SignalTimeDelayComponent.class}) public void configureTimeDelay(SetSignalDelayEvent event,EntityRef entity){
  SignalTimeDelayComponent timeDelayComponent=entity.getComponent(SignalTimeDelayComponent.class);
  timeDelayComponent.delaySetting=event.getTime();
  entity.saveComponent(timeDelayComponent);
  if (timeDelayComponent.delaySetting == 1000) {
    entity.removeComponent(SignalTimeDelayModifiedComponent.class);
  }
 else {
    entity.saveComponent(new SignalTimeDelayModifiedComponent());
  }
}","@ReceiveEvent(components={BlockComponent.class,SignalTimeDelayComponent.class}) public void configureTimeDelay(SetSignalDelayEvent event,EntityRef entity){
  SignalTimeDelayComponent timeDelayComponent=entity.getComponent(SignalTimeDelayComponent.class);
  timeDelayComponent.delaySetting=event.getTime();
  entity.saveComponent(timeDelayComponent);
  if (timeDelayComponent.delaySetting == 1000) {
    entity.removeComponent(SignalTimeDelayModifiedComponent.class);
  }
 else {
    entity.addComponent(new SignalTimeDelayModifiedComponent());
  }
}",0.9936305732484076
1061,"private void delayGateSignalChangeIfNeeded(EntityRef entity){
  if (!entity.hasComponent(SignalDelayedActionComponent.class)) {
    SignalDelayedActionComponent delayedAction=new SignalDelayedActionComponent();
    long whenToLookAt;
    final ImmutableBlockLocation location=new ImmutableBlockLocation(entity.getComponent(BlockComponent.class).getPosition());
    if (gateLastSignalChangeTime.containsKey(location)) {
      whenToLookAt=gateLastSignalChangeTime.get(location) + GATE_MINIMUM_SIGNAL_CHANGE_INTERVAL;
    }
 else {
      whenToLookAt=worldProvider.getTime();
    }
    delayedAction.executeTime=whenToLookAt;
    entity.saveComponent(delayedAction);
  }
}","private void delayGateSignalChangeIfNeeded(EntityRef entity){
  if (!entity.hasComponent(SignalDelayedActionComponent.class)) {
    SignalDelayedActionComponent delayedAction=new SignalDelayedActionComponent();
    long whenToLookAt;
    final ImmutableBlockLocation location=new ImmutableBlockLocation(entity.getComponent(BlockComponent.class).getPosition());
    if (gateLastSignalChangeTime.containsKey(location)) {
      whenToLookAt=gateLastSignalChangeTime.get(location) + GATE_MINIMUM_SIGNAL_CHANGE_INTERVAL;
    }
 else {
      whenToLookAt=worldProvider.getTime();
    }
    delayedAction.executeTime=whenToLookAt;
    entity.addComponent(delayedAction);
  }
}",0.9947722180731888
1062,"private boolean startProducingSignal(EntityRef entity,int signalStrength){
  final SignalProducerComponent producer=entity.getComponent(SignalProducerComponent.class);
  if (producer.signalStrength != signalStrength) {
    producer.signalStrength=signalStrength;
    entity.saveComponent(producer);
    entity.saveComponent(new SignalProducerModifiedComponent());
    return true;
  }
  return false;
}","private boolean startProducingSignal(EntityRef entity,int signalStrength){
  final SignalProducerComponent producer=entity.getComponent(SignalProducerComponent.class);
  if (producer.signalStrength != signalStrength) {
    producer.signalStrength=signalStrength;
    entity.saveComponent(producer);
    entity.addComponent(new SignalProducerModifiedComponent());
    return true;
  }
  return false;
}",0.9912826899128268
1063,"private void signalChangedForDelayOffGate(EntityRef entity,SignalConsumerStatusComponent consumerStatusComponent){
  SignalTimeDelayComponent delay=entity.getComponent(SignalTimeDelayComponent.class);
  if (consumerStatusComponent.hasSignal) {
    entity.removeComponent(SignalDelayedActionComponent.class);
    startProducingSignal(entity,-1);
  }
 else {
    SignalDelayedActionComponent delayedAction=new SignalDelayedActionComponent();
    delayedAction.executeTime=worldProvider.getTime() + delay.delaySetting;
    entity.saveComponent(delayedAction);
  }
}","private void signalChangedForDelayOffGate(EntityRef entity,SignalConsumerStatusComponent consumerStatusComponent){
  SignalTimeDelayComponent delay=entity.getComponent(SignalTimeDelayComponent.class);
  if (consumerStatusComponent.hasSignal) {
    entity.removeComponent(SignalDelayedActionComponent.class);
    startProducingSignal(entity,-1);
  }
 else {
    SignalDelayedActionComponent delayedAction=new SignalDelayedActionComponent();
    delayedAction.executeTime=worldProvider.getTime() + delay.delaySetting;
    entity.addComponent(delayedAction);
  }
}",0.993766696349065
1064,"private void signalChangedForDelayOnGate(EntityRef entity,SignalConsumerStatusComponent consumerStatusComponent){
  SignalTimeDelayComponent delay=entity.getComponent(SignalTimeDelayComponent.class);
  if (consumerStatusComponent.hasSignal) {
    SignalDelayedActionComponent delayedAction=new SignalDelayedActionComponent();
    delayedAction.executeTime=worldProvider.getTime() + delay.delaySetting;
    entity.saveComponent(delayedAction);
  }
 else {
    entity.removeComponent(SignalDelayedActionComponent.class);
    stopProducingSignal(entity);
  }
}","private void signalChangedForDelayOnGate(EntityRef entity,SignalConsumerStatusComponent consumerStatusComponent){
  SignalTimeDelayComponent delay=entity.getComponent(SignalTimeDelayComponent.class);
  if (consumerStatusComponent.hasSignal) {
    SignalDelayedActionComponent delayedAction=new SignalDelayedActionComponent();
    delayedAction.executeTime=worldProvider.getTime() + delay.delaySetting;
    entity.addComponent(delayedAction);
  }
 else {
    entity.removeComponent(SignalDelayedActionComponent.class);
    stopProducingSignal(entity);
  }
}",0.7996406109613656
1065,"@Override public void update(float delta){
  PerformanceMonitor.startActivity(""String_Node_Str"");
  processOffThreadChanges();
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  for (  EntityRef entity : temporaryBlockEntities) {
    cleanUpTemporaryEntity(entity);
  }
  temporaryBlockEntities.clear();
  PerformanceMonitor.endActivity();
}","@Override public void update(float delta){
  PerformanceMonitor.startActivity(""String_Node_Str"");
  processOffThreadChanges();
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  List<EntityRef> toRemove=Lists.newArrayList(temporaryBlockEntities);
  temporaryBlockEntities.clear();
  for (  EntityRef entity : toRemove) {
    cleanUpTemporaryEntity(entity);
  }
  PerformanceMonitor.endActivity();
}",0.787363304981774
1066,"Diamond3iIterator(Vector3i origin,int maxDistance,int startDistance){
  this(origin,maxDistance);
  this.level=startDistance;
  x=-level;
}","Diamond3iIterator(Vector3i origin,int maxDistance,int startDistance){
  this(origin,maxDistance);
  this.level=startDistance + 1;
  x=-level;
}",0.9858156028368794
1067,"private Region3i clearLight(int x,int y,int z,int oldLightLevel,Block type){
  int checkExtent=(oldLightLevel > 0) ? oldLightLevel - 1 : 0;
  List<Vector3i> lightSources=Lists.newArrayList();
  Region3i region=Region3i.createFromCenterExtents(new Vector3i(x,y,z),checkExtent);
  for (  Vector3i pos : Diamond3iIterator.iterate(new Vector3i(x,y,z),checkExtent + 1)) {
    byte lum=chunkView.getBlock(pos).getLuminance();
    chunkView.setLight(pos,lum);
    if (lum > 1) {
      lightSources.add(pos);
    }
  }
  for (  Vector3i pos : lightSources) {
    byte lightLevel=chunkView.getLight(pos);
    if (lightLevel > 1) {
      region=Region3i.createEncompassing(region,pushLight(pos.x,pos.y,pos.z,lightLevel));
    }
  }
  for (  Vector3i pos : Diamond3iIterator.iterateAtDistance(new Vector3i(x,y,z),checkExtent + 1)) {
    byte lightLevel=chunkView.getLight(pos);
    lightLevel=pullLight(pos.x,pos.y,pos.z,lightLevel,type);
    if (lightLevel > 1) {
      pushLight(pos.x,pos.y,pos.z,lightLevel);
    }
  }
  return region;
}","private Region3i clearLight(int x,int y,int z,int oldLightLevel,Block type){
  int checkExtent=(oldLightLevel > 0) ? oldLightLevel - 1 : 0;
  List<Vector3i> lightSources=Lists.newArrayList();
  Region3i region=Region3i.createFromCenterExtents(new Vector3i(x,y,z),checkExtent);
  for (  Vector3i pos : Diamond3iIterator.iterate(new Vector3i(x,y,z),checkExtent)) {
    byte lum=chunkView.getBlock(pos).getLuminance();
    chunkView.setLight(pos,lum);
    if (lum > 1) {
      lightSources.add(pos);
    }
  }
  for (  Vector3i pos : lightSources) {
    byte lightLevel=chunkView.getLight(pos);
    if (lightLevel > 1) {
      region=Region3i.createEncompassing(region,pushLight(pos.x,pos.y,pos.z,lightLevel));
    }
  }
  for (  Vector3i pos : Diamond3iIterator.iterateAtDistance(new Vector3i(x,y,z),checkExtent + 1)) {
    byte lightLevel=chunkView.getLight(pos);
    lightLevel=pullLight(pos.x,pos.y,pos.z,lightLevel,type);
    if (lightLevel > 1) {
      pushLight(pos.x,pos.y,pos.z,lightLevel);
    }
  }
  return region;
}",0.9980525803310614
1068,"private void localRecalculateSunlightAround(int x,int y,int z,int oldLightLevel){
  for (  Vector3i pos : Diamond3iIterator.iterate(new Vector3i(x,y,z),oldLightLevel)) {
    chunkView.setSunlight(pos,(byte)0);
  }
  for (  Vector3i pos : Diamond3iIterator.iterateAtDistance(new Vector3i(x,y,z),oldLightLevel + 1)) {
    byte lightLevel=chunkView.getSunlight(pos);
    if (lightLevel > 1) {
      pushSunlight(pos.x,pos.y,pos.z,lightLevel);
    }
  }
}","private void localRecalculateSunlightAround(int x,int y,int z,int oldLightLevel){
  for (  Vector3i pos : Diamond3iIterator.iterate(new Vector3i(x,y,z),oldLightLevel - 1)) {
    chunkView.setSunlight(pos,(byte)0);
  }
  for (  Vector3i pos : Diamond3iIterator.iterateAtDistance(new Vector3i(x,y,z),oldLightLevel)) {
    byte lightLevel=chunkView.getSunlight(pos);
    if (lightLevel > 1) {
      pushSunlight(pos.x,pos.y,pos.z,lightLevel);
    }
  }
}",0.7605321507760532
1069,"@Test public void twoDistanceIteration(){
  Iterator<Vector3i> iter=new Diamond3iIterator(Vector3i.zero(),2);
  Set<Vector3i> expected=Sets.newHashSet(Vector3i.zero(),new Vector3i(1,0,0),new Vector3i(-1,0,0),new Vector3i(0,1,0),new Vector3i(0,-1,0),new Vector3i(0,0,1),new Vector3i(0,0,-1));
  while (iter.hasNext()) {
    Vector3i next=iter.next();
    assertTrue(""String_Node_Str"" + next,expected.remove(next));
  }
  assertTrue(""String_Node_Str"" + expected,expected.isEmpty());
}","@Test public void twoDistanceIteration(){
  Set<Vector3i> iter=Sets.newHashSet(Diamond3iIterator.iterate(Vector3i.zero(),2));
  assertEquals(25,iter.size());
  for (  Vector3i pos : iter) {
    assertTrue(pos.gridDistance(new Vector3i()) <= 2);
  }
}",0.2322404371584699
1070,"@Test public void threeDistanceOnlyIteration(){
  Iterator<Vector3i> iter=new Diamond3iIterator(Vector3i.zero(),4,3);
  while (iter.hasNext()) {
    Vector3i next=iter.next();
    assertEquals(3,Vector3i.zero().gridDistance(next));
  }
}","@Test public void threeDistanceOnlyIteration(){
  Set<Vector3i> iter=Sets.newHashSet(Diamond3iIterator.iterate(Vector3i.zero(),3));
  assertEquals(63,iter.size());
  for (  Vector3i pos : iter) {
    assertTrue(pos.gridDistance(new Vector3i()) <= 3);
  }
}",0.4908722109533469
1071,"@Test public void oneDistanceIteration(){
  Iterator<Vector3i> iter=new Diamond3iIterator(Vector3i.zero(),1);
  assertEquals(Lists.newArrayList(Vector3i.zero()),Lists.newArrayList(iter));
}","@Test public void oneDistanceIteration(){
  Iterator<Vector3i> iter=new Diamond3iIterator(Vector3i.zero(),1);
  Set<Vector3i> expected=Sets.newHashSet(Vector3i.zero(),new Vector3i(1,0,0),new Vector3i(-1,0,0),new Vector3i(0,1,0),new Vector3i(0,-1,0),new Vector3i(0,0,1),new Vector3i(0,0,-1));
  while (iter.hasNext()) {
    Vector3i next=iter.next();
    assertTrue(""String_Node_Str"" + next,expected.remove(next));
  }
  assertTrue(""String_Node_Str"" + expected,expected.isEmpty());
}",0.3546944858420268
1072,"@Test public void zeroDistanceIteration(){
  Iterator<Vector3i> iter=new Diamond3iIterator(Vector3i.zero(),0);
  assertFalse(iter.hasNext());
}","@Test public void zeroDistanceIteration(){
  Iterator<Vector3i> iter=new Diamond3iIterator(Vector3i.zero(),0);
  assertEquals(Lists.newArrayList(Vector3i.zero()),Lists.newArrayList(iter));
}",0.7987987987987988
1073,"@Override public void update(float delta){
  PerformanceMonitor.startActivity(""String_Node_Str"");
  processOffThreadChanges();
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  for (  EntityRef entity : temporaryBlockEntities) {
    cleanUpTemporaryEntity(entity);
  }
  temporaryBlockEntities.clear();
  PerformanceMonitor.endActivity();
}","@Override public void update(float delta){
  PerformanceMonitor.startActivity(""String_Node_Str"");
  processOffThreadChanges();
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  List<EntityRef> toRemove=Lists.newArrayList(temporaryBlockEntities);
  temporaryBlockEntities.clear();
  for (  EntityRef entity : toRemove) {
    cleanUpTemporaryEntity(entity);
  }
  PerformanceMonitor.endActivity();
}",0.787363304981774
1074,"Diamond3iIterator(Vector3i origin,int maxDistance,int startDistance){
  this(origin,maxDistance);
  this.level=startDistance;
  x=-level;
}","Diamond3iIterator(Vector3i origin,int maxDistance,int startDistance){
  this(origin,maxDistance);
  this.level=startDistance + 1;
  x=-level;
}",0.9858156028368794
1075,"private Region3i clearLight(int x,int y,int z,int oldLightLevel,Block type){
  int checkExtent=(oldLightLevel > 0) ? oldLightLevel - 1 : 0;
  List<Vector3i> lightSources=Lists.newArrayList();
  Region3i region=Region3i.createFromCenterExtents(new Vector3i(x,y,z),checkExtent);
  for (  Vector3i pos : Diamond3iIterator.iterate(new Vector3i(x,y,z),checkExtent + 1)) {
    byte lum=chunkView.getBlock(pos).getLuminance();
    chunkView.setLight(pos,lum);
    if (lum > 1) {
      lightSources.add(pos);
    }
  }
  for (  Vector3i pos : lightSources) {
    byte lightLevel=chunkView.getLight(pos);
    if (lightLevel > 1) {
      region=Region3i.createEncompassing(region,pushLight(pos.x,pos.y,pos.z,lightLevel));
    }
  }
  for (  Vector3i pos : Diamond3iIterator.iterateAtDistance(new Vector3i(x,y,z),checkExtent + 1)) {
    byte lightLevel=chunkView.getLight(pos);
    lightLevel=pullLight(pos.x,pos.y,pos.z,lightLevel,type);
    if (lightLevel > 1) {
      pushLight(pos.x,pos.y,pos.z,lightLevel);
    }
  }
  return region;
}","private Region3i clearLight(int x,int y,int z,int oldLightLevel,Block type){
  int checkExtent=(oldLightLevel > 0) ? oldLightLevel - 1 : 0;
  List<Vector3i> lightSources=Lists.newArrayList();
  Region3i region=Region3i.createFromCenterExtents(new Vector3i(x,y,z),checkExtent);
  for (  Vector3i pos : Diamond3iIterator.iterate(new Vector3i(x,y,z),checkExtent)) {
    byte lum=chunkView.getBlock(pos).getLuminance();
    chunkView.setLight(pos,lum);
    if (lum > 1) {
      lightSources.add(pos);
    }
  }
  for (  Vector3i pos : lightSources) {
    byte lightLevel=chunkView.getLight(pos);
    if (lightLevel > 1) {
      region=Region3i.createEncompassing(region,pushLight(pos.x,pos.y,pos.z,lightLevel));
    }
  }
  for (  Vector3i pos : Diamond3iIterator.iterateAtDistance(new Vector3i(x,y,z),checkExtent + 1)) {
    byte lightLevel=chunkView.getLight(pos);
    lightLevel=pullLight(pos.x,pos.y,pos.z,lightLevel,type);
    if (lightLevel > 1) {
      pushLight(pos.x,pos.y,pos.z,lightLevel);
    }
  }
  return region;
}",0.9980525803310614
1076,"private void localRecalculateSunlightAround(int x,int y,int z,int oldLightLevel){
  for (  Vector3i pos : Diamond3iIterator.iterate(new Vector3i(x,y,z),oldLightLevel)) {
    chunkView.setSunlight(pos,(byte)0);
  }
  for (  Vector3i pos : Diamond3iIterator.iterateAtDistance(new Vector3i(x,y,z),oldLightLevel + 1)) {
    byte lightLevel=chunkView.getSunlight(pos);
    if (lightLevel > 1) {
      pushSunlight(pos.x,pos.y,pos.z,lightLevel);
    }
  }
}","private void localRecalculateSunlightAround(int x,int y,int z,int oldLightLevel){
  for (  Vector3i pos : Diamond3iIterator.iterate(new Vector3i(x,y,z),oldLightLevel - 1)) {
    chunkView.setSunlight(pos,(byte)0);
  }
  for (  Vector3i pos : Diamond3iIterator.iterateAtDistance(new Vector3i(x,y,z),oldLightLevel)) {
    byte lightLevel=chunkView.getSunlight(pos);
    if (lightLevel > 1) {
      pushSunlight(pos.x,pos.y,pos.z,lightLevel);
    }
  }
}",0.7605321507760532
1077,"@Test public void twoDistanceIteration(){
  Iterator<Vector3i> iter=new Diamond3iIterator(Vector3i.zero(),2);
  Set<Vector3i> expected=Sets.newHashSet(Vector3i.zero(),new Vector3i(1,0,0),new Vector3i(-1,0,0),new Vector3i(0,1,0),new Vector3i(0,-1,0),new Vector3i(0,0,1),new Vector3i(0,0,-1));
  while (iter.hasNext()) {
    Vector3i next=iter.next();
    assertTrue(""String_Node_Str"" + next,expected.remove(next));
  }
  assertTrue(""String_Node_Str"" + expected,expected.isEmpty());
}","@Test public void twoDistanceIteration(){
  Set<Vector3i> iter=Sets.newHashSet(Diamond3iIterator.iterate(Vector3i.zero(),2));
  assertEquals(25,iter.size());
  for (  Vector3i pos : iter) {
    assertTrue(pos.gridDistance(new Vector3i()) <= 2);
  }
}",0.2322404371584699
1078,"@Test public void threeDistanceOnlyIteration(){
  Iterator<Vector3i> iter=new Diamond3iIterator(Vector3i.zero(),4,3);
  while (iter.hasNext()) {
    Vector3i next=iter.next();
    assertEquals(3,Vector3i.zero().gridDistance(next));
  }
}","@Test public void threeDistanceOnlyIteration(){
  Set<Vector3i> iter=Sets.newHashSet(Diamond3iIterator.iterate(Vector3i.zero(),3));
  assertEquals(63,iter.size());
  for (  Vector3i pos : iter) {
    assertTrue(pos.gridDistance(new Vector3i()) <= 3);
  }
}",0.4908722109533469
1079,"@Test public void oneDistanceIteration(){
  Iterator<Vector3i> iter=new Diamond3iIterator(Vector3i.zero(),1);
  assertEquals(Lists.newArrayList(Vector3i.zero()),Lists.newArrayList(iter));
}","@Test public void oneDistanceIteration(){
  Iterator<Vector3i> iter=new Diamond3iIterator(Vector3i.zero(),1);
  Set<Vector3i> expected=Sets.newHashSet(Vector3i.zero(),new Vector3i(1,0,0),new Vector3i(-1,0,0),new Vector3i(0,1,0),new Vector3i(0,-1,0),new Vector3i(0,0,1),new Vector3i(0,0,-1));
  while (iter.hasNext()) {
    Vector3i next=iter.next();
    assertTrue(""String_Node_Str"" + next,expected.remove(next));
  }
  assertTrue(""String_Node_Str"" + expected,expected.isEmpty());
}",0.3546944858420268
1080,"@Test public void zeroDistanceIteration(){
  Iterator<Vector3i> iter=new Diamond3iIterator(Vector3i.zero(),0);
  assertFalse(iter.hasNext());
}","@Test public void zeroDistanceIteration(){
  Iterator<Vector3i> iter=new Diamond3iIterator(Vector3i.zero(),0);
  assertEquals(Lists.newArrayList(Vector3i.zero()),Lists.newArrayList(iter));
}",0.7987987987987988
1081,"private void initHost(){
  loadProcesses.add(new RegisterMods(worldInfo));
  loadProcesses.add(new CacheTextures());
  loadProcesses.add(new RegisterBlocks(worldInfo));
  loadProcesses.add(new CacheBlocks());
  loadProcesses.add(new InitialiseEntitySystem());
  loadProcesses.add(new LoadPrefabs());
  loadProcesses.add(new RegisterInputSystem());
  loadProcesses.add(new RegisterSystems(netMode));
  loadProcesses.add(new InitialiseCommandSystem());
  loadProcesses.add(new InitialiseWorld(worldInfo));
  loadProcesses.add(new InitialiseSystems());
  loadProcesses.add(new LoadEntities(worldInfo));
  loadProcesses.add(new InitialiseBlockTypeEntities());
  loadProcesses.add(new CreateWorldEntity());
  if (netMode == NetworkMode.SERVER) {
    loadProcesses.add(new StartServer());
  }
  loadProcesses.add(new SetupLocalPlayer());
  loadProcesses.add(new AwaitCharacterSpawn());
  loadProcesses.add(new PrepareWorld());
}","private void initHost(){
  loadProcesses.add(new RegisterMods(worldInfo));
  loadProcesses.add(new CacheTextures());
  loadProcesses.add(new RegisterBlocks(worldInfo));
  loadProcesses.add(new CacheBlocks());
  loadProcesses.add(new InitialiseEntitySystem());
  loadProcesses.add(new LoadPrefabs());
  loadProcesses.add(new ProcessBlockPrefabs());
  loadProcesses.add(new RegisterInputSystem());
  loadProcesses.add(new RegisterSystems(netMode));
  loadProcesses.add(new InitialiseCommandSystem());
  loadProcesses.add(new InitialiseWorld(worldInfo));
  loadProcesses.add(new InitialiseSystems());
  loadProcesses.add(new LoadEntities(worldInfo));
  loadProcesses.add(new InitialiseBlockTypeEntities());
  loadProcesses.add(new CreateWorldEntity());
  if (netMode == NetworkMode.SERVER) {
    loadProcesses.add(new StartServer());
  }
  loadProcesses.add(new SetupLocalPlayer());
  loadProcesses.add(new AwaitCharacterSpawn());
  loadProcesses.add(new PrepareWorld());
}",0.9746300211416492
1082,"private void initClient(){
  loadProcesses.add(new JoinServer(worldInfo));
  loadProcesses.add(new RegisterMods(worldInfo));
  loadProcesses.add(new CacheTextures());
  loadProcesses.add(new RegisterBlocks(worldInfo));
  loadProcesses.add(new CacheBlocks());
  loadProcesses.add(new InitialiseEntitySystem());
  loadProcesses.add(new LoadPrefabs());
  loadProcesses.add(new RegisterInputSystem());
  loadProcesses.add(new RegisterSystems(netMode));
  loadProcesses.add(new InitialiseCommandSystem());
  loadProcesses.add(new InitialiseRemoteWorld(worldInfo));
  loadProcesses.add(new InitialiseSystems());
  loadProcesses.add(new SetupRemotePlayer());
  loadProcesses.add(new AwaitCharacterSpawn());
  loadProcesses.add(new PrepareWorld());
}","private void initClient(){
  loadProcesses.add(new JoinServer(worldInfo));
  loadProcesses.add(new RegisterMods(worldInfo));
  loadProcesses.add(new CacheTextures());
  loadProcesses.add(new RegisterBlocks(worldInfo));
  loadProcesses.add(new CacheBlocks());
  loadProcesses.add(new InitialiseEntitySystem());
  loadProcesses.add(new LoadPrefabs());
  loadProcesses.add(new ProcessBlockPrefabs());
  loadProcesses.add(new RegisterInputSystem());
  loadProcesses.add(new RegisterSystems(netMode));
  loadProcesses.add(new InitialiseCommandSystem());
  loadProcesses.add(new InitialiseRemoteWorld(worldInfo));
  loadProcesses.add(new InitialiseSystems());
  loadProcesses.add(new SetupRemotePlayer());
  loadProcesses.add(new AwaitCharacterSpawn());
  loadProcesses.add(new PrepareWorld());
}",0.9686684073107048
1083,"@Override public boolean step(){
  RemoteChunkProvider chunkProvider=new RemoteChunkProvider();
  WorldRenderer worldRenderer=new WorldRenderer(worldInfo,chunkProvider,CoreRegistry.get(LocalPlayerSystem.class));
  CoreRegistry.put(WorldRenderer.class,worldRenderer);
  CoreRegistry.put(WorldProvider.class,worldRenderer.getWorldProvider());
  CoreRegistry.put(LocalPlayer.class,new LocalPlayer());
  CoreRegistry.put(Camera.class,worldRenderer.getActiveCamera());
  CoreRegistry.put(BulletPhysics.class,worldRenderer.getBulletRenderer());
  CoreRegistry.get(WorldProvider.class).setTime(worldInfo.getTime());
  CoreRegistry.get(NetworkSystem.class).setRemoteWorldProvider(chunkProvider);
  return true;
}","@Override public boolean step(){
  RemoteChunkProvider chunkProvider=new RemoteChunkProvider();
  BlockManager blockManager=CoreRegistry.get(BlockManager.class);
  EntityAwareWorldProvider entityWorldProvider=new EntityAwareWorldProvider(new WorldProviderCoreImpl(worldInfo,chunkProvider,blockManager));
  WorldProvider worldProvider=new WorldProviderWrapper(entityWorldProvider);
  CoreRegistry.put(WorldProvider.class,worldProvider);
  CoreRegistry.put(BlockEntityRegistry.class,entityWorldProvider);
  CoreRegistry.get(ComponentSystemManager.class).register(entityWorldProvider,""String_Node_Str"");
  WorldRenderer worldRenderer=new WorldRenderer(worldProvider,chunkProvider,CoreRegistry.get(LocalPlayerSystem.class));
  CoreRegistry.put(WorldRenderer.class,worldRenderer);
  CoreRegistry.put(LocalPlayer.class,new LocalPlayer());
  CoreRegistry.put(Camera.class,worldRenderer.getActiveCamera());
  CoreRegistry.put(BulletPhysics.class,worldRenderer.getBulletRenderer());
  CoreRegistry.get(WorldProvider.class).setTime(worldInfo.getTime());
  CoreRegistry.get(NetworkSystem.class).setRemoteWorldProvider(chunkProvider);
  return true;
}",0.631578947368421
1084,"@Override public boolean step(){
  if (worldInfo.getSeed() == null || worldInfo.getSeed().isEmpty()) {
    FastRandom random=new FastRandom();
    worldInfo.setSeed(random.randomCharacterString(16));
  }
  logger.info(""String_Node_Str"",worldInfo.getSeed());
  ChunkGeneratorManager chunkGeneratorManager=ChunkGeneratorManagerImpl.buildChunkGenerator(Arrays.asList(worldInfo.getChunkGenerators()));
  chunkGeneratorManager.setWorldSeed(worldInfo.getSeed());
  chunkGeneratorManager.setWorldBiomeProvider(new WorldBiomeProviderImpl(worldInfo.getSeed()));
  ChunkStore chunkStore=null;
  PathManager.getInstance().setCurrentWorldTitle(worldInfo.getTitle());
  File f=new File(PathManager.getInstance().getCurrentWorldPath(),TerasologyConstants.WORLD_DATA_FILE);
  if (f.exists()) {
    try {
      chunkStore=loadChunkStore(f);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  if (chunkStore == null) {
    chunkStore=new ChunkStoreGZip();
  }
  WorldRenderer worldRenderer=new WorldRenderer(worldInfo,new LocalChunkProvider(chunkStore,chunkGeneratorManager),CoreRegistry.get(LocalPlayerSystem.class));
  CoreRegistry.put(WorldRenderer.class,worldRenderer);
  CoreRegistry.put(WorldProvider.class,worldRenderer.getWorldProvider());
  CoreRegistry.put(LocalPlayer.class,new LocalPlayer());
  CoreRegistry.put(Camera.class,worldRenderer.getActiveCamera());
  CoreRegistry.put(BulletPhysics.class,worldRenderer.getBulletRenderer());
  CoreRegistry.get(WorldProvider.class).setTime(worldInfo.getTime());
  return true;
}","@Override public boolean step(){
  if (worldInfo.getSeed() == null || worldInfo.getSeed().isEmpty()) {
    FastRandom random=new FastRandom();
    worldInfo.setSeed(random.randomCharacterString(16));
  }
  logger.info(""String_Node_Str"",worldInfo.getSeed());
  ChunkGeneratorManager chunkGeneratorManager=ChunkGeneratorManagerImpl.buildChunkGenerator(Arrays.asList(worldInfo.getChunkGenerators()));
  chunkGeneratorManager.setWorldSeed(worldInfo.getSeed());
  chunkGeneratorManager.setWorldBiomeProvider(new WorldBiomeProviderImpl(worldInfo.getSeed()));
  ChunkStore chunkStore=null;
  PathManager.getInstance().setCurrentWorldTitle(worldInfo.getTitle());
  File f=new File(PathManager.getInstance().getCurrentWorldPath(),TerasologyConstants.WORLD_DATA_FILE);
  if (f.exists()) {
    try {
      chunkStore=loadChunkStore(f);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  if (chunkStore == null) {
    chunkStore=new ChunkStoreGZip();
  }
  BlockManager blockManager=CoreRegistry.get(BlockManager.class);
  LocalChunkProvider chunkProvider=new LocalChunkProvider(chunkStore,chunkGeneratorManager);
  EntityAwareWorldProvider entityWorldProvider=new EntityAwareWorldProvider(new WorldProviderCoreImpl(worldInfo,chunkProvider,blockManager));
  WorldProvider worldProvider=new WorldProviderWrapper(entityWorldProvider);
  CoreRegistry.put(WorldProvider.class,worldProvider);
  chunkProvider.setBlockEntityRegistry(entityWorldProvider);
  CoreRegistry.put(BlockEntityRegistry.class,entityWorldProvider);
  CoreRegistry.get(ComponentSystemManager.class).register(entityWorldProvider,""String_Node_Str"");
  WorldRenderer worldRenderer=new WorldRenderer(worldProvider,chunkProvider,CoreRegistry.get(LocalPlayerSystem.class));
  CoreRegistry.put(WorldRenderer.class,worldRenderer);
  CoreRegistry.put(LocalPlayer.class,new LocalPlayer());
  CoreRegistry.put(Camera.class,worldRenderer.getActiveCamera());
  CoreRegistry.put(BulletPhysics.class,worldRenderer.getBulletRenderer());
  CoreRegistry.get(WorldProvider.class).setTime(worldInfo.getTime());
  return true;
}",0.5901369863013699
1085,"public boolean isForceBlockActive(){
  return forceBlockActive;
}","/** 
 * @return Whether this component forces a block active
 */
public boolean isForceBlockActive(){
  return forceBlockActive;
}",0.6666666666666666
1086,"public boolean isReplicatedFromOwner(){
  return replicatedFromOwner;
}","/** 
 * @return Whether this component replicates any fields from owner to server
 */
public boolean isReplicatedFromOwner(){
  return replicatedFromOwner;
}",0.6228070175438597
1087,"public boolean isReplicated(){
  return replicated;
}","/** 
 * @return Whether this component needs to be replicated
 */
public boolean isReplicated(){
  return replicated;
}",0.6162790697674418
1088,"public T clone(Component component){
  if (getType().isInstance(component)) {
    return super.clone(getType().cast(component));
  }
  return null;
}","/** 
 * @param component
 * @return A clone of the given instance of this component, or null if the component does not belong to this metadata
 */
public T clone(Component component){
  if (getType().isInstance(component)) {
    return super.clone(getType().cast(component));
  }
  return null;
}",0.6696629213483146
1089,"public boolean isRetainUnalteredOnBlockChange(){
  return retainUnalteredOnBlockChange;
}","/** 
 * @return Whether this component should be retained unaltered on block change
 */
public boolean isRetainUnalteredOnBlockChange(){
  return retainUnalteredOnBlockChange;
}",0.6691729323308271
1090,"public ComponentMetadata(Class<T> simpleClass,String... names) throws NoSuchMethodException {
  super(simpleClass,names);
  replicated=simpleClass.getAnnotation(Replicate.class) != null;
  ForceBlockActive forceBlockActiveAnnotation=simpleClass.getAnnotation(ForceBlockActive.class);
  if (forceBlockActiveAnnotation != null) {
    forceBlockActive=true;
    retainUnalteredOnBlockChange=forceBlockActiveAnnotation.retainUnalteredOnBlockChange();
  }
}","public ComponentMetadata(Class<T> simpleClass,String... names) throws NoSuchMethodException {
  super(simpleClass,names);
  replicated=simpleClass.getAnnotation(Replicate.class) != null;
  blockLifecycleEventsRequired=simpleClass.getAnnotation(RequiresBlockLifecycleEvents.class) != null;
  ForceBlockActive forceBlockActiveAnnotation=simpleClass.getAnnotation(ForceBlockActive.class);
  if (forceBlockActiveAnnotation != null) {
    forceBlockActive=true;
    retainUnalteredOnBlockChange=forceBlockActiveAnnotation.retainUnalteredOnBlockChange();
  }
}",0.8986083499005965
1091,"public boolean isReferenceOwner(){
  return referenceOwner;
}","/** 
 * @return Whether this component owns any references
 */
public boolean isReferenceOwner(){
  return referenceOwner;
}",0.6594594594594595
1092,"/** 
 * Initializes a new (local) world for the single player mode.
 * @param worldInfo Information describing the world
 */
public WorldRenderer(WorldInfo worldInfo,ChunkProvider chunkProvider,LocalPlayerSystem localPlayerSystem){
  this.chunkProvider=chunkProvider;
  BlockManager blockManager=CoreRegistry.get(BlockManager.class);
  EntityAwareWorldProvider entityWorldProvider=new EntityAwareWorldProvider(new WorldProviderCoreImpl(worldInfo,this.chunkProvider,blockManager));
  CoreRegistry.put(BlockEntityRegistry.class,entityWorldProvider);
  CoreRegistry.get(ComponentSystemManager.class).register(entityWorldProvider,""String_Node_Str"");
  worldProvider=new WorldProviderWrapper(entityWorldProvider);
  bulletPhysics=new BulletPhysics(worldProvider);
  chunkTesselator=new ChunkTessellator(worldProvider.getBiomeProvider());
  skysphere=new Skysphere(this);
  chunkUpdateManager=new ChunkUpdateManager(chunkTesselator,worldProvider);
  worldTimeEventManager=new WorldTimeEventManager(worldProvider);
  blockGrid=new BlockGrid();
  localPlayerSystem.setPlayerCamera(defaultCamera);
  systemManager=CoreRegistry.get(ComponentSystemManager.class);
  audioManager=CoreRegistry.get(AudioManager.class);
  initTimeEvents();
}","/** 
 * Initializes a new (local) world for the single player mode.
 */
public WorldRenderer(WorldProvider worldProvider,ChunkProvider chunkProvider,LocalPlayerSystem localPlayerSystem){
  this.chunkProvider=chunkProvider;
  this.worldProvider=worldProvider;
  bulletPhysics=new BulletPhysics(worldProvider);
  chunkTesselator=new ChunkTessellator(worldProvider.getBiomeProvider());
  skysphere=new Skysphere(this);
  chunkUpdateManager=new ChunkUpdateManager(chunkTesselator,worldProvider);
  worldTimeEventManager=new WorldTimeEventManager(worldProvider);
  blockGrid=new BlockGrid();
  localPlayerSystem.setPlayerCamera(defaultCamera);
  systemManager=CoreRegistry.get(ComponentSystemManager.class);
  audioManager=CoreRegistry.get(AudioManager.class);
  initTimeEvents();
}",0.718562874251497
1093,"@Override public boolean setBlock(int x,int y,int z,Block type,Block oldType){
  if (Thread.currentThread().equals(mainThread)) {
    Vector3i pos=new Vector3i(x,y,z);
    EntityRef blockEntity=getBlockEntityAt(pos);
    if (super.setBlock(x,y,z,type,oldType)) {
      EntityRef regionEntity=blockRegionLookup.get(pos);
      if (regionEntity != null) {
        regionEntity.send(new OnChangedBlock(pos,type,oldType));
      }
      updateBlockEntity(blockEntity,oldType,type);
      blockEntity.send(new OnChangedBlock(new Vector3i(x,y,z),type,oldType));
      return true;
    }
  }
 else {
    if (super.setBlock(x,y,z,type,oldType)) {
      eventQueue.add(new OnChangedBlock(new Vector3i(x,y,z),type,oldType));
      return true;
    }
  }
  return false;
}","@Override public boolean setBlock(int x,int y,int z,Block type,Block oldType){
  if (Thread.currentThread().equals(mainThread)) {
    Vector3i pos=new Vector3i(x,y,z);
    EntityRef blockEntity=getBlockEntityAt(pos);
    if (super.setBlock(x,y,z,type,oldType)) {
      if (type.isKeepActive()) {
        temporaryBlockEntities.remove(blockEntity);
      }
 else       if (oldType.isKeepActive() && isTemporaryBlock(blockEntity,type)) {
        temporaryBlockEntities.add(blockEntity);
      }
      EntityRef regionEntity=blockRegionLookup.get(pos);
      if (regionEntity != null) {
        regionEntity.send(new OnChangedBlock(pos,type,oldType));
      }
      updateBlockEntity(blockEntity,oldType,type);
      blockEntity.send(new OnChangedBlock(new Vector3i(x,y,z),type,oldType));
      return true;
    }
  }
 else {
    if (super.setBlock(x,y,z,type,oldType)) {
      eventQueue.add(new OnChangedBlock(new Vector3i(x,y,z),type,oldType));
      return true;
    }
  }
  return false;
}",0.8687214611872146
1094,"public void setKeepActive(boolean keepActive){
  this.keepActive=true;
}","public void setKeepActive(boolean keepActive){
  this.keepActive=keepActive;
}",0.9333333333333332
1095,"@Override public boolean step(){
  NetworkSystem networkSystem=CoreRegistry.get(NetworkSystem.class);
  BlockManager blockManager;
  if (networkSystem.getMode().isAuthority()) {
    blockManager=new BlockManagerAuthority(worldInfo.getBlockIdMap());
    blockManager.subscribe(CoreRegistry.get(NetworkSystem.class));
  }
 else {
    blockManager=new BlockManagerClient(worldInfo.getBlockIdMap());
  }
  blockManager.buildAtlas();
  CoreRegistry.put(BlockManager.class,blockManager);
  return true;
}","@Override public boolean step(){
  NetworkSystem networkSystem=CoreRegistry.get(NetworkSystem.class);
  BlockManager blockManager;
  if (networkSystem.getMode().isAuthority()) {
    blockManager=new BlockManagerAuthority(worldInfo.getBlockIdMap());
    blockManager.subscribe(CoreRegistry.get(NetworkSystem.class));
  }
 else {
    blockManager=new BlockManagerClient(networkSystem.getServer().getInfo().getRegisterBlockFamilyList(),worldInfo.getBlockIdMap());
  }
  blockManager.buildAtlas();
  CoreRegistry.put(BlockManager.class,blockManager);
  return true;
}",0.9123468426013196
1096,"public void registerNetworkEntity(EntityRef entity){
  if (mode == NetworkMode.NONE) {
    return;
  }
  NetworkComponent netComponent=entity.getComponent(NetworkComponent.class);
  if (mode == NetworkMode.SERVER) {
    netComponent.setNetworkId(nextNetId++);
    entity.saveComponent(netComponent);
  }
  logger.debug(""String_Node_Str"",entity);
  netIdToEntityId.put(netComponent.getNetworkId(),entity.getId());
  if (mode == NetworkMode.SERVER) {
switch (netComponent.replicateMode) {
case OWNER:
      NetClient clientPlayer=getNetOwner(entity);
    if (clientPlayer != null) {
      clientPlayer.setNetInitial(netComponent.getNetworkId());
    }
  break;
default :
for (NetClient client : netClientList) {
  client.setNetInitial(netComponent.getNetworkId());
}
break;
}
if (netComponent.owner.exists()) {
ownerLookup.put(entity,netComponent.owner);
ownedLookup.put(netComponent.owner,entity);
}
}
}","public void registerNetworkEntity(EntityRef entity){
  if (mode == NetworkMode.NONE) {
    return;
  }
  NetworkComponent netComponent=entity.getComponent(NetworkComponent.class);
  if (mode == NetworkMode.SERVER) {
    netComponent.setNetworkId(nextNetId++);
    entity.saveComponent(netComponent);
  }
  logger.debug(""String_Node_Str"",entity);
  if (NULL_NET_ID != netIdToEntityId.put(netComponent.getNetworkId(),entity.getId())) {
    logger.error(""String_Node_Str"");
  }
  if (mode == NetworkMode.SERVER) {
switch (netComponent.replicateMode) {
case OWNER:
      NetClient clientPlayer=getNetOwner(entity);
    if (clientPlayer != null) {
      clientPlayer.setNetInitial(netComponent.getNetworkId());
    }
  break;
default :
for (NetClient client : netClientList) {
  client.setNetInitial(netComponent.getNetworkId());
}
break;
}
if (netComponent.owner.exists()) {
ownerLookup.put(entity,netComponent.owner);
ownedLookup.put(netComponent.owner,entity);
}
}
}",0.960342979635584
1097,"private void processNewClient(NetClient client){
  logger.info(""String_Node_Str"",client.getName());
  client.connected(entityManager,entitySerializer,eventSerializer,entitySystemLibrary);
  clientList.add(client);
  netClientList.add(client);
  clientPlayerLookup.put(client.getEntity(),client);
  sendServerInfo(client);
  connectClient(client);
  logger.info(""String_Node_Str"",client.getEntity());
  for (  EntityRef netEntity : entityManager.listEntitiesWith(NetworkComponent.class)) {
    NetworkComponent netComp=netEntity.getComponent(NetworkComponent.class);
switch (netComp.replicateMode) {
case OWNER:
      if (client.equals(getOwner(netEntity))) {
        client.setNetInitial(netComp.getNetworkId());
      }
    break;
default :
  client.setNetInitial(netComp.getNetworkId());
break;
}
}
}","private void processNewClient(NetClient client){
  logger.info(""String_Node_Str"",client.getName());
  client.connected(entityManager,entitySerializer,eventSerializer,entitySystemLibrary);
  clientList.add(client);
  netClientList.add(client);
  clientPlayerLookup.put(client.getEntity(),client);
  sendServerInfo(client);
  connectClient(client);
  logger.info(""String_Node_Str"",client.getEntity());
  for (  EntityRef netEntity : entityManager.listEntitiesWith(NetworkComponent.class)) {
    NetworkComponent netComp=netEntity.getComponent(NetworkComponent.class);
    if (netComp.getNetworkId() != NULL_NET_ID) {
switch (netComp.replicateMode) {
case OWNER:
        if (client.equals(getOwner(netEntity))) {
          client.setNetInitial(netComp.getNetworkId());
        }
      break;
default :
    client.setNetInitial(netComp.getNetworkId());
  break;
}
}
}
}",0.9622075584883024
1098,"private void sendServerInfo(NetClient client){
  NetData.ServerInfoMessage.Builder serverInfoMessageBuilder=NetData.ServerInfoMessage.newBuilder();
  WorldProvider world=CoreRegistry.get(WorldProvider.class);
  if (world != null) {
    serverInfoMessageBuilder.setTime(world.getTime());
    serverInfoMessageBuilder.setWorldName(world.getTitle());
  }
  for (  Mod mod : CoreRegistry.get(ModManager.class).getActiveMods()) {
    if (!mod.getModInfo().isServersideOnly()) {
      serverInfoMessageBuilder.addModule(NetData.ModuleInfo.newBuilder().setModuleId(mod.getModInfo().getId()).build());
    }
  }
  for (  Map.Entry<String,Byte> blockMapping : blockManager.getBlockIdMap().entrySet()) {
    serverInfoMessageBuilder.addBlockId(blockMapping.getValue());
    serverInfoMessageBuilder.addBlockName(blockMapping.getKey());
  }
  serializeComponentInfo(serverInfoMessageBuilder);
  serializeEventInfo(serverInfoMessageBuilder);
  serverInfoMessageBuilder.setClientId(client.getEntity().getComponent(NetworkComponent.class).getNetworkId());
  client.send(NetData.NetMessage.newBuilder().setTime(timer.getTimeInMs()).setServerInfo(serverInfoMessageBuilder).build());
}","private void sendServerInfo(NetClient client){
  NetData.ServerInfoMessage.Builder serverInfoMessageBuilder=NetData.ServerInfoMessage.newBuilder();
  WorldProvider world=CoreRegistry.get(WorldProvider.class);
  if (world != null) {
    serverInfoMessageBuilder.setTime(world.getTime());
    serverInfoMessageBuilder.setWorldName(world.getTitle());
  }
  for (  Mod mod : CoreRegistry.get(ModManager.class).getActiveMods()) {
    if (!mod.getModInfo().isServersideOnly()) {
      serverInfoMessageBuilder.addModule(NetData.ModuleInfo.newBuilder().setModuleId(mod.getModInfo().getId()).build());
    }
  }
  for (  Map.Entry<String,Byte> blockMapping : blockManager.getBlockIdMap().entrySet()) {
    serverInfoMessageBuilder.addBlockId(blockMapping.getValue());
    serverInfoMessageBuilder.addBlockName(blockMapping.getKey());
  }
  for (  BlockFamily registeredBlockFamily : blockManager.listRegisteredBlockFamilies()) {
    serverInfoMessageBuilder.addRegisterBlockFamily(registeredBlockFamily.getURI().toString());
  }
  serializeComponentInfo(serverInfoMessageBuilder);
  serializeEventInfo(serverInfoMessageBuilder);
  serverInfoMessageBuilder.setClientId(client.getEntity().getComponent(NetworkComponent.class).getNetworkId());
  client.send(NetData.NetMessage.newBuilder().setTime(timer.getTimeInMs()).setServerInfo(serverInfoMessageBuilder).build());
}",0.9244163039176888
1099,"@Override public void host(int port) throws HostingFailedException {
  if (mode == NetworkMode.NONE) {
    try {
      for (      EntityRef entity : entityManager.listEntitiesWith(NetworkComponent.class)) {
        registerNetworkEntity(entity);
      }
      generateSerializationTables();
      factory=new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newCachedThreadPool());
      ServerBootstrap bootstrap=new ServerBootstrap(factory);
      bootstrap.setPipelineFactory(new TerasologyServerPipelineFactory(this));
      bootstrap.setOption(""String_Node_Str"",true);
      bootstrap.setOption(""String_Node_Str"",true);
      Channel listenChannel=bootstrap.bind(new InetSocketAddress(port));
      allChannels.add(listenChannel);
      logger.info(""String_Node_Str"");
      nextNetworkTick=timer.getRawTimeInMs();
      mode=NetworkMode.SERVER;
    }
 catch (    ChannelException e) {
      if (e.getCause() instanceof BindException) {
        throw new HostingFailedException(""String_Node_Str"");
      }
 else {
        throw new HostingFailedException(""String_Node_Str"");
      }
    }
  }
}","@Override public void host(int port) throws HostingFailedException {
  if (mode == NetworkMode.NONE) {
    try {
      mode=NetworkMode.SERVER;
      for (      EntityRef entity : entityManager.listEntitiesWith(NetworkComponent.class)) {
        registerNetworkEntity(entity);
      }
      generateSerializationTables();
      factory=new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newCachedThreadPool());
      ServerBootstrap bootstrap=new ServerBootstrap(factory);
      bootstrap.setPipelineFactory(new TerasologyServerPipelineFactory(this));
      bootstrap.setOption(""String_Node_Str"",true);
      bootstrap.setOption(""String_Node_Str"",true);
      Channel listenChannel=bootstrap.bind(new InetSocketAddress(port));
      allChannels.add(listenChannel);
      logger.info(""String_Node_Str"");
      nextNetworkTick=timer.getRawTimeInMs();
    }
 catch (    ChannelException e) {
      if (e.getCause() instanceof BindException) {
        throw new HostingFailedException(""String_Node_Str"");
      }
 else {
        throw new HostingFailedException(""String_Node_Str"");
      }
    }
  }
}",0.9723707664884136
1100,"public void updateNetworkEntity(EntityRef entity){
  NetworkComponent netComponent=entity.getComponent(NetworkComponent.class);
  if (netComponent.getNetworkId() == 0) {
    return;
  }
  EntityRef lastOwnerEntity=ownerLookup.get(entity);
  if (lastOwnerEntity == null) {
    lastOwnerEntity=EntityRef.NULL;
  }
  if (!Objects.equal(lastOwnerEntity,netComponent.owner)) {
    NetClient lastOwner=getNetOwner(lastOwnerEntity);
    NetClient newOwner=getNetOwner(netComponent.owner);
    if (!Objects.equal(lastOwner,newOwner)) {
      recursiveUpdateOwnership(entity,lastOwner,newOwner);
      if (newOwner != null) {
        int id=netComponent.getNetworkId();
        for (        Component component : entity.iterateComponents()) {
          if (entitySystemLibrary.getComponentLibrary().getMetadata(component.getClass()).isReplicated()) {
            newOwner.setComponentDirty(id,component.getClass());
          }
        }
      }
    }
    if (lastOwnerEntity.exists()) {
      ownedLookup.remove(lastOwnerEntity,entity);
    }
    if (netComponent.owner.exists()) {
      ownerLookup.put(entity,netComponent.owner);
      ownedLookup.put(netComponent.owner,entity);
    }
 else {
      ownerLookup.remove(entity);
    }
  }
}","public void updateNetworkEntity(EntityRef entity){
  NetworkComponent netComponent=entity.getComponent(NetworkComponent.class);
  if (netComponent.getNetworkId() == NULL_NET_ID) {
    return;
  }
  EntityRef lastOwnerEntity=ownerLookup.get(entity);
  if (lastOwnerEntity == null) {
    lastOwnerEntity=EntityRef.NULL;
  }
  if (!Objects.equal(lastOwnerEntity,netComponent.owner)) {
    NetClient lastOwner=getNetOwner(lastOwnerEntity);
    NetClient newOwner=getNetOwner(netComponent.owner);
    if (!Objects.equal(lastOwner,newOwner)) {
      recursiveUpdateOwnership(entity,lastOwner,newOwner);
      if (newOwner != null) {
        int id=netComponent.getNetworkId();
        for (        Component component : entity.iterateComponents()) {
          if (entitySystemLibrary.getComponentLibrary().getMetadata(component.getClass()).isReplicated()) {
            newOwner.setComponentDirty(id,component.getClass());
          }
        }
      }
    }
    if (lastOwnerEntity.exists()) {
      ownedLookup.remove(lastOwnerEntity,entity);
    }
    if (netComponent.owner.exists()) {
      ownerLookup.put(entity,netComponent.owner);
      ownedLookup.put(netComponent.owner,entity);
    }
 else {
      ownerLookup.remove(entity);
    }
  }
}",0.9951534733441034
1101,"public void unregisterNetworkEntity(EntityRef entity){
  NetworkComponent netComponent=entity.getComponent(NetworkComponent.class);
  if (netComponent != null) {
    logger.debug(""String_Node_Str"",entity,netComponent.getNetworkId());
    netIdToEntityId.remove(netComponent.getNetworkId());
    if (mode == NetworkMode.SERVER) {
      for (      NetClient client : netClientList) {
        client.setNetRemoved(netComponent.getNetworkId());
      }
    }
    netComponent.setNetworkId(0);
    entity.saveComponent(netComponent);
  }
  ownerLookup.remove(entity);
}","public void unregisterNetworkEntity(EntityRef entity){
  NetworkComponent netComponent=entity.getComponent(NetworkComponent.class);
  if (netComponent != null) {
    logger.debug(""String_Node_Str"",entity,netComponent.getNetworkId());
    netIdToEntityId.remove(netComponent.getNetworkId());
    if (mode == NetworkMode.SERVER) {
      for (      NetClient client : netClientList) {
        client.setNetRemoved(netComponent.getNetworkId());
      }
    }
    netComponent.setNetworkId(NULL_NET_ID);
    entity.saveComponent(netComponent);
  }
  ownerLookup.remove(entity);
}",0.9894551845342706
1102,"@Override public void shutdown(){
  if (mode != NetworkMode.NONE) {
    allChannels.close().awaitUninterruptibly();
    factory.releaseExternalResources();
  }
  processPendingDisconnects();
  for (  Client client : clientList) {
    processRemovedClient(client);
  }
  mode=NetworkMode.NONE;
  server=null;
  nextNetId=1;
  netIdToEntityId.clear();
  if (this.entityManager != null) {
    this.entityManager.unsubscribe(this);
  }
  entityManager=null;
  entitySystemLibrary=null;
  eventSerializer=null;
  entitySerializer=null;
  clientList.clear();
  netClientList.clear();
  logger.info(""String_Node_Str"");
}","@Override public void shutdown(){
  if (mode != NetworkMode.NONE) {
    allChannels.close().awaitUninterruptibly();
    factory.releaseExternalResources();
  }
  processPendingDisconnects();
  for (  Client client : clientList) {
    processRemovedClient(client);
  }
  mode=NetworkMode.NONE;
  server=null;
  nextNetId=1;
  netIdToEntityId.clear();
  if (this.entityManager != null) {
    for (    EntityRef entity : entityManager.listEntitiesWith(NetworkComponent.class)) {
      NetworkComponent netComp=entity.getComponent(NetworkComponent.class);
      netComp.setNetworkId(0);
      entity.saveComponent(netComp);
    }
    this.entityManager.unsubscribe(this);
  }
  entityManager=null;
  entitySystemLibrary=null;
  eventSerializer=null;
  entitySerializer=null;
  clientList.clear();
  netClientList.clear();
  logger.info(""String_Node_Str"");
}",0.8362892223738063
1103,"private void createEntityMessage(NetData.CreateEntityMessage message){
  EntityRef newEntity;
  if (message.hasBlockPos()) {
    newEntity=blockEntityRegistry.getOrCreateBlockEntityAt(NetMessageUtil.convert(message.getBlockPos()));
    entitySerializer.deserializeOnto(newEntity,message.getEntity());
  }
 else {
    newEntity=entitySerializer.deserialize(message.getEntity());
  }
  if (newEntity == null) {
    logger.error(""String_Node_Str"");
  }
 else   if (newEntity.getComponent(NetworkComponent.class) == null) {
    logger.error(""String_Node_Str"",newEntity);
  }
 else   if (newEntity.getComponent(NetworkComponent.class).getNetworkId() == 0) {
    logger.error(""String_Node_Str"",newEntity);
  }
  logger.info(""String_Node_Str"",newEntity,newEntity.getComponent(NetworkComponent.class).getNetworkId());
  networkSystem.registerNetworkEntity(newEntity);
}","private void createEntityMessage(NetData.CreateEntityMessage message){
  EntityRef newEntity=entitySerializer.deserialize(message.getEntity());
  if (newEntity == null) {
    logger.error(""String_Node_Str"");
  }
 else   if (newEntity.getComponent(NetworkComponent.class) == null) {
    logger.error(""String_Node_Str"",newEntity);
  }
 else   if (newEntity.getComponent(NetworkComponent.class).getNetworkId() == 0) {
    logger.error(""String_Node_Str"",newEntity);
  }
  logger.info(""String_Node_Str"",newEntity,newEntity.getComponent(NetworkComponent.class).getNetworkId());
  networkSystem.registerNetworkEntity(newEntity);
}",0.7722371967654986
1104,"@Override public boolean step(){
  ComponentSystemManager componentSystemManager=CoreRegistry.get(ComponentSystemManager.class);
  for (  UpdateSubscriberSystem updater : componentSystemManager.iterateUpdateSubscribers()) {
    updater.update(0.0f);
  }
  LocalPlayer localPlayer=CoreRegistry.get(LocalPlayer.class);
  ClientComponent client=localPlayer.getClientEntity().getComponent(ClientComponent.class);
  if (client != null && client.character.exists()) {
    worldRenderer.setPlayer(CoreRegistry.get(LocalPlayer.class));
    return true;
  }
  return false;
}","@Override public boolean step(){
  ComponentSystemManager componentSystemManager=CoreRegistry.get(ComponentSystemManager.class);
  for (  UpdateSubscriberSystem updater : componentSystemManager.iterateUpdateSubscribers()) {
    updater.update(0.0f);
  }
  LocalPlayer localPlayer=CoreRegistry.get(LocalPlayer.class);
  ClientComponent client=localPlayer.getClientEntity().getComponent(ClientComponent.class);
  if (client != null && client.character.exists()) {
    worldRenderer.setPlayer(CoreRegistry.get(LocalPlayer.class));
    return true;
  }
 else {
    worldRenderer.getChunkProvider().update();
  }
  return false;
}",0.950461796809404
1105,"@ReceiveEvent(components=ClientComponent.class) public void onConnect(ConnectedEvent connected,EntityRef entity){
  worldRenderer.getChunkProvider().addRelevanceEntity(entity,4,networkSystem.getOwner(entity));
  if (connected.getEntityStore().hasCharacter()) {
    LocationComponent location=entity.getComponent(LocationComponent.class);
    location.setWorldPosition(connected.getEntityStore().getRelevanceLocation());
    entity.saveComponent(location);
    if (worldRenderer.getWorldProvider().isBlockActive(connected.getEntityStore().getRelevanceLocation())) {
      restoreCharacter(entity,connected.getEntityStore());
    }
 else {
      SpawningClientInfo spawningClientInfo=new SpawningClientInfo(entity,connected.getEntityStore().getRelevanceLocation(),connected.getEntityStore());
      clientsPreparingToSpawn.add(spawningClientInfo);
    }
  }
 else {
    Vector3i pos=Vector3i.zero();
    if (chunkProvider.getChunk(pos) != null) {
      spawnPlayer(entity,new Vector3i(Chunk.SIZE_X / 2,Chunk.SIZE_Y,Chunk.SIZE_Z / 2));
    }
 else {
      LocationComponent location=entity.getComponent(LocationComponent.class);
      location.setWorldPosition(new Vector3f(Chunk.SIZE_X / 2,Chunk.SIZE_Y / 2,Chunk.SIZE_Z / 2));
      entity.saveComponent(location);
      SpawningClientInfo spawningClientInfo=new SpawningClientInfo(entity,new Vector3f(Chunk.SIZE_X / 2,Chunk.SIZE_Y / 2,Chunk.SIZE_Z / 2));
      clientsPreparingToSpawn.add(spawningClientInfo);
    }
  }
}","@ReceiveEvent(components=ClientComponent.class) public void onConnect(ConnectedEvent connected,EntityRef entity){
  LocationComponent loc=entity.getComponent(LocationComponent.class);
  loc.setWorldPosition(connected.getEntityStore().getRelevanceLocation());
  entity.saveComponent(loc);
  worldRenderer.getChunkProvider().addRelevanceEntity(entity,4,networkSystem.getOwner(entity));
  if (connected.getEntityStore().hasCharacter()) {
    if (worldRenderer.getWorldProvider().isBlockActive(connected.getEntityStore().getRelevanceLocation())) {
      restoreCharacter(entity,connected.getEntityStore());
    }
 else {
      SpawningClientInfo spawningClientInfo=new SpawningClientInfo(entity,connected.getEntityStore().getRelevanceLocation(),connected.getEntityStore());
      clientsPreparingToSpawn.add(spawningClientInfo);
    }
  }
 else {
    Vector3i pos=Vector3i.zero();
    if (chunkProvider.getChunk(pos) != null) {
      spawnPlayer(entity,new Vector3i(Chunk.SIZE_X / 2,Chunk.SIZE_Y,Chunk.SIZE_Z / 2));
    }
 else {
      SpawningClientInfo spawningClientInfo=new SpawningClientInfo(entity,new Vector3f(Chunk.SIZE_X / 2,Chunk.SIZE_Y / 2,Chunk.SIZE_Z / 2));
      clientsPreparingToSpawn.add(spawningClientInfo);
    }
  }
}",0.6999630040695524
1106,"private void restoreCharacter(EntityRef entity,PlayerEntityStore playerEntityStore){
  Map<String,EntityRef> restoredEntities=playerEntityStore.restoreAll();
  EntityRef character=restoredEntities.get(""String_Node_Str"");
  if (character == null) {
    spawnPlayer(entity,new Vector3i(Chunk.SIZE_X / 2,Chunk.SIZE_Y,Chunk.SIZE_Z / 2));
  }
 else {
    Client clientListener=networkSystem.getOwner(entity);
    int distance=clientListener.getViewDistance();
    if (!clientListener.isLocal()) {
      distance+=ChunkConstants.REMOTE_GENERATION_DISTANCE;
    }
    worldRenderer.getChunkProvider().updateRelevanceEntity(entity,distance);
    NetworkComponent netComp=character.getComponent(NetworkComponent.class);
    if (netComp != null) {
      netComp.owner=entity;
      character.saveComponent(netComp);
    }
    ClientComponent client=entity.getComponent(ClientComponent.class);
    client.character=character;
    entity.saveComponent(client);
  }
}","private void restoreCharacter(EntityRef entity,PlayerEntityStore playerEntityStore){
  Map<String,EntityRef> restoredEntities=playerEntityStore.restoreAll();
  EntityRef character=restoredEntities.get(""String_Node_Str"");
  if (character == null) {
    spawnPlayer(entity,new Vector3i(Chunk.SIZE_X / 2,Chunk.SIZE_Y,Chunk.SIZE_Z / 2));
  }
 else {
    Client clientListener=networkSystem.getOwner(entity);
    int distance=clientListener.getViewDistance();
    if (!clientListener.isLocal()) {
      distance+=ChunkConstants.REMOTE_GENERATION_DISTANCE;
    }
    worldRenderer.getChunkProvider().updateRelevanceEntity(entity,distance);
    NetworkComponent netComp=character.getComponent(NetworkComponent.class);
    if (netComp != null) {
      netComp.owner=entity;
      character.saveComponent(netComp);
    }
    ClientComponent client=entity.getComponent(ClientComponent.class);
    client.character=character;
    entity.saveComponent(client);
    Location.attachChild(character,entity);
  }
}",0.9774590163934426
1107,"@Override public void dispose(){
  boolean saveWorld=CoreRegistry.get(NetworkSystem.class).getMode().isAuthority();
  networkSystem.shutdown();
  eventSystem.process();
  componentSystemManager.shutdown();
  guiManager.closeAllWindows();
  if (saveWorld) {
    try {
      CoreRegistry.get(WorldPersister.class).save(new File(PathManager.getInstance().getCurrentWorldPath(),TerasologyConstants.ENTITY_DATA_FILE),WorldPersister.SaveFormat.Binary);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  entityManager.clear();
  if (worldRenderer != null) {
    worldRenderer.dispose();
    worldRenderer=null;
  }
}","@Override public void dispose(){
  boolean saveWorld=CoreRegistry.get(NetworkSystem.class).getMode().isAuthority();
  networkSystem.shutdown();
  eventSystem.process();
  componentSystemManager.shutdown();
  guiManager.closeAllWindows();
  if (saveWorld) {
    try {
      CoreRegistry.get(WorldPersister.class).save(new File(PathManager.getInstance().getCurrentWorldPath(),TerasologyConstants.ENTITY_DATA_FILE),WorldPersister.SaveFormat.Binary);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  entityManager.clear();
  if (worldRenderer != null) {
    worldRenderer.dispose(saveWorld);
    worldRenderer=null;
  }
}",0.9930928626247122
1108,"@Override public void removedForStoring(EntityRef entity){
  if (entity.exists()) {
    int entityId=entity.getId();
    if (eventSystem != null) {
      eventSystem.send(entity,OnDeactivatedEvent.newInstance());
    }
    store.remove(entityId);
  }
}","@Override public void removedForStoring(EntityRef entity){
  if (entity.exists()) {
    int entityId=entity.getId();
    if (eventSystem != null) {
      eventSystem.send(entity,OnDeactivatedEvent.newInstance());
    }
    loadedIds.remove(entityId);
    store.remove(entityId);
  }
}",0.9402985074626866
1109,"@Override public EntityRef createEntityWithId(int id,Iterable<Component> components){
  if (!freedIds.contains(id)) {
    EntityRef entity=createEntityRef(id);
    for (    Component c : components) {
      store.put(id,c);
    }
    if (eventSystem != null) {
      eventSystem.send(entity,OnActivatedEvent.newInstance());
    }
    return entity;
  }
  return EntityRef.NULL;
}","@Override public EntityRef createEntityWithId(int id,Iterable<Component> components){
  if (!freedIds.contains(id)) {
    EntityRef entity=createEntityRef(id);
    for (    Component c : components) {
      store.put(id,c);
    }
    loadedIds.add(id);
    if (eventSystem != null) {
      eventSystem.send(entity,OnActivatedEvent.newInstance());
    }
    return entity;
  }
  return EntityRef.NULL;
}",0.970550576184379
1110,"@Override public void clear(){
  store.clear();
  nextEntityId=1;
  freedIds.clear();
  entityCache.clear();
}","@Override public void clear(){
  store.clear();
  nextEntityId=1;
  loadedIds.clear();
  freedIds.clear();
  entityCache.clear();
}",0.9128630705394192
1111,"void destroy(int entityId){
  EntityRef ref=createEntityRef(entityId);
  if (eventSystem != null) {
    eventSystem.send(ref,OnDeactivatedEvent.newInstance());
    eventSystem.send(ref,OnRemovedEvent.newInstance());
  }
  for (  Component comp : store.iterateComponents(entityId)) {
    notifyComponentRemoved(ref,comp.getClass());
  }
  entityCache.remove(entityId);
  freedIds.add(entityId);
  if (ref instanceof PojoEntityRef) {
    ((PojoEntityRef)ref).invalidate();
  }
  store.remove(entityId);
}","void destroy(int entityId){
  if (!loadedIds.contains(entityId)) {
    return;
  }
  EntityRef ref=createEntityRef(entityId);
  if (eventSystem != null) {
    eventSystem.send(ref,OnDeactivatedEvent.newInstance());
    eventSystem.send(ref,OnRemovedEvent.newInstance());
  }
  for (  Component comp : store.iterateComponents(entityId)) {
    notifyComponentRemoved(ref,comp.getClass());
  }
  entityCache.remove(entityId);
  loadedIds.remove(entityId);
  freedIds.add(entityId);
  if (ref instanceof PojoEntityRef) {
    ((PojoEntityRef)ref).invalidate();
  }
  store.remove(entityId);
}",0.9219467401285584
1112,"public static void attachChild(EntityRef parent,EntityRef child){
  LocationComponent childLoc=child.getComponent(LocationComponent.class);
  LocationComponent parentLoc=parent.getComponent(LocationComponent.class);
  if (childLoc != null && parentLoc != null && !childLoc.getParent().equals(parent)) {
    Vector3f oldWorldPos=childLoc.getWorldPosition();
    LocationComponent oldParentLoc=childLoc.getParent().getComponent(LocationComponent.class);
    if (oldParentLoc != null) {
      oldParentLoc.children.remove(child);
      childLoc.getParent().saveComponent(oldParentLoc);
    }
    childLoc.parent=parent;
    childLoc.setWorldPosition(oldWorldPos);
    parentLoc.children.add(child);
    child.saveComponent(childLoc);
    parent.saveComponent(parentLoc);
  }
}","/** 
 * Attaches an entity to another entity. Both must have location components. The child maintains its previous position and rotation but follows the parent.
 * @param parent
 * @param child
 */
public static void attachChild(EntityRef parent,EntityRef child){
  LocationComponent childLoc=child.getComponent(LocationComponent.class);
  LocationComponent parentLoc=parent.getComponent(LocationComponent.class);
  if (childLoc != null && parentLoc != null && !childLoc.getParent().equals(parent)) {
    Vector3f oldWorldPos=childLoc.getWorldPosition();
    LocationComponent oldParentLoc=childLoc.getParent().getComponent(LocationComponent.class);
    if (oldParentLoc != null) {
      oldParentLoc.children.remove(child);
      childLoc.getParent().saveComponent(oldParentLoc);
    }
    childLoc.parent=parent;
    childLoc.setWorldPosition(oldWorldPos);
    parentLoc.children.add(child);
    child.saveComponent(childLoc);
    parent.saveComponent(parentLoc);
  }
}",0.8864678899082569
1113,"public EntityRef newInstance(Vector3f spawnPosition,EntityRef controller){
  EntityRef player=entityManager.create(""String_Node_Str"",spawnPosition);
  EntityRef transferSlot=entityManager.create(""String_Node_Str"");
  CharacterComponent playerComponent=player.getComponent(CharacterComponent.class);
  playerComponent.spawnPosition.set(spawnPosition);
  playerComponent.movingItem=transferSlot;
  playerComponent.controller=controller;
  player.saveComponent(playerComponent);
  EntityRef chest=blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""));
  BlockItemComponent blockItem=chest.getComponent(BlockItemComponent.class);
  EntityRef chestContents=blockItem.placedEntity;
  inventoryManager.giveItem(chestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(chestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(chestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(chestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(chestContents,entityManager.create(""String_Node_Str""));
  inventoryManager.giveItem(chestContents,entityManager.create(""String_Node_Str""));
  inventoryManager.giveItem(chestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(chestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(chestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  EntityRef doorItem=entityManager.create(""String_Node_Str"");
  ItemComponent doorItemComp=doorItem.getComponent(ItemComponent.class);
  doorItemComp.stackCount=20;
  doorItem.saveComponent(doorItemComp);
  inventoryManager.giveItem(chestContents,doorItem);
  EntityRef innerChest=blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""));
  BlockItemComponent innerBlockItem=innerChest.getComponent(BlockItemComponent.class);
  EntityRef innerChestContents=innerBlockItem.placedEntity;
  inventoryManager.giveItem(innerChestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(innerChestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(innerChestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(innerChestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(innerChestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(innerChestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(chestContents,innerChest);
  inventoryManager.giveItem(player,entityManager.create(""String_Node_Str""));
  inventoryManager.giveItem(player,entityManager.create(""String_Node_Str""));
  inventoryManager.giveItem(player,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(player,entityManager.create(""String_Node_Str""));
  inventoryManager.giveItem(player,entityManager.create(""String_Node_Str""));
  inventoryManager.giveItem(player,entityManager.create(""String_Node_Str""));
  inventoryManager.giveItem(player,chest);
  return player;
}","public EntityRef newInstance(Vector3f spawnPosition,EntityRef controller){
  EntityBuilder builder=entityManager.newBuilder(""String_Node_Str"");
  builder.getComponent(LocationComponent.class).setWorldPosition(spawnPosition);
  builder.getComponent(NetworkComponent.class).owner=controller;
  EntityRef transferSlot=entityManager.create(""String_Node_Str"");
  CharacterComponent playerComponent=builder.getComponent(CharacterComponent.class);
  playerComponent.spawnPosition.set(spawnPosition);
  playerComponent.movingItem=transferSlot;
  playerComponent.controller=controller;
  EntityRef chest=blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""));
  BlockItemComponent blockItem=chest.getComponent(BlockItemComponent.class);
  EntityRef chestContents=blockItem.placedEntity;
  inventoryManager.giveItem(chestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(chestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(chestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(chestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(chestContents,entityManager.create(""String_Node_Str""));
  inventoryManager.giveItem(chestContents,entityManager.create(""String_Node_Str""));
  inventoryManager.giveItem(chestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(chestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(chestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  EntityRef doorItem=entityManager.create(""String_Node_Str"");
  ItemComponent doorItemComp=doorItem.getComponent(ItemComponent.class);
  doorItemComp.stackCount=20;
  doorItem.saveComponent(doorItemComp);
  inventoryManager.giveItem(chestContents,doorItem);
  EntityRef innerChest=blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""));
  BlockItemComponent innerBlockItem=innerChest.getComponent(BlockItemComponent.class);
  EntityRef innerChestContents=innerBlockItem.placedEntity;
  inventoryManager.giveItem(innerChestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(innerChestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(innerChestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(innerChestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(innerChestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(innerChestContents,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(chestContents,innerChest);
  EntityRef player=builder.build();
  inventoryManager.giveItem(player,entityManager.create(""String_Node_Str""));
  inventoryManager.giveItem(player,entityManager.create(""String_Node_Str""));
  inventoryManager.giveItem(player,blockFactory.newInstance(blockManager.getBlockFamily(""String_Node_Str""),99));
  inventoryManager.giveItem(player,entityManager.create(""String_Node_Str""));
  inventoryManager.giveItem(player,entityManager.create(""String_Node_Str""));
  inventoryManager.giveItem(player,entityManager.create(""String_Node_Str""));
  inventoryManager.giveItem(player,chest);
  return player;
}",0.8896219931271477
1114,"private void spawnPlayer(EntityRef clientEntity,Vector3i spawnPos){
  while (worldRenderer.getWorldProvider().getBlock(spawnPos) == BlockManager.getAir() && spawnPos.y > 0) {
    spawnPos.y--;
  }
  ClientComponent client=clientEntity.getComponent(ClientComponent.class);
  if (client != null) {
    PlayerFactory playerFactory=new PlayerFactory(entityManager,inventoryManager);
    EntityRef playerCharacter=playerFactory.newInstance(new Vector3f(spawnPos.x,spawnPos.y + 1.5f,spawnPos.z),clientEntity);
    Location.attachChild(playerCharacter,clientEntity);
    LocationComponent clientLoc=clientEntity.getComponent(LocationComponent.class);
    clientLoc.setLocalPosition(new Vector3f());
    clientLoc.setLocalRotation(new Quat4f(0,0,0,1));
    clientEntity.saveComponent(clientLoc);
    Client clientListener=networkSystem.getOwner(clientEntity);
    int distance=clientListener.getViewDistance();
    if (!clientListener.isLocal()) {
      distance+=ChunkConstants.REMOTE_GENERATION_DISTANCE;
    }
    worldRenderer.getChunkProvider().updateRelevanceEntity(playerCharacter,distance);
    client.character=playerCharacter;
    clientEntity.saveComponent(client);
  }
}","private void spawnPlayer(EntityRef clientEntity,Vector3i spawnPos){
  while (worldRenderer.getWorldProvider().getBlock(spawnPos) == BlockManager.getAir() && spawnPos.y > 0) {
    spawnPos.y--;
  }
  ClientComponent client=clientEntity.getComponent(ClientComponent.class);
  if (client != null) {
    PlayerFactory playerFactory=new PlayerFactory(entityManager,inventoryManager);
    EntityRef playerCharacter=playerFactory.newInstance(new Vector3f(spawnPos.x,spawnPos.y + 1.5f,spawnPos.z),clientEntity);
    Location.attachChild(playerCharacter,clientEntity,new Vector3f(),new Quat4f(0,0,0,1));
    Client clientListener=networkSystem.getOwner(clientEntity);
    int distance=clientListener.getViewDistance();
    if (!clientListener.isLocal()) {
      distance+=ChunkConstants.REMOTE_GENERATION_DISTANCE;
    }
    worldRenderer.getChunkProvider().updateRelevanceEntity(clientEntity,distance);
    client.character=playerCharacter;
    clientEntity.saveComponent(client);
  }
}",0.8661710037174721
1115,"private void restoreCharacter(EntityRef entity,PlayerEntityStore playerEntityStore){
  Map<String,EntityRef> restoredEntities=playerEntityStore.restoreAll();
  EntityRef character=restoredEntities.get(""String_Node_Str"");
  if (character == null) {
    spawnPlayer(entity,new Vector3i(Chunk.SIZE_X / 2,Chunk.SIZE_Y,Chunk.SIZE_Z / 2));
  }
 else {
    Client clientListener=networkSystem.getOwner(entity);
    int distance=clientListener.getViewDistance();
    if (!clientListener.isLocal()) {
      distance+=ChunkConstants.REMOTE_GENERATION_DISTANCE;
    }
    worldRenderer.getChunkProvider().updateRelevanceEntity(entity,distance);
    ClientComponent client=entity.getComponent(ClientComponent.class);
    client.character=character;
    entity.saveComponent(client);
    CharacterComponent characterComp=character.getComponent(CharacterComponent.class);
    characterComp.controller=entity;
    character.saveComponent(characterComp);
    Location.attachChild(character,entity);
  }
}","private void restoreCharacter(EntityRef entity,PlayerEntityStore playerEntityStore){
  Map<String,EntityRef> restoredEntities=playerEntityStore.restoreAll();
  EntityRef character=restoredEntities.get(""String_Node_Str"");
  if (character == null) {
    spawnPlayer(entity,new Vector3i(Chunk.SIZE_X / 2,Chunk.SIZE_Y,Chunk.SIZE_Z / 2));
  }
 else {
    Client clientListener=networkSystem.getOwner(entity);
    int distance=clientListener.getViewDistance();
    if (!clientListener.isLocal()) {
      distance+=ChunkConstants.REMOTE_GENERATION_DISTANCE;
    }
    worldRenderer.getChunkProvider().updateRelevanceEntity(entity,distance);
    ClientComponent client=entity.getComponent(ClientComponent.class);
    client.character=character;
    entity.saveComponent(client);
    CharacterComponent characterComp=character.getComponent(CharacterComponent.class);
    if (characterComp != null) {
      characterComp.controller=entity;
      character.saveComponent(characterComp);
      NetworkComponent netComp=character.getComponent(NetworkComponent.class);
      netComp.owner=entity;
      character.saveComponent(netComp);
      Location.attachChild(character,entity,new Vector3f(),new Quat4f(0,0,0,1));
    }
 else {
      character.destroy();
      spawnPlayer(entity,new Vector3i(Chunk.SIZE_X / 2,Chunk.SIZE_Y,Chunk.SIZE_Z / 2));
    }
  }
}",0.8173241852487135
1116,"private void receivedServerInfo(ServerInfoMessage message){
  if (awaitingServerInfo) {
    awaitingServerInfo=false;
    server.setServerInfo(message);
  }
}","private void receivedServerInfo(ServerInfoMessage message){
  if (awaitingServerInfo) {
    logger.info(""String_Node_Str"");
    awaitingServerInfo=false;
    server.setServerInfo(message);
  }
}",0.8977272727272727
1117,"private void processEvents(NetData.NetMessage message){
  boolean lagCompensated=false;
  PredictionSystem predictionSystem=CoreRegistry.get(PredictionSystem.class);
  for (  NetData.EventMessage eventMessage : message.getEventList()) {
    Event event=eventSerializer.deserialize(eventMessage.getEvent());
    EventMetadata<?> metadata=entitySystemLibrary.getEventLibrary().getMetadata(event.getClass());
    if (metadata.getNetworkEventType() != NetworkEventType.SERVER) {
      logger.warn(""String_Node_Str"",metadata,getName());
      continue;
    }
    if (!lagCompensated && metadata.isLagCompensated()) {
      if (predictionSystem != null) {
        predictionSystem.lagCompensate(getEntity(),lastReceivedTime);
      }
      lagCompensated=true;
    }
    EntityRef target=EntityRef.NULL;
    if (eventMessage.hasTargetId()) {
      target=networkSystem.getEntity(eventMessage.getTargetId());
    }
    if (target.exists()) {
      if (networkSystem.getOwner(target).equals(this)) {
        target.send(event);
      }
 else {
        logger.warn(""String_Node_Str"",event,target,this);
      }
    }
  }
  if (lagCompensated && predictionSystem != null) {
    predictionSystem.restoreToPresent();
  }
}","private void processEvents(NetData.NetMessage message){
  boolean lagCompensated=false;
  PredictionSystem predictionSystem=CoreRegistry.get(PredictionSystem.class);
  for (  NetData.EventMessage eventMessage : message.getEventList()) {
    Event event=eventSerializer.deserialize(eventMessage.getEvent());
    EventMetadata<?> metadata=entitySystemLibrary.getEventLibrary().getMetadata(event.getClass());
    if (metadata.getNetworkEventType() != NetworkEventType.SERVER) {
      logger.warn(""String_Node_Str"",metadata,getName());
      continue;
    }
    if (!lagCompensated && metadata.isLagCompensated()) {
      if (predictionSystem != null) {
        predictionSystem.lagCompensate(getEntity(),lastReceivedTime);
      }
      lagCompensated=true;
    }
    EntityRef target=EntityRef.NULL;
    if (eventMessage.hasTargetId()) {
      target=networkSystem.getEntity(eventMessage.getTargetId());
    }
    if (target.exists()) {
      if (Objects.equal(networkSystem.getOwner(target),this)) {
        target.send(event);
      }
 else {
        logger.warn(""String_Node_Str"",event,target,this);
      }
    }
  }
  if (lagCompensated && predictionSystem != null) {
    predictionSystem.restoreToPresent();
  }
}",0.9905232797692624
1118,"@ReceiveEvent(components={PotionComponent.class}) public void onActivate(ActivateEvent event,EntityRef entity){
  potion=entity.getComponent(PotionComponent.class);
  poisoned=entity.getComponent(PoisonedComponent.class);
  EntityManager entityManager=CoreRegister.get(EntityManager.class);
  HealthComponent health=event.getTarget().getComponent(HealthComponent.class);
  ItemComponent itemComp=entity.getComponent(ItemComponent.class);
  EntityRef item=entityManager.create(""String_Node_Str"");
switch (potion.type) {
case Red:
    event.getInstigator().send(new BoostHpEvent());
  event.getInstigator().send(new ReceiveItemEvent(item));
if (itemComp != null && !itemComp.container.exists()) {
  item.destroy();
}
break;
case Green:
event.getInstigator().send(new ReceiveItemEvent(item));
if (itemComp != null && !itemComp.container.exists()) {
item.destroy();
}
event.getInstigator().send(new PoisonedEvent());
break;
case Orange:
event.getInstigator().send(new CurePoisonEvent());
event.getInstigator().send(new ReceiveItemEvent(item));
if (itemComp != null && !itemComp.container.exists()) {
item.destroy();
}
break;
case Purple:
event.getInstigator().send(new ReceiveItemEvent(item));
if (itemComp != null && !itemComp.container.exists()) {
item.destroy();
}
event.getInstigator().send(new BoostSpeedEvent());
break;
default :
break;
}
AudioManager.play(new AssetUri(AssetType.SOUND,""String_Node_Str""),1.0f);
}","@ReceiveEvent(components={PotionComponent.class}) public void onActivate(ActivateEvent event,EntityRef entity){
  potion=entity.getComponent(PotionComponent.class);
  poisoned=entity.getComponent(PoisonedComponent.class);
  EntityManager entityManager=CoreRegister.get(EntityManager.class);
  HealthComponent health=event.getTarget().getComponent(HealthComponent.class);
  ItemComponent itemComp=entity.getComponent(ItemComponent.class);
  EntityRef item=entityManager.create(""String_Node_Str"");
switch (potion.type) {
case Red:
    event.getInstigator().send(new BoostHpEvent());
  event.getInstigator().send(new ReceiveItemEvent(item));
if (itemComp != null && !itemComp.container.exists()) {
  item.destroy();
}
break;
case Green:
event.getInstigator().send(new ReceiveItemEvent(item));
if (itemComp != null && !itemComp.container.exists()) {
item.destroy();
}
event.getInstigator().send(new PoisonedEvent());
break;
case Orange:
event.getInstigator().send(new CurePoisonEvent());
event.getInstigator().send(new ReceiveItemEvent(item));
if (itemComp != null && !itemComp.container.exists()) {
item.destroy();
}
break;
case Purple:
event.getInstigator().send(new ReceiveItemEvent(item));
if (itemComp != null && !itemComp.container.exists()) {
item.destroy();
}
event.getInstigator().send(new BoostSpeedEvent());
break;
default :
break;
}
audioManager.playSound(Assets.getSound(""String_Node_Str""),1.0f);
}",0.970942593905032
1119,"/** 
 * Stops all playback.
 */
@Override public void stopAllSounds(){
  for (  SoundPool pool : _pools.values()) {
    pool.stopAll();
  }
}",void stopAllSounds();,0.2592592592592592
1120,"public static SoundSource playMusic(String shortUri){
  AssetUri uri=new AssetUri(AssetType.MUSIC,shortUri);
  return playMusic(uri);
}",void playMusic(Sound sound);,0.2699386503067484
1121,"public void setFullscreen(Boolean state){
  if (Config.getInstance().isFullscreen() != state) {
    Config.getInstance().setFullscreen(state);
    setDisplayMode();
    CoreRegistry.get(GUIManager.class).update(true);
  }
}","public void setFullscreen(Boolean state){
  if (Config.getInstance().isFullscreen() != state) {
    Config.getInstance().setFullscreen(state);
    setDisplayMode();
    resizeViewport();
    CoreRegistry.get(GUIManager.class).update(true);
  }
}",0.9529914529914528
1122,"/** 
 * Generate the local contents of a chunk. This should be purely deterministic from the chunk contents, chunk position and world seed - should not depend on external state or other data.
 * @param c
 */
public void generateChunk(Chunk c){
  int hm_x=(((c.getChunkWorldPosX() / Chunk.SIZE_X) % 512) + 512) % 512;
  int hm_z=(((c.getChunkWorldPosZ() / Chunk.SIZE_Z) % 512) + 512) % 512;
  double scaleFactor=0.05 * Chunk.SIZE_Y;
  double p00=heightmap[hm_x][hm_z] * scaleFactor;
  double p10=heightmap[(hm_x - 1 + 512) % 512][(hm_z) % 512] * scaleFactor;
  double p11=heightmap[(hm_x - 1 + 512) % 512][(hm_z + 1 + 512) % 512] * scaleFactor;
  double p01=heightmap[(hm_x) % 512][(hm_z + 1 + 512) % 512] * scaleFactor;
  for (int x=0; x < Chunk.SIZE_X; x++) {
    for (int z=0; z < Chunk.SIZE_Z; z++) {
      WorldBiomeProvider.Biome type=biomeProvider.getBiomeAt(c.getBlockWorldPosX(x),c.getBlockWorldPosZ(z));
      double interpolatedHeight=lerp(x / (double)Chunk.SIZE_X,lerp(z / (double)Chunk.SIZE_Z,p10,p11),lerp(z / (double)Chunk.SIZE_Z,p00,p01));
      double threshold=Math.floor(interpolatedHeight);
      for (int y=Chunk.SIZE_Y; y >= 0; y--) {
        if (y == 0) {
          c.setBlock(x,y,z,mantle);
          break;
        }
 else         if (y < threshold) {
          c.setBlock(x,y,z,stone);
        }
 else         if (y == threshold) {
          if (y < Chunk.SIZE_Y * 0.05 + 1) {
            c.setBlock(x,y,z,sand);
          }
 else           if (y < Chunk.SIZE_Y * 0.05 * 12) {
            c.setBlock(x,y,z,grass);
          }
 else {
            c.setBlock(x,y,z,snow);
          }
        }
 else {
          if (y <= Chunk.SIZE_Y / 20) {
            c.setBlock(x,y,z,water);
            c.setLiquid(x,y,z,new LiquidData(LiquidType.WATER,Chunk.MAX_LIQUID_DEPTH));
          }
 else {
            c.setBlock(x,y,z,air);
          }
        }
      }
    }
  }
}","/** 
 * Generate the local contents of a chunk. This should be purely deterministic from the chunk contents, chunk position and world seed - should not depend on external state or other data.
 * @param c
 */
public void generateChunk(Chunk c){
  int hm_x=(((c.getChunkWorldPosX() / Chunk.SIZE_X) % 512) + 512) % 512;
  int hm_z=(((c.getChunkWorldPosZ() / Chunk.SIZE_Z) % 512) + 512) % 512;
  double scaleFactor=0.05 * Chunk.SIZE_Y;
  double p00=heightmap[hm_x][hm_z] * scaleFactor;
  double p10=heightmap[(hm_x - 1 + 512) % 512][(hm_z) % 512] * scaleFactor;
  double p11=heightmap[(hm_x - 1 + 512) % 512][(hm_z + 1 + 512) % 512] * scaleFactor;
  double p01=heightmap[(hm_x) % 512][(hm_z + 1 + 512) % 512] * scaleFactor;
  for (int x=0; x < Chunk.SIZE_X; x++) {
    for (int z=0; z < Chunk.SIZE_Z; z++) {
      WorldBiomeProvider.Biome type=biomeProvider.getBiomeAt(c.getBlockWorldPosX(x),c.getBlockWorldPosZ(z));
      double interpolatedHeight=lerp(x / (double)Chunk.SIZE_X,lerp(z / (double)Chunk.SIZE_Z,p10,p11),lerp(z / (double)Chunk.SIZE_Z,p00,p01));
      double threshold=Math.floor(interpolatedHeight);
      for (int y=Chunk.SIZE_Y - 1; y >= 0; y--) {
        if (y == 0) {
          c.setBlock(x,y,z,mantle);
          break;
        }
 else         if (y < threshold) {
          c.setBlock(x,y,z,stone);
        }
 else         if (y == threshold) {
          if (y < Chunk.SIZE_Y * 0.05 + 1) {
            c.setBlock(x,y,z,sand);
          }
 else           if (y < Chunk.SIZE_Y * 0.05 * 12) {
            c.setBlock(x,y,z,grass);
          }
 else {
            c.setBlock(x,y,z,snow);
          }
        }
 else {
          if (y <= Chunk.SIZE_Y / 20) {
            c.setBlock(x,y,z,water);
            c.setLiquid(x,y,z,new LiquidData(LiquidType.WATER,Chunk.MAX_LIQUID_DEPTH));
          }
 else {
            c.setBlock(x,y,z,air);
          }
        }
      }
    }
  }
}",0.9989406779661016
1123,"@Override public void generateChunk(final Chunk chunk){
  for (int x=0; x < Chunk.SIZE_X; x++) {
    for (int z=0; z < Chunk.SIZE_Z; z++) {
      final WorldBiomeProvider.Biome type=biomeProvider.getBiomeAt(chunk.getBlockWorldPosX(x),chunk.getBlockWorldPosZ(z));
      for (int y=Chunk.SIZE_Y; y >= 0; y--) {
        if (y == 0) {
          chunk.setBlock(x,y,z,mantle);
        }
 else         if (y < height) {
switch (type) {
case FOREST:
            chunk.setBlock(x,y,z,dirt);
          break;
case PLAINS:
        chunk.setBlock(x,y,z,dirt);
      break;
case MOUNTAINS:
    chunk.setBlock(x,y,z,stone);
  break;
case SNOW:
chunk.setBlock(x,y,z,snow);
break;
case DESERT:
chunk.setBlock(x,y,z,sand);
break;
}
}
 else if (y == height) {
switch (type) {
case FOREST:
chunk.setBlock(x,y,z,dirt);
break;
case PLAINS:
chunk.setBlock(x,y,z,grass);
break;
case MOUNTAINS:
chunk.setBlock(x,y,z,stone);
break;
case SNOW:
chunk.setBlock(x,y,z,snow);
break;
case DESERT:
chunk.setBlock(x,y,z,sand);
break;
}
}
 else {
chunk.setBlock(x,y,z,air);
}
}
}
}
}","@Override public void generateChunk(final Chunk chunk){
  for (int x=0; x < Chunk.SIZE_X; x++) {
    for (int z=0; z < Chunk.SIZE_Z; z++) {
      final WorldBiomeProvider.Biome type=biomeProvider.getBiomeAt(chunk.getBlockWorldPosX(x),chunk.getBlockWorldPosZ(z));
      for (int y=Chunk.SIZE_Y - 1; y >= 0; y--) {
        if (y == 0) {
          chunk.setBlock(x,y,z,mantle);
        }
 else         if (y < height) {
switch (type) {
case FOREST:
            chunk.setBlock(x,y,z,dirt);
          break;
case PLAINS:
        chunk.setBlock(x,y,z,dirt);
      break;
case MOUNTAINS:
    chunk.setBlock(x,y,z,stone);
  break;
case SNOW:
chunk.setBlock(x,y,z,snow);
break;
case DESERT:
chunk.setBlock(x,y,z,sand);
break;
}
}
 else if (y == height) {
switch (type) {
case FOREST:
chunk.setBlock(x,y,z,dirt);
break;
case PLAINS:
chunk.setBlock(x,y,z,grass);
break;
case MOUNTAINS:
chunk.setBlock(x,y,z,stone);
break;
case SNOW:
chunk.setBlock(x,y,z,snow);
break;
case DESERT:
chunk.setBlock(x,y,z,sand);
break;
}
}
 else {
chunk.setBlock(x,y,z,air);
}
}
}
}
}",0.9980970504281635
1124,"@Override public void generateChunk(Chunk c){
  double[][][] densityMap=new double[Chunk.SIZE_X + 1][Chunk.SIZE_Y + 1][Chunk.SIZE_Z + 1];
  for (int x=0; x <= Chunk.SIZE_X; x+=SAMPLE_RATE_3D_HOR) {
    for (int z=0; z <= Chunk.SIZE_Z; z+=SAMPLE_RATE_3D_HOR) {
      for (int y=0; y <= Chunk.SIZE_Y; y+=SAMPLE_RATE_3D_VERT) {
        densityMap[x][y][z]=calcDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z));
      }
    }
  }
  triLerpDensityMap(densityMap);
  for (int x=0; x < Chunk.SIZE_X; x++) {
    for (int z=0; z < Chunk.SIZE_Z; z++) {
      WorldBiomeProvider.Biome type=biomeProvider.getBiomeAt(c.getBlockWorldPosX(x),c.getBlockWorldPosZ(z));
      int firstBlockHeight=-1;
      for (int y=Chunk.SIZE_Y; y >= 0; y--) {
        if (y == 0) {
          c.setBlock(x,y,z,mantle);
          break;
        }
        if (y <= 32 && y > 0) {
          c.setBlock(x,y,z,water);
          c.setLiquid(x,y,z,new LiquidData(LiquidType.WATER,Chunk.MAX_LIQUID_DEPTH));
          if (y == 32) {
            if (type == WorldBiomeProvider.Biome.SNOW)             c.setBlock(x,y,z,ice);
          }
        }
        double dens=densityMap[x][y][z];
        if ((dens >= 0 && dens < 32)) {
          if (firstBlockHeight == -1)           firstBlockHeight=y;
          if (calcCaveDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z)) > -0.7)           GenerateOuterLayer(x,y,z,firstBlockHeight,c,type);
 else           c.setBlock(x,y,z,air);
          continue;
        }
 else         if (dens >= 32) {
          if (firstBlockHeight == -1)           firstBlockHeight=y;
          if (calcCaveDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z)) > -0.6)           GenerateInnerLayer(x,y,z,c,type);
 else           c.setBlock(x,y,z,air);
          continue;
        }
        firstBlockHeight=-1;
      }
    }
  }
}","@Override public void generateChunk(Chunk c){
  double[][][] densityMap=new double[Chunk.SIZE_X + 1][Chunk.SIZE_Y + 1][Chunk.SIZE_Z + 1];
  for (int x=0; x <= Chunk.SIZE_X; x+=SAMPLE_RATE_3D_HOR) {
    for (int z=0; z <= Chunk.SIZE_Z; z+=SAMPLE_RATE_3D_HOR) {
      for (int y=0; y <= Chunk.SIZE_Y; y+=SAMPLE_RATE_3D_VERT) {
        densityMap[x][y][z]=calcDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z));
      }
    }
  }
  triLerpDensityMap(densityMap);
  for (int x=0; x < Chunk.SIZE_X; x++) {
    for (int z=0; z < Chunk.SIZE_Z; z++) {
      WorldBiomeProvider.Biome type=biomeProvider.getBiomeAt(c.getBlockWorldPosX(x),c.getBlockWorldPosZ(z));
      int firstBlockHeight=-1;
      for (int y=Chunk.SIZE_Y - 1; y >= 0; y--) {
        if (y == 0) {
          c.setBlock(x,y,z,mantle);
          break;
        }
        if (y <= 32 && y > 0) {
          c.setBlock(x,y,z,water);
          c.setLiquid(x,y,z,new LiquidData(LiquidType.WATER,Chunk.MAX_LIQUID_DEPTH));
          if (y == 32) {
            if (type == WorldBiomeProvider.Biome.SNOW)             c.setBlock(x,y,z,ice);
          }
        }
        double dens=densityMap[x][y][z];
        if ((dens >= 0 && dens < 32)) {
          if (firstBlockHeight == -1)           firstBlockHeight=y;
          if (calcCaveDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z)) > -0.7)           GenerateOuterLayer(x,y,z,firstBlockHeight,c,type);
 else           c.setBlock(x,y,z,air);
          continue;
        }
 else         if (dens >= 32) {
          if (firstBlockHeight == -1)           firstBlockHeight=y;
          if (calcCaveDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z)) > -0.6)           GenerateInnerLayer(x,y,z,c,type);
 else           c.setBlock(x,y,z,air);
          continue;
        }
        firstBlockHeight=-1;
      }
    }
  }
}",0.9989053092501368
1125,"public boolean setSunlight(int x,int y,int z,byte amount){
  byte oldValue=(byte)sunlight.set(x,y,z,amount);
  return oldValue != amount;
}","public boolean setSunlight(int x,int y,int z,byte amount){
  Preconditions.checkArgument(amount >= 0 && amount < 16);
  int raw=light.get(x,y,z);
  int old=raw >> 4;
  if (old == amount)   return false;
  int val=(byte)((raw & 0x0F) | (amount << 4));
  light.set(x,y,z,val);
  return true;
}",0.3627906976744186
1126,"public byte getSunlight(int x,int y,int z){
  return (byte)sunlight.get(x,y,z);
}","public byte getSunlight(int x,int y,int z){
  int raw=light.get(x,y,z);
  return (byte)((raw & 0xF0) >> 4);
}",0.6947368421052632
1127,"public boolean setLight(int x,int y,int z,byte amount){
  byte oldValue=(byte)light.set(x,y,z,amount);
  return (oldValue != amount);
}","public boolean setLight(int x,int y,int z,byte amount){
  Preconditions.checkArgument(amount >= 0 && amount < 16);
  int raw=light.get(x,y,z);
  int old=raw & 0x0F;
  if (old == amount)   return false;
  int val=(byte)(raw & 0xF0) | (amount & 0x0F);
  light.set(x,y,z,val);
  return true;
}",0.348235294117647
1128,"public byte getLight(int x,int y,int z){
  return (byte)light.get(x,y,z);
}","public byte getLight(int x,int y,int z){
  int raw=light.get(x,y,z);
  return (byte)(raw & 0x0F);
}",0.7241379310344828
1129,"public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(pos.x);
  out.writeInt(pos.y);
  out.writeInt(pos.z);
  out.writeObject(chunkState);
  out.writeObject(blocks);
  out.writeObject(sunlight);
  out.writeObject(light);
  out.writeObject(liquid);
}","public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(pos.x);
  out.writeInt(pos.y);
  out.writeInt(pos.z);
  out.writeObject(chunkState);
  out.writeObject(blocks);
  out.writeObject(light);
  out.writeObject(liquid);
}",0.944337811900192
1130,"public Chunk(Chunk other){
  pos.set(other.pos);
  blocks=other.blocks.copy();
  sunlight=other.sunlight.copy();
  light=other.light.copy();
  liquid=other.liquid.copy();
  chunkState=other.chunkState;
  dirty=true;
}","public Chunk(Chunk other){
  pos.set(other.pos);
  blocks=other.blocks.copy();
  light=other.light.copy();
  liquid=other.liquid.copy();
  chunkState=other.chunkState;
  dirty=true;
}",0.915
1131,"public void pack(){
  lock();
  try {
    TeraArray packed=blocks.pack();
    if (packed != blocks) {
      double bp=100d - (100d / blocks.getEstimatedMemoryConsumptionInBytes() * packed.getEstimatedMemoryConsumptionInBytes());
      System.out.println(String.format(""String_Node_Str"",pos.x,pos.y,pos.z,fpercent.format(bp)));
      blocks=packed;
    }
  }
  finally {
    unlock();
  }
}","public void pack(){
  lock();
  try {
    TeraArray packedBlocks=blocks.pack();
    TeraArray packedLight=light.pack();
    if (packedBlocks != blocks || packedLight != light) {
      double bp=100d - (100d / blocks.getEstimatedMemoryConsumptionInBytes() * packedBlocks.getEstimatedMemoryConsumptionInBytes());
      double bl=100d - (100d / light.getEstimatedMemoryConsumptionInBytes() * packedLight.getEstimatedMemoryConsumptionInBytes());
      System.out.println(String.format(""String_Node_Str"",pos.x,pos.y,pos.z,fpercent.format(bp),fpercent.format(bl)));
      blocks=packedBlocks;
      light=packedLight;
    }
 else {
      System.out.println(String.format(""String_Node_Str"",pos.x,pos.y,pos.z));
    }
  }
  finally {
    unlock();
  }
}",0.6860670194003528
1132,"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  pos.x=in.readInt();
  pos.y=in.readInt();
  pos.z=in.readInt();
  setDirty(true);
  chunkState=(State)in.readObject();
  blocks=(TeraArray)in.readObject();
  sunlight=(TeraArray)in.readObject();
  light=(TeraArray)in.readObject();
  liquid=(TeraArray)in.readObject();
}","public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  pos.x=in.readInt();
  pos.y=in.readInt();
  pos.z=in.readInt();
  setDirty(true);
  chunkState=(State)in.readObject();
  blocks=(TeraArray)in.readObject();
  light=(TeraArray)in.readObject();
  liquid=(TeraArray)in.readObject();
}",0.9303703703703704
1133,"@Override public boolean set(int x,int y,int z,int value,int expected){
  if (!contains(x,y,z))   throw new IndexOutOfBoundsException();
  if (value < 0 || value > 15 || expected < 0 || expected > 15)   throw new IllegalArgumentException();
  int pos=pos(x,y,z);
  if (pos < sizeXYZHalf) {
    int raw=data[pos] & 0xFF;
    byte old=(byte)((raw & 0x0F) & 0xFF);
    if (old == expected) {
      int tmp=value & 0xFF;
      data[pos]=(byte)((tmp & 0x0F) | (raw & 0xF0));
      return true;
    }
    return false;
  }
  int raw=data[pos % sizeXYZHalf] & 0xFF;
  byte old=(byte)(raw >> 4);
  if (old == expected) {
    int tmp=value & 0xFF;
    data[pos % sizeXYZHalf]=(byte)((raw & 0x0F) | (tmp << 4) & 0xFF);
    return true;
  }
  return false;
}","@Override public boolean set(int x,int y,int z,int value,int expected){
  if (!contains(x,y,z))   throw new IndexOutOfBoundsException(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ z+ ""String_Node_Str"");
  if (value < 0 || value > 15)   throw new IllegalArgumentException(""String_Node_Str"" + value + ""String_Node_Str"");
  if (expected < 0 || expected > 15)   throw new IllegalArgumentException(""String_Node_Str"" + value + ""String_Node_Str"");
  int pos=pos(x,y,z);
  if (pos < sizeXYZHalf) {
    int raw=data[pos] & 0xFF;
    byte old=(byte)((raw & 0x0F) & 0xFF);
    if (old == expected) {
      int tmp=value & 0xFF;
      data[pos]=(byte)((tmp & 0x0F) | (raw & 0xF0));
      return true;
    }
    return false;
  }
  int raw=data[pos % sizeXYZHalf] & 0xFF;
  byte old=(byte)(raw >> 4);
  if (old == expected) {
    int tmp=value & 0xFF;
    data[pos % sizeXYZHalf]=(byte)((raw & 0x0F) | (tmp << 4) & 0xFF);
    return true;
  }
  return false;
}",0.8534734384121424
1134,"@Override public int get(int x,int y,int z){
  if (!contains(x,y,z))   throw new IndexOutOfBoundsException();
  int pos=pos(x,y,z);
  if (pos < sizeXYZHalf) {
    int raw=data[pos] & 0xFF;
    return (byte)((raw & 0x0F) & 0xFF);
  }
  int raw=data[pos % sizeXYZHalf] & 0xFF;
  return (byte)(raw >> 4);
}","@Override public int get(int x,int y,int z){
  if (!contains(x,y,z))   throw new IndexOutOfBoundsException(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ z+ ""String_Node_Str"");
  int pos=pos(x,y,z);
  if (pos < sizeXYZHalf) {
    int raw=data[pos] & 0xFF;
    return (byte)((raw & 0x0F) & 0xFF);
  }
  int raw=data[pos % sizeXYZHalf] & 0xFF;
  return (byte)(raw >> 4);
}",0.8769898697539797
1135,"@Override public boolean set(int x,int y,int z,int value,int expected){
  if (!contains(x,y,z))   throw new IndexOutOfBoundsException();
  if (value < 0 || value > 255 || expected < 0 || expected > 255)   throw new IllegalArgumentException();
  int pos=pos(x,y,z);
  int old=data[pos] & 0xFF;
  if (old == expected) {
    data[pos]=(byte)value;
    return true;
  }
  return false;
}","@Override public boolean set(int x,int y,int z,int value,int expected){
  if (!contains(x,y,z))   throw new IndexOutOfBoundsException(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ z+ ""String_Node_Str"");
  if (value < -128 || value > 127)   throw new IllegalArgumentException(""String_Node_Str"" + value + ""String_Node_Str"");
  if (expected < -128 || expected > 127)   throw new IllegalArgumentException(""String_Node_Str"" + value + ""String_Node_Str"");
  int pos=pos(x,y,z);
  int old=data[pos];
  if (old == expected) {
    data[pos]=(byte)value;
    return true;
  }
  return false;
}",0.7215447154471545
1136,"@Override public int get(int x,int y,int z){
  if (!contains(x,y,z))   throw new IndexOutOfBoundsException();
  int pos=pos(x,y,z);
  return data[pos] & 0xFF;
}","@Override public int get(int x,int y,int z){
  if (!contains(x,y,z))   throw new IndexOutOfBoundsException(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ z+ ""String_Node_Str"");
  int pos=pos(x,y,z);
  return data[pos];
}",0.7688442211055276
1137,"@Override public boolean set(int x,int y,int z,int value,int expected){
  if (!contains(x,y,z))   throw new IndexOutOfBoundsException();
  if (value < 0 || value > 255 || expected < 0 || expected > 255)   throw new IllegalArgumentException();
  if (value == expected)   return true;
  byte[] data=inflated[y];
  int pos=z * sizeX + x;
  if (data != null) {
    int old=data[pos] & 0xFF;
    if (old == expected)     data[pos]=(byte)value;
    return old == expected;
  }
  byte old=deflated[y];
  if (old == (byte)expected) {
    data=new byte[sizeXZ];
    Arrays.fill(data,old);
    data[pos]=(byte)value;
    inflated[y]=data;
    return true;
  }
  return false;
}","@Override public boolean set(int x,int y,int z,int value,int expected){
  if (!contains(x,y,z))   throw new IndexOutOfBoundsException(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ z+ ""String_Node_Str"");
  if (value < -128 || value > 127)   throw new IllegalArgumentException(""String_Node_Str"" + value + ""String_Node_Str"");
  if (expected < -128 || expected > 127)   throw new IllegalArgumentException(""String_Node_Str"" + value + ""String_Node_Str"");
  if (value == expected)   return true;
  byte[] data=inflated[y];
  int pos=z * sizeX + x;
  if (data != null) {
    int old=data[pos];
    if (old == expected)     data[pos]=(byte)value;
    return old == expected;
  }
  byte old=deflated[y];
  if (old == (byte)expected) {
    data=new byte[sizeXZ];
    Arrays.fill(data,old);
    data[pos]=(byte)value;
    inflated[y]=data;
    return true;
  }
  return false;
}",0.8234536082474226
1138,"@Override public int get(int x,int y,int z){
  if (!contains(x,y,z))   throw new IndexOutOfBoundsException();
  byte[] data=inflated[y];
  if (data != null)   return data[z * sizeX + x];
  return deflated[y];
}","@Override public int get(int x,int y,int z){
  if (!contains(x,y,z))   throw new IndexOutOfBoundsException(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ z+ ""String_Node_Str"");
  byte[] data=inflated[y];
  if (data != null)   return data[z * sizeX + x];
  return deflated[y];
}",0.8316831683168316
1139,"private void checkChunkReady(Vector3i pos){
  if (worldEntity.exists()) {
    for (    Vector3i adjPos : Region3i.createFromCenterExtents(pos,LOCAL_REGION_EXTENTS)) {
      Chunk chunk=getChunk(pos);
      if (chunk == null || chunk.getChunkState() != Chunk.State.COMPLETE) {
        return;
      }
    }
    worldEntity.send(new ChunkReadyEvent(pos));
  }
}","private void checkChunkReady(Vector3i pos){
  if (worldEntity.exists()) {
    for (    Vector3i adjPos : Region3i.createFromCenterExtents(pos,LOCAL_REGION_EXTENTS)) {
      Chunk chunk=getChunk(adjPos);
      if (chunk == null || chunk.getChunkState() != Chunk.State.COMPLETE) {
        return;
      }
    }
    worldEntity.send(new ChunkReadyEvent(pos));
  }
}",0.9930651872399444
1140,"@Override public void generateChunk(Chunk c){
  double[][][] densityMap=new double[Chunk.SIZE_X + 1][Chunk.SIZE_Y + 1][Chunk.SIZE_Z + 1];
  for (int x=0; x <= Chunk.SIZE_X; x+=SAMPLE_RATE_3D_HOR) {
    for (int z=0; z <= Chunk.SIZE_Z; z+=SAMPLE_RATE_3D_HOR) {
      for (int y=0; y <= Chunk.SIZE_Y; y+=SAMPLE_RATE_3D_VERT) {
        densityMap[x][y][z]=calcDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z));
      }
    }
  }
  triLerpDensityMap(densityMap);
  for (int x=0; x < Chunk.SIZE_X; x++) {
    for (int z=0; z < Chunk.SIZE_Z; z++) {
      WorldBiomeProvider.Biome type=biomeProvider.getBiomeAt(c.getBlockWorldPosX(x),c.getBlockWorldPosZ(z));
      int firstBlockHeight=-1;
      for (int y=Chunk.SIZE_Y; y >= 0; y--) {
        if (y == 0) {
          c.setBlock(x,y,z,mantle);
          break;
        }
        if (y <= 32 && y > 0) {
          c.setBlock(x,y,z,water);
          c.setLiquid(x,y,z,new LiquidData(LiquidType.WATER,Chunk.MAX_LIQUID_DEPTH));
          if (y == 32) {
            if (type == WorldBiomeProvider.Biome.SNOW)             c.setBlock(x,y,z,ice);
          }
        }
        double dens=densityMap[x][y][z];
        if ((dens >= 0 && dens < 32)) {
          if (firstBlockHeight == -1)           firstBlockHeight=y;
          if (calcCaveDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z)) > -0.7)           GenerateOuterLayer(x,y,z,firstBlockHeight,c,type);
 else           c.setBlock(x,y,z,air);
          continue;
        }
 else         if (dens >= 32) {
          if (firstBlockHeight == -1)           firstBlockHeight=y;
          if (calcCaveDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z)) > -0.6)           GenerateInnerLayer(x,y,z,c,type);
 else           c.setBlock(x,y,z,air);
          continue;
        }
        firstBlockHeight=-1;
      }
    }
  }
}","@Override public void generateChunk(Chunk c){
  double[][][] densityMap=new double[Chunk.SIZE_X + 1][Chunk.SIZE_Y + 1][Chunk.SIZE_Z + 1];
  for (int x=0; x <= Chunk.SIZE_X; x+=SAMPLE_RATE_3D_HOR) {
    for (int z=0; z <= Chunk.SIZE_Z; z+=SAMPLE_RATE_3D_HOR) {
      for (int y=0; y <= Chunk.SIZE_Y; y+=SAMPLE_RATE_3D_VERT) {
        densityMap[x][y][z]=calcDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z));
      }
    }
  }
  triLerpDensityMap(densityMap);
  for (int x=0; x < Chunk.SIZE_X; x++) {
    for (int z=0; z < Chunk.SIZE_Z; z++) {
      WorldBiomeProvider.Biome type=biomeProvider.getBiomeAt(c.getBlockWorldPosX(x),c.getBlockWorldPosZ(z));
      int firstBlockHeight=-1;
      for (int y=Chunk.SIZE_Y - 1; y >= 0; y--) {
        if (y == 0) {
          c.setBlock(x,y,z,mantle);
          break;
        }
        if (y <= 32 && y > 0) {
          c.setBlock(x,y,z,water);
          c.setLiquid(x,y,z,new LiquidData(LiquidType.WATER,Chunk.MAX_LIQUID_DEPTH));
          if (y == 32) {
            if (type == WorldBiomeProvider.Biome.SNOW)             c.setBlock(x,y,z,ice);
          }
        }
        double dens=densityMap[x][y][z];
        if ((dens >= 0 && dens < 32)) {
          if (firstBlockHeight == -1)           firstBlockHeight=y;
          if (calcCaveDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z)) > -0.7)           GenerateOuterLayer(x,y,z,firstBlockHeight,c,type);
 else           c.setBlock(x,y,z,air);
          continue;
        }
 else         if (dens >= 32) {
          if (firstBlockHeight == -1)           firstBlockHeight=y;
          if (calcCaveDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z)) > -0.6)           GenerateInnerLayer(x,y,z,c,type);
 else           c.setBlock(x,y,z,air);
          continue;
        }
        firstBlockHeight=-1;
      }
    }
  }
}",0.9989053092501368
1141,"@Override public void generateChunk(Chunk c){
  double[][][] densityMap=new double[Chunk.SIZE_X + 1][Chunk.SIZE_Y + 1][Chunk.SIZE_Z + 1];
  for (int x=0; x <= Chunk.SIZE_X; x+=SAMPLE_RATE_3D_HOR) {
    for (int z=0; z <= Chunk.SIZE_Z; z+=SAMPLE_RATE_3D_HOR) {
      for (int y=0; y <= Chunk.SIZE_Y; y+=SAMPLE_RATE_3D_VERT) {
        densityMap[x][y][z]=calcDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z));
      }
    }
  }
  triLerpDensityMap(densityMap);
  for (int x=0; x < Chunk.SIZE_X; x++) {
    for (int z=0; z < Chunk.SIZE_Z; z++) {
      WorldBiomeProvider.Biome type=biomeProvider.getBiomeAt(c.getBlockWorldPosX(x),c.getBlockWorldPosZ(z));
      int firstBlockHeight=-1;
      for (int y=Chunk.SIZE_Y; y >= 0; y--) {
        if (y == 0) {
          c.setBlock(x,y,z,mantle);
          break;
        }
        if (y <= 32 && y > 0) {
          c.setBlock(x,y,z,water);
          c.setLiquid(x,y,z,new LiquidData(LiquidType.WATER,Chunk.MAX_LIQUID_DEPTH));
          if (y == 32) {
            if (type == WorldBiomeProvider.Biome.SNOW)             c.setBlock(x,y,z,ice);
          }
        }
        double dens=densityMap[x][y][z];
        if ((dens >= 0 && dens < 32)) {
          if (firstBlockHeight == -1)           firstBlockHeight=y;
          if (calcCaveDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z)) > -0.7)           GenerateOuterLayer(x,y,z,firstBlockHeight,c,type);
 else           c.setBlock(x,y,z,air);
          continue;
        }
 else         if (dens >= 32) {
          if (firstBlockHeight == -1)           firstBlockHeight=y;
          if (calcCaveDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z)) > -0.6)           GenerateInnerLayer(x,y,z,c,type);
 else           c.setBlock(x,y,z,air);
          continue;
        }
        firstBlockHeight=-1;
      }
    }
  }
}","@Override public void generateChunk(Chunk c){
  double[][][] densityMap=new double[Chunk.SIZE_X + 1][Chunk.SIZE_Y + 1][Chunk.SIZE_Z + 1];
  for (int x=0; x <= Chunk.SIZE_X; x+=SAMPLE_RATE_3D_HOR) {
    for (int z=0; z <= Chunk.SIZE_Z; z+=SAMPLE_RATE_3D_HOR) {
      for (int y=0; y <= Chunk.SIZE_Y; y+=SAMPLE_RATE_3D_VERT) {
        densityMap[x][y][z]=calcDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z));
      }
    }
  }
  triLerpDensityMap(densityMap);
  for (int x=0; x < Chunk.SIZE_X; x++) {
    for (int z=0; z < Chunk.SIZE_Z; z++) {
      WorldBiomeProvider.Biome type=biomeProvider.getBiomeAt(c.getBlockWorldPosX(x),c.getBlockWorldPosZ(z));
      int firstBlockHeight=-1;
      for (int y=Chunk.SIZE_Y - 1; y >= 0; y--) {
        if (y == 0) {
          c.setBlock(x,y,z,mantle);
          break;
        }
        if (y <= 32 && y > 0) {
          c.setBlock(x,y,z,water);
          c.setLiquid(x,y,z,new LiquidData(LiquidType.WATER,Chunk.MAX_LIQUID_DEPTH));
          if (y == 32) {
            if (type == WorldBiomeProvider.Biome.SNOW)             c.setBlock(x,y,z,ice);
          }
        }
        double dens=densityMap[x][y][z];
        if ((dens >= 0 && dens < 32)) {
          if (firstBlockHeight == -1)           firstBlockHeight=y;
          if (calcCaveDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z)) > -0.7)           GenerateOuterLayer(x,y,z,firstBlockHeight,c,type);
 else           c.setBlock(x,y,z,air);
          continue;
        }
 else         if (dens >= 32) {
          if (firstBlockHeight == -1)           firstBlockHeight=y;
          if (calcCaveDensity(c.getBlockWorldPosX(x),y,c.getBlockWorldPosZ(z)) > -0.6)           GenerateInnerLayer(x,y,z,c,type);
 else           c.setBlock(x,y,z,air);
          continue;
        }
        firstBlockHeight=-1;
      }
    }
  }
}",0.9989053092501368
1142,"private void checkChunkReady(Vector3i pos){
  if (worldEntity.exists()) {
    Chunk chunk=getChunk(pos);
    if (chunk != null && chunk.getChunkState() == Chunk.State.COMPLETE) {
      worldEntity.send(new ChunkReadyEvent(pos));
    }
  }
}","private void checkChunkReady(Vector3i pos){
  if (worldEntity.exists()) {
    for (    Vector3i adjPos : Region3i.createFromCenterExtents(pos,LOCAL_REGION_EXTENTS)) {
      Chunk chunk=getChunk(adjPos);
      if (chunk == null || chunk.getChunkState() != Chunk.State.COMPLETE) {
        return;
      }
    }
    worldEntity.send(new ChunkReadyEvent(pos));
  }
}",0.760797342192691
1143,"private void checkChunkReady(Vector3i pos){
  if (worldEntity.exists()) {
    for (    Vector3i adjPos : Region3i.createFromCenterExtents(pos,LOCAL_REGION_EXTENTS)) {
      Chunk chunk=getChunk(pos);
      if (chunk == null || chunk.getChunkState() != Chunk.State.COMPLETE) {
        return;
      }
    }
    worldEntity.send(new ChunkReadyEvent(pos));
  }
}","private void checkChunkReady(Vector3i pos){
  if (worldEntity.exists()) {
    for (    Vector3i adjPos : Region3i.createFromCenterExtents(pos,LOCAL_REGION_EXTENTS)) {
      Chunk chunk=getChunk(adjPos);
      if (chunk == null || chunk.getChunkState() != Chunk.State.COMPLETE) {
        return;
      }
    }
    worldEntity.send(new ChunkReadyEvent(pos));
  }
}",0.9930651872399444
1144,"@Override public int begin(){
  entityManager=CoreRegistry.get(EntityManager.class);
  worldRenderer=CoreRegistry.get(WorldRenderer.class);
  chunkProvider=worldRenderer.getChunkProvider();
  Iterator<EntityRef> iterator=entityManager.iteratorEntities(LocalPlayerComponent.class).iterator();
  spawningPlayer=!iterator.hasNext();
  if (spawningPlayer) {
    spawnZoneEntity=entityManager.create();
    spawnZoneEntity.addComponent(new LocationComponent(new Vector3f(Chunk.SIZE_X / 2,Chunk.SIZE_Y / 2,Chunk.SIZE_Z / 2)));
    worldRenderer.getChunkProvider().addRegionEntity(spawnZoneEntity,1);
    targetPos=Vector3i.zero();
  }
 else {
    CoreRegistry.get(LocalPlayer.class).setEntity(iterator.next());
    worldRenderer.setPlayer(CoreRegistry.get(LocalPlayer.class));
    targetPos=TeraMath.calcChunkPos(new Vector3i(worldRenderer.getPlayer().getPosition(),0.5f));
  }
  return UNKNOWN_STEPS;
}","@Override public int begin(){
  entityManager=CoreRegistry.get(EntityManager.class);
  worldRenderer=CoreRegistry.get(WorldRenderer.class);
  chunkProvider=worldRenderer.getChunkProvider();
  Iterator<EntityRef> iterator=entityManager.iteratorEntities(LocalPlayerComponent.class).iterator();
  spawningPlayer=!iterator.hasNext();
  if (spawningPlayer) {
    spawnZoneEntity=entityManager.create();
    spawnZoneEntity.addComponent(new LocationComponent(new Vector3f(Chunk.SIZE_X / 2,Chunk.SIZE_Y / 2,Chunk.SIZE_Z / 2)));
    worldRenderer.getChunkProvider().addRegionEntity(spawnZoneEntity,4);
    targetPos=Vector3i.zero();
  }
 else {
    CoreRegistry.get(LocalPlayer.class).setEntity(iterator.next());
    worldRenderer.setPlayer(CoreRegistry.get(LocalPlayer.class));
    targetPos=TeraMath.calcChunkPos(new Vector3i(worldRenderer.getPlayer().getPosition(),0.5f));
  }
  return UNKNOWN_STEPS;
}",0.9988851727982164
1145,"/** 
 * Responsible for tick update - see if we should attempt to spawn something
 * @param delta time step since last update
 */
public void update(float delta){
  tick+=delta * 1000;
  if (tick - lastTick < timeBetweenSpawns) {
    return;
  }
  logger.info(""String_Node_Str"");
  lastTick=tick;
  int maxMobs=entityManager.getComponentCount(SpawnerComponent.class) * maxMobsPerSpawner + maxMobsPerSpawner;
  int currentMobs=entityManager.getComponentCount(SimpleAIComponent.class);
  logger.info(""String_Node_Str"",currentMobs,maxMobs);
  if (currentMobs >= maxMobs) {
    logger.info(""String_Node_Str"");
    return;
  }
  logger.info(""String_Node_Str"",entityManager.getComponentCount(SpawnerComponent.class));
  for (  EntityRef entity : entityManager.iteratorEntities(SpawnerComponent.class,BlockComponent.class)) {
    logger.info(""String_Node_Str"" + entity);
    SpawnerComponent spawnComp=entity.getComponent(SpawnerComponent.class);
    BlockComponent blockComp=entity.getComponent(BlockComponent.class);
    if (currentMobs < maxMobs) {
      Vector3f pos=blockComp.getPosition().toVector3f();
      logger.info(""String_Node_Str"",pos);
      String chosenSpawnerType=spawnComp.types.get(random.randomIntAbs(spawnComp.types.size()));
      Set randomType=typeLists.get(chosenSpawnerType);
      logger.info(""String_Node_Str"",chosenSpawnerType,randomType.size());
      if (randomType.size() == 0) {
        logger.warn(""String_Node_Str"");
        return;
      }
      int anotherRandomIndex=random.randomIntAbs(randomType.size());
      Object[] randomPrefabs=randomType.toArray();
      Prefab chosenPrefab=(Prefab)randomPrefabs[anotherRandomIndex];
      logger.info(""String_Node_Str"",anotherRandomIndex,chosenSpawnerType,chosenPrefab);
      factory.generateGelatinousCube(pos,chosenPrefab);
      currentMobs++;
    }
  }
}","/** 
 * Responsible for tick update - see if we should attempt to spawn something
 * @param delta time step since last update
 */
public void update(float delta){
  tick+=delta * 1000;
  if (tick - lastTick < timeBetweenSpawns) {
    return;
  }
  logger.info(""String_Node_Str"");
  lastTick=tick;
  int maxMobs=entityManager.getComponentCount(SpawnerComponent.class) * maxMobsPerSpawner + maxMobsPerSpawner;
  int currentMobs=entityManager.getComponentCount(SimpleAIComponent.class);
  logger.info(""String_Node_Str"",currentMobs,maxMobs);
  if (currentMobs >= maxMobs) {
    logger.info(""String_Node_Str"");
    return;
  }
  logger.info(""String_Node_Str"",entityManager.getComponentCount(SpawnerComponent.class));
  for (  EntityRef entity : entityManager.iteratorEntities(SpawnerComponent.class,BlockComponent.class)) {
    logger.info(""String_Node_Str"",entity);
    SpawnerComponent spawnComp=entity.getComponent(SpawnerComponent.class);
    int spawnTypes=spawnComp.types.size();
    if (spawnTypes == 0) {
      logger.warn(""String_Node_Str"");
      continue;
    }
    BlockComponent blockComp=entity.getComponent(BlockComponent.class);
    if (currentMobs < maxMobs) {
      Vector3f pos=blockComp.getPosition().toVector3f();
      logger.info(""String_Node_Str"",pos);
      String chosenSpawnerType=spawnComp.types.get(random.randomIntAbs(spawnComp.types.size()));
      Set randomType=typeLists.get(chosenSpawnerType);
      logger.info(""String_Node_Str"",chosenSpawnerType,randomType.size());
      if (randomType.size() == 0) {
        logger.warn(""String_Node_Str"");
        return;
      }
      int anotherRandomIndex=random.randomIntAbs(randomType.size());
      Object[] randomPrefabs=randomType.toArray();
      Prefab chosenPrefab=(Prefab)randomPrefabs[anotherRandomIndex];
      logger.info(""String_Node_Str"",anotherRandomIndex,chosenSpawnerType,chosenPrefab);
      factory.generateGelatinousCube(pos,chosenPrefab);
      currentMobs++;
    }
  }
}",0.9647182727751448
1146,"@ReceiveEvent(components={DoorComponent.class,ItemComponent.class}) public void placeDoor(ActivateEvent event,EntityRef entity){
  DoorComponent door=entity.getComponent(DoorComponent.class);
  BlockComponent targetBlockComp=event.getTarget().getComponent(BlockComponent.class);
  if (targetBlockComp == null) {
    event.cancel();
    return;
  }
  Vector3f horizDir=new Vector3f(event.getDirection());
  horizDir.y=0;
  Side facingDir=Side.inDirection(horizDir);
  if (!facingDir.isHorizontal()) {
    event.cancel();
    return;
  }
  Vector3f offset=new Vector3f(event.getHitPosition());
  offset.sub(targetBlockComp.getPosition().toVector3f());
  Side offsetDir=Side.inDirection(offset);
  Vector3i primePos=new Vector3i(targetBlockComp.getPosition());
  primePos.add(offsetDir.getVector3i());
  Block primeBlock=worldProvider.getBlock(primePos);
  if (!primeBlock.isReplacementAllowed()) {
    event.cancel();
    return;
  }
  Block belowBlock=worldProvider.getBlock(primePos.x,primePos.y - 1,primePos.z);
  Block aboveBlock=worldProvider.getBlock(primePos.x,primePos.y + 1,primePos.z);
  Vector3i bottomBlockPos=null;
  Block bottomBlock=null;
  Vector3i topBlockPos=null;
  Block topBlock=null;
  if (belowBlock.isReplacementAllowed()) {
    bottomBlockPos=new Vector3i(primePos.x,primePos.y - 1,primePos.z);
    bottomBlock=belowBlock;
    topBlockPos=primePos;
    topBlock=primeBlock;
  }
 else   if (aboveBlock.isReplacementAllowed()) {
    bottomBlockPos=primePos;
    bottomBlock=primeBlock;
    topBlockPos=new Vector3i(primePos.x,primePos.y + 1,primePos.z);
    topBlock=aboveBlock;
  }
 else {
    event.cancel();
    return;
  }
  Side attachSide=determineAttachSide(facingDir,offsetDir,bottomBlockPos,topBlockPos);
  if (attachSide == null) {
    event.cancel();
    return;
  }
  worldProvider.setBlock(bottomBlockPos,door.bottomBlockFamily.getBlockFor(facingDir.reverse(),Side.TOP),bottomBlock);
  worldProvider.setBlock(topBlockPos,door.topBlockFamily.getBlockFor(facingDir.reverse(),Side.TOP),topBlock);
  EntityRef newDoor=entityManager.copy(entity);
  newDoor.addComponent(new BlockRegionComponent(Region3i.createBounded(bottomBlockPos,topBlockPos)));
  Vector3f doorCenter=bottomBlockPos.toVector3f();
  doorCenter.y+=0.5f;
  newDoor.addComponent(new LocationComponent(doorCenter));
  DoorComponent newDoorComp=newDoor.getComponent(DoorComponent.class);
  newDoorComp.closedDirection=facingDir.reverse();
  newDoorComp.openDirection=attachSide.reverse();
  newDoorComp.isOpen=false;
  newDoor.saveComponent(newDoorComp);
  newDoor.removeComponent(ItemComponent.class);
  AudioManager.play(new AssetUri(AssetType.SOUND,""String_Node_Str""),0.5f);
}","@ReceiveEvent(components={DoorComponent.class,ItemComponent.class}) public void placeDoor(ActivateEvent event,EntityRef entity){
  DoorComponent door=entity.getComponent(DoorComponent.class);
  BlockComponent targetBlockComp=event.getTarget().getComponent(BlockComponent.class);
  if (targetBlockComp == null) {
    event.cancel();
    return;
  }
  Vector3f horizDir=new Vector3f(event.getDirection());
  horizDir.y=0;
  Side facingDir=Side.inDirection(horizDir);
  if (!facingDir.isHorizontal()) {
    event.cancel();
    return;
  }
  Vector3f offset=new Vector3f(event.getHitPosition());
  offset.sub(targetBlockComp.getPosition().toVector3f());
  Side offsetDir=Side.inDirection(offset);
  Vector3i primePos=new Vector3i(targetBlockComp.getPosition());
  primePos.add(offsetDir.getVector3i());
  Block primeBlock=worldProvider.getBlock(primePos);
  if (!primeBlock.isReplacementAllowed()) {
    event.cancel();
    return;
  }
  Block belowBlock=worldProvider.getBlock(primePos.x,primePos.y - 1,primePos.z);
  Block aboveBlock=worldProvider.getBlock(primePos.x,primePos.y + 1,primePos.z);
  Vector3i bottomBlockPos=null;
  Block bottomBlock=null;
  Vector3i topBlockPos=null;
  Block topBlock=null;
  if (belowBlock.isReplacementAllowed()) {
    bottomBlockPos=new Vector3i(primePos.x,primePos.y - 1,primePos.z);
    bottomBlock=belowBlock;
    topBlockPos=primePos;
    topBlock=primeBlock;
  }
 else   if (aboveBlock.isReplacementAllowed()) {
    bottomBlockPos=primePos;
    bottomBlock=primeBlock;
    topBlockPos=new Vector3i(primePos.x,primePos.y + 1,primePos.z);
    topBlock=aboveBlock;
  }
 else {
    event.cancel();
    return;
  }
  Side attachSide=determineAttachSide(facingDir,offsetDir,bottomBlockPos,topBlockPos);
  if (attachSide == null) {
    event.cancel();
    return;
  }
  Side closedSide=facingDir.reverse();
  if (closedSide == attachSide || closedSide.reverse() == attachSide) {
    closedSide=attachSide.rotateClockwise(1);
  }
  worldProvider.setBlock(bottomBlockPos,door.bottomBlockFamily.getBlockFor(closedSide,Side.TOP),bottomBlock);
  worldProvider.setBlock(topBlockPos,door.topBlockFamily.getBlockFor(closedSide,Side.TOP),topBlock);
  EntityRef newDoor=entityManager.copy(entity);
  newDoor.addComponent(new BlockRegionComponent(Region3i.createBounded(bottomBlockPos,topBlockPos)));
  Vector3f doorCenter=bottomBlockPos.toVector3f();
  doorCenter.y+=0.5f;
  newDoor.addComponent(new LocationComponent(doorCenter));
  DoorComponent newDoorComp=newDoor.getComponent(DoorComponent.class);
  newDoorComp.closedDirection=closedSide;
  newDoorComp.openDirection=attachSide.reverse();
  newDoorComp.isOpen=false;
  newDoor.saveComponent(newDoorComp);
  newDoor.removeComponent(ItemComponent.class);
  AudioManager.play(new AssetUri(AssetType.SOUND,""String_Node_Str""),0.5f);
  logger.info(""String_Node_Str"",newDoorComp.closedDirection);
  logger.info(""String_Node_Str"",newDoorComp.openDirection);
}",0.9310714285714284
1147,"/** 
 * Place the item in the transfer slot directly on the target cell.
 * @param targetCell The target cell to move the item to.
 * @param amount The amount to place. 0 for whole stack.
 */
private static boolean moveItemPlace(UIItemCell targetCell,byte amount){
  EntityRef item=getFromTransferSlot();
  ItemComponent sourceItem=item.getComponent(ItemComponent.class);
  InventoryComponent targetInventory=targetCell.getOwnerEntity().getComponent(InventoryComponent.class);
  if (!targetInventory.itemSlots.get(targetCell.slot).exists()) {
    if (amount == 0) {
      amount=sourceItem.stackCount;
    }
    EntityManager entityManager=CoreRegistry.get(EntityManager.class);
    EntityRef copy=entityManager.copy(item);
    ItemComponent copyItem=copy.getComponent(ItemComponent.class);
    amount=(byte)Math.min(amount,sourceItem.stackCount);
    if (sourceItem.stackCount > amount) {
      sourceItem.stackCount-=amount;
      copyItem.stackCount=amount;
      copyItem.container=targetCell.ownerEntity;
      targetInventory.itemSlots.set(targetCell.slot,copy);
      return true;
    }
 else {
      targetInventory.itemSlots.set(targetCell.slot,item);
      sendToTransferSlot(null,(byte)0);
      return true;
    }
  }
  return false;
}","/** 
 * Place the item in the transfer slot directly on the target cell.
 * @param targetCell The target cell to move the item to.
 * @param amount The amount to place. 0 for whole stack.
 */
private static boolean moveItemPlace(UIItemCell targetCell,byte amount){
  EntityRef item=getFromTransferSlot();
  ItemComponent sourceItem=item.getComponent(ItemComponent.class);
  InventoryComponent targetInventory=targetCell.getOwnerEntity().getComponent(InventoryComponent.class);
  if (!targetInventory.itemSlots.get(targetCell.slot).exists()) {
    if (amount == 0) {
      amount=sourceItem.stackCount;
    }
    EntityManager entityManager=CoreRegistry.get(EntityManager.class);
    EntityRef copy=entityManager.copy(item);
    ItemComponent copyItem=copy.getComponent(ItemComponent.class);
    amount=(byte)Math.min(amount,sourceItem.stackCount);
    if (sourceItem.stackCount > amount) {
      sourceItem.stackCount-=amount;
      copyItem.stackCount=amount;
      copyItem.container=targetCell.ownerEntity;
      targetInventory.itemSlots.set(targetCell.slot,copy);
      return true;
    }
 else {
      sourceItem.container=targetCell.ownerEntity;
      targetInventory.itemSlots.set(targetCell.slot,item);
      sendToTransferSlot(null,(byte)0);
      return true;
    }
  }
  return false;
}",0.9799607072691552
1148,"/** 
 * Update the transfer icon position to the current mouse position.
 */
private void moveTransferIcon(){
  if (ownerEntity.getComponent(InventoryComponent.class) != null) {
    if (getFromTransferSlot().exists()) {
      ItemComponent item=getFromTransferSlot().getComponent(ItemComponent.class);
      if (item.container == ownerEntity) {
        transferIcon.setPosition(new Vector2f(Mouse.getX() - getSize().x / 2,Display.getHeight() - Mouse.getY() - getSize().y / 2));
      }
    }
  }
}","/** 
 * Update the transfer icon position to the current mouse position. TODO all item cells with the same ownerEntity are updating the position -> just the dragged (source) item cell should update the position
 */
private void moveTransferIcon(){
  if (ownerEntity.getComponent(InventoryComponent.class) != null) {
    if (getFromTransferSlot().exists()) {
      ItemComponent item=getFromTransferSlot().getComponent(ItemComponent.class);
      if (item.container == ownerEntity) {
        transferIcon.setPosition(new Vector2f(Mouse.getX() - getSize().x / 2,Display.getHeight() - Mouse.getY() - getSize().y / 2));
      }
    }
  }
}",0.8780918727915195
1149,"/** 
 * Processes the given keyboard input.
 * @param event The key event
 */
public void processKeyboardInput(KeyEvent event){
  super.processKeyboardInput(event);
  if (!isVisible())   return;
  if (!event.isDown()) {
    return;
  }
switch (event.getKey()) {
case Keyboard.KEY_BACK:
    int length=_consoleInput.length() - 1;
  if (length < 0) {
    length=0;
  }
_consoleInput.setLength(length);
break;
case Keyboard.KEY_RETURN:
processConsoleString();
break;
case Keyboard.KEY_UP:
rotateRingBuffer(1);
break;
case Keyboard.KEY_DOWN:
rotateRingBuffer(-1);
break;
default :
char c=event.getKeyCharacter();
if (!Character.isISOControl(c)) {
_consoleInput.append(c);
}
break;
}
}","/** 
 * Processes the given keyboard input.
 * @param event The key event
 */
public void processKeyboardInput(KeyEvent event){
  super.processKeyboardInput(event);
  if (!isVisible())   return;
  if (!event.isDown()) {
    return;
  }
switch (event.getKey()) {
case Keyboard.KEY_BACK:
    int length=_consoleInput.length() - 1;
  if (length < 0) {
    length=0;
  }
_consoleInput.setLength(length);
event.consume();
break;
case Keyboard.KEY_RETURN:
processConsoleString();
event.consume();
break;
case Keyboard.KEY_UP:
rotateRingBuffer(1);
event.consume();
break;
case Keyboard.KEY_DOWN:
rotateRingBuffer(-1);
event.consume();
break;
default :
char c=event.getKeyCharacter();
if (!Character.isISOControl(c)) {
_consoleInput.append(c);
event.consume();
}
break;
}
}",0.9411764705882352
1150,"@Override public void update(float delta){
  DynamicsWorld world=physics.getWorld();
  ObjectArrayList<PersistentManifold> manifolds=new ObjectArrayList<PersistentManifold>();
  for (  PairCachingGhostObject trigger : entityTriggers.values()) {
    EntityRef entity=(EntityRef)trigger.getUserPointer();
    for (    BroadphasePair initialPair : trigger.getOverlappingPairCache().getOverlappingPairArray()) {
      EntityRef otherEntity=null;
      if (initialPair.pProxy0.clientObject == trigger) {
        if (((CollisionObject)initialPair.pProxy1.clientObject).getUserPointer() instanceof EntityRef) {
          otherEntity=(EntityRef)((CollisionObject)initialPair.pProxy1.clientObject).getUserPointer();
        }
      }
 else {
        if (((CollisionObject)initialPair.pProxy0.clientObject).getUserPointer() instanceof EntityRef) {
          otherEntity=(EntityRef)((CollisionObject)initialPair.pProxy0.clientObject).getUserPointer();
        }
      }
      if (otherEntity == null) {
        continue;
      }
      BroadphasePair pair=world.getPairCache().findPair(initialPair.pProxy0,initialPair.pProxy1);
      if (pair == null) {
        continue;
      }
      manifolds.clear();
      if (pair.algorithm != null) {
        pair.algorithm.getAllContactManifolds(manifolds);
      }
      for (      PersistentManifold manifold : manifolds) {
        for (int point=0; point < manifold.getNumContacts(); ++point) {
          ManifoldPoint manifoldPoint=manifold.getContactPoint(point);
          if (manifoldPoint.getDistance() < 0) {
            entity.send(new CollideEvent(otherEntity));
            otherEntity.send(new CollideEvent(entity));
            break;
          }
        }
      }
    }
    LocationComponent location=entity.getComponent(LocationComponent.class);
    if (location != null) {
      trigger.setWorldTransform(new Transform(new Matrix4f(location.getWorldRotation(),location.getWorldPosition(),1.0f)));
    }
  }
}","@Override public void update(float delta){
  List<CollisionPair> collisionPairs=Lists.newArrayList();
  DynamicsWorld world=physics.getWorld();
  ObjectArrayList<PersistentManifold> manifolds=new ObjectArrayList<PersistentManifold>();
  for (  PairCachingGhostObject trigger : entityTriggers.values()) {
    EntityRef entity=(EntityRef)trigger.getUserPointer();
    for (    BroadphasePair initialPair : trigger.getOverlappingPairCache().getOverlappingPairArray()) {
      EntityRef otherEntity=null;
      if (initialPair.pProxy0.clientObject == trigger) {
        if (((CollisionObject)initialPair.pProxy1.clientObject).getUserPointer() instanceof EntityRef) {
          otherEntity=(EntityRef)((CollisionObject)initialPair.pProxy1.clientObject).getUserPointer();
        }
      }
 else {
        if (((CollisionObject)initialPair.pProxy0.clientObject).getUserPointer() instanceof EntityRef) {
          otherEntity=(EntityRef)((CollisionObject)initialPair.pProxy0.clientObject).getUserPointer();
        }
      }
      if (otherEntity == null) {
        continue;
      }
      BroadphasePair pair=world.getPairCache().findPair(initialPair.pProxy0,initialPair.pProxy1);
      if (pair == null) {
        continue;
      }
      manifolds.clear();
      if (pair.algorithm != null) {
        pair.algorithm.getAllContactManifolds(manifolds);
      }
      for (      PersistentManifold manifold : manifolds) {
        for (int point=0; point < manifold.getNumContacts(); ++point) {
          ManifoldPoint manifoldPoint=manifold.getContactPoint(point);
          if (manifoldPoint.getDistance() < 0) {
            collisionPairs.add(new CollisionPair(entity,otherEntity));
            break;
          }
        }
      }
    }
    LocationComponent location=entity.getComponent(LocationComponent.class);
    if (location != null) {
      trigger.setWorldTransform(new Transform(new Matrix4f(location.getWorldRotation(),location.getWorldPosition(),1.0f)));
    }
  }
  for (  CollisionPair pair : collisionPairs) {
    if (pair.b.exists()) {
      pair.a.send(new CollideEvent(pair.b));
    }
    if (pair.a.exists()) {
      pair.b.send(new CollideEvent(pair.a));
    }
  }
}",0.787614900822448
1151,"public void init(GameEngine engine){
  ModManager modManager=new ModManager();
  for (  Mod mod : modManager.getMods()) {
    mod.setEnabled(true);
  }
  modManager.saveModSelectionToConfig();
  AssetManager.getInstance().clear();
  BlockManager.getInstance().load(worldInfo.getBlockIdMap());
  cacheTextures();
  entityManager=new EntitySystemBuilder().build();
  eventSystem=CoreRegistry.get(EventSystem.class);
  componentSystemManager=new ComponentSystemManager();
  CoreRegistry.put(ComponentSystemManager.class,componentSystemManager);
  localPlayerSys=new LocalPlayerSystem();
  componentSystemManager.register(localPlayerSys,""String_Node_Str"");
  cameraTargetSystem=new CameraTargetSystem();
  CoreRegistry.put(CameraTargetSystem.class,cameraTargetSystem);
  componentSystemManager.register(cameraTargetSystem,""String_Node_Str"");
  inputSystem=new InputSystem();
  CoreRegistry.put(InputSystem.class,inputSystem);
  componentSystemManager.register(inputSystem,""String_Node_Str"");
  componentSystemManager.loadEngineSystems();
  componentSystemManager.loadSystems(""String_Node_Str"",""String_Node_Str"");
  CoreRegistry.put(WorldPersister.class,new WorldPersister(entityManager));
  loadPrefabs();
}","public void init(GameEngine engine){
  ModManager modManager=new ModManager();
  for (  Mod mod : modManager.getMods()) {
    mod.setEnabled(true);
  }
  modManager.saveModSelectionToConfig();
  AssetManager.getInstance().clear();
  BlockManager.getInstance().load(worldInfo.getBlockIdMap());
  cacheTextures();
  cacheBlockMesh();
  entityManager=new EntitySystemBuilder().build();
  eventSystem=CoreRegistry.get(EventSystem.class);
  componentSystemManager=new ComponentSystemManager();
  CoreRegistry.put(ComponentSystemManager.class,componentSystemManager);
  localPlayerSys=new LocalPlayerSystem();
  componentSystemManager.register(localPlayerSys,""String_Node_Str"");
  cameraTargetSystem=new CameraTargetSystem();
  CoreRegistry.put(CameraTargetSystem.class,cameraTargetSystem);
  componentSystemManager.register(cameraTargetSystem,""String_Node_Str"");
  inputSystem=new InputSystem();
  CoreRegistry.put(InputSystem.class,inputSystem);
  componentSystemManager.register(inputSystem,""String_Node_Str"");
  componentSystemManager.loadEngineSystems();
  componentSystemManager.loadSystems(""String_Node_Str"",""String_Node_Str"");
  CoreRegistry.put(WorldPersister.class,new WorldPersister(entityManager));
  loadPrefabs();
}",0.9917559769167352
1152,"private void prepareWorld(){
  UIScreenLoading loadingScreen=GUIManager.getInstance().addWindow(new UIScreenLoading(),""String_Node_Str"");
  GUIManager.getInstance().setFocusedWindow(loadingScreen);
  Display.update();
  Timer timer=CoreRegistry.get(Timer.class);
  long startTime=timer.getTimeInMs();
  Iterator<EntityRef> iterator=entityManager.iteratorEntities(LocalPlayerComponent.class).iterator();
  if (iterator.hasNext()) {
    CoreRegistry.get(LocalPlayer.class).setEntity(iterator.next());
    worldRenderer.setPlayer(CoreRegistry.get(LocalPlayer.class));
  }
 else {
    EntityRef spawnZoneEntity=entityManager.create();
    spawnZoneEntity.addComponent(new LocationComponent(new Vector3f(Chunk.SIZE_X / 2,Chunk.SIZE_Y / 2,Chunk.SIZE_Z / 2)));
    worldRenderer.getChunkProvider().addRegionEntity(spawnZoneEntity,1);
    while (!worldRenderer.getWorldProvider().isBlockActive(new Vector3i(Chunk.SIZE_X / 2,Chunk.SIZE_Y / 2,Chunk.SIZE_Z / 2))) {
      loadingScreen.updateStatus(String.format(""String_Node_Str"",(timer.getTimeInMs() - startTime) / 50.0f),(timer.getTimeInMs() - startTime) / 50.0f);
      renderUserInterface();
      updateUserInterface();
      Display.update();
    }
    Vector3i spawnPoint=new Vector3i(Chunk.SIZE_X / 2,Chunk.SIZE_Y,Chunk.SIZE_Z / 2);
    while (worldRenderer.getWorldProvider().getBlock(spawnPoint) == BlockManager.getInstance().getAir() && spawnPoint.y > 0) {
      spawnPoint.y--;
    }
    PlayerFactory playerFactory=new PlayerFactory(entityManager);
    CoreRegistry.get(LocalPlayer.class).setEntity(playerFactory.newInstance(new Vector3f(spawnPoint.x,spawnPoint.y + 1.5f,spawnPoint.z)));
    worldRenderer.setPlayer(CoreRegistry.get(LocalPlayer.class));
    worldRenderer.getChunkProvider().removeRegionEntity(spawnZoneEntity);
    spawnZoneEntity.destroy();
  }
  while (!getWorldRenderer().pregenerateChunks() && timer.getTimeInMs() - startTime < 5000) {
    loadingScreen.updateStatus(String.format(""String_Node_Str"",(timer.getTimeInMs() - startTime) / 50.0f),(timer.getTimeInMs() - startTime) / 50.0f);
    renderUserInterface();
    updateUserInterface();
    Display.update();
  }
  EntityRef playerEntity=CoreRegistry.get(LocalPlayer.class).getEntity();
  LocalPlayerComponent localPlayerComponent=playerEntity.getComponent(LocalPlayerComponent.class);
  if (localPlayerComponent.isDead) {
    playerEntity.send(new RespawnEvent());
  }
  GUIManager.getInstance().removeWindow(loadingScreen);
  GUIManager.getInstance().setFocusedWindow(MenuControlSystem.HUD);
  worldRenderer.initPortal();
}","private void prepareWorld(){
  UIScreenLoading loadingScreen=GUIManager.getInstance().addWindow(new UIScreenLoading(),""String_Node_Str"");
  GUIManager.getInstance().setFocusedWindow(loadingScreen);
  Display.update();
  Timer timer=CoreRegistry.get(Timer.class);
  long startTime=timer.getTimeInMs();
  Iterator<EntityRef> iterator=entityManager.iteratorEntities(LocalPlayerComponent.class).iterator();
  if (iterator.hasNext()) {
    CoreRegistry.get(LocalPlayer.class).setEntity(iterator.next());
    worldRenderer.setPlayer(CoreRegistry.get(LocalPlayer.class));
  }
 else {
    EntityRef spawnZoneEntity=entityManager.create();
    spawnZoneEntity.addComponent(new LocationComponent(new Vector3f(Chunk.SIZE_X / 2,Chunk.SIZE_Y / 2,Chunk.SIZE_Z / 2)));
    worldRenderer.getChunkProvider().addRegionEntity(spawnZoneEntity,1);
    while (!worldRenderer.getWorldProvider().isBlockActive(new Vector3i(Chunk.SIZE_X / 2,Chunk.SIZE_Y / 2,Chunk.SIZE_Z / 2))) {
      loadingScreen.updateStatus(String.format(""String_Node_Str"",(timer.getTimeInMs() - startTime) / 50.0f),(timer.getTimeInMs() - startTime) / 50.0f);
      renderUserInterface();
      updateUserInterface();
      Display.update();
    }
    Vector3i spawnPoint=new Vector3i(Chunk.SIZE_X / 2,Chunk.SIZE_Y,Chunk.SIZE_Z / 2);
    while (worldRenderer.getWorldProvider().getBlock(spawnPoint) == BlockManager.getInstance().getAir() && spawnPoint.y > 0) {
      spawnPoint.y--;
    }
    PlayerFactory playerFactory=new PlayerFactory(entityManager);
    CoreRegistry.get(LocalPlayer.class).setEntity(playerFactory.newInstance(new Vector3f(spawnPoint.x,spawnPoint.y + 1.5f,spawnPoint.z)));
    worldRenderer.setPlayer(CoreRegistry.get(LocalPlayer.class));
    worldRenderer.getChunkProvider().removeRegionEntity(spawnZoneEntity);
    spawnZoneEntity.destroy();
  }
  while (!getWorldRenderer().pregenerateChunks() && timer.getTimeInMs() - startTime < 5000) {
    loadingScreen.updateStatus(String.format(""String_Node_Str"",(timer.getTimeInMs() - startTime) / 50.0f),(timer.getTimeInMs() - startTime) / 50.0f);
    renderUserInterface();
    updateUserInterface();
    Display.update();
  }
  EntityRef playerEntity=CoreRegistry.get(LocalPlayer.class).getEntity();
  LocalPlayerComponent localPlayerComponent=playerEntity.getComponent(LocalPlayerComponent.class);
  if (localPlayerComponent.isDead) {
    playerEntity.send(new RespawnEvent());
  }
  GUIManager.getInstance().removeWindow(loadingScreen);
  GUIManager.getInstance().setFocusedWindow(MenuControlSystem.HUD);
  worldRenderer.initPortal();
  worldRenderer.getWorldProvider().setTime(worldInfo.getTime());
}",0.987425033855678
1153,"@Override public void update(float delta){
  List<CollisionPair> collisionPairs=Lists.newArrayList();
  DynamicsWorld world=physics.getWorld();
  ObjectArrayList<PersistentManifold> manifolds=new ObjectArrayList<PersistentManifold>();
  for (  PairCachingGhostObject trigger : entityTriggers.values()) {
    EntityRef entity=(EntityRef)trigger.getUserPointer();
    for (    BroadphasePair initialPair : trigger.getOverlappingPairCache().getOverlappingPairArray()) {
      EntityRef otherEntity=null;
      if (initialPair.pProxy0.clientObject == trigger) {
        if (((CollisionObject)initialPair.pProxy1.clientObject).getUserPointer() instanceof EntityRef) {
          otherEntity=(EntityRef)((CollisionObject)initialPair.pProxy1.clientObject).getUserPointer();
        }
      }
 else {
        if (((CollisionObject)initialPair.pProxy0.clientObject).getUserPointer() instanceof EntityRef) {
          otherEntity=(EntityRef)((CollisionObject)initialPair.pProxy0.clientObject).getUserPointer();
        }
      }
      if (otherEntity == null) {
        continue;
      }
      BroadphasePair pair=world.getPairCache().findPair(initialPair.pProxy0,initialPair.pProxy1);
      if (pair == null) {
        continue;
      }
      manifolds.clear();
      if (pair.algorithm != null) {
        pair.algorithm.getAllContactManifolds(manifolds);
      }
      for (      PersistentManifold manifold : manifolds) {
        for (int point=0; point < manifold.getNumContacts(); ++point) {
          ManifoldPoint manifoldPoint=manifold.getContactPoint(point);
          if (manifoldPoint.getDistance() < 0) {
            collisionPairs.add(new CollisionPair(entity,otherEntity));
            break;
          }
        }
      }
    }
  }
  for (  CollisionPair pair : collisionPairs) {
    if (pair.b.exists()) {
      pair.a.send(new CollideEvent(pair.b));
    }
    if (pair.a.exists()) {
      pair.b.send(new CollideEvent(pair.a));
    }
  }
}","@Override public void update(float delta){
  if (skipProcessingFrames > 0) {
    skipProcessingFrames--;
    return;
  }
  List<CollisionPair> collisionPairs=Lists.newArrayList();
  DynamicsWorld world=physics.getWorld();
  ObjectArrayList<PersistentManifold> manifolds=new ObjectArrayList<PersistentManifold>();
  for (  PairCachingGhostObject trigger : entityTriggers.values()) {
    EntityRef entity=(EntityRef)trigger.getUserPointer();
    for (    BroadphasePair initialPair : trigger.getOverlappingPairCache().getOverlappingPairArray()) {
      EntityRef otherEntity=null;
      if (initialPair.pProxy0.clientObject == trigger) {
        if (((CollisionObject)initialPair.pProxy1.clientObject).getUserPointer() instanceof EntityRef) {
          otherEntity=(EntityRef)((CollisionObject)initialPair.pProxy1.clientObject).getUserPointer();
        }
      }
 else {
        if (((CollisionObject)initialPair.pProxy0.clientObject).getUserPointer() instanceof EntityRef) {
          otherEntity=(EntityRef)((CollisionObject)initialPair.pProxy0.clientObject).getUserPointer();
        }
      }
      if (otherEntity == null) {
        continue;
      }
      BroadphasePair pair=world.getPairCache().findPair(initialPair.pProxy0,initialPair.pProxy1);
      if (pair == null) {
        continue;
      }
      manifolds.clear();
      if (pair.algorithm != null) {
        pair.algorithm.getAllContactManifolds(manifolds);
      }
      for (      PersistentManifold manifold : manifolds) {
        for (int point=0; point < manifold.getNumContacts(); ++point) {
          ManifoldPoint manifoldPoint=manifold.getContactPoint(point);
          if (manifoldPoint.getDistance() < 0) {
            collisionPairs.add(new CollisionPair(entity,otherEntity));
            break;
          }
        }
      }
    }
  }
  for (  CollisionPair pair : collisionPairs) {
    if (pair.b.exists()) {
      pair.a.send(new CollideEvent(pair.b));
    }
    if (pair.a.exists()) {
      pair.b.send(new CollideEvent(pair.a));
    }
  }
}",0.980342741935484
1154,"@Override public void initialise(){
  physics=CoreRegistry.get(BulletPhysics.class);
}","@Override public void initialise(){
  physics=CoreRegistry.get(BulletPhysics.class);
  skipProcessingFrames=4;
}",0.8686868686868687
1155,"private void generateMesh(){
  Tessellator tessellator=new Tessellator();
  for (  BlockPart dir : BlockPart.values()) {
    BlockMeshPart part=meshPart.get(dir);
    if (part != null) {
      float lightLevel=DIRECTION_LIT_LEVEL.get(dir);
      tessellator.setColor(new Vector4f(lightLevel,lightLevel,lightLevel,lightLevel));
      tessellator.addMeshPart(part);
    }
  }
  mesh=tessellator.generateMesh(new AssetUri(AssetType.MESH,uri.toString()));
}","private void generateMesh(){
  Tessellator tessellator=new Tessellator();
  for (  BlockPart dir : BlockPart.values()) {
    BlockMeshPart part=meshPart.get(dir);
    if (part != null) {
      float lightLevel=DIRECTION_LIT_LEVEL.get(dir);
      tessellator.setColor(new Vector4f(lightLevel,lightLevel,lightLevel,lightLevel));
      tessellator.addMeshPart(part);
    }
  }
  mesh=tessellator.generateMesh(new AssetUri(AssetType.MESH,uri.toString()));
  AssetManager.getInstance().addAssetTemporary(mesh.getURI(),mesh);
}",0.9301848049281314
1156,"private BufferedImage generateAtlas(int mipMapLevel){
  int size=Block.ATLAS_SIZE_IN_PX / (1 << mipMapLevel);
  int textureSize=Block.TEXTURE_SIZE_IN_PX / (1 << mipMapLevel);
  BufferedImage result=new BufferedImage(size,size,BufferedImage.TYPE_INT_ARGB);
  Graphics g=result.getGraphics();
  if (tiles.size() > MAX_TILES) {
    logger.severe(""String_Node_Str"");
  }
  g.setColor(new Color(0,0,0));
  g.drawRect(0,0,textureSize,textureSize);
  for (int index=0; index < tiles.size() && index < MAX_TILES; ++index) {
    Tile tile=tiles.get(index);
    int posX=(index) % Block.ATLAS_ELEMENTS_PER_ROW_AND_COLUMN;
    int posY=(index) / Block.ATLAS_ELEMENTS_PER_ROW_AND_COLUMN;
    g.drawImage(tile.getImage().getScaledInstance(textureSize,textureSize,Image.SCALE_SMOOTH),posX * textureSize,posY * textureSize,null);
  }
  return result;
}","private BufferedImage generateAtlas(int mipMapLevel){
  int size=Block.ATLAS_SIZE_IN_PX / (1 << mipMapLevel);
  int textureSize=Block.TEXTURE_SIZE_IN_PX / (1 << mipMapLevel);
  BufferedImage result=new BufferedImage(size,size,BufferedImage.TYPE_INT_ARGB);
  Graphics g=result.getGraphics();
  if (tiles.size() > MAX_TILES) {
    logger.severe(""String_Node_Str"");
  }
  for (int index=0; index < tiles.size() && index < MAX_TILES; ++index) {
    Tile tile=tiles.get(index);
    int posX=(index) % Block.ATLAS_ELEMENTS_PER_ROW_AND_COLUMN;
    int posY=(index) / Block.ATLAS_ELEMENTS_PER_ROW_AND_COLUMN;
    g.drawImage(tile.getImage().getScaledInstance(textureSize,textureSize,Image.SCALE_SMOOTH),posX * textureSize,posY * textureSize,null);
  }
  return result;
}",0.953095684803002
1157,"private int strToKey(String skey){
  if (skey.startsWith(""String_Node_Str"")) {
    if (skey == ""String_Node_Str"") {
      return 256;
    }
 else     if (skey == ""String_Node_Str"") {
      return 257;
    }
 else     if (skey == ""String_Node_Str"") {
      return 258;
    }
 else     if (skey == ""String_Node_Str"") {
      return 259;
    }
 else     if (skey == ""String_Node_Str"") {
      return 260;
    }
 else {
      return 261;
    }
  }
 else {
    return Keyboard.getKeyIndex(skey);
  }
}","private int strToKey(String skey){
  if (skey.startsWith(""String_Node_Str"")) {
    if (skey.equals(""String_Node_Str"")) {
      return 256;
    }
 else     if (skey.equals(""String_Node_Str"")) {
      return 257;
    }
 else     if (skey.equals(""String_Node_Str"")) {
      return 258;
    }
 else     if (skey.equals(""String_Node_Str"")) {
      return 259;
    }
 else     if (skey.equals(""String_Node_Str"")) {
      return 260;
    }
 else {
      return 261;
    }
  }
 else {
    return Keyboard.getKeyIndex(skey);
  }
}",0.9360865290068828
1158,"private ChunkGeneratorManager initChunkGeneratorManager(String title){
  ChunkGeneratorManager chunkGeneratorManager=null;
  File generatorDataFile=new File(PathManager.getInstance().getWorldSavePath(title),CHUNK_GENERATOR_FILE);
  try {
    chunkGeneratorManager=new ChunkGeneratorPersister().load(generatorDataFile);
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,""String_Node_Str"",e);
  }
  if (chunkGeneratorManager == null) {
switch (Config.getInstance().getChunkGenerator()) {
case 1:
      chunkGeneratorManager=new ChunkGeneratorManagerImpl();
    chunkGeneratorManager.registerChunkGenerator(new FlatTerrainGenerator());
  chunkGeneratorManager.registerChunkGenerator(new FloraGenerator());
chunkGeneratorManager.registerChunkGenerator(new LiquidsGenerator());
break;
default :
chunkGeneratorManager=ChunkGeneratorManagerImpl.getDefaultInstance();
}
try {
new ChunkGeneratorPersister().save(generatorDataFile,chunkGeneratorManager);
}
 catch (IOException e) {
logger.log(Level.SEVERE,""String_Node_Str"",e);
}
}
return chunkGeneratorManager;
}","private ChunkGeneratorManager initChunkGeneratorManager(String title){
  ChunkGeneratorManager chunkGeneratorManager=null;
  File generatorDataFile=new File(PathManager.getInstance().getWorldSavePath(title),CHUNK_GENERATOR_FILE);
  try {
    chunkGeneratorManager=new ChunkGeneratorPersister().load(generatorDataFile);
  }
 catch (  IOException e) {
    logger.log(Level.SEVERE,""String_Node_Str"",e);
  }
  if (chunkGeneratorManager == null) {
switch (Config.getInstance().getChunkGenerator()) {
case 1:
      chunkGeneratorManager=ChunkGeneratorManagerImpl.getFlatInstance();
    break;
default :
  chunkGeneratorManager=ChunkGeneratorManagerImpl.getDefaultInstance();
}
try {
new ChunkGeneratorPersister().save(generatorDataFile,chunkGeneratorManager);
}
 catch (IOException e) {
logger.log(Level.SEVERE,""String_Node_Str"",e);
}
}
return chunkGeneratorManager;
}",0.8647242455775234
1159,"public ChunkGeneratorManager load(final File file) throws IOException {
  final FileInputStream in=new FileInputStream(file);
  ChunkGeneratorManager chunkGeneratorManager=null;
  try {
    final BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(in));
    chunkGeneratorManager=ChunkGeneratorJSONFormat.read(bufferedReader);
  }
  finally {
    try {
      in.close();
    }
 catch (    final IOException e) {
      logger.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
  return chunkGeneratorManager;
}","public ChunkGeneratorManager load(final File file) throws IOException {
  ChunkGeneratorManager chunkGeneratorManager=null;
  if (file.exists()) {
    final FileInputStream in=new FileInputStream(file);
    try {
      final BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(in));
      chunkGeneratorManager=ChunkGeneratorJSONFormat.read(bufferedReader);
    }
  finally {
      try {
        in.close();
      }
 catch (      final IOException e) {
        logger.log(Level.SEVERE,""String_Node_Str"",e);
      }
    }
  }
  return chunkGeneratorManager;
}",0.8558476881233001
1160,"private Vector3d getCameraPosition(){
  return CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
}","private Vector3f getCameraPosition(){
  return CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
}",0.9915966386554622
1161,"protected void updatePosition(Vector3d position){
  float[] pos=new float[]{(float)position.x,(float)position.y,(float)position.z};
  if (isAbsolute()) {
    Vector3d cameraPos=getCameraPosition();
    pos[0]-=cameraPos.x;
    pos[1]-=cameraPos.y;
    pos[2]-=cameraPos.z;
  }
  alSource3f(getSourceId(),AL10.AL_POSITION,pos[0],pos[1],pos[2]);
  OpenALException.checkState(""String_Node_Str"");
}","protected void updatePosition(Vector3d position){
  float[] pos=new float[]{(float)position.x,(float)position.y,(float)position.z};
  if (isAbsolute()) {
    Vector3f cameraPos=getCameraPosition();
    pos[0]-=cameraPos.x;
    pos[1]-=cameraPos.y;
    pos[2]-=cameraPos.z;
  }
  alSource3f(getSourceId(),AL10.AL_POSITION,pos[0],pos[1],pos[2]);
  OpenALException.checkState(""String_Node_Str"");
}",0.9974619289340102
1162,"@Override protected boolean checkDistance(Vector3d soundSource){
  Camera camera=CoreRegistry.get(WorldRenderer.class).getActiveCamera();
  if (camera == null) {
    return false;
  }
  Vector3d soundPosition=new Vector3d(soundSource);
  soundPosition.sub(camera.getPosition());
  return soundPosition.lengthSquared() < MAX_DISTANCE_SQUARED;
}","@Override protected boolean checkDistance(Vector3d soundSource){
  Camera camera=CoreRegistry.get(WorldRenderer.class).getActiveCamera();
  if (camera == null) {
    return false;
  }
  Vector3f soundPosition=new Vector3f(soundSource);
  soundPosition.sub(camera.getPosition());
  return soundPosition.lengthSquared() < MAX_DISTANCE_SQUARED;
}",0.9941690962099126
1163,"public void renderTransparent(){
  ShaderManager.getInstance().enableShader(""String_Node_Str"");
  glDisable(GL11.GL_CULL_FACE);
  Vector3d cameraPosition=worldRenderer.getActiveCamera().getPosition();
  for (  EntityRef entity : entityManager.iteratorEntities(BlockParticleEffectComponent.class,LocationComponent.class)) {
    LocationComponent location=entity.getComponent(LocationComponent.class);
    Vector3f worldPos=location.getWorldPosition();
    if (!worldProvider.isBlockActive(worldPos)) {
      continue;
    }
    double temperature=worldProvider.getBiomeProvider().getTemperatureAt((int)worldPos.x,(int)worldPos.z);
    double humidity=worldProvider.getBiomeProvider().getHumidityAt((int)worldPos.x,(int)worldPos.z);
    glPushMatrix();
    glTranslated(worldPos.x - cameraPosition.x,worldPos.y - cameraPosition.y,worldPos.z - cameraPosition.z);
    BlockParticleEffectComponent particleEffect=entity.getComponent(BlockParticleEffectComponent.class);
    if (particleEffect.blockType == null) {
      return;
    }
    for (    Particle particle : particleEffect.particles) {
      glPushMatrix();
      glTranslatef(particle.position.x,particle.position.y,particle.position.z);
      applyOrientation();
      glScalef(particle.size,particle.size,particle.size);
      float light=worldRenderer.getRenderingLightValueAt(new Vector3f(worldPos.x + particle.position.x,worldPos.y + particle.position.y,worldPos.z + particle.position.z));
      renderParticle(particle,particleEffect.blockType.getArchetypeBlock().getId(),temperature,humidity,light);
      glPopMatrix();
    }
    glPopMatrix();
  }
  glEnable(GL11.GL_CULL_FACE);
}","public void renderTransparent(){
  ShaderManager.getInstance().enableShader(""String_Node_Str"");
  glDisable(GL11.GL_CULL_FACE);
  Vector3f cameraPosition=worldRenderer.getActiveCamera().getPosition();
  for (  EntityRef entity : entityManager.iteratorEntities(BlockParticleEffectComponent.class,LocationComponent.class)) {
    LocationComponent location=entity.getComponent(LocationComponent.class);
    Vector3f worldPos=location.getWorldPosition();
    if (!worldProvider.isBlockActive(worldPos)) {
      continue;
    }
    double temperature=worldProvider.getBiomeProvider().getTemperatureAt((int)worldPos.x,(int)worldPos.z);
    double humidity=worldProvider.getBiomeProvider().getHumidityAt((int)worldPos.x,(int)worldPos.z);
    glPushMatrix();
    glTranslated(worldPos.x - cameraPosition.x,worldPos.y - cameraPosition.y,worldPos.z - cameraPosition.z);
    BlockParticleEffectComponent particleEffect=entity.getComponent(BlockParticleEffectComponent.class);
    if (particleEffect.blockType == null) {
      return;
    }
    for (    Particle particle : particleEffect.particles) {
      glPushMatrix();
      glTranslatef(particle.position.x,particle.position.y,particle.position.z);
      applyOrientation();
      glScalef(particle.size,particle.size,particle.size);
      float light=worldRenderer.getRenderingLightValueAt(new Vector3f(worldPos.x + particle.position.x,worldPos.y + particle.position.y,worldPos.z + particle.position.z));
      renderParticle(particle,particleEffect.blockType.getArchetypeBlock().getId(),temperature,humidity,light);
      glPopMatrix();
    }
    glPopMatrix();
  }
  glEnable(GL11.GL_CULL_FACE);
}",0.9993917274939172
1164,"private double calcBobbingOffset(float phaseOffset,float amplitude,float frequency){
  return java.lang.Math.sin(bobFactor * frequency + phaseOffset) * amplitude;
}","private float calcBobbingOffset(float phaseOffset,float amplitude,float frequency){
  return (float)java.lang.Math.sin(bobFactor * frequency + phaseOffset) * amplitude;
}",0.9520958083832336
1165,"private void updateCamera(CharacterMovementComponent charMovementComp,Vector3f position,Quat4f rotation){
  Vector3d cameraPosition=new Vector3d();
  cameraPosition.add(new Vector3d(position),new Vector3d(0,0.6f,0));
  playerCamera.getPosition().set(cameraPosition);
  Vector3f viewDir=new Vector3f(0,0,1);
  QuaternionUtil.quatRotate(rotation,viewDir,viewDir);
  playerCamera.getViewingDirection().set(viewDir);
  float stepDelta=charMovementComp.footstepDelta - lastStepDelta;
  if (stepDelta < 0)   stepDelta+=charMovementComp.distanceBetweenFootsteps;
  bobFactor+=stepDelta;
  lastStepDelta=charMovementComp.footstepDelta;
  if (cameraBobbing) {
    playerCamera.setBobbingRotationOffsetFactor(calcBobbingOffset(0.0f,0.01f,2.5f));
    playerCamera.setBobbingVerticalOffsetFactor(calcBobbingOffset((float)java.lang.Math.PI / 4f,0.025f,3f));
  }
 else {
    playerCamera.setBobbingRotationOffsetFactor(0.0);
    playerCamera.setBobbingVerticalOffsetFactor(0.0);
  }
  if (charMovementComp.isGhosting) {
    playerCamera.extendFov(24);
  }
 else {
    playerCamera.resetFov();
  }
}","private void updateCamera(CharacterMovementComponent charMovementComp,Vector3f position,Quat4f rotation){
  Vector3d cameraPosition=new Vector3d();
  cameraPosition.add(new Vector3d(position),new Vector3d(0,0.6f,0));
  playerCamera.getPosition().set(cameraPosition);
  Vector3f viewDir=new Vector3f(0,0,1);
  QuaternionUtil.quatRotate(rotation,viewDir,playerCamera.getViewingDirection());
  float stepDelta=charMovementComp.footstepDelta - lastStepDelta;
  if (stepDelta < 0)   stepDelta+=charMovementComp.distanceBetweenFootsteps;
  bobFactor+=stepDelta;
  lastStepDelta=charMovementComp.footstepDelta;
  if (cameraBobbing) {
    playerCamera.setBobbingRotationOffsetFactor(calcBobbingOffset(0.0f,0.01f,2.5f));
    playerCamera.setBobbingVerticalOffsetFactor(calcBobbingOffset((float)java.lang.Math.PI / 4f,0.025f,3f));
  }
 else {
    playerCamera.setBobbingRotationOffsetFactor(0.0f);
    playerCamera.setBobbingVerticalOffsetFactor(0.0f);
  }
  if (charMovementComp.isGhosting) {
    playerCamera.extendFov(24);
  }
 else {
    playerCamera.resetFov();
  }
}",0.961789375582479
1166,"@Override public void renderOverlay(){
  if (effectsTexture == null)   return;
  ShaderManager.getInstance().enableDefaultTextured();
  glBindTexture(GL11.GL_TEXTURE_2D,effectsTexture.getId());
  glEnable(GL11.GL_BLEND);
  glBlendFunc(GL_DST_COLOR,GL_ZERO);
  Vector3d cameraPosition=CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
  for (  EntityRef entity : entityManager.iteratorEntities(HealthComponent.class,BlockComponent.class)) {
    HealthComponent health=entity.getComponent(HealthComponent.class);
    if (health.currentHealth == health.maxHealth)     continue;
    BlockComponent blockComp=entity.getComponent(BlockComponent.class);
    if (!worldProvider.isBlockActive(blockComp.getPosition()))     continue;
    glPushMatrix();
    glTranslated(blockComp.getPosition().x - cameraPosition.x,blockComp.getPosition().y - cameraPosition.y,blockComp.getPosition().z - cameraPosition.z);
    float offset=java.lang.Math.round((1.0f - (float)health.currentHealth / health.maxHealth) * 10.0f) * 0.0625f;
    glMatrixMode(GL_TEXTURE);
    glPushMatrix();
    glTranslatef(offset,0f,0f);
    glMatrixMode(GL_MODELVIEW);
    overlayMesh.render();
    glPopMatrix();
    glMatrixMode(GL_TEXTURE);
    glPopMatrix();
    glMatrixMode(GL_MODELVIEW);
  }
  glDisable(GL11.GL_BLEND);
}","@Override public void renderOverlay(){
  if (effectsTexture == null)   return;
  ShaderManager.getInstance().enableDefaultTextured();
  glBindTexture(GL11.GL_TEXTURE_2D,effectsTexture.getId());
  glEnable(GL11.GL_BLEND);
  glBlendFunc(GL_DST_COLOR,GL_ZERO);
  Vector3f cameraPosition=CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
  for (  EntityRef entity : entityManager.iteratorEntities(HealthComponent.class,BlockComponent.class)) {
    HealthComponent health=entity.getComponent(HealthComponent.class);
    if (health.currentHealth == health.maxHealth)     continue;
    BlockComponent blockComp=entity.getComponent(BlockComponent.class);
    if (!worldProvider.isBlockActive(blockComp.getPosition()))     continue;
    glPushMatrix();
    glTranslated(blockComp.getPosition().x - cameraPosition.x,blockComp.getPosition().y - cameraPosition.y,blockComp.getPosition().z - cameraPosition.z);
    float offset=java.lang.Math.round((1.0f - (float)health.currentHealth / health.maxHealth) * 10.0f) * 0.0625f;
    glMatrixMode(GL_TEXTURE);
    glPushMatrix();
    glTranslatef(offset,0f,0f);
    glMatrixMode(GL_MODELVIEW);
    overlayMesh.render();
    glPopMatrix();
    glMatrixMode(GL_TEXTURE);
    glPopMatrix();
    glMatrixMode(GL_MODELVIEW);
  }
  glDisable(GL11.GL_BLEND);
}",0.9992343032159264
1167,"@Override public void renderTransparent(){
  Vector3d cameraPosition=worldRenderer.getActiveCamera().getPosition();
  for (  EntityRef entity : manager.iteratorEntities(MeshComponent.class,AABBCollisionComponent.class,LocationComponent.class)) {
    MeshComponent meshComp=entity.getComponent(MeshComponent.class);
    if (meshComp.renderType == MeshComponent.RenderType.Normal)     continue;
    AABBCollisionComponent collision=entity.getComponent(AABBCollisionComponent.class);
    LocationComponent location=entity.getComponent(LocationComponent.class);
    Vector3f worldPos=location.getWorldPosition();
    Vector3d extents=new Vector3d(collision.getExtents());
    float worldScale=location.getWorldScale();
    extents.scale(worldScale);
    AABB aabb=new AABB(new Vector3d(worldPos),new Vector3d(collision.getExtents()));
    if (worldRenderer.isAABBVisible(aabb)) {
      glPushMatrix();
      glTranslated(worldPos.x - cameraPosition.x,worldPos.y - cameraPosition.y,worldPos.z - cameraPosition.z);
      AxisAngle4f rot=new AxisAngle4f();
      rot.set(location.getWorldRotation());
      glRotatef(TeraMath.RAD_TO_DEG * rot.angle,rot.x,rot.y,rot.z);
      glScalef(worldScale,worldScale,worldScale);
      ShaderProgram shader=ShaderManager.getInstance().getShaderProgram(""String_Node_Str"");
      shader.enable();
      shader.setFloat4(""String_Node_Str"",meshComp.color.x,meshComp.color.y,meshComp.color.z,meshComp.color.w);
      shader.setFloat(""String_Node_Str"",worldRenderer.getRenderingLightValueAt(worldPos));
      mesh.render();
      glPopMatrix();
    }
  }
}","@Override public void renderTransparent(){
  Vector3f cameraPosition=worldRenderer.getActiveCamera().getPosition();
  for (  EntityRef entity : manager.iteratorEntities(MeshComponent.class,AABBCollisionComponent.class,LocationComponent.class)) {
    MeshComponent meshComp=entity.getComponent(MeshComponent.class);
    if (meshComp.renderType == MeshComponent.RenderType.Normal)     continue;
    AABBCollisionComponent collision=entity.getComponent(AABBCollisionComponent.class);
    LocationComponent location=entity.getComponent(LocationComponent.class);
    Vector3f worldPos=location.getWorldPosition();
    Vector3d extents=new Vector3d(collision.getExtents());
    float worldScale=location.getWorldScale();
    extents.scale(worldScale);
    AABB aabb=new AABB(new Vector3d(worldPos),new Vector3d(collision.getExtents()));
    if (worldRenderer.isAABBVisible(aabb)) {
      glPushMatrix();
      glTranslated(worldPos.x - cameraPosition.x,worldPos.y - cameraPosition.y,worldPos.z - cameraPosition.z);
      AxisAngle4f rot=new AxisAngle4f();
      rot.set(location.getWorldRotation());
      glRotatef(TeraMath.RAD_TO_DEG * rot.angle,rot.x,rot.y,rot.z);
      glScalef(worldScale,worldScale,worldScale);
      ShaderProgram shader=ShaderManager.getInstance().getShaderProgram(""String_Node_Str"");
      shader.enable();
      shader.setFloat4(""String_Node_Str"",meshComp.color.x,meshComp.color.y,meshComp.color.z,meshComp.color.w);
      shader.setFloat(""String_Node_Str"",worldRenderer.getRenderingLightValueAt(worldPos));
      mesh.render();
      glPopMatrix();
    }
  }
}",0.9993678887484198
1168,"@Override public void renderOpaque(){
  boolean carryingTorch=CoreRegistry.get(LocalPlayer.class).isCarryingTorch();
  Vector3d cameraPosition=worldRenderer.getActiveCamera().getPosition();
  for (  EntityRef entity : manager.iteratorEntities(MeshComponent.class,AABBCollisionComponent.class,LocationComponent.class)) {
    MeshComponent meshComp=entity.getComponent(MeshComponent.class);
    if (meshComp.renderType != MeshComponent.RenderType.Normal || meshComp.mesh == null)     continue;
    AABBCollisionComponent collision=entity.getComponent(AABBCollisionComponent.class);
    LocationComponent location=entity.getComponent(LocationComponent.class);
    Vector3f worldPos=location.getWorldPosition();
    Vector3d extents=new Vector3d(collision.getExtents());
    float worldScale=location.getWorldScale();
    extents.scale(worldScale);
    AABB aabb=new AABB(new Vector3d(worldPos),new Vector3d(collision.getExtents()));
    if (worldRenderer.isAABBVisible(aabb)) {
      glPushMatrix();
      glTranslated(worldPos.x - cameraPosition.x,worldPos.y - cameraPosition.y,worldPos.z - cameraPosition.z);
      AxisAngle4f rot=new AxisAngle4f();
      rot.set(location.getWorldRotation());
      glRotatef(TeraMath.RAD_TO_DEG * rot.angle,rot.x,rot.y,rot.z);
      glScalef(worldScale,worldScale,worldScale);
      meshComp.material.enable();
      meshComp.material.setFloat(""String_Node_Str"",worldRenderer.getRenderingLightValueAt(worldPos));
      meshComp.material.setInt(""String_Node_Str"",carryingTorch ? 1 : 0);
      meshComp.material.bindTextures();
      meshComp.mesh.render();
      glPopMatrix();
    }
  }
}","@Override public void renderOpaque(){
  boolean carryingTorch=CoreRegistry.get(LocalPlayer.class).isCarryingTorch();
  Vector3f cameraPosition=worldRenderer.getActiveCamera().getPosition();
  for (  EntityRef entity : manager.iteratorEntities(MeshComponent.class,AABBCollisionComponent.class,LocationComponent.class)) {
    MeshComponent meshComp=entity.getComponent(MeshComponent.class);
    if (meshComp.renderType != MeshComponent.RenderType.Normal || meshComp.mesh == null)     continue;
    AABBCollisionComponent collision=entity.getComponent(AABBCollisionComponent.class);
    LocationComponent location=entity.getComponent(LocationComponent.class);
    Vector3f worldPos=location.getWorldPosition();
    Vector3d extents=new Vector3d(collision.getExtents());
    float worldScale=location.getWorldScale();
    extents.scale(worldScale);
    AABB aabb=new AABB(new Vector3d(worldPos),new Vector3d(collision.getExtents()));
    if (worldRenderer.isAABBVisible(aabb)) {
      glPushMatrix();
      glTranslated(worldPos.x - cameraPosition.x,worldPos.y - cameraPosition.y,worldPos.z - cameraPosition.z);
      AxisAngle4f rot=new AxisAngle4f();
      rot.set(location.getWorldRotation());
      glRotatef(TeraMath.RAD_TO_DEG * rot.angle,rot.x,rot.y,rot.z);
      glScalef(worldScale,worldScale,worldScale);
      meshComp.material.enable();
      meshComp.material.setFloat(""String_Node_Str"",worldRenderer.getRenderingLightValueAt(worldPos));
      meshComp.material.setInt(""String_Node_Str"",carryingTorch ? 1 : 0);
      meshComp.material.bindTextures();
      meshComp.mesh.render();
      glPopMatrix();
    }
  }
}",0.999383477188656
1169,"public void update(){
  if (!target.exists() && targetBlockPos != null) {
    target=blockRegistry.getOrCreateEntityAt(targetBlockPos);
  }
  boolean lostTarget=false;
  if (!target.exists()) {
    targetBlockPos=null;
    lostTarget=true;
  }
  Camera camera=CoreRegistry.get(WorldRenderer.class).getActiveCamera();
  BulletPhysicsRenderer physicsRenderer=CoreRegistry.get(BulletPhysicsRenderer.class);
  HitResult hitInfo=physicsRenderer.rayTrace(new Vector3f(camera.getPosition()),new Vector3f(camera.getViewingDirection()),TARGET_DISTANCE);
  if (hitInfo.isHit()) {
    hitPosition=hitInfo.getHitPoint();
    hitNormal=hitInfo.getHitNormal();
    Vector3i newBlockPos=null;
    BlockComponent blockComp=hitInfo.getEntity().getComponent(BlockComponent.class);
    if (blockComp != null) {
      newBlockPos=new Vector3i(blockComp.getPosition());
    }
    if (!Objects.equal(targetBlockPos,newBlockPos) || lostTarget) {
      EntityRef oldTarget=target;
      target=EntityRef.NULL;
      targetBlockPos=newBlockPos;
      if (newBlockPos != null) {
        target=hitInfo.getEntity();
      }
      oldTarget.send(new CameraOutEvent());
      target.send(new CameraOverEvent());
      localPlayer.getEntity().send(new CameraTargetChangedEvent(oldTarget,target));
    }
  }
}","public void update(){
  if (!target.exists() && targetBlockPos != null) {
    target=blockRegistry.getOrCreateEntityAt(targetBlockPos);
  }
  boolean lostTarget=false;
  if (!target.exists()) {
    targetBlockPos=null;
    lostTarget=true;
  }
  Camera camera=CoreRegistry.get(WorldRenderer.class).getActiveCamera();
  BulletPhysicsRenderer physicsRenderer=CoreRegistry.get(BulletPhysicsRenderer.class);
  HitResult hitInfo=physicsRenderer.rayTrace(new Vector3f(camera.getPosition()),new Vector3f(camera.getViewingDirection()),TARGET_DISTANCE);
  Vector3i newBlockPos=null;
  if (hitInfo.isHit()) {
    hitPosition=hitInfo.getHitPoint();
    hitNormal=hitInfo.getHitNormal();
    BlockComponent blockComp=hitInfo.getEntity().getComponent(BlockComponent.class);
    if (blockComp != null) {
      newBlockPos=new Vector3i(blockComp.getPosition());
    }
  }
  if (!Objects.equal(targetBlockPos,newBlockPos) || lostTarget) {
    EntityRef oldTarget=target;
    target=EntityRef.NULL;
    targetBlockPos=newBlockPos;
    if (newBlockPos != null) {
      target=hitInfo.getEntity();
    }
    oldTarget.send(new CameraOutEvent());
    target.send(new CameraOverEvent());
    localPlayer.getEntity().send(new CameraTargetChangedEvent(oldTarget,target));
  }
}",0.8601895734597157
1170,"/** 
 * Renders this AABB. <p/>
 * @param lineThickness The thickness of the line
 */
public void render(float lineThickness){
  ShaderManager.getInstance().enableDefault();
  glPushMatrix();
  Vector3d cameraPosition=CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
  glTranslated(getPosition().x - cameraPosition.x,-cameraPosition.y,getPosition().z - cameraPosition.z);
  renderLocally(lineThickness);
  glPopMatrix();
}","/** 
 * Renders this AABB. <p/>
 * @param lineThickness The thickness of the line
 */
public void render(float lineThickness){
  ShaderManager.getInstance().enableDefault();
  glPushMatrix();
  Vector3f cameraPosition=CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
  glTranslated(getPosition().x - cameraPosition.x,-cameraPosition.y,getPosition().z - cameraPosition.z);
  renderLocally(lineThickness);
  glPopMatrix();
}",0.9977477477477478
1171,"/** 
 * Returns true if this view frustum intersects the given AABB.
 */
public boolean intersects(AABB aabb){
  Vector3d[] aabbVertices=aabb.getVertices();
  Vector3d cp=CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
  for (int i=0; i < 6; i++) {
    if (_planes[i].getA() * (aabbVertices[0].x - cp.x) + _planes[i].getB() * (aabbVertices[0].y - cp.y) + _planes[i].getC() * (aabbVertices[0].z - cp.z) + _planes[i].getD() > 0)     continue;
    if (_planes[i].getA() * (aabbVertices[1].x - cp.x) + _planes[i].getB() * (aabbVertices[1].y - cp.y) + _planes[i].getC() * (aabbVertices[1].z - cp.z) + _planes[i].getD() > 0)     continue;
    if (_planes[i].getA() * (aabbVertices[2].x - cp.x) + _planes[i].getB() * (aabbVertices[2].y - cp.y) + _planes[i].getC() * (aabbVertices[2].z - cp.z) + _planes[i].getD() > 0)     continue;
    if (_planes[i].getA() * (aabbVertices[3].x - cp.x) + _planes[i].getB() * (aabbVertices[3].y - cp.y) + _planes[i].getC() * (aabbVertices[3].z - cp.z) + _planes[i].getD() > 0)     continue;
    if (_planes[i].getA() * (aabbVertices[4].x - cp.x) + _planes[i].getB() * (aabbVertices[4].y - cp.y) + _planes[i].getC() * (aabbVertices[4].z - cp.z) + _planes[i].getD() > 0)     continue;
    if (_planes[i].getA() * (aabbVertices[5].x - cp.x) + _planes[i].getB() * (aabbVertices[5].y - cp.y) + _planes[i].getC() * (aabbVertices[5].z - cp.z) + _planes[i].getD() > 0)     continue;
    if (_planes[i].getA() * (aabbVertices[6].x - cp.x) + _planes[i].getB() * (aabbVertices[6].y - cp.y) + _planes[i].getC() * (aabbVertices[6].z - cp.z) + _planes[i].getD() > 0)     continue;
    if (_planes[i].getA() * (aabbVertices[7].x - cp.x) + _planes[i].getB() * (aabbVertices[7].y - cp.y) + _planes[i].getC() * (aabbVertices[7].z - cp.z) + _planes[i].getD() > 0)     continue;
    return false;
  }
  return true;
}","/** 
 * Returns true if this view frustum intersects the given AABB.
 */
public boolean intersects(AABB aabb){
  Vector3d[] aabbVertices=aabb.getVertices();
  Vector3f cp=CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
  for (int i=0; i < 6; i++) {
    if (_planes[i].getA() * (aabbVertices[0].x - cp.x) + _planes[i].getB() * (aabbVertices[0].y - cp.y) + _planes[i].getC() * (aabbVertices[0].z - cp.z) + _planes[i].getD() > 0)     continue;
    if (_planes[i].getA() * (aabbVertices[1].x - cp.x) + _planes[i].getB() * (aabbVertices[1].y - cp.y) + _planes[i].getC() * (aabbVertices[1].z - cp.z) + _planes[i].getD() > 0)     continue;
    if (_planes[i].getA() * (aabbVertices[2].x - cp.x) + _planes[i].getB() * (aabbVertices[2].y - cp.y) + _planes[i].getC() * (aabbVertices[2].z - cp.z) + _planes[i].getD() > 0)     continue;
    if (_planes[i].getA() * (aabbVertices[3].x - cp.x) + _planes[i].getB() * (aabbVertices[3].y - cp.y) + _planes[i].getC() * (aabbVertices[3].z - cp.z) + _planes[i].getD() > 0)     continue;
    if (_planes[i].getA() * (aabbVertices[4].x - cp.x) + _planes[i].getB() * (aabbVertices[4].y - cp.y) + _planes[i].getC() * (aabbVertices[4].z - cp.z) + _planes[i].getD() > 0)     continue;
    if (_planes[i].getA() * (aabbVertices[5].x - cp.x) + _planes[i].getB() * (aabbVertices[5].y - cp.y) + _planes[i].getC() * (aabbVertices[5].z - cp.z) + _planes[i].getD() > 0)     continue;
    if (_planes[i].getA() * (aabbVertices[6].x - cp.x) + _planes[i].getB() * (aabbVertices[6].y - cp.y) + _planes[i].getC() * (aabbVertices[6].z - cp.z) + _planes[i].getD() > 0)     continue;
    if (_planes[i].getA() * (aabbVertices[7].x - cp.x) + _planes[i].getB() * (aabbVertices[7].y - cp.y) + _planes[i].getC() * (aabbVertices[7].z - cp.z) + _planes[i].getD() > 0)     continue;
    return false;
  }
  return true;
}",0.9994582881906826
1172,"public Vector3d getPosition(){
  return _position;
}","public Vector3f getPosition(){
  return _position;
}",0.9807692307692308
1173,"public Vector3d getViewingDirection(){
  return _viewingDirection;
}","public Vector3f getViewingDirection(){
  return _viewingDirection;
}",0.9852941176470588
1174,"public Vector3d getUp(){
  return _up;
}","public Vector3f getUp(){
  return _up;
}",0.975
1175,"public void loadModelViewMatrix(){
  glMatrixMode(GL11.GL_MODELVIEW);
  glLoadIdentity();
  Vector3d right=new Vector3d();
  right.cross(_viewingDirection,_up);
  right.scale(_bobbingRotationOffsetFactor);
  GLU.gluLookAt(0f,(float)_bobbingVerticalOffsetFactor * 2.0f,0f,(float)_viewingDirection.x,(float)_viewingDirection.y + (float)_bobbingVerticalOffsetFactor * 2.0f,(float)_viewingDirection.z,(float)_up.x + (float)right.x,(float)_up.y + (float)right.y,(float)_up.z + (float)right.z);
  _viewFrustum.updateFrustum();
}","public void loadModelViewMatrix(){
  glMatrixMode(GL11.GL_MODELVIEW);
  glLoadIdentity();
  Vector3f right=new Vector3f();
  right.cross(_viewingDirection,_up);
  right.scale(_bobbingRotationOffsetFactor);
  GLU.gluLookAt(0f,(float)_bobbingVerticalOffsetFactor * 2.0f,0f,(float)_viewingDirection.x,(float)_viewingDirection.y + (float)_bobbingVerticalOffsetFactor * 2.0f,(float)_viewingDirection.z,(float)_up.x + (float)right.x,(float)_up.y + (float)right.y,(float)_up.z + (float)right.z);
  _viewFrustum.updateFrustum();
}",0.9961685823754788
1176,"public void loadNormalizedModelViewMatrix(){
  glMatrixMode(GL11.GL_MODELVIEW);
  glLoadIdentity();
  Vector3d right=new Vector3d();
  right.cross(_viewingDirection,_up);
  right.scale(_bobbingRotationOffsetFactor);
  GLU.gluLookAt(0f,0f,0f,(float)_viewingDirection.x,(float)_viewingDirection.y,(float)_viewingDirection.z,(float)_up.x + (float)right.x,(float)_up.y + (float)right.y,(float)_up.z + (float)right.z);
  _viewFrustum.updateFrustum();
}","public void loadNormalizedModelViewMatrix(){
  glMatrixMode(GL11.GL_MODELVIEW);
  glLoadIdentity();
  Vector3f right=new Vector3f();
  right.cross(_viewingDirection,_up);
  right.scale(_bobbingRotationOffsetFactor);
  GLU.gluLookAt(0f,0f,0f,(float)_viewingDirection.x,(float)_viewingDirection.y,(float)_viewingDirection.z,(float)_up.x + (float)right.x,(float)_up.y + (float)right.y,(float)_up.z + (float)right.z);
  _viewFrustum.updateFrustum();
}",0.9955257270693512
1177,"public void setBobbingRotationOffsetFactor(double f){
  _bobbingRotationOffsetFactor=f;
}","public void setBobbingRotationOffsetFactor(float f){
  _bobbingRotationOffsetFactor=f;
}",0.9491525423728814
1178,"public void setBobbingVerticalOffsetFactor(double f){
  _bobbingVerticalOffsetFactor=f;
}","public void setBobbingVerticalOffsetFactor(float f){
  _bobbingVerticalOffsetFactor=f;
}",0.9491525423728814
1179,"public void update(){
  super.update();
  _healthBar.setPosition(new Vector2f(_toolbar.getPosition().x,_toolbar.getPosition().y - _toolbar.getSize().y + 8f));
  _crosshair.setPosition(new Vector2f(Display.getWidth() / 2,Display.getHeight() / 2));
  boolean enableDebug=Config.getInstance().isDebug();
  _debugLine1.setVisible(enableDebug);
  _debugLine2.setVisible(enableDebug);
  _debugLine3.setVisible(enableDebug);
  _debugLine4.setVisible(enableDebug);
  if (enableDebug) {
    double memoryUsage=((double)Runtime.getRuntime().totalMemory() - (double)Runtime.getRuntime().freeMemory()) / 1048576.0;
    Timer timer=CoreRegistry.get(Timer.class);
    _debugLine1.setText(String.format(""String_Node_Str"",timer.getFps(),memoryUsage,Runtime.getRuntime().totalMemory() / 1048576.0,Runtime.getRuntime().maxMemory() / 1048576.0));
    _debugLine2.setText(String.format(""String_Node_Str"",CoreRegistry.get(LocalPlayer.class)));
    _debugLine3.setText(String.format(""String_Node_Str"",CoreRegistry.get(WorldRenderer.class)));
    _debugLine4.setText(String.format(""String_Node_Str"",ChunkTessellator.getVertexArrayUpdateCount(),CoreRegistry.get(GameEngine.class).getActiveTaskCount()));
  }
}","public void update(){
  super.update();
  _healthBar.setPosition(new Vector2f(_toolbar.getPosition().x,_toolbar.getPosition().y - _toolbar.getSize().y + 8f));
  _crosshair.setPosition(new Vector2f(Display.getWidth() / 2,Display.getHeight() / 2));
  boolean enableDebug=Config.getInstance().isDebug();
  _debugLine1.setVisible(enableDebug);
  _debugLine2.setVisible(enableDebug);
  _debugLine3.setVisible(enableDebug);
  _debugLine4.setVisible(enableDebug);
  if (enableDebug) {
    CameraTargetSystem cameraTarget=CoreRegistry.get(CameraTargetSystem.class);
    double memoryUsage=((double)Runtime.getRuntime().totalMemory() - (double)Runtime.getRuntime().freeMemory()) / 1048576.0;
    Timer timer=CoreRegistry.get(Timer.class);
    _debugLine1.setText(String.format(""String_Node_Str"",timer.getFps(),memoryUsage,Runtime.getRuntime().totalMemory() / 1048576.0,Runtime.getRuntime().maxMemory() / 1048576.0));
    _debugLine2.setText(String.format(""String_Node_Str"",cameraTarget.toString()));
    _debugLine3.setText(String.format(""String_Node_Str"",CoreRegistry.get(WorldRenderer.class)));
    _debugLine4.setText(String.format(""String_Node_Str"",ChunkTessellator.getVertexArrayUpdateCount(),CoreRegistry.get(GameEngine.class).getActiveTaskCount()));
  }
}",0.9458572600492208
1180,"@Override public void render(){
  FloatBuffer mBuffer=BufferUtils.createFloatBuffer(16);
  float[] mFloat=new float[16];
  GL11.glPushMatrix();
  Vector3d cameraPosition=_parent.getActiveCamera().getPosition();
  GL11.glTranslated(-cameraPosition.x,-cameraPosition.y,-cameraPosition.z);
  List<CollisionObject> collisionObjects=_discreteDynamicsWorld.getCollisionObjectArray();
  for (  CollisionObject co : collisionObjects) {
    if (co.getClass().equals(BlockRigidBody.class)) {
      BlockRigidBody br=(BlockRigidBody)co;
      Block block=BlockManager.getInstance().getBlock(br.getType());
      Transform t=new Transform();
      br.getMotionState().getWorldTransform(t);
      t.getOpenGLMatrix(mFloat);
      mBuffer.put(mFloat);
      mBuffer.flip();
      GL11.glPushMatrix();
      GL11.glMultMatrix(mBuffer);
      if (br.getCollisionShape() == _blockShapeHalf)       GL11.glScalef(0.5f,0.5f,0.5f);
 else       if (br.getCollisionShape() == _blockShapeQuarter)       GL11.glScalef(0.25f,0.25f,0.25f);
      block.renderWithLightValue(_parent.getRenderingLightValueAt(t.origin));
      GL11.glPopMatrix();
    }
  }
  GL11.glPopMatrix();
}","@Override public void render(){
  FloatBuffer mBuffer=BufferUtils.createFloatBuffer(16);
  float[] mFloat=new float[16];
  GL11.glPushMatrix();
  Vector3f cameraPosition=_parent.getActiveCamera().getPosition();
  GL11.glTranslated(-cameraPosition.x,-cameraPosition.y,-cameraPosition.z);
  List<CollisionObject> collisionObjects=_discreteDynamicsWorld.getCollisionObjectArray();
  for (  CollisionObject co : collisionObjects) {
    if (co.getClass().equals(BlockRigidBody.class)) {
      BlockRigidBody br=(BlockRigidBody)co;
      Block block=BlockManager.getInstance().getBlock(br.getType());
      Transform t=new Transform();
      br.getMotionState().getWorldTransform(t);
      t.getOpenGLMatrix(mFloat);
      mBuffer.put(mFloat);
      mBuffer.flip();
      GL11.glPushMatrix();
      GL11.glMultMatrix(mBuffer);
      if (br.getCollisionShape() == _blockShapeHalf)       GL11.glScalef(0.5f,0.5f,0.5f);
 else       if (br.getCollisionShape() == _blockShapeQuarter)       GL11.glScalef(0.25f,0.25f,0.25f);
      block.renderWithLightValue(_parent.getRenderingLightValueAt(t.origin));
      GL11.glPopMatrix();
    }
  }
  GL11.glPopMatrix();
}",0.9991304347826088
1181,"@Override public void applyParameters(ShaderProgram program){
  PostProcessingRenderer.FBO scene=PostProcessingRenderer.getInstance().getFBO(""String_Node_Str"");
  GL13.glActiveTexture(GL13.GL_TEXTURE1);
  PostProcessingRenderer.getInstance().getFBO(""String_Node_Str"").bindTexture();
  GL13.glActiveTexture(GL13.GL_TEXTURE2);
  PostProcessingRenderer.getInstance().getFBO(""String_Node_Str"").bindTexture();
  GL13.glActiveTexture(GL13.GL_TEXTURE3);
  glBindTexture(GL11.GL_TEXTURE_2D,texture.getId());
  GL13.glActiveTexture(GL13.GL_TEXTURE4);
  scene.bindDepthTexture();
  GL13.glActiveTexture(GL13.GL_TEXTURE0);
  PostProcessingRenderer.getInstance().getFBO(""String_Node_Str"").bindTexture();
  program.setInt(""String_Node_Str"",0);
  program.setInt(""String_Node_Str"",1);
  program.setInt(""String_Node_Str"",2);
  program.setInt(""String_Node_Str"",3);
  program.setInt(""String_Node_Str"",4);
  program.setFloat(""String_Node_Str"",Config.getInstance().getActiveViewingDistance() * 8.0f);
  if (CoreRegistry.get(LocalPlayer.class).isValid()) {
    Vector3d cameraPos=CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
    Block block=CoreRegistry.get(WorldProvider.class).getBlock(new Vector3f(cameraPos));
    program.setInt(""String_Node_Str"",block.isLiquid() ? 1 : 0);
  }
}","@Override public void applyParameters(ShaderProgram program){
  PostProcessingRenderer.FBO scene=PostProcessingRenderer.getInstance().getFBO(""String_Node_Str"");
  GL13.glActiveTexture(GL13.GL_TEXTURE1);
  PostProcessingRenderer.getInstance().getFBO(""String_Node_Str"").bindTexture();
  GL13.glActiveTexture(GL13.GL_TEXTURE2);
  PostProcessingRenderer.getInstance().getFBO(""String_Node_Str"").bindTexture();
  GL13.glActiveTexture(GL13.GL_TEXTURE3);
  glBindTexture(GL11.GL_TEXTURE_2D,texture.getId());
  GL13.glActiveTexture(GL13.GL_TEXTURE4);
  scene.bindDepthTexture();
  GL13.glActiveTexture(GL13.GL_TEXTURE0);
  PostProcessingRenderer.getInstance().getFBO(""String_Node_Str"").bindTexture();
  program.setInt(""String_Node_Str"",0);
  program.setInt(""String_Node_Str"",1);
  program.setInt(""String_Node_Str"",2);
  program.setInt(""String_Node_Str"",3);
  program.setInt(""String_Node_Str"",4);
  program.setFloat(""String_Node_Str"",Config.getInstance().getActiveViewingDistance() * 8.0f);
  if (CoreRegistry.get(LocalPlayer.class).isValid()) {
    Vector3f cameraPos=CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
    Block block=CoreRegistry.get(WorldProvider.class).getBlock(cameraPos);
    program.setInt(""String_Node_Str"",block.isLiquid() ? 1 : 0);
  }
}",0.9937548790007806
1182,"@Override public void render(){
  ShaderManager.getInstance().enableDefault();
  for (int i=0; i < 2; i++) {
    if (i == 0) {
      glColorMask(false,false,false,false);
    }
 else {
      glColorMask(true,true,true,true);
    }
    for (    BlockPosition gp : _gridPositions) {
      GL11.glPushMatrix();
      Vector3d cameraPosition=CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
      GL11.glTranslated(gp.x - cameraPosition.x,gp.y - cameraPosition.y,gp.z - cameraPosition.z);
      _mesh.render();
      GL11.glPopMatrix();
    }
  }
}","@Override public void render(){
  ShaderManager.getInstance().enableDefault();
  for (int i=0; i < 2; i++) {
    if (i == 0) {
      glColorMask(false,false,false,false);
    }
 else {
      glColorMask(true,true,true,true);
    }
    for (    BlockPosition gp : _gridPositions) {
      GL11.glPushMatrix();
      Vector3f cameraPosition=CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
      GL11.glTranslated(gp.x - cameraPosition.x,gp.y - cameraPosition.y,gp.z - cameraPosition.z);
      _mesh.render();
      GL11.glPopMatrix();
    }
  }
}",0.9982332155477032
1183,"private void renderChunk(Chunk chunk,ChunkMesh.RENDER_PHASE phase){
  if (chunk.getChunkState() == Chunk.State.COMPLETE && chunk.getMesh() != null) {
    ShaderProgram shader=ShaderManager.getInstance().getShaderProgram(""String_Node_Str"");
    shader.setFloat3(""String_Node_Str"",(float)(chunk.getPos().x * Chunk.SIZE_X),(float)(chunk.getPos().y * Chunk.SIZE_Y),(float)(chunk.getPos().z * Chunk.SIZE_Z));
    GL11.glPushMatrix();
    Vector3d cameraPosition=CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
    GL11.glTranslated(chunk.getPos().x * Chunk.SIZE_X - cameraPosition.x,chunk.getPos().y * Chunk.SIZE_Y - cameraPosition.y,chunk.getPos().z * Chunk.SIZE_Z - cameraPosition.z);
    for (int i=0; i < VERTICAL_SEGMENTS; i++) {
      if (!chunk.getMesh()[i].isEmpty()) {
        if (Config.getInstance().isRenderChunkBoundingBoxes()) {
          chunk.getSubMeshAABB(i).renderLocally(1f);
          _statRenderedTriangles+=12;
        }
        shader.enable();
        chunk.getMesh()[i].render(phase);
        _statRenderedTriangles+=chunk.getMesh()[i].triangleCount();
      }
    }
    GL11.glPopMatrix();
  }
 else {
    _statChunkNotReady++;
  }
}","private void renderChunk(Chunk chunk,ChunkMesh.RENDER_PHASE phase){
  if (chunk.getChunkState() == Chunk.State.COMPLETE && chunk.getMesh() != null) {
    ShaderProgram shader=ShaderManager.getInstance().getShaderProgram(""String_Node_Str"");
    shader.setFloat3(""String_Node_Str"",(float)(chunk.getPos().x * Chunk.SIZE_X),(float)(chunk.getPos().y * Chunk.SIZE_Y),(float)(chunk.getPos().z * Chunk.SIZE_Z));
    GL11.glPushMatrix();
    Vector3f cameraPosition=CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
    GL11.glTranslated(chunk.getPos().x * Chunk.SIZE_X - cameraPosition.x,chunk.getPos().y * Chunk.SIZE_Y - cameraPosition.y,chunk.getPos().z * Chunk.SIZE_Z - cameraPosition.z);
    for (int i=0; i < VERTICAL_SEGMENTS; i++) {
      if (!chunk.getMesh()[i].isEmpty()) {
        if (Config.getInstance().isRenderChunkBoundingBoxes()) {
          chunk.getSubMeshAABB(i).renderLocally(1f);
          _statRenderedTriangles+=12;
        }
        shader.enable();
        chunk.getMesh()[i].render(phase);
        _statRenderedTriangles+=chunk.getMesh()[i].triangleCount();
      }
    }
    GL11.glPopMatrix();
  }
 else {
    _statChunkNotReady++;
  }
}",0.9991511035653652
1184,"private float distanceToCamera(Chunk chunk){
  Vector3f result=new Vector3f((chunk.getPos().x + 0.5f) * Chunk.SIZE_X,0,(chunk.getPos().z + 0.5f) * Chunk.SIZE_Z);
  Vector3d cameraPos=CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
  result.x-=cameraPos.x;
  result.z-=cameraPos.z;
  return result.length();
}","private float distanceToCamera(Chunk chunk){
  Vector3f result=new Vector3f((chunk.getPos().x + 0.5f) * Chunk.SIZE_X,0,(chunk.getPos().z + 0.5f) * Chunk.SIZE_Z);
  Vector3f cameraPos=CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
  result.x-=cameraPos.x;
  result.z-=cameraPos.z;
  return result.length();
}",0.9969788519637462
1185,"private void propagateFrom(int blockX,int blockY,int blockZ){
  propagateSunlightFrom(blockX,blockY,blockZ);
  propagateLightFrom(blockX,blockY,blockZ);
}","private void propagateFrom(int blockX,int blockY,int blockZ){
  propagateSunlightFrom(blockX,blockY,blockZ);
}",0.8333333333333334
1186,"private void propagateSunlightFrom(int blockX,int blockY,int blockZ){
  byte lightLevel=worldView.getSunlight(blockX,blockY,blockZ);
  if (lightLevel <= 1)   return;
  for (  Vector3i adjDir : HORIZONTAL_LIGHT_DIRECTIONS) {
    int adjX=blockX + adjDir.x;
    int adjZ=blockZ + adjDir.z;
    byte adjLightValue=worldView.getSunlight(adjX,blockY,adjZ);
    if (adjLightValue < lightLevel - 1 && worldView.getBlock(adjX,blockY,adjZ).isTranslucent()) {
      worldView.setSunlight(adjX,blockY,adjZ,(byte)(lightLevel - 1));
      propagateSunlightFrom(adjX,blockY,adjZ);
    }
  }
  if (blockY > 0) {
    byte lowerLight=worldView.getSunlight(blockX,blockY - 1,blockZ);
    if (lightLevel == NewChunk.MAX_LIGHT) {
      if (lowerLight < lightLevel) {
        worldView.setSunlight(blockX,blockY - 1,blockZ,lightLevel);
        propagateSunlightFrom(blockX,blockY - 1,blockZ);
      }
    }
 else {
      if (lowerLight < lightLevel - 1) {
        worldView.setSunlight(blockX,blockY - 1,blockZ,(byte)(lightLevel - 1));
        propagateSunlightFrom(blockX,blockY - 1,blockZ);
      }
    }
  }
  if (blockY < NewChunk.CHUNK_DIMENSION_Y - 1) {
    byte upperLight=worldView.getSunlight(blockX,blockY + 1,blockZ);
    if (upperLight < lightLevel - 1) {
      worldView.setSunlight(blockX,blockY + 1,blockZ,(byte)(lightLevel - 1));
      propagateSunlightFrom(blockX,blockY + 1,blockZ);
    }
  }
}","private void propagateSunlightFrom(int blockX,int blockY,int blockZ){
  byte lightLevel=worldView.getSunlight(blockX,blockY,blockZ);
  if (lightLevel == 0)   return;
  if (blockY > 0 && worldView.getBlock(blockX,blockY - 1,blockZ).isTranslucent()) {
    byte lowerLight=worldView.getSunlight(blockX,blockY - 1,blockZ);
    if (lightLevel == NewChunk.MAX_LIGHT) {
      if (lowerLight < lightLevel) {
        worldView.setSunlight(blockX,blockY - 1,blockZ,lightLevel);
        propagateSunlightFrom(blockX,blockY - 1,blockZ);
      }
    }
 else {
      if (lowerLight < lightLevel - 1) {
        worldView.setSunlight(blockX,blockY - 1,blockZ,(byte)(lightLevel - 1));
        propagateSunlightFrom(blockX,blockY - 1,blockZ);
      }
    }
  }
  if (blockY < NewChunk.CHUNK_DIMENSION_Y - 1 && worldView.getBlock(blockX,blockY + 1,blockZ).isTranslucent()) {
    byte upperLight=worldView.getSunlight(blockX,blockY + 1,blockZ);
    if (lightLevel == NewChunk.MAX_LIGHT) {
      if (upperLight < lightLevel) {
        worldView.setSunlight(blockX,blockY + 1,blockZ,lightLevel);
        propagateSunlightFrom(blockX,blockY + 1,blockZ);
      }
    }
 else {
      if (upperLight < lightLevel - 1) {
        worldView.setSunlight(blockX,blockY + 1,blockZ,(byte)(lightLevel - 1));
        propagateSunlightFrom(blockX,blockY + 1,blockZ);
      }
    }
  }
  if (lightLevel <= 1)   return;
  for (  Vector3i adjDir : HORIZONTAL_LIGHT_DIRECTIONS) {
    int adjX=blockX + adjDir.x;
    int adjZ=blockZ + adjDir.z;
    byte adjLightValue=worldView.getSunlight(adjX,blockY,adjZ);
    if (adjLightValue < lightLevel - 1 && worldView.getBlock(adjX,blockY,adjZ).isTranslucent()) {
      worldView.setSunlight(adjX,blockY,adjZ,(byte)(lightLevel - 1));
      propagateSunlightFrom(adjX,blockY,adjZ);
    }
  }
}",0.631083202511774
1187,"private void propagateLightFrom(int blockX,int blockY,int blockZ){
  byte lightLevel=worldView.getLight(blockX,blockY,blockZ);
  if (lightLevel <= 1)   return;
  for (  Vector3i adjDir : HORIZONTAL_LIGHT_DIRECTIONS) {
    int adjX=blockX + adjDir.x;
    int adjZ=blockZ + adjDir.z;
    byte adjLightValue=worldView.getLight(adjX,blockY,adjZ);
    if (adjLightValue < lightLevel - 1 && worldView.getBlock(adjX,blockY,adjZ).isTranslucent()) {
      worldView.setLight(adjX,blockY,adjZ,(byte)(lightLevel - 1));
      propagateLightFrom(adjX,blockY,adjZ);
    }
  }
  if (blockY > 0) {
    byte lowerLight=worldView.getLight(blockX,blockY - 1,blockZ);
    if (lowerLight < lightLevel - 1) {
      worldView.setLight(blockX,blockY - 1,blockZ,(byte)(lightLevel - 1));
      propagateLightFrom(blockX,blockY - 1,blockZ);
    }
  }
  if (blockY < NewChunk.CHUNK_DIMENSION_Y - 1) {
    byte upperLight=worldView.getLight(blockX,blockY + 1,blockZ);
    if (upperLight < lightLevel - 1) {
      worldView.setLight(blockX,blockY + 1,blockZ,(byte)(lightLevel - 1));
      propagateLightFrom(blockX,blockY + 1,blockZ);
    }
  }
}","private void propagateLightFrom(int blockX,int blockY,int blockZ){
  byte lightLevel=worldView.getLight(blockX,blockY,blockZ);
  if (lightLevel <= 1)   return;
  for (  Vector3i adjDir : HORIZONTAL_LIGHT_DIRECTIONS) {
    int adjX=blockX + adjDir.x;
    int adjZ=blockZ + adjDir.z;
    byte adjLightValue=worldView.getLight(adjX,blockY,adjZ);
    if (adjLightValue < lightLevel - 1 && worldView.getBlock(adjX,blockY,adjZ).isTranslucent()) {
      worldView.setLight(adjX,blockY,adjZ,(byte)(lightLevel - 1));
      propagateLightFrom(adjX,blockY,adjZ);
    }
  }
  if (blockY > 0 && worldView.getBlock(blockX,blockY - 1,blockZ).isTranslucent()) {
    byte lowerLight=worldView.getLight(blockX,blockY - 1,blockZ);
    if (lowerLight < lightLevel - 1) {
      worldView.setLight(blockX,blockY - 1,blockZ,(byte)(lightLevel - 1));
      propagateLightFrom(blockX,blockY - 1,blockZ);
    }
  }
  if (blockY < NewChunk.CHUNK_DIMENSION_Y - 1 && worldView.getBlock(blockX,blockY + 1,blockZ).isTranslucent()) {
    byte upperLight=worldView.getLight(blockX,blockY + 1,blockZ);
    if (upperLight < lightLevel - 1) {
      worldView.setLight(blockX,blockY + 1,blockZ,(byte)(lightLevel - 1));
      propagateLightFrom(blockX,blockY + 1,blockZ);
    }
  }
}",0.9457627118644067
1188,"private void spreadSunlightInternal(NewChunk chunk,int x,int y,int z){
  byte lightValue=chunk.getSunlight(x,y,z);
  if (lightValue <= 1)   return;
  for (  Vector3i adjDir : HORIZONTAL_LIGHT_DIRECTIONS) {
    int adjX=x + adjDir.x;
    int adjZ=z + adjDir.z;
    if (chunk.isInBounds(adjX,y,adjZ)) {
      byte adjLightValue=chunk.getSunlight(adjX,y,adjZ);
      if (adjLightValue < lightValue - 1 && chunk.getBlock(adjX,y,adjZ).isTranslucent()) {
        chunk.setSunlight(adjX,y,adjZ,(byte)(lightValue - 1));
        spreadSunlightInternal(chunk,adjX,y,adjZ);
      }
    }
  }
  if (y > 0 && lightValue < NewChunk.MAX_LIGHT && chunk.getSunlight(x,y - 1,z) < lightValue - 1 && chunk.getBlock(x,y - 1,z).isTranslucent()) {
    chunk.setSunlight(x,y - 1,z,(byte)(lightValue - 1));
    spreadSunlightInternal(chunk,x,y - 1,z);
  }
}","private void spreadSunlightInternal(NewChunk chunk,int x,int y,int z){
  byte lightValue=chunk.getSunlight(x,y,z);
  if (y > 0 && lightValue < NewChunk.MAX_LIGHT && chunk.getSunlight(x,y - 1,z) < lightValue - 1 && chunk.getBlock(x,y - 1,z).isTranslucent()) {
    chunk.setSunlight(x,y - 1,z,(byte)(lightValue - 1));
    spreadSunlightInternal(chunk,x,y - 1,z);
  }
  if (y < NewChunk.CHUNK_DIMENSION_Y && lightValue < NewChunk.MAX_LIGHT && chunk.getSunlight(x,y + 1,z) < lightValue - 1 && chunk.getBlock(x,y + 1,z).isTranslucent()) {
    chunk.setSunlight(x,y + 1,z,(byte)(lightValue - 1));
    spreadSunlightInternal(chunk,x,y + 1,z);
  }
  if (lightValue <= 1)   return;
  for (  Vector3i adjDir : HORIZONTAL_LIGHT_DIRECTIONS) {
    int adjX=x + adjDir.x;
    int adjZ=z + adjDir.z;
    if (chunk.isInBounds(adjX,y,adjZ)) {
      byte adjLightValue=chunk.getSunlight(adjX,y,adjZ);
      if (adjLightValue < lightValue - 1 && chunk.getBlock(adjX,y,adjZ).isTranslucent()) {
        chunk.setSunlight(adjX,y,adjZ,(byte)(lightValue - 1));
        spreadSunlightInternal(chunk,adjX,y,adjZ);
      }
    }
  }
}",0.6003094378545643
1189,"/** 
 * Returns the byte value at the given position.
 */
public byte get(int x,int y,int z){
  int pos=(x * _lX * _lY) + (y * _lX) + z;
  if (x >= _lX || y >= _lY || z >= _lZ || x < 0 || y < 0 || z < 0)   return -1;
  if (pos < _halfSize) {
    int bArray=_array[pos] & 0xFF;
    return (byte)((bArray & 0x0F) & 0xFF);
  }
  int bArray=_array[pos % _halfSize] & 0xFF;
  return (byte)(bArray >> 4);
}","/** 
 * Returns the byte value at the given position.
 */
public byte get(int x,int y,int z){
  int pos=(x * _lX * _lY) + (y * _lX) + z;
  if (x >= _lX || y >= _lY || z >= _lZ || x < 0 || y < 0 || z < 0) {
    throw new IndexOutOfBoundsException(String.format(""String_Node_Str"",x,y,z));
  }
  if (pos < _halfSize) {
    int bArray=_array[pos] & 0xFF;
    return (byte)((bArray & 0x0F) & 0xFF);
  }
  int bArray=_array[pos % _halfSize] & 0xFF;
  return (byte)(bArray >> 4);
}",0.8878718535469108
1190,"public void update(float delta){
  for (  EntityRef entity : entityManager.iteratorEntities(SimpleMinionAIComponent.class,CharacterMovementComponent.class,LocationComponent.class,MinionComponent.class)) {
    LocationComponent location=entity.getComponent(LocationComponent.class);
    SimpleMinionAIComponent ai=entity.getComponent(SimpleMinionAIComponent.class);
    CharacterMovementComponent moveComp=entity.getComponent(CharacterMovementComponent.class);
    MinionComponent minioncomp=entity.getComponent(MinionComponent.class);
    Vector3f worldPos=location.getWorldPosition();
    moveComp.getDrive().set(0,0,0);
    LocalPlayer localPlayer=CoreRegistry.get(LocalPlayer.class);
    if (localPlayer != null) {
switch (minioncomp.minionBehaviour) {
case Follow:
{
          Vector3f dist=new Vector3f(worldPos);
          dist.sub(localPlayer.getPosition());
          double distanceToPlayer=dist.lengthSquared();
          if (distanceToPlayer > 8) {
            Vector3f target=localPlayer.getPosition();
            ai.movementTarget.set(target);
            ai.followingPlayer=true;
            entity.saveComponent(ai);
          }
          setMovement(ai.movementTarget,worldPos,entity,moveComp,location);
          break;
        }
case Gather:
{
        List<Vector3f> targets=ai.gatherTargets;
        if (targets == null || targets.size() < 1)         break;
        Vector3f currentTarget=targets.get(0);
        Vector3f dist=new Vector3f(worldPos);
        dist.sub(currentTarget);
        double distanceToTarget=dist.lengthSquared();
        if (distanceToTarget < 4) {
          if (timer.getTimeInMs() - ai.lastAttacktime > 500) {
            ai.lastAttacktime=timer.getTimeInMs();
            boolean attacked=attack(entity,currentTarget);
            if (!attacked) {
              ai.gatherTargets.remove(currentTarget);
            }
          }
        }
        entity.saveComponent(ai);
        setMovement(currentTarget,worldPos,entity,moveComp,location);
        break;
      }
case Move:
{
      List<Vector3f> targets=ai.movementTargets;
      if (targets == null || targets.size() < 1)       break;
      Vector3f currentTarget=targets.get(0);
      worldPos.y=worldPos.y - (worldPos.y % 1);
      Vector3f dist=new Vector3f(worldPos);
      dist.sub(currentTarget);
      double distanceToTarget=dist.length();
      if (distanceToTarget < 0.1d) {
        ai.movementTargets.remove(0);
        entity.saveComponent(ai);
        currentTarget=null;
        break;
      }
      setMovement(currentTarget,worldPos,entity,moveComp,location);
      break;
    }
case Patrol:
{
    List<Vector3f> targets=ai.patrolTargets;
    if (targets == null || targets.size() < 1)     break;
    int patrolCounter=ai.patrolCounter;
    Vector3f currentTarget=null;
    if (patrolCounter < targets.size()) {
      currentTarget=targets.get(patrolCounter);
    }
    if (currentTarget == null) {
      break;
    }
    Vector3f dist=new Vector3f(worldPos);
    dist.sub(currentTarget);
    double distanceToTarget=dist.length();
    if (distanceToTarget < 0.1d) {
      patrolCounter++;
      if (!(patrolCounter < targets.size()))       patrolCounter=0;
      ai.patrolCounter=patrolCounter;
      entity.saveComponent(ai);
      break;
    }
    setMovement(currentTarget,worldPos,entity,moveComp,location);
    break;
  }
case Test:
{
  if (!ai.locked) {
    List<Vector3f> targets=ai.movementTargets;
    List<Vector3f> pathTargets=ai.pathTargets;
    if (targets == null || targets.size() < 1)     break;
    Vector3f currentTarget;
    if (pathTargets != null && pathTargets.size() > 0) {
      currentTarget=pathTargets.get(0);
    }
 else {
      currentTarget=targets.get(0);
    }
    if (ai.previousTarget != ai.movementTargets.get(0)) {
      ai.locked=true;
      ai.pathTargets=aStarPathing.findPath(worldPos,currentTarget);
    }
    ai.locked=false;
    if (ai.pathTargets != null && ai.pathTargets.size() > 0) {
      pathTargets=ai.pathTargets;
      pathTargets.get(0);
      ai.previousTarget=targets.get(0);
      currentTarget=pathTargets.get(0);
    }
    worldPos.y=worldPos.y - (worldPos.y % 1);
    Vector3f dist=new Vector3f(worldPos);
    dist.sub(currentTarget);
    double distanceToTarget=dist.length();
    if (distanceToTarget < 1.5d) {
      if (ai.pathTargets != null && ai.pathTargets.size() > 0) {
        ai.pathTargets.remove(0);
        entity.saveComponent(ai);
      }
 else {
        ai.movementTargets.remove(0);
        ai.previousTarget=null;
        entity.saveComponent(ai);
      }
      break;
    }
    setMovement(currentTarget,worldPos,entity,moveComp,location);
    break;
  }
}
default :
{
break;
}
}
}
}
}","public void update(float delta){
  for (  EntityRef entity : entityManager.iteratorEntities(SimpleMinionAIComponent.class,CharacterMovementComponent.class,LocationComponent.class,MinionComponent.class)) {
    LocationComponent location=entity.getComponent(LocationComponent.class);
    SimpleMinionAIComponent ai=entity.getComponent(SimpleMinionAIComponent.class);
    CharacterMovementComponent moveComp=entity.getComponent(CharacterMovementComponent.class);
    MinionComponent minioncomp=entity.getComponent(MinionComponent.class);
    Vector3f worldPos=location.getWorldPosition();
    moveComp.getDrive().set(0,0,0);
    LocalPlayer localPlayer=CoreRegistry.get(LocalPlayer.class);
    if (localPlayer != null) {
switch (minioncomp.minionBehaviour) {
case Follow:
{
          Vector3f dist=new Vector3f(worldPos);
          dist.sub(localPlayer.getPosition());
          double distanceToPlayer=dist.lengthSquared();
          if (distanceToPlayer > 8) {
            Vector3f target=localPlayer.getPosition();
            ai.movementTarget.set(target);
            ai.followingPlayer=true;
            entity.saveComponent(ai);
          }
          setMovement(ai.movementTarget,worldPos,entity,moveComp,location);
          break;
        }
case Gather:
{
        List<Vector3f> targets=ai.gatherTargets;
        if (targets == null || targets.size() < 1)         break;
        Vector3f currentTarget=targets.get(0);
        Vector3f dist=new Vector3f(worldPos);
        dist.sub(currentTarget);
        double distanceToTarget=dist.lengthSquared();
        if (distanceToTarget < 4) {
          if (timer.getTimeInMs() - ai.lastAttacktime > 500) {
            ai.lastAttacktime=timer.getTimeInMs();
            boolean attacked=attack(entity,currentTarget);
            if (!attacked) {
              ai.gatherTargets.remove(currentTarget);
            }
          }
        }
        entity.saveComponent(ai);
        setMovement(currentTarget,worldPos,entity,moveComp,location);
        break;
      }
case Move:
{
      List<Vector3f> targets=ai.movementTargets;
      if (targets == null || targets.size() < 1)       break;
      Vector3f currentTarget=targets.get(0);
      worldPos.y=worldPos.y - (worldPos.y % 1);
      Vector3f dist=new Vector3f(worldPos);
      dist.sub(currentTarget);
      double distanceToTarget=dist.length();
      if (distanceToTarget < 0.1d) {
        ai.movementTargets.remove(0);
        entity.saveComponent(ai);
        currentTarget=null;
        break;
      }
      setMovement(currentTarget,worldPos,entity,moveComp,location);
      break;
    }
case Patrol:
{
    List<Vector3f> targets=ai.patrolTargets;
    if (targets == null || targets.size() < 1)     break;
    int patrolCounter=ai.patrolCounter;
    Vector3f currentTarget=null;
    if (patrolCounter < targets.size()) {
      currentTarget=targets.get(patrolCounter);
    }
    if (currentTarget == null) {
      break;
    }
    Vector3f dist=new Vector3f(worldPos);
    dist.sub(currentTarget);
    double distanceToTarget=dist.length();
    if (distanceToTarget < 0.1d) {
      patrolCounter++;
      if (!(patrolCounter < targets.size()))       patrolCounter=0;
      ai.patrolCounter=patrolCounter;
      entity.saveComponent(ai);
      break;
    }
    setMovement(currentTarget,worldPos,entity,moveComp,location);
    break;
  }
case Test:
{
  if (!ai.locked) {
    List<Vector3f> targets=ai.movementTargets;
    List<Vector3f> pathTargets=ai.pathTargets;
    if (targets == null || targets.size() < 1)     break;
    Vector3f currentTarget;
    if (pathTargets != null && pathTargets.size() > 0) {
      currentTarget=pathTargets.get(0);
    }
 else {
      currentTarget=targets.get(0);
    }
    if (ai.previousTarget != ai.movementTargets.get(0)) {
      ai.locked=true;
      ai.pathTargets=aStarPathing.findPath(worldPos,new Vector3f(currentTarget));
    }
    ai.locked=false;
    if (ai.pathTargets != null && ai.pathTargets.size() > 0) {
      pathTargets=ai.pathTargets;
      ai.previousTarget=targets.get(0);
      currentTarget=pathTargets.get(0);
    }
    worldPos.y=worldPos.y - (worldPos.y % 1);
    Vector3f dist=new Vector3f(worldPos);
    dist.sub(currentTarget);
    double distanceToTarget=dist.length();
    if (distanceToTarget < 0.1d) {
      if (ai.pathTargets != null && ai.pathTargets.size() > 0) {
        ai.pathTargets.remove(0);
        entity.saveComponent(ai);
      }
 else {
        ai.movementTargets.remove(0);
        ai.previousTarget=null;
        entity.saveComponent(ai);
      }
      break;
    }
    setMovement(currentTarget,worldPos,entity,moveComp,location);
    break;
  }
}
default :
{
break;
}
}
}
}
}",0.9407613344739092
1191,"public void update(float delta){
  for (  EntityRef entity : entityManager.iteratorEntities(SimpleMinionAIComponent.class,CharacterMovementComponent.class,LocationComponent.class,MinionComponent.class)) {
    LocationComponent location=entity.getComponent(LocationComponent.class);
    SimpleMinionAIComponent ai=entity.getComponent(SimpleMinionAIComponent.class);
    CharacterMovementComponent moveComp=entity.getComponent(CharacterMovementComponent.class);
    MinionComponent minioncomp=entity.getComponent(MinionComponent.class);
    Vector3f worldPos=location.getWorldPosition();
    moveComp.getDrive().set(0,0,0);
    LocalPlayer localPlayer=CoreRegistry.get(LocalPlayer.class);
    if (localPlayer != null) {
switch (minioncomp.minionBehaviour) {
case Follow:
{
          Vector3f dist=new Vector3f(worldPos);
          dist.sub(localPlayer.getPosition());
          double distanceToPlayer=dist.lengthSquared();
          if (distanceToPlayer > 8) {
            Vector3f target=localPlayer.getPosition();
            ai.movementTarget.set(target);
            ai.followingPlayer=true;
            entity.saveComponent(ai);
          }
          Vector3f targetDirection=new Vector3f();
          targetDirection.sub(ai.movementTarget,worldPos);
          if (targetDirection.x * targetDirection.x + targetDirection.z * targetDirection.z > 0.01f) {
            targetDirection.normalize();
            moveComp.setDrive(targetDirection);
            float yaw=(float)Math.atan2(targetDirection.x,targetDirection.z);
            AxisAngle4f axisAngle=new AxisAngle4f(0,1,0,yaw);
            location.getLocalRotation().set(axisAngle);
          }
 else {
            moveComp.getDrive().set(0,0,0);
          }
          entity.saveComponent(moveComp);
          entity.saveComponent(location);
          break;
        }
case Gather:
{
        List<Vector3f> targets=ai.gatherTargets;
        if (targets == null || targets.size() < 1)         return;
        Vector3f currentTarget=targets.get(0);
        Vector3f dist=new Vector3f(worldPos);
        dist.sub(currentTarget);
        double distanceToTarget=dist.lengthSquared();
        if (distanceToTarget < 4) {
          if (timer.getTimeInMs() - ai.lastAttacktime > 500) {
            ai.lastAttacktime=timer.getTimeInMs();
            boolean attacked=attack(entity,currentTarget);
            if (!attacked) {
              ai.gatherTargets.remove(currentTarget);
            }
          }
        }
        Vector3f targetDirection=new Vector3f();
        targetDirection.sub(currentTarget,worldPos);
        if (targetDirection.x * targetDirection.x + targetDirection.z * targetDirection.z > 0.01f) {
          targetDirection.normalize();
          moveComp.setDrive(targetDirection);
          float yaw=(float)Math.atan2(targetDirection.x,targetDirection.z);
          AxisAngle4f axisAngle=new AxisAngle4f(0,1,0,yaw);
          location.getLocalRotation().set(axisAngle);
        }
 else {
          moveComp.setDrive(new Vector3f());
        }
        entity.saveComponent(ai);
        entity.saveComponent(moveComp);
        entity.saveComponent(location);
        break;
      }
case Move:
{
      List<Vector3f> targets=ai.movementTargets;
      if (targets == null || targets.size() < 1)       return;
      Vector3f currentTarget=targets.get(0);
      Vector3f dist=new Vector3f(worldPos);
      dist.sub(currentTarget);
      double distanceToTarget=dist.length();
      if (distanceToTarget < 1.0d) {
        ai.movementTargets.remove(0);
        entity.saveComponent(ai);
        currentTarget=null;
        break;
      }
      Vector3f targetDirection=new Vector3f();
      targetDirection.sub(currentTarget,worldPos);
      if (targetDirection.x * targetDirection.x + targetDirection.z * targetDirection.z > 0.01f) {
        targetDirection.normalize();
        moveComp.setDrive(targetDirection);
        float yaw=(float)Math.atan2(targetDirection.x,targetDirection.z);
        AxisAngle4f axisAngle=new AxisAngle4f(0,1,0,yaw);
        location.getLocalRotation().set(axisAngle);
      }
 else {
        moveComp.setDrive(new Vector3f());
      }
      entity.saveComponent(moveComp);
      entity.saveComponent(location);
      break;
    }
case Patrol:
{
    List<Vector3f> targets=ai.patrolTargets;
    if (targets == null || targets.size() < 1)     return;
    int patrolCounter=ai.patrolCounter;
    Vector3f currentTarget=null;
    if (patrolCounter < targets.size()) {
      currentTarget=targets.get(patrolCounter);
    }
    if (currentTarget == null) {
      return;
    }
    Vector3f dist=new Vector3f(worldPos);
    dist.sub(currentTarget);
    double distanceToTarget=dist.length();
    if (distanceToTarget < 1.0d) {
      patrolCounter++;
      if (!(patrolCounter < targets.size()))       patrolCounter=0;
      ai.patrolCounter=patrolCounter;
      entity.saveComponent(ai);
      break;
    }
    Vector3f targetDirection=new Vector3f();
    targetDirection.sub(currentTarget,worldPos);
    if (targetDirection.x * targetDirection.x + targetDirection.z * targetDirection.z > 0.01f) {
      targetDirection.normalize();
      moveComp.setDrive(targetDirection);
      float yaw=(float)Math.atan2(targetDirection.x,targetDirection.z);
      AxisAngle4f axisAngle=new AxisAngle4f(0,1,0,yaw);
      location.getLocalRotation().set(axisAngle);
    }
 else {
      moveComp.setDrive(new Vector3f());
    }
    entity.saveComponent(moveComp);
    entity.saveComponent(location);
    break;
  }
case Test:
{
}
default :
{
break;
}
}
}
}
}","public void update(float delta){
  for (  EntityRef entity : entityManager.iteratorEntities(SimpleMinionAIComponent.class,CharacterMovementComponent.class,LocationComponent.class,MinionComponent.class)) {
    LocationComponent location=entity.getComponent(LocationComponent.class);
    SimpleMinionAIComponent ai=entity.getComponent(SimpleMinionAIComponent.class);
    CharacterMovementComponent moveComp=entity.getComponent(CharacterMovementComponent.class);
    MinionComponent minioncomp=entity.getComponent(MinionComponent.class);
    Vector3f worldPos=location.getWorldPosition();
    moveComp.getDrive().set(0,0,0);
    LocalPlayer localPlayer=CoreRegistry.get(LocalPlayer.class);
    if (localPlayer != null) {
switch (minioncomp.minionBehaviour) {
case Follow:
{
          Vector3f dist=new Vector3f(worldPos);
          dist.sub(localPlayer.getPosition());
          double distanceToPlayer=dist.lengthSquared();
          if (distanceToPlayer > 8) {
            Vector3f target=localPlayer.getPosition();
            ai.movementTarget.set(target);
            ai.followingPlayer=true;
            entity.saveComponent(ai);
          }
          Vector3f targetDirection=new Vector3f();
          targetDirection.sub(ai.movementTarget,worldPos);
          if (targetDirection.x * targetDirection.x + targetDirection.z * targetDirection.z > 0.01f) {
            targetDirection.normalize();
            moveComp.setDrive(targetDirection);
            float yaw=(float)Math.atan2(targetDirection.x,targetDirection.z);
            AxisAngle4f axisAngle=new AxisAngle4f(0,1,0,yaw);
            location.getLocalRotation().set(axisAngle);
          }
 else {
            moveComp.getDrive().set(0,0,0);
          }
          entity.saveComponent(moveComp);
          entity.saveComponent(location);
          break;
        }
case Gather:
{
        List<Vector3f> targets=ai.gatherTargets;
        if (targets == null || targets.size() < 1)         break;
        Vector3f currentTarget=targets.get(0);
        Vector3f dist=new Vector3f(worldPos);
        dist.sub(currentTarget);
        double distanceToTarget=dist.lengthSquared();
        if (distanceToTarget < 4) {
          if (timer.getTimeInMs() - ai.lastAttacktime > 500) {
            ai.lastAttacktime=timer.getTimeInMs();
            boolean attacked=attack(entity,currentTarget);
            if (!attacked) {
              ai.gatherTargets.remove(currentTarget);
            }
          }
        }
        Vector3f targetDirection=new Vector3f();
        targetDirection.sub(currentTarget,worldPos);
        if (targetDirection.x * targetDirection.x + targetDirection.z * targetDirection.z > 0.01f) {
          targetDirection.normalize();
          moveComp.setDrive(targetDirection);
          float yaw=(float)Math.atan2(targetDirection.x,targetDirection.z);
          AxisAngle4f axisAngle=new AxisAngle4f(0,1,0,yaw);
          location.getLocalRotation().set(axisAngle);
        }
 else {
          moveComp.setDrive(new Vector3f());
        }
        entity.saveComponent(ai);
        entity.saveComponent(moveComp);
        entity.saveComponent(location);
        break;
      }
case Move:
{
      List<Vector3f> targets=ai.movementTargets;
      if (targets == null || targets.size() < 1)       break;
      Vector3f currentTarget=targets.get(0);
      Vector3f dist=new Vector3f(worldPos);
      dist.sub(currentTarget);
      double distanceToTarget=dist.length();
      if (distanceToTarget < 1.0d) {
        ai.movementTargets.remove(0);
        entity.saveComponent(ai);
        currentTarget=null;
        break;
      }
      Vector3f targetDirection=new Vector3f();
      targetDirection.sub(currentTarget,worldPos);
      if (targetDirection.x * targetDirection.x + targetDirection.z * targetDirection.z > 0.01f) {
        targetDirection.normalize();
        moveComp.setDrive(targetDirection);
        float yaw=(float)Math.atan2(targetDirection.x,targetDirection.z);
        AxisAngle4f axisAngle=new AxisAngle4f(0,1,0,yaw);
        location.getLocalRotation().set(axisAngle);
      }
 else {
        moveComp.setDrive(new Vector3f());
      }
      entity.saveComponent(moveComp);
      entity.saveComponent(location);
      break;
    }
case Patrol:
{
    List<Vector3f> targets=ai.patrolTargets;
    if (targets == null || targets.size() < 1)     break;
    int patrolCounter=ai.patrolCounter;
    Vector3f currentTarget=null;
    if (patrolCounter < targets.size()) {
      currentTarget=targets.get(patrolCounter);
    }
    if (currentTarget == null) {
      break;
    }
    Vector3f dist=new Vector3f(worldPos);
    dist.sub(currentTarget);
    double distanceToTarget=dist.length();
    if (distanceToTarget < 1.0d) {
      patrolCounter++;
      if (!(patrolCounter < targets.size()))       patrolCounter=0;
      ai.patrolCounter=patrolCounter;
      entity.saveComponent(ai);
      break;
    }
    Vector3f targetDirection=new Vector3f();
    targetDirection.sub(currentTarget,worldPos);
    if (targetDirection.x * targetDirection.x + targetDirection.z * targetDirection.z > 0.01f) {
      targetDirection.normalize();
      moveComp.setDrive(targetDirection);
      float yaw=(float)Math.atan2(targetDirection.x,targetDirection.z);
      AxisAngle4f axisAngle=new AxisAngle4f(0,1,0,yaw);
      location.getLocalRotation().set(axisAngle);
    }
 else {
      moveComp.setDrive(new Vector3f());
    }
    entity.saveComponent(moveComp);
    entity.saveComponent(location);
    break;
  }
case Test:
{
}
default :
{
break;
}
}
}
}
}",0.9960260115606936
1192,"public void RightMouseReleased(){
  UIMinion minionbehaviourmenu=(UIMinion)GUIManager.getInstance().getWindowById(behaviourmenu);
  if (minionbehaviourmenu != null) {
    GUIManager.getInstance().removeWindow(minionbehaviourmenu);
    if (GUIManager.getInstance().getWindowById(""String_Node_Str"") != null) {
      GUIManager.getInstance().setFocusedWindow(""String_Node_Str"");
    }
  }
  setMinionSelectMode(false);
  if (getSelectedBehaviour() == MinionComponent.MinionBehaviour.Disappear) {
    DestroyActiveMinion();
  }
 else   if (getSelectedBehaviour() == MinionComponent.MinionBehaviour.Inventory) {
    LocalPlayer localPlayer=CoreRegistry.get(LocalPlayer.class);
    if (localPlayer == null)     return;
    getSelectedMinion().send(new ActivateEvent(getSelectedMinion(),localPlayer.getEntity()));
  }
  MinionComponent minioncomp=getSelectedMinion().getComponent(MinionComponent.class);
  getSelectedMinion().saveComponent(minioncomp);
}","public void RightMouseReleased(){
  UIMinion minionbehaviourmenu=(UIMinion)GUIManager.getInstance().getWindowById(behaviourmenu);
  if (minionbehaviourmenu != null) {
    GUIManager.getInstance().removeWindow(minionbehaviourmenu);
    if (GUIManager.getInstance().getWindowById(""String_Node_Str"") != null) {
      GUIManager.getInstance().setFocusedWindow(""String_Node_Str"");
    }
  }
  setMinionSelectMode(false);
  if (getSelectedBehaviour() == MinionComponent.MinionBehaviour.Disappear) {
    DestroyActiveMinion();
  }
 else   if (getSelectedBehaviour() == MinionComponent.MinionBehaviour.Inventory) {
    LocalPlayer localPlayer=CoreRegistry.get(LocalPlayer.class);
    if (localPlayer == null)     return;
    getSelectedMinion().send(new ActivateEvent(getSelectedMinion(),localPlayer.getEntity()));
    MinionComponent minioncomp=getSelectedMinion().getComponent(MinionComponent.class);
    minioncomp.minionBehaviour=MinionComponent.MinionBehaviour.Move;
  }
  MinionComponent minioncomp=getSelectedMinion().getComponent(MinionComponent.class);
  getSelectedMinion().saveComponent(minioncomp);
}",0.923451974646514
1193,"public void init(GameEngine engine){
  ModManager modManager=new ModManager();
  for (  Mod mod : modManager.getMods()) {
    mod.setEnabled(true);
  }
  modManager.saveModSelectionToConfig();
  BlockShapeManager.getInstance().reload();
  componentLibrary=new ComponentLibraryImpl();
  componentLibrary.registerTypeHandler(BlockFamily.class,new BlockFamilyTypeHandler());
  componentLibrary.registerTypeHandler(Color4f.class,new Color4fTypeHandler());
  componentLibrary.registerTypeHandler(Quat4f.class,new Quat4fTypeHandler());
  componentLibrary.registerTypeHandler(Sound.class,new SoundTypeHandler(AudioManager.getInstance()));
  componentLibrary.registerTypeHandler(Vector3f.class,new Vector3fTypeHandler());
  componentLibrary.registerTypeHandler(Vector2f.class,new Vector2fTypeHandler());
  componentLibrary.registerTypeHandler(Vector3i.class,new Vector3iTypeHandler());
  PrefabManager prefabManager=new PojoPrefabManager();
  CoreRegistry.put(PrefabManager.class,prefabManager);
  _entityManager=new PojoEntityManager(componentLibrary,prefabManager);
  _entityManager.setEventSystem(new PojoEventSystem(_entityManager));
  CoreRegistry.put(EntityManager.class,_entityManager);
  _componentSystemManager=new ComponentSystemManager();
  CoreRegistry.put(ComponentSystemManager.class,_componentSystemManager);
  CoreRegistry.put(WorldPersister.class,new WorldPersister(componentLibrary,_entityManager));
  componentLibrary.registerComponentClass(ExplosionActionComponent.class);
  componentLibrary.registerComponentClass(PlaySoundActionComponent.class);
  componentLibrary.registerComponentClass(TunnelActionComponent.class);
  componentLibrary.registerComponentClass(AABBCollisionComponent.class);
  componentLibrary.registerComponentClass(BlockComponent.class);
  componentLibrary.registerComponentClass(BlockItemComponent.class);
  componentLibrary.registerComponentClass(BlockParticleEffectComponent.class);
  componentLibrary.registerComponentClass(CameraComponent.class);
  componentLibrary.registerComponentClass(CharacterMovementComponent.class);
  componentLibrary.registerComponentClass(CharacterSoundComponent.class);
  componentLibrary.registerComponentClass(HealthComponent.class);
  componentLibrary.registerComponentClass(InventoryComponent.class);
  componentLibrary.registerComponentClass(ItemComponent.class);
  componentLibrary.registerComponentClass(LightComponent.class);
  componentLibrary.registerComponentClass(LocalPlayerComponent.class);
  componentLibrary.registerComponentClass(LocationComponent.class);
  componentLibrary.registerComponentClass(MeshComponent.class);
  componentLibrary.registerComponentClass(PlayerComponent.class);
  componentLibrary.registerComponentClass(SimpleAIComponent.class);
  componentLibrary.registerComponentClass(SimpleMinionAIComponent.class);
  componentLibrary.registerComponentClass(MinionBarComponent.class);
  componentLibrary.registerComponentClass(MinionComponent.class);
  componentLibrary.registerComponentClass(AccessInventoryActionComponent.class);
  componentLibrary.registerComponentClass(SpawnPrefabActionComponent.class);
  componentLibrary.registerComponentClass(BookComponent.class);
  componentLibrary.registerComponentClass(BookshelfComponent.class);
  loadPrefabs();
  BlockEntityRegistry blockEntityRegistry=new BlockEntityRegistry();
  _componentSystemManager.register(blockEntityRegistry,""String_Node_Str"");
  CoreRegistry.put(BlockEntityRegistry.class,blockEntityRegistry);
  _componentSystemManager.register(new CharacterMovementSystem(),""String_Node_Str"");
  _componentSystemManager.register(new SimpleAISystem(),""String_Node_Str"");
  _componentSystemManager.register(new SimpleMinionAISystem(),""String_Node_Str"");
  _componentSystemManager.register(new ItemSystem(),""String_Node_Str"");
  _componentSystemManager.register(new CharacterSoundSystem(),""String_Node_Str"");
  _localPlayerSys=new LocalPlayerSystem();
  _componentSystemManager.register(_localPlayerSys,""String_Node_Str"");
  _componentSystemManager.register(new FirstPersonRenderer(),""String_Node_Str"");
  _componentSystemManager.register(new HealthSystem(),""String_Node_Str"");
  _componentSystemManager.register(new BlockEntitySystem(),""String_Node_Str"");
  _componentSystemManager.register(new BlockParticleEmitterSystem(),""String_Node_Str"");
  _componentSystemManager.register(new BlockDamageRenderer(),""String_Node_Str"");
  _componentSystemManager.register(new InventorySystem(),""String_Node_Str"");
  _componentSystemManager.register(new MeshRenderer(),""String_Node_Str"");
  _componentSystemManager.register(new ExplosionAction(),""String_Node_Str"");
  _componentSystemManager.register(new PlaySoundAction(),""String_Node_Str"");
  _componentSystemManager.register(new TunnelAction(),""String_Node_Str"");
  _componentSystemManager.register(new AccessInventoryAction(),""String_Node_Str"");
  _componentSystemManager.register(new SpawnPrefabAction(),""String_Node_Str"");
  _componentSystemManager.register(new ReadBookAction(),""String_Node_Str"");
  _componentSystemManager.register(new DestroyMinion(),""String_Node_Str"");
  _componentSystemManager.register(new BookshelfHandler(),""String_Node_Str"");
  _hud=new UIHeadsUpDisplay();
  _hud.setVisible(true);
  _pauseMenu=new UIPauseMenu();
  _loadingScreen=new UILoadingScreen();
  _statusScreen=new UIStatusScreen();
  _inventoryScreen=new UIInventoryScreen();
  _metrics=new UIMetrics();
  _metrics.setVisible(true);
  _guiScreens.add(_metrics);
  _guiScreens.add(_hud);
  _guiScreens.add(_pauseMenu);
  _guiScreens.add(_loadingScreen);
  _guiScreens.add(_inventoryScreen);
  _guiScreens.add(_statusScreen);
}","public void init(GameEngine engine){
  ModManager modManager=new ModManager();
  for (  Mod mod : modManager.getMods()) {
    mod.setEnabled(true);
  }
  modManager.saveModSelectionToConfig();
  BlockShapeManager.getInstance().reload();
  componentLibrary=new ComponentLibraryImpl();
  componentLibrary.registerTypeHandler(BlockFamily.class,new BlockFamilyTypeHandler());
  componentLibrary.registerTypeHandler(Color4f.class,new Color4fTypeHandler());
  componentLibrary.registerTypeHandler(Quat4f.class,new Quat4fTypeHandler());
  componentLibrary.registerTypeHandler(Sound.class,new SoundTypeHandler(AudioManager.getInstance()));
  componentLibrary.registerTypeHandler(Vector3f.class,new Vector3fTypeHandler());
  componentLibrary.registerTypeHandler(Vector2f.class,new Vector2fTypeHandler());
  componentLibrary.registerTypeHandler(Vector3i.class,new Vector3iTypeHandler());
  PrefabManager prefabManager=new PojoPrefabManager();
  CoreRegistry.put(PrefabManager.class,prefabManager);
  _entityManager=new PojoEntityManager(componentLibrary,prefabManager);
  _entityManager.setEventSystem(new PojoEventSystem(_entityManager));
  CoreRegistry.put(EntityManager.class,_entityManager);
  _componentSystemManager=new ComponentSystemManager();
  CoreRegistry.put(ComponentSystemManager.class,_componentSystemManager);
  CoreRegistry.put(WorldPersister.class,new WorldPersister(componentLibrary,_entityManager));
  componentLibrary.registerComponentClass(ExplosionActionComponent.class);
  componentLibrary.registerComponentClass(PlaySoundActionComponent.class);
  componentLibrary.registerComponentClass(TunnelActionComponent.class);
  componentLibrary.registerComponentClass(AABBCollisionComponent.class);
  componentLibrary.registerComponentClass(BlockComponent.class);
  componentLibrary.registerComponentClass(BlockItemComponent.class);
  componentLibrary.registerComponentClass(BlockParticleEffectComponent.class);
  componentLibrary.registerComponentClass(CameraComponent.class);
  componentLibrary.registerComponentClass(CharacterMovementComponent.class);
  componentLibrary.registerComponentClass(CharacterSoundComponent.class);
  componentLibrary.registerComponentClass(HealthComponent.class);
  componentLibrary.registerComponentClass(InventoryComponent.class);
  componentLibrary.registerComponentClass(ItemComponent.class);
  componentLibrary.registerComponentClass(LightComponent.class);
  componentLibrary.registerComponentClass(LocalPlayerComponent.class);
  componentLibrary.registerComponentClass(LocationComponent.class);
  componentLibrary.registerComponentClass(MeshComponent.class);
  componentLibrary.registerComponentClass(PlayerComponent.class);
  componentLibrary.registerComponentClass(SimpleAIComponent.class);
  componentLibrary.registerComponentClass(SimpleMinionAIComponent.class);
  componentLibrary.registerComponentClass(MinionBarComponent.class);
  componentLibrary.registerComponentClass(MinionComponent.class);
  componentLibrary.registerComponentClass(AccessInventoryActionComponent.class);
  componentLibrary.registerComponentClass(SpawnPrefabActionComponent.class);
  componentLibrary.registerComponentClass(BookComponent.class);
  componentLibrary.registerComponentClass(BookshelfComponent.class);
  loadPrefabs();
  BlockEntityRegistry blockEntityRegistry=new BlockEntityRegistry();
  _componentSystemManager.register(blockEntityRegistry,""String_Node_Str"");
  CoreRegistry.put(BlockEntityRegistry.class,blockEntityRegistry);
  _componentSystemManager.register(new CharacterMovementSystem(),""String_Node_Str"");
  _componentSystemManager.register(new SimpleAISystem(),""String_Node_Str"");
  _componentSystemManager.register(new SimpleMinionAISystem(),""String_Node_Str"");
  _componentSystemManager.register(new ItemSystem(),""String_Node_Str"");
  _componentSystemManager.register(new CharacterSoundSystem(),""String_Node_Str"");
  _localPlayerSys=new LocalPlayerSystem();
  _componentSystemManager.register(_localPlayerSys,""String_Node_Str"");
  _componentSystemManager.register(new FirstPersonRenderer(),""String_Node_Str"");
  _componentSystemManager.register(new HealthSystem(),""String_Node_Str"");
  _componentSystemManager.register(new BlockEntitySystem(),""String_Node_Str"");
  _componentSystemManager.register(new BlockParticleEmitterSystem(),""String_Node_Str"");
  _componentSystemManager.register(new BlockDamageRenderer(),""String_Node_Str"");
  _componentSystemManager.register(new InventorySystem(),""String_Node_Str"");
  _componentSystemManager.register(new MeshRenderer(),""String_Node_Str"");
  _componentSystemManager.register(new ExplosionAction(),""String_Node_Str"");
  _componentSystemManager.register(new PlaySoundAction(),""String_Node_Str"");
  _componentSystemManager.register(new TunnelAction(),""String_Node_Str"");
  _componentSystemManager.register(new AccessInventoryAction(),""String_Node_Str"");
  _componentSystemManager.register(new SpawnPrefabAction(),""String_Node_Str"");
  _componentSystemManager.register(new ReadBookAction(),""String_Node_Str"");
  _componentSystemManager.register(new BookshelfHandler(),""String_Node_Str"");
  _hud=new UIHeadsUpDisplay();
  _hud.setVisible(true);
  _pauseMenu=new UIPauseMenu();
  _loadingScreen=new UILoadingScreen();
  _statusScreen=new UIStatusScreen();
  _inventoryScreen=new UIInventoryScreen();
  _metrics=new UIMetrics();
  _metrics.setVisible(true);
  _guiScreens.add(_metrics);
  _guiScreens.add(_hud);
  _guiScreens.add(_pauseMenu);
  _guiScreens.add(_loadingScreen);
  _guiScreens.add(_inventoryScreen);
  _guiScreens.add(_statusScreen);
}",0.9932669000807972
1194,"public void addText(String addtext) throws IOException {
  String wrappedtext=""String_Node_Str"";
  int linecounter=0;
  String[] parts=addtext.split(newLine);
  ArrayList<String> finaltext=new ArrayList<String>();
  int width=Display.getWidth() - 8;
  int charCount=(int)(width / 7);
  for (int i=0; i < parts.length; i++) {
    if (parts[i].length() > charCount) {
      int endpoint=charCount;
      int beginpoint=0;
      while (endpoint > beginpoint) {
        for (int j=endpoint; j > beginpoint; j--) {
          Character ch=parts[i].charAt(j);
          if (Character.isSpaceChar(ch)) {
            endpoint=j;
            break;
          }
 else {
switch (ch) {
case '.':
case '?':
case ';':
case ':':
case '\t':
case '!':
              endpoint=j;
            break;
        }
      }
    }
    finaltext.add(parts[i].substring(beginpoint,endpoint) + newLine);
    linecounter++;
    beginpoint=endpoint + 1;
    endpoint=beginpoint + charCount;
    if (endpoint > parts[i].length() - 1) {
      finaltext.add(parts[i].substring(beginpoint,parts[i].length() - 1) + newLine);
      linecounter++;
      endpoint=-1;
    }
  }
}
 else {
  finaltext.add(parts[i] + newLine);
  linecounter++;
}
}
Gson gson=new Gson();
JsonWriter writer=new JsonWriter(new FileWriter(""String_Node_Str""));
writer.beginArray();
Iterator e=finaltext.iterator();
while (e.hasNext()) {
gson.toJson(e.next(),String.class,writer);
}
writer.endArray();
writer.close();
}","public void addText(String addtext) throws IOException {
  String wrappedtext=""String_Node_Str"";
  int linecounter=0;
  String[] parts=addtext.split(newLine);
  ArrayList<String> finaltext=new ArrayList<String>();
  int width=Display.getWidth() - 8;
  int charCount=(int)(width / 7);
  for (int i=0; i < parts.length; i++) {
    if (parts[i].length() > charCount) {
      int endpoint=charCount;
      int beginpoint=0;
      while (endpoint > beginpoint) {
        for (int j=endpoint; j > beginpoint; j--) {
          Character ch=parts[i].charAt(j);
          if (Character.isSpaceChar(ch)) {
            endpoint=j;
            break;
          }
 else {
switch (ch) {
case '.':
case '?':
case ';':
case ':':
case '\t':
case '!':
              endpoint=j;
            break;
        }
      }
    }
    finaltext.add(parts[i].substring(beginpoint,endpoint) + newLine);
    linecounter++;
    beginpoint=endpoint + 1;
    endpoint=beginpoint + charCount;
    if (endpoint > parts[i].length() - 1) {
      finaltext.add(parts[i].substring(beginpoint,parts[i].length()) + newLine);
      linecounter++;
      endpoint=-1;
    }
  }
}
 else {
  finaltext.add(parts[i] + newLine);
  linecounter++;
}
}
Gson gson=new Gson();
JsonWriter writer=new JsonWriter(new FileWriter(""String_Node_Str""));
writer.beginArray();
Iterator e=finaltext.iterator();
while (e.hasNext()) {
gson.toJson(e.next(),String.class,writer);
}
writer.endArray();
writer.close();
}",0.9986216402481048
1195,"public void renderWithLightValue(float light){
  if (isInvisible())   return;
  ShaderProgram shader=ShaderManager.getInstance().getShaderProgram(""String_Node_Str"");
  shader.enable();
  shader.setFloat(""String_Node_Str"",light);
  if (_mesh == null) {
    Tessellator tessellator=new Tessellator();
    tessellator.setColor(new Vector4f(1,1,1,1));
    if (_centerMesh != null) {
      tessellator.addMeshPart(_centerMesh);
    }
    for (    Side dir : Side.values()) {
      BlockMeshPart part=_sideMesh.get(dir);
      if (part != null) {
        float lightLevel=DIRECTION_LIT_LEVEL.get(dir);
        tessellator.setColor(new Vector4f(lightLevel,lightLevel,lightLevel,lightLevel));
        tessellator.addMeshPart(part);
      }
    }
    _mesh=tessellator.generateMesh();
  }
  if (getBlockForm() != BLOCK_FORM.BILLBOARD) {
    _mesh.render();
  }
 else {
    glDisable(GL11.GL_CULL_FACE);
    _mesh.render();
    glEnable(GL11.GL_CULL_FACE);
  }
}","public void renderWithLightValue(float light){
  if (isInvisible())   return;
  ShaderProgram shader=ShaderManager.getInstance().getShaderProgram(""String_Node_Str"");
  shader.enable();
  shader.setFloat(""String_Node_Str"",light);
  if (_mesh == null) {
    Tessellator tessellator=new Tessellator();
    tessellator.setColor(new Vector4f(1,1,1,1));
    if (_centerMesh != null) {
      tessellator.addMeshPart(_centerMesh);
    }
    for (    Side dir : Side.values()) {
      BlockMeshPart part=_sideMesh.get(dir);
      if (part != null) {
        float lightLevel=DIRECTION_LIT_LEVEL.get(dir);
        tessellator.setColor(new Vector4f(lightLevel,lightLevel,lightLevel,lightLevel));
        tessellator.addMeshPart(part);
      }
    }
    _mesh=tessellator.generateMesh();
  }
  if (getBlockForm() != BLOCK_FORM.BILLBOARD || !glIsEnabled(GL11.GL_CULL_FACE)) {
    _mesh.render();
  }
 else {
    glDisable(GL11.GL_CULL_FACE);
    _mesh.render();
    glEnable(GL11.GL_CULL_FACE);
  }
}",0.9283135636926252
1196,"public HashMap<Byte,String> getGroovyBlocks(){
  HashMap<Byte,String> retval=new HashMap<Byte,String>();
  for (byte i=-127; i < 128; i++) {
    Block b=BlockManager.getInstance().getBlock(i);
    if (b.getId() != 0) {
      retval.put(b.getId(),b.getTitle());
    }
    if (i == 117) {
      break;
    }
  }
  return retval;
}","public HashMap<Byte,String> getGroovyBlocks(){
  HashMap<Byte,String> retval=new HashMap<Byte,String>();
  String[] endfilter={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String fampref=""String_Node_Str"";
  String tempval=""String_Node_Str"";
  boolean nodup=true;
  for (byte i=-127; i < 127; i++) {
    Block b=BlockManager.getInstance().getBlock(i);
    if (b.getId() != 0) {
      if (tempval.length() > 0) {
        if (b.getTitle().startsWith(tempval)) {
          nodup=false;
        }
 else {
          nodup=true;
          tempval=""String_Node_Str"";
        }
      }
 else {
        for (int j=0; j < endfilter.length; j++) {
          if (b.getTitle().endsWith(endfilter[j])) {
            tempval=b.getTitle().substring(0,b.getTitle().length() - endfilter[j].length());
          }
        }
      }
      if (nodup) {
        String tempfam=b.getBlockFamily().toString().split(""String_Node_Str"")[0];
        if (tempfam.startsWith(fampref)) {
          tempfam=tempfam.substring(fampref.length(),tempfam.length());
        }
        if (tempval.length() < 1) {
          retval.put(b.getId(),b.getTitle() + ""String_Node_Str"" + tempfam);
        }
 else {
          retval.put(b.getId(),tempval + ""String_Node_Str"" + tempfam);
        }
      }
    }
    if (i == 127) {
      break;
    }
  }
  return retval;
}",0.3720930232558139
1197,"@Override public void update(){
  if (_wheelMoved != 0) {
    if (_wheelMoved == 120) {
      currentpos++;
    }
 else {
      currentpos--;
    }
    _wheelMoved=0;
    try {
      showFromJson();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","@Override public void update(){
  if (wheelycount != 0) {
    currentpos+=wheelycount;
    wheelycount=0;
    try {
      showFromJson();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}",0.7056367432150313
1198,"public void showFromJson() throws IOException {
  int maxlines=getLineCount();
  int screenlines=getScreenLines();
  long beginpos, endpos, counter;
  if (screenlines + currentpos > maxlines) {
    beginpos=-1;
  }
 else {
    beginpos=maxlines - (screenlines + currentpos) + 1;
  }
  endpos=beginpos + screenlines;
  if (endpos > maxlines) {
    endpos=maxlines + 1;
  }
  counter=0;
  Gson gson=new Gson();
  JsonReader reader=new JsonReader(new FileReader(""String_Node_Str""));
  reader.beginArray();
  _text=""String_Node_Str"";
  while (reader.hasNext()) {
    if (counter > beginpos && counter < endpos) {
      _text+=gson.fromJson(reader,String.class);
    }
 else {
      gson.fromJson(reader,String.class);
    }
    counter++;
  }
  reader.endArray();
  reader.close();
}","public void showFromJson() throws IOException {
  int maxlines=getLineCount();
  int screenlines=getScreenLines();
  long beginpos, endpos, counter;
  if (screenlines > maxlines) {
    beginpos=-1;
  }
 else {
    if (currentpos < 0) {
      currentpos=0;
    }
    if (currentpos > maxlines - screenlines) {
      currentpos=maxlines - screenlines;
    }
    beginpos=maxlines - (screenlines + currentpos) - 1;
  }
  endpos=beginpos + screenlines + 1;
  counter=0;
  Gson gson=new Gson();
  JsonReader reader=new JsonReader(new FileReader(""String_Node_Str""));
  reader.beginArray();
  _text=""String_Node_Str"";
  while (reader.hasNext()) {
    if (counter > beginpos && counter < endpos) {
      _text+=gson.fromJson(reader,String.class);
    }
 else {
      gson.fromJson(reader,String.class);
    }
    counter++;
  }
  reader.endArray();
  reader.close();
}",0.8212324588163514
1199,"private void getHelp(String commandstring) throws IOException {
  String[] split=commandstring.split(""String_Node_Str"");
  if (split.length > 1) {
    if (split[1].equals(""String_Node_Str"")) {
      GroovyHelpManager groovyhelpmanager=new GroovyHelpManager();
      HashMap<String,String> commandhelp=groovyhelpmanager.getHelpCommands();
      String[] commandlist=groovyhelpmanager.getGroovyCommands();
      String retval=""String_Node_Str"" + newLine + newLine;
      for (int i=0; i < commandlist.length; i++) {
        if (commandhelp.containsKey(commandlist[i])) {
          retval+=commandlist[i].toString() + ""String_Node_Str"" + commandhelp.get(commandlist[i]).toString()+ newLine;
        }
 else {
          retval+=commandlist[i].toString() + ""String_Node_Str"" + newLine;
        }
      }
      setHelpText(retval);
      return;
    }
    GroovyHelpManager groovyhelpmanager=new GroovyHelpManager();
    if (groovyhelpmanager.getHelpCommands().containsKey(split[1])) {
      GroovyHelp groovyhelp=groovyhelpmanager.readCommandHelp(split[1]);
      setHelpText(groovyhelp);
      return;
    }
    if (split[1].equals(""String_Node_Str"")) {
      String tempval=""String_Node_Str"";
      HashMap<Byte,String> blocks=groovyhelpmanager.getGroovyBlocks();
      for (byte i=0; i < blocks.size(); i++) {
        tempval+=""String_Node_Str"" + blocks.get(i) + ""String_Node_Str""+ i+ newLine;
      }
      setHelpText(tempval);
      return;
    }
    showError();
  }
 else {
    showHelp();
  }
}","private void getHelp(String commandstring) throws IOException {
  String[] split=commandstring.split(""String_Node_Str"");
  if (split.length > 1) {
    if (split[1].equals(""String_Node_Str"")) {
      GroovyHelpManager groovyhelpmanager=new GroovyHelpManager();
      HashMap<String,String> commandhelp=groovyhelpmanager.getHelpCommands();
      String[] commandlist=groovyhelpmanager.getGroovyCommands();
      String retval=""String_Node_Str"" + newLine + newLine;
      for (int i=0; i < commandlist.length; i++) {
        if (commandhelp.containsKey(commandlist[i])) {
          retval+=commandlist[i].toString() + ""String_Node_Str"" + commandhelp.get(commandlist[i]).toString()+ newLine;
        }
 else {
          retval+=commandlist[i].toString() + ""String_Node_Str"" + newLine;
        }
      }
      setHelpText(retval);
      return;
    }
    GroovyHelpManager groovyhelpmanager=new GroovyHelpManager();
    if (groovyhelpmanager.getHelpCommands().containsKey(split[1])) {
      GroovyHelp groovyhelp=groovyhelpmanager.readCommandHelp(split[1]);
      setHelpText(groovyhelp);
      return;
    }
    if (split[1].equals(""String_Node_Str"")) {
      String tempval=""String_Node_Str"";
      HashMap<Byte,String> blocks=groovyhelpmanager.getGroovyBlocks();
      for (byte i=0; i < Byte.MAX_VALUE; i++) {
        if (blocks.containsKey(i)) {
          tempval+=""String_Node_Str"" + blocks.get(i) + ""String_Node_Str""+ i+ newLine;
        }
      }
      setHelpText(tempval);
      return;
    }
    showError();
  }
 else {
    showHelp();
  }
}",0.9763624425476034
1200,"private void setupSelectWorldMenu(){
  _selectWorldMenu=new UISelectWorldMenu();
  _selectWorldMenu.setVisible(false);
  UIButton goToBack=(UIButton)_selectWorldMenu.getElementById(""String_Node_Str"");
  goToBack.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _selectWorldMenu.setVisible(false);
      _mainMenu.setVisible(true);
    }
  }
);
}","private void setupSelectWorldMenu(){
  _selectWorldMenu=new UISelectWorldMenu();
  _selectWorldMenu.setVisible(false);
  UIButton goToBack=(UIButton)_selectWorldMenu.getElementById(""String_Node_Str"");
  goToBack.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      GUIManager.getInstance().setFocusedWindow(_mainMenu);
    }
  }
);
}",0.8711340206185567
1201,"public void activate(){
  Mouse.setGrabbed(false);
  playBackgroundMusic();
  UIButton graphicsQualityButton=(UIButton)_configMenu.getElementById(""String_Node_Str"");
  UIButton FOVButton=(UIButton)_configMenu.getElementById(""String_Node_Str"");
  UIButton viewingDistanceButton=(UIButton)_configMenu.getElementById(""String_Node_Str"");
  if (Config.getInstance().getActiveViewingDistanceId() == 3)   viewingDistanceButton.getLabel().setText(""String_Node_Str"");
 else   if (Config.getInstance().getActiveViewingDistanceId() == 1)   viewingDistanceButton.getLabel().setText(""String_Node_Str"");
 else   if (Config.getInstance().getActiveViewingDistanceId() == 2)   viewingDistanceButton.getLabel().setText(""String_Node_Str"");
 else   viewingDistanceButton.getLabel().setText(""String_Node_Str"");
  if (Config.getInstance().getGraphicsQuality() == 1)   graphicsQualityButton.getLabel().setText(""String_Node_Str"");
 else   if (Config.getInstance().getGraphicsQuality() == 2)   graphicsQualityButton.getLabel().setText(""String_Node_Str"");
 else   graphicsQualityButton.getLabel().setText(""String_Node_Str"");
  FOVButton.getLabel().setText(""String_Node_Str"" + (int)Config.getInstance().getFov());
}","public void activate(){
  Mouse.setGrabbed(false);
  playBackgroundMusic();
  GUIManager.getInstance().getWindowById(""String_Node_Str"").setVisible(true);
  GUIManager.getInstance().getWindowById(""String_Node_Str"").setVisible(false);
  GUIManager.getInstance().getWindowById(""String_Node_Str"").setVisible(false);
  GUIManager.getInstance().getWindowById(""String_Node_Str"").setVisible(false);
  GUIManager.getInstance().setFocusedWindow(""String_Node_Str"");
  UIButton graphicsQualityButton=(UIButton)_configMenu.getElementById(""String_Node_Str"");
  UIButton FOVButton=(UIButton)_configMenu.getElementById(""String_Node_Str"");
  UIButton viewingDistanceButton=(UIButton)_configMenu.getElementById(""String_Node_Str"");
  if (Config.getInstance().getActiveViewingDistanceId() == 3)   viewingDistanceButton.getLabel().setText(""String_Node_Str"");
 else   if (Config.getInstance().getActiveViewingDistanceId() == 1)   viewingDistanceButton.getLabel().setText(""String_Node_Str"");
 else   if (Config.getInstance().getActiveViewingDistanceId() == 2)   viewingDistanceButton.getLabel().setText(""String_Node_Str"");
 else   viewingDistanceButton.getLabel().setText(""String_Node_Str"");
  if (Config.getInstance().getGraphicsQuality() == 1)   graphicsQualityButton.getLabel().setText(""String_Node_Str"");
 else   if (Config.getInstance().getGraphicsQuality() == 2)   graphicsQualityButton.getLabel().setText(""String_Node_Str"");
 else   graphicsQualityButton.getLabel().setText(""String_Node_Str"");
  FOVButton.getLabel().setText(""String_Node_Str"" + (int)Config.getInstance().getFov());
}",0.8624319419237749
1202,"private void setupMainMenu(){
  _mainMenu=new UIMainMenu();
  _mainMenu.setVisible(true);
  UIButton singlePlayerButton=(UIButton)_mainMenu.getElementById(""String_Node_Str"");
  UIButton configButton=(UIButton)_mainMenu.getElementById(""String_Node_Str"");
  UIButton exitButton=(UIButton)_mainMenu.getElementById(""String_Node_Str"");
  singlePlayerButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _mainMenu.setVisible(false);
      _selectWorldMenu.setVisible(true);
    }
  }
);
  exitButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      Terasology.getInstance().exit();
    }
  }
);
  configButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _mainMenu.setVisible(false);
      _configMenu.setVisible(true);
    }
  }
);
}","private void setupMainMenu(){
  _mainMenu=new UIMainMenu();
  _mainMenu.setVisible(true);
  UIButton singlePlayerButton=(UIButton)_mainMenu.getElementById(""String_Node_Str"");
  UIButton configButton=(UIButton)_mainMenu.getElementById(""String_Node_Str"");
  UIButton exitButton=(UIButton)_mainMenu.getElementById(""String_Node_Str"");
  singlePlayerButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      GUIManager.getInstance().setFocusedWindow(_selectWorldMenu);
    }
  }
);
  exitButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      Terasology.getInstance().exit();
    }
  }
);
  configButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      GUIManager.getInstance().setFocusedWindow(_configMenu);
    }
  }
);
}",0.8657565415244596
1203,"private void setTopWindow(int windowPosition){
  _lastFocused=_focusedWindow;
  _focusedWindow=(UIDisplayWindow)_renderer.getDisplayElements().get(windowPosition);
  if (!_focusedWindow.isMaximized()) {
    _renderer.changeElementDepth(windowPosition,_renderer.getDisplayElements().size() - 1);
  }
}","private void setTopWindow(int windowPosition){
  if (_renderer.getDisplayElements().size() - 1 < windowPosition || windowPosition < 0) {
    return;
  }
  UIDisplayWindow setTopWindow=(UIDisplayWindow)_renderer.getDisplayElements().get(windowPosition);
  if (setTopWindow == null) {
    return;
  }
  if (_lastFocused != null && _lastFocused.equals(setTopWindow)) {
    return;
  }
  _lastFocused=_focusedWindow;
  if (_lastFocused != null && _lastFocused.isMaximized() && setTopWindow.isMaximized()) {
    _lastFocused.setVisible(false);
  }
  _focusedWindow=setTopWindow;
  if (!_focusedWindow.isMaximized()) {
    _renderer.changeElementDepth(windowPosition,_renderer.getDisplayElements().size() - 1);
  }
  if (!_focusedWindow.isVisible()) {
    _focusedWindow.setVisible(true);
  }
}",0.4650735294117647
1204,"public void resize(){
  _title.setSize(new Vector2f(getSize().x * 0.85f,19f));
  _title.getPosition().x=(getPosition().x + getSize().x / 2f) - _title.getSize().x / 2;
  _title.resize();
  _style=null;
  _close.getPosition().x=getSize().x - 25f;
  windowStyleSetup();
}","public void resize(){
  _title.setSize(new Vector2f(getSize().x * 0.55f,19f));
  _title.getPosition().x=getSize().x / 2f - _title.getSize().x / 2;
  _title.resize();
  _style=null;
  _close.getPosition().x=getSize().x - 25f;
  windowStyleSetup();
}",0.9573643410852714
1205,"public void clearData(){
  if (_inputValue.length() > 0) {
    _inputValue.delete(0,_inputValue.length() - 1);
  }
  _inputText.setText(""String_Node_Str"");
}","public void clearData(){
  if (_inputValue.length() > 0) {
    _inputValue.delete(0,_inputValue.length() - 1);
  }
  _cursorPosition=0;
  _inputText.setText(""String_Node_Str"");
}",0.9373134328358208
1206,"public UIList(Vector2f size){
  setSize(size);
  setCrop(true);
  setScrollBarsPosition(getPosition(),getSize());
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setCropMargin(new Vector4f(-15f,-15f,0,0));
}","public UIList(Vector2f size){
  setSize(size);
  setCrop(true);
  setScrollBarsPosition(getPosition(),getSize());
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setStyle(""String_Node_Str"",""String_Node_Str"");
  setCropMargin(new Vector4f(-15f,-15f,-15f,0));
}",0.9942004971002486
1207,"public void update(){
  Vector2f mousePos=new Vector2f(Mouse.getX(),Display.getHeight() - Mouse.getY());
  if (intersects(mousePos)) {
    boolean itemClicked=false;
    for (int i=(_items.size() - 1); i >= 0; i--) {
      UIListItem item=_items.get(i);
      if (item.isVisible()) {
        if (item.intersects(mousePos)) {
          if (_mouseDown) {
            if (item.isSelected()) {
              break;
            }
            if (_selectedItemIndex >= 0) {
              _items.get(_selectedItemIndex).setSelected(false);
            }
            item.setSelected(true);
            _selectedItemIndex=i;
            _mouseDown=false;
            itemClicked=true;
          }
        }
      }
    }
    if (!itemClicked) {
      _mouseUp=false;
      _mouseDown=false;
    }
  }
 else {
    _mouseUp=false;
    _mouseDown=false;
  }
  super.update();
}","public void update(){
  Vector2f mousePos=new Vector2f(Mouse.getX(),Display.getHeight() - Mouse.getY());
  if (intersects(mousePos)) {
    if (_scrollBarVertical.intersects(mousePos) || _scrollBarHorizontal.intersects(mousePos)) {
      return;
    }
    boolean itemClicked=false;
    for (int i=(_items.size() - 1); i >= 0; i--) {
      UIListItem item=_items.get(i);
      if (item.isVisible()) {
        if (item.intersects(mousePos)) {
          if (_mouseDown) {
            if (item.isSelected()) {
              doubleClick();
              break;
            }
            if (_selectedItemIndex >= 0) {
              _items.get(_selectedItemIndex).setSelected(false);
            }
            item.setSelected(true);
            _selectedItemIndex=i;
            _mouseDown=false;
            itemClicked=true;
          }
        }
      }
    }
    if (!itemClicked) {
      _mouseUp=false;
      _mouseDown=false;
    }
  }
 else {
    _wheelMoved=0;
    _mouseUp=false;
    _mouseDown=false;
  }
  super.update();
}",0.9135021097046412
1208,"public UIListItem getSelectedItem(){
  return _items.get(_selectedItemIndex);
}","public UIListItem getSelectedItem(){
  if (_selectedItemIndex < 0) {
    return null;
  }
  return _items.get(_selectedItemIndex);
}",0.7488151658767772
1209,"public void init(){
  _gameInstance=Terasology.getInstance();
  setupMainMenu();
  setupSelectWorldMenu();
  setupConfigMenu();
  _mainMenu.name=""String_Node_Str"";
  _configMenu.name=""String_Node_Str"";
  _selectWorldMenu.name=""String_Node_Str"";
  GUIManager.getInstance().addWindow(_mainMenu,""String_Node_Str"");
  GUIManager.getInstance().addWindow(_configMenu,""String_Node_Str"");
  GUIManager.getInstance().addWindow(_selectWorldMenu,""String_Node_Str"");
}","public void init(){
  _gameInstance=Terasology.getInstance();
  setupMainMenu();
  setupSelectWorldMenu();
  setupConfigMenu();
  GUIManager.getInstance().addWindow(_mainMenu,""String_Node_Str"");
  GUIManager.getInstance().addWindow(_configMenu,""String_Node_Str"");
  GUIManager.getInstance().addWindow(_selectWorldMenu,""String_Node_Str"");
}",0.8528301886792453
1210,"private void setupMainMenu(){
  _mainMenu=new UIMainMenu();
  _mainMenu.setVisible(true);
  UIButton singlePlayerButton=(UIButton)_mainMenu.getElementById(""String_Node_Str"");
  UIButton configButton=(UIButton)_mainMenu.getElementById(""String_Node_Str"");
  UIButton exitButton=(UIButton)_mainMenu.getElementById(""String_Node_Str"");
  singlePlayerButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      GUIManager.getInstance().setFocusedWindow(_selectWorldMenu);
    }
  }
);
  exitButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      Terasology.getInstance().exit();
    }
  }
);
  configButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      GUIManager.getInstance().setFocusedWindow(_configMenu);
    }
  }
);
}","private void setupMainMenu(){
  _mainMenu=new UIMainMenu();
  _mainMenu.setVisible(true);
  UIButton singlePlayerButton=(UIButton)_mainMenu.getElementById(""String_Node_Str"");
  UIButton configButton=(UIButton)_mainMenu.getElementById(""String_Node_Str"");
  UIButton exitButton=(UIButton)_mainMenu.getElementById(""String_Node_Str"");
  singlePlayerButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _selectWorldMenu.fillList();
      GUIManager.getInstance().setFocusedWindow(_selectWorldMenu);
    }
  }
);
  exitButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      Terasology.getInstance().exit();
    }
  }
);
  configButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      GUIManager.getInstance().setFocusedWindow(_configMenu);
    }
  }
);
}",0.9802816901408452
1211,"public void clearData(){
  _selectedItemIndex=-1;
  _items.get(_selectedItemIndex).setSelected(false);
}","public void clearData(){
  if (_selectedItemIndex < 0) {
    return;
  }
  _items.get(_selectedItemIndex).setSelected(false);
  _selectedItemIndex=-1;
}",0.7890625
1212,"public void removeAll(){
  for (int i=(_items.size() - 1); i >= 0; i--) {
    removeDisplayElement(_items.get(i));
    _items.remove(i);
  }
}","public void removeAll(){
  clearData();
  for (int i=(_items.size() - 1); i >= 0; i--) {
    removeDisplayElement(_items.get(i));
    _items.remove(i);
  }
}",0.9498327759197324
1213,"public UISelectWorldMenu(){
  maximaze();
  _overlay=new UIImageOverlay(""String_Node_Str"");
  _overlay.setVisible(true);
  _window=new UIDialogCreateNewWorld(""String_Node_Str"",new Vector2f(512f,256f));
  _window.center();
  _window.setModal(true);
  GUIManager.getInstance().addWindow(_window,""String_Node_Str"");
  _list=new UIList(new Vector2f(512f,256f));
  _list.setVisible(true);
  _list.addDoubleClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      loadSelectedWorld();
    }
  }
);
  ConfigObject config=null;
  String path=Terasology.getInstance().getWorldSavePath(""String_Node_Str"");
  File worldCatalog=new File(path);
  for (  File file : worldCatalog.listFiles(new FileFilter(){
    public boolean accept(    File file){
      if (file.isDirectory()) {
        return true;
      }
 else {
        return false;
      }
    }
  }
)) {
    File worldManifest=new File(file.getPath() + ""String_Node_Str"");
    try {
      config=new ConfigSlurper().parse(worldManifest.toURI().toURL());
      if (config.get(""String_Node_Str"") != null && config.get(""String_Node_Str"") != null) {
        _list.addItem((String)config.get(""String_Node_Str""),config);
      }
    }
 catch (    MalformedURLException e) {
      Terasology.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
  _goToBack=new UIButton(new Vector2f(256f,32f));
  _goToBack.getLabel().setText(""String_Node_Str"");
  _goToBack.setVisible(true);
  _loadFromList=new UIButton(new Vector2f(128f,32f));
  _loadFromList.getLabel().setText(""String_Node_Str"");
  _loadFromList.setVisible(true);
  _createNewWorld=new UIButton(new Vector2f(192f,32f));
  _createNewWorld.getLabel().setText(""String_Node_Str"");
  _createNewWorld.setVisible(true);
  _deleteFromList=new UIButton(new Vector2f(128f,32f));
  _deleteFromList.getLabel().setText(""String_Node_Str"");
  _deleteFromList.setVisible(true);
  _createNewWorld.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      GUIManager.getInstance().setFocusedWindow(_window);
    }
  }
);
  _deleteFromList.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      if (_list.getSelectedItem() == null) {
        GUIManager.getInstance().showMessage(""String_Node_Str"",""String_Node_Str"");
        return;
      }
      try {
        ConfigObject config=(ConfigObject)_list.getSelectedItem().getValue();
        String path=Terasology.getInstance().getWorldSavePath((String)config.get(""String_Node_Str""));
        File world=new File(path);
        WorldUtil.deleteWorld(world);
        _list.removeSelectedItem();
      }
 catch (      Exception e) {
        GUIManager.getInstance().showMessage(""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
);
  _loadFromList.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      loadSelectedWorld();
    }
  }
);
  addDisplayElement(_overlay);
  addDisplayElement(_list,""String_Node_Str"");
  addDisplayElement(_loadFromList,""String_Node_Str"");
  addDisplayElement(_goToBack,""String_Node_Str"");
  addDisplayElement(_createNewWorld,""String_Node_Str"");
  addDisplayElement(_deleteFromList,""String_Node_Str"");
  update();
}","public UISelectWorldMenu(){
  maximaze();
  _overlay=new UIImageOverlay(""String_Node_Str"");
  _overlay.setVisible(true);
  _window=new UIDialogCreateNewWorld(""String_Node_Str"",new Vector2f(512f,256f));
  _window.center();
  _window.setModal(true);
  GUIManager.getInstance().addWindow(_window,""String_Node_Str"");
  _list=new UIList(new Vector2f(512f,256f));
  _list.setVisible(true);
  _list.addDoubleClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      loadSelectedWorld();
    }
  }
);
  _goToBack=new UIButton(new Vector2f(256f,32f));
  _goToBack.getLabel().setText(""String_Node_Str"");
  _goToBack.setVisible(true);
  _loadFromList=new UIButton(new Vector2f(128f,32f));
  _loadFromList.getLabel().setText(""String_Node_Str"");
  _loadFromList.setVisible(true);
  _createNewWorld=new UIButton(new Vector2f(192f,32f));
  _createNewWorld.getLabel().setText(""String_Node_Str"");
  _createNewWorld.setVisible(true);
  _deleteFromList=new UIButton(new Vector2f(128f,32f));
  _deleteFromList.getLabel().setText(""String_Node_Str"");
  _deleteFromList.setVisible(true);
  _createNewWorld.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      GUIManager.getInstance().setFocusedWindow(_window);
    }
  }
);
  _deleteFromList.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      if (_list.getSelectedItem() == null) {
        GUIManager.getInstance().showMessage(""String_Node_Str"",""String_Node_Str"");
        return;
      }
      try {
        ConfigObject config=(ConfigObject)_list.getSelectedItem().getValue();
        String path=Terasology.getInstance().getWorldSavePath((String)config.get(""String_Node_Str""));
        File world=new File(path);
        WorldUtil.deleteWorld(world);
        _list.removeSelectedItem();
      }
 catch (      Exception e) {
        GUIManager.getInstance().showMessage(""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
);
  _loadFromList.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      loadSelectedWorld();
    }
  }
);
  fillList();
  addDisplayElement(_overlay);
  addDisplayElement(_list,""String_Node_Str"");
  addDisplayElement(_loadFromList,""String_Node_Str"");
  addDisplayElement(_goToBack,""String_Node_Str"");
  addDisplayElement(_createNewWorld,""String_Node_Str"");
  addDisplayElement(_deleteFromList,""String_Node_Str"");
  update();
}",0.8553964373035278
1214,"public void init(){
  _gameInstance=Terasology.getInstance();
  setupMainMenu();
  setupConfigMenu();
  GUIManager.getInstance().addWindow(_mainMenu);
  GUIManager.getInstance().addWindow(_configMenu);
  GUIManager.getInstance().addWindow(_selectWorldMenu);
}","public void init(){
  _gameInstance=Terasology.getInstance();
  setupMainMenu();
  setupSelectWorldMenu();
  setupConfigMenu();
  _mainMenu.name=""String_Node_Str"";
  _configMenu.name=""String_Node_Str"";
  _selectWorldMenu.name=""String_Node_Str"";
  GUIManager.getInstance().addWindow(_mainMenu,""String_Node_Str"");
  GUIManager.getInstance().addWindow(_configMenu,""String_Node_Str"");
  GUIManager.getInstance().addWindow(_selectWorldMenu,""String_Node_Str"");
}",0.7244755244755244
1215,"private void setupConfigMenu(){
  _configMenu=new UIConfigMenu();
  _configMenu.getBackToMainMenuButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _mainMenu.setVisible(true);
      _configMenu.setVisible(false);
    }
  }
);
  _configMenu.getGraphicsQualityButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      UIButton button=(UIButton)element;
      if (button.getLabel().getText().equals(""String_Node_Str"")) {
        Config.getInstance().setGraphicsQuality(1);
        button.getLabel().setText(""String_Node_Str"");
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        Config.getInstance().setGraphicsQuality(2);
        button.getLabel().setText(""String_Node_Str"");
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        Config.getInstance().setGraphicsQuality(0);
        button.getLabel().setText(""String_Node_Str"");
      }
    }
  }
);
  _configMenu.getFOVButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      UIButton button=(UIButton)element;
      if (button.getLabel().getText().equals(""String_Node_Str"")) {
        button.getLabel().setText(""String_Node_Str"");
        Config.getInstance().setFov(80);
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        button.getLabel().setText(""String_Node_Str"");
        Config.getInstance().setFov(85);
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        button.getLabel().setText(""String_Node_Str"");
        Config.getInstance().setFov(90);
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        button.getLabel().setText(""String_Node_Str"");
        Config.getInstance().setFov(75);
      }
    }
  }
);
  _configMenu.getViewingDistanceButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      UIButton button=(UIButton)element;
      if (button.getLabel().getText().equals(""String_Node_Str"")) {
        button.getLabel().setText(""String_Node_Str"");
        Config.getInstance().setViewingDistanceById(1);
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        button.getLabel().setText(""String_Node_Str"");
        Config.getInstance().setViewingDistanceById(2);
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        Config.getInstance().setViewingDistanceById(3);
        button.getLabel().setText(""String_Node_Str"");
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        Config.getInstance().setViewingDistanceById(0);
        button.getLabel().setText(""String_Node_Str"");
      }
    }
  }
);
}","private void setupConfigMenu(){
  _configMenu=new UIConfigMenu();
  _configMenu.setVisible(false);
  UIButton backToMainMenuButton=(UIButton)_configMenu.getElementById(""String_Node_Str"");
  UIButton graphicsQualityButton=(UIButton)_configMenu.getElementById(""String_Node_Str"");
  UIButton FOVButton=(UIButton)_configMenu.getElementById(""String_Node_Str"");
  UIButton viewingDistanceButton=(UIButton)_configMenu.getElementById(""String_Node_Str"");
  backToMainMenuButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _mainMenu.setVisible(true);
      _configMenu.setVisible(false);
    }
  }
);
  graphicsQualityButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      UIButton button=(UIButton)element;
      if (button.getLabel().getText().equals(""String_Node_Str"")) {
        Config.getInstance().setGraphicsQuality(1);
        button.getLabel().setText(""String_Node_Str"");
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        Config.getInstance().setGraphicsQuality(2);
        button.getLabel().setText(""String_Node_Str"");
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        Config.getInstance().setGraphicsQuality(0);
        button.getLabel().setText(""String_Node_Str"");
      }
    }
  }
);
  FOVButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      UIButton button=(UIButton)element;
      if (button.getLabel().getText().equals(""String_Node_Str"")) {
        button.getLabel().setText(""String_Node_Str"");
        Config.getInstance().setFov(80);
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        button.getLabel().setText(""String_Node_Str"");
        Config.getInstance().setFov(85);
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        button.getLabel().setText(""String_Node_Str"");
        Config.getInstance().setFov(90);
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        button.getLabel().setText(""String_Node_Str"");
        Config.getInstance().setFov(75);
      }
    }
  }
);
  viewingDistanceButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      UIButton button=(UIButton)element;
      if (button.getLabel().getText().equals(""String_Node_Str"")) {
        button.getLabel().setText(""String_Node_Str"");
        Config.getInstance().setViewingDistanceById(1);
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        button.getLabel().setText(""String_Node_Str"");
        Config.getInstance().setViewingDistanceById(2);
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        Config.getInstance().setViewingDistanceById(3);
        button.getLabel().setText(""String_Node_Str"");
      }
 else       if (button.getLabel().getText().equals(""String_Node_Str"")) {
        Config.getInstance().setViewingDistanceById(0);
        button.getLabel().setText(""String_Node_Str"");
      }
    }
  }
);
}",0.6395078150981044
1216,"public void activate(){
  Mouse.setGrabbed(false);
  playBackgroundMusic();
  if (Config.getInstance().getActiveViewingDistanceId() == 3)   _configMenu.getViewingDistanceButton().getLabel().setText(""String_Node_Str"");
 else   if (Config.getInstance().getActiveViewingDistanceId() == 1)   _configMenu.getViewingDistanceButton().getLabel().setText(""String_Node_Str"");
 else   if (Config.getInstance().getActiveViewingDistanceId() == 2)   _configMenu.getViewingDistanceButton().getLabel().setText(""String_Node_Str"");
 else   _configMenu.getViewingDistanceButton().getLabel().setText(""String_Node_Str"");
  if (Config.getInstance().getGraphicsQuality() == 1)   _configMenu.getGraphicsQualityButton().getLabel().setText(""String_Node_Str"");
 else   if (Config.getInstance().getGraphicsQuality() == 2)   _configMenu.getGraphicsQualityButton().getLabel().setText(""String_Node_Str"");
 else   _configMenu.getGraphicsQualityButton().getLabel().setText(""String_Node_Str"");
  _configMenu.getFOVButton().getLabel().setText(""String_Node_Str"" + (int)Config.getInstance().getFov());
}","public void activate(){
  Mouse.setGrabbed(false);
  playBackgroundMusic();
  UIButton graphicsQualityButton=(UIButton)_configMenu.getElementById(""String_Node_Str"");
  UIButton FOVButton=(UIButton)_configMenu.getElementById(""String_Node_Str"");
  UIButton viewingDistanceButton=(UIButton)_configMenu.getElementById(""String_Node_Str"");
  if (Config.getInstance().getActiveViewingDistanceId() == 3)   viewingDistanceButton.getLabel().setText(""String_Node_Str"");
 else   if (Config.getInstance().getActiveViewingDistanceId() == 1)   viewingDistanceButton.getLabel().setText(""String_Node_Str"");
 else   if (Config.getInstance().getActiveViewingDistanceId() == 2)   viewingDistanceButton.getLabel().setText(""String_Node_Str"");
 else   viewingDistanceButton.getLabel().setText(""String_Node_Str"");
  if (Config.getInstance().getGraphicsQuality() == 1)   graphicsQualityButton.getLabel().setText(""String_Node_Str"");
 else   if (Config.getInstance().getGraphicsQuality() == 2)   graphicsQualityButton.getLabel().setText(""String_Node_Str"");
 else   graphicsQualityButton.getLabel().setText(""String_Node_Str"");
  FOVButton.getLabel().setText(""String_Node_Str"" + (int)Config.getInstance().getFov());
}",0.1925465838509316
1217,"private void setupMainMenu(){
  _mainMenu=new UIMainMenu();
  _mainMenu.setVisible(true);
  _selectWorldMenu=new UISelectWorldMenu();
  _selectWorldMenu.setVisible(false);
  _mainMenu.getSinglePlayerButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _mainMenu.setVisible(false);
      _selectWorldMenu.setVisible(true);
    }
  }
);
  _mainMenu.getExitButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      Terasology.getInstance().exit();
    }
  }
);
  _mainMenu.getConfigButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _mainMenu.setVisible(false);
      _configMenu.setVisible(true);
    }
  }
);
  _selectWorldMenu.getGoToBackButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _selectWorldMenu.setVisible(false);
      _mainMenu.setVisible(true);
    }
  }
);
}","private void setupMainMenu(){
  _mainMenu=new UIMainMenu();
  _mainMenu.setVisible(true);
  UIButton singlePlayerButton=(UIButton)_mainMenu.getElementById(""String_Node_Str"");
  UIButton configButton=(UIButton)_mainMenu.getElementById(""String_Node_Str"");
  UIButton exitButton=(UIButton)_mainMenu.getElementById(""String_Node_Str"");
  singlePlayerButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _mainMenu.setVisible(false);
      _selectWorldMenu.setVisible(true);
    }
  }
);
  exitButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      Terasology.getInstance().exit();
    }
  }
);
  configButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _mainMenu.setVisible(false);
      _configMenu.setVisible(true);
    }
  }
);
}",0.6878980891719745
1218,"public void addWindow(UIDisplayWindow window){
  if (window.isMaximized()) {
    _renderer.addtDisplayElementToPosition(0,window);
  }
 else {
    _renderer.addDisplayElement(window);
  }
}","public void addWindow(UIDisplayWindow window,String windowId){
  if (window.isMaximized()) {
    _renderer.addtDisplayElementToPosition(0,window);
  }
 else {
    _renderer.addDisplayElement(window);
  }
  _windowsById.put(windowId,window);
}",0.877030162412993
1219,"private void checkTopWindow(){
  if (_focusedWindow.isModal() && _focusedWindow.isVisible()) {
    return;
  }
  Vector2f mousePos=new Vector2f(Mouse.getX(),Display.getHeight() - Mouse.getY());
  int size=_renderer.getDisplayElements().size();
  for (int i=size - 1; i >= 0; i--) {
    UIDisplayWindow window=(UIDisplayWindow)_renderer.getDisplayElements().get(i);
    if (window.isVisible() && window.intersects(mousePos)) {
      if (!window.isMaximized()) {
        _renderer.changeElementDepth(i,size - 1);
      }
      _focusedWindow=window;
      break;
    }
    ;
  }
}","private void checkTopWindow(){
  if (_focusedWindow.isModal() && _focusedWindow.isVisible()) {
    return;
  }
  Vector2f mousePos=new Vector2f(Mouse.getX(),Display.getHeight() - Mouse.getY());
  int size=_renderer.getDisplayElements().size();
  for (int i=size - 1; i >= 0; i--) {
    UIDisplayWindow window=(UIDisplayWindow)_renderer.getDisplayElements().get(i);
    if (window.isVisible() && window.intersects(mousePos)) {
      setTopWindow(i);
      break;
    }
    ;
  }
}",0.8457899716177862
1220,"/** 
 * Process keyboard input - first look for ""system"" like events, then otherwise pass to the Player object
 */
public void processKeyboardInput(int key){
  for (  UIDisplayElement screen : _renderer.getDisplayElements()) {
    if (screenCanFocus(screen)) {
      screen.processKeyboardInput(key);
    }
  }
}","/** 
 * Process keyboard input - first look for ""system"" like events, then otherwise pass to the Player object
 */
public void processKeyboardInput(int key){
  for (  UIDisplayElement screen : _renderer.getDisplayElements()) {
    if (screen.isVisible() && !screen.isOverlay()) {
      screen.processKeyboardInput(key);
    }
  }
}",0.8118195956454122
1221,"public void removeWindow(UIDisplayWindow window){
  _renderer.removeDisplayElement(window);
}","public void removeWindow(UIDisplayWindow window){
  _renderer.removeDisplayElement(window);
  if (_windowsById.containsValue(window)) {
    for (    String key : _windowsById.keySet()) {
      if (_windowsById.get(key).equals(window)) {
        _windowsById.remove(key);
        break;
      }
    }
  }
}",0.4673366834170854
1222,"public UIDialogCreateNewWorld(String title,Vector2f size){
  super(title,size);
  _inputSeed=new UIInput(new Vector2f(256f,30f));
  _inputSeed.setVisible(true);
  _inputWorldTitle=new UIInput(new Vector2f(256f,30f));
  _inputWorldTitle.setVisible(true);
  _inputWorldTitleLabel=new UIText(""String_Node_Str"");
  _inputWorldTitleLabel.setColor(Color.darkGray);
  _inputWorldTitleLabel.getSize().y=16f;
  _inputWorldTitleLabel.setVisible(true);
  _inputSeedLabel=new UIText(""String_Node_Str"");
  _inputSeedLabel.setColor(Color.darkGray);
  _inputSeedLabel.getSize().y=16f;
  _inputSeedLabel.setVisible(true);
  _inputWorldTitleLabel.setPosition(new Vector2f(15f,32f));
  _inputWorldTitle.setPosition(new Vector2f(_inputWorldTitleLabel.getPosition().x,_inputWorldTitleLabel.getPosition().y + _inputWorldTitleLabel.getSize().y + 8f));
  _inputSeedLabel.setPosition(new Vector2f(_inputWorldTitle.getPosition().x,_inputWorldTitle.getPosition().y + _inputWorldTitle.getSize().y + 16f));
  _inputSeed.setPosition(new Vector2f(_inputSeedLabel.getPosition().x,_inputSeedLabel.getPosition().y + _inputSeedLabel.getSize().y + 8f));
  _okButton=new UIButton(new Vector2f(128f,32f));
  _okButton.getLabel().setText(""String_Node_Str"");
  _okButton.setPosition(new Vector2f(size.x / 2 - _okButton.getSize().x - 16f,size.y - _okButton.getSize().y));
  _okButton.setVisible(true);
  _okButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      if (_inputSeed.getValue().length() > 0) {
        Config.getInstance().setDefaultSeed(_inputSeed.getValue());
      }
      if (_inputWorldTitle.getValue().length() > 0) {
        Config.getInstance().setWorldTitle(_inputWorldTitle.getValue());
      }
 else {
        Config.getInstance().setWorldTitle(""String_Node_Str"");
      }
      Terasology.getInstance().setGameState(Terasology.GAME_STATE.SINGLE_PLAYER);
    }
  }
);
  _cancelButton=new UIButton(new Vector2f(128f,32f));
  _cancelButton.setPosition(new Vector2f(_okButton.getPosition().x + _okButton.getSize().x + 16f,_okButton.getPosition().y));
  _cancelButton.getLabel().setText(""String_Node_Str"");
  _cancelButton.setVisible(true);
  _cancelButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      setVisible(false);
    }
  }
);
  addDisplayElement(_okButton);
  addDisplayElement(_cancelButton);
  addDisplayElement(_inputSeed);
  addDisplayElement(_inputSeedLabel);
  addDisplayElement(_inputWorldTitleLabel);
  addDisplayElement(_inputWorldTitle);
}","public UIDialogCreateNewWorld(String title,Vector2f size){
  super(title,size);
  _inputSeed=new UIInput(new Vector2f(256f,30f));
  _inputSeed.setVisible(true);
  _inputWorldTitle=new UIInput(new Vector2f(256f,30f));
  _inputWorldTitle.setVisible(true);
  _inputWorldTitleLabel=new UIText(""String_Node_Str"");
  _inputWorldTitleLabel.setColor(Color.darkGray);
  _inputWorldTitleLabel.getSize().y=16f;
  _inputWorldTitleLabel.setVisible(true);
  _inputSeedLabel=new UIText(""String_Node_Str"");
  _inputSeedLabel.setColor(Color.darkGray);
  _inputSeedLabel.getSize().y=16f;
  _inputSeedLabel.setVisible(true);
  _inputWorldTitleLabel.setPosition(new Vector2f(15f,32f));
  _inputWorldTitle.setPosition(new Vector2f(_inputWorldTitleLabel.getPosition().x,_inputWorldTitleLabel.getPosition().y + _inputWorldTitleLabel.getSize().y + 8f));
  _inputSeedLabel.setPosition(new Vector2f(_inputWorldTitle.getPosition().x,_inputWorldTitle.getPosition().y + _inputWorldTitle.getSize().y + 16f));
  _inputSeed.setPosition(new Vector2f(_inputSeedLabel.getPosition().x,_inputSeedLabel.getPosition().y + _inputSeedLabel.getSize().y + 8f));
  _okButton=new UIButton(new Vector2f(128f,32f));
  _okButton.getLabel().setText(""String_Node_Str"");
  _okButton.setPosition(new Vector2f(size.x / 2 - _okButton.getSize().x - 16f,size.y - _okButton.getSize().y));
  _okButton.setVisible(true);
  _okButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      if (_inputSeed.getValue().length() > 0) {
        Config.getInstance().setDefaultSeed(_inputSeed.getValue());
      }
      if (_inputWorldTitle.getValue().length() > 0) {
        Config.getInstance().setWorldTitle(_inputWorldTitle.getValue());
      }
 else {
        Config.getInstance().setWorldTitle(""String_Node_Str"");
      }
      Terasology.getInstance().setGameState(Terasology.GAME_STATE.SINGLE_PLAYER);
    }
  }
);
  _cancelButton=new UIButton(new Vector2f(128f,32f));
  _cancelButton.setPosition(new Vector2f(_okButton.getPosition().x + _okButton.getSize().x + 16f,_okButton.getPosition().y));
  _cancelButton.getLabel().setText(""String_Node_Str"");
  _cancelButton.setVisible(true);
  _cancelButton.addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      setVisible(false);
    }
  }
);
  addDisplayElement(_okButton,""String_Node_Str"");
  addDisplayElement(_cancelButton,""String_Node_Str"");
  addDisplayElement(_inputSeed,""String_Node_Str"");
  addDisplayElement(_inputSeedLabel,""String_Node_Str"");
  addDisplayElement(_inputWorldTitleLabel,""String_Node_Str"");
  addDisplayElement(_inputWorldTitle,""String_Node_Str"");
}",0.9791907514450868
1223,"public void clicked(Vector2f mousePos){
  _focused=true;
  if (_inputValue.length() > 0 && _inputText.getTextWidth() > 0) {
    Vector2f absolutePosition=_inputText.calcAbsolutePosition();
    float positionRelativeElement=(absolutePosition.x + _inputText.getTextWidth()) - mousePos.x;
    float averageSymbols=_inputText.getTextWidth() / _inputValue.length();
    int pos=Math.abs((int)(positionRelativeElement / averageSymbols) - _inputValue.length());
    if (pos > (_inputValue.length() - 1)) {
      pos=_inputValue.length() - 1;
    }
 else     if (pos < 0) {
      pos=0;
    }
    _cursorPosition=pos;
    System.out.println(_cursorPosition);
  }
}","public void clicked(Vector2f mousePos){
  _focused=true;
  if (_inputValue.length() > 0 && _inputText.getTextWidth() > 0) {
    Vector2f absolutePosition=_inputText.calcAbsolutePosition();
    float positionRelativeElement=(absolutePosition.x + _inputText.getTextWidth()) - mousePos.x;
    float averageSymbols=_inputText.getTextWidth() / _inputValue.length();
    int pos=Math.abs((int)(positionRelativeElement / averageSymbols) - _inputValue.length());
    if (pos > (_inputValue.length() - 1)) {
      pos=_inputValue.length() - 1;
    }
 else     if (pos < 0) {
      pos=0;
    }
    _cursorPosition=pos;
  }
}",0.967741935483871
1224,"public void update(){
  Vector2f mousePos=new Vector2f(Mouse.getX(),Display.getHeight() - Mouse.getY());
  if (intersects(mousePos)) {
    for (int i=(_items.size() - 1); i >= 0; i--) {
      UIListItem item=_items.get(i);
      if (item.isVisible()) {
        if (item.intersects(mousePos)) {
          if (_mouseDown) {
            if (_selectedItemIndex >= 0) {
              _items.get(_selectedItemIndex).setSelected(false);
            }
            item.setSelected(true);
            _selectedItem=item;
            _selectedItemIndex=i;
            _mouseDown=false;
          }
        }
      }
    }
  }
 else {
    _mouseUp=false;
    _mouseDown=false;
  }
  super.update();
}","public void update(){
  Vector2f mousePos=new Vector2f(Mouse.getX(),Display.getHeight() - Mouse.getY());
  if (intersects(mousePos)) {
    boolean itemClicked=false;
    for (int i=(_items.size() - 1); i >= 0; i--) {
      UIListItem item=_items.get(i);
      if (item.isVisible()) {
        if (item.intersects(mousePos)) {
          if (_mouseDown) {
            if (item.isSelected()) {
              break;
            }
            if (_selectedItemIndex >= 0) {
              _items.get(_selectedItemIndex).setSelected(false);
            }
            item.setSelected(true);
            _selectedItem=item;
            _selectedItemIndex=i;
            _mouseDown=false;
            itemClicked=true;
          }
        }
      }
    }
    if (!itemClicked) {
      _mouseUp=false;
      _mouseDown=false;
    }
  }
 else {
    _mouseUp=false;
    _mouseDown=false;
  }
  super.update();
}",0.8128544423440454
1225,"public UIListItem(Vector2f size,String text,Object value){
  setSize(size);
  _text=text;
  _value=value;
  _label=new UIText();
  _label.setVisible(true);
  _label.setColor(Color.white);
  _label.setPosition(new Vector2f((getPosition().x + _padding.x),(getPosition().y + _padding.y)));
  _label.setText(_text);
  if (getSize().x < _label.getTextWidth()) {
    setSize(new Vector2f(_label.getTextWidth(),getSize().y));
  }
  addDisplayElement(_label);
}","public UIListItem(Vector2f size,String text,Object value){
  setSize(size);
  _text=text;
  _value=value;
  _label=new UIText();
  _label.setVisible(true);
  _label.setColor(Color.black);
  _label.setPosition(new Vector2f((getPosition().x + _padding.x),(getPosition().y + _padding.y)));
  _label.setText(_text);
  if (getSize().x < _label.getTextWidth()) {
    setSize(new Vector2f(_label.getTextWidth(),getSize().y));
  }
  addDisplayElement(_label);
}",0.9889624724061812
1226,"public void setSelected(boolean selected){
  _isSelected=selected;
  if (_isSelected) {
    _label.setColor(Color.orange);
  }
 else {
    _label.setColor(Color.black);
  }
}","public void setSelected(boolean selected){
  _isSelected=selected;
  if (_isSelected) {
    setStyle(""String_Node_Str"",""String_Node_Str"");
    _label.setColor(Color.orange);
  }
 else {
    setStyle(""String_Node_Str"",""String_Node_Str"");
    _label.setColor(Color.black);
  }
}",0.7733333333333333
1227,"public UIScrollBarThumb(Vector2f size,UIScrollBar.ScrollType scrollType){
  setSize(size);
  _scrollType=scrollType;
  _header=new UIGraphicsElement(""String_Node_Str"");
  _body=new UIGraphicsElement(""String_Node_Str"");
  _footer=new UIGraphicsElement(""String_Node_Str"");
  _header.setVisible(true);
  _body.setVisible(true);
  _footer.setVisible(true);
  addDisplayElement(_header);
  addDisplayElement(_body);
  addDisplayElement(_footer);
switch (scrollType) {
case vertical:
    setVerticalOptions();
  break;
case horizontal:
setHorizontalPositions();
break;
}
}","public UIScrollBarThumb(Vector2f size,UIScrollBar.ScrollType scrollType){
  setSize(size);
  _scrollType=scrollType;
  _header=new UIGraphicsElement(""String_Node_Str"");
  _body=new UIGraphicsElement(""String_Node_Str"");
  _footer=new UIGraphicsElement(""String_Node_Str"");
  _header.setVisible(true);
  _body.setVisible(true);
  _footer.setVisible(true);
  addDisplayElement(_header);
  addDisplayElement(_body);
  addDisplayElement(_footer);
switch (scrollType) {
case vertical:
    setVerticalOptions();
  break;
case horizontal:
setHorizontalPositions();
break;
}
_header.getTextureOrigin().set(0f,155f / 512f);
_body.getTextureOrigin().set(7f / 512f,155f / 512f);
_footer.getTextureOrigin().set(0f,155f / 512f);
}",0.8836846213895394
1228,"public void setStyle(String property,String value){
  if (_style == null) {
    _style=new UIDisplayContainerStyle(getSize());
    _style.setPosition(getPosition());
    _style.setVisible(true);
    _style.setCroped(false);
    addDisplayElement(_style);
  }
  _style.parseStyle(property,value);
}","public void setStyle(String property,String value){
  if (_style == null) {
    _style=new UIDisplayContainerStyle(getSize());
    _style.setPosition(new Vector2f(0f,0f));
    _style.setVisible(true);
    _style.setCroped(false);
    addFirstDisplayElement(_style);
  }
  _style.parseStyle(property,value);
}",0.9421487603305784
1229,"@Override public void initialize(){
  logger.info(""String_Node_Str"");
  try {
    AL.create();
  }
 catch (  LWJGLException e) {
    logger.info(""String_Node_Str"" + e.getMessage());
    return;
  }
  AL10.alGetError();
  logger.info(""String_Node_Str"" + AL10.alGetString(AL10.AL_VERSION) + ""String_Node_Str"");
  ALCcontext context=ALC10.alcGetCurrentContext();
  ALCdevice device=ALC10.alcGetContextsDevice(context);
  logger.info(""String_Node_Str"" + AL10.alGetString(AL10.AL_RENDERER) + ""String_Node_Str""+ AL10.alGetString(AL10.AL_VENDOR));
  logger.info(""String_Node_Str"" + ALC10.alcGetString(device,ALC10.ALC_DEVICE_SPECIFIER));
  logger.info(""String_Node_Str"" + AL10.alGetString(AL10.AL_EXTENSIONS));
  logger.info(""String_Node_Str"" + ALC10.alcGetString(device,ALC10.ALC_EXTENSIONS));
  IntBuffer buffer=BufferUtils.createIntBuffer(1);
  ALC10.alcGetInteger(device,ALC11.ALC_MONO_SOURCES,buffer);
  logger.info(""String_Node_Str"" + buffer.get(0));
  buffer.rewind();
  ALC10.alcGetInteger(device,ALC11.ALC_STEREO_SOURCES,buffer);
  logger.info(""String_Node_Str"" + buffer.get(0));
  buffer.rewind();
  ALC10.alcGetInteger(device,ALC10.ALC_FREQUENCY,buffer);
  logger.info(""String_Node_Str"" + buffer.get(0));
  buffer.rewind();
  AL10.alDistanceModel(AL10.AL_INVERSE_DISTANCE_CLAMPED);
  this._pools.put(""String_Node_Str"",new BasicSoundPool(30));
  this._pools.put(""String_Node_Str"",new BasicStreamingSoundPool(2));
  this.loadAssets();
}","@Override public void initialize(){
  logger.info(""String_Node_Str"");
  try {
    AL.create();
  }
 catch (  LWJGLException e) {
    throw new RuntimeException(e);
  }
  AL10.alGetError();
  logger.info(""String_Node_Str"" + AL10.alGetString(AL10.AL_VERSION) + ""String_Node_Str"");
  ALCcontext context=ALC10.alcGetCurrentContext();
  ALCdevice device=ALC10.alcGetContextsDevice(context);
  logger.info(""String_Node_Str"" + AL10.alGetString(AL10.AL_RENDERER) + ""String_Node_Str""+ AL10.alGetString(AL10.AL_VENDOR));
  logger.info(""String_Node_Str"" + ALC10.alcGetString(device,ALC10.ALC_DEVICE_SPECIFIER));
  logger.info(""String_Node_Str"" + AL10.alGetString(AL10.AL_EXTENSIONS));
  logger.info(""String_Node_Str"" + ALC10.alcGetString(device,ALC10.ALC_EXTENSIONS));
  IntBuffer buffer=BufferUtils.createIntBuffer(1);
  ALC10.alcGetInteger(device,ALC11.ALC_MONO_SOURCES,buffer);
  logger.info(""String_Node_Str"" + buffer.get(0));
  buffer.rewind();
  ALC10.alcGetInteger(device,ALC11.ALC_STEREO_SOURCES,buffer);
  logger.info(""String_Node_Str"" + buffer.get(0));
  buffer.rewind();
  ALC10.alcGetInteger(device,ALC10.ALC_FREQUENCY,buffer);
  logger.info(""String_Node_Str"" + buffer.get(0));
  buffer.rewind();
  AL10.alDistanceModel(AL10.AL_INVERSE_DISTANCE_CLAMPED);
  this._pools.put(""String_Node_Str"",new BasicSoundPool(30));
  this._pools.put(""String_Node_Str"",new BasicStreamingSoundPool(2));
  this.loadAssets();
}",0.9690794096978216
1230,"private void setupMainMenu(){
  _mainMenu=new UIMainMenu();
  _mainMenu.setVisible(true);
  _mainMenu.getStartButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      Terasology.getInstance().setGameState(Terasology.GAME_STATE.SINGLE_PLAYER);
    }
  }
);
  _mainMenu.getExitButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      Terasology.getInstance().exit();
    }
  }
);
  _mainMenu.getConfigButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _mainMenu.setVisible(false);
      _configMenu.setVisible(true);
    }
  }
);
  _mainMenu.getOptionsButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _mainMenu.setVisible(false);
      _selectWorldMenu.setVisible(true);
    }
  }
);
  _selectWorldMenu.getGoToBackButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _selectWorldMenu.setVisible(false);
      _mainMenu.setVisible(true);
    }
  }
);
}","private void setupMainMenu(){
  _mainMenu=new UIMainMenu();
  _mainMenu.setVisible(true);
  _selectWorldMenu=new UISelectWorldMenu();
  _selectWorldMenu.setVisible(false);
  _mainMenu.getStartButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      Terasology.getInstance().setGameState(Terasology.GAME_STATE.SINGLE_PLAYER);
    }
  }
);
  _mainMenu.getExitButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      Terasology.getInstance().exit();
    }
  }
);
  _mainMenu.getConfigButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _mainMenu.setVisible(false);
      _configMenu.setVisible(true);
    }
  }
);
  _mainMenu.getOptionsButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _mainMenu.setVisible(false);
      _selectWorldMenu.setVisible(true);
    }
  }
);
  _selectWorldMenu.getGoToBackButton().addClickListener(new IClickListener(){
    public void clicked(    UIDisplayElement element){
      _selectWorldMenu.setVisible(false);
      _mainMenu.setVisible(true);
    }
  }
);
}",0.9648972602739726
1231,"public void clicked(Vector2f mousePos){
  _focused=true;
}","public void clicked(Vector2f mousePos){
  _focused=true;
  if (_inputValue.length() > 0 && _inputText.getTextWidth() > 0) {
    Vector2f absolutePosition=_inputText.calcAbsolutePosition();
    float positionRelativeElement=(absolutePosition.x + _inputText.getTextWidth()) - mousePos.x;
    float averageSymbols=_inputText.getTextWidth() / _inputValue.length();
    int pos=Math.abs((int)(positionRelativeElement / averageSymbols) - _inputValue.length());
    if (pos > (_inputValue.length() - 1)) {
      pos=_inputValue.length() - 1;
    }
 else     if (pos < 0) {
      pos=0;
    }
    _cursorPosition=pos;
    System.out.println(_cursorPosition);
  }
}",0.1624649859943977
1232,"public void update(){
  updateGraphicsElementsPosition();
  Vector2f mousePos=new Vector2f(Mouse.getX(),Display.getHeight() - Mouse.getY());
  if (intersects(mousePos)) {
    if (_mouseDown) {
      _scrolled=true;
      if (_prevMousePos == -1) {
        if (_scrollType == ScrollType.vertical) {
          _prevMousePos=mousePos.y;
        }
 else {
          _prevMousePos=mousePos.x;
        }
      }
    }
  }
  if (_scrolled) {
    scrolled(_scrollType == ScrollType.vertical ? mousePos.y : mousePos.x);
  }
  if (!_mouseDown || !_scrolled || _mouseUp) {
    _scrolled=false;
    _mouseDown=false;
    _prevMousePos=-1;
    _mouseUp=false;
  }
}","public void update(){
  updateThumb();
  Vector2f mousePos=new Vector2f(Mouse.getX(),Display.getHeight() - Mouse.getY());
  if (intersects(mousePos)) {
    if (_mouseDown) {
      _scrolled=true;
      if (_prevMousePos == -1) {
        if (_scrollType == ScrollType.vertical) {
          _prevMousePos=mousePos.y;
        }
 else {
          _prevMousePos=mousePos.x;
        }
      }
    }
  }
  if (_scrolled) {
    scrolled(_scrollType == ScrollType.vertical ? mousePos.y : mousePos.x);
  }
  if (!_mouseDown || !_scrolled || _mouseUp) {
    _scrolled=false;
    _mouseDown=false;
    _prevMousePos=-1;
    _mouseUp=false;
  }
  super.update();
}",0.9639293937068304
1233,"public UIScrollBar(Vector2f size,ScrollType scrollType){
  setScrollType(scrollType);
  for (int i=0; i < 3; i++) {
    _scrollGraphicsElements.add(new UIGraphicsElement(""String_Node_Str""));
    _scrollGraphicsElements.get(i).setVisible(true);
    addDisplayElement(_scrollGraphicsElements.get(i));
  }
switch (_scrollType) {
case vertical:
    setSize(new Vector2f(15f,size.y));
  setVerticalOptions(size);
break;
case horizontal:
setSize(new Vector2f(size.x,15f));
setHorizontalPositions();
break;
}
}","public UIScrollBar(Vector2f size,ScrollType scrollType){
  setScrollType(scrollType);
switch (_scrollType) {
case vertical:
    setSize(new Vector2f(15f,size.y));
  _scrolBarThumb=new UIScrollBarThumb(getSize(),ScrollType.vertical);
break;
case horizontal:
setSize(new Vector2f(size.x,15f));
_scrolBarThumb=new UIScrollBarThumb(getSize(),ScrollType.horizontal);
break;
}
_scrolBarThumb.setVisible(true);
addDisplayElement(_scrolBarThumb);
}",0.5090137857900318
1234,"private void scrolled(float mousePos){
  if (_max < (getScrollBarPosition() + mousePos - _prevMousePos + getScrollBarSize())) {
    mousePos=_max - getScrollBarSize() + _prevMousePos - getScrollBarPosition();
  }
 else   if (_min > (getScrollBarPosition() + mousePos - _prevMousePos)) {
    mousePos=_min + _prevMousePos - getScrollBarPosition();
  }
  _scrollShift=(mousePos - _prevMousePos) / _step;
  setScrollBarPosition((getScrollBarPosition() + mousePos - _prevMousePos));
  _prevMousePos=mousePos;
  for (int i=0; i < _scrollListeners.size(); i++) {
    _scrollListeners.get(i).scrolled(this);
  }
}","private void scrolled(float mousePos){
  if (_max < (_scrolBarThumb.getThumbPosition() + mousePos - _prevMousePos + _scrolBarThumb.getThumbSize())) {
    mousePos=_max - _scrolBarThumb.getThumbSize() + _prevMousePos - _scrolBarThumb.getThumbPosition();
  }
 else   if (_min > (_scrolBarThumb.getThumbPosition() + mousePos - _prevMousePos)) {
    mousePos=_min + _prevMousePos - _scrolBarThumb.getThumbPosition();
  }
  _scrolBarThumb.setThumbPosition((_scrolBarThumb.getThumbPosition() + mousePos - _prevMousePos));
  calculateValue();
  _prevMousePos=mousePos;
  for (int i=0; i < _scrollListeners.size(); i++) {
    _scrollListeners.get(i).scrolled(this);
  }
}",0.3750985027580772
1235,"public void setMaxMin(float min,float max){
  _min=min;
  _max=max;
}","public void setMaxMin(float min,float max){
  _min=min;
  _max=max;
switch (_scrollType) {
case vertical:
    setSize(new Vector2f(15f,max));
  break;
case horizontal:
setSize(new Vector2f(max,15f));
break;
}
}",0.4946236559139785
1236,"public void setStep(float contentLength,float containerLength){
  try {
    _step=1.0f / (contentLength / containerLength);
    if (_step > 1.0f) {
      _step=1.0f;
    }
  }
 catch (  ArithmeticException e) {
    _step=1.0f;
  }
  _containerLength=containerLength;
}","public void setStep(float contentLength,float containerLength){
  try {
    _step=containerLength / contentLength;
    if (_step > 1.0f) {
      _step=1.0f;
    }
  }
 catch (  ArithmeticException e) {
    _step=1.0f;
  }
  _containerLength=containerLength;
  _contentLength=contentLength;
}",0.404293381037567
1237,"public UIList(Vector2f size){
  setSize(size);
  setCrop(false);
  setCropMargin(new Vector4f(0.0f,25f,0.0f,5f));
  setScrollBarPosition(new Vector2f(getPosition().x + size.x,getPosition().y));
  _borderTop=new UIGraphicsElement(""String_Node_Str"");
  _borderTop.setVisible(true);
  _borderTop.getTextureSize().set(new Vector2f(256f / 512f,4f / 512f));
  _borderRight=new UIGraphicsElement(""String_Node_Str"");
  _borderRight.setVisible(true);
  _borderRight.setPosition(new Vector2f(getSize().x,getPosition().y));
  _borderRight.setRotateAngle(90f);
  _borderRight.getTextureSize().set(new Vector2f(256f / 512f,4f / 512f));
  _borderBottom=new UIGraphicsElement(""String_Node_Str"");
  _borderBottom.setVisible(true);
  _borderBottom.setPosition(new Vector2f(getSize().x,getSize().y));
  _borderBottom.setRotateAngle(180f);
  _borderBottom.getTextureSize().set(new Vector2f(256f / 512f,4f / 512f));
  _borderLeft=new UIGraphicsElement(""String_Node_Str"");
  _borderLeft.setVisible(true);
  _borderLeft.setRotateAngle(90f);
  _borderLeft.getTextureSize().set(new Vector2f(256f / 512f,4f / 512f));
  addDisplayElement(_borderTop);
  addDisplayElement(_borderRight);
  addDisplayElement(_borderBottom);
  addDisplayElement(_borderLeft);
}","public UIList(Vector2f size){
  setSize(size);
  setCrop(true);
  setCropMargin(new Vector4f(0.0f,25f,0.0f,5f));
  setScrollBarPosition(new Vector2f(getPosition().x + size.x,getPosition().y));
  _borderTop=new UIGraphicsElement(""String_Node_Str"");
  _borderTop.setVisible(true);
  _borderTop.getTextureSize().set(new Vector2f(256f / 512f,4f / 512f));
  _borderRight=new UIGraphicsElement(""String_Node_Str"");
  _borderRight.setVisible(true);
  _borderRight.setPosition(new Vector2f(getSize().x,getPosition().y));
  _borderRight.setRotateAngle(90f);
  _borderRight.getTextureSize().set(new Vector2f(256f / 512f,4f / 512f));
  _borderBottom=new UIGraphicsElement(""String_Node_Str"");
  _borderBottom.setVisible(true);
  _borderBottom.setPosition(new Vector2f(getSize().x,getSize().y));
  _borderBottom.setRotateAngle(180f);
  _borderBottom.getTextureSize().set(new Vector2f(256f / 512f,4f / 512f));
  _borderLeft=new UIGraphicsElement(""String_Node_Str"");
  _borderLeft.setVisible(true);
  _borderLeft.setRotateAngle(90f);
  _borderLeft.getTextureSize().set(new Vector2f(256f / 512f,4f / 512f));
  addDisplayElement(_borderTop);
  addDisplayElement(_borderRight);
  addDisplayElement(_borderBottom);
  addDisplayElement(_borderLeft);
}",0.9971556277935798
1238,"public void update(){
  Vector2f mousePos=new Vector2f(Mouse.getX(),Display.getHeight() - Mouse.getY());
  if (intersects(mousePos)) {
    for (int i=(_items.size() - 1); i >= 0; i--) {
      UIListItem item=_items.get(i);
      if (item.isVisible()) {
        if (item.intersects(mousePos)) {
          if (_mouseDown) {
            _items.get(_selectedItemIndex).setSelected(false);
            item.setSelected(true);
            _selectedItem=item;
            _selectedItemIndex=i;
            _mouseDown=false;
          }
        }
      }
    }
  }
 else {
    _mouseUp=false;
    _mouseDown=false;
  }
  updateBorders();
  super.update();
}","public void update(){
  Vector2f mousePos=new Vector2f(Mouse.getX(),Display.getHeight() - Mouse.getY());
  if (intersects(mousePos)) {
    for (int i=(_items.size() - 1); i >= 0; i--) {
      UIListItem item=_items.get(i);
      if (item.isVisible()) {
        if (item.intersects(mousePos)) {
          if (_mouseDown) {
            if (_selectedItemIndex > 0) {
              _items.get(_selectedItemIndex).setSelected(false);
            }
            item.setSelected(true);
            _selectedItem=item;
            _selectedItemIndex=i;
            _mouseDown=false;
          }
        }
      }
    }
  }
 else {
    _mouseUp=false;
    _mouseDown=false;
  }
  updateBorders();
  super.update();
}",0.957227138643068
1239,"public void removeSelectedItem(){
  Vector2f deletedElementPosition=_items.get(_selectedItemIndex).getPosition();
  removeDisplayElement(_selectedItem);
  _items.remove(_selectedItemIndex);
  for (int i=_selectedItemIndex; i < _items.size(); i++) {
    _items.get(i).getPosition().y-=32f;
  }
  _selectedItemIndex=_items.size() - 1;
}","public void removeSelectedItem(){
  if (_selectedItemIndex < 0 || _selectedItem == null) {
    return;
  }
  Vector2f deletedElementPosition=_items.get(_selectedItemIndex).getPosition();
  removeDisplayElement(_selectedItem);
  _items.remove(_selectedItemIndex);
  _selectedItem=null;
  for (int i=_selectedItemIndex; i < _items.size(); i++) {
    _items.get(i).getPosition().y-=32f;
  }
  if (_selectedItemIndex > _items.size() - 1) {
    if (_items.size() - 1 >= 0) {
      _selectedItemIndex=_items.size() - 1;
      _items.get(_selectedItemIndex).setSelected(true);
    }
 else {
      _selectedItemIndex=-1;
    }
  }
  if (_selectedItemIndex >= 0) {
    _selectedItem=_items.get(_selectedItemIndex);
    _selectedItem.setSelected(true);
  }
}",0.5785582255083179
1240,"public UIListItem(Vector2f size,String text,Object value){
  setSize(size);
  _text=text;
  _value=value;
  _label=new UIText();
  _label.setVisible(true);
  _label.setColor(Color.red);
  _label.setPosition(new Vector2f((getPosition().x + _padding.x),(getPosition().y + _padding.y)));
  _label.setText(_text);
  addDisplayElement(_label);
}","public UIListItem(Vector2f size,String text,Object value){
  setSize(size);
  _text=text;
  _value=value;
  _label=new UIText();
  _label.setVisible(true);
  _label.setColor(Color.black);
  _label.setPosition(new Vector2f((getPosition().x + _padding.x),(getPosition().y + _padding.y)));
  _label.setText(_text);
  addDisplayElement(_label);
}",0.9882697947214076
1241,"public void setSelected(boolean selected){
  _isSelected=selected;
  if (_isSelected) {
    _label.setColor(Color.orange);
  }
 else {
    _label.setColor(Color.red);
  }
}","public void setSelected(boolean selected){
  _isSelected=selected;
  if (_isSelected) {
    _label.setColor(Color.orange);
  }
 else {
    _label.setColor(Color.black);
  }
}",0.976878612716763
1242,"private void setHorizontalPositions(){
}","private void setHorizontalPositions(){
  _scrollGraphicsElements.get(0).setPosition(getPosition());
  _scrollGraphicsElements.get(0).setSize(new Vector2f(7f,15f));
  _scrollGraphicsElements.get(0).getTextureSize().set(new Vector2f(7f / 512f,15f / 512f));
  _scrollGraphicsElements.get(1).setPosition(new Vector2f(getPosition().x + _scrollGraphicsElements.get(0).getSize().x,getPosition().y));
  _scrollGraphicsElements.get(1).getTextureSize().set(new Vector2f(10f / 512f,15f / 512f));
  _scrollGraphicsElements.get(2).setRotateAngle(180);
  _scrollGraphicsElements.get(2).setPosition(new Vector2f((getPosition().x + 2 * _scrollGraphicsElements.get(0).getTextureSize().x + _scrollGraphicsElements.get(1).getSize().x),getPosition().y));
  _scrollGraphicsElements.get(2).setSize(new Vector2f(7f,15f));
  _scrollGraphicsElements.get(2).getTextureSize().set(new Vector2f(7f / 512f,15f / 512f));
}",0.0859291084854994
1243,"public void render(){
  super.render();
  updateCameraParameters();
  if (SHOW_PLACING_BOX) {
    if (_selectedBlock != null) {
      Block block=BlockManager.getInstance().getBlock(_parent.getWorldProvider().getBlockAtPosition(_selectedBlock.getBlockPosition().toVector3d()));
      if (block.isRenderBoundingBox()) {
        block.getBounds(_selectedBlock.getBlockPosition()).render(8f);
      }
    }
  }
  if (isRenderPlayerModel())   getAABB().render(4f);
}","public void render(){
  super.render();
  updateCameraParameters();
  if (SHOW_PLACING_BOX) {
    if (_selectedBlock != null) {
      Block block=BlockManager.getInstance().getBlock(_parent.getWorldProvider().getBlockAtPosition(_selectedBlock.getBlockPosition().toVector3d()));
      if (block.isRenderBoundingBox()) {
        block.getBounds(_selectedBlock.getBlockPosition()).render(2f);
      }
    }
  }
  if (isRenderPlayerModel())   getAABB().render(1f);
}",0.9956709956709956
1244,"/** 
 * Updates the status if the entity is currently swimming (in water).
 */
private void updateSwimStatus(){
  ArrayList<BlockPosition> blockPositions=gatherAdjacentBlockPositions(getPosition());
  boolean swimming=false, headUnderWater=false;
  Vector3d eyePos=calcEyePosition();
  eyePos.y+=0.25;
  for (int i=0; i < blockPositions.size(); i++) {
    BlockPosition p=blockPositions.get(i);
    byte blockType=_parent.getWorldProvider().getBlockAtPosition(new Vector3d(p.x,p.y,p.z));
    Block block=BlockManager.getInstance().getBlock(blockType);
    if (block.isLiquid()) {
      for (      AABB blockAABB : block.getColliders(p.x,p.y,p.z)) {
        if (getAABB().overlaps(blockAABB)) {
          swimming=true;
          if (blockAABB.contains(eyePos)) {
            headUnderWater=true;
            break;
          }
        }
      }
    }
  }
  _headUnderWater=headUnderWater;
  _isSwimming=swimming;
}","/** 
 * Updates the status if the entity is currently swimming (in water).
 */
private void updateSwimStatus(){
  ArrayList<BlockPosition> blockPositions=gatherAdjacentBlockPositions(getPosition());
  boolean swimming=false, headUnderWater=false;
  Vector3d eyePos=calcEyePosition();
  eyePos.y+=0.25;
  for (int i=0; i < blockPositions.size(); i++) {
    BlockPosition p=blockPositions.get(i);
    byte blockType=_parent.getWorldProvider().getBlockAtPosition(new Vector3d(p.x,p.y,p.z));
    Block block=BlockManager.getInstance().getBlock(blockType);
    if (block.isLiquid()) {
      for (      AABB blockAABB : block.getColliders(p.x,p.y,p.z)) {
        if (getAABB().overlaps(blockAABB)) {
          swimming=true;
        }
        if (swimming=true) {
          if (blockAABB.contains(eyePos)) {
            headUnderWater=true;
            break;
          }
        }
      }
    }
  }
  _headUnderWater=headUnderWater;
  _isSwimming=swimming;
}",0.9791108730583824
1245,"public void render(){
  setViewingDirection(_yaw,_pitch);
  if (Config.getInstance().isDebugCollision()) {
    getAABB().render(2f);
    ArrayList<BlockPosition> blocks=gatherAdjacentBlockPositions(getPosition());
    for (int i=0; i < blocks.size(); i++) {
      BlockPosition p=blocks.get(i);
      byte blockType=_parent.getWorldProvider().getBlockAtPosition(new Vector3d(p.x,p.y,p.z));
      Block block=BlockManager.getInstance().getBlock(blockType);
      for (      AABB blockAABB : block.getColliders(p.x,p.y,p.z)) {
        blockAABB.render(2f);
      }
    }
  }
}","public void render(){
  setViewingDirection(_yaw,_pitch);
  if (Config.getInstance().isDebugCollision()) {
    getAABB().render(1f);
    ArrayList<BlockPosition> blocks=gatherAdjacentBlockPositions(getPosition());
    for (int i=0; i < blocks.size(); i++) {
      BlockPosition p=blocks.get(i);
      byte blockType=_parent.getWorldProvider().getBlockAtPosition(new Vector3d(p.x,p.y,p.z));
      Block block=BlockManager.getInstance().getBlock(blockType);
      for (      AABB blockAABB : block.getColliders(p.x,p.y,p.z)) {
        blockAABB.render(1f);
      }
    }
  }
}",0.9965156794425089
1246,"/** 
 * Draws the opaque or translucent elements of a chunk.
 * @param type The type of vertices to render
 */
public void render(ChunkMesh.RENDER_PHASE type){
  if (isReadyForRendering()) {
    ShaderProgram shader=ShaderManager.getInstance().getShaderProgram(""String_Node_Str"");
    shader.setFloat3(""String_Node_Str"",(float)(getPosition().x * Chunk.CHUNK_DIMENSION_X),(float)(getPosition().y * Chunk.CHUNK_DIMENSION_Y),(float)(getPosition().z * Chunk.CHUNK_DIMENSION_Z));
    GL11.glPushMatrix();
    Vector3d cameraPosition=Terasology.getInstance().getActiveCamera().getPosition();
    GL11.glTranslated(getPosition().x * Chunk.CHUNK_DIMENSION_X - cameraPosition.x,getPosition().y * Chunk.CHUNK_DIMENSION_Y - cameraPosition.y,getPosition().z * Chunk.CHUNK_DIMENSION_Z - cameraPosition.z);
    for (int i=0; i < VERTICAL_SEGMENTS; i++) {
      if (!isSubMeshEmpty(i)) {
        if (Config.getInstance().isRenderChunkBoundingBoxes()) {
          getSubMeshAABB(i).renderLocally(2f);
          _statRenderedTriangles+=12;
        }
        shader.enable();
        _activeMeshes[i].render(type);
        _statRenderedTriangles+=_activeMeshes[i].triangleCount();
      }
    }
    GL11.glPopMatrix();
  }
 else {
    _statChunkNotReady++;
  }
}","/** 
 * Draws the opaque or translucent elements of a chunk.
 * @param type The type of vertices to render
 */
public void render(ChunkMesh.RENDER_PHASE type){
  if (isReadyForRendering()) {
    ShaderProgram shader=ShaderManager.getInstance().getShaderProgram(""String_Node_Str"");
    shader.setFloat3(""String_Node_Str"",(float)(getPosition().x * Chunk.CHUNK_DIMENSION_X),(float)(getPosition().y * Chunk.CHUNK_DIMENSION_Y),(float)(getPosition().z * Chunk.CHUNK_DIMENSION_Z));
    GL11.glPushMatrix();
    Vector3d cameraPosition=Terasology.getInstance().getActiveCamera().getPosition();
    GL11.glTranslated(getPosition().x * Chunk.CHUNK_DIMENSION_X - cameraPosition.x,getPosition().y * Chunk.CHUNK_DIMENSION_Y - cameraPosition.y,getPosition().z * Chunk.CHUNK_DIMENSION_Z - cameraPosition.z);
    for (int i=0; i < VERTICAL_SEGMENTS; i++) {
      if (!isSubMeshEmpty(i)) {
        if (Config.getInstance().isRenderChunkBoundingBoxes()) {
          getSubMeshAABB(i).renderLocally(1f);
          _statRenderedTriangles+=12;
        }
        shader.enable();
        _activeMeshes[i].render(type);
        _statRenderedTriangles+=_activeMeshes[i].triangleCount();
      }
    }
    GL11.glPopMatrix();
  }
 else {
    _statChunkNotReady++;
  }
}",0.9991961414790996
1247,"/** 
 * Renders the world.
 */
public void render(){
  queueRenderer();
  PostProcessingRenderer.getInstance().beginRenderScene();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  getActiveCamera().lookThroughNormalized();
  _skysphere.render();
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  getActiveCamera().lookThrough();
  _player.render();
  glEnable(GL_LIGHT0);
  boolean headUnderWater=false;
  if (_cameraMode == CAMERA_MODE.PLAYER)   _player.isHeadUnderWater();
  if (_wireframe)   glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);
  PerformanceMonitor.startActivity(""String_Node_Str"");
  while (_renderQueueOpaque.size() > 0)   _renderQueueOpaque.poll().render();
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  while (_renderQueueChunksOpaque.size() > 0)   _renderQueueChunksOpaque.poll().render(ChunkMesh.RENDER_PHASE.OPAQUE);
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  while (_renderQueueChunksSortedBillboards.size() > 0)   _renderQueueChunksSortedBillboards.poll().render(ChunkMesh.RENDER_PHASE.BILLBOARD_AND_TRANSLUCENT);
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  while (_renderQueueTransparent.size() > 0)   _renderQueueTransparent.poll().render();
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  if (headUnderWater) {
    glDisable(GL11.GL_CULL_FACE);
  }
  while (_renderQueueChunksSortedWater.size() > 0) {
    Chunk c=_renderQueueChunksSortedWater.poll();
    for (int j=0; j < 2; j++) {
      if (j == 0) {
        glColorMask(false,false,false,false);
        c.render(ChunkMesh.RENDER_PHASE.WATER_AND_ICE);
      }
 else {
        glColorMask(true,true,true,true);
        c.render(ChunkMesh.RENDER_PHASE.WATER_AND_ICE);
      }
    }
  }
  _player.renderExtractionOverlay();
  glDisable(GL_BLEND);
  if (headUnderWater)   glEnable(GL11.GL_CULL_FACE);
  if (_wireframe)   glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);
  glDisable(GL_LIGHT0);
  PerformanceMonitor.endActivity();
  PostProcessingRenderer.getInstance().endRenderScene();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  PostProcessingRenderer.getInstance().renderScene();
  PerformanceMonitor.endActivity();
  if (_cameraMode == CAMERA_MODE.PLAYER)   _player.renderFirstPersonViewElements();
}","/** 
 * Renders the world.
 */
public void render(){
  queueRenderer();
  PostProcessingRenderer.getInstance().beginRenderScene();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  getActiveCamera().lookThroughNormalized();
  _skysphere.render();
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  getActiveCamera().lookThrough();
  _player.render();
  glEnable(GL_LIGHT0);
  boolean headUnderWater=false;
  if (_cameraMode == CAMERA_MODE.PLAYER)   headUnderWater=_player.isHeadUnderWater();
  if (_wireframe)   glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);
  PerformanceMonitor.startActivity(""String_Node_Str"");
  while (_renderQueueOpaque.size() > 0)   _renderQueueOpaque.poll().render();
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  while (_renderQueueChunksOpaque.size() > 0)   _renderQueueChunksOpaque.poll().render(ChunkMesh.RENDER_PHASE.OPAQUE);
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  while (_renderQueueChunksSortedBillboards.size() > 0)   _renderQueueChunksSortedBillboards.poll().render(ChunkMesh.RENDER_PHASE.BILLBOARD_AND_TRANSLUCENT);
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  while (_renderQueueTransparent.size() > 0)   _renderQueueTransparent.poll().render();
  PerformanceMonitor.endActivity();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  if (headUnderWater) {
    glDisable(GL11.GL_CULL_FACE);
  }
  while (_renderQueueChunksSortedWater.size() > 0) {
    Chunk c=_renderQueueChunksSortedWater.poll();
    for (int j=0; j < 2; j++) {
      if (j == 0) {
        glColorMask(false,false,false,false);
        c.render(ChunkMesh.RENDER_PHASE.WATER_AND_ICE);
      }
 else {
        glColorMask(true,true,true,true);
        c.render(ChunkMesh.RENDER_PHASE.WATER_AND_ICE);
      }
    }
  }
  _player.renderExtractionOverlay();
  glDisable(GL_BLEND);
  if (headUnderWater)   glEnable(GL11.GL_CULL_FACE);
  if (_wireframe)   glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);
  glDisable(GL_LIGHT0);
  PerformanceMonitor.endActivity();
  PostProcessingRenderer.getInstance().endRenderScene();
  PerformanceMonitor.startActivity(""String_Node_Str"");
  PostProcessingRenderer.getInstance().renderScene();
  PerformanceMonitor.endActivity();
  if (_cameraMode == CAMERA_MODE.PLAYER)   _player.renderFirstPersonViewElements();
}",0.9970053902974646
1248,"/** 
 * Returns true if no more chunks can be generated.
 * @return
 */
public boolean generateChunk(){
  updateChunksInProximity(false);
  for (int i=0; i < _chunksInProximity.size(); i++) {
    Chunk c=_chunksInProximity.get(i);
    if (c.isDirty() || c.isLightDirty() || c.isFresh()) {
      c.processChunk();
      c.generateVBOs();
      return false;
    }
  }
  return true;
}","/** 
 * Returns true if no more chunks can be generated.
 * @return
 */
public boolean generateChunk(){
  for (int i=0; i < _chunksInProximity.size(); i++) {
    Chunk c=_chunksInProximity.get(i);
    if (c.isDirty() || c.isLightDirty() || c.isFresh()) {
      c.processChunk();
      c.generateVBOs();
      return false;
    }
  }
  return true;
}",0.953551912568306
1249,"/** 
 * Sets a new player and spawns him at the spawning point.
 * @param p The player
 */
public void setPlayer(Player p){
  if (_player != null) {
    _player.unregisterObserver(_chunkUpdateManager);
    _player.unregisterObserver(_worldProvider.getGrowthSimulator());
    _player.unregisterObserver(_worldProvider.getLiquidSimulator());
  }
  _player=p;
  _player.registerObserver(_chunkUpdateManager);
  _player.registerObserver(_worldProvider.getGrowthSimulator());
  _player.registerObserver(_worldProvider.getLiquidSimulator());
  _player.load();
  _player.setSpawningPoint(_worldProvider.nextSpawningPoint());
  _player.reset();
  if (_player.getPosition().equals(new Vector3d(0.0,0.0,0.0))) {
    _player.respawn();
  }
}","/** 
 * Sets a new player and spawns him at the spawning point.
 * @param p The player
 */
public void setPlayer(Player p){
  if (_player != null) {
    _player.unregisterObserver(_chunkUpdateManager);
    _player.unregisterObserver(_worldProvider.getGrowthSimulator());
    _player.unregisterObserver(_worldProvider.getLiquidSimulator());
  }
  _player=p;
  _player.registerObserver(_chunkUpdateManager);
  _player.registerObserver(_worldProvider.getGrowthSimulator());
  _player.registerObserver(_worldProvider.getLiquidSimulator());
  _player.load();
  _player.setSpawningPoint(_worldProvider.nextSpawningPoint());
  updateChunksInProximity(true);
  _player.reset();
  if (_player.getPosition().equals(new Vector3d(0.0,0.0,0.0))) {
    _player.respawn();
  }
}",0.9778968519758876
1250,"public SoundSource setAudio(Sound sound){
  if (sound == null || sound.equals(this.audio)) {
    return this;
  }
  boolean playing=isPlaying();
  if (playing) {
    this.stop();
  }
  if (sound instanceof AbstractSound) {
    this.audio=(AbstractSound)sound;
    AL10.alSourcei(this.getSourceId(),AL10.AL_BUFFER,this.audio.getBufferId());
    OpenALException.checkState(""String_Node_Str"");
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (playing) {
    this.play();
  }
  return this;
}","public SoundSource setAudio(Sound sound){
  boolean playing=isPlaying();
  if (playing) {
    this.stop();
  }
  this.reset();
  if (sound instanceof AbstractSound) {
    this.audio=(AbstractSound)sound;
    AL10.alSourcei(this.getSourceId(),AL10.AL_BUFFER,this.audio.getBufferId());
    OpenALException.checkState(""String_Node_Str"");
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (playing) {
    this.play();
  }
  return this;
}",0.8109756097560976
1251,"private void updateFade(){
  if (!fade) {
    return;
  }
  float delta=(this.srcGain - this.targetGain) / 100;
  System.out.println(""String_Node_Str"" + this.audio.getName());
  this.setGain(this.getGain() - delta);
  if (this.getGain() >= this.targetGain) {
    if (this.targetGain == 0.0f) {
      this.stop();
    }
    fade=false;
  }
}","private void updateFade(){
  if (!fade) {
    return;
  }
  float delta=(this.srcGain - this.targetGain) / 100;
  this.setGain(this.getGain() - delta);
  if (this.getGain() >= this.targetGain) {
    if (this.targetGain == 0.0f) {
      this.stop();
    }
    fade=false;
  }
}",0.8961038961038961
1252,"public void load(File file){
  if (file == null || !file.exists()) {
    throw new IllegalArgumentException(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
  }
  try {
    this.load(new FileInputStream(file));
  }
 catch (  IOException e) {
    throw new IllegalStateException(""String_Node_Str"" + e.getMessage(),e);
  }
}","public void load(URL source){
  try {
    this.load(source.openStream());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.5136842105263157
1253,"public AbstractStreamingSound(String name,InputStream source){
  super(name,source);
  this.audioStream=source;
  this.initializeBuffers();
}","public AbstractStreamingSound(String name,URL source){
  super(name);
  this.audioSource=source;
  this.initializeBuffers();
  this.reset();
}",0.8480565371024735
1254,"public void update(){
  this.updateFade();
  if (this.absolutePosition) {
    updatePosition(this.position);
  }
  if (_playing && alGetSourcei(this.sourceId,AL_SOURCE_STATE) != AL_PLAYING) {
    _playing=false;
  }
}","public void update(){
  this.updateFade();
  if (this.absolutePosition) {
    updatePosition(this.position);
  }
  this.updateState();
}",0.7195467422096318
1255,"public SoundSource setLooping(boolean looping){
  AL10.alSourcei(this.getSourceId(),AL10.AL_LOOPING,looping ? AL10.AL_TRUE : AL10.AL_FALSE);
  OpenALException.checkState(""String_Node_Str"");
  return this;
}","public SoundSource setLooping(boolean looping){
  alSourcei(this.getSourceId(),AL_LOOPING,looping ? AL_TRUE : AL_FALSE);
  OpenALException.checkState(""String_Node_Str"");
  return this;
}",0.9489795918367347
1256,"private void updateFade(){
  if (!fade) {
    return;
  }
  float delta=(this.srcGain - this.targetGain) / 10;
  this.setGain(this.srcGain - delta);
  if (this.getGain() == this.targetGain) {
    if (this.targetGain == 0.0f) {
      this.stop();
    }
    fade=false;
  }
}","private void updateFade(){
  if (!fade) {
    return;
  }
  float delta=(this.srcGain - this.targetGain) / 100;
  System.out.println(""String_Node_Str"" + this.audio.getName());
  this.setGain(this.getGain() - delta);
  if (this.getGain() >= this.targetGain) {
    if (this.targetGain == 0.0f) {
      this.stop();
    }
    fade=false;
  }
}",0.7928221859706363
1257,"public SoundSource stop(){
  alSourceRewind(this.getSourceId());
  AL10.alSourceStop(this.getSourceId());
  OpenALException.checkState(""String_Node_Str"");
  _playing=false;
  return this;
}","public SoundSource stop(){
  if (this.audio != null) {
    this.audio.reset();
  }
  alSourceStop(this.getSourceId());
  alSourceRewind(this.getSourceId());
  OpenALException.checkState(""String_Node_Str"");
  _playing=false;
  return this;
}",0.6899766899766899
1258,"@Override public void update(){
  int buffersProcessed=AL10.alGetSourcei(this.getSourceId(),AL10.AL_BUFFERS_PROCESSED);
  while (buffersProcessed-- > 0) {
    int buffer=AL10.alSourceUnqueueBuffers(this.getSourceId());
    if (((AbstractStreamingSound)audio).updateBuffer(buffer)) {
      AL10.alSourceQueueBuffers(this.getSourceId(),buffer);
    }
 else {
      _playing=false;
      continue;
    }
    OpenALException.checkState(""String_Node_Str"");
  }
  int state=AL10.alGetSourcei(getSourceId(),AL10.AL_SOURCE_STATE);
  if (_playing && state != AL10.AL_PLAYING) {
    AL10.alSourcePlay(this.getSourceId());
  }
  super.update();
}","@Override public void update(){
  System.out.println(""String_Node_Str"" + this.sourceId + ""String_Node_Str""+ _playing+ ""String_Node_Str""+ alGetSourcei(this.sourceId,AL_SOURCE_STATE));
  int buffersProcessed=alGetSourcei(this.getSourceId(),AL_BUFFERS_PROCESSED);
  while (buffersProcessed-- > 0) {
    int buffer=alSourceUnqueueBuffers(this.getSourceId());
    OpenALException.checkState(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + buffer + ""String_Node_Str""+ this.audio.getName()+ ""String_Node_Str""+ this.sourceId);
    if (((AbstractStreamingSound)audio).updateBuffer(buffer)) {
      alSourceQueueBuffers(this.getSourceId(),buffer);
      OpenALException.checkState(""String_Node_Str"");
    }
 else {
      _playing=false;
      continue;
    }
  }
  super.update();
}",0.3530239099859353
1259,"public SoundSource setAudio(Sound sound){
  if (sound == null || sound.equals(this.audio)) {
    return this;
  }
  if (sound instanceof AbstractStreamingSound) {
    AbstractStreamingSound asa=(AbstractStreamingSound)sound;
    this.audio=asa;
    int[] buffers=asa.getBuffers();
    for (    int buffer : buffers) {
      asa.updateBuffer(buffer);
    }
    AL10.alSourceQueueBuffers(this.getSourceId(),(IntBuffer)BufferUtils.createIntBuffer(buffers.length).put(buffers).flip());
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return this;
}","public SoundSource setAudio(Sound sound){
  boolean playing=this.isPlaying();
  if (playing) {
    alSourceStop(this.sourceId);
    alSourceRewind(this.sourceId);
  }
  if (sound instanceof AbstractStreamingSound) {
    alSourcei(this.getSourceId(),AL_BUFFER,0);
    AbstractStreamingSound asa=(AbstractStreamingSound)sound;
    this.audio=asa;
    asa.reset();
    int[] buffers=asa.getBuffers();
    for (    int buffer : buffers) {
      asa.updateBuffer(buffer);
    }
    alSourceQueueBuffers(this.getSourceId(),(IntBuffer)BufferUtils.createIntBuffer(buffers.length).put(buffers).flip());
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (playing) {
    this.play();
  }
  return this;
}",0.5895061728395061
1260,"public void load(InputStream stream){
  if (stream == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    ByteArrayOutputStream bos=new ByteArrayOutputStream();
    OggReader reader=new OggReader(stream);
    FileOutputStream fos=new FileOutputStream(""String_Node_Str"");
    byte buffer[]=new byte[1024];
    int read;
    int totalRead=0;
    do {
      read=reader.read(buffer,0,buffer.length);
      if (read < 0) {
        break;
      }
      totalRead+=read;
      bos.write(buffer,0,read);
      fos.write(buffer,0,read);
    }
 while (read > 0);
    buffer=bos.toByteArray();
    ByteBuffer data=BufferUtils.createByteBuffer(totalRead).put(buffer);
    data.flip();
    this.channels=reader.getChannels();
    int sampleRate=reader.getRate();
    AL10.alBufferData(this.getBufferId(),this.channels == 1 ? AL10.AL_FORMAT_MONO16 : AL10.AL_FORMAT_STEREO16,data,sampleRate);
    OpenALException.checkState(""String_Node_Str"");
  }
 catch (  IOException e) {
    throw new IllegalStateException(""String_Node_Str"" + e.getMessage(),e);
  }
}","public void load(InputStream stream){
  if (stream == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    ByteArrayOutputStream bos=new ByteArrayOutputStream();
    OggReader reader=new OggReader(stream);
    byte buffer[]=new byte[1024];
    int read;
    int totalRead=0;
    do {
      read=reader.read(buffer,0,buffer.length);
      if (read < 0) {
        break;
      }
      totalRead+=read;
      bos.write(buffer,0,read);
    }
 while (read > 0);
    buffer=bos.toByteArray();
    ByteBuffer data=BufferUtils.createByteBuffer(totalRead).put(buffer);
    data.flip();
    this.channels=reader.getChannels();
    int sampleRate=reader.getRate();
    AL10.alBufferData(this.getBufferId(),this.channels == 1 ? AL10.AL_FORMAT_MONO16 : AL10.AL_FORMAT_STEREO16,data,sampleRate);
    OpenALException.checkState(""String_Node_Str"");
  }
 catch (  IOException e) {
    throw new IllegalStateException(""String_Node_Str"" + e.getMessage(),e);
  }
}",0.9521016617790812
1261,"public OggSound(String name){
  super(name);
}","public OggSound(String name,URL source){
  super(name,source);
}",0.8363636363636363
1262,"@Override protected ByteBuffer fetchData(){
  try {
    int read=file.read(dataBuffer,0,dataBuffer.capacity());
    dataBuffer.rewind();
    if (read <= 0) {
      return null;
    }
    return dataBuffer;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","@Override protected ByteBuffer fetchData(){
  try {
    int read=file.read(dataBuffer,0,dataBuffer.capacity());
    dataBuffer.rewind();
    System.out.println(""String_Node_Str"" + read);
    if (read <= 0) {
      return null;
    }
    return dataBuffer;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9172185430463576
1263,"@Override public void load(InputStream stream){
  super.load(stream);
  this.file=new OggReader(stream);
}","public void load(InputStream stream){
  if (this.file != null) {
    try {
      this.file.close();
    }
 catch (    IOException e) {
    }
  }
  this.file=new OggReader(stream);
}",0.5993031358885017
1264,"public OggStreamingSound(String name,InputStream source){
  super(name,source);
}","public OggStreamingSound(String name,URL source){
  super(name,source);
}",0.9090909090909092
1265,"public void update(){
  _defaultTexture.setSize(getSize());
  Vector2f mousePos=new Vector2f(Mouse.getX(),Display.getHeight() - Mouse.getY());
  if (intersects(mousePos)) {
    if (!_clickSoundPlayed) {
      AudioManager.getInstance().getAudio(""String_Node_Str"").playAsSoundEffect(1.0f,0.5f,false);
      _clickSoundPlayed=true;
    }
    if (_mouseUp) {
      _mouseUp=false;
    }
    if (_mouseDown) {
      clicked();
    }
  }
 else {
    if (_mouseDown) {
      _focused=false;
    }
    _clickSoundPlayed=false;
    _mouseUp=false;
    _mouseDown=false;
    _defaultTexture.getTextureOrigin().set(0f,90f / 512f);
  }
  if (_focused) {
    _defaultTexture.getTextureOrigin().set(0f,120f / 512f);
  }
 else {
    _defaultTexture.getTextureOrigin().set(0f,90f / 512f);
  }
  _inputText.setText(_inputValue.toString());
}","public void update(){
  _defaultTexture.setSize(getSize());
  Vector2f mousePos=new Vector2f(Mouse.getX(),Display.getHeight() - Mouse.getY());
  if (intersects(mousePos)) {
    if (!_clickSoundPlayed) {
      AudioManager.getInstance().getAudio(""String_Node_Str"").playAsSoundEffect(1.0f,0.5f,false);
      _clickSoundPlayed=true;
    }
    if (_mouseUp) {
      _mouseUp=false;
    }
    if (_mouseDown) {
      clicked();
    }
  }
 else {
    if (_mouseDown) {
      _focused=false;
    }
    _clickSoundPlayed=false;
    _mouseUp=false;
    _mouseDown=false;
    _defaultTexture.getTextureOrigin().set(0f,90f / 512f);
  }
  if (_focused) {
    if (!_textCursor.isVisible()) {
      _textCursor.setVisible(true);
    }
    _defaultTexture.getTextureOrigin().set(0f,120f / 512f);
  }
 else {
    if (_textCursor.isVisible()) {
      _textCursor.setVisible(false);
    }
    _defaultTexture.getTextureOrigin().set(0f,90f / 512f);
  }
  float textWidthWhithPos=_inputText.getTextWidth() + _inputText.getPosition().x + getPosition().x;
  if (textWidthWhithPos > (getPosition().x + getSize().x)) {
    _inputText.setPosition(new Vector2f((_inputText.getPosition().x - 8f),_inputText.getPosition().y));
  }
}",0.7934943321833415
1266,"public void processKeyboardInput(int key){
  if (_focused) {
    if (key == Keyboard.KEY_BACK) {
      int length=_inputValue.length() - 1;
      if (length < 0) {
        length=0;
      }
      _inputValue.setLength(length);
    }
 else {
      char c=Keyboard.getEventCharacter();
      _inputValue.append(c);
    }
  }
}","public void processKeyboardInput(int key){
  System.out.println(_inputText.getPosition().x);
  System.out.println(getPosition().x);
  System.out.println(_inputText.getTextWidth());
  System.out.println(getSize().x);
  System.out.println(""String_Node_Str"");
  if (_focused) {
    if (key == Keyboard.KEY_BACK) {
      int length=_inputValue.length() - 1;
      if (length < 0) {
        length=0;
      }
      _inputValue.setLength(length);
      float textPosition=_inputText.getPosition().x;
      if (textPosition < 0) {
        if (textPosition + 8f > 0 && textPosition + 8f < _padding.x) {
          _inputText.setPosition(new Vector2f(_padding.x,_inputText.getPosition().y));
        }
 else {
          _inputText.setPosition(new Vector2f(textPosition + 8f,_inputText.getPosition().y));
        }
      }
    }
 else {
      char c=Keyboard.getEventCharacter();
      if (c >= 'a' && c < 'z' + 1 || c >= '0' && c < '9' + 1 || c >= 'A' && c < 'Z' + 1 || c == ' ' || c == '_' || c == '.' || c == ',' || c == '!' || c == '-' || c == '(' || c == ')' || c == '""' || c == '\'' || c == ';' || c == '+') {
        _inputValue.append(c);
      }
    }
    _inputText.setText(_inputValue.toString());
    _textCursor.setPosition(new Vector2f(_padding.x / 2 + _inputText.getTextWidth() / 2,(_textCursor.getPosition().y)));
  }
}",0.3932038834951456
1267,"public UIInput(Vector2f size){
  setSize(size);
  setCrop(true);
  _defaultTexture=new UIGraphicsElement(""String_Node_Str"");
  _defaultTexture.setVisible(true);
  _defaultTexture.getTextureSize().set(new Vector2f(256f / 512f,30f / 512f));
  _inputText=new UIText();
  _inputText.setVisible(true);
  _inputText.setColor(Color.red);
  _inputText.setPosition(new Vector2f((getPosition().x + _padding.x),(getPosition().y + _padding.y)));
  addDisplayElement(_defaultTexture);
  addDisplayElement(_inputText);
}","public UIInput(Vector2f size){
  setSize(size);
  setCrop(true);
  _defaultTexture=new UIGraphicsElement(""String_Node_Str"");
  _defaultTexture.setVisible(true);
  _defaultTexture.getTextureSize().set(new Vector2f(256f / 512f,30f / 512f));
  _inputText=new UIText();
  _inputText.setVisible(true);
  _inputText.setPosition(new Vector2f((getPosition().x + _padding.x),(getPosition().y + _padding.y)));
  _textCursor=new UITextCursor();
  _textCursor.setVisible(false);
  _textCursor.setPosition(new Vector2f((getPosition().x + _padding.x + _inputText.getTextWidth()),(getPosition().y + _padding.y / 2)));
  System.out.println(""String_Node_Str"" + _textCursor.getPosition());
  addDisplayElement(_defaultTexture);
  addDisplayElement(_inputText);
  addDisplayElement(_textCursor);
}",0.7429906542056075
1268,"public void clicked(){
  System.out.println(""String_Node_Str"" + Mouse.getX() + ""String_Node_Str""+ (Display.getHeight() - Mouse.getY()));
  System.out.println(""String_Node_Str"" + getPosition().y + ""String_Node_Str""+ (Display.getHeight() - Mouse.getY()));
  _focused=true;
}","public void clicked(){
  _focused=true;
}",0.2619808306709265
1269,"/** 
 * Places a block of a given type in front of the player.
 * @param type The type of the block
 * @return True if a block was placed
 */
public boolean placeBlock(BlockGroup type){
  IWorldProvider worldProvider=_player.getParent().getWorldProvider();
  RayBlockIntersection.Intersection selectedBlock=_player.getSelectedBlock();
  if (selectedBlock != null) {
    BlockPosition centerPos=selectedBlock.getBlockPosition();
    Block centerBlock=BlockManager.getInstance().getBlock(worldProvider.getBlock(centerPos.x,centerPos.y,centerPos.z));
    if (!centerBlock.isAllowBlockAttachment()) {
      return false;
    }
    BlockPosition blockPos=selectedBlock.calcAdjacentBlockPos();
    Block adjBlock=BlockManager.getInstance().getBlock(worldProvider.getBlock(blockPos.x,blockPos.y,blockPos.z));
    if (adjBlock != null && !adjBlock.isInvisible() && adjBlock.isRenderBoundingBox()) {
      return false;
    }
    Side attachmentSide=Side.inDirection(centerPos.x - blockPos.x,centerPos.y - blockPos.y,centerPos.z - blockPos.z);
    Vector3d attachDir=new Vector3d(centerPos.x - blockPos.x,centerPos.y - blockPos.y,centerPos.z - blockPos.z);
    Vector3d rawDirection=new Vector3d(_player.getViewingDirection());
    double dot=rawDirection.dot(attachDir);
    rawDirection.sub(new Vector3d(dot * attachDir.x,dot * attachDir.y,dot * attachDir.z));
    Side direction=Side.inDirection(rawDirection.x,rawDirection.y,rawDirection.z);
    Block block=type.getBlockFor(attachmentSide,direction);
    if (block == null)     return false;
    if (!block.isPenetrable()) {
      for (      AABB blockAABB : block.getColliders(blockPos.x,blockPos.y,blockPos.z)) {
        if (blockAABB.overlaps(_player.getAABB())) {
          return false;
        }
      }
    }
    placeBlock(blockPos,block.getId(),true);
    AudioManager.getInstance().playVaryingSound(""String_Node_Str"",0.6f,0.5f);
    return true;
  }
  return false;
}","/** 
 * Places a block of a given type in front of the player.
 * @param type The type of the block
 * @return True if a block was placed
 */
public boolean placeBlock(BlockGroup type){
  IWorldProvider worldProvider=_player.getParent().getWorldProvider();
  RayBlockIntersection.Intersection selectedBlock=_player.getSelectedBlock();
  if (selectedBlock != null) {
    BlockPosition centerPos=selectedBlock.getBlockPosition();
    Block centerBlock=BlockManager.getInstance().getBlock(worldProvider.getBlock(centerPos.x,centerPos.y,centerPos.z));
    if (!centerBlock.isAllowBlockAttachment()) {
      return false;
    }
    BlockPosition blockPos=selectedBlock.calcAdjacentBlockPos();
    Block adjBlock=BlockManager.getInstance().getBlock(worldProvider.getBlock(blockPos.x,blockPos.y,blockPos.z));
    if (adjBlock != null && !adjBlock.isInvisible() && !adjBlock.isSelectionRayThrough()) {
      return false;
    }
    Side attachmentSide=Side.inDirection(centerPos.x - blockPos.x,centerPos.y - blockPos.y,centerPos.z - blockPos.z);
    Vector3d attachDir=new Vector3d(centerPos.x - blockPos.x,centerPos.y - blockPos.y,centerPos.z - blockPos.z);
    Vector3d rawDirection=new Vector3d(_player.getViewingDirection());
    double dot=rawDirection.dot(attachDir);
    rawDirection.sub(new Vector3d(dot * attachDir.x,dot * attachDir.y,dot * attachDir.z));
    Side direction=Side.inDirection(rawDirection.x,rawDirection.y,rawDirection.z);
    Block block=type.getBlockFor(attachmentSide,direction);
    if (block == null)     return false;
    if (!block.isPenetrable()) {
      for (      AABB blockAABB : block.getColliders(blockPos.x,blockPos.y,blockPos.z)) {
        if (blockAABB.overlaps(_player.getAABB())) {
          return false;
        }
      }
    }
    placeBlock(blockPos,block.getId(),true);
    AudioManager.getInstance().playVaryingSound(""String_Node_Str"",0.6f,0.5f);
    return true;
  }
  return false;
}",0.9919459599896076
1270,"public void render(){
  super.render();
  glPushMatrix();
  glTranslatef(getPosition().x - _parent.getWorldProvider().getRenderingReferencePoint().x,getPosition().y - _parent.getWorldProvider().getRenderingReferencePoint().y,getPosition().z - _parent.getWorldProvider().getRenderingReferencePoint().z);
  glRotatef((float)_yaw,0f,1f,0f);
  TextureManager.getInstance().bindTexture(""String_Node_Str"");
  ShaderManager.getInstance().enableShader(""String_Node_Str"");
  int tick=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader(""String_Node_Str""),""String_Node_Str"");
  GL20.glUniform1f(tick,_parent.getTick());
  int cOffset=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader(""String_Node_Str""),""String_Node_Str"");
  GL20.glUniform4f(cOffset,COLORS[_randomColorId].x,COLORS[_randomColorId].y,COLORS[_randomColorId].z,1.0f);
  int light=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader(""String_Node_Str""),""String_Node_Str"");
  GL20.glUniform1f(light,calcLightValue());
  if (_displayListOuterBody == -1 || _displayListInnerBody == -1) {
    generateDisplayList();
  }
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  glPushMatrix();
  glScalef(_randomSize,_randomSize,_randomSize);
  glCallList(_displayListInnerBody);
  glCallList(_displayListOuterBody);
  glPopMatrix();
  ShaderManager.getInstance().enableShader(null);
  glPopMatrix();
}","public void render(){
  super.render();
  glPushMatrix();
  glTranslatef(getPosition().x - _parent.getWorldProvider().getRenderingReferencePoint().x,getPosition().y - _parent.getWorldProvider().getRenderingReferencePoint().y,getPosition().z - _parent.getWorldProvider().getRenderingReferencePoint().z);
  glRotatef((float)_yaw,0f,1f,0f);
  TextureManager.getInstance().bindTexture(""String_Node_Str"");
  ShaderManager.getInstance().enableShader(""String_Node_Str"");
  int tick=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader(""String_Node_Str""),""String_Node_Str"");
  GL20.glUniform1f(tick,_parent.getTick());
  int cOffset=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader(""String_Node_Str""),""String_Node_Str"");
  GL20.glUniform4f(cOffset,COLORS[_randomColorId].x,COLORS[_randomColorId].y,COLORS[_randomColorId].z,1.0f);
  int light=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader(""String_Node_Str""),""String_Node_Str"");
  GL20.glUniform1f(light,calcLightValue());
  if (_displayListOuterBody == -1 || _displayListInnerBody == -1) {
    generateDisplayList();
  }
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  glPushMatrix();
  glScalef(_randomSize,_randomSize,_randomSize);
  glCallList(_displayListInnerBody);
  glCallList(_displayListOuterBody);
  glPopMatrix();
  glDisable(GL_BLEND);
  ShaderManager.getInstance().enableShader(null);
  glPopMatrix();
}",0.9918871252204584
1271,"public void blockRemoved(Chunk chunk,BlockPosition pos){
  for (int i=0; i < 6; i++) {
    BlockPosition nBp=new BlockPosition(pos.x + (int)NEIGHBORS6[i].x,pos.y + (int)NEIGHBORS6[i].x,pos.z + (int)NEIGHBORS6[i].z);
    if (_parent.getBlock(nBp.x,nBp.y,nBp.z) == DIRT_TYPE) {
      addActiveBlock(nBp);
    }
  }
}","public void blockRemoved(Chunk chunk,BlockPosition pos){
  for (int i=0; i < 6; i++) {
    BlockPosition nBp=new BlockPosition(pos.x + (int)NEIGHBORS6[i].x,pos.y + (int)NEIGHBORS6[i].y,pos.z + (int)NEIGHBORS6[i].z);
    if (_parent.getBlock(nBp.x,nBp.y,nBp.z) == DIRT_TYPE) {
      addActiveBlock(nBp);
    }
  }
}",0.9968152866242038
1272,"public void blockPlaced(Chunk chunk,BlockPosition pos){
  if (_parent.getBlock(pos.x,pos.y,pos.z) == DIRT_TYPE) {
    addActiveBlock(pos);
  }
  for (int i=0; i < 6; i++) {
    BlockPosition nBp=new BlockPosition(pos.x + (int)NEIGHBORS6[i].x,pos.y + (int)NEIGHBORS6[i].x,pos.z + (int)NEIGHBORS6[i].z);
    if (_parent.getBlock(nBp.x,nBp.y,nBp.z) == DIRT_TYPE) {
      addActiveBlock(nBp);
    }
  }
}","public void blockPlaced(Chunk chunk,BlockPosition pos){
  if (_parent.getBlock(pos.x,pos.y,pos.z) == DIRT_TYPE) {
    addActiveBlock(pos);
  }
  for (int i=0; i < 6; i++) {
    BlockPosition nBp=new BlockPosition(pos.x + (int)NEIGHBORS6[i].x,pos.y + (int)NEIGHBORS6[i].y,pos.z + (int)NEIGHBORS6[i].z);
    if (_parent.getBlock(nBp.x,nBp.y,nBp.z) == DIRT_TYPE) {
      addActiveBlock(nBp);
    }
  }
}",0.9975
1273,"/** 
 * Renders the world.
 */
public void render(){
  if (_player == null)   return;
  if (!_player.isHeadUnderWater()) {
    _player.applyNormalizedModelViewMatrix();
    glDisable(GL_CULL_FACE);
    glDisable(GL_DEPTH_TEST);
    glBegin(GL_QUADS);
    Primitives.drawSkyBox(getDaylight());
    glEnd();
    glEnable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
  }
  _player.applyPlayerModelViewMatrix();
  renderSunMoon();
  if (!_player.isHeadUnderWater())   renderClouds();
  _player.render();
  ShaderManager.getInstance().enableShader(""String_Node_Str"");
  int daylight=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader(""String_Node_Str""),""String_Node_Str"");
  int swimmimg=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader(""String_Node_Str""),""String_Node_Str"");
  GL20.glUniform1f(daylight,(float)getDaylight());
  GL20.glUniform1i(swimmimg,_player.isHeadUnderWater() ? 1 : 0);
  ShaderManager.getInstance().enableShader(""String_Node_Str"");
  daylight=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader(""String_Node_Str""),""String_Node_Str"");
  GL20.glUniform1f(daylight,(float)getDaylight());
  ShaderManager.getInstance().enableShader(null);
  renderChunks();
  renderEntities();
}","/** 
 * Renders the world.
 */
public void render(){
  if (_player == null)   return;
  if (!_player.isHeadUnderWater()) {
    _player.applyNormalizedModelViewMatrix();
    glDisable(GL_CULL_FACE);
    glDisable(GL_DEPTH_TEST);
    glBegin(GL_QUADS);
    Primitives.drawSkyBox(getDaylight());
    glEnd();
    glEnable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
  }
  _player.applyPlayerModelViewMatrix();
  renderSunMoon();
  if (!_player.isHeadUnderWater())   renderClouds();
  _player.render();
  ShaderManager.getInstance().enableShader(""String_Node_Str"");
  int daylight=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader(""String_Node_Str""),""String_Node_Str"");
  int swimmimg=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader(""String_Node_Str""),""String_Node_Str"");
  GL20.glUniform1f(daylight,(float)getDaylight());
  GL20.glUniform1i(swimmimg,_player.isHeadUnderWater() ? 1 : 0);
  ShaderManager.getInstance().enableShader(""String_Node_Str"");
  daylight=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader(""String_Node_Str""),""String_Node_Str"");
  GL20.glUniform1f(daylight,(float)getDaylight());
  ShaderManager.getInstance().enableShader(null);
  renderEntities();
  renderChunks();
}",0.983753046303818
1274,"public void initGame(){
  _timerTicksPerSecond=Sys.getTimerResolution();
  _font1=new TrueTypeFont(new Font(""String_Node_Str"",Font.PLAIN,12),true);
  ShaderManager.getInstance();
  glEnable(GL_CULL_FACE);
  glEnable(GL_DEPTH_TEST);
  glDepthFunc(GL_LEQUAL);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  GL11.glHint(GL11.GL_PERSPECTIVE_CORRECTION_HINT,GL11.GL_NICEST);
  Chunk.init();
  World.init();
  _player=new Player();
  String worldSeed=Configuration.DEFAULT_SEED;
  if (worldSeed.length() == 0) {
    worldSeed=_rand.randomCharacterString(16);
  }
  initNewWorld(""String_Node_Str"",worldSeed);
}","public void initGame(){
  _timerTicksPerSecond=Sys.getTimerResolution();
  _font1=new TrueTypeFont(new Font(""String_Node_Str"",Font.PLAIN,12),true);
  ShaderManager.getInstance();
  glEnable(GL_CULL_FACE);
  glEnable(GL_DEPTH_TEST);
  glDepthFunc(GL_LEQUAL);
  glShadeModel(GL11.GL_SMOOTH);
  GL11.glHint(GL11.GL_PERSPECTIVE_CORRECTION_HINT,GL11.GL_NICEST);
  Chunk.init();
  World.init();
  _player=new Player();
  String worldSeed=Configuration.DEFAULT_SEED;
  if (worldSeed.length() == 0) {
    worldSeed=_rand.randomCharacterString(16);
  }
  initNewWorld(""String_Node_Str"",worldSeed);
}",0.9433333333333334
1275,"@Override public void update(){
  if (_newMesh != null) {
    if (_newMesh.isGenerated()) {
      ChunkMesh oldMesh=_activeMesh;
      if (oldMesh != null)       oldMesh.dispose();
      _activeMesh=_newMesh;
      _newMesh=null;
    }
  }
}","@Override public void update(){
  if (_newMesh != null) {
    for (    Chunk nc : loadOrCreateNeighbors()) {
      if (nc.isDirty()) {
        return;
      }
    }
    if (_newMesh.isGenerated()) {
      ChunkMesh oldMesh=_activeMesh;
      if (oldMesh != null)       oldMesh.dispose();
      _activeMesh=_newMesh;
      _newMesh=null;
    }
  }
}",0.8183361629881154
1276,"private void generateBlockVertices(ChunkMesh mesh,int x,int y,int z){
  byte block=_chunk.getBlock(x,y,z);
  RENDER_TYPE renderType=RENDER_TYPE.TRANS;
  if (!Block.getBlockForType(block).isBlockTypeTranslucent()) {
    renderType=RENDER_TYPE.OPAQUE;
  }
  if (Block.getBlockForType(block).isBlockInvisible() || Block.getBlockForType(block).isBlockBillboard()) {
    return;
  }
  boolean drawFront, drawBack, drawLeft, drawRight, drawTop, drawBottom;
  byte blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x),_chunk.getBlockWorldPosY(y + 1),_chunk.getBlockWorldPosZ(z));
  drawTop=isSideVisibleForBlockTypes(blockToCheck,block);
  blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x),_chunk.getBlockWorldPosY(y),_chunk.getBlockWorldPosZ(z - 1));
  drawFront=isSideVisibleForBlockTypes(blockToCheck,block);
  blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x),_chunk.getBlockWorldPosY(y),_chunk.getBlockWorldPosZ(z + 1));
  drawBack=isSideVisibleForBlockTypes(blockToCheck,block);
  blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x - 1),_chunk.getBlockWorldPosY(y),_chunk.getBlockWorldPosZ(z));
  drawLeft=isSideVisibleForBlockTypes(blockToCheck,block);
  blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x + 1),_chunk.getBlockWorldPosY(y),_chunk.getBlockWorldPosZ(z));
  drawRight=isSideVisibleForBlockTypes(blockToCheck,block);
  blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x),_chunk.getBlockWorldPosY(y - 1),_chunk.getBlockWorldPosZ(z));
  drawBottom=isSideVisibleForBlockTypes(blockToCheck,block);
  Block.BLOCK_FORM blockForm=Block.getBlockForType(block).getBlockForm();
  if (blockForm == Block.BLOCK_FORM.LOWERED_BOCK) {
    blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x),_chunk.getBlockWorldPosY(y - 1),_chunk.getBlockWorldPosZ(z - 1));
    drawFront=isSideVisibleForBlockTypes(blockToCheck,block) || drawFront;
    blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x),_chunk.getBlockWorldPosY(y - 1),_chunk.getBlockWorldPosZ(z + 1));
    drawBack=isSideVisibleForBlockTypes(blockToCheck,block) || drawBack;
    blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x - 1),_chunk.getBlockWorldPosY(y - 1),_chunk.getBlockWorldPosZ(z));
    drawLeft=isSideVisibleForBlockTypes(blockToCheck,block) || drawLeft;
    blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x + 1),_chunk.getBlockWorldPosY(y - 1),_chunk.getBlockWorldPosZ(z));
    drawRight=isSideVisibleForBlockTypes(blockToCheck,block) || drawRight;
  }
  if (drawTop) {
    Vector3f p1=VectorPool.getVector(-0.5f,0.5f,0.5f);
    Vector3f p2=VectorPool.getVector(0.5f,0.5f,0.5f);
    Vector3f p3=VectorPool.getVector(0.5f,0.5f,-0.5f);
    Vector3f p4=VectorPool.getVector(-0.5f,0.5f,-0.5f);
    Vector3f norm=VectorPool.getVector(0,1,0);
    Vector4f colorOffset=Block.getBlockForType(block).getColorOffsetFor(Block.SIDE.TOP);
    Vector3f texOffset=VectorPool.getVector(Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.TOP).x,Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.TOP).y,0f);
    generateVerticesForBlockSide(mesh,x,y,z,p1,p2,p3,p4,norm,colorOffset,texOffset,renderType,blockForm);
    VectorPool.putVector(p1);
    VectorPool.putVector(p2);
    VectorPool.putVector(p3);
    VectorPool.putVector(p4);
    VectorPool.putVector(norm);
  }
  if (drawFront) {
    Vector3f p1=VectorPool.getVector(-0.5f,0.5f,-0.5f);
    Vector3f p2=VectorPool.getVector(0.5f,0.5f,-0.5f);
    Vector3f p3=VectorPool.getVector(0.5f,-0.5f,-0.5f);
    Vector3f p4=VectorPool.getVector(-0.5f,-0.5f,-0.5f);
    Vector3f norm=VectorPool.getVector(0,0,-1);
    Vector4f colorOffset=Block.getBlockForType(block).getColorOffsetFor(Block.SIDE.FRONT);
    Vector3f texOffset=VectorPool.getVector(Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.FRONT).x,Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.FRONT).y,0f);
    generateVerticesForBlockSide(mesh,x,y,z,p1,p2,p3,p4,norm,colorOffset,texOffset,renderType,blockForm);
    VectorPool.putVector(p1);
    VectorPool.putVector(p2);
    VectorPool.putVector(p3);
    VectorPool.putVector(p4);
    VectorPool.putVector(norm);
  }
  if (drawBack) {
    Vector3f p1=VectorPool.getVector(-0.5f,-0.5f,0.5f);
    Vector3f p2=VectorPool.getVector(0.5f,-0.5f,0.5f);
    Vector3f p3=VectorPool.getVector(0.5f,0.5f,0.5f);
    Vector3f p4=VectorPool.getVector(-0.5f,0.5f,0.5f);
    Vector3f norm=VectorPool.getVector(0,0,1);
    Vector4f colorOffset=Block.getBlockForType(block).getColorOffsetFor(Block.SIDE.BACK);
    Vector3f texOffset=VectorPool.getVector(Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.BACK).x,Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.BACK).y,0f);
    generateVerticesForBlockSide(mesh,x,y,z,p1,p2,p3,p4,norm,colorOffset,texOffset,renderType,blockForm);
    VectorPool.putVector(p1);
    VectorPool.putVector(p2);
    VectorPool.putVector(p3);
    VectorPool.putVector(p4);
    VectorPool.putVector(norm);
  }
  if (drawLeft) {
    Vector3f p1=VectorPool.getVector(-0.5f,-0.5f,-0.5f);
    Vector3f p2=VectorPool.getVector(-0.5f,-0.5f,0.5f);
    Vector3f p3=VectorPool.getVector(-0.5f,0.5f,0.5f);
    Vector3f p4=VectorPool.getVector(-0.5f,0.5f,-0.5f);
    Vector3f norm=VectorPool.getVector(-1,0,0);
    Vector4f colorOffset=Block.getBlockForType(block).getColorOffsetFor(Block.SIDE.LEFT);
    Vector3f texOffset=VectorPool.getVector(Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.LEFT).x,Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.LEFT).y,0f);
    generateVerticesForBlockSide(mesh,x,y,z,p1,p2,p3,p4,norm,colorOffset,texOffset,renderType,blockForm);
    VectorPool.putVector(p1);
    VectorPool.putVector(p2);
    VectorPool.putVector(p3);
    VectorPool.putVector(p4);
    VectorPool.putVector(norm);
  }
  if (drawRight) {
    Vector3f p1=VectorPool.getVector(0.5f,0.5f,-0.5f);
    Vector3f p2=VectorPool.getVector(0.5f,0.5f,0.5f);
    Vector3f p3=VectorPool.getVector(0.5f,-0.5f,0.5f);
    Vector3f p4=VectorPool.getVector(0.5f,-0.5f,-0.5f);
    Vector3f norm=VectorPool.getVector(1,0,0);
    Vector4f colorOffset=Block.getBlockForType(block).getColorOffsetFor(Block.SIDE.RIGHT);
    Vector3f texOffset=VectorPool.getVector(Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.RIGHT).x,Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.RIGHT).y,0f);
    generateVerticesForBlockSide(mesh,x,y,z,p1,p2,p3,p4,norm,colorOffset,texOffset,renderType,blockForm);
    VectorPool.putVector(p1);
    VectorPool.putVector(p2);
    VectorPool.putVector(p3);
    VectorPool.putVector(p4);
    VectorPool.putVector(norm);
  }
  if (drawBottom) {
    Vector3f p1=VectorPool.getVector(-0.5f,-0.5f,-0.5f);
    Vector3f p2=VectorPool.getVector(0.5f,-0.5f,-0.5f);
    Vector3f p3=VectorPool.getVector(0.5f,-0.5f,0.5f);
    Vector3f p4=VectorPool.getVector(-0.5f,-0.5f,0.5f);
    Vector3f norm=VectorPool.getVector(0,-1,0);
    Vector4f colorOffset=Block.getBlockForType(block).getColorOffsetFor(Block.SIDE.BOTTOM);
    Vector3f texOffset=VectorPool.getVector(Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.BOTTOM).x,Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.BOTTOM).y,0f);
    generateVerticesForBlockSide(mesh,x,y,z,p1,p2,p3,p4,norm,colorOffset,texOffset,renderType,blockForm);
    VectorPool.putVector(p1);
    VectorPool.putVector(p2);
    VectorPool.putVector(p3);
    VectorPool.putVector(p4);
    VectorPool.putVector(norm);
  }
}","private void generateBlockVertices(ChunkMesh mesh,int x,int y,int z){
  byte block=_chunk.getBlock(x,y,z);
  RENDER_TYPE renderType=RENDER_TYPE.TRANS;
  if (!Block.getBlockForType(block).isBlockTypeTranslucent()) {
    renderType=RENDER_TYPE.OPAQUE;
  }
  if (Block.getBlockForType(block).isBlockInvisible() || Block.getBlockForType(block).isBlockBillboard()) {
    return;
  }
  boolean drawFront, drawBack, drawLeft, drawRight, drawTop, drawBottom;
  byte blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x),_chunk.getBlockWorldPosY(y + 1),_chunk.getBlockWorldPosZ(z));
  drawTop=isSideVisibleForBlockTypes(blockToCheck,block);
  blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x),_chunk.getBlockWorldPosY(y),_chunk.getBlockWorldPosZ(z - 1));
  drawFront=isSideVisibleForBlockTypes(blockToCheck,block);
  blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x),_chunk.getBlockWorldPosY(y),_chunk.getBlockWorldPosZ(z + 1));
  drawBack=isSideVisibleForBlockTypes(blockToCheck,block);
  blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x - 1),_chunk.getBlockWorldPosY(y),_chunk.getBlockWorldPosZ(z));
  drawLeft=isSideVisibleForBlockTypes(blockToCheck,block);
  blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x + 1),_chunk.getBlockWorldPosY(y),_chunk.getBlockWorldPosZ(z));
  drawRight=isSideVisibleForBlockTypes(blockToCheck,block);
  if (y > 0) {
    blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x),_chunk.getBlockWorldPosY(y - 1),_chunk.getBlockWorldPosZ(z));
    drawBottom=isSideVisibleForBlockTypes(blockToCheck,block);
  }
 else {
    drawBottom=false;
  }
  Block.BLOCK_FORM blockForm=Block.getBlockForType(block).getBlockForm();
  if (blockForm == Block.BLOCK_FORM.LOWERED_BOCK) {
    blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x),_chunk.getBlockWorldPosY(y - 1),_chunk.getBlockWorldPosZ(z - 1));
    drawFront=isSideVisibleForBlockTypes(blockToCheck,block) || drawFront;
    blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x),_chunk.getBlockWorldPosY(y - 1),_chunk.getBlockWorldPosZ(z + 1));
    drawBack=isSideVisibleForBlockTypes(blockToCheck,block) || drawBack;
    blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x - 1),_chunk.getBlockWorldPosY(y - 1),_chunk.getBlockWorldPosZ(z));
    drawLeft=isSideVisibleForBlockTypes(blockToCheck,block) || drawLeft;
    blockToCheck=_chunk.getParent().getBlock(_chunk.getBlockWorldPosX(x + 1),_chunk.getBlockWorldPosY(y - 1),_chunk.getBlockWorldPosZ(z));
    drawRight=isSideVisibleForBlockTypes(blockToCheck,block) || drawRight;
  }
  if (drawTop) {
    Vector3f p1=VectorPool.getVector(-0.5f,0.5f,0.5f);
    Vector3f p2=VectorPool.getVector(0.5f,0.5f,0.5f);
    Vector3f p3=VectorPool.getVector(0.5f,0.5f,-0.5f);
    Vector3f p4=VectorPool.getVector(-0.5f,0.5f,-0.5f);
    Vector3f norm=VectorPool.getVector(0,1,0);
    Vector4f colorOffset=Block.getBlockForType(block).getColorOffsetFor(Block.SIDE.TOP);
    Vector3f texOffset=VectorPool.getVector(Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.TOP).x,Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.TOP).y,0f);
    generateVerticesForBlockSide(mesh,x,y,z,p1,p2,p3,p4,norm,colorOffset,texOffset,renderType,blockForm);
    VectorPool.putVector(p1);
    VectorPool.putVector(p2);
    VectorPool.putVector(p3);
    VectorPool.putVector(p4);
    VectorPool.putVector(norm);
  }
  if (drawFront) {
    Vector3f p1=VectorPool.getVector(-0.5f,0.5f,-0.5f);
    Vector3f p2=VectorPool.getVector(0.5f,0.5f,-0.5f);
    Vector3f p3=VectorPool.getVector(0.5f,-0.5f,-0.5f);
    Vector3f p4=VectorPool.getVector(-0.5f,-0.5f,-0.5f);
    Vector3f norm=VectorPool.getVector(0,0,-1);
    Vector4f colorOffset=Block.getBlockForType(block).getColorOffsetFor(Block.SIDE.FRONT);
    Vector3f texOffset=VectorPool.getVector(Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.FRONT).x,Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.FRONT).y,0f);
    generateVerticesForBlockSide(mesh,x,y,z,p1,p2,p3,p4,norm,colorOffset,texOffset,renderType,blockForm);
    VectorPool.putVector(p1);
    VectorPool.putVector(p2);
    VectorPool.putVector(p3);
    VectorPool.putVector(p4);
    VectorPool.putVector(norm);
  }
  if (drawBack) {
    Vector3f p1=VectorPool.getVector(-0.5f,-0.5f,0.5f);
    Vector3f p2=VectorPool.getVector(0.5f,-0.5f,0.5f);
    Vector3f p3=VectorPool.getVector(0.5f,0.5f,0.5f);
    Vector3f p4=VectorPool.getVector(-0.5f,0.5f,0.5f);
    Vector3f norm=VectorPool.getVector(0,0,1);
    Vector4f colorOffset=Block.getBlockForType(block).getColorOffsetFor(Block.SIDE.BACK);
    Vector3f texOffset=VectorPool.getVector(Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.BACK).x,Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.BACK).y,0f);
    generateVerticesForBlockSide(mesh,x,y,z,p1,p2,p3,p4,norm,colorOffset,texOffset,renderType,blockForm);
    VectorPool.putVector(p1);
    VectorPool.putVector(p2);
    VectorPool.putVector(p3);
    VectorPool.putVector(p4);
    VectorPool.putVector(norm);
  }
  if (drawLeft) {
    Vector3f p1=VectorPool.getVector(-0.5f,-0.5f,-0.5f);
    Vector3f p2=VectorPool.getVector(-0.5f,-0.5f,0.5f);
    Vector3f p3=VectorPool.getVector(-0.5f,0.5f,0.5f);
    Vector3f p4=VectorPool.getVector(-0.5f,0.5f,-0.5f);
    Vector3f norm=VectorPool.getVector(-1,0,0);
    Vector4f colorOffset=Block.getBlockForType(block).getColorOffsetFor(Block.SIDE.LEFT);
    Vector3f texOffset=VectorPool.getVector(Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.LEFT).x,Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.LEFT).y,0f);
    generateVerticesForBlockSide(mesh,x,y,z,p1,p2,p3,p4,norm,colorOffset,texOffset,renderType,blockForm);
    VectorPool.putVector(p1);
    VectorPool.putVector(p2);
    VectorPool.putVector(p3);
    VectorPool.putVector(p4);
    VectorPool.putVector(norm);
  }
  if (drawRight) {
    Vector3f p1=VectorPool.getVector(0.5f,0.5f,-0.5f);
    Vector3f p2=VectorPool.getVector(0.5f,0.5f,0.5f);
    Vector3f p3=VectorPool.getVector(0.5f,-0.5f,0.5f);
    Vector3f p4=VectorPool.getVector(0.5f,-0.5f,-0.5f);
    Vector3f norm=VectorPool.getVector(1,0,0);
    Vector4f colorOffset=Block.getBlockForType(block).getColorOffsetFor(Block.SIDE.RIGHT);
    Vector3f texOffset=VectorPool.getVector(Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.RIGHT).x,Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.RIGHT).y,0f);
    generateVerticesForBlockSide(mesh,x,y,z,p1,p2,p3,p4,norm,colorOffset,texOffset,renderType,blockForm);
    VectorPool.putVector(p1);
    VectorPool.putVector(p2);
    VectorPool.putVector(p3);
    VectorPool.putVector(p4);
    VectorPool.putVector(norm);
  }
  if (drawBottom) {
    Vector3f p1=VectorPool.getVector(-0.5f,-0.5f,-0.5f);
    Vector3f p2=VectorPool.getVector(0.5f,-0.5f,-0.5f);
    Vector3f p3=VectorPool.getVector(0.5f,-0.5f,0.5f);
    Vector3f p4=VectorPool.getVector(-0.5f,-0.5f,0.5f);
    Vector3f norm=VectorPool.getVector(0,-1,0);
    Vector4f colorOffset=Block.getBlockForType(block).getColorOffsetFor(Block.SIDE.BOTTOM);
    Vector3f texOffset=VectorPool.getVector(Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.BOTTOM).x,Block.getBlockForType(block).getTextureOffsetFor(Block.SIDE.BOTTOM).y,0f);
    generateVerticesForBlockSide(mesh,x,y,z,p1,p2,p3,p4,norm,colorOffset,texOffset,renderType,blockForm);
    VectorPool.putVector(p1);
    VectorPool.putVector(p2);
    VectorPool.putVector(p3);
    VectorPool.putVector(p4);
    VectorPool.putVector(norm);
  }
}",0.9962408494361276
1277,"/** 
 * TODO
 */
public void updateDisplayLists(){
  if (!_displayListUpdates.isEmpty()) {
    Chunk c=_displayListUpdates.removeFirst();
    c.generateVBOs();
  }
}","/** 
 * TODO
 */
public void updateDisplayLists(){
  while (!_displayListUpdates.isEmpty()) {
    Chunk c=_displayListUpdates.removeFirst();
    c.generateVBOs();
  }
}",0.984984984984985
1278,"/** 
 * Renders the HUD on the screen.
 */
private void renderHUD(){
  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();
  glOrtho(0,Display.getDisplayMode().getWidth(),Display.getDisplayMode().getHeight(),0,-1,1);
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
  glDisable(GL_DEPTH_TEST);
  glEnable(GL_BLEND);
  if (Configuration.getSettingBoolean(""String_Node_Str"")) {
    _font1.drawString(4,4,String.format(""String_Node_Str"",Configuration.GAME_TITLE,_meanFps,_memoryUsage,Color.white));
    _font1.drawString(4,22,String.format(""String_Node_Str"",_player,Color.white));
    _font1.drawString(4,38,String.format(""String_Node_Str"",_world,Color.white));
    _font1.drawString(4,54,String.format(""String_Node_Str"",Chunk.getVertexArrayUpdateCount(),Color.white));
  }
  if (_pauseGame) {
    _font1.drawString(4,Display.getDisplayMode().getHeight() - 16 - 4,String.format(""String_Node_Str"",_consoleInput),Color.red);
  }
  glColor3f(1f,1f,1f);
  glLineWidth(2f);
  if (Configuration.getSettingBoolean(""String_Node_Str"")) {
    glBegin(GL_LINES);
    glVertex2d(Display.getDisplayMode().getWidth() / 2f - 8f,Display.getDisplayMode().getHeight() / 2f);
    glVertex2d(Display.getDisplayMode().getWidth() / 2f + 8f,Display.getDisplayMode().getHeight() / 2f);
    glVertex2d(Display.getDisplayMode().getWidth() / 2f,Display.getDisplayMode().getHeight() / 2f - 8f);
    glVertex2d(Display.getDisplayMode().getWidth() / 2f,Display.getDisplayMode().getHeight() / 2f + 8f);
    glEnd();
  }
  glDisable(GL_BLEND);
  glEnable(GL_DEPTH_TEST);
  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();
}","/** 
 * Renders the HUD on the screen.
 */
private void renderHUD(){
  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();
  glOrtho(0,Display.getDisplayMode().getWidth(),Display.getDisplayMode().getHeight(),0,-1,1);
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
  glDisable(GL_DEPTH_TEST);
  glEnable(GL_BLEND);
  if (Configuration.getSettingBoolean(""String_Node_Str"")) {
    glColor3f(1f,1f,1f);
    glLineWidth(2f);
    glBegin(GL_LINES);
    glVertex2d(Display.getDisplayMode().getWidth() / 2f - 8f,Display.getDisplayMode().getHeight() / 2f);
    glVertex2d(Display.getDisplayMode().getWidth() / 2f + 8f,Display.getDisplayMode().getHeight() / 2f);
    glVertex2d(Display.getDisplayMode().getWidth() / 2f,Display.getDisplayMode().getHeight() / 2f - 8f);
    glVertex2d(Display.getDisplayMode().getWidth() / 2f,Display.getDisplayMode().getHeight() / 2f + 8f);
    glEnd();
  }
  if (Configuration.getSettingBoolean(""String_Node_Str"")) {
    _font1.drawString(4,4,String.format(""String_Node_Str"",Configuration.GAME_TITLE,_meanFps,_memoryUsage,Color.white));
    _font1.drawString(4,22,String.format(""String_Node_Str"",_player,Color.white));
    _font1.drawString(4,38,String.format(""String_Node_Str"",_world,Color.white));
    _font1.drawString(4,54,String.format(""String_Node_Str"",Chunk.getVertexArrayUpdateCount(),Color.white));
  }
  if (_pauseGame) {
    _font1.drawString(4,Display.getDisplayMode().getHeight() - 16 - 4,String.format(""String_Node_Str"",_consoleInput),Color.red);
  }
  glDisable(GL_BLEND);
  glEnable(GL_DEPTH_TEST);
  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();
}",0.6618705035971223
1279,"/** 
 * @param c
 * @param x
 * @param y
 * @param z 
 */
protected void generateGrassAndFlowers(Chunk c,int x,int y,int z){
  float grassDens=calcGrassDensity(c.getBlockWorldPosX(x),c.getBlockWorldPosY(y),c.getBlockWorldPosZ(z));
  if (c.getBlock(x,y,z) == 0x1 && grassDens > 0.0) {
    double rand=_rand.standNormalDistrDouble();
    if (rand > -1 && rand < 1) {
      if (c.canBlockSeeTheSky(x,y + 1,z)) {
        c.setBlock(x,y + 1,z,(byte)0xB);
      }
    }
 else {
      if (c.canBlockSeeTheSky(x,y + 1,z)) {
        c.setBlock(x,y + 1,z,(byte)0xC);
      }
    }
    if (_rand.standNormalDistrDouble() < -2) {
      if (_rand.randomBoolean()) {
        if (c.canBlockSeeTheSky(x,y + 1,z)) {
          c.setBlock(x,y + 1,z,(byte)0x9);
        }
      }
 else {
        if (c.canBlockSeeTheSky(x,y + 1,z)) {
          c.setBlock(x,y + 1,z,(byte)0xA);
        }
      }
    }
  }
}","/** 
 * @param c
 * @param x
 * @param y
 * @param z 
 */
protected void generateGrassAndFlowers(Chunk c,int x,int y,int z){
  if (c.getBlock(x,y,z) == 0x1) {
    float grassDens=calcGrassDensity(c.getBlockWorldPosX(x),c.getBlockWorldPosY(y),c.getBlockWorldPosZ(z));
    if (grassDens > 0.0) {
      double rand=_rand.standNormalDistrDouble();
      if (rand > -1 && rand < 1) {
        if (c.canBlockSeeTheSky(x,y + 1,z)) {
          c.setBlock(x,y + 1,z,(byte)0xB);
        }
      }
 else {
        if (c.canBlockSeeTheSky(x,y + 1,z)) {
          c.setBlock(x,y + 1,z,(byte)0xC);
        }
      }
      if (_rand.standNormalDistrDouble() < -2) {
        if (_rand.randomBoolean()) {
          if (c.canBlockSeeTheSky(x,y + 1,z)) {
            c.setBlock(x,y + 1,z,(byte)0x9);
          }
        }
 else {
          if (c.canBlockSeeTheSky(x,y + 1,z)) {
            c.setBlock(x,y + 1,z,(byte)0xA);
          }
        }
      }
    }
  }
}",0.3846994535519126
1280,"/** 
 * @param c
 * @param x
 * @param y
 * @param z 
 */
protected void generateTree(Chunk c,int x,int y,int z){
  if (c.getParent().isBlockSurrounded(c.getBlockWorldPosX(x),c.getBlockWorldPosY(y + 1),c.getBlockWorldPosZ(z)) || !c.canBlockSeeTheSky(x,y + 1,z)) {
    return;
  }
  float forestDens=calcForestDensity(c.getBlockWorldPosX(x),c.getBlockWorldPosY(y),c.getBlockWorldPosZ(z));
  if (c.getBlock(x,y,z) == 0x1 && y > 32) {
    double r=_rand.standNormalDistrDouble();
    if (forestDens < 0.01) {
      r+=3f;
    }
    if (r > -0.05 && r < 0.05) {
      double r2=_rand.standNormalDistrDouble();
      if (r2 > -2 && r2 < -1) {
        c.setBlock(x,y + 1,z,(byte)0x0);
        c.getParent().getGeneratorPineTree().generate(c.getBlockWorldPosX(x),c.getBlockWorldPosY((int)y) + 1,c.getBlockWorldPosZ(z),false);
      }
 else       if (r2 > -3 && r2 < -2) {
        c.setBlock(x,y + 1,z,(byte)0x0);
        c.getParent().getGeneratorFirTree().generate(c.getBlockWorldPosX(x),c.getBlockWorldPosY((int)y) + 1,c.getBlockWorldPosZ(z),false);
      }
 else {
        c.setBlock(x,y + 1,z,(byte)0x0);
        c.getParent().getGeneratorTree().generate(c.getBlockWorldPosX(x),c.getBlockWorldPosY((int)y) + 1,c.getBlockWorldPosZ(z),false);
      }
    }
  }
}","/** 
 * @param c
 * @param x
 * @param y
 * @param z 
 */
protected void generateTree(Chunk c,int x,int y,int z){
  if (c.getParent().isBlockSurrounded(c.getBlockWorldPosX(x),c.getBlockWorldPosY(y + 1),c.getBlockWorldPosZ(z)) || !c.canBlockSeeTheSky(x,y + 1,z)) {
    return;
  }
  if (c.getBlock(x,y,z) == 0x1 && y > 32) {
    float forestDens=calcForestDensity(c.getBlockWorldPosX(x),c.getBlockWorldPosY(y),c.getBlockWorldPosZ(z));
    double r=_rand.standNormalDistrDouble();
    if (forestDens < 0.01) {
      r+=3f;
    }
    if (r > -0.05 && r < 0.05) {
      double r2=_rand.standNormalDistrDouble();
      if (r2 > -2 && r2 < -1) {
        c.setBlock(x,y + 1,z,(byte)0x0);
        c.getParent().getGeneratorPineTree().generate(c.getBlockWorldPosX(x),c.getBlockWorldPosY((int)y) + 1,c.getBlockWorldPosZ(z),false);
      }
 else       if (r2 > -3 && r2 < -2) {
        c.setBlock(x,y + 1,z,(byte)0x0);
        c.getParent().getGeneratorFirTree().generate(c.getBlockWorldPosX(x),c.getBlockWorldPosY((int)y) + 1,c.getBlockWorldPosZ(z),false);
      }
 else {
        c.setBlock(x,y + 1,z,(byte)0x0);
        c.getParent().getGeneratorTree().generate(c.getBlockWorldPosX(x),c.getBlockWorldPosY((int)y) + 1,c.getBlockWorldPosZ(z),false);
      }
    }
  }
}",0.9133545310015898
1281,"/** 
 * Returns true if the block side is ajdacent to a translucent block or an air block. NOTE: Air has to be handled separatly. Otherwise the water surface would not be displayed due to the tessellation process.
 */
private boolean isSideVisibleForBlockTypes(byte blockToCheck,byte currentBlock){
  return blockToCheck == 0x0 || blockToCheck == 0x6 || (Block.getBlockForType(blockToCheck).isBlockTypeTranslucent() && !Block.getBlockForType(currentBlock).isBlockTypeTranslucent());
}","/** 
 * Returns true if the block side is ajdacent to a translucent block or an air block. NOTE: Air and leafs have to be handled separatly. Otherwise the water surface would not be displayed due to the tessellation process.
 */
private boolean isSideVisibleForBlockTypes(byte blockToCheck,byte currentBlock){
  return blockToCheck == 0x0 || blockToCheck == 0x6 || Block.getBlockForType(blockToCheck).isBlockBillboard() || (Block.getBlockForType(blockToCheck).isBlockTypeTranslucent() && !Block.getBlockForType(currentBlock).isBlockTypeTranslucent());
}",0.927675988428158
1282,"/** 
 */
public static void loadDefaults(){
  _settingsBoolean.put(""String_Node_Str"",true);
  _settingsBoolean.put(""String_Node_Str"",false);
  _settingsBoolean.put(""String_Node_Str"",true);
  _settingsBoolean.put(""String_Node_Str"",true);
  _settingsBoolean.put(""String_Node_Str"",false);
  _settingsBoolean.put(""String_Node_Str"",false);
  _settingsNumeric.put(""String_Node_Str"",10f);
  _settingsNumeric.put(""String_Node_Str"",64f);
  _settingsNumeric.put(""String_Node_Str"",1.5f);
  _settingsNumeric.put(""String_Node_Str"",1.2f);
  _settingsNumeric.put(""String_Node_Str"",0.8f);
  _settingsNumeric.put(""String_Node_Str"",0.05f);
  _settingsNumeric.put(""String_Node_Str"",0.05f);
}","/** 
 */
public static void loadDefaults(){
  _settingsBoolean.put(""String_Node_Str"",true);
  _settingsBoolean.put(""String_Node_Str"",false);
  _settingsBoolean.put(""String_Node_Str"",true);
  _settingsBoolean.put(""String_Node_Str"",true);
  _settingsBoolean.put(""String_Node_Str"",false);
  _settingsBoolean.put(""String_Node_Str"",false);
  _settingsNumeric.put(""String_Node_Str"",10f);
  _settingsNumeric.put(""String_Node_Str"",64f);
  _settingsNumeric.put(""String_Node_Str"",1.5f);
  _settingsNumeric.put(""String_Node_Str"",1.6f);
  _settingsNumeric.put(""String_Node_Str"",0.8f);
  _settingsNumeric.put(""String_Node_Str"",0.05f);
  _settingsNumeric.put(""String_Node_Str"",0.05f);
}",0.9985119047619048
1283,"/** 
 * Sets the light value at the given position.
 * @param x The X-coordinate
 * @param y The Y-coordinate
 * @param z The Z-coordinate
 * @param intens The light intensity value
 */
public void setSunlight(int x,int y,int z,byte intens){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=loadOrCreateChunk(calcChunkPosX(x),calcChunkPosZ(z));
    c.setSunlight(blockPosX,blockPosY,blockPosZ,intens);
  }
 catch (  Exception e) {
  }
}","/** 
 * Sets the light value at the given position.
 * @param x The X-coordinate
 * @param y The Y-coordinate
 * @param z The Z-coordinate
 * @param intens The light intensity value
 */
public void setSunlight(int x,int y,int z,byte intens){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=loadOrCreateChunk(calcChunkPosX(x),calcChunkPosZ(z));
    c.setSunlight(blockPosX,y,blockPosZ,intens);
  }
 catch (  Exception e) {
  }
}",0.8865836791147994
1284,"/** 
 * Places a block of a specific type at a given position.
 * @param x The X-coordinate
 * @param y The Y-coordinate
 * @param z The Z-coordinate
 * @param type The type of the block to set
 * @param update If set the affected chunk is queued for updating
 * @param overwrite  
 */
public final void setBlock(int x,int y,int z,byte type,boolean update,boolean overwrite){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=loadOrCreateChunk(calcChunkPosX(x),calcChunkPosZ(z));
    if (overwrite || c.getBlock(blockPosX,blockPosY,blockPosZ) == 0) {
      c.setBlock(blockPosX,blockPosY,blockPosZ,type);
      if (update) {
        byte oldValue=getLight(x,y,z);
        c.calcSunlightAtLocalPos(blockPosX,blockPosZ,true);
        c.refreshLightAtLocalPos(blockPosX,blockPosY,blockPosZ);
        byte newValue=getLight(x,y,z);
        if (newValue > oldValue) {
          c.spreadLight(blockPosX,blockPosY,blockPosZ,newValue);
        }
 else         if (newValue < oldValue) {
        }
        queueChunkForUpdate(c);
      }
    }
  }
 catch (  Exception e) {
  }
}","/** 
 * Places a block of a specific type at a given position.
 * @param x The X-coordinate
 * @param y The Y-coordinate
 * @param z The Z-coordinate
 * @param type The type of the block to set
 * @param update If set the affected chunk is queued for updating
 * @param overwrite  
 */
public final void setBlock(int x,int y,int z,byte type,boolean update,boolean overwrite){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=loadOrCreateChunk(calcChunkPosX(x),calcChunkPosZ(z));
    if (overwrite || c.getBlock(blockPosX,y,blockPosZ) == 0) {
      c.setBlock(blockPosX,y,blockPosZ,type);
      if (update) {
        byte oldValue=getLight(x,y,z);
        c.calcSunlightAtLocalPos(blockPosX,blockPosZ,true);
        c.refreshLightAtLocalPos(blockPosX,y,blockPosZ);
        byte newValue=getLight(x,y,z);
        if (newValue > oldValue) {
          c.spreadLight(blockPosX,y,blockPosZ,newValue);
        }
 else         if (newValue < oldValue) {
        }
        queueChunkForUpdate(c);
      }
    }
  }
 catch (  Exception e) {
  }
}",0.8987341772151899
1285,"/** 
 * Initializes a new world for the single player mode.
 * @param title The title/description of the world
 * @param seed The seed string used to genrate the terrain
 * @param p The player
 */
public World(String title,String seed,Player p){
  this._player=p;
  _chunks=new Chunk[(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x][(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y][(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.z];
  _title=title;
  if (_title.equals(""String_Node_Str"")) {
    _title=seed;
  }
  _generatorTerrain=new ChunkGeneratorTerrain(seed);
  _generatorForest=new ChunkGeneratorForest(seed);
  _generatorTree=new ObjectGeneratorTree(this,seed);
  _generatorPineTree=new ObjectGeneratorPineTree(this,seed);
  for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
    for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.z; z++) {
      Chunk c=loadOrCreateChunk(x,z);
      _chunks[x][0][z]=c;
      queueChunkForUpdate(c);
    }
  }
  _updateThread=new Thread(new Runnable(){
    @Override public void run(){
      while (true) {
        if (!_updateThreadAlive) {
          return;
        }
        if (!_updatingEnabled) {
synchronized (_updateThread) {
            try {
              _updateThread.wait();
            }
 catch (            InterruptedException ex) {
            }
          }
        }
        long timeStart=System.currentTimeMillis();
        timeStart=System.currentTimeMillis();
        if (!_chunkUpdateNormal.isEmpty()) {
          Chunk[] chunks=_chunkUpdateNormal.toArray(new Chunk[0]);
          double dist=Float.MAX_VALUE;
          int index=-1;
          for (int i=0; i < chunks.length; i++) {
            Chunk c=chunks[i];
            double tDist=c.calcDistanceToPlayer();
            if (tDist <= dist) {
              dist=tDist;
              index=i;
            }
          }
          if (index >= 0) {
            Chunk c=(Chunk)chunks[index];
            processChunk(c);
          }
          _statUpdateDuration+=System.currentTimeMillis() - timeStart;
          _statUpdateDuration/=2;
        }
        updateInfWorld();
        updateDaytime();
        generateNewChunks();
        try {
          Thread.sleep(15);
        }
 catch (        InterruptedException ex) {
          Logger.getLogger(World.class.getName()).log(Level.SEVERE,null,ex);
        }
      }
    }
  }
);
}","/** 
 * Initializes a new world for the single player mode.
 * @param title The title/description of the world
 * @param seed The seed string used to genrate the terrain
 * @param p The player
 */
public World(String title,String seed,Player p){
  this._player=p;
  _chunks=new Chunk[(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x][(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y];
  _title=title;
  if (_title.equals(""String_Node_Str"")) {
    _title=seed;
  }
  _generatorTerrain=new ChunkGeneratorTerrain(seed);
  _generatorForest=new ChunkGeneratorForest(seed);
  _generatorTree=new ObjectGeneratorTree(this,seed);
  _generatorPineTree=new ObjectGeneratorPineTree(this,seed);
  for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
    for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.y; z++) {
      Chunk c=loadOrCreateChunk(x,z);
      _chunks[x][z]=c;
      queueChunkForUpdate(c);
    }
  }
  _updateThread=new Thread(new Runnable(){
    @Override public void run(){
      while (true) {
        if (!_updateThreadAlive) {
          return;
        }
        if (!_updatingEnabled) {
synchronized (_updateThread) {
            try {
              _updateThread.wait();
            }
 catch (            InterruptedException ex) {
            }
          }
        }
        long timeStart=System.currentTimeMillis();
        timeStart=System.currentTimeMillis();
        if (!_chunkUpdateNormal.isEmpty()) {
          Chunk[] chunks=_chunkUpdateNormal.toArray(new Chunk[0]);
          double dist=Float.MAX_VALUE;
          int index=-1;
          for (int i=0; i < chunks.length; i++) {
            Chunk c=chunks[i];
            double tDist=c.calcDistanceToPlayer();
            if (tDist <= dist) {
              dist=tDist;
              index=i;
            }
          }
          if (index >= 0) {
            Chunk c=(Chunk)chunks[index];
            processChunk(c);
          }
          _statUpdateDuration+=System.currentTimeMillis() - timeStart;
          _statUpdateDuration/=2;
        }
        updateInfWorld();
        updateDaytime();
        generateNewChunks();
        try {
          Thread.sleep(15);
        }
 catch (        InterruptedException ex) {
          Logger.getLogger(World.class.getName()).log(Level.SEVERE,null,ex);
        }
      }
    }
  }
);
}",0.8424190800681431
1286,"/** 
 * Recursive light calculation. Too slow!
 * @param x
 * @param y
 * @param z
 * @param lightValue
 * @param depth  
 */
public void spreadLight(int x,int y,int z,byte lightValue,int depth){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=loadOrCreateChunk(calcChunkPosX(x),calcChunkPosZ(z));
    c.spreadLight(blockPosX,blockPosY,blockPosZ,lightValue,depth);
  }
 catch (  Exception e) {
  }
}","/** 
 * Recursive light calculation. Too slow!
 * @param x
 * @param y
 * @param z
 * @param lightValue
 * @param depth  
 */
public void spreadLight(int x,int y,int z,byte lightValue,int depth){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=loadOrCreateChunk(calcChunkPosX(x),calcChunkPosZ(z));
    c.spreadLight(blockPosX,y,blockPosZ,lightValue,depth);
  }
 catch (  Exception e) {
  }
}",0.8238719068413392
1287,"/** 
 * Recursive light calculation. Too weird.
 * @param x
 * @param y
 * @param z
 * @param oldValue
 * @param depth  
 */
public void unspreadLight(int x,int y,int z,byte oldValue,int depth){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=loadOrCreateChunk(calcChunkPosX(x),calcChunkPosZ(z));
    c.unspreadLight(blockPosX,blockPosY,blockPosZ,oldValue,depth);
  }
 catch (  Exception e) {
  }
}","/** 
 * Recursive light calculation. Too weird.
 * @param x
 * @param y
 * @param z
 * @param oldValue
 * @param depth  
 */
public void unspreadLight(int x,int y,int z,byte oldValue,int depth){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=loadOrCreateChunk(calcChunkPosX(x),calcChunkPosZ(z));
    c.unspreadLight(blockPosX,y,blockPosZ,oldValue,depth);
  }
 catch (  Exception e) {
  }
}",0.6647230320699709
1288,"/** 
 * Loads a specified chunk from the cache or queues a new chunk for generation. NOTE: This method ALWAYS returns a valid chunk since new chunks are generated if none of the present chunks fit.
 * @param x X-coordinate of the chunk
 * @param z Z-coordinate of the chunk
 * @return The chunk
 */
public Chunk loadOrCreateChunk(int x,int z){
  if (x < 0 || z < 0) {
    return null;
  }
  Chunk c=getChunk(x,0,z);
  if (c != null) {
    if (c.getPosition().x != x || c.getPosition().y != 0 || c.getPosition().z != z) {
      c=_chunkCache.get(Helper.getInstance().cantorize(x,z));
    }
  }
  if (c != null) {
    return c;
  }
 else {
  }
  if (_chunkCache.size() >= 1024) {
    ArrayList<Chunk> sortedChunks=null;
    sortedChunks=new ArrayList<Chunk>(_chunkCache.values());
    Collections.sort(sortedChunks);
    Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"");
    for (int i=0; i < 32; i++) {
      int indexToDelete=sortedChunks.size() - i;
      if (indexToDelete >= 0 && indexToDelete < sortedChunks.size()) {
        Chunk cc=sortedChunks.get(indexToDelete);
        _chunkCache.remove(Helper.getInstance().cantorize((int)cc.getPosition().x,(int)cc.getPosition().z));
        _chunkUpdateNormal.remove(cc);
        cc.dispose();
      }
    }
    Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"");
  }
  c=prepareNewChunk(x,z);
  _chunkCache.put(Helper.getInstance().cantorize(x,z),c);
  return c;
}","/** 
 * Loads a specified chunk from the cache or queues a new chunk for generation. NOTE: This method ALWAYS returns a valid chunk since new chunks are generated if none of the present chunks fit.
 * @param x X-coordinate of the chunk
 * @param z Z-coordinate of the chunk
 * @return The chunk
 */
public Chunk loadOrCreateChunk(int x,int z){
  if (x < 0 || z < 0) {
    return null;
  }
  Chunk c=getChunk(x,z);
  if (c != null) {
    if (c.getPosition().x != x || c.getPosition().y != 0 || c.getPosition().z != z) {
      c=_chunkCache.get(Helper.getInstance().cantorize(x,z));
    }
  }
  if (c != null) {
    return c;
  }
 else {
  }
  if (_chunkCache.size() >= 1024) {
    ArrayList<Chunk> sortedChunks=null;
    sortedChunks=new ArrayList<Chunk>(_chunkCache.values());
    Collections.sort(sortedChunks);
    Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"");
    for (int i=0; i < 32; i++) {
      int indexToDelete=sortedChunks.size() - i;
      if (indexToDelete >= 0 && indexToDelete < sortedChunks.size()) {
        Chunk cc=sortedChunks.get(indexToDelete);
        _chunkCache.remove(Helper.getInstance().cantorize((int)cc.getPosition().x,(int)cc.getPosition().z));
        _chunkUpdateNormal.remove(cc);
        cc.dispose();
      }
    }
    Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"");
  }
  c=prepareNewChunk(x,z);
  _chunkCache.put(Helper.getInstance().cantorize(x,z),c);
  return c;
}",0.9993188010899182
1289,"/** 
 * Returns the internal position of a block within a chunk.
 * @param x1 The Z-coordinate of the block within the world
 * @param x2 The Z-coordinate of the chunk within the world
 * @return The Z-coordinate of the block within the chunk
 */
private int calcBlockPosZ(int z1,int z2){
  z1=z1 % ((int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.z * (int)Configuration.CHUNK_DIMENSIONS.z);
  return (z1 - (z2 * (int)Configuration.CHUNK_DIMENSIONS.z));
}","/** 
 * Returns the internal position of a block within a chunk.
 * @param x1 The Z-coordinate of the block within the world
 * @param x2 The Z-coordinate of the chunk within the world
 * @return The Z-coordinate of the block within the chunk
 */
private int calcBlockPosZ(int z1,int z2){
  z1=z1 % ((int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y * (int)Configuration.CHUNK_DIMENSIONS.z);
  return (z1 - (z2 * (int)Configuration.CHUNK_DIMENSIONS.z));
}",0.9977924944812362
1290,"/** 
 * Returns the light value at the given position.
 * @param x The X-coordinate
 * @param y The Y-coordinate
 * @param z The Z-coordinate
 * @return The light value
 */
public final byte getLight(int x,int y,int z){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=loadOrCreateChunk(calcChunkPosX(x),calcChunkPosZ(z));
    return c.getLight(blockPosX,blockPosY,blockPosZ);
  }
 catch (  Exception e) {
  }
  return -1;
}","/** 
 * Returns the light value at the given position.
 * @param x The X-coordinate
 * @param y The Y-coordinate
 * @param z The Z-coordinate
 * @return The light value
 */
public final byte getLight(int x,int y,int z){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=loadOrCreateChunk(calcChunkPosX(x),calcChunkPosZ(z));
    return c.getLight(blockPosX,y,blockPosZ);
  }
 catch (  Exception e) {
  }
  return -1;
}",0.8973277074542897
1291,"/** 
 * Updates the displayed chunks according to the players position and queues new chunks for updating.
 */
private void updateInfWorld(){
  for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
    for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.z; z++) {
      Chunk c=getChunk(x,0,z);
      if (c != null) {
        Vector3f pos=new Vector3f(x,0,z);
        int multZ=(int)calcPlayerChunkOffsetZ() / (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.z + 1;
        if (z < calcPlayerChunkOffsetZ() % Configuration.VIEWING_DISTANCE_IN_CHUNKS.z) {
          pos.z+=Configuration.VIEWING_DISTANCE_IN_CHUNKS.z * multZ;
        }
 else {
          pos.z+=Configuration.VIEWING_DISTANCE_IN_CHUNKS.z * (multZ - 1);
        }
        int multX=(int)calcPlayerChunkOffsetX() / (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x + 1;
        if (x < calcPlayerChunkOffsetX() % Configuration.VIEWING_DISTANCE_IN_CHUNKS.x) {
          pos.x+=Configuration.VIEWING_DISTANCE_IN_CHUNKS.x * multX;
        }
 else {
          pos.x+=Configuration.VIEWING_DISTANCE_IN_CHUNKS.x * (multX - 1);
        }
        if (c.getPosition().x != pos.x || c.getPosition().z != pos.z) {
          _chunkUpdateNormal.remove(c);
          c=loadOrCreateChunk((int)pos.x,(int)pos.z);
          _chunks[x][0][z]=c;
          queueChunkForUpdate(c);
        }
      }
    }
  }
}","/** 
 * Updates the displayed chunks according to the players position and queues new chunks for updating.
 */
private void updateInfWorld(){
  for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
    for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.y; z++) {
      Chunk c=getChunk(x,z);
      if (c != null) {
        Vector3f pos=new Vector3f(x,0,z);
        int multZ=(int)calcPlayerChunkOffsetZ() / (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y + 1;
        if (z < calcPlayerChunkOffsetZ() % Configuration.VIEWING_DISTANCE_IN_CHUNKS.y) {
          pos.z+=Configuration.VIEWING_DISTANCE_IN_CHUNKS.y * multZ;
        }
 else {
          pos.z+=Configuration.VIEWING_DISTANCE_IN_CHUNKS.y * (multZ - 1);
        }
        int multX=(int)calcPlayerChunkOffsetX() / (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x + 1;
        if (x < calcPlayerChunkOffsetX() % Configuration.VIEWING_DISTANCE_IN_CHUNKS.x) {
          pos.x+=Configuration.VIEWING_DISTANCE_IN_CHUNKS.x * multX;
        }
 else {
          pos.x+=Configuration.VIEWING_DISTANCE_IN_CHUNKS.x * (multX - 1);
        }
        if (c.getPosition().x != pos.x || c.getPosition().z != pos.z) {
          _chunkUpdateNormal.remove(c);
          c=loadOrCreateChunk((int)pos.x,(int)pos.z);
          _chunks[x][z]=c;
          queueChunkForUpdate(c);
        }
      }
    }
  }
}",0.9484083424807904
1292,"/** 
 * Calculates the intersection of a given ray originating from a specified point with a block. Returns a list of intersections ordered by the distance to the player.
 * @param x
 * @param y
 * @param z
 * @param origin
 * @param ray
 * @return Distance-ordered list of ray-face-intersections
 */
public ArrayList<RayFaceIntersection> rayBlockIntersection(int x,int y,int z,Vector3f origin,Vector3f ray){
  if (getBlock(x,y,z) == 0) {
    return null;
  }
  ArrayList<RayFaceIntersection> result=new ArrayList<RayFaceIntersection>();
  Vector3f[] vertices=verticesForBlockAt(x,y,z);
  Vector3f blockPos=new Vector3f(x,y,z);
  RayFaceIntersection is=rayFaceIntersection(blockPos,vertices[0],vertices[3],vertices[2],origin,ray);
  if (is != null) {
    result.add(is);
  }
  is=rayFaceIntersection(blockPos,vertices[4],vertices[5],vertices[6],origin,ray);
  if (is != null) {
    result.add(is);
  }
  is=rayFaceIntersection(blockPos,vertices[0],vertices[4],vertices[7],origin,ray);
  if (is != null) {
    result.add(is);
  }
  is=rayFaceIntersection(blockPos,vertices[1],vertices[2],vertices[6],origin,ray);
  if (is != null) {
    result.add(is);
  }
  is=rayFaceIntersection(blockPos,vertices[3],vertices[7],vertices[6],origin,ray);
  if (is != null) {
    result.add(is);
  }
  is=rayFaceIntersection(blockPos,vertices[0],vertices[1],vertices[5],origin,ray);
  if (is != null) {
    result.add(is);
  }
  Collections.sort(result);
  return result;
}","/** 
 * Calculates the intersection of a given ray originating from a specified point with a block. Returns a list of intersections ordered by the distance to the player.
 * @param x
 * @param y
 * @param z
 * @param origin
 * @param ray
 * @return Distance-ordered list of ray-face-intersections
 */
public ArrayList<RayFaceIntersection> rayBlockIntersection(int x,int y,int z,Vector3f origin,Vector3f ray){
  if (Block.getBlock(getBlock(x,y,z)).isBlockInvisible()) {
    return null;
  }
  ArrayList<RayFaceIntersection> result=new ArrayList<RayFaceIntersection>();
  Vector3f[] vertices=verticesForBlockAt(x,y,z);
  Vector3f blockPos=new Vector3f(x,y,z);
  RayFaceIntersection is=rayFaceIntersection(blockPos,vertices[0],vertices[3],vertices[2],origin,ray);
  if (is != null) {
    result.add(is);
  }
  is=rayFaceIntersection(blockPos,vertices[4],vertices[5],vertices[6],origin,ray);
  if (is != null) {
    result.add(is);
  }
  is=rayFaceIntersection(blockPos,vertices[0],vertices[4],vertices[7],origin,ray);
  if (is != null) {
    result.add(is);
  }
  is=rayFaceIntersection(blockPos,vertices[1],vertices[2],vertices[6],origin,ray);
  if (is != null) {
    result.add(is);
  }
  is=rayFaceIntersection(blockPos,vertices[3],vertices[7],vertices[6],origin,ray);
  if (is != null) {
    result.add(is);
  }
  is=rayFaceIntersection(blockPos,vertices[0],vertices[1],vertices[5],origin,ray);
  if (is != null) {
    result.add(is);
  }
  Collections.sort(result);
  return result;
}",0.9864038069340584
1293,"/** 
 * @param c
 * @return
 */
public boolean isChunkVisible(Chunk c){
  if (c.getPosition().x >= calcChunkPosX((int)_player.getPosition().x) - Configuration.VIEWING_DISTANCE_IN_CHUNKS.x / 2 && c.getPosition().x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x / 2 + calcChunkPosX((int)_player.getPosition().x)) {
    if (c.getPosition().z >= calcChunkPosZ((int)_player.getPosition().z) - Configuration.VIEWING_DISTANCE_IN_CHUNKS.z / 2 && c.getPosition().z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.z / 2 + calcChunkPosZ((int)_player.getPosition().z)) {
      return true;
    }
  }
  return false;
}","/** 
 * @param c
 * @return
 */
public boolean isChunkVisible(Chunk c){
  if (c.getPosition().x >= calcChunkPosX((int)_player.getPosition().x) - Configuration.VIEWING_DISTANCE_IN_CHUNKS.x / 2 && c.getPosition().x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x / 2 + calcChunkPosX((int)_player.getPosition().x)) {
    if (c.getPosition().z >= calcChunkPosZ((int)_player.getPosition().z) - Configuration.VIEWING_DISTANCE_IN_CHUNKS.y / 2 && c.getPosition().z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.y / 2 + calcChunkPosZ((int)_player.getPosition().z)) {
      return true;
    }
  }
  return false;
}",0.9163879598662208
1294,"/** 
 * Renders the world.
 */
@Override public void render(){
  glPushMatrix();
  glTranslatef(_player.getPosition().x,Configuration.VIEWING_DISTANCE_IN_CHUNKS.y * Configuration.CHUNK_DIMENSIONS.y * 0.75f,Configuration.VIEWING_DISTANCE_IN_CHUNKS.z * Configuration.CHUNK_DIMENSIONS.z + _player.getPosition().z);
  glDisable(GL_FOG);
  glColor4f(1f,1f,1f,1.0f);
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  glEnable(GL_TEXTURE_2D);
  if (isDaytime()) {
    _textureSun.bind();
  }
 else {
    _textureMoon.bind();
  }
  glBegin(GL_QUADS);
  glTexCoord2f(0.0f,0.0f);
  glVertex3f(-Configuration.SUN_SIZE,Configuration.SUN_SIZE,-Configuration.SUN_SIZE);
  glTexCoord2f(1.f,0.0f);
  glVertex3f(Configuration.SUN_SIZE,Configuration.SUN_SIZE,-Configuration.SUN_SIZE);
  glTexCoord2f(1.f,1.0f);
  glVertex3f(Configuration.SUN_SIZE,-Configuration.SUN_SIZE,-Configuration.SUN_SIZE);
  glTexCoord2f(0.f,1.0f);
  glVertex3f(-Configuration.SUN_SIZE,-Configuration.SUN_SIZE,-Configuration.SUN_SIZE);
  glEnd();
  glDisable(GL_TEXTURE_2D);
  glDisable(GL_BLEND);
  glEnable(GL_FOG);
  glPopMatrix();
  for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
    for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.z; z++) {
      Chunk c=getChunk(x,0,z);
      if (c != null) {
        c.render(false);
      }
    }
  }
  for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
    for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.z; z++) {
      Chunk c=getChunk(x,0,z);
      if (c != null) {
        c.render(true);
      }
    }
  }
}","/** 
 * Renders the world.
 */
@Override public void render(){
  glPushMatrix();
  glTranslatef(_player.getPosition().x,Configuration.VIEWING_DISTANCE_IN_CHUNKS.y * Configuration.CHUNK_DIMENSIONS.y * 0.75f,Configuration.CHUNK_DIMENSIONS.z + _player.getPosition().z);
  glDisable(GL_FOG);
  glColor4f(1f,1f,1f,1.0f);
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  glEnable(GL_TEXTURE_2D);
  if (isDaytime()) {
    _textureSun.bind();
  }
 else {
    _textureMoon.bind();
  }
  glBegin(GL_QUADS);
  glTexCoord2f(0.0f,0.0f);
  glVertex3f(-Configuration.SUN_SIZE,Configuration.SUN_SIZE,-Configuration.SUN_SIZE);
  glTexCoord2f(1.f,0.0f);
  glVertex3f(Configuration.SUN_SIZE,Configuration.SUN_SIZE,-Configuration.SUN_SIZE);
  glTexCoord2f(1.f,1.0f);
  glVertex3f(Configuration.SUN_SIZE,-Configuration.SUN_SIZE,-Configuration.SUN_SIZE);
  glTexCoord2f(0.f,1.0f);
  glVertex3f(-Configuration.SUN_SIZE,-Configuration.SUN_SIZE,-Configuration.SUN_SIZE);
  glEnd();
  glDisable(GL_TEXTURE_2D);
  glDisable(GL_BLEND);
  glEnable(GL_FOG);
  glPopMatrix();
  for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
    for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.y; z++) {
      Chunk c=getChunk(x,z);
      if (c != null) {
        c.render(false);
      }
    }
  }
  for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
    for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.y; z++) {
      Chunk c=getChunk(x,z);
      if (c != null) {
        c.render(true);
      }
    }
  }
}",0.983169260082566
1295,"/** 
 * Returns the block at the given position.
 * @param x The X-coordinate
 * @param y The Y-coordinate
 * @param z The Z-coordinate
 * @return The type of the block
 */
public final byte getBlock(int x,int y,int z){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=loadOrCreateChunk(calcChunkPosX(x),calcChunkPosZ(z));
    return c.getBlock(blockPosX,blockPosY,blockPosZ);
  }
 catch (  Exception e) {
  }
  return -1;
}","/** 
 * Returns the block at the given position.
 * @param x The X-coordinate
 * @param y The Y-coordinate
 * @param z The Z-coordinate
 * @return The type of the block
 */
public final byte getBlock(int x,int y,int z){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=loadOrCreateChunk(calcChunkPosX(x),calcChunkPosZ(z));
    return c.getBlock(blockPosX,y,blockPosZ);
  }
 catch (  Exception e) {
  }
  return -1;
}",0.8973277074542897
1296,"/** 
 * Queues all displayed chunks for updating.
 */
public void updateAllChunks(){
  for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
    for (int y=0; y < Configuration.VIEWING_DISTANCE_IN_CHUNKS.y; y++) {
      for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.z; z++) {
        Chunk c=getChunk(x,y,z);
        queueChunkForUpdate(c);
      }
    }
  }
}","/** 
 * Queues all displayed chunks for updating.
 */
public void updateAllChunks(){
  for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
    for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.y; z++) {
      Chunk c=getChunk(x,z);
      queueChunkForUpdate(c);
    }
  }
}",0.7132459970887919
1297,"/** 
 * Returns the chunk at the given position.
 * @param x The X-coordinate
 * @param y The Y-coordinate
 * @param z The Z-coordinate
 * @return The chunk
 */
public final Chunk getChunk(int x,int y,int z){
  Chunk c=null;
  try {
    c=_chunks[x % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x][y % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y][z % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.z];
  }
 catch (  Exception e) {
  }
  return c;
}","/** 
 * Returns the chunk at the given position.
 * @param x The X-coordinate
 * @param y The Y-coordinate
 * @param z The Z-coordinate
 * @return The chunk
 */
public final Chunk getChunk(int x,int z){
  Chunk c=null;
  try {
    c=_chunks[x % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x][z % (int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y];
  }
 catch (  Exception e) {
  }
  return c;
}",0.8288075560802833
1298,"/** 
 * Returns the cave density for the base terrain.
 * @param x
 * @param y
 * @param z
 * @return
 */
protected float calcForestDensity(float x,float y,float z){
  float result=0.0f;
  result+=_pGen1.noise(0.004f * x,0.004f * y,0.004f * z);
  return result;
}","/** 
 * Returns the cave density for the base terrain.
 * @param x
 * @param y
 * @param z
 * @return
 */
protected float calcForestDensity(float x,float y,float z){
  float result=0.0f;
  result+=_pGen3.noise(0.04f * x,0.04f * y,0.04f * z);
  return result;
}",0.9904397705544932
1299,"/** 
 * @param x
 * @param y
 * @param z
 * @return
 */
protected float calcGrassDensity(float x,float y,float z){
  float result=0.0f;
  result+=_pGen1.noise(0.8f * x,0.8f * y,0.8f * z);
  return result;
}","/** 
 * @param x
 * @param y
 * @param z
 * @return
 */
protected float calcGrassDensity(float x,float y,float z){
  float result=0.0f;
  result+=_pGen3.noise(0.8f * x,0.8f * y,0.8f * z);
  return result;
}",0.9951456310679612
1300,"/** 
 * Returns the spawning point of the player. TODO: Should not determine the spawning point randomly.
 * @return The coordinates of the spawning point
 */
public Vector3f calcPlayerOrigin(){
  return new Vector3f(Configuration.CHUNK_DIMENSIONS.x * Configuration.VIEWING_DISTANCE_IN_CHUNKS.x / 2,127,(Configuration.CHUNK_DIMENSIONS.z * Configuration.VIEWING_DISTANCE_IN_CHUNKS.z) / 2);
}","/** 
 * Returns the spawning point of the player. TODO: Should not determine the spawning point randomly.
 * @return The coordinates of the spawning point
 */
public Vector3f calcPlayerOrigin(){
  return new Vector3f(Configuration.CHUNK_DIMENSIONS.x * Configuration.VIEWING_DISTANCE_IN_CHUNKS.x / 2,127,(Configuration.CHUNK_DIMENSIONS.z * Configuration.VIEWING_DISTANCE_IN_CHUNKS.y) / 2);
}",0.9974358974358974
1301,"/** 
 * Saves this chunk to the disk.
 * @return 
 */
public boolean writeChunkToDisk(){
  if (_fresh) {
    return false;
  }
  ByteBuffer output=BufferUtils.createByteBuffer((int)Configuration.CHUNK_DIMENSIONS.x * (int)Configuration.CHUNK_DIMENSIONS.y * (int)Configuration.CHUNK_DIMENSIONS.z* 3);
  File dir1=new File(String.format(""String_Node_Str"",_parent.getTitle()));
  if (!dir1.exists()) {
    dir1.mkdir();
  }
  File dir2=new File(String.format(""String_Node_Str"",_parent.getTitle()));
  if (!dir2.exists()) {
    dir2.mkdir();
  }
  File f=new File(String.format(""String_Node_Str"",_parent.getTitle(),Helper.getInstance().cantorize((int)_position.x,(int)_position.z)));
  for (int x=0; x < Configuration.CHUNK_DIMENSIONS.x; x++) {
    for (int y=0; y < Configuration.CHUNK_DIMENSIONS.y; y++) {
      for (int z=0; z < Configuration.CHUNK_DIMENSIONS.z; z++) {
        output.put(_blocks[x][y][z]);
        output.put(_sunlight[x][y][z]);
      }
    }
  }
  output.rewind();
  try {
    FileOutputStream oS=new FileOutputStream(f);
    FileChannel c=oS.getChannel();
    c.write(output);
    oS.close();
    return true;
  }
 catch (  FileNotFoundException ex) {
    Logger.getLogger(Chunk.class.getName()).log(Level.SEVERE,null,ex);
  }
catch (  IOException ex) {
    Logger.getLogger(Chunk.class.getName()).log(Level.SEVERE,null,ex);
  }
  return false;
}","/** 
 * Saves this chunk to the disk.
 * @return 
 */
public boolean writeChunkToDisk(){
  if (_fresh || _lightDirty) {
    return false;
  }
  ByteBuffer output=BufferUtils.createByteBuffer((int)Configuration.CHUNK_DIMENSIONS.x * (int)Configuration.CHUNK_DIMENSIONS.y * (int)Configuration.CHUNK_DIMENSIONS.z* 3);
  File dir1=new File(String.format(""String_Node_Str"",_parent.getTitle()));
  if (!dir1.exists()) {
    dir1.mkdir();
  }
  File dir2=new File(String.format(""String_Node_Str"",_parent.getTitle()));
  if (!dir2.exists()) {
    dir2.mkdir();
  }
  File f=new File(String.format(""String_Node_Str"",_parent.getTitle(),Helper.getInstance().cantorize((int)_position.x,(int)_position.z)));
  for (int x=0; x < Configuration.CHUNK_DIMENSIONS.x; x++) {
    for (int y=0; y < Configuration.CHUNK_DIMENSIONS.y; y++) {
      for (int z=0; z < Configuration.CHUNK_DIMENSIONS.z; z++) {
        output.put(_blocks[x][y][z]);
        output.put(_sunlight[x][y][z]);
      }
    }
  }
  output.rewind();
  try {
    FileOutputStream oS=new FileOutputStream(f);
    FileChannel c=oS.getChannel();
    c.write(output);
    oS.close();
    return true;
  }
 catch (  FileNotFoundException ex) {
    Logger.getLogger(Chunk.class.getName()).log(Level.SEVERE,null,ex);
  }
catch (  IOException ex) {
    Logger.getLogger(Chunk.class.getName()).log(Level.SEVERE,null,ex);
  }
  return false;
}",0.994535519125683
1302,"/** 
 * Starts the render loop. The application can be terminated by pressing the ESCAPE key.
 */
private void start(){
  _logger.log(Level.INFO,""String_Node_Str"");
  _lastLoopTime=Helper.getInstance().getTime();
  while (_runGame) {
    Display.sync(120);
    long delta=Helper.getInstance().getTime() - _lastLoopTime;
    _lastLoopTime=Helper.getInstance().getTime();
    _lastFpsTime+=delta;
    _fps++;
    if (_lastFpsTime >= 1000) {
      _lastFpsTime=0;
      _meanFps+=_fps;
      _meanFps/=2;
      _fps=0;
    }
    processKeyboardInput();
    processMouseInput();
    if (!_showDebugConsole) {
      update(delta);
    }
    render();
    Display.update();
  }
  Display.destroy();
}","/** 
 * Starts the render loop. The application can be terminated by pressing the ESCAPE key.
 */
private void start(){
  _logger.log(Level.INFO,""String_Node_Str"");
  _lastLoopTime=Helper.getInstance().getTime();
  while (_runGame) {
    Display.sync(60);
    long delta=Helper.getInstance().getTime() - _lastLoopTime;
    _lastLoopTime=Helper.getInstance().getTime();
    _lastFpsTime+=delta;
    _fps++;
    if (_lastFpsTime >= 1000) {
      _lastFpsTime=0;
      _meanFps+=_fps;
      _meanFps/=2;
      _fps=0;
    }
    processKeyboardInput();
    processMouseInput();
    if (!_showDebugConsole) {
      update(delta);
    }
    render();
    Display.update();
  }
  Display.destroy();
}",0.9978370583994232
1303,"/** 
 * Populates the chunk (e.g. placement of trees etc.). TODO: Much to simple and boring
 */
public void populate(){
  for (int y=0; y < Configuration.CHUNK_DIMENSIONS.y; y++) {
    for (int x=0; x < Configuration.CHUNK_DIMENSIONS.x; x++) {
      for (int z=0; z < Configuration.CHUNK_DIMENSIONS.z; z++) {
        float dens=calcForestDensity(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z));
        if (dens > 0.25 && dens < 0.6f && getBlock(x,y,z) == 0x1 && y > 32) {
          _parent.generateTree(getBlockWorldPosX(x),getBlockWorldPosY((int)y) + 1,getBlockWorldPosZ(z),false);
          return;
        }
 else         if (dens >= 0.6f && getBlock(x,y,z) == 0x1 && y > 32) {
          _parent.generatePineTree(getBlockWorldPosX(x),getBlockWorldPosY((int)y) + 1,getBlockWorldPosZ(z),false);
          return;
        }
      }
    }
  }
}","/** 
 * Populates the chunk (e.g. placement of trees etc.). TODO: Much to simple and boring :-(
 */
public void populate(){
  for (int y=0; y < Configuration.CHUNK_DIMENSIONS.y; y++) {
    for (int x=0; x < Configuration.CHUNK_DIMENSIONS.x; x++) {
      for (int z=0; z < Configuration.CHUNK_DIMENSIONS.z; z++) {
        float dens=calcForestDensity(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z));
        if (dens > 0.25 && dens < 0.6f && getBlock(x,y,z) == 0x1 && y > 32) {
          _parent.generateTree(getBlockWorldPosX(x),getBlockWorldPosY((int)y) + 1,getBlockWorldPosZ(z),false);
          return;
        }
 else         if (dens >= 0.6f && getBlock(x,y,z) == 0x1 && y > 32) {
          _parent.generatePineTree(getBlockWorldPosX(x),getBlockWorldPosY((int)y) + 1,getBlockWorldPosZ(z),false);
          return;
        }
      }
    }
  }
}",0.9976798143851509
1304,"/** 
 * Calculates a intersection with the face of a block defined by 3 points.
 * @param blockPos The position of the block to intersect with
 * @param v0 Point 1
 * @param v1 Point 2
 * @param v2 Point 3
 * @param origin Origin of the intersection ray
 * @param ray Direction of the intersection ray
 * @return Ray-face-intersection
 */
private RayFaceIntersection rayFaceIntersection(Vector3f blockPos,Vector3f v0,Vector3f v1,Vector3f v2,Vector3f origin,Vector3f ray){
  Vector3f a=Vector3f.sub(v1,v0,null);
  Vector3f b=Vector3f.sub(v2,v0,null);
  Vector3f norm=Vector3f.cross(a,b,null);
  float d=-(norm.x * v0.x + norm.y * v0.y + norm.z * v0.z);
  float t=-(norm.x * origin.x + norm.y * origin.y + norm.z * origin.z + d) / (Vector3f.dot(ray,norm));
  Vector3f intersectPoint=new Vector3f(ray.x * t,ray.y * t,ray.z * t);
  Vector3f.add(intersectPoint,origin,intersectPoint);
  if (intersectPoint.x >= v0.x && intersectPoint.x <= v2.x && intersectPoint.y >= v0.y && intersectPoint.y <= v2.y && intersectPoint.z >= v0.z && intersectPoint.z <= v2.z) {
    return new RayFaceIntersection(blockPos,v0,v1,v2,d,t,origin,ray,intersectPoint);
  }
  return null;
}","/** 
 * Calculates a intersection with the face of a block defined by 3 points.
 * @param blockPos The position of the block to intersect with
 * @param v0 Point 1
 * @param v1 Point 2
 * @param v2 Point 3
 * @param origin Origin of the intersection ray
 * @param ray Direction of the intersection ray
 * @return Ray-face-intersection
 */
private RayFaceIntersection rayFaceIntersection(Vector3f blockPos,Vector3f v0,Vector3f v1,Vector3f v2,Vector3f origin,Vector3f ray){
  Vector3f a=Vector3f.sub(v1,v0,null);
  Vector3f b=Vector3f.sub(v2,v0,null);
  Vector3f norm=Vector3f.cross(a,b,null);
  float d=-(norm.x * v0.x + norm.y * v0.y + norm.z * v0.z);
  float t=-(norm.x * origin.x + norm.y * origin.y + norm.z * origin.z + d) / (Vector3f.dot(ray,norm));
  if (t < 0) {
    return null;
  }
  Vector3f intersectPoint=new Vector3f(ray.x * t,ray.y * t,ray.z * t);
  Vector3f.add(intersectPoint,origin,intersectPoint);
  if (intersectPoint.x >= v0.x && intersectPoint.x <= v2.x && intersectPoint.y >= v0.y && intersectPoint.y <= v2.y && intersectPoint.z >= v0.z && intersectPoint.z <= v2.z) {
    return new RayFaceIntersection(blockPos,v0,v1,v2,d,t,origin,ray,intersectPoint);
  }
  return null;
}",0.9847068819031436
1305,"/** 
 * Updates the daytime of the world. A day in Blockmania has 12 minutes.
 */
private void updateDaytime(){
  if (Helper.getInstance().getTime() - lastDaytimeMeasurement >= 30000) {
    _daytime=(short)((_daytime + 1) % 24);
    lastDaytimeMeasurement=Helper.getInstance().getTime();
    Logger.getLogger(World.class.getName()).log(Level.INFO,""String_Node_Str"",_daytime);
    byte oldDaylight=_daylight;
switch (_daytime) {
case 18:
      _daylight=(byte)(0.8f * Configuration.MAX_LIGHT);
    break;
case 20:
  _daylight=(byte)(0.6f * Configuration.MAX_LIGHT);
break;
case 21:
_daylight=(byte)(0.4f * Configuration.MAX_LIGHT);
break;
case 22:
_daylight=(byte)(0.3f * Configuration.MAX_LIGHT);
break;
case 23:
_daylight=(byte)(0.2f * Configuration.MAX_LIGHT);
break;
case 5:
_daylight=(byte)(0.3f * Configuration.MAX_LIGHT);
break;
case 6:
_daylight=(byte)(0.6f * Configuration.MAX_LIGHT);
break;
case 7:
_daylight=(byte)(0.8f * Configuration.MAX_LIGHT);
break;
case 8:
_daylight=Configuration.MAX_LIGHT;
break;
}
if (_daylight != oldDaylight) {
synchronized (_chunkCache) {
for (int key : _chunkCache.keySet()) {
_chunkCache.get(key)._dirty=true;
}
}
for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.z; z++) {
Chunk c=_chunks[x][0][z];
queueChunkForUpdate(c,0);
}
}
}
}
}","/** 
 * Updates the daytime of the world. A day in Blockmania has 12 minutes.
 */
private void updateDaytime(){
  if (Helper.getInstance().getTime() - lastDaytimeMeasurement >= 30000) {
    _daytime=(short)((_daytime + 1) % 24);
    lastDaytimeMeasurement=Helper.getInstance().getTime();
    Logger.getLogger(World.class.getName()).log(Level.INFO,""String_Node_Str"",_daytime);
    byte oldDaylight=_daylight;
switch (_daytime) {
case 18:
      _daylight=(byte)(0.8f * Configuration.MAX_LIGHT);
    break;
case 20:
  _daylight=(byte)(0.6f * Configuration.MAX_LIGHT);
break;
case 21:
_daylight=(byte)(0.4f * Configuration.MAX_LIGHT);
break;
case 22:
_daylight=(byte)(0.3f * Configuration.MAX_LIGHT);
break;
case 23:
_daylight=(byte)(0.2f * Configuration.MAX_LIGHT);
break;
case 5:
_daylight=(byte)(0.3f * Configuration.MAX_LIGHT);
break;
case 6:
_daylight=(byte)(0.6f * Configuration.MAX_LIGHT);
break;
case 7:
_daylight=(byte)(0.8f * Configuration.MAX_LIGHT);
break;
case 8:
_daylight=Configuration.MAX_LIGHT;
break;
}
if (_daylight != oldDaylight) {
for (int key : _chunkCache.keySet()) {
_chunkCache.get(key)._dirty=true;
}
for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.z; z++) {
Chunk c=_chunks[x][0][z];
queueChunkForUpdate(c,0);
}
}
}
}
}",0.9376167351512888
1306,"/** 
 * Initializes a new world for the single player mode.
 * @param title The title/description of the world
 * @param seed The seed string used to genrate the terrain
 * @param p The player
 */
public World(String title,String seed,Player p){
  this._player=p;
  _rand=new FastRandom(seed.hashCode());
  _chunks=new Chunk[(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x][(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y][(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.z];
  _generatorTerrain=new GeneratorTerrain(seed);
  _generatorForest=new GeneratorForest(seed);
  _updateThread=new Thread(new Runnable(){
    @Override public void run(){
      long timeStart=System.currentTimeMillis();
      Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"");
      for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
        for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.z; z++) {
          Chunk c=loadOrCreateChunk(x,z);
          _chunks[x][0][z]=c;
          queueChunkForUpdate(c,0);
        }
      }
      _worldGenerated=true;
      _player.resetPlayer();
      Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"",(System.currentTimeMillis() - timeStart) / 1000d);
      while (true) {
        ArrayList<Chunk> sortedUpdates=new ArrayList<Chunk>(_chunkUpdateNormal);
        Collections.sort(sortedUpdates);
        for (int i=0; i < 16; i++) {
          if (sortedUpdates.size() > 0 && _chunkUpdateImportant.isEmpty()) {
            Chunk c=sortedUpdates.remove(0);
            _chunkUpdateNormal.remove(c);
            processChunk(c);
          }
 else {
            Chunk c=_chunkUpdateImportant.poll();
            processChunk(c);
          }
        }
      }
    }
  }
);
  _worldThread=new Thread(new Runnable(){
    @Override public void run(){
      while (true) {
        updateInfWorld();
        updateDaytime();
      }
    }
  }
);
  _updateThread.start();
  _worldThread.start();
}","/** 
 * Initializes a new world for the single player mode.
 * @param title The title/description of the world
 * @param seed The seed string used to genrate the terrain
 * @param p The player
 */
public World(String title,String seed,Player p){
  this._player=p;
  _rand=new FastRandom(seed.hashCode());
  _chunks=new Chunk[(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x][(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y][(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.z];
  _generatorTerrain=new GeneratorTerrain(seed);
  _generatorForest=new GeneratorForest(seed);
  _updateThread=new Thread(new Runnable(){
    @Override public void run(){
      long timeStart=System.currentTimeMillis();
      Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"");
      for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
        for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.z; z++) {
          Chunk c=loadOrCreateChunk(x,z);
          _chunks[x][0][z]=c;
          queueChunkForUpdate(c,0);
        }
      }
      _worldGenerated=true;
      _player.resetPlayer();
      Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"",(System.currentTimeMillis() - timeStart) / 1000d);
      while (true) {
        ArrayList<Chunk> sortedUpdates=new ArrayList<Chunk>(_chunkUpdateNormal);
        Collections.sort(sortedUpdates);
        for (int i=0; i < 8; i++) {
          if (sortedUpdates.size() > 0 && _chunkUpdateImportant.isEmpty()) {
            Chunk c=sortedUpdates.remove(0);
            _chunkUpdateNormal.remove(c);
            processChunk(c);
          }
 else {
            Chunk c=_chunkUpdateImportant.poll();
            processChunk(c);
          }
        }
      }
    }
  }
);
  _worldThread=new Thread(new Runnable(){
    @Override public void run(){
      while (true) {
        updateInfWorld();
        updateDaytime();
      }
    }
  }
);
  _updateThread.start();
  _worldThread.start();
}",0.9992418498862776
1307,"/** 
 * Loads a specified chunk from the cache or queues a new chunk for generation. NOTE: This method ALWAYS returns a valid chunk since new chunks are generated if none of the present chunks fit. TODO: Chunks should be saved to and loaded from the hard disk!
 * @param x X-coordinate of the chunk
 * @param z Z-coordinate of the chunk
 * @return The chunk
 */
private Chunk loadOrCreateChunk(int x,int z){
  Chunk c=getChunk(x,0,z);
  if (c != null) {
    if (c.getPosition().x != x || c.getPosition().y != 0 || c.getPosition().z != z) {
synchronized (_chunkCache) {
        c=_chunkCache.get(Helper.getInstance().cantorize(x,z));
      }
    }
  }
  if (c != null) {
    return c;
  }
 else {
  }
synchronized (_chunkCache) {
    if (_chunkCache.size() >= 1024) {
      ArrayList<Chunk> sortedChunks=new ArrayList<Chunk>(_chunkCache.values());
      Collections.sort(sortedChunks);
      Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"");
      for (int i=0; i < 256; i++) {
        int indexToDelete=sortedChunks.size() - i;
        if (indexToDelete >= 0 && indexToDelete < sortedChunks.size()) {
          Chunk cc=sortedChunks.get(indexToDelete);
          _chunkCache.remove(Helper.getInstance().cantorize((int)cc.getPosition().x,(int)cc.getPosition().z));
        }
      }
      Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"");
    }
  }
  ArrayList<Generator> gs=new ArrayList<Generator>();
  gs.add(_generatorTerrain);
  gs.add(_generatorForest);
  c=new Chunk(this,new Vector3f(x,0,z),gs);
synchronized (_chunkCache) {
    _chunkCache.put(Helper.getInstance().cantorize(x,z),c);
  }
  return c;
}","/** 
 * Loads a specified chunk from the cache or queues a new chunk for generation. NOTE: This method ALWAYS returns a valid chunk since new chunks are generated if none of the present chunks fit. TODO: Chunks should be saved to and loaded from the hard disk!
 * @param x X-coordinate of the chunk
 * @param z Z-coordinate of the chunk
 * @return The chunk
 */
private synchronized Chunk loadOrCreateChunk(int x,int z){
  Chunk c=getChunk(x,0,z);
  if (c != null) {
    if (c.getPosition().x != x || c.getPosition().y != 0 || c.getPosition().z != z) {
      c=_chunkCache.get(Helper.getInstance().cantorize(x,z));
    }
  }
  if (c != null) {
    return c;
  }
 else {
  }
  if (_chunkCache.size() >= 1024) {
    ArrayList<Chunk> sortedChunks=new ArrayList<Chunk>(_chunkCache.values());
    Collections.sort(sortedChunks);
    Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"");
    for (int i=0; i < 256; i++) {
      int indexToDelete=sortedChunks.size() - i;
      if (indexToDelete >= 0 && indexToDelete < sortedChunks.size()) {
        Chunk cc=sortedChunks.get(indexToDelete);
        _chunkCache.remove(Helper.getInstance().cantorize((int)cc.getPosition().x,(int)cc.getPosition().z));
      }
    }
    Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"");
  }
  ArrayList<Generator> gs=new ArrayList<Generator>();
  gs.add(_generatorTerrain);
  gs.add(_generatorForest);
  c=new Chunk(this,new Vector3f(x,0,z),gs);
  _chunkCache.put(Helper.getInstance().cantorize(x,z),c);
  return c;
}",0.9284380833851898
1308,"/** 
 * Tries to load a chunk from the cache. Returns null if no chunk is found.
 * @param x X-coordinate
 * @param z Z-coordinate
 * @return The loaded chunk
 */
private Chunk loadChunk(int x,int z){
synchronized (_chunkCache) {
    Chunk c=_chunkCache.get(Helper.getInstance().cantorize(x,z));
    return c;
  }
}","/** 
 * Tries to load a chunk from the cache. Returns null if no chunk is found.
 * @param x X-coordinate
 * @param z Z-coordinate
 * @return The loaded chunk
 */
private synchronized Chunk loadChunk(int x,int z){
  Chunk c=_chunkCache.get(Helper.getInstance().cantorize(x,z));
  return c;
}",0.9174917491749176
1309,"private void queueChunkForUpdate(Chunk c,int prio){
  ArrayBlockingQueue queue=null;
  if (prio > 0) {
    queue=_chunkUpdateImportant;
  }
 else {
    queue=_chunkUpdateNormal;
  }
  queue.add(c);
}","private void queueChunkForUpdate(Chunk c,int prio){
  LinkedBlockingQueue queue=null;
  if (prio > 0) {
    queue=_chunkUpdateImportant;
  }
 else {
    queue=_chunkUpdateNormal;
  }
  queue.add(c);
}",0.9724310776942356
1310,"/** 
 * Returns the detail level for the base terrain.
 */
protected float calcTerrainDetail(float x,float z){
  float result=0.0f;
  result+=_pGen2.noiseNoiseWithOctaves(0.02f * x,0.02f,0.02f * z,4);
  return result;
}","/** 
 * Returns the detail level for the base terrain.
 */
protected float calcTerrainDetail(float x,float z){
  float result=0.0f;
  result+=_pGen3.noiseNoiseWithOctaves(0.02f * x,0.02f,0.02f * z,12);
  return result;
}",0.9886104783599088
1311,"/** 
 * Returns the base elevation for the terrain.
 */
protected float calcTerrainElevation(float x,float z){
  float result=0.0f;
  result+=_pGen1.noiseNoiseWithOctaves(0.003f * x,0.003f,0.003f * z,4) * 128f;
  return Math.abs(result);
}","/** 
 * Returns the base elevation for the terrain.
 */
protected float calcTerrainElevation(float x,float z){
  float result=0.0f;
  result+=_pGen1.noiseNoiseWithOctaves(0.003f * x,0.003f,0.003f * z,16) * 128f;
  return result;
}",0.9466950959488272
1312,"@Override public void generate(Chunk c,World parent){
  int xOffset=(int)c.getPosition().x * (int)Configuration.CHUNK_DIMENSIONS.x;
  int yOffset=(int)c.getPosition().y * (int)Configuration.CHUNK_DIMENSIONS.y;
  int zOffset=(int)c.getPosition().z * (int)Configuration.CHUNK_DIMENSIONS.z;
  for (int x=0; x < Configuration.CHUNK_DIMENSIONS.x; x++) {
    for (int z=0; z < Configuration.CHUNK_DIMENSIONS.z; z++) {
      int height=(int)(calcTerrainElevation(x + xOffset,z + zOffset) + (calcTerrainRoughness(x + xOffset,z + zOffset) * calcTerrainDetail(x + xOffset,z + zOffset)) * 64);
      for (int i=(int)Configuration.CHUNK_DIMENSIONS.y; i >= 0; i--) {
        if (calcCaveDensityAt(x + xOffset,i + yOffset,z + zOffset) < 0.5) {
          if (calcCanyonDensity(x + xOffset,i + yOffset,z + zOffset) > 0.1f) {
            float stoneDensity=calcStoneDensity(x + xOffset,i + yOffset,z + zOffset);
            if (i == height) {
              if (i > 32) {
                c.setBlock(x,i,z,(byte)0x1);
              }
 else               if (i <= 34 && i >= 28) {
                c.setBlock(x,i,z,(byte)0x7);
              }
 else {
                c.setBlock(x,i,z,(byte)0x2);
              }
            }
 else             if (i < height) {
              if (i <= 34 && i >= 28 && stoneDensity > 0f) {
                c.setBlock(x,i,z,(byte)0x7);
              }
 else               if (i < height * 0.75f && stoneDensity < 0f) {
                c.setBlock(x,i,z,(byte)0x3);
              }
 else {
                c.setBlock(x,i,z,(byte)0x2);
              }
              if (i <= 34 && i >= 28) {
                c.setBlock(x,i,z,(byte)0x7);
              }
            }
          }
        }
        if (i <= 30 && i > 0) {
          if (c.getBlock(x,i,z) == 0) {
            c.setBlock(x,i,z,(byte)0x4);
          }
        }
        if (i == 0) {
          c.setBlock(x,i,z,(byte)0x8);
        }
      }
    }
  }
}","@Override public void generate(Chunk c,World parent){
  int xOffset=(int)c.getPosition().x * (int)Configuration.CHUNK_DIMENSIONS.x;
  int yOffset=(int)c.getPosition().y * (int)Configuration.CHUNK_DIMENSIONS.y;
  int zOffset=(int)c.getPosition().z * (int)Configuration.CHUNK_DIMENSIONS.z;
  for (int x=0; x < Configuration.CHUNK_DIMENSIONS.x; x++) {
    for (int z=0; z < Configuration.CHUNK_DIMENSIONS.z; z++) {
      int height=(int)(calcTerrainElevation(x + xOffset,z + zOffset) + (calcTerrainRoughness(x + xOffset,z + zOffset) * calcTerrainDetail(x + xOffset,z + zOffset)));
      for (int i=(int)Configuration.CHUNK_DIMENSIONS.y; i >= 0; i--) {
        if (calcCaveDensityAt(x + xOffset,i + yOffset,z + zOffset) < 0.5) {
          if (calcCanyonDensity(x + xOffset,i + yOffset,z + zOffset) > 0.1f) {
            float stoneDensity=calcStoneDensity(x + xOffset,i + yOffset,z + zOffset);
            if (i == height) {
              if (i > 32) {
                c.setBlock(x,i,z,(byte)0x1);
              }
 else               if (i <= 34 && i >= 28) {
                c.setBlock(x,i,z,(byte)0x7);
              }
 else {
                c.setBlock(x,i,z,(byte)0x2);
              }
            }
 else             if (i < height) {
              if (i <= 34 && i >= 28 && stoneDensity > 0f) {
                c.setBlock(x,i,z,(byte)0x7);
              }
 else               if (i < height * 0.75f && stoneDensity < 0f) {
                c.setBlock(x,i,z,(byte)0x3);
              }
 else {
                c.setBlock(x,i,z,(byte)0x2);
              }
              if (i <= 34 && i >= 28) {
                c.setBlock(x,i,z,(byte)0x7);
              }
            }
          }
        }
        if (i <= 30 && i > 0) {
          if (c.getBlock(x,i,z) == 0) {
            c.setBlock(x,i,z,(byte)0x4);
          }
        }
        if (i == 0) {
          c.setBlock(x,i,z,(byte)0x8);
        }
      }
    }
  }
}",0.9986975774941392
1313,"/** 
 * Returns the roughness for the base terrain.
 */
protected float calcTerrainRoughness(float x,float z){
  float result=0.0f;
  result+=_pGen1.noiseNoiseWithOctaves(0.04f * x,0.04f,0.04f * z,8);
  return result;
}","/** 
 * Returns the roughness for the base terrain.
 */
protected float calcTerrainRoughness(float x,float z){
  float result=0.0f;
  result+=_pGen2.noiseNoiseWithOctaves(0.01f * x,0.01f,0.01f * z,16);
  return result;
}",0.9521640091116174
1314,"public boolean dimBlockAtLocalPos(int x,int y,int z){
  if (_parent.getBlock(getBlockWorldPosX(x + 1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) > 0 || _parent.getBlock(getBlockWorldPosX(x - 1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) > 0 || _parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z + 1)) > 0 || _parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z - 1)) > 0) {
    return true;
  }
  return false;
}","public boolean dimBlockAtLocalPos(int x,int y,int z){
  if (_parent.getBlock(getBlockWorldPosX(x + 1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) > 0 || _parent.getBlock(getBlockWorldPosX(x - 1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) > 0 || _parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z + 1)) > 0 || _parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z - 1)) > 0) {
    if (_parent.getBlock(getBlockWorldPosX(x + 1),getBlockWorldPosY(y),getBlockWorldPosZ(z + 1)) > 0 || _parent.getBlock(getBlockWorldPosX(x - 1),getBlockWorldPosY(y),getBlockWorldPosZ(z + 1)) > 0 || _parent.getBlock(getBlockWorldPosX(x + 1),getBlockWorldPosY(y),getBlockWorldPosZ(z - 1)) > 0 || _parent.getBlock(getBlockWorldPosX(x - 1),getBlockWorldPosY(y),getBlockWorldPosZ(z - 1)) > 0) {
      return true;
    }
  }
  return false;
}",0.6996996996996997
1315,"/** 
 * Draws the chunk.
 */
@Override public void render(){
  if (Configuration._showChunkOutlines) {
    glPushMatrix();
    glTranslatef(_position.x * (int)CHUNK_DIMENSIONS.x,_position.y * (int)CHUNK_DIMENSIONS.y,_position.z * (int)CHUNK_DIMENSIONS.z);
    glColor3f(255.0f,0.0f,0.0f);
    glBegin(GL_LINE_LOOP);
    glVertex3f(0.0f,0.0f,0.0f);
    glVertex3f(CHUNK_DIMENSIONS.x,0.0f,0.0f);
    glVertex3f(CHUNK_DIMENSIONS.x,CHUNK_DIMENSIONS.y,0.0f);
    glVertex3f(0.0f,CHUNK_DIMENSIONS.y,0.0f);
    glEnd();
    glBegin(GL_LINE_LOOP);
    glVertex3f(0.0f,0.0f,0.0f);
    glVertex3f(0.0f,0.0f,CHUNK_DIMENSIONS.z);
    glVertex3f(0.0f,CHUNK_DIMENSIONS.y,CHUNK_DIMENSIONS.z);
    glVertex3f(0.0f,CHUNK_DIMENSIONS.y,0.0f);
    glVertex3f(0.0f,0.0f,0.0f);
    glEnd();
    glBegin(GL_LINE_LOOP);
    glVertex3f(0.0f,0.0f,CHUNK_DIMENSIONS.z);
    glVertex3f(CHUNK_DIMENSIONS.x,0.0f,CHUNK_DIMENSIONS.z);
    glVertex3f(CHUNK_DIMENSIONS.x,CHUNK_DIMENSIONS.y,CHUNK_DIMENSIONS.z);
    glVertex3f(0.0f,CHUNK_DIMENSIONS.y,CHUNK_DIMENSIONS.z);
    glVertex3f(0.0f,0.0f,CHUNK_DIMENSIONS.z);
    glEnd();
    glBegin(GL_LINE_LOOP);
    glVertex3f(CHUNK_DIMENSIONS.x,0.0f,0.0f);
    glVertex3f(CHUNK_DIMENSIONS.x,0.0f,CHUNK_DIMENSIONS.z);
    glVertex3f(CHUNK_DIMENSIONS.x,CHUNK_DIMENSIONS.y,CHUNK_DIMENSIONS.z);
    glVertex3f(CHUNK_DIMENSIONS.x,CHUNK_DIMENSIONS.y,0.0f);
    glVertex3f(CHUNK_DIMENSIONS.x,0.0f,0.0f);
    glEnd();
    glPopMatrix();
  }
  glEnable(GL_TEXTURE_2D);
  glCallList(_displayList);
  glDisable(GL_TEXTURE_2D);
}","/** 
 * Draws the chunk.
 */
@Override public void render(){
  if (Configuration._showChunkOutlines) {
    glPushMatrix();
    glTranslatef(_position.x * (int)CHUNK_DIMENSIONS.x,_position.y * (int)CHUNK_DIMENSIONS.y,_position.z * (int)CHUNK_DIMENSIONS.z);
    glColor3f(255.0f,0.0f,0.0f);
    glBegin(GL_LINE_LOOP);
    glVertex3f(0.0f,0.0f,0.0f);
    glVertex3f(CHUNK_DIMENSIONS.x,0.0f,0.0f);
    glVertex3f(CHUNK_DIMENSIONS.x,CHUNK_DIMENSIONS.y,0.0f);
    glVertex3f(0.0f,CHUNK_DIMENSIONS.y,0.0f);
    glEnd();
    glBegin(GL_LINE_LOOP);
    glVertex3f(0.0f,0.0f,0.0f);
    glVertex3f(0.0f,0.0f,CHUNK_DIMENSIONS.z);
    glVertex3f(0.0f,CHUNK_DIMENSIONS.y,CHUNK_DIMENSIONS.z);
    glVertex3f(0.0f,CHUNK_DIMENSIONS.y,0.0f);
    glVertex3f(0.0f,0.0f,0.0f);
    glEnd();
    glBegin(GL_LINE_LOOP);
    glVertex3f(0.0f,0.0f,CHUNK_DIMENSIONS.z);
    glVertex3f(CHUNK_DIMENSIONS.x,0.0f,CHUNK_DIMENSIONS.z);
    glVertex3f(CHUNK_DIMENSIONS.x,CHUNK_DIMENSIONS.y,CHUNK_DIMENSIONS.z);
    glVertex3f(0.0f,CHUNK_DIMENSIONS.y,CHUNK_DIMENSIONS.z);
    glVertex3f(0.0f,0.0f,CHUNK_DIMENSIONS.z);
    glEnd();
    glBegin(GL_LINE_LOOP);
    glVertex3f(CHUNK_DIMENSIONS.x,0.0f,0.0f);
    glVertex3f(CHUNK_DIMENSIONS.x,0.0f,CHUNK_DIMENSIONS.z);
    glVertex3f(CHUNK_DIMENSIONS.x,CHUNK_DIMENSIONS.y,CHUNK_DIMENSIONS.z);
    glVertex3f(CHUNK_DIMENSIONS.x,CHUNK_DIMENSIONS.y,0.0f);
    glVertex3f(CHUNK_DIMENSIONS.x,0.0f,0.0f);
    glEnd();
    glPopMatrix();
  }
  _textureMap.bind();
  glEnable(GL_TEXTURE_2D);
  glCallList(_displayList);
  glDisable(GL_TEXTURE_2D);
}",0.9928525016244314
1316,"/** 
 * Generates the terrain within this chunk.
 */
public void generate(){
  clear();
  int xOffset=(int)_position.x * (int)CHUNK_DIMENSIONS.x;
  int yOffset=(int)_position.y * (int)CHUNK_DIMENSIONS.y;
  int zOffset=(int)_position.z * (int)CHUNK_DIMENSIONS.z;
  for (int x=0; x < Chunk.CHUNK_DIMENSIONS.x; x++) {
    for (int z=0; z < Chunk.CHUNK_DIMENSIONS.z; z++) {
      int height=(int)(calcTerrainElevation(x + xOffset,z + zOffset) + (calcTerrainRoughness(x + xOffset,z + zOffset) * calcTerrainDetail(x + xOffset,z + zOffset)) * 64) + 64;
      for (int i=(int)CHUNK_DIMENSIONS.y; i > 0; i--) {
        if (calcCaveDensityAt(x + xOffset,i,z + zOffset) < 0.5 && calcCanyonDensity(x + xOffset,i + yOffset,z + zOffset) < 0.5) {
          if (i == height) {
            if (i != 36) {
              setBlock(x,i,z,0x1);
            }
 else {
              setBlock(x,i,z,0x7);
            }
          }
 else           if (i < height) {
            if (i < height * 0.75f) {
              setBlock(x,i,z,0x3);
            }
 else {
              setBlock(x,i,z,0x2);
            }
            if (i <= 36 && i >= 32) {
              setBlock(x,i,z,0x7);
            }
          }
        }
        if (i <= 32) {
          if (getBlock(x,i,z) == 0) {
            setBlock(x,i,z,0x4);
          }
        }
      }
    }
  }
}","public void generate(){
  if (_fresh) {
    generateTerrain();
    populate();
    calcSunlight();
    _fresh=false;
  }
}",0.1282758620689655
1317,"/** 
 * Init. the textures used within chunks.
 */
public static void init(){
  try {
    _textureMap=TextureLoader.getTexture(""String_Node_Str"",new FileInputStream(Chunk.class.getResource(""String_Node_Str"").getPath()),GL_NEAREST);
    _textureMap.bind();
  }
 catch (  IOException ex) {
    Logger.getLogger(Chunk.class.getName()).log(Level.SEVERE,null,ex);
  }
}","/** 
 * Init. the textures used within chunks.
 */
public static void init(){
  try {
    _textureMap=TextureLoader.getTexture(""String_Node_Str"",new FileInputStream(Chunk.class.getResource(""String_Node_Str"").getPath()),GL_NEAREST);
  }
 catch (  IOException ex) {
    Logger.getLogger(Chunk.class.getName()).log(Level.SEVERE,null,ex);
  }
}",0.9659090909090908
1318,"/** 
 * Generates the display list from the precalculated arrays.
 */
public void generateDisplayList(){
  if (_chunkID == -1) {
    _chunkID=maxChunkID + 1;
    maxChunkID++;
    _displayList=glGenLists(1);
  }
  FloatBuffer cb=null;
  FloatBuffer tb=null;
  FloatBuffer vb=null;
  vb=BufferUtils.createFloatBuffer(_quads.size());
  for (  Float f : _quads) {
    vb.put(f);
  }
  tb=BufferUtils.createFloatBuffer(_tex.size());
  for (  Float f : _tex) {
    tb.put(f);
  }
  _tex.clear();
  cb=BufferUtils.createFloatBuffer(_color.size());
  for (  Float f : _color) {
    cb.put(f);
  }
  _color.clear();
  vb.flip();
  tb.flip();
  cb.flip();
  glNewList(_displayList,GL_COMPILE);
  glEnableClientState(GL_VERTEX_ARRAY);
  glEnableClientState(GL_TEXTURE_COORD_ARRAY);
  glEnableClientState(GL_COLOR_ARRAY);
  glTexCoordPointer(2,0,tb);
  glColorPointer(3,0,cb);
  glVertexPointer(3,0,vb);
  glDrawArrays(GL_QUADS,0,_quads.size() / 3);
  glDisableClientState(GL_COLOR_ARRAY);
  glDisableClientState(GL_TEXTURE_COORD_ARRAY);
  glDisableClientState(GL_VERTEX_ARRAY);
  glEndList();
  _quads.clear();
  vb=null;
  tb=null;
  cb=null;
}","/** 
 * Generates the display list from the precalculated arrays.
 */
public synchronized void generateDisplayList(){
  if (_chunkID == -1) {
    _chunkID=maxChunkID + 1;
    maxChunkID++;
    _displayList=glGenLists(1);
  }
  FloatBuffer cb=null;
  FloatBuffer tb=null;
  FloatBuffer vb=null;
  vb=BufferUtils.createFloatBuffer(_quads.size());
  for (  Float f : _quads) {
    vb.put(f);
  }
  tb=BufferUtils.createFloatBuffer(_tex.size());
  for (  Float f : _tex) {
    tb.put(f);
  }
  cb=BufferUtils.createFloatBuffer(_color.size());
  for (  Float f : _color) {
    cb.put(f);
  }
  vb.flip();
  tb.flip();
  cb.flip();
  glNewList(_displayList,GL_COMPILE);
  glEnableClientState(GL_VERTEX_ARRAY);
  glEnableClientState(GL_TEXTURE_COORD_ARRAY);
  glEnableClientState(GL_COLOR_ARRAY);
  glTexCoordPointer(2,0,tb);
  glColorPointer(3,0,cb);
  glVertexPointer(3,0,vb);
  glDrawArrays(GL_QUADS,0,_quads.size() / 3);
  glDisableClientState(GL_COLOR_ARRAY);
  glDisableClientState(GL_TEXTURE_COORD_ARRAY);
  glDisableClientState(GL_VERTEX_ARRAY);
  glEndList();
  vb=null;
  tb=null;
  cb=null;
}",0.9708650829224564
1319,"/** 
 * Init. the chunk.
 */
public Chunk(World p,Vector3f position){
  this._position=position;
  _parent=p;
  clear();
  generate();
}","/** 
 * Init. the chunk.
 */
public Chunk(World p,Vector3f position){
  this._position=position;
  _parent=p;
  _blocks=new int[(int)CHUNK_DIMENSIONS.x][(int)CHUNK_DIMENSIONS.y][(int)CHUNK_DIMENSIONS.z];
  _light=new float[(int)CHUNK_DIMENSIONS.x][(int)CHUNK_DIMENSIONS.y][(int)CHUNK_DIMENSIONS.z];
}",0.536697247706422
1320,"/** 
 * Generates the vertex-, texture- and color-arrays.
 */
public void generateVertexArray(){
  _color.clear();
  _quads.clear();
  _tex.clear();
  Vector3f offset=new Vector3f(_position.x * CHUNK_DIMENSIONS.x,_position.y * CHUNK_DIMENSIONS.y,_position.z * CHUNK_DIMENSIONS.z);
  for (int x=0; x < CHUNK_DIMENSIONS.x; x++) {
    for (int y=0; y < CHUNK_DIMENSIONS.y; y++) {
      for (int z=0; z < CHUNK_DIMENSIONS.z; z++) {
        int block=_blocks[x][y][z];
        if (block > 0) {
          boolean drawFront, drawBack, drawLeft, drawRight, drawTop, drawBottom;
          int blockToCheck=0;
          blockToCheck=_parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y + 1),getBlockWorldPosZ(z));
          drawTop=checkBlockTypeToDraw(blockToCheck,block);
          if (drawTop) {
            Vector3f colorOffset=Helper.getInstance().getColorOffsetFor(block,Helper.SIDE.TOP);
            float shadowIntens=Math.max(_parent.getLight(getBlockWorldPosX(x),getBlockWorldPosY(y + 1),getBlockWorldPosZ(z)) - (dimBlockAtLocalPos(x,y + 1,z) ? DIMMING_INTENS : 0.0f),MIN_LIGHT);
            float texOffsetX=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.TOP).x;
            float texOffsetY=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.TOP).y;
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY);
            _quads.add(0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
          }
          blockToCheck=_parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z - 1));
          drawFront=checkBlockTypeToDraw(blockToCheck,block);
          if (drawFront) {
            Vector3f colorOffset=Helper.getInstance().getColorOffsetFor(block,Helper.SIDE.FRONT);
            float shadowIntens=Math.max(_parent.getLight(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z - 1)) - BLOCK_SIDE_DIMMING - (dimBlockAtLocalPos(x,y,z - 1) ? DIMMING_INTENS : 0.0f),MIN_LIGHT);
            float texOffsetX=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.FRONT).x;
            float texOffsetY=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.FRONT).y;
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY);
            _quads.add(0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
          }
          blockToCheck=_parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z + 1));
          drawBack=checkBlockTypeToDraw(blockToCheck,block);
          if (drawBack) {
            Vector3f colorOffset=Helper.getInstance().getColorOffsetFor(block,Helper.SIDE.BACK);
            float shadowIntens=Math.max(_parent.getLight(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z + 1)) - BLOCK_SIDE_DIMMING - (dimBlockAtLocalPos(x,y,z + 1) ? DIMMING_INTENS : 0.0f),MIN_LIGHT);
            float texOffsetX=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.BACK).x;
            float texOffsetY=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.BACK).y;
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY);
            _quads.add(0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
          }
          blockToCheck=_parent.getBlock(getBlockWorldPosX(x - 1),getBlockWorldPosY(y),getBlockWorldPosZ(z));
          drawLeft=checkBlockTypeToDraw(blockToCheck,block);
          if (drawLeft) {
            Vector3f colorOffset=Helper.getInstance().getColorOffsetFor(block,Helper.SIDE.LEFT);
            float shadowIntens=Math.max(_parent.getLight(getBlockWorldPosX(x - 1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) - BLOCK_SIDE_DIMMING - (dimBlockAtLocalPos(x - 1,y,z) ? DIMMING_INTENS : 0.0f),MIN_LIGHT);
            float texOffsetX=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.LEFT).x;
            float texOffsetY=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.LEFT).y;
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
          }
          blockToCheck=_parent.getBlock(getBlockWorldPosX(x + 1),getBlockWorldPosY(y),getBlockWorldPosZ(z));
          drawRight=checkBlockTypeToDraw(blockToCheck,block);
          if (drawRight) {
            Vector3f colorOffset=Helper.getInstance().getColorOffsetFor(block,Helper.SIDE.RIGHT);
            float shadowIntens=Math.max(_parent.getLight(getBlockWorldPosX(x + 1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) - BLOCK_SIDE_DIMMING - (dimBlockAtLocalPos(x + 1,y,z) ? DIMMING_INTENS : 0.0f),MIN_LIGHT);
            float texOffsetX=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.RIGHT).x;
            float texOffsetY=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.RIGHT).y;
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY);
            _quads.add(0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY);
            _quads.add(0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
          }
          blockToCheck=_parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y - 1),getBlockWorldPosZ(z));
          drawBottom=checkBlockTypeToDraw(blockToCheck,block);
          if (drawBottom) {
            Vector3f colorOffset=Helper.getInstance().getColorOffsetFor(block,Helper.SIDE.BOTTOM);
            float shadowIntens=Math.max(_parent.getLight(getBlockWorldPosX(x),getBlockWorldPosY(y - 1),getBlockWorldPosZ(z)) - BLOCK_SIDE_DIMMING - (dimBlockAtLocalPos(x,y - 1,z) ? DIMMING_INTENS : 0.0f),MIN_LIGHT);
            float texOffsetX=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.BOTTOM).x;
            float texOffsetY=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.BOTTOM).y;
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY);
            _quads.add(0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
          }
        }
      }
    }
  }
}","/** 
 * Generates the vertex-, texture- and color-arrays.
 */
public synchronized void generateVertexArray(){
  _color.clear();
  _quads.clear();
  _tex.clear();
  Vector3f offset=new Vector3f(_position.x * CHUNK_DIMENSIONS.x,_position.y * CHUNK_DIMENSIONS.y,_position.z * CHUNK_DIMENSIONS.z);
  for (int x=0; x < CHUNK_DIMENSIONS.x; x++) {
    for (int y=0; y < CHUNK_DIMENSIONS.y; y++) {
      for (int z=0; z < CHUNK_DIMENSIONS.z; z++) {
        int block=_blocks[x][y][z];
        if (block > 0) {
          boolean drawFront, drawBack, drawLeft, drawRight, drawTop, drawBottom;
          int blockToCheck=0;
          blockToCheck=_parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y + 1),getBlockWorldPosZ(z));
          drawTop=checkBlockTypeToDraw(blockToCheck,block);
          if (drawTop) {
            Vector3f colorOffset=Helper.getInstance().getColorOffsetFor(block,Helper.SIDE.TOP);
            float shadowIntens=Math.max(_parent.getLight(getBlockWorldPosX(x),getBlockWorldPosY(y + 1),getBlockWorldPosZ(z)) - (dimBlockAtLocalPos(x,y + 1,z) ? DIMMING_INTENS : 0.0f),MIN_LIGHT);
            float texOffsetX=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.TOP).x;
            float texOffsetY=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.TOP).y;
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY);
            _quads.add(0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
          }
          blockToCheck=_parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z - 1));
          drawFront=checkBlockTypeToDraw(blockToCheck,block);
          if (drawFront) {
            Vector3f colorOffset=Helper.getInstance().getColorOffsetFor(block,Helper.SIDE.FRONT);
            float shadowIntens=Math.max(_parent.getLight(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z - 1)) - BLOCK_SIDE_DIMMING - (dimBlockAtLocalPos(x,y,z - 1) ? DIMMING_INTENS : 0.0f),MIN_LIGHT);
            float texOffsetX=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.FRONT).x;
            float texOffsetY=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.FRONT).y;
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY);
            _quads.add(0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
          }
          blockToCheck=_parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z + 1));
          drawBack=checkBlockTypeToDraw(blockToCheck,block);
          if (drawBack) {
            Vector3f colorOffset=Helper.getInstance().getColorOffsetFor(block,Helper.SIDE.BACK);
            float shadowIntens=Math.max(_parent.getLight(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z + 1)) - BLOCK_SIDE_DIMMING - (dimBlockAtLocalPos(x,y,z + 1) ? DIMMING_INTENS : 0.0f),MIN_LIGHT);
            float texOffsetX=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.BACK).x;
            float texOffsetY=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.BACK).y;
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY);
            _quads.add(0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
          }
          blockToCheck=_parent.getBlock(getBlockWorldPosX(x - 1),getBlockWorldPosY(y),getBlockWorldPosZ(z));
          drawLeft=checkBlockTypeToDraw(blockToCheck,block);
          if (drawLeft) {
            Vector3f colorOffset=Helper.getInstance().getColorOffsetFor(block,Helper.SIDE.LEFT);
            float shadowIntens=Math.max(_parent.getLight(getBlockWorldPosX(x - 1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) - BLOCK_SIDE_DIMMING - (dimBlockAtLocalPos(x - 1,y,z) ? DIMMING_INTENS : 0.0f),MIN_LIGHT);
            float texOffsetX=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.LEFT).x;
            float texOffsetY=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.LEFT).y;
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
          }
          blockToCheck=_parent.getBlock(getBlockWorldPosX(x + 1),getBlockWorldPosY(y),getBlockWorldPosZ(z));
          drawRight=checkBlockTypeToDraw(blockToCheck,block);
          if (drawRight) {
            Vector3f colorOffset=Helper.getInstance().getColorOffsetFor(block,Helper.SIDE.RIGHT);
            float shadowIntens=Math.max(_parent.getLight(getBlockWorldPosX(x + 1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) - BLOCK_SIDE_DIMMING - (dimBlockAtLocalPos(x + 1,y,z) ? DIMMING_INTENS : 0.0f),MIN_LIGHT);
            float texOffsetX=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.RIGHT).x;
            float texOffsetY=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.RIGHT).y;
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY);
            _quads.add(0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY);
            _quads.add(0.5f + x + offset.x);
            _quads.add(0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
          }
          blockToCheck=_parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y - 1),getBlockWorldPosZ(z));
          drawBottom=checkBlockTypeToDraw(blockToCheck,block);
          if (drawBottom) {
            Vector3f colorOffset=Helper.getInstance().getColorOffsetFor(block,Helper.SIDE.BOTTOM);
            float shadowIntens=Math.max(_parent.getLight(getBlockWorldPosX(x),getBlockWorldPosY(y - 1),getBlockWorldPosZ(z)) - BLOCK_SIDE_DIMMING - (dimBlockAtLocalPos(x,y - 1,z) ? DIMMING_INTENS : 0.0f),MIN_LIGHT);
            float texOffsetX=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.BOTTOM).x;
            float texOffsetY=Helper.getInstance().getTextureOffsetFor(block,Helper.SIDE.BOTTOM).y;
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY);
            _quads.add(0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(-0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX + 0.0625f);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
            _color.add(colorOffset.x * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.y * shadowIntens * _parent.getDaylight());
            _color.add(colorOffset.z * shadowIntens * _parent.getDaylight());
            _tex.add(texOffsetX);
            _tex.add(texOffsetY + 0.0625f);
            _quads.add(-0.5f + x + offset.x);
            _quads.add(-0.5f + y + offset.y);
            _quads.add(0.5f + z + offset.z);
          }
        }
      }
    }
  }
}",0.999585551694456
1321,"/** 
 * Populates the chunk (e.g. placement of trees etc.).
 */
public void populate(){
  for (int x=0; x < Chunk.CHUNK_DIMENSIONS.x; x++) {
    for (int z=0; z < Chunk.CHUNK_DIMENSIONS.z; z++) {
      for (int y=32; y < Chunk.CHUNK_DIMENSIONS.y; y++) {
        if (_parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z)) == 0x1 && _rand.nextFloat() < 0.009f) {
          if (_rand.nextBoolean()) {
            _parent.generateTree(getBlockWorldPosX(x),getBlockWorldPosY((int)y) + 1,getBlockWorldPosZ(z));
          }
 else {
            _parent.generatePineTree(getBlockWorldPosX(x),getBlockWorldPosY((int)y) + 1,getBlockWorldPosZ(z));
          }
          return;
        }
      }
    }
  }
}","/** 
 * Populates the chunk (e.g. placement of trees etc.).
 */
public void populate(){
  for (int y=0; y < Chunk.CHUNK_DIMENSIONS.y; y++) {
    for (int x=0; x < Chunk.CHUNK_DIMENSIONS.x; x++) {
      for (int z=0; z < Chunk.CHUNK_DIMENSIONS.z; z++) {
        float dens=calcForestDensity(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z));
        if (dens > 0.55 && dens < 0.7f && _parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z)) == 0x1 && y > 32) {
          _parent.generateTree(getBlockWorldPosX(x),getBlockWorldPosY((int)y) + 1,getBlockWorldPosZ(z),false);
          return;
        }
 else         if (dens >= 0.7f && _parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z)) == 0x1 && y > 32) {
          _parent.generatePineTree(getBlockWorldPosX(x),getBlockWorldPosY((int)y) + 1,getBlockWorldPosZ(z),false);
          return;
        }
      }
    }
  }
}",0.6996978851963747
1322,"void calcLight(){
  for (int ite=0; ite < 16; ite++) {
    for (int x=0; x < (int)CHUNK_DIMENSIONS.x; x++) {
      for (int z=0; z < (int)CHUNK_DIMENSIONS.z; z++) {
        for (int y=(int)CHUNK_DIMENSIONS.y - 1; y > 0; y--) {
          if (getLight(x,y,z) == MAX_LIGHT - ite * 0.0625f && getBlock(x,y,z) == 0) {
            floodLight(x,y,z);
          }
        }
      }
    }
  }
}","public void calcLight(){
  for (int ite=0; ite < 16; ite++) {
    for (int x=0; x < (int)CHUNK_DIMENSIONS.x; x++) {
      for (int z=0; z < (int)CHUNK_DIMENSIONS.z; z++) {
        for (int y=(int)CHUNK_DIMENSIONS.y - 1; y > 0; y--) {
          if (getLight(x,y,z) == MAX_LIGHT - ite * 0.0625f && getBlock(x,y,z) == 0) {
            floodLight(x,y,z);
          }
        }
      }
    }
  }
}",0.990990990990991
1323,"@Override public String toString(){
  return String.format(""String_Node_Str"",_chunkID,blockCount());
}","@Override public String toString(){
  return String.format(""String_Node_Str"",_chunkID,blockCount(),_position);
}",0.9532710280373832
1324,"public Vector3f getColorOffsetFor(int type,SIDE side){
switch (type) {
case 0x1:
    if (side == SIDE.TOP) {
      return new Vector3f(204f / 255f,255f / 255f,25f / 255f);
    }
  break;
case 0x6:
return new Vector3f(80f / 255f,176f / 255f,7f / 255f);
}
return new Vector3f(1.0f,1.0f,1.0f);
}","public Vector3f getColorOffsetFor(int type,SIDE side){
switch (type) {
case 0x1:
    if (side == SIDE.TOP) {
      return new Vector3f(204f / 255f,255f / 255f,25f / 255f);
    }
  break;
case 0x6:
return new Vector3f(159f / 255f,235f / 255f,89f / 255f);
}
return new Vector3f(1.0f,1.0f,1.0f);
}",0.9180887372013652
1325,"private float maxLightFromNeighbors(int x,int y,int z){
  float intens=0.0f;
  for (int x1=0; x1 <= 16; ++x1) {
    float tempInt=parent.getSunlight(getBlockWorldPosX(x + x1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) / Math.abs(x1);
    if (tempInt > intens) {
      intens=tempInt;
    }
    if (parent.getBlock(getBlockWorldPosX(x + x1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) > 0) {
      break;
    }
  }
  for (int x1=0; x1 >= -16; --x1) {
    float tempInt=parent.getSunlight(getBlockWorldPosX(x + x1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) / Math.abs(x1);
    if (tempInt > intens) {
      intens=tempInt;
    }
    if (parent.getBlock(getBlockWorldPosX(x + x1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) > 0) {
      break;
    }
  }
  for (int z1=0; z1 <= 16; ++z1) {
    float tempInt=parent.getSunlight(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z + z1)) / Math.abs(z1);
    if (tempInt > intens) {
      intens=tempInt;
    }
    if (parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z + z1)) > 0) {
      break;
    }
  }
  for (int z1=0; z1 >= -16; --z1) {
    float tempInt=parent.getSunlight(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z + z1)) / Math.abs(z1);
    if (tempInt > intens) {
      intens=tempInt;
    }
    if (parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z + z1)) > 0) {
      break;
    }
  }
  return intens;
}","private float maxLightFromNeighbors(int x,int y,int z){
  float intens=0.0f;
  for (int x1=0; x1 <= 16; ++x1) {
    float tempInt=parent.getSunlight(getBlockWorldPosX(x + x1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) / (Math.abs(x1) + 1);
    if (tempInt > intens) {
      intens=tempInt;
    }
    if (parent.getBlock(getBlockWorldPosX(x + x1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) > 0) {
      break;
    }
  }
  for (int x1=0; x1 >= -16; --x1) {
    float tempInt=parent.getSunlight(getBlockWorldPosX(x + x1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) / (Math.abs(x1) + 1);
    if (tempInt > intens) {
      intens=tempInt;
    }
    if (parent.getBlock(getBlockWorldPosX(x + x1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) > 0) {
      break;
    }
  }
  for (int z1=0; z1 <= 16; ++z1) {
    float tempInt=parent.getSunlight(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z + z1)) / (Math.abs(z1) + 1);
    if (tempInt > intens) {
      intens=tempInt;
    }
    if (parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z + z1)) > 0) {
      break;
    }
  }
  for (int z1=0; z1 >= -16; --z1) {
    float tempInt=parent.getSunlight(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z + z1)) / (Math.abs(z1) + 1);
    if (tempInt > intens) {
      intens=tempInt;
    }
    if (parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z + z1)) > 0) {
      break;
    }
  }
  return intens;
}",0.9917412250516172
1326,"public void calcSunlight(){
  sunlight=new float[(int)chunkDimensions.x][(int)chunkDimensions.y][(int)chunkDimensions.z];
  for (int x=0; x < (int)chunkDimensions.x; x++) {
    for (int z=0; z < (int)chunkDimensions.z; z++) {
      for (int y=(int)chunkDimensions.y - 1; y > 0; y--) {
        if (blocks[x][y][z] == 0) {
          setSunlight(x,y,z,MAX_LIGHT);
        }
 else {
          setSunlight(x,y,z,MAX_LIGHT);
          break;
        }
      }
    }
  }
}","public void calcSunlight(){
  sunlight=new float[(int)chunkDimensions.x][(int)chunkDimensions.y][(int)chunkDimensions.z];
  for (int x=0; x < (int)chunkDimensions.x; x++) {
    for (int z=0; z < (int)chunkDimensions.z; z++) {
      for (int y=(int)chunkDimensions.y - 1; y > 0; y--) {
        if (blocks[x][y][z] == 0) {
          setSunlight(x,y,z,MAX_LIGHT);
        }
 else {
          break;
        }
      }
    }
  }
}",0.9550561797752808
1327,"public float getLight(int x,int y,int z){
  float result=0f;
  try {
    result=light[x][y][z];
    if (result == 0.0f) {
      result=sunlight[x][y][z];
    }
  }
 catch (  Exception e) {
  }
  if (result == 0f) {
    result=MIN_LIGHT;
  }
  return result;
}","public float getLight(int x,int y,int z){
  float result=0f;
  try {
    result=light[x][y][z];
    if (result == 0.0f) {
      result=sunlight[x][y][z];
    }
  }
 catch (  Exception e) {
  }
  if (result < 0.2f) {
    result=MIN_LIGHT;
  }
  return result;
}",0.9826589595375722
1328,"public void calcLight(){
  light=new float[(int)chunkDimensions.x][(int)chunkDimensions.y][(int)chunkDimensions.z];
  for (int x=0; x < (int)chunkDimensions.x; x++) {
    for (int z=0; z < (int)chunkDimensions.z; z++) {
      for (int y=0; y < (int)chunkDimensions.y; y++) {
        if (blocks[x][y][z] == 0 && sunlight[x][y][z] == 0) {
          setLight(x,y,z,maxLightFromNeighbors(x,y,z));
        }
      }
    }
  }
}","public void calcLight(){
  light=new float[(int)chunkDimensions.x][(int)chunkDimensions.y][(int)chunkDimensions.z];
  for (int x=0; x < (int)chunkDimensions.x; x++) {
    for (int z=0; z < (int)chunkDimensions.z; z++) {
      for (int y=0; y < (int)chunkDimensions.y; y++) {
        if (blocks[x][y][z] == 0 && sunlight[x][y][z] == 0) {
          float sunl=maxLightFromNeighbors(x,y,z);
          setLight(x,y,z,sunl);
        }
 else         if (blocks[x][y][z] == 0 && sunlight[x][y][z] > 0f) {
          float dimming=0.0f;
          dimming+=(parent.getBlock(getBlockWorldPosX(x + 1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(getBlockWorldPosX(x - 1),getBlockWorldPosY(y),getBlockWorldPosZ(z)) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z + 1)) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(getBlockWorldPosX(x),getBlockWorldPosY(y),getBlockWorldPosZ(z - 1)) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(getBlockWorldPosX(x + 1),getBlockWorldPosY(y),getBlockWorldPosZ(z + 1)) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(getBlockWorldPosX(x - 1),getBlockWorldPosY(y),getBlockWorldPosZ(z - 1)) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(getBlockWorldPosX(x - 1),getBlockWorldPosY(y),getBlockWorldPosZ(z + 1)) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(getBlockWorldPosX(x + 1),getBlockWorldPosY(y),getBlockWorldPosZ(z - 1)) > 0) ? DIMMING_INTENS : 0.0f;
          setLight(x,y,z,Math.max(sunlight[x][y][z] - dimming,0f));
        }
      }
    }
  }
}",0.3812646370023419
1329,"/** 
 * Returns true if the given position is filled with a block.
 */
public boolean isHitting(int x,int y,int z){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.viewingDistanceInChunks.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.viewingDistanceInChunks.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.viewingDistanceInChunks.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=chunks[chunkPosX][chunkPosY][chunkPosZ];
    return (c.getBlock(blockPosX,blockPosY,blockPosZ) > 0);
  }
 catch (  Exception e) {
    return false;
  }
}","/** 
 * Returns true if the given position is filled with a block.
 */
public boolean isHitting(int x,int y,int z){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.viewingDistanceInChunks.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.viewingDistanceInChunks.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.viewingDistanceInChunks.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=getChunk(chunkPosX,chunkPosY,chunkPosZ);
    return (c.getBlock(blockPosX,blockPosY,blockPosZ) > 0);
  }
 catch (  Exception e) {
    return false;
  }
}",0.9819277108433736
1330,"/** 
 * Sets the type of a block at a given position.
 */
public final void setBlock(int x,int y,int z,int type){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.viewingDistanceInChunks.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.viewingDistanceInChunks.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.viewingDistanceInChunks.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=chunks[chunkPosX][chunkPosY][chunkPosZ];
    if (c.getPosition().x != calcChunkPosX(x) || c.getPosition().y != calcChunkPosY(y) || c.getPosition().z != calcChunkPosZ(z)) {
      return;
    }
    c.setBlock(blockPosX,blockPosY,blockPosZ,type);
    queueChunkForUpdate(c);
  }
 catch (  Exception e) {
    return;
  }
}","/** 
 * Sets the type of a block at a given position.
 */
public final void setBlock(int x,int y,int z,int type){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.viewingDistanceInChunks.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.viewingDistanceInChunks.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.viewingDistanceInChunks.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=getChunk(chunkPosX,chunkPosY,chunkPosZ);
    if (c.getPosition().x != calcChunkPosX(x) || c.getPosition().y != calcChunkPosY(y) || c.getPosition().z != calcChunkPosZ(z)) {
      return;
    }
    c.setBlock(blockPosX,blockPosY,blockPosZ,type);
    queueChunkForUpdate(c);
  }
 catch (  Exception e) {
    return;
  }
}",0.985489721886336
1331,"@Override public void run(){
  while (true) {
    updateInfWorld();
    if (Helper.getInstance().getTime() - daylightTimer > 20000) {
      daylight-=0.2;
      if (daylight <= 0.4f) {
        daylight=1.0f;
      }
      daylightTimer=Helper.getInstance().getTime();
      updateAllChunks();
    }
  }
}","@Override public void run(){
  while (true) {
    updateInfWorld();
    if (Helper.getInstance().getTime() - daylightTimer > 120000) {
      daylight-=0.2;
      if (daylight <= 0.4f) {
        daylight=1.0f;
      }
      daylightTimer=Helper.getInstance().getTime();
      updateAllChunks();
    }
  }
}",0.9983579638752051
1332,"public World(String title,String seed,Player p){
  this.player=p;
  rand=new Random(seed.hashCode());
  pGen1=new PerlinNoise(rand.nextInt());
  pGen2=new PerlinNoise(rand.nextInt());
  pGen3=new PerlinNoise(rand.nextInt());
  final World currentWorld=this;
  chunks=new Chunk[(int)Configuration.viewingDistanceInChunks.x][(int)Configuration.viewingDistanceInChunks.y][(int)Configuration.viewingDistanceInChunks.z];
  updateThread=new Thread(new Runnable(){
    @Override public void run(){
      long timeStart=System.currentTimeMillis();
      Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"");
      for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
        for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
          for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
            Chunk c=new Chunk(currentWorld,new Vector3f(x,y,z));
            chunks[x][y][z]=c;
            c.generate();
            c.populate();
            c.calcSunlight();
            queueChunkForUpdate(c);
          }
        }
      }
      setWorldGenerated(true);
      player.resetPlayer();
      Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"",(System.currentTimeMillis() - timeStart) / 1000d);
      while (true) {
        Chunk c=null;
synchronized (chunkUpdateQueueDL) {
          c=chunkUpdateQueue.peek();
          if (chunkUpdateQueueDL.contains(c)) {
            c=null;
          }
 else {
            chunkUpdateQueue.poll();
          }
        }
        if (c != null) {
          c.calcSunlight();
          c.calcLight();
          c.generateVertexArray();
synchronized (chunkUpdateQueueDL) {
            chunkUpdateQueueDL.add(c);
          }
        }
      }
    }
  }
);
  worldThread=new Thread(new Runnable(){
    @Override public void run(){
      while (true) {
        updateInfWorld();
        if (Helper.getInstance().getTime() - daylightTimer > 20000) {
          daylight-=0.2;
          if (daylight <= 0.4f) {
            daylight=1.0f;
          }
          daylightTimer=Helper.getInstance().getTime();
          updateAllChunks();
        }
      }
    }
  }
);
}","public World(String title,String seed,Player p){
  this.player=p;
  rand=new Random(seed.hashCode());
  pGen1=new PerlinNoise(rand.nextInt());
  pGen2=new PerlinNoise(rand.nextInt());
  pGen3=new PerlinNoise(rand.nextInt());
  final World currentWorld=this;
  chunks=new Chunk[(int)Configuration.viewingDistanceInChunks.x][(int)Configuration.viewingDistanceInChunks.y][(int)Configuration.viewingDistanceInChunks.z];
  updateThread=new Thread(new Runnable(){
    @Override public void run(){
      long timeStart=System.currentTimeMillis();
      Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"");
      for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
        for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
          for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
            Chunk c=new Chunk(currentWorld,new Vector3f(x,y,z));
            chunks[x][y][z]=c;
            c.generate();
            c.populate();
            c.calcSunlight();
            queueChunkForUpdate(c);
          }
        }
      }
      setWorldGenerated(true);
      player.resetPlayer();
      Logger.getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"",(System.currentTimeMillis() - timeStart) / 1000d);
      while (true) {
        Chunk c=null;
synchronized (chunkUpdateQueueDL) {
          c=chunkUpdateQueue.peek();
          if (chunkUpdateQueueDL.contains(c)) {
            c=null;
          }
 else {
            chunkUpdateQueue.poll();
          }
        }
        if (c != null) {
          c.calcLight();
          c.generateVertexArray();
synchronized (chunkUpdateQueueDL) {
            chunkUpdateQueueDL.add(c);
          }
        }
      }
    }
  }
);
  worldThread=new Thread(new Runnable(){
    @Override public void run(){
      while (true) {
        updateInfWorld();
        if (Helper.getInstance().getTime() - daylightTimer > 120000) {
          daylight-=0.2;
          if (daylight <= 0.4f) {
            daylight=1.0f;
          }
          daylightTimer=Helper.getInstance().getTime();
          updateAllChunks();
        }
      }
    }
  }
);
}",0.9933195116332644
1333,"public final float getSunlight(int x,int y,int z){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.viewingDistanceInChunks.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.viewingDistanceInChunks.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.viewingDistanceInChunks.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=chunks[chunkPosX][chunkPosY][chunkPosZ];
    if (c.getPosition().x == calcChunkPosX(x) && c.getPosition().y == calcChunkPosY(y) && c.getPosition().z == calcChunkPosZ(z)) {
      return c.getSunlight(blockPosX,blockPosY,blockPosZ);
    }
  }
 catch (  Exception e) {
  }
  return -1f;
}","public final float getSunlight(int x,int y,int z){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.viewingDistanceInChunks.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.viewingDistanceInChunks.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.viewingDistanceInChunks.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=getChunk(chunkPosX,chunkPosY,chunkPosZ);
    if (c.getPosition().x == calcChunkPosX(x) && c.getPosition().y == calcChunkPosY(y) && c.getPosition().z == calcChunkPosZ(z)) {
      return c.getSunlight(blockPosX,blockPosY,blockPosZ);
    }
  }
 catch (  Exception e) {
  }
  return -1f;
}",0.9835841313269492
1334,"@Override public void render(){
  glPushMatrix();
  glDisable(GL_FOG);
  glTranslatef(Configuration.viewingDistanceInChunks.x * Chunk.chunkDimensions.x * 1.5f + player.getPosition().x,Configuration.viewingDistanceInChunks.y * Chunk.chunkDimensions.y + player.getPosition().y,Configuration.viewingDistanceInChunks.z * Chunk.chunkDimensions.z * 1.5f + player.getPosition().z);
  glCallList(displayListSun);
  glEnable(GL_FOG);
  glPopMatrix();
  for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
    for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
      for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
        Chunk c=chunks[x][y][z];
        if (c != null) {
          c.render();
        }
      }
    }
  }
}","@Override public void render(){
  glPushMatrix();
  glDisable(GL_FOG);
  glTranslatef(Configuration.viewingDistanceInChunks.x * Chunk.chunkDimensions.x * 1.5f + player.getPosition().x,Configuration.viewingDistanceInChunks.y * Chunk.chunkDimensions.y + player.getPosition().y,Configuration.viewingDistanceInChunks.z * Chunk.chunkDimensions.z * 1.5f + player.getPosition().z);
  glCallList(displayListSun);
  glEnable(GL_FOG);
  glPopMatrix();
  for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
    for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
      for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
        Chunk c=getChunk(x,y,z);
        if (c != null) {
          c.render();
        }
      }
    }
  }
}",0.9816031537450722
1335,"/** 
 * TODO.
 */
public final float getLight(int x,int y,int z){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.viewingDistanceInChunks.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.viewingDistanceInChunks.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.viewingDistanceInChunks.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=chunks[chunkPosX][chunkPosY][chunkPosZ];
    if (c.getPosition().x == calcChunkPosX(x) && c.getPosition().y == calcChunkPosY(y) && c.getPosition().z == calcChunkPosZ(z)) {
      return c.getLight(blockPosX,blockPosY,blockPosZ);
    }
  }
 catch (  Exception e) {
  }
  return -1f;
}","/** 
 * TODO.
 */
public final float getLight(int x,int y,int z){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.viewingDistanceInChunks.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.viewingDistanceInChunks.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.viewingDistanceInChunks.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=getChunk(chunkPosX,chunkPosY,chunkPosZ);
    if (c.getPosition().x == calcChunkPosX(x) && c.getPosition().y == calcChunkPosY(y) && c.getPosition().z == calcChunkPosZ(z)) {
      return c.getLight(blockPosX,blockPosY,blockPosZ);
    }
  }
 catch (  Exception e) {
  }
  return -1f;
}",0.9838492597577388
1336,"/** 
 * Returns a block at a position by looking up the containing chunk.
 */
public final int getBlock(int x,int y,int z){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.viewingDistanceInChunks.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.viewingDistanceInChunks.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.viewingDistanceInChunks.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=chunks[chunkPosX][chunkPosY][chunkPosZ];
    if (c.getPosition().x == calcChunkPosX(x) && c.getPosition().y == calcChunkPosY(y) && c.getPosition().z == calcChunkPosZ(z)) {
      return c.getBlock(blockPosX,blockPosY,blockPosZ);
    }
  }
 catch (  Exception e) {
  }
  return -1;
}","/** 
 * Returns a block at a position by looking up the containing chunk.
 */
public final int getBlock(int x,int y,int z){
  int chunkPosX=calcChunkPosX(x) % (int)Configuration.viewingDistanceInChunks.x;
  int chunkPosY=calcChunkPosY(y) % (int)Configuration.viewingDistanceInChunks.y;
  int chunkPosZ=calcChunkPosZ(z) % (int)Configuration.viewingDistanceInChunks.z;
  int blockPosX=calcBlockPosX(x,chunkPosX);
  int blockPosY=calcBlockPosY(y,chunkPosY);
  int blockPosZ=calcBlockPosZ(z,chunkPosZ);
  try {
    Chunk c=getChunk(chunkPosX,chunkPosY,chunkPosZ);
    if (c.getPosition().x == calcChunkPosX(x) && c.getPosition().y == calcChunkPosY(y) && c.getPosition().z == calcChunkPosZ(z)) {
      return c.getBlock(blockPosX,blockPosY,blockPosZ);
    }
  }
 catch (  Exception e) {
  }
  return -1;
}",0.985
1337,"private void queueChunkForUpdate(Chunk c){
  if (c != null) {
    ArrayList<Chunk> cs=new ArrayList<Chunk>();
    cs.add(c);
    try {
      cs.add(chunks[(int)c.getPosition().x + 1][(int)c.getPosition().y][(int)c.getPosition().z]);
    }
 catch (    Exception e) {
    }
    try {
      cs.add(chunks[(int)c.getPosition().x - 1][(int)c.getPosition().y][(int)c.getPosition().z]);
    }
 catch (    Exception e) {
    }
    try {
      cs.add(chunks[(int)c.getPosition().x][(int)c.getPosition().y][(int)c.getPosition().z + 1]);
    }
 catch (    Exception e) {
    }
    try {
      cs.add(chunks[(int)c.getPosition().x][(int)c.getPosition().y][(int)c.getPosition().z - 1]);
    }
 catch (    Exception e) {
    }
synchronized (chunkUpdateQueueDL) {
      for (      Chunk cc : cs) {
        if (!chunkUpdateQueue.contains(cc) && cc != null) {
          chunkUpdateQueue.add(cc);
        }
      }
    }
  }
}","private void queueChunkForUpdate(Chunk c){
  if (c != null) {
    ArrayList<Chunk> cs=new ArrayList<Chunk>();
    cs.add(c);
    try {
      cs.add(getChunk((int)c.getPosition().x + 1,(int)c.getPosition().y,(int)c.getPosition().z));
    }
 catch (    Exception e) {
    }
    try {
      cs.add(getChunk((int)c.getPosition().x - 1,(int)c.getPosition().y,(int)c.getPosition().z));
    }
 catch (    Exception e) {
    }
    try {
      cs.add(getChunk((int)c.getPosition().x,(int)c.getPosition().y,(int)c.getPosition().z + 1));
    }
 catch (    Exception e) {
    }
    try {
      cs.add(getChunk((int)c.getPosition().x,(int)c.getPosition().y,(int)c.getPosition().z - 1));
    }
 catch (    Exception e) {
    }
synchronized (chunkUpdateQueueDL) {
      for (      Chunk cc : cs) {
        if (!chunkUpdateQueue.contains(cc) && cc != null) {
          chunkUpdateQueue.add(cc);
        }
      }
    }
  }
}",0.8502202643171806
1338,"private void updateInfWorld(){
  for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
    for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
      for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
        Chunk c=chunks[x][y][z];
        if (c != null) {
          Vector3f pos=new Vector3f(x,y,z);
          int multZ=(int)calcPlayerChunkOffsetZ() / (int)Configuration.viewingDistanceInChunks.z + 1;
          if (z < calcPlayerChunkOffsetZ() % Configuration.viewingDistanceInChunks.z) {
            pos.z+=Configuration.viewingDistanceInChunks.z * multZ;
          }
 else {
            pos.z+=Configuration.viewingDistanceInChunks.z * (multZ - 1);
          }
          int multX=(int)calcPlayerChunkOffsetX() / (int)Configuration.viewingDistanceInChunks.x + 1;
          if (x < calcPlayerChunkOffsetX() % Configuration.viewingDistanceInChunks.x) {
            pos.x+=Configuration.viewingDistanceInChunks.x * multX;
          }
 else {
            pos.x+=Configuration.viewingDistanceInChunks.x * (multX - 1);
          }
          if (c.getPosition().x != pos.x || c.getPosition().z != pos.z) {
            c.setPosition(pos);
            c.generate();
            c.populate();
            queueChunkForUpdate(c);
          }
        }
      }
    }
  }
}","private void updateInfWorld(){
  ArrayList<Chunk> chunksToUpdate=new ArrayList<Chunk>();
  for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
    for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
      for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
        Chunk c=getChunk(x,y,z);
        if (c != null) {
          Vector3f pos=new Vector3f(x,y,z);
          int multZ=(int)calcPlayerChunkOffsetZ() / (int)Configuration.viewingDistanceInChunks.z + 1;
          if (z < calcPlayerChunkOffsetZ() % Configuration.viewingDistanceInChunks.z) {
            pos.z+=Configuration.viewingDistanceInChunks.z * multZ;
          }
 else {
            pos.z+=Configuration.viewingDistanceInChunks.z * (multZ - 1);
          }
          int multX=(int)calcPlayerChunkOffsetX() / (int)Configuration.viewingDistanceInChunks.x + 1;
          if (x < calcPlayerChunkOffsetX() % Configuration.viewingDistanceInChunks.x) {
            pos.x+=Configuration.viewingDistanceInChunks.x * multX;
          }
 else {
            pos.x+=Configuration.viewingDistanceInChunks.x * (multX - 1);
          }
          if (c.getPosition().x != pos.x || c.getPosition().z != pos.z) {
            c.setPosition(pos);
            c.generate();
            c.populate();
            c.calcSunlight();
            chunksToUpdate.add(c);
          }
        }
      }
    }
  }
  for (  Chunk c : chunksToUpdate) {
    queueChunkForUpdate(c);
  }
}",0.8619942196531792
1339,"public void updateAllChunks(){
  for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
    for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
      for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
        Chunk c=chunks[x][y][z];
        queueChunkForUpdate(c);
      }
    }
  }
}","public void updateAllChunks(){
  for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
    for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
      for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
        Chunk c=getChunk(x,y,z);
        queueChunkForUpdate(c);
      }
    }
  }
}",0.953846153846154
1340,"public Chunk(World p,Vector3f position){
  this.position=position;
  if (Chunk.parent == null) {
    Chunk.parent=p;
  }
  blocks=new int[(int)chunkDimensions.x][(int)chunkDimensions.y][(int)chunkDimensions.z];
  light=new float[(int)chunkDimensions.x][(int)chunkDimensions.y][(int)chunkDimensions.z];
  generate();
}","public Chunk(World p,Vector3f position){
  this.position=position;
  if (Chunk.parent == null) {
    Chunk.parent=p;
  }
  blocks=new int[(int)chunkDimensions.x][(int)chunkDimensions.y][(int)chunkDimensions.z];
  light=new float[(int)chunkDimensions.x][(int)chunkDimensions.y][(int)chunkDimensions.z];
  if (position.y == 0) {
    generate();
  }
}",0.9533834586466166
1341,"/** 
 * Returns the base elevation for the terrain.
 */
private float calcTerrainElevation(float x,float z){
  float result=0.0f;
  result+=pGen1.noise(0.0009f * x,0.0009f,0.00009f * z) * 64.0f;
  return Math.abs(result);
}","/** 
 * Returns the base elevation for the terrain.
 */
private float calcTerrainElevation(float x,float z){
  float result=0.0f;
  result+=pGen1.noise(0.002f * x,0.002f,0.002f * z) * 90.0f;
  return Math.abs(result);
}",0.9683257918552036
1342,"public void calcSunlight(){
  for (int x=0; x < (int)chunkDimensions.x; x++) {
    for (int z=0; z < (int)chunkDimensions.z; z++) {
      boolean covered=false;
      for (int y=(int)chunkDimensions.y - 1; y >= 0; y--) {
        if (blocks[x][y][z] == 0 && !covered) {
          float dimming=0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x + 1,y,z)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x - 1,y,z)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x,y,z + 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x,y,z - 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x + 1,y,z + 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x - 1,y,z - 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x + 1,y,z - 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x - 1,y,z + 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          setLight(x,y,z,1.0f - dimming);
        }
 else         if (blocks[x][y][z] == 0 && covered) {
          float luminance=getLight(x - 1,y,z) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z) * LUMINANCE_INTENS;
          luminance+=getLight(x,y,z + 1) * LUMINANCE_INTENS;
          luminance+=getLight(x,y,z - 1) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z + 1) * LUMINANCE_INTENS;
          luminance+=getLight(x - 1,y,z - 1) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z + 1) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z - 1) * LUMINANCE_INTENS;
          setLight(x,y,z,0.05f + (float)Math.min(luminance,1.0f));
        }
 else {
          covered=true;
        }
      }
    }
  }
}","public void calcSunlight(){
  for (int x=0; x < (int)chunkDimensions.x; x++) {
    for (int z=0; z < (int)chunkDimensions.z; z++) {
      boolean covered=false;
      for (int y=(int)chunkDimensions.y - 1; y >= 0; y--) {
        if (blocks[x][y][z] == 0 && !covered) {
          float dimming=0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x + 1,y,z)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x - 1,y,z)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x,y,z + 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x,y,z - 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x + 1,y,z + 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x - 1,y,z - 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x + 1,y,z - 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x - 1,y,z + 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          setLight(x,y,z,1.0f - dimming);
        }
 else         if (blocks[x][y][z] == 0 && covered) {
          float luminance=getLight(x - 1,y,z) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z) * LUMINANCE_INTENS;
          luminance+=getLight(x,y,z + 1) * LUMINANCE_INTENS;
          luminance+=getLight(x,y,z - 1) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z + 1) * LUMINANCE_INTENS;
          luminance+=getLight(x - 1,y,z - 1) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z + 1) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z - 1) * LUMINANCE_INTENS;
          setLight(x,y,z,0.1f + (float)Math.min(luminance,1.0f));
        }
 else {
          covered=true;
        }
      }
    }
  }
}",0.9992684711046086
1343,"public void resizeGL(){
  glViewport(0,0,(int)DISPLAY_WIDTH,(int)DISPLAY_HEIGHT);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(64.0f,DISPLAY_WIDTH / DISPLAY_HEIGHT,0.1f,1000f);
  glPushMatrix();
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glPushMatrix();
}","public void resizeGL(){
  glViewport(0,0,(int)DISPLAY_WIDTH,(int)DISPLAY_HEIGHT);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(64.0f,DISPLAY_WIDTH / DISPLAY_HEIGHT,0.01f,1000f);
  glPushMatrix();
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glPushMatrix();
}",0.9982608695652174
1344,"public void render(){
  glClearColor(world.getDaylightColor().x,world.getDaylightColor().y,world.getDaylightColor().z,1.0f);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glLoadIdentity();
  player.render();
  world.render();
  Vector3f blockPosition=player.calcViewBlockPosition();
  int bpX=(int)blockPosition.x;
  int bpY=(int)blockPosition.y;
  int bpZ=(int)blockPosition.z;
  glColor3f(1.0f,0.0f,0.0f);
  glLineWidth(4.0f);
  glBegin(GL_LINES);
  glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ - 0.5f);
  glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ - 0.5f);
  glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ + 0.5f);
  glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ + 0.5f);
  glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ + 0.5f);
  glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ + 0.5f);
  glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ - 0.5f);
  glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ - 0.5f);
  glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ - 0.5f);
  glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ + 0.5f);
  glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ - 0.5f);
  glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ + 0.5f);
  glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ - 0.5f);
  glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ + 0.5f);
  glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ - 0.5f);
  glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ + 0.5f);
  glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ - 0.5f);
  glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ - 0.5f);
  glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ - 0.5f);
  glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ - 0.5f);
  glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ + 0.5f);
  glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ + 0.5f);
  glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ + 0.5f);
  glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ + 0.5f);
  glEnd();
}","public void render(){
  glClearColor(world.getDaylightColor().x,world.getDaylightColor().y,world.getDaylightColor().z,1.0f);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glLoadIdentity();
  player.render();
  world.render();
  Vector3f blockPosition=player.calcViewBlockPosition();
  if (blockPosition != null) {
    int bpX=(int)blockPosition.x;
    int bpY=(int)blockPosition.y;
    int bpZ=(int)blockPosition.z;
    glColor3f(1.0f,0.0f,0.0f);
    glLineWidth(4.0f);
    glBegin(GL_LINES);
    glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ - 0.5f);
    glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ - 0.5f);
    glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ + 0.5f);
    glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ + 0.5f);
    glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ + 0.5f);
    glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ + 0.5f);
    glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ - 0.5f);
    glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ - 0.5f);
    glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ - 0.5f);
    glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ + 0.5f);
    glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ - 0.5f);
    glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ + 0.5f);
    glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ - 0.5f);
    glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ + 0.5f);
    glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ - 0.5f);
    glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ + 0.5f);
    glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ - 0.5f);
    glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ - 0.5f);
    glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ - 0.5f);
    glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ - 0.5f);
    glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ + 0.5f);
    glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ + 0.5f);
    glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ + 0.5f);
    glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ + 0.5f);
    glEnd();
  }
}",0.2612855007473841
1345,"private boolean isPlayerStandingOnGround(){
  if (getParent() != null) {
    return getParent().isHitting(new Vector3f(getPosition().x,getPosition().y - PLAYER_HEIGHT,getPosition().z));
  }
 else {
    return false;
  }
}","private boolean isPlayerStandingOnGround(){
  if (getParent() != null) {
    return getParent().isHitting(new Vector3f(getPosition().x + 0.5f,getPosition().y - PLAYER_HEIGHT,getPosition().z + 0.5f));
  }
 else {
    return false;
  }
}",0.9692982456140352
1346,"public Vector3f calcViewBlockPosition(){
  Vector3f blockPosition=new Vector3f(position);
  Vector2f viewingDirectionHorizontal=new Vector2f((float)Math.sin(Math.toRadians(yaw)),-1f * (float)Math.cos(Math.toRadians(yaw)));
  Vector2f viewingDirectionVertical=new Vector2f(-1f * (float)Math.sin(Math.toRadians(pitch)),(float)Math.cos(Math.toRadians(pitch)));
  blockPosition.x+=4f * viewingDirectionHorizontal.x;
  blockPosition.y+=4f * viewingDirectionVertical.x;
  blockPosition.z+=4f * viewingDirectionHorizontal.y;
  return blockPosition;
}","public Vector3f calcViewBlockPosition(){
  Vector3f blockPosition=new Vector3f(position);
  Vector2f viewingDirectionHorizontal=new Vector2f((float)Math.sin(Math.toRadians(yaw)),-1f * (float)Math.cos(Math.toRadians(yaw)));
  Vector2f viewingDirectionVertical=new Vector2f(-1f * (float)Math.sin(Math.toRadians(pitch)),(float)Math.cos(Math.toRadians(pitch)));
  for (int z=0; z < 4; z++) {
    blockPosition.x+=viewingDirectionHorizontal.x * viewingDirectionVertical.y;
    blockPosition.y+=viewingDirectionVertical.x;
    blockPosition.z+=viewingDirectionHorizontal.y * viewingDirectionVertical.y;
    if (parent.getBlock(blockPosition) != 0) {
      return blockPosition;
    }
  }
  return null;
}",0.8251410153102336
1347,"private void processMovement(long delta){
  if (getParent() != null) {
    if (Keyboard.isKeyDown(Keyboard.KEY_R)) {
      resetPlayer();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_T)) {
      parent.generateTrees();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_W)) {
      walkForward();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_S)) {
      walkBackwards();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_A)) {
      strafeLeft();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_D)) {
      strafeRight();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_SPACE)) {
      jump();
    }
    if (!parent.isHitting(new Vector3f(getPosition().x,getPosition().y - PLAYER_HEIGHT,getPosition().z))) {
      if (gravity > -MAX_GRAVITY) {
        gravity-=1;
      }
      getPosition().y+=(gravity / 1000.0f) * delta;
    }
 else     if (gravity > 0.0f) {
      getPosition().y+=(gravity / 1000.0f) * delta;
    }
    if (isObjectInFrontOfPlayer()) {
      accX=0;
      accZ=0;
    }
    getPosition().x+=(accX / 1000.0f) * delta;
    getPosition().z+=(accZ / 1000.0f) * delta;
    accX=0;
    accZ=0;
  }
}","private void processMovement(long delta){
  if (getParent() != null) {
    if (Keyboard.isKeyDown(Keyboard.KEY_R)) {
      resetPlayer();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_T)) {
      parent.generateTrees();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_W)) {
      walkForward();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_S)) {
      walkBackwards();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_A)) {
      strafeLeft();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_D)) {
      strafeRight();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_SPACE)) {
      jump();
    }
    boolean hitting=parent.isHitting(new Vector3f(getPosition().x + 0.5f,getPosition().y - PLAYER_HEIGHT,getPosition().z + 0.5f));
    if (!hitting) {
      if (gravity > -MAX_GRAVITY) {
        gravity-=0.5f;
      }
      getPosition().y+=(gravity / 1000.0f) * delta;
    }
 else     if (gravity > 0.0f) {
      getPosition().y+=(gravity / 1000.0f) * delta;
    }
 else {
      gravity=0.0f;
    }
    Vector2f dir=new Vector2f((float)accX,(float)accZ);
    try {
      dir.normalise();
    }
 catch (    Exception e) {
    }
    if (checkForCollision(new Vector3f(getPosition().x + dir.x * 0.1f,getPosition().y - PLAYER_HEIGHT + 1,getPosition().z + dir.y * 0.1f))) {
      accX=0;
      accZ=0;
    }
    getPosition().x+=(accX / 1000.0f) * delta;
    getPosition().z+=(accZ / 1000.0f) * delta;
    accX=0;
    accZ=0;
  }
}",0.8463676061929337
1348,"public void init(){
  updateThread.start();
  Sphere s=new Sphere();
  displayListSun=glGenLists(1);
  glNewList(displayListSun,GL_COMPILE);
  glColor4f(1.0f,0.8f,0.0f,1.0f);
  s.draw(120.0f,16,32);
  glEndList();
}","public void init(){
  updateThread.start();
  Sphere s=new Sphere();
  displayListSun=glGenLists(1);
  glNewList(displayListSun,GL_COMPILE);
  glColor4f(1.0f,0.8f,0.0f,1.0f);
  s.draw(256.0f,16,32);
  glEndList();
}",0.9906976744186048
1349,"/** 
 * @return the player
 */
public Player getPlayer(){
  return player;
}","/** 
 * TODO
 */
public Player getPlayer(){
  return player;
}",0.8405797101449275
1350,"/** 
 * Sets the type of a block at a given position.
 * @param pos
 * @param type
 */
public final void setBlock(Vector3f pos,int type){
  Vector3f chunkPos=calcChunkPos(pos);
  Vector3f blockCoord=calcBlockPos(pos,chunkPos);
  try {
    Chunk c=chunks[(int)chunkPos.x][(int)chunkPos.y][(int)chunkPos.z];
    if (c == null) {
      c=new Chunk(this,new Vector3f(chunkPos.x,chunkPos.y,chunkPos.z));
      chunks[(int)chunkPos.x][(int)chunkPos.y][(int)chunkPos.z]=c;
    }
    c.setBlock(blockCoord,type,true);
    chunkUpdateQueue.add(c);
  }
 catch (  Exception e) {
    return;
  }
}","/** 
 * Sets the type of a block at a given position.
 */
public final void setBlock(Vector3f pos,int type){
  Vector3f chunkPos=calcChunkPos(pos);
  Vector3f blockCoord=calcBlockPos(pos,chunkPos);
  try {
    Chunk c=chunks[(int)chunkPos.x][(int)chunkPos.y][(int)chunkPos.z];
    Chunk c1=chunks[(int)chunkPos.x - 1][(int)chunkPos.y][(int)chunkPos.z];
    Chunk c2=chunks[(int)chunkPos.x + 1][(int)chunkPos.y][(int)chunkPos.z];
    Chunk c3=chunks[(int)chunkPos.x][(int)chunkPos.y][(int)chunkPos.z - 1];
    Chunk c4=chunks[(int)chunkPos.x][(int)chunkPos.y][(int)chunkPos.z + 1];
    c.setBlock(blockCoord,type,true);
    if ((int)blockCoord.x == 0) {
      c1.dirty=true;
      chunkUpdateQueue.add(c1);
    }
 else     if ((int)blockCoord.x == (int)Chunk.chunkDimensions.x - 1) {
      c2.dirty=true;
      chunkUpdateQueue.add(c2);
    }
    if ((int)blockCoord.z == 0) {
      c3.dirty=true;
      chunkUpdateQueue.add(c3);
    }
 else     if ((int)blockCoord.z == (int)Chunk.chunkDimensions.z - 1) {
      c4.dirty=true;
      chunkUpdateQueue.add(c4);
    }
    chunkUpdateQueue.add(c);
  }
 catch (  Exception e) {
    return;
  }
}",0.4475362318840579
1351,"/** 
 * Calculate the position of a world-block within a specific chunk.
 */
private Vector3f calcBlockPos(Vector3f pos,Vector3f chunkPos){
  return new Vector3f(pos.x - (chunkPos.x * Chunk.chunkDimensions.x),pos.y - (chunkPos.y * Chunk.chunkDimensions.y),pos.z - (chunkPos.z * Chunk.chunkDimensions.z));
}","/** 
 * Calculate the position of a world-block within a specific chunk.
 */
private Vector3f calcBlockPos(Vector3f pos,Vector3f chunkPos){
  if (pos != null && chunkPos != null) {
    return new Vector3f(pos.x - (chunkPos.x * Chunk.chunkDimensions.x),pos.y - (chunkPos.y * Chunk.chunkDimensions.y),pos.z - (chunkPos.z * Chunk.chunkDimensions.z));
  }
  return null;
}",0.9080118694362018
1352,"/** 
 * Calculate the corresponding chunk for a given position within the world.
 */
private Vector3f calcChunkPos(Vector3f pos){
  return new Vector3f((int)(pos.x / Chunk.chunkDimensions.x),(int)(pos.y / Chunk.chunkDimensions.y),(int)(pos.z / Chunk.chunkDimensions.z));
}","/** 
 * Calculate the corresponding chunk for a given position within the world.
 */
private Vector3f calcChunkPos(Vector3f pos){
  if (pos != null) {
    return new Vector3f((int)(pos.x / Chunk.chunkDimensions.x),(int)(pos.y / Chunk.chunkDimensions.y),(int)(pos.z / Chunk.chunkDimensions.z));
  }
  return null;
}",0.9283276450511946
1353,"@Override public void render(){
  glPushMatrix();
  glDisable(GL_FOG);
  glTranslatef(Configuration.viewingDistanceInChunks.x * Chunk.chunkDimensions.x,Configuration.viewingDistanceInChunks.y * Chunk.chunkDimensions.y * 2f,Configuration.viewingDistanceInChunks.z * Chunk.chunkDimensions.z);
  glCallList(displayListSun);
  glEnable(GL_FOG);
  glPopMatrix();
  for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
    for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
      for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
        Chunk c=chunks[x][y][z];
        if (c != null) {
          c.render();
        }
      }
    }
  }
}","@Override public void render(){
  glPushMatrix();
  glDisable(GL_FOG);
  glTranslatef(Configuration.viewingDistanceInChunks.x * Chunk.chunkDimensions.x * 1.5f,Configuration.viewingDistanceInChunks.y * Chunk.chunkDimensions.y,Configuration.viewingDistanceInChunks.z * Chunk.chunkDimensions.z * 1.5f);
  glCallList(displayListSun);
  glEnable(GL_FOG);
  glPopMatrix();
  for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
    for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
      for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
        Chunk c=chunks[x][y][z];
        if (c != null) {
          c.render();
        }
      }
    }
  }
}",0.9024211298606016
1354,"public Chunk(World p,Vector3f position){
  this.position=position;
  if (Chunk.parent == null) {
    Chunk.parent=p;
  }
  blocks=new int[(int)chunkDimensions.x][(int)chunkDimensions.y][(int)chunkDimensions.z];
  light=new float[(int)chunkDimensions.x][(int)chunkDimensions.y][(int)chunkDimensions.z];
  generate();
}","public Chunk(World p,Vector3f position){
  this.position=position;
  if (Chunk.parent == null) {
    Chunk.parent=p;
  }
  blocks=new int[(int)chunkDimensions.x][(int)chunkDimensions.y][(int)chunkDimensions.z];
  light=new float[(int)chunkDimensions.x][(int)chunkDimensions.y][(int)chunkDimensions.z];
  if (position.y == 0) {
    generate();
  }
}",0.9533834586466166
1355,"/** 
 * Returns the base elevation for the terrain.
 */
private float calcTerrainElevation(float x,float z){
  float result=0.0f;
  result+=pGen1.noise(0.0009f * x,0.0009f,0.00009f * z) * 64.0f;
  return Math.abs(result);
}","/** 
 * Returns the base elevation for the terrain.
 */
private float calcTerrainElevation(float x,float z){
  float result=0.0f;
  result+=pGen1.noise(0.002f * x,0.002f,0.002f * z) * 90.0f;
  return Math.abs(result);
}",0.9683257918552036
1356,"public void calcSunlight(){
  for (int x=0; x < (int)chunkDimensions.x; x++) {
    for (int z=0; z < (int)chunkDimensions.z; z++) {
      boolean covered=false;
      for (int y=(int)chunkDimensions.y - 1; y >= 0; y--) {
        if (blocks[x][y][z] == 0 && !covered) {
          float dimming=0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x + 1,y,z)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x - 1,y,z)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x,y,z + 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x,y,z - 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x + 1,y,z + 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x - 1,y,z - 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x + 1,y,z - 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x - 1,y,z + 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          setLight(x,y,z,1.0f - dimming);
        }
 else         if (blocks[x][y][z] == 0 && covered) {
          float luminance=getLight(x - 1,y,z) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z) * LUMINANCE_INTENS;
          luminance+=getLight(x,y,z + 1) * LUMINANCE_INTENS;
          luminance+=getLight(x,y,z - 1) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z + 1) * LUMINANCE_INTENS;
          luminance+=getLight(x - 1,y,z - 1) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z + 1) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z - 1) * LUMINANCE_INTENS;
          setLight(x,y,z,0.05f + (float)Math.min(luminance,1.0f));
        }
 else {
          covered=true;
        }
      }
    }
  }
}","public void calcSunlight(){
  for (int x=0; x < (int)chunkDimensions.x; x++) {
    for (int z=0; z < (int)chunkDimensions.z; z++) {
      boolean covered=false;
      for (int y=(int)chunkDimensions.y - 1; y >= 0; y--) {
        if (blocks[x][y][z] == 0 && !covered) {
          float dimming=0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x + 1,y,z)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x - 1,y,z)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x,y,z + 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x,y,z - 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x + 1,y,z + 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x - 1,y,z - 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x + 1,y,z - 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          dimming+=(parent.getBlock(new Vector3f(getBlockWorldPos(new Vector3f(x - 1,y,z + 1)))) > 0) ? DIMMING_INTENS : 0.0f;
          setLight(x,y,z,1.0f - dimming);
        }
 else         if (blocks[x][y][z] == 0 && covered) {
          float luminance=getLight(x - 1,y,z) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z) * LUMINANCE_INTENS;
          luminance+=getLight(x,y,z + 1) * LUMINANCE_INTENS;
          luminance+=getLight(x,y,z - 1) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z + 1) * LUMINANCE_INTENS;
          luminance+=getLight(x - 1,y,z - 1) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z + 1) * LUMINANCE_INTENS;
          luminance+=getLight(x + 1,y,z - 1) * LUMINANCE_INTENS;
          setLight(x,y,z,0.1f + (float)Math.min(luminance,1.0f));
        }
 else {
          covered=true;
        }
      }
    }
  }
}",0.9992684711046086
1357,"public void resizeGL(){
  glViewport(0,0,(int)DISPLAY_WIDTH,(int)DISPLAY_HEIGHT);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(64.0f,DISPLAY_WIDTH / DISPLAY_HEIGHT,0.1f,1000f);
  glPushMatrix();
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glPushMatrix();
}","public void resizeGL(){
  glViewport(0,0,(int)DISPLAY_WIDTH,(int)DISPLAY_HEIGHT);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(64.0f,DISPLAY_WIDTH / DISPLAY_HEIGHT,0.01f,1000f);
  glPushMatrix();
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glPushMatrix();
}",0.9982608695652174
1358,"public void render(){
  glClearColor(world.getDaylightColor().x,world.getDaylightColor().y,world.getDaylightColor().z,1.0f);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glLoadIdentity();
  player.render();
  world.render();
  Vector3f blockPosition=player.calcViewBlockPosition();
  int bpX=(int)blockPosition.x;
  int bpY=(int)blockPosition.y;
  int bpZ=(int)blockPosition.z;
  glColor3f(1.0f,0.0f,0.0f);
  glLineWidth(4.0f);
  glBegin(GL_LINES);
  glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ - 0.5f);
  glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ - 0.5f);
  glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ + 0.5f);
  glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ + 0.5f);
  glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ + 0.5f);
  glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ + 0.5f);
  glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ - 0.5f);
  glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ - 0.5f);
  glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ - 0.5f);
  glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ + 0.5f);
  glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ - 0.5f);
  glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ + 0.5f);
  glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ - 0.5f);
  glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ + 0.5f);
  glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ - 0.5f);
  glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ + 0.5f);
  glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ - 0.5f);
  glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ - 0.5f);
  glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ - 0.5f);
  glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ - 0.5f);
  glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ + 0.5f);
  glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ + 0.5f);
  glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ + 0.5f);
  glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ + 0.5f);
  glEnd();
}","public void render(){
  glClearColor(world.getDaylightColor().x,world.getDaylightColor().y,world.getDaylightColor().z,1.0f);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glLoadIdentity();
  player.render();
  world.render();
  Vector3f blockPosition=player.calcViewBlockPosition();
  if (blockPosition != null) {
    int bpX=(int)blockPosition.x;
    int bpY=(int)blockPosition.y;
    int bpZ=(int)blockPosition.z;
    glColor3f(1.0f,0.0f,0.0f);
    glLineWidth(4.0f);
    glBegin(GL_LINES);
    glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ - 0.5f);
    glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ - 0.5f);
    glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ + 0.5f);
    glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ + 0.5f);
    glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ + 0.5f);
    glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ + 0.5f);
    glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ - 0.5f);
    glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ - 0.5f);
    glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ - 0.5f);
    glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ + 0.5f);
    glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ - 0.5f);
    glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ + 0.5f);
    glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ - 0.5f);
    glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ + 0.5f);
    glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ - 0.5f);
    glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ + 0.5f);
    glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ - 0.5f);
    glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ - 0.5f);
    glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ - 0.5f);
    glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ - 0.5f);
    glVertex3f(bpX - 0.5f,bpY - 0.5f,bpZ + 0.5f);
    glVertex3f(bpX - 0.5f,bpY + 0.5f,bpZ + 0.5f);
    glVertex3f(bpX + 0.5f,bpY - 0.5f,bpZ + 0.5f);
    glVertex3f(bpX + 0.5f,bpY + 0.5f,bpZ + 0.5f);
    glEnd();
  }
}",0.2612855007473841
1359,"private boolean isPlayerStandingOnGround(){
  if (getParent() != null) {
    return getParent().isHitting(new Vector3f(getPosition().x,getPosition().y - PLAYER_HEIGHT,getPosition().z));
  }
 else {
    return false;
  }
}","private boolean isPlayerStandingOnGround(){
  if (getParent() != null) {
    return getParent().isHitting(new Vector3f(getPosition().x + 0.5f,getPosition().y - PLAYER_HEIGHT,getPosition().z + 0.5f));
  }
 else {
    return false;
  }
}",0.9692982456140352
1360,"public Vector3f calcViewBlockPosition(){
  Vector3f blockPosition=new Vector3f(position);
  Vector2f viewingDirectionHorizontal=new Vector2f((float)Math.sin(Math.toRadians(yaw)),-1f * (float)Math.cos(Math.toRadians(yaw)));
  Vector2f viewingDirectionVertical=new Vector2f(-1f * (float)Math.sin(Math.toRadians(pitch)),(float)Math.cos(Math.toRadians(pitch)));
  blockPosition.x+=4f * viewingDirectionHorizontal.x;
  blockPosition.y+=4f * viewingDirectionVertical.x;
  blockPosition.z+=4f * viewingDirectionHorizontal.y;
  return blockPosition;
}","public Vector3f calcViewBlockPosition(){
  Vector3f blockPosition=new Vector3f(position);
  Vector2f viewingDirectionHorizontal=new Vector2f((float)Math.sin(Math.toRadians(yaw)),-1f * (float)Math.cos(Math.toRadians(yaw)));
  Vector2f viewingDirectionVertical=new Vector2f(-1f * (float)Math.sin(Math.toRadians(pitch)),(float)Math.cos(Math.toRadians(pitch)));
  for (int z=0; z < 4; z++) {
    blockPosition.x+=viewingDirectionHorizontal.x * viewingDirectionVertical.y;
    blockPosition.y+=viewingDirectionVertical.x;
    blockPosition.z+=viewingDirectionHorizontal.y * viewingDirectionVertical.y;
    if (parent.getBlock(blockPosition) != 0) {
      return blockPosition;
    }
  }
  return null;
}",0.8251410153102336
1361,"private void processMovement(long delta){
  if (getParent() != null) {
    if (Keyboard.isKeyDown(Keyboard.KEY_R)) {
      resetPlayer();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_T)) {
      parent.generateTrees();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_W)) {
      walkForward();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_S)) {
      walkBackwards();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_A)) {
      strafeLeft();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_D)) {
      strafeRight();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_SPACE)) {
      jump();
    }
    if (!parent.isHitting(new Vector3f(getPosition().x,getPosition().y - PLAYER_HEIGHT,getPosition().z))) {
      if (gravity > -MAX_GRAVITY) {
        gravity-=1;
      }
      getPosition().y+=(gravity / 1000.0f) * delta;
    }
 else     if (gravity > 0.0f) {
      getPosition().y+=(gravity / 1000.0f) * delta;
    }
    if (isObjectInFrontOfPlayer()) {
      accX=0;
      accZ=0;
    }
    getPosition().x+=(accX / 1000.0f) * delta;
    getPosition().z+=(accZ / 1000.0f) * delta;
    accX=0;
    accZ=0;
  }
}","private void processMovement(long delta){
  if (getParent() != null) {
    if (Keyboard.isKeyDown(Keyboard.KEY_R)) {
      resetPlayer();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_T)) {
      parent.generateTrees();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_W)) {
      walkForward();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_S)) {
      walkBackwards();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_A)) {
      strafeLeft();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_D)) {
      strafeRight();
    }
    if (Keyboard.isKeyDown(Keyboard.KEY_SPACE)) {
      jump();
    }
    boolean hitting=parent.isHitting(new Vector3f(getPosition().x + 0.5f,getPosition().y - PLAYER_HEIGHT,getPosition().z + 0.5f));
    if (!hitting) {
      if (gravity > -MAX_GRAVITY) {
        gravity-=0.5f;
      }
      getPosition().y+=(gravity / 1000.0f) * delta;
    }
 else     if (gravity > 0.0f) {
      getPosition().y+=(gravity / 1000.0f) * delta;
    }
 else {
      gravity=0.0f;
    }
    Vector2f dir=new Vector2f((float)accX,(float)accZ);
    try {
      dir.normalise();
    }
 catch (    Exception e) {
    }
    if (checkForCollision(new Vector3f(getPosition().x + dir.x * 0.1f,getPosition().y - PLAYER_HEIGHT + 1,getPosition().z + dir.y * 0.1f))) {
      accX=0;
      accZ=0;
    }
    getPosition().x+=(accX / 1000.0f) * delta;
    getPosition().z+=(accZ / 1000.0f) * delta;
    accX=0;
    accZ=0;
  }
}",0.8463676061929337
1362,"public void init(){
  updateThread.start();
  Sphere s=new Sphere();
  displayListSun=glGenLists(1);
  glNewList(displayListSun,GL_COMPILE);
  glColor4f(1.0f,0.8f,0.0f,1.0f);
  s.draw(120.0f,16,32);
  glEndList();
}","public void init(){
  updateThread.start();
  Sphere s=new Sphere();
  displayListSun=glGenLists(1);
  glNewList(displayListSun,GL_COMPILE);
  glColor4f(1.0f,0.8f,0.0f,1.0f);
  s.draw(256.0f,16,32);
  glEndList();
}",0.9906976744186048
1363,"/** 
 * @return the player
 */
public Player getPlayer(){
  return player;
}","/** 
 * TODO
 */
public Player getPlayer(){
  return player;
}",0.8405797101449275
1364,"/** 
 * Sets the type of a block at a given position.
 * @param pos
 * @param type
 */
public final void setBlock(Vector3f pos,int type){
  Vector3f chunkPos=calcChunkPos(pos);
  Vector3f blockCoord=calcBlockPos(pos,chunkPos);
  try {
    Chunk c=chunks[(int)chunkPos.x][(int)chunkPos.y][(int)chunkPos.z];
    if (c == null) {
      c=new Chunk(this,new Vector3f(chunkPos.x,chunkPos.y,chunkPos.z));
      chunks[(int)chunkPos.x][(int)chunkPos.y][(int)chunkPos.z]=c;
    }
    c.setBlock(blockCoord,type,true);
    chunkUpdateQueue.add(c);
  }
 catch (  Exception e) {
    return;
  }
}","/** 
 * Sets the type of a block at a given position.
 */
public final void setBlock(Vector3f pos,int type){
  Vector3f chunkPos=calcChunkPos(pos);
  Vector3f blockCoord=calcBlockPos(pos,chunkPos);
  try {
    Chunk c=chunks[(int)chunkPos.x][(int)chunkPos.y][(int)chunkPos.z];
    Chunk c1=chunks[(int)chunkPos.x - 1][(int)chunkPos.y][(int)chunkPos.z];
    Chunk c2=chunks[(int)chunkPos.x + 1][(int)chunkPos.y][(int)chunkPos.z];
    Chunk c3=chunks[(int)chunkPos.x][(int)chunkPos.y][(int)chunkPos.z - 1];
    Chunk c4=chunks[(int)chunkPos.x][(int)chunkPos.y][(int)chunkPos.z + 1];
    c.setBlock(blockCoord,type,true);
    if ((int)blockCoord.x == 0) {
      c1.dirty=true;
      chunkUpdateQueue.add(c1);
    }
 else     if ((int)blockCoord.x == (int)Chunk.chunkDimensions.x - 1) {
      c2.dirty=true;
      chunkUpdateQueue.add(c2);
    }
    if ((int)blockCoord.z == 0) {
      c3.dirty=true;
      chunkUpdateQueue.add(c3);
    }
 else     if ((int)blockCoord.z == (int)Chunk.chunkDimensions.z - 1) {
      c4.dirty=true;
      chunkUpdateQueue.add(c4);
    }
    chunkUpdateQueue.add(c);
  }
 catch (  Exception e) {
    return;
  }
}",0.4475362318840579
1365,"/** 
 * Calculate the position of a world-block within a specific chunk.
 */
private Vector3f calcBlockPos(Vector3f pos,Vector3f chunkPos){
  return new Vector3f(pos.x - (chunkPos.x * Chunk.chunkDimensions.x),pos.y - (chunkPos.y * Chunk.chunkDimensions.y),pos.z - (chunkPos.z * Chunk.chunkDimensions.z));
}","/** 
 * Calculate the position of a world-block within a specific chunk.
 */
private Vector3f calcBlockPos(Vector3f pos,Vector3f chunkPos){
  if (pos != null && chunkPos != null) {
    return new Vector3f(pos.x - (chunkPos.x * Chunk.chunkDimensions.x),pos.y - (chunkPos.y * Chunk.chunkDimensions.y),pos.z - (chunkPos.z * Chunk.chunkDimensions.z));
  }
  return null;
}",0.9080118694362018
1366,"/** 
 * Calculate the corresponding chunk for a given position within the world.
 */
private Vector3f calcChunkPos(Vector3f pos){
  return new Vector3f((int)(pos.x / Chunk.chunkDimensions.x),(int)(pos.y / Chunk.chunkDimensions.y),(int)(pos.z / Chunk.chunkDimensions.z));
}","/** 
 * Calculate the corresponding chunk for a given position within the world.
 */
private Vector3f calcChunkPos(Vector3f pos){
  if (pos != null) {
    return new Vector3f((int)(pos.x / Chunk.chunkDimensions.x),(int)(pos.y / Chunk.chunkDimensions.y),(int)(pos.z / Chunk.chunkDimensions.z));
  }
  return null;
}",0.9283276450511946
1367,"@Override public void render(){
  glPushMatrix();
  glDisable(GL_FOG);
  glTranslatef(Configuration.viewingDistanceInChunks.x * Chunk.chunkDimensions.x,Configuration.viewingDistanceInChunks.y * Chunk.chunkDimensions.y * 2f,Configuration.viewingDistanceInChunks.z * Chunk.chunkDimensions.z);
  glCallList(displayListSun);
  glEnable(GL_FOG);
  glPopMatrix();
  for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
    for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
      for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
        Chunk c=chunks[x][y][z];
        if (c != null) {
          c.render();
        }
      }
    }
  }
}","@Override public void render(){
  glPushMatrix();
  glDisable(GL_FOG);
  glTranslatef(Configuration.viewingDistanceInChunks.x * Chunk.chunkDimensions.x * 1.5f,Configuration.viewingDistanceInChunks.y * Chunk.chunkDimensions.y,Configuration.viewingDistanceInChunks.z * Chunk.chunkDimensions.z * 1.5f);
  glCallList(displayListSun);
  glEnable(GL_FOG);
  glPopMatrix();
  for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
    for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
      for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
        Chunk c=chunks[x][y][z];
        if (c != null) {
          c.render();
        }
      }
    }
  }
}",0.9024211298606016
1368,"private HyperLogLogPlus(int p,int sp,int[] sparseSet,RegisterSet registerSet){
  if ((p < 4) || ((p > sp) && (sp != 0))) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (sp > 32) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.p=p;
  m=1 << p;
  format=Format.NORMAL;
  this.registerSet=registerSet;
  if (registerSet == null) {
    if (sp > 0) {
      format=Format.SPARSE;
      this.sp=sp;
      sm=1 << sp;
      if (sparseSet == null) {
        this.sparseSet=EMPTY_SPARSE;
      }
 else {
        this.sparseSet=sparseSet;
      }
      sparseSetThreshold=(int)(m * 0.75);
    }
 else {
      this.registerSet=new RegisterSet(1 << p);
    }
  }
  this.alphaMM=HyperLogLog.getAlphaMM(p,m);
}","private HyperLogLogPlus(int p,int sp,int[] sparseSet,RegisterSet registerSet){
  if ((p < 4) || ((p > sp) && (sp != 0))) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (sp > 32) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.p=p;
  m=p > 30 ? Integer.MAX_VALUE : 1 << p;
  format=Format.NORMAL;
  this.registerSet=registerSet;
  if (registerSet == null) {
    if (sp > 0) {
      format=Format.SPARSE;
      this.sp=sp;
      sm=sp > 30 ? Integer.MAX_VALUE : 1 << sp;
      if (sparseSet == null) {
        this.sparseSet=EMPTY_SPARSE;
      }
 else {
        this.sparseSet=sparseSet;
      }
      sparseSetThreshold=(int)(m * 0.75);
    }
 else {
      this.registerSet=new RegisterSet(m);
    }
  }
  this.alphaMM=HyperLogLog.getAlphaMM(p,m);
}",0.9570871261378412
1369,"@Override public boolean equals(Object obj){
  if (!(obj instanceof HyperLogLogPlus)) {
    return false;
  }
  HyperLogLogPlus other=(HyperLogLogPlus)obj;
  if (other.format != format) {
    return false;
  }
  if (format == Format.NORMAL) {
    return Arrays.equals(registerSet.readOnlyBits(),other.registerSet.readOnlyBits());
  }
 else {
    mergeTempList();
    other.mergeTempList();
    return Arrays.equals(sparseSet,sparseSet);
  }
}","@Override public boolean equals(Object obj){
  if (!(obj instanceof HyperLogLogPlus)) {
    return false;
  }
  HyperLogLogPlus other=(HyperLogLogPlus)obj;
  if (other.format != format) {
    return false;
  }
  if (format == Format.NORMAL) {
    return Arrays.equals(registerSet.readOnlyBits(),other.registerSet.readOnlyBits());
  }
 else {
    mergeTempList();
    other.mergeTempList();
    return Arrays.equals(sparseSet,other.sparseSet);
  }
}",0.9932584269662922
1370,"@Test public void testAccuracyStrings(){
  int seed=7364181;
  Random r=new Random(seed);
  int numItems=1000000;
  String[] xs=new String[numItems];
  int maxScale=20;
  for (int i=0; i < xs.length; ++i) {
    int scale=r.nextInt(maxScale);
    xs[i]=RandomStringUtils.random(scale);
  }
  double epsOfTotalCount=0.0001;
  double confidence=0.99;
  CountMinSketch sketch=new CountMinSketch(epsOfTotalCount,confidence,seed);
  for (  String x : xs) {
    sketch.add(x,1);
  }
  Map<String,Long> actualFreq=new HashMap<String,Long>();
  for (  String x : xs) {
    Long val=actualFreq.get(x);
    if (val == null) {
      actualFreq.put(x,1L);
    }
 else {
      actualFreq.put(x,val + 1L);
    }
  }
  sketch=CountMinSketch.deserialize(CountMinSketch.serialize(sketch));
  int numErrors=0;
  for (int i=0; i < actualFreq.size(); ++i) {
    Long value=actualFreq.get(i);
    long lvalue=(value == null) ? 0 : value;
    double ratio=1.0 * (sketch.estimateCount(i) - lvalue) / xs.length;
    if (ratio > 1.0001) {
      numErrors++;
    }
  }
  double pCorrect=1 - 1.0 * numErrors / actualFreq.size();
  assertTrue(""String_Node_Str"" + confidence + ""String_Node_Str""+ pCorrect,pCorrect > confidence);
}","@Test public void testAccuracyStrings(){
  int seed=7364181;
  Random r=new Random(seed);
  int numItems=1000000;
  int absentItems=numItems * 10;
  String[] xs=new String[numItems];
  int maxScale=20;
  for (int i=0; i < numItems; i++) {
    int scale=r.nextInt(maxScale);
    xs[i]=RandomStringUtils.random(scale);
  }
  double epsOfTotalCount=0.0001;
  double confidence=0.99;
  CountMinSketch sketch=new CountMinSketch(epsOfTotalCount,confidence,seed);
  for (  String x : xs) {
    sketch.add(x,1);
  }
  Map<String,Long> actualFreq=new HashMap<String,Long>();
  for (  String x : xs) {
    Long val=actualFreq.get(x);
    if (val == null) {
      actualFreq.put(x,1L);
    }
 else {
      actualFreq.put(x,val + 1L);
    }
  }
  sketch=CountMinSketch.deserialize(CountMinSketch.serialize(sketch));
  int numErrors=0;
  for (  Map.Entry<String,Long> entry : actualFreq.entrySet()) {
    String key=entry.getKey();
    long count=entry.getValue();
    double ratio=((double)(sketch.estimateCount(key) - count)) / numItems;
    if (ratio > epsOfTotalCount) {
      numErrors++;
    }
  }
  for (int i=0; i < absentItems; i++) {
    int scale=r.nextInt(maxScale);
    String key=RandomStringUtils.random(scale);
    Long value=actualFreq.get(key);
    long count=(value == null) ? 0L : value;
    double ratio=((double)(sketch.estimateCount(key) - count)) / numItems;
    if (ratio > epsOfTotalCount) {
      numErrors++;
    }
  }
  double pCorrect=1.0 - ((double)numErrors) / (numItems + absentItems);
  System.out.println(pCorrect);
  assertTrue(""String_Node_Str"" + confidence + ""String_Node_Str""+ pCorrect,pCorrect > confidence);
  assertTrue(""String_Node_Str"" + confidence + ""String_Node_Str""+ pCorrect,pCorrect > confidence);
}",0.6494037478705281
1371,"@Test public void testAccuracy(){
  int seed=7364181;
  Random r=new Random(seed);
  int numItems=1000000;
  int[] xs=new int[numItems];
  int maxScale=20;
  for (int i=0; i < xs.length; ++i) {
    int scale=r.nextInt(maxScale);
    xs[i]=r.nextInt(1 << scale);
  }
  double epsOfTotalCount=0.0001;
  double confidence=0.99;
  CountMinSketch sketch=new CountMinSketch(epsOfTotalCount,confidence,seed);
  for (  int x : xs) {
    sketch.add(x,1);
  }
  int[] actualFreq=new int[1 << maxScale];
  for (  int x : xs) {
    actualFreq[x]++;
  }
  sketch=CountMinSketch.deserialize(CountMinSketch.serialize(sketch));
  int numErrors=0;
  for (int i=0; i < actualFreq.length; ++i) {
    double ratio=1.0 * (sketch.estimateCount(i) - actualFreq[i]) / xs.length;
    if (ratio > 1.0001) {
      numErrors++;
    }
  }
  double pCorrect=1 - 1.0 * numErrors / actualFreq.length;
  assertTrue(""String_Node_Str"" + confidence + ""String_Node_Str""+ pCorrect,pCorrect > confidence);
}","@Test public void testAccuracy(){
  int seed=7364181;
  Random r=new Random(seed);
  int numItems=1000000;
  int[] xs=new int[numItems];
  int maxScale=20;
  for (int i=0; i < numItems; i++) {
    int scale=r.nextInt(maxScale);
    xs[i]=r.nextInt(1 << scale);
  }
  double epsOfTotalCount=0.0001;
  double confidence=0.99;
  CountMinSketch sketch=new CountMinSketch(epsOfTotalCount,confidence,seed);
  for (  int x : xs) {
    sketch.add(x,1);
  }
  int[] actualFreq=new int[1 << maxScale];
  for (  int x : xs) {
    actualFreq[x]++;
  }
  sketch=CountMinSketch.deserialize(CountMinSketch.serialize(sketch));
  int numErrors=0;
  for (int i=0; i < actualFreq.length; ++i) {
    double ratio=((double)(sketch.estimateCount(i) - actualFreq[i])) / numItems;
    if (ratio > epsOfTotalCount) {
      numErrors++;
    }
  }
  double pCorrect=1.0 - ((double)numErrors) / actualFreq.length;
  assertTrue(""String_Node_Str"" + confidence + ""String_Node_Str""+ pCorrect,pCorrect > confidence);
}",0.8960573476702509
1372,"private void compressFully(){
  Long[] allNodes=node2count.keySet().toArray(new Long[node2count.size()]);
  for (  long node : allNodes) {
    compressDownward(node);
  }
}","private void compressFully(){
  Long[] allNodes=node2count.keySet().toArray(new Long[node2count.size()]);
  for (  long node : allNodes) {
    if (!isRoot(node)) {
      compressDownward(node);
    }
  }
}",0.9124668435013262
1373,"@Test public void testComprehensiveOnMixture(){
  RandomEngine r=new MersenneTwister64(0);
  Normal[] dists=new Normal[]{new Normal(100,50,r),new Normal(150,20,r),new Normal(500,300,r),new Normal(10000,10000,r),new Normal(1200,300,r)};
  for (  int numSamples : new int[]{1,10,100,1000,10000}) {
    long[][] samples=new long[dists.length][];
    for (int i=0; i < dists.length; ++i) {
      samples[i]=new long[numSamples];
      for (int j=0; j < samples[i].length; ++j) {
        samples[i][j]=(long)Math.max(0,dists[i].nextDouble());
      }
    }
    double compressionFactor=1000;
    int logCapacity=1;
    long max=0;
    for (    long[] s : samples) {
      for (      long x : s)       max=Math.max(max,x);
    }
    for (double scale=1; scale < max; scale*=2, logCapacity++) {
      ;
    }
    double eps=logCapacity / compressionFactor;
    QDigest[] digests=new QDigest[dists.length];
    for (int i=0; i < digests.length; ++i) {
      digests[i]=new QDigest(compressionFactor);
      for (      long x : samples[i]) {
        digests[i].offer(x);
      }
    }
    int numTotal=0;
    for (int i=0; i < digests.length; ++i) {
      for (double q=0; q <= 1; q+=0.01) {
        long res=digests[i].getQuantile(q);
        double[] actualRank=actualRankOf(res,samples[i]);
        assertTrue(actualRank[0] + ""String_Node_Str"" + actualRank[1]+ ""String_Node_Str""+ q,q >= actualRank[0] - eps && q <= actualRank[1] + eps);
      }
      numTotal+=samples[i].length;
      long[] total=new long[numTotal];
      int offset=0;
      QDigest totalDigest=new QDigest(compressionFactor);
      for (int j=0; j <= i; ++j) {
        System.arraycopy(samples[j],0,total,offset,samples[j].length);
        offset+=samples[j].length;
        totalDigest=QDigest.unionOf(totalDigest,digests[j]);
      }
      for (double q=0; q <= 1; q+=0.01) {
        long res=totalDigest.getQuantile(q);
        double[] actualRank=actualRankOf(res,total);
        assertTrue(actualRank[0] + ""String_Node_Str"" + actualRank[1]+ ""String_Node_Str""+ q,q >= actualRank[0] - eps && q <= actualRank[1] + eps);
      }
    }
  }
}","@Test public void testComprehensiveOnMixture(){
  RandomEngine r=new MersenneTwister64(0);
  Normal[] dists=new Normal[]{new Normal(100,50,r),new Normal(150,20,r),new Normal(500,300,r),new Normal(10000,10000,r),new Normal(1200,300,r)};
  for (  int numSamples : new int[]{1,10,100,1000,10000}) {
    long[][] samples=new long[dists.length][];
    for (int i=0; i < dists.length; ++i) {
      samples[i]=new long[numSamples];
      for (int j=0; j < samples[i].length; ++j) {
        samples[i][j]=(long)Math.max(0,dists[i].nextDouble());
      }
    }
    double compressionFactor=1000;
    int logCapacity=1;
    long max=0;
    for (    long[] s : samples) {
      for (      long x : s)       max=Math.max(max,x);
    }
    for (double scale=1; scale < max; scale*=2, logCapacity++) {
      ;
    }
    double eps=logCapacity / compressionFactor;
    QDigest[] digests=new QDigest[dists.length];
    for (int i=0; i < digests.length; ++i) {
      digests[i]=new QDigest(compressionFactor);
      for (      long x : samples[i]) {
        digests[i].offer(x);
      }
      assertEquals(samples[i].length,digests[i].computeActualSize());
    }
    int numTotal=0;
    for (int i=0; i < digests.length; ++i) {
      for (double q=0; q <= 1; q+=0.01) {
        long res=digests[i].getQuantile(q);
        double[] actualRank=actualRankOf(res,samples[i]);
        assertTrue(actualRank[0] + ""String_Node_Str"" + actualRank[1]+ ""String_Node_Str""+ q,q >= actualRank[0] - eps && q <= actualRank[1] + eps);
      }
      numTotal+=samples[i].length;
      long[] total=new long[numTotal];
      int offset=0;
      QDigest totalDigest=new QDigest(compressionFactor);
      long expectedSize=0;
      for (int j=0; j <= i; ++j) {
        System.arraycopy(samples[j],0,total,offset,samples[j].length);
        offset+=samples[j].length;
        totalDigest=QDigest.unionOf(totalDigest,digests[j]);
        expectedSize+=samples[j].length;
      }
      assertEquals(expectedSize,totalDigest.computeActualSize());
      for (double q=0; q <= 1; q+=0.01) {
        long res=totalDigest.getQuantile(q);
        double[] actualRank=actualRankOf(res,total);
        assertTrue(actualRank[0] + ""String_Node_Str"" + actualRank[1]+ ""String_Node_Str""+ q,q >= actualRank[0] - eps && q <= actualRank[1] + eps);
      }
    }
  }
}",0.9538043478260868
1374,"@Override public byte[] getBytes() throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(baos);
  dos.writeInt(-VERSION);
  dos.write(Varint.writeUnsignedVarInt(p));
  dos.write(Varint.writeUnsignedVarInt(sp));
switch (format) {
case NORMAL:
    dos.write(Varint.writeUnsignedVarInt(0));
  dos.write(Varint.writeUnsignedVarInt(registerSet.size * 4));
for (int x : registerSet.bits()) {
  dos.writeInt(x);
}
break;
case SPARSE:
dos.write(Varint.writeUnsignedVarInt(1));
mergeTempList();
dos.write(Varint.writeUnsignedVarInt(sparseSet.length));
int prevMergedDelta=0;
for (int k : sparseSet) {
dos.write(deltaAdd(k,prevMergedDelta));
prevMergedDelta=k;
}
break;
}
return baos.toByteArray();
}","@Override public byte[] getBytes() throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(baos);
  dos.writeInt(-VERSION);
  Varint.writeUnsignedVarInt(p,dos);
  Varint.writeUnsignedVarInt(sp,dos);
switch (format) {
case NORMAL:
    Varint.writeUnsignedVarInt(0,dos);
  Varint.writeUnsignedVarInt(registerSet.size * 4,dos);
for (int x : registerSet.bits()) {
  dos.writeInt(x);
}
break;
case SPARSE:
Varint.writeUnsignedVarInt(1,dos);
mergeTempList();
Varint.writeUnsignedVarInt(sparseSet.length,dos);
int prevMergedDelta=0;
for (int k : sparseSet) {
Varint.writeUnsignedVarInt(k - prevMergedDelta,dos);
prevMergedDelta=k;
}
break;
}
return baos.toByteArray();
}",0.890530557421088
1375,"private static HyperLogLogPlus decodeBytes(DataInputStream oi) throws IOException {
  int p=Varint.readUnsignedVarInt(oi);
  int sp=Varint.readUnsignedVarInt(oi);
  int formatType=Varint.readUnsignedVarInt(oi);
  if (formatType == 0) {
    int size=Varint.readUnsignedVarInt(oi);
    byte[] longArrayBytes=new byte[size];
    oi.readFully(longArrayBytes);
    HyperLogLogPlus hyperLogLogPlus=new HyperLogLogPlus(p,sp,new RegisterSet((int)Math.pow(2,p),Bits.getBits(longArrayBytes)));
    hyperLogLogPlus.format=Format.NORMAL;
    return hyperLogLogPlus;
  }
 else {
    int[] rehydratedSparseSet=new int[Varint.readUnsignedVarInt(oi)];
    int prevDeltaRead=0;
    for (int i=0; i < rehydratedSparseSet.length; i++) {
      int nextVal=HyperLogLogPlus.deltaRead(Varint.readUnsignedVarInt(oi),prevDeltaRead);
      rehydratedSparseSet[i]=nextVal;
      prevDeltaRead=nextVal;
    }
    HyperLogLogPlus hyperLogLogPlus=new HyperLogLogPlus(p,sp,rehydratedSparseSet);
    hyperLogLogPlus.format=Format.SPARSE;
    return hyperLogLogPlus;
  }
}","private static HyperLogLogPlus decodeBytes(DataInputStream oi) throws IOException {
  int p=Varint.readUnsignedVarInt(oi);
  int sp=Varint.readUnsignedVarInt(oi);
  int formatType=Varint.readUnsignedVarInt(oi);
  if (formatType == 0) {
    int size=Varint.readUnsignedVarInt(oi);
    byte[] longArrayBytes=new byte[size];
    oi.readFully(longArrayBytes);
    HyperLogLogPlus hyperLogLogPlus=new HyperLogLogPlus(p,sp,new RegisterSet((int)Math.pow(2,p),Bits.getBits(longArrayBytes)));
    hyperLogLogPlus.format=Format.NORMAL;
    return hyperLogLogPlus;
  }
 else {
    int[] rehydratedSparseSet=new int[Varint.readUnsignedVarInt(oi)];
    int prevDeltaRead=0;
    for (int i=0; i < rehydratedSparseSet.length; i++) {
      int nextVal=Varint.readUnsignedVarInt(oi) + prevDeltaRead;
      rehydratedSparseSet[i]=nextVal;
      prevDeltaRead=nextVal;
    }
    HyperLogLogPlus hyperLogLogPlus=new HyperLogLogPlus(p,sp,rehydratedSparseSet);
    hyperLogLogPlus.format=Format.SPARSE;
    return hyperLogLogPlus;
  }
}",0.984900146127618
1376,"/** 
 * Merge this HLL++ instance with another! The power of friends! <p/> This works very similarly to the merge with temp list function. <p/> However, in this case, both lists will need their own delta decoding and neither will have to worry about consuming duplicates.
 * @param other
 * @return the new sparse set
 */
private int[] mergeEstimators(HyperLogLogPlus other){
  other.mergeTempList();
  int[] tmp=other.getSparseSet();
  mergeTempList();
  int[] set=sparseSet;
  List<Integer> newSet=new ArrayList<Integer>();
  int seti=0;
  int tmpi=0;
  while (seti < set.length || tmpi < tmp.length) {
    if (seti >= set.length) {
      newSet.add(tmp[tmpi++]);
    }
 else     if (tmpi >= tmp.length) {
      newSet.add(set[seti++]);
    }
 else {
      int setVal=set[seti];
      int tmpVal=tmp[tmpi];
      if (getSparseIndex(setVal) == getSparseIndex(tmpVal)) {
        newSet.add(Math.min(setVal,tmpVal));
        tmpi++;
        seti++;
      }
 else       if (setVal < tmpVal) {
        newSet.add(setVal);
        seti++;
      }
 else {
        newSet.add(tmpVal);
        tmpi++;
      }
    }
  }
  return toIntArray(newSet);
}","/** 
 * Merge this HLL++ instance with another! The power of friends! <p/> This works very similarly to the merge with temp list function. <p/> However, in this case, both lists will need their own delta decoding and neither will have to worry about consuming duplicates.
 * @param other
 * @return the new sparse set
 */
private int[] mergeEstimators(HyperLogLogPlus other){
  other.mergeTempList();
  int[] tmp=other.getSparseSet();
  mergeTempList();
  int[] set=sparseSet;
  List<Integer> newSet=new ArrayList<Integer>();
  int seti=0;
  int tmpi=0;
  while (seti < set.length || tmpi < tmp.length) {
    if (seti >= set.length) {
      newSet.add(tmp[tmpi++]);
    }
 else     if (tmpi >= tmp.length) {
      newSet.add(set[seti++]);
    }
 else {
      int setVal=set[seti];
      int tmpVal=tmp[tmpi];
      if (getSparseIndex(setVal) == getSparseIndex(tmpVal)) {
        newSet.add(Math.min(setVal,tmpVal));
        tmpi++;
        seti++;
      }
 else       if (getSparseIndex(setVal) < getSparseIndex(tmpVal)) {
        newSet.add(setVal);
        seti++;
      }
 else {
        newSet.add(tmpVal);
        tmpi++;
      }
    }
  }
  return toIntArray(newSet);
}",0.9861949956859362
1377,"private double getBias(int[] nearestNeighbors){
  double[] biasVector=biasData[p - 4];
  double biasTotal=0.0d;
  for (  int nearestNeighbor : nearestNeighbors) {
    biasTotal+=biasVector[nearestNeighbor];
  }
  return biasTotal / (biasVector.length);
}","private double getBias(int[] nearestNeighbors){
  double[] biasVector=biasData[p - 4];
  double biasTotal=0.0d;
  for (  int nearestNeighbor : nearestNeighbors) {
    biasTotal+=biasVector[nearestNeighbor];
  }
  return biasTotal / (nearestNeighbors.length);
}",0.9494163424124512
1378,"public static QDigest unionOf(QDigest a,QDigest b){
  if (a.compressionFactor != b.compressionFactor) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + a.compressionFactor + ""String_Node_Str""+ ""String_Node_Str""+ b.compressionFactor);
  }
  if (a.capacity > b.capacity) {
    return unionOf(b,a);
  }
  QDigest res=new QDigest(a.compressionFactor);
  res.capacity=a.capacity;
  for (  long k : a.node2count.keySet()) {
    res.node2count.put(k,a.node2count.get(k));
  }
  if (b.capacity > res.capacity) {
    res.rebuildToCapacity(b.capacity);
  }
  for (  long k : b.node2count.keySet()) {
    res.node2count.put(k,b.get(k) + res.get(k));
  }
  res.compressFully();
  return res;
}","public static QDigest unionOf(QDigest a,QDigest b){
  if (a.compressionFactor != b.compressionFactor) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + a.compressionFactor + ""String_Node_Str""+ ""String_Node_Str""+ b.compressionFactor);
  }
  if (a.capacity > b.capacity) {
    return unionOf(b,a);
  }
  QDigest res=new QDigest(a.compressionFactor);
  res.capacity=a.capacity;
  res.size=a.size + b.size;
  for (  long k : a.node2count.keySet()) {
    res.node2count.put(k,a.node2count.get(k));
  }
  if (b.capacity > res.capacity) {
    res.rebuildToCapacity(b.capacity);
  }
  for (  long k : b.node2count.keySet()) {
    res.node2count.put(k,b.get(k) + res.get(k));
  }
  res.compressFully();
  return res;
}",0.9807162534435262
1379,"@Override public void offer(long value){
  if (value < 0 || value == Long.MAX_VALUE) {
    throw new IllegalArgumentException(""String_Node_Str"" + (Long.MAX_VALUE - 1));
  }
  if (value >= capacity) {
    rebuildToCapacity(Long.highestOneBit(value) << 1);
  }
  long leaf=value2leaf(value);
  node2count.put(leaf,get(leaf) + 1);
  size++;
  compressUpward(leaf);
  if (node2count.size() > 3 * compressionFactor) {
    compressFully();
  }
}","@Override public void offer(long value){
  if (value < 0 || value > Long.MAX_VALUE / 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + Long.MAX_VALUE / 2 + ""String_Node_Str"" + value);
  }
  if (value >= capacity) {
    rebuildToCapacity(Long.highestOneBit(value) << 1);
  }
  long leaf=value2leaf(value);
  node2count.put(leaf,get(leaf) + 1);
  size++;
  compressUpward(leaf);
  if (node2count.size() > 3 * compressionFactor) {
    compressFully();
  }
}",0.9525909592061742
1380,"@Override public long getQuantile(double q){
  List<long[]> ranges=toAscRanges();
  long s=0;
  for (  long[] r : ranges) {
    if (s > q * size) {
      return r[1];
    }
    s+=r[2];
  }
  return ranges.get(ranges.size() - 1)[1];
}","@Override public long getQuantile(double q){
  List<long[]> ranges=toAscRanges();
  long s=0;
  for (  long[] r : ranges) {
    s+=r[2];
    if (s > q * size) {
      return r[1];
    }
  }
  return ranges.get(ranges.size() - 1)[1];
}",0.7905982905982906
1381,"private double getBias(int[] nearestNeighbors){
  double[] biasVector=biasData[p - 4];
  double biasTotal=0.0d;
  for (  int nearestNeighbor : nearestNeighbors) {
    biasTotal+=biasVector[nearestNeighbor];
  }
  return biasTotal / (biasVector.length);
}","private double getBias(int[] nearestNeighbors){
  double[] biasVector=biasData[p - 4];
  double biasTotal=0.0d;
  for (  int nearestNeighbor : nearestNeighbors) {
    biasTotal+=biasVector[nearestNeighbor];
  }
  return biasTotal / nearestNeighbors.length;
}",0.9453125
1382,"/** 
 * Encode the sp length idx and, if necessary, the run length. <p/> Start with the 64 bit hash as x. <p/> Find all the bits that belong in the first sp (roughly 25) bits. (This is idx') Get rid of the first p (roughly 18) bits of those. (Those were idx (not prime)) <p/> If all the remaining bits are zero then we are going to need to find and encode the full run length of leading zeros, but this only happens once in 2 ^ (sp - p) or roughly 2 ^ 7 times. <p/> If at least one of them is not zero, then since the run length is determined by bits after p and the idx' contains the first (sp - p) bits of those, then just by putting idx' in the encoding, we will also be giving it all the information it needs to find the run length. <p/> The relationship looks like this: <p/> *******************************************************   <- hashed length of bits | p bits = idx ||     look for leading zeros here     | |      sp bits = idx'     | | all 0s? | <p/> If we have idx', we could theoretically scan it (as per zeroTest) when unencoding and therefore know whether to look for the extra run length information. However, for now we have followed the authors of the paper and put this information in a flag bit at the end of the encoding. <p/> Based on this flag, we know whether to adjust for the missing run length bits. We could also use this flag to compress all the zeros in ""| all 0s? |"", but saving a byte or so once in 128 times is less than the 120 bits spent on the flag elsewhere. Of course, after compression, the losses are not quite so large either way. <p/> The encoding scheme now looks like: <p/> ********************************* <- smaller length of bits (half, but not to scale) | empty ||       sp bits     ||F| |  p bits  || has 1 ||0| <p/> <p/> or if the run length was needed (ie 'all 0s?' was indeed all 0s): <p/> * |      sp bits    || run len ||F| |  p bits ||  0s  |           |1| <p/> <p/> The other notable encoding feature is the inversion of the run length, which just lets the lists be sorted in a convenient way. (Could alternatively sort in reverse, and use descending deltas).
 * @param x  the hash bits
 * @param p  the 'normal' mode precision
 * @param sp the 'sparse' mode precision
 * @return the encoded data as an integer
 */
private int encodeHash(long x,int p,int sp){
  int idx=(int)(x >>> (64 - sp));
  int zeroTest=idx << ((32 - sp) + p);
  if (zeroTest == 0) {
    final int runLength=Long.numberOfLeadingZeros((x << this.p) | (1 << (this.p - 1))) + 1;
    int invrl=runLength ^ 63;
    return idx << 6 | invrl << 1 | 1;
  }
 else {
    return idx << 1;
  }
}","/** 
 * Encode the sp length idx and, if necessary, the run length. <p/> Start with the 64 bit hash as x. <p/> Find all the bits that belong in the first sp (roughly 25) bits. (This is idx') Get rid of the first p (roughly 18) bits of those. (Those were idx (not prime)) <p/> If all the remaining bits are zero then we are going to need to find and encode the full run length of leading zeros, but this only happens once in 2 ^ (sp - p) or roughly 2 ^ 7 times. <p/> If at least one of them is not zero, then since the run length is determined by bits after p and the idx' contains the first (sp - p) bits of those, then just by putting idx' in the encoding, we will also be giving it all the information it needs to find the run length. <p/> The relationship looks like this: <p/> *******************************************************   <- hashed length of bits | p bits = idx ||     look for leading zeros here     | |      sp bits = idx'     | | all 0s? | <p/> If we have idx', we could theoretically scan it (as per zeroTest) when unencoding and therefore know whether to look for the extra run length information. However, for now we have followed the authors of the paper and put this information in a flag bit at the end of the encoding. <p/> Based on this flag, we know whether to adjust for the missing run length bits. We could also use this flag to compress all the zeros in ""| all 0s? |"", but saving a byte or so once in 128 times is less than the 120 bits spent on the flag elsewhere. Of course, after compression, the losses are not quite so large either way. <p/> The encoding scheme now looks like: <p/> ********************************* <- smaller length of bits (half, but not to scale) | empty ||       sp bits     ||F| |  p bits  || has 1 ||0| <p/> <p/> or if the run length was needed (ie 'all 0s?' was indeed all 0s): <p/> * |      sp bits    || run len ||F| |  p bits ||  0s  |           |1| <p/> <p/> The other notable encoding feature is the inversion of the run length, which just lets the lists be sorted in a convenient way. (Could alternatively sort in reverse, and use descending deltas).
 * @param x  the hash bits
 * @param p  the 'normal' mode precision
 * @param sp the 'sparse' mode precision
 * @return the encoded data as an integer
 */
private int encodeHash(long x,int p,int sp){
  int idx=(int)(x >>> (64 - sp));
  int zeroTest=0;
  if (p < sp) {
    zeroTest=idx << ((32 - sp) + p);
  }
  if (zeroTest == 0) {
    final int runLength=Long.numberOfLeadingZeros((x << this.p) | (1 << (this.p - 1))) + 1;
    int invrl=runLength ^ 63;
    return idx << 6 | invrl << 1 | 1;
  }
 else {
    return idx << 1;
  }
}",0.993161094224924
1383,"private List<byte[]> mergeEstimators(List<byte[]> set,HyperLogLogPlus other){
  List<byte[]> tmp=other.sparseSet;
  List<byte[]> newSet=new ArrayList<byte[]>();
  Map<Integer,Integer> indexMap=new HashMap<Integer,Integer>();
  int seti=0;
  int tmpi=0;
  while (seti < set.size() || tmpi < tmp.size()) {
    if (seti >= set.size()) {
      int tmpVal=other.unzipInt(tmp.get(tmpi));
      conditionalAdd(indexMap,tmpVal,newSet);
      tmpi++;
    }
 else     if (tmpi >= tmp.size()) {
      int setVal=unzipInt(set.get(seti));
      conditionalAdd(indexMap,setVal,newSet);
      seti++;
    }
 else {
      int setVal=unzipInt(set.get(seti));
      int tmpVal=other.unzipInt(tmp.get(tmpi));
      if (getSparseIndex(setVal) == getSparseIndex(tmpVal)) {
        int max=Math.max(setVal,tmpVal);
        conditionalAdd(indexMap,max,newSet);
        tmpi++;
        seti++;
      }
 else       if (setVal < tmpVal) {
        conditionalAdd(indexMap,setVal,newSet);
        seti++;
      }
 else {
        conditionalAdd(indexMap,tmpVal,newSet);
        tmpi++;
      }
    }
  }
  old_delta=delta;
  return newSet;
}","private List<byte[]> mergeEstimators(HyperLogLogPlus other){
  other.mergeTmp();
  mergeTmp();
  List<byte[]> set=sparseSet;
  List<byte[]> tmp=other.sparseSet;
  List<byte[]> newSet=new ArrayList<byte[]>();
  Map<Integer,Integer> indexMap=new HashMap<Integer,Integer>();
  int seti=0;
  int tmpi=0;
  while (seti < set.size() || tmpi < tmp.size()) {
    if (seti >= set.size()) {
      int tmpVal=other.unzipInt(tmp.get(tmpi));
      conditionalAdd(indexMap,tmpVal,newSet);
      tmpi++;
    }
 else     if (tmpi >= tmp.size()) {
      int setVal=unzipInt(set.get(seti));
      conditionalAdd(indexMap,setVal,newSet);
      seti++;
    }
 else {
      int setVal=unzipInt(set.get(seti));
      int tmpVal=other.unzipInt(tmp.get(tmpi));
      if (getSparseIndex(setVal) == getSparseIndex(tmpVal)) {
        int min=Math.min(setVal,tmpVal);
        conditionalAdd(indexMap,min,newSet);
        tmpi++;
        seti++;
      }
 else       if (setVal < tmpVal) {
        conditionalAdd(indexMap,setVal,newSet);
        seti++;
      }
 else {
        conditionalAdd(indexMap,tmpVal,newSet);
        tmpi++;
      }
    }
  }
  old_delta=delta;
  return newSet;
}",0.9528841919859092
1384,"@Override public ICardinality merge(ICardinality... estimators) throws CardinalityMergeException {
  if (estimators == null || estimators.length == 0) {
    return this;
  }
  int size=this.sizeof();
  for (  ICardinality estimator : estimators) {
    if (!(estimator instanceof HyperLogLogPlus)) {
      throw new HyperLogLogPlusMergeException(""String_Node_Str"");
    }
    if (estimator.sizeof() != size) {
      throw new HyperLogLogPlusMergeException(""String_Node_Str"");
    }
    HyperLogLogPlus hll=(HyperLogLogPlus)estimator;
    if (format == Format.SPARSE) {
      if (hll.format == Format.SPARSE) {
        if (sparseSet.size() + hll.sparseSet.size() > MaxThreshold) {
          convertToNormal();
          hll.convertToNormal();
        }
 else {
          mergeTmp();
          hll.mergeTmp();
          sparseSet=mergeEstimators(sparseSet,hll);
        }
      }
 else {
        convertToNormal();
      }
    }
 else {
      if (hll.format == Format.SPARSE) {
        hll.convertToNormal();
      }
    }
    if (format != Format.SPARSE) {
      for (int b=0; b < registerSet.count; b++) {
        registerSet.set(b,Math.max(registerSet.get(b),hll.registerSet.get(b)));
      }
    }
  }
  if (format == Format.SPARSE) {
    return new HyperLogLogPlus(p,sp,sparseSet);
  }
  HyperLogLogPlus outEst=new HyperLogLogPlus(p,sp,registerSet);
  outEst.format=Format.NORMAL;
  return outEst;
}","@Override public ICardinality merge(ICardinality... estimators) throws CardinalityMergeException {
  if (estimators == null || estimators.length == 0) {
    return this;
  }
  int size=this.sizeof();
  for (  ICardinality estimator : estimators) {
    if (!(estimator instanceof HyperLogLogPlus)) {
      throw new HyperLogLogPlusMergeException(""String_Node_Str"");
    }
    if (estimator.sizeof() != size) {
      throw new HyperLogLogPlusMergeException(""String_Node_Str"");
    }
    HyperLogLogPlus hll=(HyperLogLogPlus)estimator;
    if (format == Format.SPARSE) {
      if (hll.format == Format.SPARSE) {
        if (sparseSet.size() + hll.sparseSet.size() > MaxThreshold) {
          convertToNormal();
          hll.convertToNormal();
        }
 else {
          sparseSet=mergeEstimators(hll);
        }
      }
 else {
        convertToNormal();
      }
    }
 else {
      if (hll.format == Format.SPARSE) {
        hll.convertToNormal();
      }
    }
    if (format != Format.SPARSE) {
      for (int b=0; b < registerSet.count; b++) {
        registerSet.set(b,Math.max(registerSet.get(b),hll.registerSet.get(b)));
      }
    }
  }
  if (format == Format.SPARSE) {
    return new HyperLogLogPlus(p,sp,sparseSet);
  }
  HyperLogLogPlus outEst=new HyperLogLogPlus(p,sp,registerSet);
  outEst.format=Format.NORMAL;
  return outEst;
}",0.9788629737609328
1385,"private int encodeHash(long x,int p,int sp){
  int idx=(int)(x >>> (64 - sp));
  int zeroTest=idx << (7 + p);
  if (zeroTest == 0) {
    long rho=x & ((1l << (31 - sp)) - 1);
    return (int)(idx << 6 | (Long.numberOfLeadingZeros(rho)) << 1 | 1l);
  }
 else {
    return idx << 7;
  }
}","private int encodeHash(long x,int p,int sp){
  int idx=(int)(x >>> (64 - sp));
  int zeroTest=idx << (7 + p);
  if (zeroTest == 0) {
    final int runLength=Long.numberOfLeadingZeros((x << this.p) | (1 << (this.p - 1))) + 1;
    int invrl=runLength ^ 63;
    return (((idx << 6) | invrl) << 1) | 1;
  }
 else {
    return idx << 7;
  }
}",0.6613162118780096
1386,"private int decodeRunLength(int k){
  if ((k & 1) != 0) {
    return ((k & 127) + (sp - p));
  }
 else {
    return Integer.numberOfLeadingZeros(k << p) + 1;
  }
}","private int decodeRunLength(int k){
  if ((k & 1) != 0) {
    return ((k >>> 1) & 63) ^ 63;
  }
 else {
    return Integer.numberOfLeadingZeros(k << p) + 1;
  }
}",0.9230769230769232
1387,"public HyperLogLogPlus(int p,int sp,List<byte[]> Set,RegisterSet registerSet){
  this.p=p;
  this.sp=sp;
  this.m=(int)Math.pow(2,p);
  this.sm=(int)Math.pow(2,sp);
  this.registerSet=registerSet;
  this.sparseSet=Set;
switch (p) {
case 4:
    alphaMM=0.673 * m * m;
  break;
case 5:
alphaMM=0.697 * m * m;
break;
case 6:
alphaMM=0.709 * m * m;
break;
default :
alphaMM=(0.7213 / (1 + 1.079 / m)) * m * m;
}
}","public HyperLogLogPlus(int p,int sp,List<byte[]> sparseSet,RegisterSet registerSet){
  this.p=p;
  this.sp=sp;
  this.m=(int)Math.pow(2,p);
  this.sm=(int)Math.pow(2,sp);
  this.registerSet=registerSet;
  this.sparseSet=sparseSet;
switch (p) {
case 4:
    alphaMM=0.673 * m * m;
  break;
case 5:
alphaMM=0.697 * m * m;
break;
case 6:
alphaMM=0.709 * m * m;
break;
default :
alphaMM=(0.7213 / (1 + 1.079 / m)) * m * m;
}
}",0.9855421686746988
1388,"private boolean conditionalAdd(Map<Integer,Integer> tmpElementMap,int next,List<byte[]> newSet){
  int idx=getSparseIndex(next);
  int r=decodeRunLength(next);
  if (tmpElementMap.containsKey(idx) && tmpElementMap.get(idx) >= r) {
    return false;
  }
  tmpElementMap.put(idx,r);
  if (newSet.size() == 0) {
    delta=next;
  }
  newSet.add(zipInt(next));
  return true;
}","private boolean conditionalAdd(Map<Integer,Integer> tmpElementMap,int next,List<byte[]> newSet){
}",0.416135881104034
1389,"@Test public void testMerge_ManySparse() throws CardinalityMergeException {
  int numToMerge=20;
  int bits=18;
  int cardinality=10000;
  HyperLogLogPlus[] hyperLogLogs=new HyperLogLogPlus[numToMerge];
  HyperLogLogPlus baseline=new HyperLogLogPlus(bits,25);
  for (int i=0; i < numToMerge; i++) {
    hyperLogLogs[i]=new HyperLogLogPlus(bits,25);
    for (int j=0; j < cardinality; j++) {
      double val=Math.random();
      hyperLogLogs[i].offer(val);
      baseline.offer(val);
    }
  }
  long expectedCardinality=numToMerge * cardinality;
  HyperLogLogPlus hll=hyperLogLogs[0];
  hyperLogLogs=Arrays.asList(hyperLogLogs).subList(1,hyperLogLogs.length).toArray(new HyperLogLogPlus[0]);
  long mergedEstimate=hll.merge(hyperLogLogs).cardinality();
  double se=expectedCardinality * (1.04 / Math.sqrt(Math.pow(2,bits)));
  System.out.println(""String_Node_Str"" + mergedEstimate + ""String_Node_Str""+ (expectedCardinality - (3 * se))+ ""String_Node_Str""+ (expectedCardinality + (3 * se)));
  assertTrue(mergedEstimate >= expectedCardinality - (3 * se));
  assertTrue(mergedEstimate <= expectedCardinality + (3 * se));
}","@Test public void testMerge_ManySparse() throws CardinalityMergeException {
  int numToMerge=20;
  int bits=18;
  int cardinality=10000;
  HyperLogLogPlus[] hyperLogLogs=new HyperLogLogPlus[numToMerge];
  HyperLogLogPlus baseline=new HyperLogLogPlus(bits,25);
  for (int i=0; i < numToMerge; i++) {
    hyperLogLogs[i]=new HyperLogLogPlus(bits,25);
    for (int j=0; j < cardinality; j++) {
      double val=Math.random();
      hyperLogLogs[i].offer(val);
      baseline.offer(val);
    }
  }
  long expectedCardinality=numToMerge * cardinality;
  HyperLogLogPlus hll=hyperLogLogs[0];
  hyperLogLogs=Arrays.asList(hyperLogLogs).subList(1,hyperLogLogs.length).toArray(new HyperLogLogPlus[0]);
  long mergedEstimate=hll.merge(hyperLogLogs).cardinality();
  double se=expectedCardinality * (1.04 / Math.sqrt(Math.pow(2,bits)));
  System.out.println(""String_Node_Str"" + mergedEstimate + ""String_Node_Str""+ (expectedCardinality - (3 * se))+ ""String_Node_Str""+ (expectedCardinality + (3 * se)));
  double err=Math.abs(mergedEstimate - expectedCardinality) / (double)expectedCardinality;
  System.out.println(err);
  assertTrue(err < .1);
  assertTrue(mergedEstimate >= expectedCardinality - (3 * se));
  assertTrue(mergedEstimate <= expectedCardinality + (3 * se));
}",0.940386230058774
1390,"public void mergeTmp(){
  if (tmpSet.size() != 0) {
    Collections.sort(tmpSet);
    sparseSet=merge(sparseSet,tmpSet);
    tmpSet.clear();
  }
}","public void mergeTmp(){
  if (tmpSet.size() != 0) {
    resetDelta();
    Collections.sort(tmpSet);
    sparseSet=merge(sparseSet,tmpSet);
    tmpSet.clear();
  }
}",0.9419354838709676
1391,"private List<byte[]> mergeEstimators(HyperLogLogPlus other){
  other.mergeTmp();
  mergeTmp();
  List<byte[]> set=sparseSet;
  List<byte[]> tmp=other.sparseSet;
  List<byte[]> newSet=new ArrayList<byte[]>();
  Map<Integer,Integer> indexMap=new HashMap<Integer,Integer>();
  int seti=0;
  int tmpi=0;
  while (seti < set.size() || tmpi < tmp.size()) {
    if (seti >= set.size()) {
      int tmpVal=other.unzipInt(tmp.get(tmpi));
      conditionalAdd(indexMap,tmpVal,newSet);
      tmpi++;
    }
 else     if (tmpi >= tmp.size()) {
      int setVal=unzipInt(set.get(seti));
      conditionalAdd(indexMap,setVal,newSet);
      seti++;
    }
 else {
      int setVal=unzipInt(set.get(seti));
      int tmpVal=other.unzipInt(tmp.get(tmpi));
      if (getSparseIndex(setVal) == getSparseIndex(tmpVal)) {
        int min=Math.min(setVal,tmpVal);
        conditionalAdd(indexMap,min,newSet);
        tmpi++;
        seti++;
      }
 else       if (setVal < tmpVal) {
        conditionalAdd(indexMap,setVal,newSet);
        seti++;
      }
 else {
        conditionalAdd(indexMap,tmpVal,newSet);
        tmpi++;
      }
    }
  }
  old_delta=delta;
  return newSet;
}","private List<byte[]> mergeEstimators(HyperLogLogPlus other){
  other.mergeTmp();
  mergeTmp();
  resetDelta();
  other.resetDelta();
  List<byte[]> set=sparseSet;
  List<byte[]> tmp=other.sparseSet;
  List<byte[]> newSet=new ArrayList<byte[]>();
  int seti=0;
  int tmpi=0;
  while (seti < set.size() || tmpi < tmp.size()) {
    if (seti >= set.size()) {
      int tmpVal=other.deltaRead(tmp,tmpi);
      deltaAdd(newSet,tmpVal);
      tmpi++;
    }
 else     if (tmpi >= tmp.size()) {
      int setVal=deltaRead(set,seti);
      deltaAdd(newSet,setVal);
      seti++;
    }
 else {
      int setVal=deltaRead(set,seti);
      int tmpVal=other.deltaRead(tmp,tmpi);
      if (getSparseIndex(setVal) == getSparseIndex(tmpVal)) {
        int min=Math.min(setVal,tmpVal);
        deltaAdd(newSet,min);
        tmpi++;
        seti++;
      }
 else       if (setVal < tmpVal) {
        deltaAdd(newSet,setVal);
        seti++;
      }
 else {
        deltaAdd(newSet,tmpVal);
        tmpi++;
      }
    }
  }
  return newSet;
}",0.7451879010082493
1392,"private void convertToNormal(){
  mergeTmp();
  for (  byte[] bytes : sparseSet) {
    int k=unzipInt(bytes);
    int idx=getIndex(k,p);
    int r=decodeRunLength(k);
    if (registerSet.get(idx) < r) {
      registerSet.set(idx,r);
    }
  }
  format=Format.NORMAL;
  tmpSet.clear();
  sparseSet=null;
}","private void convertToNormal(){
  mergeTmp();
  resetDelta();
  for (int i=0; i < sparseSet.size(); i++) {
    int k=deltaRead(sparseSet,i);
    int idx=getIndex(k,p);
    int r=decodeRunLength(k);
    if (registerSet.get(idx) < r) {
      registerSet.set(idx,r);
    }
  }
  format=Format.NORMAL;
  tmpSet.clear();
  sparseSet=null;
}",0.8262910798122066
1393,"/** 
 * @throws IllegalArgumentException if variable-length value does not terminateafter 5 bytes have been read
 * @throws IOException if {@link DataInput} throws {@link IOException}
 * @see #readSignedVarLong(DataInput)
 */
public static int readSignedVarInt(DataInput in) throws IOException {
  int raw=readUnsignedVarInt(in);
  int temp=(((raw << 31) >> 31) ^ raw) >> 1;
  return temp ^ (raw & (1 << 31));
}","public static int readSignedVarInt(byte[] bytes){
  int raw=readUnsignedVarInt(bytes);
  int temp=(((raw << 31) >> 31) ^ raw) >> 1;
  return temp ^ (raw & (1 << 31));
}",0.5284974093264249
1394,"/** 
 * @see #writeSignedVarLong(long,DataOutput)
 */
public static void writeSignedVarInt(int value,DataOutput out) throws IOException {
  writeUnsignedVarInt((value << 1) ^ (value >> 31),out);
}","public static byte[] writeSignedVarInt(int value){
  return writeUnsignedVarInt((value << 1) ^ (value >> 31));
}",0.6428571428571429
1395,"@Test public void testMerge_Sparse() throws CardinalityMergeException {
  int numToMerge=4;
  int bits=18;
  int cardinality=1000000;
  HyperLogLogPlus[] hyperLogLogs=new HyperLogLogPlus[numToMerge];
  HyperLogLogPlus baseline=new HyperLogLogPlus(bits,25);
  for (int i=0; i < numToMerge; i++) {
    hyperLogLogs[i]=new HyperLogLogPlus(bits,25);
    for (int j=0; j < cardinality; j++) {
      double val=Math.random();
      hyperLogLogs[i].offer(val);
      baseline.offer(val);
    }
  }
  long expectedCardinality=numToMerge * cardinality;
  HyperLogLogPlus hll=hyperLogLogs[0];
  hyperLogLogs=Arrays.asList(hyperLogLogs).subList(1,hyperLogLogs.length).toArray(new HyperLogLogPlus[0]);
  long mergedEstimate=hll.merge(hyperLogLogs).cardinality();
  double se=expectedCardinality * (1.04 / Math.sqrt(Math.pow(2,bits)));
  System.out.println(""String_Node_Str"" + mergedEstimate + ""String_Node_Str""+ (expectedCardinality - (3 * se))+ ""String_Node_Str""+ (expectedCardinality + (3 * se)));
  double err=Math.abs(mergedEstimate - expectedCardinality) / (double)expectedCardinality;
  System.out.println(err);
  assertTrue(err < .1);
}","@Test public void testMerge_Sparse() throws CardinalityMergeException {
  int numToMerge=4;
  int bits=18;
  int cardinality=1000000;
  HyperLogLogPlus[] hyperLogLogs=new HyperLogLogPlus[numToMerge];
  HyperLogLogPlus baseline=new HyperLogLogPlus(bits,25);
  for (int i=0; i < numToMerge; i++) {
    hyperLogLogs[i]=new HyperLogLogPlus(bits,25);
    for (int j=0; j < cardinality; j++) {
      double val=Math.random();
      hyperLogLogs[i].offer(val);
      baseline.offer(val);
    }
  }
  long expectedCardinality=numToMerge * cardinality;
  HyperLogLogPlus hll=hyperLogLogs[0];
  hyperLogLogs=Arrays.asList(hyperLogLogs).subList(1,hyperLogLogs.length).toArray(new HyperLogLogPlus[0]);
  long mergedEstimate=hll.merge(hyperLogLogs).cardinality();
  double se=expectedCardinality * (1.04 / Math.sqrt(Math.pow(2,bits)));
  System.out.println(""String_Node_Str"" + mergedEstimate + ""String_Node_Str""+ (expectedCardinality - (3 * se))+ ""String_Node_Str""+ (expectedCardinality + (3 * se)));
  double err=Math.abs(mergedEstimate - expectedCardinality) / (double)expectedCardinality;
  System.out.println(""String_Node_Str"" + err);
  assertTrue(err < .1);
  assertTrue(mergedEstimate >= expectedCardinality - (3 * se));
  assertTrue(mergedEstimate <= expectedCardinality + (3 * se));
}",0.9385892116182571
1396,"@Test public void testMerge_ManySparse() throws CardinalityMergeException {
  int numToMerge=20;
  int bits=18;
  int cardinality=10000;
  HyperLogLogPlus[] hyperLogLogs=new HyperLogLogPlus[numToMerge];
  HyperLogLogPlus baseline=new HyperLogLogPlus(bits,25);
  for (int i=0; i < numToMerge; i++) {
    hyperLogLogs[i]=new HyperLogLogPlus(bits,25);
    for (int j=0; j < cardinality; j++) {
      double val=Math.random();
      hyperLogLogs[i].offer(val);
      baseline.offer(val);
    }
  }
  long expectedCardinality=numToMerge * cardinality;
  HyperLogLogPlus hll=hyperLogLogs[0];
  hyperLogLogs=Arrays.asList(hyperLogLogs).subList(1,hyperLogLogs.length).toArray(new HyperLogLogPlus[0]);
  long mergedEstimate=hll.merge(hyperLogLogs).cardinality();
  double se=expectedCardinality * (1.04 / Math.sqrt(Math.pow(2,bits)));
  System.out.println(""String_Node_Str"" + mergedEstimate + ""String_Node_Str""+ (expectedCardinality - (3 * se))+ ""String_Node_Str""+ (expectedCardinality + (3 * se)));
  double err=Math.abs(mergedEstimate - expectedCardinality) / (double)expectedCardinality;
  System.out.println(err);
  assertTrue(err < .1);
  assertTrue(mergedEstimate >= expectedCardinality - (3 * se));
  assertTrue(mergedEstimate <= expectedCardinality + (3 * se));
}","@Test public void testMerge_ManySparse() throws CardinalityMergeException {
  int numToMerge=20;
  int bits=18;
  int cardinality=10000;
  HyperLogLogPlus[] hyperLogLogs=new HyperLogLogPlus[numToMerge];
  HyperLogLogPlus baseline=new HyperLogLogPlus(bits,25);
  for (int i=0; i < numToMerge; i++) {
    hyperLogLogs[i]=new HyperLogLogPlus(bits,25);
    for (int j=0; j < cardinality; j++) {
      double val=Math.random();
      hyperLogLogs[i].offer(val);
      baseline.offer(val);
    }
  }
  long expectedCardinality=numToMerge * cardinality;
  HyperLogLogPlus hll=hyperLogLogs[0];
  hyperLogLogs=Arrays.asList(hyperLogLogs).subList(1,hyperLogLogs.length).toArray(new HyperLogLogPlus[0]);
  long mergedEstimate=hll.merge(hyperLogLogs).cardinality();
  double se=expectedCardinality * (1.04 / Math.sqrt(Math.pow(2,bits)));
  System.out.println(""String_Node_Str"" + mergedEstimate + ""String_Node_Str""+ (expectedCardinality - (3 * se))+ ""String_Node_Str""+ (expectedCardinality + (3 * se)));
  assertTrue(mergedEstimate >= expectedCardinality - (3 * se));
  assertTrue(mergedEstimate <= expectedCardinality + (3 * se));
}",0.8757346767422334
1397,"@Test public void testHighCardinality(){
  long start=System.currentTimeMillis();
  HyperLogLogPlus hyperLogLogPlus=new HyperLogLogPlus(18,25);
  int size=10000000;
  for (int i=0; i < size; i++) {
    hyperLogLogPlus.offer(TestICardinality.streamElement(i));
  }
  System.out.println(""String_Node_Str"" + size + ""String_Node_Str""+ hyperLogLogPlus.cardinality()+ ""String_Node_Str""+ (System.currentTimeMillis() - start));
  long estimate=hyperLogLogPlus.cardinality();
  double err=Math.abs(estimate - size) / (double)size;
  System.out.println(err);
  assertTrue(err < .1);
}","@Test public void testHighCardinality(){
  long start=System.currentTimeMillis();
  HyperLogLogPlus hyperLogLogPlus=new HyperLogLogPlus(18,25);
  int size=10000000;
  for (int i=0; i < size; i++) {
    hyperLogLogPlus.offer(TestICardinality.streamElement(i));
  }
  System.out.println(""String_Node_Str"" + size + ""String_Node_Str""+ hyperLogLogPlus.cardinality()+ ""String_Node_Str""+ (System.currentTimeMillis() - start));
  long estimate=hyperLogLogPlus.cardinality();
  double err=Math.abs(estimate - size) / (double)size;
  System.out.println(""String_Node_Str"" + err);
  assertTrue(err < .1);
}",0.9828767123287672
1398,"private int getIndex(int k,int p){
  if ((k & 1) != 0) {
    return (k >>> 6 & ((1 << p) - 1));
  }
 else {
    return (k >>> 1 & ((1 << p) - 1));
  }
}","private int getIndex(int k,int p){
  if ((k & 1) != 0) {
    return (k >>> 6 & ((1 << p) - 1));
  }
 else {
    return (k >>> (1 + (sp - p)));
  }
}",0.94
1399,"private int decodeRunLength(int k){
  if ((k & (1L)) != 0) {
    return ((k >>> 1) & ((1 << 7) - 1)) + (sp - p);
  }
 else {
    return Integer.numberOfLeadingZeros((k >>> 1) & ((1 << (sp - p - 1)) - 1)) + 1;
  }
}","private int decodeRunLength(int k){
  if ((k & (1L)) != 0) {
    return ((k >>> 1) & ((1 << 7) - 1)) + (sp - p);
  }
 else {
    return Integer.numberOfLeadingZeros((k >>> 1) & ((1 << (sp - p)) - 1)) + 1;
  }
}",0.9905660377358492
1400,"@Override public boolean offer(Object o){
  long x=MurmurHash.hash64(o);
switch (format) {
case NORMAL:
    final long idx=x >>> (64 - p);
  final int runLength=Long.numberOfLeadingZeros((x << this.p) | (1 << (this.p - 1)) + 1) + 1;
if (registerSet.get((int)idx) < runLength) {
  registerSet.set((int)idx,runLength);
  return true;
}
 else {
  return false;
}
case SPARCE:
int k=encodeHash(x,p,sp);
try {
Varint.writeUnsignedVarInt(k,dataOutput);
boolean ret=tmpSet.add(rawOutput.toByteArray());
rawOutput.reset();
if (tmpSet.size() > sparseSortThreshold) {
sparseSet=merge(sparseSet,sort(tmpSet));
tmpSet.clear();
System.out.println(""String_Node_Str"" + sparseSet.size() + ""String_Node_Str""+ (m * 6));
if (sparseSet.size() > sparseMaxThreshold) {
  format=Format.NORMAL;
  convertToNormal();
}
}
return ret;
}
 catch (IOException e) {
e.printStackTrace();
}
break;
default :
break;
}
return false;
}","@Override public boolean offer(Object o){
  long x=MurmurHash.hash64(o);
switch (format) {
case NORMAL:
    final long idx=x >>> (64 - p);
  final int runLength=Long.numberOfLeadingZeros((x << this.p) | (1 << (this.p - 1)) + 1) + 1;
if (registerSet.get((int)idx) < runLength) {
  registerSet.set((int)idx,runLength);
  return true;
}
 else {
  return false;
}
case SPARCE:
int k=encodeHash(x,p,sp);
try {
Varint.writeUnsignedVarInt(k,dataOutput);
boolean ret=tmpSet.add(rawOutput.toByteArray());
rawOutput.reset();
if (tmpSet.size() > sparseSortThreshold) {
sparseSet=merge(sparseSet,sort(tmpSet));
tmpSet.clear();
if (sparseSet.size() > sparseMaxThreshold) {
  convertToNormal();
}
}
return ret;
}
 catch (IOException e) {
e.printStackTrace();
}
break;
default :
break;
}
return false;
}",0.9294605809128632
1401,"private void convertToNormal(){
  for (  byte[] bytes : sparseSet) {
    DataInput dataInput=new DataInputStream(new ByteArrayInputStream(bytes));
    try {
      int k=Varint.readUnsignedVarInt(dataInput);
      int idx=getIndex(k,p);
      int r=decodeRunLength(k);
      final int runLength=Long.numberOfLeadingZeros((idx << this.p) | (1 << (this.p - 1)) + 1) + 1;
      if (registerSet.get(idx) < r) {
        registerSet.set(idx,runLength);
      }
      tmpSet.clear();
      sparseSet=null;
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}","private void convertToNormal(){
  for (  byte[] bytes : sparseSet) {
    DataInput dataInput=new DataInputStream(new ByteArrayInputStream(bytes));
    try {
      int k=Varint.readUnsignedVarInt(dataInput);
      int idx=getIndex(k,p);
      int r=decodeRunLength(k);
      if (registerSet.get(idx) < r) {
        registerSet.set(idx,r);
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  format=Format.NORMAL;
  tmpSet.clear();
  sparseSet=null;
}",0.7980952380952381
1402,"private int getIndex(int k,int p){
  if ((k & 1L) != 0) {
    return (k >>> 6 & ((1 << p) - 1));
  }
 else {
    return (k >>> 1 & ((1 << p) - 1));
  }
}","private int getIndex(int k,int p){
  if ((k & 1L) != 0) {
    return (k >>> 6 & ((1 << p) - 1));
  }
 else {
    return (k >>> 1 & ((1 << (p + 1)) - 1));
  }
}",0.9807692307692308
1403,"public HyperLogLogPlus(int p,int sp,RegisterSet registerSet){
  this.p=p;
  this.sp=sp;
  this.m=(int)Math.pow(2,p);
  this.sm=(int)Math.pow(2,sp);
  this.registerSet=registerSet;
  int bitSize=6;
switch (bitSize) {
case 4:
    alphaMM=0.673 * m * m;
  break;
case 5:
alphaMM=0.697 * m * m;
break;
case 6:
alphaMM=0.709 * m * m;
break;
default :
alphaMM=(0.7213 / (1 + 1.079 / m)) * m * m;
}
}","public HyperLogLogPlus(int p,int sp,RegisterSet registerSet){
  this.p=p;
  this.sp=sp;
  this.m=(int)Math.pow(2,p);
  this.sm=(int)Math.pow(2,sp);
  this.registerSet=registerSet;
switch (p) {
case 4:
    alphaMM=0.673 * m * m;
  break;
case 5:
alphaMM=0.697 * m * m;
break;
case 6:
alphaMM=0.709 * m * m;
break;
default :
alphaMM=(0.7213 / (1 + 1.079 / m)) * m * m;
}
}",0.9672346002621232
1404,"@Test public void testMerge() throws CardinalityMergeException {
  int numToMerge=1;
  int bits=14;
  int cardinality=1000000;
  HyperLogLogPlus[] hyperLogLogs=new HyperLogLogPlus[numToMerge];
  HyperLogLogPlus baseline=new HyperLogLogPlus(bits,25);
  for (int i=0; i < numToMerge; i++) {
    hyperLogLogs[i]=new HyperLogLogPlus(bits,25);
    for (int j=0; j < cardinality; j++) {
      double val=Math.random();
      hyperLogLogs[i].offer(val);
      baseline.offer(val);
    }
  }
  long expectedCardinality=numToMerge * cardinality;
  HyperLogLogPlus hll=hyperLogLogs[0];
  hyperLogLogs=Arrays.asList(hyperLogLogs).subList(1,hyperLogLogs.length).toArray(new HyperLogLogPlus[0]);
  long mergedEstimate=hll.merge(hyperLogLogs).cardinality();
  double se=expectedCardinality * (1.04 / Math.sqrt(Math.pow(2,bits)));
  System.out.println(""String_Node_Str"" + mergedEstimate + ""String_Node_Str""+ (expectedCardinality - (3 * se))+ ""String_Node_Str""+ (expectedCardinality + (3 * se)));
  assertTrue(mergedEstimate >= expectedCardinality - (3 * se));
  assertTrue(mergedEstimate <= expectedCardinality + (3 * se));
}","@Test public void testMerge() throws CardinalityMergeException {
  int numToMerge=4;
  int bits=18;
  int cardinality=1000000;
  HyperLogLogPlus[] hyperLogLogs=new HyperLogLogPlus[numToMerge];
  HyperLogLogPlus baseline=new HyperLogLogPlus(bits,25);
  for (int i=0; i < numToMerge; i++) {
    hyperLogLogs[i]=new HyperLogLogPlus(bits,25);
    for (int j=0; j < cardinality; j++) {
      double val=Math.random();
      hyperLogLogs[i].offer(val);
      baseline.offer(val);
    }
  }
  long expectedCardinality=numToMerge * cardinality;
  HyperLogLogPlus hll=hyperLogLogs[0];
  hyperLogLogs=Arrays.asList(hyperLogLogs).subList(1,hyperLogLogs.length).toArray(new HyperLogLogPlus[0]);
  long mergedEstimate=hll.merge(hyperLogLogs).cardinality();
  double se=expectedCardinality * (1.04 / Math.sqrt(Math.pow(2,bits)));
  System.out.println(""String_Node_Str"" + mergedEstimate + ""String_Node_Str""+ (expectedCardinality - (3 * se))+ ""String_Node_Str""+ (expectedCardinality + (3 * se)));
  assertTrue(mergedEstimate >= expectedCardinality - (3 * se));
  assertTrue(mergedEstimate <= expectedCardinality + (3 * se));
}",0.9864864864864864
1405,"@Test public void testHighCardinality(){
  long start=System.currentTimeMillis();
  HyperLogLogPlus hyperLogLog=new HyperLogLogPlus(14,25);
  int size=100000000;
  for (int i=0; i < size; i++) {
    hyperLogLog.offer(TestICardinality.streamElement(i));
  }
  System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - start));
  long estimate=hyperLogLog.cardinality();
  double err=Math.abs(estimate - size) / (double)size;
  System.out.println(err);
  assertTrue(err < .1);
}","@Test public void testHighCardinality(){
  long start=System.currentTimeMillis();
  HyperLogLogPlus hyperLogLogPlus=new HyperLogLogPlus(18,25);
  int size=10000000;
  for (int i=0; i < size; i++) {
    hyperLogLogPlus.offer(TestICardinality.streamElement(i));
  }
  System.out.println(""String_Node_Str"" + size + ""String_Node_Str""+ hyperLogLogPlus.cardinality()+ ""String_Node_Str""+ (System.currentTimeMillis() - start));
  long estimate=hyperLogLogPlus.cardinality();
  double err=Math.abs(estimate - size) / (double)size;
  System.out.println(err);
  assertTrue(err < .1);
}",0.9142318567389256
1406,"@Test public void testOnSquares(){
  QDigest digest=new QDigest(1000);
  for (int j=0; j < 10; ++j) {
    for (long i=0; i < 100000; ++i) {
      digest.offer(i * i);
    }
  }
  for (double i=0; i < 1; i+=0.1)   System.out.println(i + ""String_Node_Str"" + digest.getQuantile(i)+ ""String_Node_Str""+ (i * 10000L) * (i * 10000L));
}","@Test public void testOnSquares(){
  double compressionFactor=1000;
  QDigest digest=new QDigest(compressionFactor);
  int max=100000;
  for (int j=0; j < 10; ++j) {
    for (long i=0; i < max; ++i) {
      digest.offer(i * i);
    }
  }
  int logCapacity=1;
  for (long scale=1; scale < max; scale*=2, logCapacity++)   ;
  double eps=logCapacity / compressionFactor;
  for (double i=0; i < 1; i+=0.1) {
    double answer=digest.getQuantile(i);
    System.out.println(i + ""String_Node_Str"" + answer+ ""String_Node_Str""+ (i * max) * (i * max));
    double actualRank=Math.min(1.0,Math.sqrt(answer) / max);
    assertTrue(actualRank + ""String_Node_Str"" + (i - eps)+ ""String_Node_Str""+ (i + eps),actualRank > i - eps && actualRank < i + eps);
  }
}",0.516309412861137
1407,"public static HyperLogLog build(byte[] bytes) throws IOException {
  ByteArrayInputStream bais=new ByteArrayInputStream(bytes);
  DataInputStream oi=new DataInputStream(bais);
  int bits=oi.readInt();
  int size=oi.readInt();
  byte[] longArrayBytes=new byte[size];
  oi.readFully(longArrayBytes);
  return new HyperLogLog(new RegisterSet((int)Math.pow(2,bits),getBits(longArrayBytes)));
}","public static HyperLogLog build(byte[] bytes) throws IOException {
  ByteArrayInputStream bais=new ByteArrayInputStream(bytes);
  DataInputStream oi=new DataInputStream(bais);
  int bits=oi.readInt();
  int size=oi.readInt();
  byte[] longArrayBytes=new byte[size];
  oi.readFully(longArrayBytes);
  return new HyperLogLog(bits,new RegisterSet((int)Math.pow(2,bits),getBits(longArrayBytes)));
}",0.9936143039591316
1408,"/** 
 * Merges estimators to produce an estimator for their combined streams
 * @param estimators
 * @return merged estimator or null if no estimators were provided
 */
public static HyperLogLog mergeEstimators(HyperLogLog... estimators){
  HyperLogLog merged=null;
  RegisterSet mergedSet=mergeRegisters(estimators);
  if (mergedSet != null)   merged=new HyperLogLog(mergedSet);
  return merged;
}","/** 
 * Merges estimators to produce an estimator for their combined streams
 * @param estimators
 * @return merged estimator or null if no estimators were provided
 */
public static HyperLogLog mergeEstimators(HyperLogLog... estimators){
  HyperLogLog merged=null;
  RegisterSet mergedSet=mergeRegisters(estimators);
  if (mergedSet != null)   merged=new HyperLogLog(estimators[0].log2m,mergedSet);
  return merged;
}",0.9754901960784312
1409,"/** 
 * Creates a new HyperLogLog instance using the given registers.  Used for unmarshalling a serialized instance and for merging multiple counters together.
 * @param registerSet - the initial values for the register set
 */
public HyperLogLog(RegisterSet registerSet){
  this.registerSet=registerSet;
  this.log2m=(int)(Math.sqrt(Math.sqrt(registerSet.count)));
  this.m=(int)Math.pow(2,this.log2m);
switch (log2m) {
case 4:
    alphaMM=0.673 * m * m;
  break;
case 5:
alphaMM=0.697 * m * m;
break;
case 6:
alphaMM=0.709 * m * m;
break;
default :
alphaMM=(0.7213 / (1 + 1.079 / m)) * m * m;
}
}","/** 
 * Creates a new HyperLogLog instance using the given registers.  Used for unmarshalling a serialized instance and for merging multiple counters together.
 * @param registerSet - the initial values for the register set
 */
public HyperLogLog(int log2m,RegisterSet registerSet){
  this.registerSet=registerSet;
  this.log2m=log2m;
  this.m=(int)Math.pow(2,this.log2m);
switch (log2m) {
case 4:
    alphaMM=0.673 * m * m;
  break;
case 5:
alphaMM=0.697 * m * m;
break;
case 6:
alphaMM=0.709 * m * m;
break;
default :
alphaMM=(0.7213 / (1 + 1.079 / m)) * m * m;
}
}",0.9476394849785408
1410,"private static void registerMemoryStats(final MetricRegistry stats,final MemoryUsage usage){
  if (usage != null) {
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return usage.getCommitted();
      }
    }
);
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return usage.getMax();
      }
    }
);
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return usage.getUsed();
      }
    }
);
  }
}","private static void registerMemoryStats(final MetricRegistry stats,final MemoryReporter mem){
  if (mem.getUsage() != null) {
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return mem.getUsage().getCommitted();
      }
    }
);
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return mem.getUsage().getMax();
      }
    }
);
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return mem.getUsage().getUsed();
      }
    }
);
  }
}",0.908936170212766
1411,"/** 
 * Add a series of system and jvm-level stats to the given registry.
 */
public static void register(MetricRegistry registry){
  final MetricRegistry stats=registry.scope(""String_Node_Str"");
  final MemoryMXBean mem=ManagementFactory.getMemoryMXBean();
  final MemoryUsage heap=mem.getHeapMemoryUsage();
  final MetricRegistry heapRegistry=stats.scope(""String_Node_Str"");
  registerMemoryStats(heapRegistry,heap);
  final MemoryUsage nonHeap=mem.getNonHeapMemoryUsage();
  final MetricRegistry nonHeapRegistry=stats.scope(""String_Node_Str"");
  registerMemoryStats(nonHeapRegistry,nonHeap);
  final ThreadMXBean threads=ManagementFactory.getThreadMXBean();
  final MetricRegistry threadRegistry=stats.scope(""String_Node_Str"");
  threadRegistry.register(new AbstractGauge<Integer>(""String_Node_Str""){
    @Override public Integer read(){
      return threads.getDaemonThreadCount();
    }
  }
);
  threadRegistry.register(new AbstractGauge<Integer>(""String_Node_Str""){
    @Override public Integer read(){
      return threads.getThreadCount();
    }
  }
);
  threadRegistry.register(new AbstractGauge<Integer>(""String_Node_Str""){
    @Override public Integer read(){
      return threads.getPeakThreadCount();
    }
  }
);
  final ClassLoadingMXBean classLoadingBean=ManagementFactory.getClassLoadingMXBean();
  stats.register(new AbstractGauge<Integer>(""String_Node_Str""){
    @Override public Integer read(){
      return classLoadingBean.getLoadedClassCount();
    }
  }
);
  stats.register(new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      return classLoadingBean.getTotalLoadedClassCount();
    }
  }
);
  stats.register(new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      return classLoadingBean.getUnloadedClassCount();
    }
  }
);
  final RuntimeMXBean runtime=ManagementFactory.getRuntimeMXBean();
  stats.register(new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      return runtime.getStartTime();
    }
  }
);
  stats.register(new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      return runtime.getUptime();
    }
  }
);
  final OperatingSystemMXBean os=ManagementFactory.getOperatingSystemMXBean();
  stats.register(new AbstractGauge<Integer>(""String_Node_Str""){
    @Override public Integer read(){
      return os.getAvailableProcessors();
    }
  }
);
  if (os instanceof com.sun.management.OperatingSystemMXBean) {
    final com.sun.management.OperatingSystemMXBean sunOsMbean=(com.sun.management.OperatingSystemMXBean)os;
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return sunOsMbean.getFreePhysicalMemorySize();
      }
    }
);
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return sunOsMbean.getFreeSwapSpaceSize();
      }
    }
);
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return sunOsMbean.getProcessCpuTime();
      }
    }
);
  }
  if (os instanceof com.sun.management.UnixOperatingSystemMXBean) {
    final UnixOperatingSystemMXBean unix=(UnixOperatingSystemMXBean)os;
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return unix.getOpenFileDescriptorCount();
      }
    }
);
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return unix.getMaxFileDescriptorCount();
      }
    }
);
  }
  final List<MemoryPoolMXBean> memPool=ManagementFactory.getMemoryPoolMXBeans();
  final MetricRegistry memRegistry=stats.scope(""String_Node_Str"");
  final MetricRegistry currentMem=memRegistry.scope(""String_Node_Str"");
  final MetricRegistry postGCRegistry=memRegistry.scope(""String_Node_Str"");
  for (  MemoryPoolMXBean pool : memPool) {
    String name=normalizeName(pool.getName());
    registerMemoryStats(currentMem.scope(name),pool.getUsage());
    MemoryUsage postGCUsage=pool.getCollectionUsage();
    registerMemoryStats(postGCRegistry.scope(name),postGCUsage);
  }
  currentMem.register(new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      long sum=0;
      for (      MemoryPoolMXBean pool : memPool) {
        MemoryUsage usage=pool.getUsage();
        if (usage != null) {
          sum+=usage.getUsed();
        }
      }
      return sum;
    }
  }
);
  AbstractGauge<Long> totalPostGCGauge=new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      long sum=0;
      for (      MemoryPoolMXBean pool : memPool) {
        MemoryUsage usage=pool.getCollectionUsage();
        if (usage != null) {
          sum+=usage.getUsed();
        }
      }
      return sum;
    }
  }
;
  postGCRegistry.register(totalPostGCGauge);
  Multimap<String,AbstractGauge<Long>> java17gauges=buildJava17Gauges();
  if (!java17gauges.isEmpty()) {
    MetricRegistry bufferRegistry=stats.scope(""String_Node_Str"");
    for (    String scope : java17gauges.keySet()) {
      MetricRegistry pool=bufferRegistry.scope(scope);
      for (      AbstractGauge<Long> gauge : java17gauges.get(scope)) {
        pool.register(gauge);
      }
    }
  }
  final List<GarbageCollectorMXBean> gcPool=ManagementFactory.getGarbageCollectorMXBeans();
  MetricRegistry gcRegistry=stats.scope(""String_Node_Str"");
  for (  final GarbageCollectorMXBean gc : gcPool) {
    String name=normalizeName(gc.getName());
    MetricRegistry scoped=memRegistry.scope(name);
    scoped.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return gc.getCollectionCount();
      }
    }
);
    scoped.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return gc.getCollectionTime();
      }
    }
);
  }
  gcRegistry.register(new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      long sum=0;
      for (      GarbageCollectorMXBean pool : gcPool) {
        long count=pool.getCollectionCount();
        if (count > 0) {
          sum+=count;
        }
      }
      return sum;
    }
  }
);
  gcRegistry.register(new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      long sum=0;
      for (      GarbageCollectorMXBean pool : gcPool) {
        long msec=pool.getCollectionTime();
        if (msec > 0) {
          sum+=msec;
        }
      }
      return sum;
    }
  }
);
}","/** 
 * Add a series of system and jvm-level stats to the given registry.
 */
public static void register(MetricRegistry registry){
  final MetricRegistry stats=registry.scope(""String_Node_Str"");
  final MemoryMXBean mem=ManagementFactory.getMemoryMXBean();
  final MetricRegistry heapRegistry=stats.scope(""String_Node_Str"");
  registerMemoryStats(heapRegistry,new MemoryReporter(){
    @Override public MemoryUsage getUsage(){
      return mem.getHeapMemoryUsage();
    }
  }
);
  final MetricRegistry nonHeapRegistry=stats.scope(""String_Node_Str"");
  registerMemoryStats(nonHeapRegistry,new MemoryReporter(){
    @Override public MemoryUsage getUsage(){
      return mem.getNonHeapMemoryUsage();
    }
  }
);
  final ThreadMXBean threads=ManagementFactory.getThreadMXBean();
  final MetricRegistry threadRegistry=stats.scope(""String_Node_Str"");
  threadRegistry.register(new AbstractGauge<Integer>(""String_Node_Str""){
    @Override public Integer read(){
      return threads.getDaemonThreadCount();
    }
  }
);
  threadRegistry.register(new AbstractGauge<Integer>(""String_Node_Str""){
    @Override public Integer read(){
      return threads.getThreadCount();
    }
  }
);
  threadRegistry.register(new AbstractGauge<Integer>(""String_Node_Str""){
    @Override public Integer read(){
      return threads.getPeakThreadCount();
    }
  }
);
  final ClassLoadingMXBean classLoadingBean=ManagementFactory.getClassLoadingMXBean();
  stats.register(new AbstractGauge<Integer>(""String_Node_Str""){
    @Override public Integer read(){
      return classLoadingBean.getLoadedClassCount();
    }
  }
);
  stats.register(new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      return classLoadingBean.getTotalLoadedClassCount();
    }
  }
);
  stats.register(new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      return classLoadingBean.getUnloadedClassCount();
    }
  }
);
  final RuntimeMXBean runtime=ManagementFactory.getRuntimeMXBean();
  stats.register(new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      return runtime.getStartTime();
    }
  }
);
  stats.register(new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      return runtime.getUptime();
    }
  }
);
  final OperatingSystemMXBean os=ManagementFactory.getOperatingSystemMXBean();
  stats.register(new AbstractGauge<Integer>(""String_Node_Str""){
    @Override public Integer read(){
      return os.getAvailableProcessors();
    }
  }
);
  if (os instanceof com.sun.management.OperatingSystemMXBean) {
    final com.sun.management.OperatingSystemMXBean sunOsMbean=(com.sun.management.OperatingSystemMXBean)os;
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return sunOsMbean.getFreePhysicalMemorySize();
      }
    }
);
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return sunOsMbean.getFreeSwapSpaceSize();
      }
    }
);
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return sunOsMbean.getProcessCpuTime();
      }
    }
);
  }
  if (os instanceof com.sun.management.UnixOperatingSystemMXBean) {
    final UnixOperatingSystemMXBean unix=(UnixOperatingSystemMXBean)os;
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return unix.getOpenFileDescriptorCount();
      }
    }
);
    stats.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return unix.getMaxFileDescriptorCount();
      }
    }
);
  }
  final List<MemoryPoolMXBean> memPool=ManagementFactory.getMemoryPoolMXBeans();
  final MetricRegistry memRegistry=stats.scope(""String_Node_Str"");
  final MetricRegistry currentMem=memRegistry.scope(""String_Node_Str"");
  final MetricRegistry postGCRegistry=memRegistry.scope(""String_Node_Str"");
  for (  final MemoryPoolMXBean pool : memPool) {
    String name=normalizeName(pool.getName());
    registerMemoryStats(currentMem.scope(name),new MemoryReporter(){
      @Override public MemoryUsage getUsage(){
        return pool.getUsage();
      }
    }
);
    registerMemoryStats(postGCRegistry.scope(name),new MemoryReporter(){
      @Override public MemoryUsage getUsage(){
        return pool.getCollectionUsage();
      }
    }
);
  }
  currentMem.register(new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      long sum=0;
      for (      MemoryPoolMXBean pool : memPool) {
        MemoryUsage usage=pool.getUsage();
        if (usage != null) {
          sum+=usage.getUsed();
        }
      }
      return sum;
    }
  }
);
  AbstractGauge<Long> totalPostGCGauge=new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      long sum=0;
      for (      MemoryPoolMXBean pool : memPool) {
        MemoryUsage usage=pool.getCollectionUsage();
        if (usage != null) {
          sum+=usage.getUsed();
        }
      }
      return sum;
    }
  }
;
  postGCRegistry.register(totalPostGCGauge);
  Multimap<String,AbstractGauge<Long>> java17gauges=buildJava17Gauges();
  if (!java17gauges.isEmpty()) {
    MetricRegistry bufferRegistry=stats.scope(""String_Node_Str"");
    for (    String scope : java17gauges.keySet()) {
      MetricRegistry pool=bufferRegistry.scope(scope);
      for (      AbstractGauge<Long> gauge : java17gauges.get(scope)) {
        pool.register(gauge);
      }
    }
  }
  final List<GarbageCollectorMXBean> gcPool=ManagementFactory.getGarbageCollectorMXBeans();
  MetricRegistry gcRegistry=stats.scope(""String_Node_Str"");
  for (  final GarbageCollectorMXBean gc : gcPool) {
    String name=normalizeName(gc.getName());
    MetricRegistry scoped=memRegistry.scope(name);
    scoped.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return gc.getCollectionCount();
      }
    }
);
    scoped.register(new AbstractGauge<Long>(""String_Node_Str""){
      @Override public Long read(){
        return gc.getCollectionTime();
      }
    }
);
  }
  gcRegistry.register(new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      long sum=0;
      for (      GarbageCollectorMXBean pool : gcPool) {
        long count=pool.getCollectionCount();
        if (count > 0) {
          sum+=count;
        }
      }
      return sum;
    }
  }
);
  gcRegistry.register(new AbstractGauge<Long>(""String_Node_Str""){
    @Override public Long read(){
      long sum=0;
      for (      GarbageCollectorMXBean pool : gcPool) {
        long msec=pool.getCollectionTime();
        if (msec > 0) {
          sum+=msec;
        }
      }
      return sum;
    }
  }
);
}",0.8741991407251074
1412,"/** 
 * @return a WindowedHistogram with different value in each underlying Histogram
 */
private WindowedHistogram<?> createFullHistogram(Amount<Long,Time> duration,int slices,FakeTicker ticker){
  long sliceDuration=duration.as(Time.NANOSECONDS) / slices;
  WindowedApproxHistogram wh=new WindowedApproxHistogram(duration,slices,DEFAULT_MAX_MEMORY,ticker);
  ticker.advance(Amount.of(1L,Time.NANOSECONDS));
  for (int i=1; i <= slices; i++) {
    for (int j=0; j < 1000; j++) {
      wh.add(i);
    }
    ticker.advance(Amount.of(sliceDuration,Time.NANOSECONDS));
  }
  return wh;
}","/** 
 * @return a WindowedHistogram with different value in each underlying Histogram
 */
private WindowedHistogram<?> createFullHistogram(Amount<Long,Time> duration,int slices,FakeTicker ticker){
  long sliceDuration=duration.as(Time.NANOSECONDS) / slices;
  WindowedApproxHistogram wh=new WindowedApproxHistogram(duration,slices,DEFAULT_MAX_MEMORY,ticker);
  ticker.advance(Amount.of(1L,Time.NANOSECONDS));
  return fillHistogram(wh,Amount.of(sliceDuration,Time.NANOSECONDS),slices,ticker);
}",0.8515769944341373
1413,"/** 
 * Applies argument values to fields based on their annotations.
 * @param parserOracle ParserOracle available to parse raw args with.
 * @param verifiers Verifiers available to verify argument constraints with.
 * @param argumentInfo Fields to apply argument values to.
 * @param args Unparsed argument values.
 * @param positionalArgs The unparsed positional arguments.
 * @return {@code true} if the given {@code args} were successfully applied to theircorresponding  {@link com.twitter.common.args.Arg} fields.
 */
private boolean process(final ParserOracle parserOracle,Verifiers verifiers,Args.ArgumentInfo argumentInfo,Map<String,String> args,List<String> positionalArgs){
  if (!Sets.intersection(args.keySet(),ArgumentInfo.HELP_ARGS).isEmpty()) {
    printHelp(verifiers,argumentInfo);
    return false;
  }
  Optional<? extends PositionalInfo<?>> positionalInfoOptional=argumentInfo.getPositionalInfo();
  checkArgument(positionalInfoOptional.isPresent() || positionalArgs.isEmpty(),""String_Node_Str"");
  Iterable<? extends OptionInfo<?>> optionInfos=argumentInfo.getOptionInfos();
  final Set<String> argsFailedToParse=Sets.newHashSet();
  final Set<String> argsConstraintsFailed=Sets.newHashSet();
  Iterable<String> argShortNames=Iterables.transform(optionInfos,GET_OPTIONINFO_NAME);
  Set<String> argShortNamesNoCollisions=dropCollisions(argShortNames);
  Set<String> collisionsDropped=Sets.difference(ImmutableSet.copyOf(argShortNames),argShortNamesNoCollisions);
  if (!collisionsDropped.isEmpty()) {
    LOG.warning(""String_Node_Str"" + collisionsDropped);
  }
  final Map<String,OptionInfo> argsByName=ImmutableMap.<String,OptionInfo>builder().putAll(Maps.uniqueIndex(Iterables.filter(optionInfos,Predicates.compose(Predicates.in(argShortNamesNoCollisions),GET_OPTIONINFO_NAME)),GET_OPTIONINFO_NAME)).putAll(Maps.uniqueIndex(optionInfos,GET_CANONICAL_ARG_NAME)).putAll(Maps.uniqueIndex(Iterables.filter(optionInfos,IS_BOOLEAN),GET_OPTIONINFO_NEGATED_NAME)).putAll(Maps.uniqueIndex(Iterables.filter(optionInfos,IS_BOOLEAN),GET_CANONICAL_NEGATED_ARG_NAME)).build();
  Set<String> recognizedArgs=Sets.intersection(argsByName.keySet(),args.keySet());
  for (  String argName : recognizedArgs) {
    String argValue=args.get(argName);
    OptionInfo optionInfo=argsByName.get(argName);
    try {
      optionInfo.load(parserOracle,argName,argValue);
    }
 catch (    IllegalArgumentException e) {
      argsFailedToParse.add(argName + ""String_Node_Str"" + e.getMessage());
    }
  }
  if (positionalInfoOptional.isPresent()) {
    PositionalInfo<?> positionalInfo=positionalInfoOptional.get();
    positionalInfo.load(parserOracle,positionalArgs);
  }
  Set<String> commandLineArgumentInfos=Sets.newTreeSet();
  Iterable<? extends ArgumentInfo<?>> allArguments=argumentInfo.getOptionInfos();
  if (positionalInfoOptional.isPresent()) {
    PositionalInfo<?> positionalInfo=positionalInfoOptional.get();
    allArguments=Iterables.concat(optionInfos,ImmutableList.of(positionalInfo));
  }
  for (  ArgumentInfo<?> anArgumentInfo : allArguments) {
    Arg<?> arg=anArgumentInfo.getArg();
    commandLineArgumentInfos.add(String.format(""String_Node_Str"",anArgumentInfo.getName(),anArgumentInfo.getCanonicalName(),arg.uncheckedGet()));
    try {
      anArgumentInfo.verify(verifiers);
    }
 catch (    IllegalArgumentException e) {
      argsConstraintsFailed.add(anArgumentInfo.getName() + ""String_Node_Str"" + e.getMessage());
    }
  }
  ImmutableMultimap<String,String> warningMessages=ImmutableMultimap.<String,String>builder().putAll(""String_Node_Str"",Sets.difference(args.keySet(),argsByName.keySet())).putAll(""String_Node_Str"",argsFailedToParse).putAll(""String_Node_Str"",argsConstraintsFailed).build();
  if (!warningMessages.isEmpty()) {
    printHelp(verifiers,argumentInfo);
    StringBuilder sb=new StringBuilder();
    for (    Map.Entry<String,Collection<String>> warnings : warningMessages.asMap().entrySet()) {
      sb.append(warnings.getKey()).append(""String_Node_Str"").append(Joiner.on(""String_Node_Str"").join(warnings.getValue())).append(""String_Node_Str"");
    }
    throw new IllegalArgumentException(sb.toString());
  }
  LOG.info(""String_Node_Str"");
  LOG.info(""String_Node_Str"");
  for (  String commandLineArgumentInfo : commandLineArgumentInfos) {
    LOG.info(commandLineArgumentInfo);
  }
  LOG.info(""String_Node_Str"");
  return true;
}","/** 
 * Applies argument values to fields based on their annotations.
 * @param parserOracle ParserOracle available to parse raw args with.
 * @param verifiers Verifiers available to verify argument constraints with.
 * @param argumentInfo Fields to apply argument values to.
 * @param args Unparsed argument values.
 * @param positionalArgs The unparsed positional arguments.
 * @return {@code true} if the given {@code args} were successfully applied to theircorresponding  {@link com.twitter.common.args.Arg} fields.
 */
private boolean process(final ParserOracle parserOracle,Verifiers verifiers,Args.ArgumentInfo argumentInfo,Map<String,String> args,List<String> positionalArgs){
  if (!Sets.intersection(args.keySet(),ArgumentInfo.HELP_ARGS).isEmpty()) {
    printHelp(verifiers,argumentInfo);
    return false;
  }
  Optional<? extends PositionalInfo<?>> positionalInfoOptional=argumentInfo.getPositionalInfo();
  checkArgument(positionalInfoOptional.isPresent() || positionalArgs.isEmpty(),""String_Node_Str"");
  Iterable<? extends OptionInfo<?>> optionInfos=argumentInfo.getOptionInfos();
  final Set<String> argsFailedToParse=Sets.newHashSet();
  final Set<String> argsConstraintsFailed=Sets.newHashSet();
  Set<String> argAllShortNamesNoCollisions=getNoCollisions(optionInfos);
  final Map<String,OptionInfo> argsByName=ImmutableMap.<String,OptionInfo>builder().putAll(Maps.uniqueIndex(Iterables.filter(optionInfos,Predicates.compose(Predicates.in(argAllShortNamesNoCollisions),GET_OPTIONINFO_NAME)),GET_OPTIONINFO_NAME)).putAll(Maps.uniqueIndex(optionInfos,GET_CANONICAL_ARG_NAME)).putAll(Maps.uniqueIndex(Iterables.filter(Iterables.filter(optionInfos,IS_BOOLEAN),Predicates.compose(Predicates.in(argAllShortNamesNoCollisions),GET_OPTIONINFO_NEGATED_NAME)),GET_OPTIONINFO_NEGATED_NAME)).putAll(Maps.uniqueIndex(Iterables.filter(optionInfos,IS_BOOLEAN),GET_CANONICAL_NEGATED_ARG_NAME)).build();
  Set<String> recognizedArgs=Sets.intersection(argsByName.keySet(),args.keySet());
  for (  String argName : recognizedArgs) {
    String argValue=args.get(argName);
    OptionInfo optionInfo=argsByName.get(argName);
    try {
      optionInfo.load(parserOracle,argName,argValue);
    }
 catch (    IllegalArgumentException e) {
      argsFailedToParse.add(argName + ""String_Node_Str"" + e.getMessage());
    }
  }
  if (positionalInfoOptional.isPresent()) {
    PositionalInfo<?> positionalInfo=positionalInfoOptional.get();
    positionalInfo.load(parserOracle,positionalArgs);
  }
  Set<String> commandLineArgumentInfos=Sets.newTreeSet();
  Iterable<? extends ArgumentInfo<?>> allArguments=argumentInfo.getOptionInfos();
  if (positionalInfoOptional.isPresent()) {
    PositionalInfo<?> positionalInfo=positionalInfoOptional.get();
    allArguments=Iterables.concat(optionInfos,ImmutableList.of(positionalInfo));
  }
  for (  ArgumentInfo<?> anArgumentInfo : allArguments) {
    Arg<?> arg=anArgumentInfo.getArg();
    commandLineArgumentInfos.add(String.format(""String_Node_Str"",anArgumentInfo.getName(),anArgumentInfo.getCanonicalName(),arg.uncheckedGet()));
    try {
      anArgumentInfo.verify(verifiers);
    }
 catch (    IllegalArgumentException e) {
      argsConstraintsFailed.add(anArgumentInfo.getName() + ""String_Node_Str"" + e.getMessage());
    }
  }
  ImmutableMultimap<String,String> warningMessages=ImmutableMultimap.<String,String>builder().putAll(""String_Node_Str"",Sets.difference(args.keySet(),argsByName.keySet())).putAll(""String_Node_Str"",argsFailedToParse).putAll(""String_Node_Str"",argsConstraintsFailed).build();
  if (!warningMessages.isEmpty()) {
    printHelp(verifiers,argumentInfo);
    StringBuilder sb=new StringBuilder();
    for (    Map.Entry<String,Collection<String>> warnings : warningMessages.asMap().entrySet()) {
      sb.append(warnings.getKey()).append(""String_Node_Str"").append(Joiner.on(""String_Node_Str"").join(warnings.getValue())).append(""String_Node_Str"");
    }
    throw new IllegalArgumentException(sb.toString());
  }
  LOG.info(""String_Node_Str"");
  LOG.info(""String_Node_Str"");
  for (  String commandLineArgumentInfo : commandLineArgumentInfos) {
    LOG.info(commandLineArgumentInfo);
  }
  LOG.info(""String_Node_Str"");
  return true;
}",0.8844584353503556
1414,"@Override public synchronized long getQuantile(double q){
  if (count == 0) {
    return 0L;
  }
  int buf0Size=Math.min(bufferSize,leafCount);
  int buf1Size=Math.max(0,leafCount - buf0Size);
  long sum=0;
  long target=(long)(count * q);
  int i=0;
  Arrays.sort(buffer[0],0,buf0Size);
  Arrays.sort(buffer[1],0,buf1Size);
  Arrays.fill(indices,0);
  while (sum < target) {
    i=smallest(buf0Size,buf1Size,indices);
    indices[i]++;
    sum+=weight(i);
  }
  return buffer[i][indices[i] - 1];
}","@Override public synchronized long getQuantile(double q){
  if (count == 0) {
    return 0L;
  }
  int buf0Size=Math.min(bufferSize,leafCount);
  int buf1Size=Math.max(0,leafCount - buf0Size);
  long sum=0;
  long target=(long)(count * q);
  int i=0;
  Arrays.sort(buffer[0],0,buf0Size);
  Arrays.sort(buffer[1],0,buf1Size);
  Arrays.fill(indices,0);
  do {
    i=smallest(buf0Size,buf1Size,indices);
    indices[i]++;
    sum+=weight(i);
  }
 while (sum < target);
  return buffer[i][indices[i] - 1];
}",0.955044955044955
1415,"/** 
 * Bind a long value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindLong(int index,long value){
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_long(index,value);
  }
  finally {
    releaseReference();
  }
}","/** 
 * Bind a long value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindLong(int index,long value){
  if (mClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_long(index,value);
  }
  finally {
    releaseReference();
  }
}",0.8916116870876531
1416,"/** 
 * Bind a byte array value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindBlob(int index,byte[] value){
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + index + ""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_blob(index,value);
  }
  finally {
    releaseReference();
  }
}","/** 
 * Bind a byte array value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindBlob(int index,byte[] value){
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + index + ""String_Node_Str"");
  }
  if (mClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_blob(index,value);
  }
  finally {
    releaseReference();
  }
}",0.9409961685823754
1417,"/** 
 * Clears all existing bindings. Unset bindings are treated as NULL.
 */
public void clearBindings(){
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_clear_bindings();
  }
  finally {
    releaseReference();
  }
}","/** 
 * Clears all existing bindings. Unset bindings are treated as NULL.
 */
public void clearBindings(){
  if (mClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_clear_bindings();
  }
  finally {
    releaseReference();
  }
}",0.8988173455978975
1418,"/** 
 * Bind a double value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindDouble(int index,double value){
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_double(index,value);
  }
  finally {
    releaseReference();
  }
}","/** 
 * Bind a double value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindDouble(int index,double value){
  if (mClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_double(index,value);
  }
  finally {
    releaseReference();
  }
}",0.89322191272052
1419,"/** 
 * Bind a String value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindString(int index,String value){
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + index + ""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_string(index,value);
  }
  finally {
    releaseReference();
  }
}","/** 
 * Bind a String value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindString(int index,String value){
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + index + ""String_Node_Str"");
  }
  if (mClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_string(index,value);
  }
  finally {
    releaseReference();
  }
}",0.9409961685823754
1420,"/** 
 * Bind a NULL value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind null to
 */
public void bindNull(int index){
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_null(index);
  }
  finally {
    releaseReference();
  }
}","/** 
 * Bind a NULL value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind null to
 */
public void bindNull(int index){
  if (mClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_null(index);
  }
  finally {
    releaseReference();
  }
}",0.921025641025641
1421,"/** 
 * Release this program's resources, making it invalid.
 */
public void close(){
  if (!mDatabase.isOpen()) {
    return;
  }
  mDatabase.lock();
  try {
    releaseReference();
  }
  finally {
    mDatabase.unlock();
  }
}","/** 
 * Release this program's resources, making it invalid.
 */
public void close(){
  if (mClosed) {
    return;
  }
  if (!mDatabase.isOpen()) {
    return;
  }
  mDatabase.lock();
  try {
    releaseReference();
  }
  finally {
    mDatabase.unlock();
  }
  mClosed=true;
}",0.899009900990099
1422,"/** 
 * Bind a long value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindLong(int index,long value){
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_long(index,value);
  }
  finally {
    releaseReference();
  }
}","/** 
 * Bind a long value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindLong(int index,long value){
  if (mClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_long(index,value);
  }
  finally {
    releaseReference();
  }
}",0.8916116870876531
1423,"/** 
 * Bind a byte array value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindBlob(int index,byte[] value){
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + index + ""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_blob(index,value);
  }
  finally {
    releaseReference();
  }
}","/** 
 * Bind a byte array value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindBlob(int index,byte[] value){
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + index + ""String_Node_Str"");
  }
  if (mClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_blob(index,value);
  }
  finally {
    releaseReference();
  }
}",0.9409961685823754
1424,"/** 
 * Clears all existing bindings. Unset bindings are treated as NULL.
 */
public void clearBindings(){
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_clear_bindings();
  }
  finally {
    releaseReference();
  }
}","/** 
 * Clears all existing bindings. Unset bindings are treated as NULL.
 */
public void clearBindings(){
  if (mClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_clear_bindings();
  }
  finally {
    releaseReference();
  }
}",0.8988173455978975
1425,"/** 
 * Bind a double value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindDouble(int index,double value){
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_double(index,value);
  }
  finally {
    releaseReference();
  }
}","/** 
 * Bind a double value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindDouble(int index,double value){
  if (mClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_double(index,value);
  }
  finally {
    releaseReference();
  }
}",0.89322191272052
1426,"/** 
 * Bind a String value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindString(int index,String value){
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + index + ""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_string(index,value);
  }
  finally {
    releaseReference();
  }
}","/** 
 * Bind a String value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
public void bindString(int index,String value){
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + index + ""String_Node_Str"");
  }
  if (mClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_string(index,value);
  }
  finally {
    releaseReference();
  }
}",0.9409961685823754
1427,"/** 
 * Bind a NULL value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind null to
 */
public void bindNull(int index){
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_null(index);
  }
  finally {
    releaseReference();
  }
}","/** 
 * Bind a NULL value to this statement. The value remains bound until  {@link #clearBindings} is called.
 * @param index The 1-based index to the parameter to bind null to
 */
public void bindNull(int index){
  if (mClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!mDatabase.isOpen()) {
    throw new IllegalStateException(""String_Node_Str"" + mDatabase.getPath() + ""String_Node_Str"");
  }
  acquireReference();
  try {
    native_bind_null(index);
  }
  finally {
    releaseReference();
  }
}",0.921025641025641
1428,"/** 
 * Release this program's resources, making it invalid.
 */
public void close(){
  if (!mDatabase.isOpen()) {
    return;
  }
  mDatabase.lock();
  try {
    releaseReference();
  }
  finally {
    mDatabase.unlock();
  }
}","/** 
 * Release this program's resources, making it invalid.
 */
public void close(){
  if (mClosed) {
    return;
  }
  if (!mDatabase.isOpen()) {
    return;
  }
  mDatabase.lock();
  try {
    releaseReference();
  }
  finally {
    mDatabase.unlock();
  }
  mClosed=true;
}",0.899009900990099
1429,"/** 
 * Convenience method for updating rows in the database.
 * @param table the table to update in
 * @param values a map from column names to new column values. null is avalid value that will be translated to NULL.
 * @param whereClause the optional WHERE clause to apply when updating.Passing null will update all rows.
 * @param conflictAlgorithm for update conflict resolver
 * @return the number of rows affected
 */
public int updateWithOnConflict(String table,ContentValues values,String whereClause,String[] whereArgs,int conflictAlgorithm){
  if (values == null || values.size() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  StringBuilder sql=new StringBuilder(120);
  sql.append(""String_Node_Str"");
  sql.append(CONFLICT_VALUES[conflictAlgorithm]);
  sql.append(table);
  sql.append(""String_Node_Str"");
  Set<Map.Entry<String,Object>> entrySet=values.valueSet();
  Iterator<Map.Entry<String,Object>> entriesIter=entrySet.iterator();
  while (entriesIter.hasNext()) {
    Map.Entry<String,Object> entry=entriesIter.next();
    sql.append(entry.getKey());
    sql.append(""String_Node_Str"");
    if (entriesIter.hasNext()) {
      sql.append(""String_Node_Str"");
    }
  }
  if (!TextUtils.isEmpty(whereClause)) {
    sql.append(""String_Node_Str"");
    sql.append(whereClause);
  }
  lock();
  if (!isOpen()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  SQLiteStatement statement=null;
  try {
    statement=compileStatement(sql.toString());
    int size=entrySet.size();
    entriesIter=entrySet.iterator();
    int bindArg=1;
    for (int i=0; i < size; i++) {
      Map.Entry<String,Object> entry=entriesIter.next();
      DatabaseUtils.bindObjectToProgram(statement,bindArg,entry.getValue());
      bindArg++;
    }
    if (whereArgs != null) {
      size=whereArgs.length;
      for (int i=0; i < size; i++) {
        statement.bindString(bindArg,whereArgs[i]);
        bindArg++;
      }
    }
    statement.execute();
    int numChangedRows=lastChangeCount();
    if (Config.LOGD && Log.isLoggable(TAG,Log.VERBOSE)) {
      Log.v(TAG,""String_Node_Str"" + numChangedRows + ""String_Node_Str""+ values+ ""String_Node_Str""+ sql);
    }
    return numChangedRows;
  }
 catch (  SQLiteDatabaseCorruptException e) {
    onCorruption();
    throw e;
  }
catch (  SQLException e) {
    Log.e(TAG,""String_Node_Str"" + values + ""String_Node_Str""+ sql);
    throw e;
  }
 finally {
    if (statement != null) {
      statement.close();
    }
    unlock();
  }
}","/** 
 * Convenience method for updating rows in the database.
 * @param table the table to update in
 * @param values a map from column names to new column values. null is avalid value that will be translated to NULL.
 * @param whereClause the optional WHERE clause to apply when updating.Passing null will update all rows.
 * @param conflictAlgorithm for update conflict resolver
 * @return the number of rows affected
 */
public int updateWithOnConflict(String table,ContentValues values,String whereClause,String[] whereArgs,int conflictAlgorithm){
  if (values == null || values.size() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  StringBuilder sql=new StringBuilder(120);
  sql.append(""String_Node_Str"");
  sql.append(CONFLICT_VALUES[conflictAlgorithm]);
  sql.append(table);
  sql.append(""String_Node_Str"");
  Set<Map.Entry<String,Object>> entrySet=values.valueSet();
  Iterator<Map.Entry<String,Object>> entriesIter=entrySet.iterator();
  while (entriesIter.hasNext()) {
    Map.Entry<String,Object> entry=entriesIter.next();
    sql.append(entry.getKey());
    sql.append(""String_Node_Str"");
    if (entriesIter.hasNext()) {
      sql.append(""String_Node_Str"");
    }
  }
  if (!TextUtils.isEmpty(whereClause)) {
    sql.append(""String_Node_Str"");
    sql.append(whereClause);
  }
  lock();
  if (!isOpen()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  SQLiteStatement statement=null;
  try {
    statement=compileStatement(sql.toString());
    int size=entrySet.size();
    entriesIter=entrySet.iterator();
    int bindArg=1;
    for (int i=0; i < size; i++) {
      Map.Entry<String,Object> entry=entriesIter.next();
      DatabaseUtils.bindObjectToProgram(statement,bindArg,entry.getValue());
      bindArg++;
    }
    if (whereArgs != null) {
      size=whereArgs.length;
      for (int i=0; i < size; i++) {
        statement.bindString(bindArg,whereArgs[i]);
        bindArg++;
      }
    }
    statement.execute();
    int numChangedRows=lastChangeCount();
    if (Config.LOGD && Log.isLoggable(TAG,Log.VERBOSE)) {
      Log.v(TAG,""String_Node_Str"" + numChangedRows + ""String_Node_Str""+ table);
    }
    return numChangedRows;
  }
 catch (  SQLiteDatabaseCorruptException e) {
    onCorruption();
    throw e;
  }
catch (  SQLException e) {
    Log.e(TAG,""String_Node_Str"" + table);
    throw e;
  }
 finally {
    if (statement != null) {
      statement.close();
    }
    unlock();
  }
}",0.9856883692803872
1430,"/** 
 * Convenience method for replacing a row in the database.
 * @param table the table in which to replace the row
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,so if initialValues is empty this row will explicitly be assigned a NULL value
 * @param initialValues this map contains the initial column values forthe row. The key
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
public long replace(String table,String nullColumnHack,ContentValues initialValues){
  try {
    return insertWithOnConflict(table,nullColumnHack,initialValues,CONFLICT_REPLACE);
  }
 catch (  SQLException e) {
    Log.e(TAG,""String_Node_Str"" + initialValues,e);
    return -1;
  }
}","/** 
 * Convenience method for replacing a row in the database.
 * @param table the table in which to replace the row
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,so if initialValues is empty this row will explicitly be assigned a NULL value
 * @param initialValues this map contains the initial column values forthe row. The key
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
public long replace(String table,String nullColumnHack,ContentValues initialValues){
  try {
    return insertWithOnConflict(table,nullColumnHack,initialValues,CONFLICT_REPLACE);
  }
 catch (  SQLException e) {
    Log.e(TAG,""String_Node_Str"" + table,e);
    return -1;
  }
}",0.9875
1431,"/** 
 * Runs the provided SQL and returns a cursor over the result set.
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,which will be replaced by the values from selectionArgs. The values will be bound as Strings.
 * @param editTable the name of the first table, which is editable
 * @return A {@link Cursor} object, which is positioned before the first entry. Note that{@link Cursor}s are not synchronized, see the documentation for more details.
 */
public Cursor rawQueryWithFactory(CursorFactory cursorFactory,String sql,String[] selectionArgs,String editTable){
  if (!isOpen()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  long timeStart=0;
  if (Config.LOGV || mSlowQueryThreshold != -1) {
    timeStart=System.currentTimeMillis();
  }
  SQLiteCursorDriver driver=new SQLiteDirectCursorDriver(this,sql,editTable);
  Cursor cursor=null;
  try {
    cursor=driver.query(cursorFactory != null ? cursorFactory : mFactory,selectionArgs);
  }
  finally {
    if (Config.LOGV || mSlowQueryThreshold != -1) {
      int count=-1;
      if (cursor != null) {
        count=cursor.getCount();
      }
      long duration=System.currentTimeMillis() - timeStart;
      if (Config.LOGV || duration >= mSlowQueryThreshold) {
        Log.v(TAG,""String_Node_Str"" + duration + ""String_Node_Str""+ driver.toString()+ ""String_Node_Str""+ (selectionArgs != null ? TextUtils.join(""String_Node_Str"",selectionArgs) : ""String_Node_Str"")+ ""String_Node_Str""+ count);
      }
    }
  }
  return new CrossProcessCursorWrapper(cursor);
}","/** 
 * Runs the provided SQL and returns a cursor over the result set.
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,which will be replaced by the values from selectionArgs. The values will be bound as Strings.
 * @param editTable the name of the first table, which is editable
 * @return A {@link Cursor} object, which is positioned before the first entry. Note that{@link Cursor}s are not synchronized, see the documentation for more details.
 */
public Cursor rawQueryWithFactory(CursorFactory cursorFactory,String sql,String[] selectionArgs,String editTable){
  if (!isOpen()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  long timeStart=0;
  if (Config.LOGV || mSlowQueryThreshold != -1) {
    timeStart=System.currentTimeMillis();
  }
  SQLiteCursorDriver driver=new SQLiteDirectCursorDriver(this,sql,editTable);
  Cursor cursor=null;
  try {
    cursor=driver.query(cursorFactory != null ? cursorFactory : mFactory,selectionArgs);
  }
  finally {
    if (Config.LOGV || mSlowQueryThreshold != -1) {
      int count=-1;
      if (cursor != null) {
        count=cursor.getCount();
      }
      long duration=System.currentTimeMillis() - timeStart;
      if (Config.LOGV || duration >= mSlowQueryThreshold) {
        Log.v(TAG,""String_Node_Str"" + duration + ""String_Node_Str""+ driver.toString()+ ""String_Node_Str""+ count);
      }
    }
  }
  return new CrossProcessCursorWrapper(cursor);
}",0.9654545454545456
1432,"/** 
 * General method for inserting a row into the database.
 * @param table the table to insert the row into
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,so if initialValues is empty this column will explicitly be assigned a NULL value
 * @param initialValues this map contains the initial column values for therow. The keys should be the column names and the values the column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted rowOR the primary key of the existing row if the input param 'conflictAlgorithm' = {@link #CONFLICT_IGNORE}OR -1 if any error
 */
public long insertWithOnConflict(String table,String nullColumnHack,ContentValues initialValues,int conflictAlgorithm){
  if (!isOpen()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  StringBuilder sql=new StringBuilder(152);
  sql.append(""String_Node_Str"");
  sql.append(CONFLICT_VALUES[conflictAlgorithm]);
  sql.append(""String_Node_Str"");
  sql.append(table);
  StringBuilder values=new StringBuilder(40);
  Set<Map.Entry<String,Object>> entrySet=null;
  if (initialValues != null && initialValues.size() > 0) {
    entrySet=initialValues.valueSet();
    Iterator<Map.Entry<String,Object>> entriesIter=entrySet.iterator();
    sql.append('(');
    boolean needSeparator=false;
    while (entriesIter.hasNext()) {
      if (needSeparator) {
        sql.append(""String_Node_Str"");
        values.append(""String_Node_Str"");
      }
      needSeparator=true;
      Map.Entry<String,Object> entry=entriesIter.next();
      sql.append(entry.getKey());
      values.append('?');
    }
    sql.append(')');
  }
 else {
    sql.append(""String_Node_Str"" + nullColumnHack + ""String_Node_Str"");
    values.append(""String_Node_Str"");
  }
  sql.append(""String_Node_Str"");
  sql.append(values);
  sql.append(""String_Node_Str"");
  lock();
  SQLiteStatement statement=null;
  try {
    statement=compileStatement(sql.toString());
    if (entrySet != null) {
      int size=entrySet.size();
      Iterator<Map.Entry<String,Object>> entriesIter=entrySet.iterator();
      for (int i=0; i < size; i++) {
        Map.Entry<String,Object> entry=entriesIter.next();
        DatabaseUtils.bindObjectToProgram(statement,i + 1,entry.getValue());
      }
    }
    statement.execute();
    long insertedRowId=lastInsertRow();
    if (insertedRowId == -1) {
      Log.e(TAG,""String_Node_Str"" + initialValues + ""String_Node_Str""+ sql);
    }
 else {
      if (Config.LOGD && Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,""String_Node_Str"" + insertedRowId + ""String_Node_Str""+ initialValues+ ""String_Node_Str""+ sql);
      }
    }
    return insertedRowId;
  }
 catch (  SQLiteDatabaseCorruptException e) {
    onCorruption();
    throw e;
  }
 finally {
    if (statement != null) {
      statement.close();
    }
    unlock();
  }
}","/** 
 * General method for inserting a row into the database.
 * @param table the table to insert the row into
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,so if initialValues is empty this column will explicitly be assigned a NULL value
 * @param initialValues this map contains the initial column values for therow. The keys should be the column names and the values the column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted rowOR the primary key of the existing row if the input param 'conflictAlgorithm' = {@link #CONFLICT_IGNORE}OR -1 if any error
 */
public long insertWithOnConflict(String table,String nullColumnHack,ContentValues initialValues,int conflictAlgorithm){
  if (!isOpen()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  StringBuilder sql=new StringBuilder(152);
  sql.append(""String_Node_Str"");
  sql.append(CONFLICT_VALUES[conflictAlgorithm]);
  sql.append(""String_Node_Str"");
  sql.append(table);
  StringBuilder values=new StringBuilder(40);
  Set<Map.Entry<String,Object>> entrySet=null;
  if (initialValues != null && initialValues.size() > 0) {
    entrySet=initialValues.valueSet();
    Iterator<Map.Entry<String,Object>> entriesIter=entrySet.iterator();
    sql.append('(');
    boolean needSeparator=false;
    while (entriesIter.hasNext()) {
      if (needSeparator) {
        sql.append(""String_Node_Str"");
        values.append(""String_Node_Str"");
      }
      needSeparator=true;
      Map.Entry<String,Object> entry=entriesIter.next();
      sql.append(entry.getKey());
      values.append('?');
    }
    sql.append(')');
  }
 else {
    sql.append(""String_Node_Str"" + nullColumnHack + ""String_Node_Str"");
    values.append(""String_Node_Str"");
  }
  sql.append(""String_Node_Str"");
  sql.append(values);
  sql.append(""String_Node_Str"");
  lock();
  SQLiteStatement statement=null;
  try {
    statement=compileStatement(sql.toString());
    if (entrySet != null) {
      int size=entrySet.size();
      Iterator<Map.Entry<String,Object>> entriesIter=entrySet.iterator();
      for (int i=0; i < size; i++) {
        Map.Entry<String,Object> entry=entriesIter.next();
        DatabaseUtils.bindObjectToProgram(statement,i + 1,entry.getValue());
      }
    }
    statement.execute();
    long insertedRowId=lastInsertRow();
    if (insertedRowId == -1) {
      Log.e(TAG,""String_Node_Str"" + table);
    }
 else {
      if (Config.LOGD && Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,""String_Node_Str"" + insertedRowId + ""String_Node_Str""+ table);
      }
    }
    return insertedRowId;
  }
 catch (  SQLiteDatabaseCorruptException e) {
    onCorruption();
    throw e;
  }
 finally {
    if (statement != null) {
      statement.close();
    }
    unlock();
  }
}",0.9850746268656716
1433,"/** 
 * Convenience method for inserting a row into the database.
 * @param table the table to insert the row into
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,so if initialValues is empty this column will explicitly be assigned a NULL value
 * @param values this map contains the initial column values for therow. The keys should be the column names and the values the column values
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
public long insert(String table,String nullColumnHack,ContentValues values){
  try {
    return insertWithOnConflict(table,nullColumnHack,values,CONFLICT_NONE);
  }
 catch (  SQLException e) {
    Log.e(TAG,""String_Node_Str"" + values,e);
    return -1;
  }
}","/** 
 * Convenience method for inserting a row into the database.
 * @param table the table to insert the row into
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,so if initialValues is empty this column will explicitly be assigned a NULL value
 * @param values this map contains the initial column values for therow. The keys should be the column names and the values the column values
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
public long insert(String table,String nullColumnHack,ContentValues values){
  try {
    return insertWithOnConflict(table,nullColumnHack,values,CONFLICT_NONE);
  }
 catch (  SQLException e) {
    Log.e(TAG,""String_Node_Str"" + table,e);
    return -1;
  }
}",0.9926910299003322
1434,"/** 
 * Copy data from cursor to CursorWindow
 * @param position start position of data
 * @param window
 */
public void fillWindow(int position,android.database.CursorWindow window){
  if (position < 0 || position >= getCount()) {
    return;
  }
  window.acquireReference();
  try {
    int oldpos=mPos;
    mPos=position - 1;
    window.clear();
    window.setStartPosition(position);
    int columnNum=getColumnCount();
    window.setNumColumns(columnNum);
    while (moveToNext() && window.allocRow()) {
      for (int i=0; i < columnNum; i++) {
        String field=getString(i);
        if (field != null) {
          if (!window.putString(field,mPos,i)) {
            window.freeLastRow();
            break;
          }
        }
 else {
          if (!window.putNull(mPos,i)) {
            window.freeLastRow();
            break;
          }
        }
      }
    }
    mPos=oldpos;
  }
 catch (  IllegalStateException e) {
  }
 finally {
    window.releaseReference();
  }
}","/** 
 * Copy data from cursor to CursorWindow
 * @param position start position of data
 * @param window
 */
public void fillWindow(int position,android.database.CursorWindow window){
  DatabaseUtils.cursorFillWindow(this,position,window);
}",0.3113284433577832
1435,"@Override public void fillWindow(int position,CursorWindow window){
  if (position < 0 || position > getCount()) {
    return;
  }
  window.acquireReference();
  try {
    moveToPosition(position - 1);
    window.clear();
    window.setStartPosition(position);
    int columnNum=getColumnCount();
    window.setNumColumns(columnNum);
    while (moveToNext() && window.allocRow()) {
      for (int i=0; i < columnNum; i++) {
        String field=getString(i);
        if (field != null) {
          if (!window.putString(field,getPosition(),i)) {
            window.freeLastRow();
            break;
          }
        }
 else {
          if (!window.putNull(getPosition(),i)) {
            window.freeLastRow();
            break;
          }
        }
      }
    }
  }
 catch (  IllegalStateException e) {
  }
 finally {
    window.releaseReference();
  }
}","@Override public void fillWindow(int position,CursorWindow window){
  DatabaseUtils.cursorFillWindow(this,position,window);
}",0.182741116751269
1436,"private void addEvent(String title,String password){
  SQLiteDatabase db=eventsData.getWritableDatabase(password);
  ContentValues values=new ContentValues();
  values.put(EventDataSQLHelper.TIME,System.currentTimeMillis());
  values.put(EventDataSQLHelper.TITLE,title);
  db.insert(EventDataSQLHelper.TABLE,null,values);
}","private void addEvent(String title,SQLiteDatabase db){
  ContentValues values=new ContentValues();
  values.put(EventDataSQLHelper.TIME,System.currentTimeMillis());
  values.put(EventDataSQLHelper.TITLE,title);
  db.insert(EventDataSQLHelper.TABLE,null,values);
}",0.8430034129692833
1437,"private Cursor getEvents(String password){
  SQLiteDatabase db=eventsData.getReadableDatabase(password);
  Cursor cursor=db.query(EventDataSQLHelper.TABLE,null,null,null,null,null,null);
  startManagingCursor(cursor);
  return cursor;
}","private Cursor getEvents(SQLiteDatabase db){
  Cursor cursor=db.query(EventDataSQLHelper.TABLE,null,null,null,null,null,null);
  startManagingCursor(cursor);
  return cursor;
}",0.8495145631067961
1438,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  SQLiteDatabase.loadLibs(this);
  String password=""String_Node_Str"";
  eventsData=new EventDataSQLHelper(this);
  SQLiteDatabase db=eventsData.getWritableDatabase(password);
  addEvent(""String_Node_Str"",password);
  Cursor cursor=getEvents(password);
  showEvents(cursor);
  db.close();
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  SQLiteDatabase.loadLibs(this);
  String password=""String_Node_Str"";
  eventsData=new EventDataSQLHelper(this);
  SQLiteDatabase db=eventsData.getWritableDatabase(password);
  for (int i=1; i < 100; i++)   addEvent(""String_Node_Str"" + i,db);
  db.close();
  db=eventsData.getReadableDatabase(password);
  Cursor cursor=getEvents(db);
  showEvents(cursor);
  db.close();
}",0.8842105263157894
1439,"/** 
 * Copy data from cursor to CursorWindow
 * @param position start position of data
 * @param window
 */
public void fillWindow(int position,CursorWindow window){
  if (position < 0 || position > getCount()) {
    return;
  }
  window.acquireReference();
  try {
    int oldpos=mPos;
    mPos=position - 1;
    window.clear();
    window.setStartPosition(position);
    int columnNum=getColumnCount();
    window.setNumColumns(columnNum);
    while (moveToNext() && window.allocRow()) {
      for (int i=0; i < columnNum; i++) {
        String field=getString(i);
        if (field != null) {
          if (!window.putString(field,mPos,i)) {
            window.freeLastRow();
            break;
          }
        }
 else {
          if (!window.putNull(mPos,i)) {
            window.freeLastRow();
            break;
          }
        }
      }
    }
    mPos=oldpos;
  }
 catch (  IllegalStateException e) {
  }
 finally {
    window.releaseReference();
  }
}","/** 
 * Copy data from cursor to CursorWindow
 * @param position start position of data
 * @param window
 */
public void fillWindow(int position,android.database.CursorWindow window){
  if (position < 0 || position > getCount()) {
    return;
  }
  window.acquireReference();
  try {
    int oldpos=mPos;
    mPos=position - 1;
    window.clear();
    window.setStartPosition(position);
    int columnNum=getColumnCount();
    window.setNumColumns(columnNum);
    while (moveToNext() && window.allocRow()) {
      for (int i=0; i < columnNum; i++) {
        String field=getString(i);
        if (field != null) {
          if (!window.putString(field,mPos,i)) {
            window.freeLastRow();
            break;
          }
        }
 else {
          if (!window.putNull(mPos,i)) {
            window.freeLastRow();
            break;
          }
        }
      }
    }
    mPos=oldpos;
  }
 catch (  IllegalStateException e) {
  }
 finally {
    window.releaseReference();
  }
}",0.991295442908346
1440,"public boolean requery(){
  if (mSelfObserver != null && mSelfObserverRegistered == false) {
    mSelfObserverRegistered=true;
  }
  mDataSetObservable.notifyChanged();
  return true;
}","public boolean requery(){
  if (mSelfObserver != null && mSelfObserverRegistered == false) {
    mContentResolver.registerContentObserver(mNotifyUri,true,mSelfObserver);
    mSelfObserverRegistered=true;
  }
  mDataSetObservable.notifyChanged();
  return true;
}",0.8277404921700223
1441,"/** 
 * @hide
 */
public void deactivateInternal(){
  if (mSelfObserver != null) {
    mSelfObserverRegistered=false;
  }
  mDataSetObservable.notifyInvalidated();
}","/** 
 * @hide
 */
public void deactivateInternal(){
  if (mSelfObserver != null) {
    mContentResolver.unregisterContentObserver(mSelfObserver);
    mSelfObserverRegistered=false;
  }
  mDataSetObservable.notifyInvalidated();
}",0.8396946564885496
1442,"/** 
 * Gets a SelfDataChangeOberserver that can be sent to a remote process to receive change notifications over IPC.
 * @return A SelfContentObserver hooked up to this Cursor
 */
public synchronized IContentObserver getObserver(){
  if (mObserverBridge == null) {
    mObserverBridge=new SelfContentObserver(this);
  }
  return mObserverBridge.getContentObserver();
}","/** 
 * Gets a SelfDataChangeOberserver that can be sent to a remote process to receive change notifications over IPC.
 * @return A SelfContentObserver hooked up to this Cursor
 */
public synchronized IContentObserver getObserver(){
  if (mObserverBridge == null) {
    mObserverBridge=new SelfContentObserver(this);
  }
  return null;
}",0.943342776203966
1443,"private Bitmap getBitmapFromUrl(String url){
  Bitmap bitmap=null;
  try {
    URLConnection conn=new URL(url).openConnection();
    conn.setConnectTimeout(CONNECT_TIMEOUT);
    conn.setReadTimeout(READ_TIMEOUT);
    bitmap=BitmapFactory.decodeStream((InputStream)conn.getContent());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return bitmap;
}","private Bitmap getBitmapFromUrl(String url){
  Bitmap bitmap=null;
  try {
    URLConnection conn=new URL(url).openConnection();
    conn.setConnectTimeout(CONNECT_TIMEOUT);
    conn.setReadTimeout(READ_TIMEOUT);
    BitmapFactory.Options options=new BitmapFactory.Options();
    options.inSampleSize=8;
    Rect rect=new Rect(-1,-1,-1,-1);
    bitmap=BitmapFactory.decodeStream((InputStream)conn.getContent(),rect,options);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return bitmap;
}",0.8362369337979094
1444,"@Test public void toShortMessageWithFullConstructor() throws DeliveryReceiptException {
  DeliveryReceipt dlr=new DeliveryReceipt(""String_Node_Str"",1,1,new DateTime(0),new DateTime(0),SmppConstants.STATE_ENROUTE,0,""String_Node_Str"");
  String receipt=dlr.toShortMessage();
  Assert.assertEquals(""String_Node_Str"",receipt);
}","@Test public void toShortMessageWithFullConstructor() throws DeliveryReceiptException {
  DeliveryReceipt dlr=new DeliveryReceipt(""String_Node_Str"",1,1,new DateTime(0L,DateTimeZone.UTC),new DateTime(0L,DateTimeZone.UTC),SmppConstants.STATE_ENROUTE,0,""String_Node_Str"");
  String receipt=dlr.toShortMessage();
  Assert.assertEquals(""String_Node_Str"",receipt);
}",0.9473684210526316
1445,"@Override public int docID(){
  return primeDoc;
}","@Override public int docID(){
  return print(DOC_ID,primeDoc);
}",0.8771929824561403
1446,"@Override public int advance(int target) throws IOException {
  if (target == NO_MORE_DOCS) {
    return scorer.advance(NO_MORE_DOCS);
  }
  int doc=scorer.docID();
  int odoc=doc;
  if (isScorerExhausted(doc)) {
    return primeDoc=doc;
  }
  if (target > doc || doc == -1) {
    doc=scorer.advance(target);
    if (isScorerExhausted(doc)) {
      return primeDoc=doc;
    }
  }
 else   if (isScorerExhausted(doc)) {
    return primeDoc == -1 ? primeDoc=doc : primeDoc;
  }
  int gatherAllHitsSuperDoc=gatherAllHitsSuperDoc(doc);
  return gatherAllHitsSuperDoc;
}","@Override public int advance(int target) throws IOException {
  if (target == NO_MORE_DOCS) {
    return print(ADVANCE,primeDoc=scorer.advance(NO_MORE_DOCS));
  }
  int doc=scorer.docID();
  int odoc=doc;
  if (isScorerExhausted(doc)) {
    return print(ADVANCE,primeDoc=doc);
  }
  if (target > doc || doc == -1) {
    doc=scorer.advance(target);
    if (isScorerExhausted(doc)) {
      return print(ADVANCE,primeDoc=doc);
    }
  }
 else   if (isScorerExhausted(doc)) {
    return print(ADVANCE,primeDoc == -1 ? primeDoc=doc : primeDoc);
  }
  return print(ADVANCE,gatherAllHitsSuperDoc(doc));
}",0.8630490956072352
1447,"@Override public int nextDoc() throws IOException {
  int doc=scorer.docID();
  int odoc=doc;
  if (isScorerExhausted(doc)) {
    return primeDoc=doc;
  }
  if (doc == -1) {
    doc=scorer.nextDoc();
    if (isScorerExhausted(doc)) {
      return primeDoc=doc;
    }
  }
 else   if (isScorerExhausted(doc)) {
    return primeDoc == -1 ? primeDoc=doc : primeDoc;
  }
  int gatherAllHitsSuperDoc=gatherAllHitsSuperDoc(doc);
  return gatherAllHitsSuperDoc;
}","@Override public int nextDoc() throws IOException {
  int doc=scorer.docID();
  int odoc=doc;
  if (isScorerExhausted(doc)) {
    return primeDoc=doc;
  }
  if (doc == -1) {
    doc=scorer.nextDoc();
    if (isScorerExhausted(doc)) {
      return print(NEXT_DOC,primeDoc=doc);
    }
  }
 else   if (isScorerExhausted(doc)) {
    return print(NEXT_DOC,primeDoc == -1 ? primeDoc=doc : primeDoc);
  }
  return print(NEXT_DOC,gatherAllHitsSuperDoc(doc));
}",0.86438809261301
1448,"private void setupData() throws BlurException, IOException {
  RowMutation mutation1=newRowMutation(TABLE,""String_Node_Str"",newRecordMutation(FAMILY,""String_Node_Str"",newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str"")));
  RowMutation mutation2=newRowMutation(TABLE,""String_Node_Str"",newRecordMutation(FAMILY,""String_Node_Str"",newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str"")));
  RowMutation mutation3=newRowMutation(TABLE,""String_Node_Str"",newRecordMutation(FAMILY,""String_Node_Str"",newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str"")));
  RowMutation mutation4=newRowMutation(TABLE,""String_Node_Str"",newRecordMutation(FAMILY,""String_Node_Str"",newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str"")));
  RowMutation mutation5=newRowMutation(TABLE,""String_Node_Str"",newRecordMutation(FAMILY,""String_Node_Str"",newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str"")),newRecordMutation(FAMILY,""String_Node_Str"",newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str"")));
  mutation5.waitToBeVisible=true;
  indexManager.mutate(mutation1);
  indexManager.mutate(mutation2);
  indexManager.mutate(mutation3);
  indexManager.mutate(mutation4);
  indexManager.mutate(mutation5);
}","private void setupData() throws BlurException, IOException {
  RowMutation mutation1=newRowMutation(TABLE,""String_Node_Str"",newRecordMutation(FAMILY,""String_Node_Str"",newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str"")));
  RowMutation mutation2=newRowMutation(TABLE,""String_Node_Str"",newRecordMutation(FAMILY,""String_Node_Str"",newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str"")),newRecordMutation(FAMILY,""String_Node_Str"",newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str"")));
  RowMutation mutation3=newRowMutation(TABLE,""String_Node_Str"",newRecordMutation(FAMILY,""String_Node_Str"",newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str"")));
  RowMutation mutation4=newRowMutation(TABLE,""String_Node_Str"",newRecordMutation(FAMILY,""String_Node_Str"",newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str"")),newRecordMutation(FAMILY,""String_Node_Str"",newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str"")));
  RowMutation mutation5=newRowMutation(TABLE,""String_Node_Str"",newRecordMutation(FAMILY,""String_Node_Str"",newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str"")),newRecordMutation(FAMILY,""String_Node_Str"",newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str""),newColumn(""String_Node_Str"",""String_Node_Str"")));
  mutation5.waitToBeVisible=true;
  indexManager.mutate(mutation1);
  indexManager.mutate(mutation2);
  indexManager.mutate(mutation3);
  indexManager.mutate(mutation4);
  indexManager.mutate(mutation5);
}",0.926829268292683
1449,"public void init() throws IOException {
  initIndexWriterConfig();
  initIndexReader(IndexReader.open(getDirectory(),true));
}","public void init() throws IOException {
  initIndexWriterConfig();
  DirectIODirectory directory=getDirectory();
  if (!IndexReader.indexExists(directory)) {
    IndexWriterConfig conf=new IndexWriterConfig(Version.LUCENE_35,new KeywordAnalyzer());
    new IndexWriter(directory,conf).close();
  }
  initIndexReader(IndexReader.open(directory,true));
}",0.4476987447698745
1450,"private void waitForTheTableToEnable(String cluster,String table) throws BlurException {
  LOG.info(""String_Node_Str"" + table + ""String_Node_Str"");
}","private void waitForTheTableToEnable(String cluster,String table) throws BlurException {
  LOG.info(""String_Node_Str"" + table + ""String_Node_Str"");
  while (true) {
    if (_clusterStatus.isEnabled(false,cluster,table)) {
      return;
    }
    try {
      Thread.sleep(3000);
    }
 catch (    InterruptedException e) {
      LOG.error(""String_Node_Str"" + table + ""String_Node_Str"",e);
      throw new BException(""String_Node_Str"" + table + ""String_Node_Str"",e);
    }
  }
}",0.4768
1451,"private void waitForTheTableToDisengage(String cluster,String table) throws BlurException, TException {
  LOG.info(""String_Node_Str"" + table + ""String_Node_Str"");
}","private void waitForTheTableToDisengage(String cluster,String table) throws BlurException, TException {
}",0.7806691449814126
1452,"public static void main(String[] args) throws TTransportException, IOException, KeeperException, InterruptedException, BlurException {
  int serverIndex=getServerIndex(args);
  LOG.info(""String_Node_Str"");
  Thread.setDefaultUncaughtExceptionHandler(new SimpleUncaughtExceptionHandler());
  BlurConfiguration configuration=new BlurConfiguration();
  int numberOfBlocksPerBank=16384;
  int blockSize=BlockDirectory.BLOCK_SIZE;
  int bankCount=configuration.getInt(BLUR_SHARD_BLOCKCACHE_SLAB_COUNT,1);
  Configuration config=new Configuration();
  BlurMetrics blurMetrics=new BlurMetrics(config);
  boolean directAllocation=configuration.getBoolean(BLUR_SHARD_BLOCKCACHE_DIRECT_MEMORY_ALLOCATION,true);
  int slabSize=numberOfBlocksPerBank * blockSize;
  LOG.info(""String_Node_Str"",bankCount,directAllocation);
  LOG.info(""String_Node_Str"",slabSize,bankCount,((long)bankCount * (long)slabSize));
  BufferStore.init(configuration,blurMetrics);
  BlockCache blockCache;
  try {
    long totalMemory=bankCount * numberOfBlocksPerBank * blockSize;
    blockCache=new BlockCache(blurMetrics,directAllocation,totalMemory,slabSize,blockSize);
  }
 catch (  OutOfMemoryError e) {
    if (""String_Node_Str"".equals(e.getMessage())) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
    throw e;
  }
  BlockDirectoryCache cache=new BlockDirectoryCache(blockCache,blurMetrics);
  String bindAddress=configuration.get(BLUR_SHARD_BIND_ADDRESS);
  int bindPort=configuration.getInt(BLUR_SHARD_BIND_PORT,-1);
  bindPort+=serverIndex;
  LOG.info(""String_Node_Str"",serverIndex,bindAddress + ""String_Node_Str"" + bindPort);
  String nodeNameHostName=getNodeName(configuration,BLUR_SHARD_HOSTNAME);
  String nodeName=nodeNameHostName + ""String_Node_Str"" + bindPort;
  String zkConnectionStr=isEmpty(configuration.get(BLUR_ZOOKEEPER_CONNECTION),BLUR_ZOOKEEPER_CONNECTION);
  BlurQueryChecker queryChecker=new BlurQueryChecker(configuration);
  final ZooKeeper zooKeeper=ZkUtils.newZooKeeper(zkConnectionStr);
  try {
    ZookeeperSystemTime.checkSystemTime(zooKeeper,configuration.getLong(BLUR_ZOOKEEPER_SYSTEM_TIME_TOLERANCE,3000));
  }
 catch (  KeeperException e) {
    if (e.code() == Code.CONNECTIONLOSS) {
      System.err.println(""String_Node_Str"" + zkConnectionStr + ""String_Node_Str"");
      System.exit(1);
    }
  }
  final ZookeeperClusterStatus clusterStatus=new ZookeeperClusterStatus(zooKeeper);
  final BlurIndexRefresher refresher=new BlurIndexRefresher();
  refresher.init();
  BlurFilterCache filterCache=getFilterCache(configuration);
  BlurIndexWarmup indexWarmup=getIndexWarmup(configuration);
  IndexDeletionPolicy indexDeletionPolicy=new TimeBasedIndexDeletionPolicy(configuration.getLong(BLUR_SHARD_INDEX_DELETION_POLICY_MAXAGE,60000));
  final DistributedIndexServer indexServer=new DistributedIndexServer();
  indexServer.setBlurMetrics(blurMetrics);
  indexServer.setCache(cache);
  indexServer.setClusterStatus(clusterStatus);
  indexServer.setConfiguration(config);
  indexServer.setNodeName(nodeName);
  indexServer.setRefresher(refresher);
  indexServer.setShardOpenerThreadCount(configuration.getInt(BLUR_SHARD_OPENER_THREAD_COUNT,16));
  indexServer.setZookeeper(zooKeeper);
  indexServer.setFilterCache(filterCache);
  indexServer.setSafeModeDelay(configuration.getLong(BLUR_SHARD_SAFEMODEDELAY,60000));
  indexServer.setWarmup(indexWarmup);
  indexServer.setIndexDeletionPolicy(indexDeletionPolicy);
  indexServer.setTimeBetweenCommits(configuration.getLong(BLUR_SHARD_TIME_BETWEEN_COMMITS,60000));
  indexServer.setTimeBetweenRefreshs(configuration.getLong(BLUR_SHARD_TIME_BETWEEN_REFRESHS,500));
  indexServer.init();
  final IndexManager indexManager=new IndexManager();
  indexManager.setIndexServer(indexServer);
  indexManager.setMaxClauseCount(configuration.getInt(BLUR_MAX_CLAUSE_COUNT,1024));
  indexManager.setThreadCount(configuration.getInt(BLUR_INDEXMANAGER_SEARCH_THREAD_COUNT,32));
  indexManager.setBlurMetrics(blurMetrics);
  indexManager.setFilterCache(filterCache);
  indexManager.init();
  final BlurShardServer shardServer=new BlurShardServer();
  shardServer.setIndexServer(indexServer);
  shardServer.setIndexManager(indexManager);
  shardServer.setZookeeper(zooKeeper);
  shardServer.setClusterStatus(clusterStatus);
  shardServer.setDataFetchThreadCount(configuration.getInt(BLUR_SHARD_DATA_FETCH_THREAD_COUNT,8));
  shardServer.setMaxQueryCacheElements(configuration.getInt(BLUR_SHARD_CACHE_MAX_QUERYCACHE_ELEMENTS,128));
  shardServer.setMaxTimeToLive(configuration.getLong(BLUR_SHARD_CACHE_MAX_TIMETOLIVE,TimeUnit.MINUTES.toMillis(1)));
  shardServer.setQueryChecker(queryChecker);
  shardServer.init();
  Iface iface=BlurUtil.recordMethodCallsAndAverageTimes(blurMetrics,shardServer,Iface.class);
  int threadCount=configuration.getInt(BLUR_SHARD_SERVER_THRIFT_THREAD_COUNT,32);
  final ThriftBlurShardServer server=new ThriftBlurShardServer();
  server.setNodeName(nodeName);
  server.setBindAddress(bindAddress);
  server.setBindPort(bindPort);
  server.setThreadCount(threadCount);
  server.setIface(iface);
  server.setConfiguration(configuration);
  new BlurServerShutDown().register(new BlurShutdown(){
    @Override public void shutdown(){
      ThreadWatcher threadWatcher=ThreadWatcher.instance();
      quietClose(refresher,server,shardServer,indexManager,indexServer,threadWatcher);
      System.exit(0);
    }
  }
,zooKeeper);
  server.start();
}","public static void main(String[] args) throws TTransportException, IOException, KeeperException, InterruptedException, BlurException {
  int serverIndex=getServerIndex(args);
  LOG.info(""String_Node_Str"");
  Thread.setDefaultUncaughtExceptionHandler(new SimpleUncaughtExceptionHandler());
  BlurConfiguration configuration=new BlurConfiguration();
  int numberOfBlocksPerBank=16384;
  int blockSize=BlockDirectory.BLOCK_SIZE;
  int bankCount=configuration.getInt(BLUR_SHARD_BLOCKCACHE_SLAB_COUNT,1);
  Configuration config=new Configuration();
  BlurMetrics blurMetrics=new BlurMetrics(config);
  boolean directAllocation=configuration.getBoolean(BLUR_SHARD_BLOCKCACHE_DIRECT_MEMORY_ALLOCATION,true);
  int slabSize=numberOfBlocksPerBank * blockSize;
  LOG.info(""String_Node_Str"",bankCount,directAllocation);
  LOG.info(""String_Node_Str"",slabSize,bankCount,((long)bankCount * (long)slabSize));
  BufferStore.init(configuration,blurMetrics);
  BlockCache blockCache;
  try {
    long totalMemory=(long)bankCount * (long)numberOfBlocksPerBank * (long)blockSize;
    blockCache=new BlockCache(blurMetrics,directAllocation,totalMemory,slabSize,blockSize);
  }
 catch (  OutOfMemoryError e) {
    if (""String_Node_Str"".equals(e.getMessage())) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
    throw e;
  }
  BlockDirectoryCache cache=new BlockDirectoryCache(blockCache,blurMetrics);
  String bindAddress=configuration.get(BLUR_SHARD_BIND_ADDRESS);
  int bindPort=configuration.getInt(BLUR_SHARD_BIND_PORT,-1);
  bindPort+=serverIndex;
  LOG.info(""String_Node_Str"",serverIndex,bindAddress + ""String_Node_Str"" + bindPort);
  String nodeNameHostName=getNodeName(configuration,BLUR_SHARD_HOSTNAME);
  String nodeName=nodeNameHostName + ""String_Node_Str"" + bindPort;
  String zkConnectionStr=isEmpty(configuration.get(BLUR_ZOOKEEPER_CONNECTION),BLUR_ZOOKEEPER_CONNECTION);
  BlurQueryChecker queryChecker=new BlurQueryChecker(configuration);
  final ZooKeeper zooKeeper=ZkUtils.newZooKeeper(zkConnectionStr);
  try {
    ZookeeperSystemTime.checkSystemTime(zooKeeper,configuration.getLong(BLUR_ZOOKEEPER_SYSTEM_TIME_TOLERANCE,3000));
  }
 catch (  KeeperException e) {
    if (e.code() == Code.CONNECTIONLOSS) {
      System.err.println(""String_Node_Str"" + zkConnectionStr + ""String_Node_Str"");
      System.exit(1);
    }
  }
  final ZookeeperClusterStatus clusterStatus=new ZookeeperClusterStatus(zooKeeper);
  final BlurIndexRefresher refresher=new BlurIndexRefresher();
  refresher.init();
  BlurFilterCache filterCache=getFilterCache(configuration);
  BlurIndexWarmup indexWarmup=getIndexWarmup(configuration);
  IndexDeletionPolicy indexDeletionPolicy=new TimeBasedIndexDeletionPolicy(configuration.getLong(BLUR_SHARD_INDEX_DELETION_POLICY_MAXAGE,60000));
  final DistributedIndexServer indexServer=new DistributedIndexServer();
  indexServer.setBlurMetrics(blurMetrics);
  indexServer.setCache(cache);
  indexServer.setClusterStatus(clusterStatus);
  indexServer.setConfiguration(config);
  indexServer.setNodeName(nodeName);
  indexServer.setRefresher(refresher);
  indexServer.setShardOpenerThreadCount(configuration.getInt(BLUR_SHARD_OPENER_THREAD_COUNT,16));
  indexServer.setZookeeper(zooKeeper);
  indexServer.setFilterCache(filterCache);
  indexServer.setSafeModeDelay(configuration.getLong(BLUR_SHARD_SAFEMODEDELAY,60000));
  indexServer.setWarmup(indexWarmup);
  indexServer.setIndexDeletionPolicy(indexDeletionPolicy);
  indexServer.setTimeBetweenCommits(configuration.getLong(BLUR_SHARD_TIME_BETWEEN_COMMITS,60000));
  indexServer.setTimeBetweenRefreshs(configuration.getLong(BLUR_SHARD_TIME_BETWEEN_REFRESHS,500));
  indexServer.init();
  final IndexManager indexManager=new IndexManager();
  indexManager.setIndexServer(indexServer);
  indexManager.setMaxClauseCount(configuration.getInt(BLUR_MAX_CLAUSE_COUNT,1024));
  indexManager.setThreadCount(configuration.getInt(BLUR_INDEXMANAGER_SEARCH_THREAD_COUNT,32));
  indexManager.setBlurMetrics(blurMetrics);
  indexManager.setFilterCache(filterCache);
  indexManager.init();
  final BlurShardServer shardServer=new BlurShardServer();
  shardServer.setIndexServer(indexServer);
  shardServer.setIndexManager(indexManager);
  shardServer.setZookeeper(zooKeeper);
  shardServer.setClusterStatus(clusterStatus);
  shardServer.setDataFetchThreadCount(configuration.getInt(BLUR_SHARD_DATA_FETCH_THREAD_COUNT,8));
  shardServer.setMaxQueryCacheElements(configuration.getInt(BLUR_SHARD_CACHE_MAX_QUERYCACHE_ELEMENTS,128));
  shardServer.setMaxTimeToLive(configuration.getLong(BLUR_SHARD_CACHE_MAX_TIMETOLIVE,TimeUnit.MINUTES.toMillis(1)));
  shardServer.setQueryChecker(queryChecker);
  shardServer.init();
  Iface iface=BlurUtil.recordMethodCallsAndAverageTimes(blurMetrics,shardServer,Iface.class);
  int threadCount=configuration.getInt(BLUR_SHARD_SERVER_THRIFT_THREAD_COUNT,32);
  final ThriftBlurShardServer server=new ThriftBlurShardServer();
  server.setNodeName(nodeName);
  server.setBindAddress(bindAddress);
  server.setBindPort(bindPort);
  server.setThreadCount(threadCount);
  server.setIface(iface);
  server.setConfiguration(configuration);
  new BlurServerShutDown().register(new BlurShutdown(){
    @Override public void shutdown(){
      ThreadWatcher threadWatcher=ThreadWatcher.instance();
      quietClose(refresher,server,shardServer,indexManager,indexServer,threadWatcher);
      System.exit(0);
    }
  }
,zooKeeper);
  server.start();
}",0.9983434566537824
1453,"@Override public boolean isEnabled(boolean useCache,String cluster,String table){
  if (useCache) {
    Boolean enabled=_enabledMap.get(getClusterTableKey(cluster,table));
    if (enabled == null) {
      throw new RuntimeException(""String_Node_Str"" + table + ""String_Node_Str"");
    }
 else {
      return enabled;
    }
  }
  LOG.debug(""String_Node_Str"");
  String tablePathIsEnabled=ZookeeperPathConstants.getTableEnabledPath(cluster,table);
  try {
    if (_zk.exists(tablePathIsEnabled,false) == null) {
      return false;
    }
  }
 catch (  KeeperException e) {
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  return true;
}","@Override public boolean isEnabled(boolean useCache,String cluster,String table){
  if (useCache) {
    Boolean enabled=_enabledMap.get(getClusterTableKey(cluster,table));
    if (enabled == null) {
      return false;
    }
 else {
      return enabled;
    }
  }
  LOG.debug(""String_Node_Str"");
  String tablePathIsEnabled=ZookeeperPathConstants.getTableEnabledPath(cluster,table);
  try {
    if (_zk.exists(tablePathIsEnabled,false) == null) {
      return false;
    }
  }
 catch (  KeeperException e) {
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  return true;
}",0.9364248317127898
1454,"private void waitForTheTableToEnable(String cluster,String table) throws BlurException {
  LOG.info(""String_Node_Str"" + table + ""String_Node_Str"");
  while (true) {
    if (_clusterStatus.isEnabled(true,cluster,table)) {
      return;
    }
    try {
      Thread.sleep(3000);
    }
 catch (    InterruptedException e) {
      LOG.error(""String_Node_Str"" + table + ""String_Node_Str"",e);
      throw new BException(""String_Node_Str"" + table + ""String_Node_Str"",e);
    }
  }
}","private void waitForTheTableToEnable(String cluster,String table) throws BlurException {
  LOG.info(""String_Node_Str"" + table + ""String_Node_Str"");
  while (true) {
    if (_clusterStatus.isEnabled(false,cluster,table)) {
      return;
    }
    try {
      Thread.sleep(3000);
    }
 catch (    InterruptedException e) {
      LOG.error(""String_Node_Str"" + table + ""String_Node_Str"",e);
      throw new BException(""String_Node_Str"" + table + ""String_Node_Str"",e);
    }
  }
}",0.9926393270241852
1455,"public static void disableTable(ZooKeeper zookeeper,String cluster,String table) throws IOException, InterruptedException, KeeperException {
  if (zookeeper.exists(ZookeeperPathConstants.getTablePath(cluster,table),false) == null) {
    throw new IOException(""String_Node_Str"" + table + ""String_Node_Str"");
  }
  String blurTableEnabledPath=ZookeeperPathConstants.getTableEnabledPath(cluster,table);
  if (zookeeper.exists(blurTableEnabledPath,false) == null) {
    throw new IOException(""String_Node_Str"" + table + ""String_Node_Str"");
  }
  zookeeper.delete(blurTableEnabledPath,-1);
  waitForWriteLocksToClear(zookeeper,cluster,table);
}","public static void disableTable(ZooKeeper zookeeper,String cluster,String table) throws IOException, InterruptedException, KeeperException {
  if (zookeeper.exists(ZookeeperPathConstants.getTablePath(cluster,table),false) == null) {
    throw new IOException(""String_Node_Str"" + table + ""String_Node_Str"");
  }
  String blurTableEnabledPath=ZookeeperPathConstants.getTableEnabledPath(cluster,table);
  if (zookeeper.exists(blurTableEnabledPath,false) == null) {
    throw new IOException(""String_Node_Str"" + table + ""String_Node_Str"");
  }
  zookeeper.delete(blurTableEnabledPath,-1);
}",0.9567346938775512
1456,"public static void enableTable(ZooKeeper zookeeper,String cluster,String table) throws IOException, KeeperException, InterruptedException {
  if (zookeeper.exists(ZookeeperPathConstants.getTablePath(cluster,table),false) == null) {
    throw new IOException(""String_Node_Str"" + table + ""String_Node_Str"");
  }
  String blurTableEnabledPath=ZookeeperPathConstants.getTableEnabledPath(cluster,table);
  if (zookeeper.exists(blurTableEnabledPath,false) != null) {
    throw new IOException(""String_Node_Str"" + table + ""String_Node_Str"");
  }
  zookeeper.create(blurTableEnabledPath,null,Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  int shardCount=getShardCount(zookeeper,cluster,table);
  waitForWriteLocksToEngage(zookeeper,cluster,table,shardCount);
}","public static void enableTable(ZooKeeper zookeeper,String cluster,String table) throws IOException, KeeperException, InterruptedException {
  if (zookeeper.exists(ZookeeperPathConstants.getTablePath(cluster,table),false) == null) {
    throw new IOException(""String_Node_Str"" + table + ""String_Node_Str"");
  }
  String blurTableEnabledPath=ZookeeperPathConstants.getTableEnabledPath(cluster,table);
  if (zookeeper.exists(blurTableEnabledPath,false) != null) {
    throw new IOException(""String_Node_Str"" + table + ""String_Node_Str"");
  }
  zookeeper.create(blurTableEnabledPath,null,Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
}",0.9115942028985508
1457,"@Override public final void enableTable(String table) throws BlurException, TException {
  try {
    String cluster=_clusterStatus.getCluster(false,table);
    if (cluster == null) {
      throw new BlurException(""String_Node_Str"" + table + ""String_Node_Str"",null);
    }
    EnableTable.enableTable(_zookeeper,cluster,table);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e,table);
    throw new BException(e.getMessage(),e);
  }
}","@Override public final void enableTable(String table) throws BlurException, TException {
  try {
    String cluster=_clusterStatus.getCluster(false,table);
    if (cluster == null) {
      throw new BlurException(""String_Node_Str"" + table + ""String_Node_Str"",null);
    }
    EnableTable.enableTable(_zookeeper,cluster,table);
    waitForTheTableToEnable(cluster,table);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e,table);
    throw new BException(e.getMessage(),e);
  }
}",0.953091684434968
1458,"public static void main(String[] args) throws TTransportException, IOException, KeeperException, InterruptedException, BlurException {
  int serverIndex=getServerIndex(args);
  LOG.info(""String_Node_Str"");
  Thread.setDefaultUncaughtExceptionHandler(new SimpleUncaughtExceptionHandler());
  BlurConfiguration configuration=new BlurConfiguration();
  String bindAddress=configuration.get(BLUR_CONTROLLER_BIND_ADDRESS);
  int bindPort=configuration.getInt(BLUR_CONTROLLER_BIND_PORT,-1);
  bindPort+=serverIndex;
  LOG.info(""String_Node_Str"",serverIndex,bindAddress + ""String_Node_Str"" + bindPort);
  Configuration config=new Configuration();
  BlurMetrics blurMetrics=new BlurMetrics(config);
  String nodeName=ThriftBlurShardServer.getNodeName(configuration,BLUR_CONTROLLER_HOSTNAME);
  nodeName=nodeName + ""String_Node_Str"" + bindPort;
  String zkConnectionStr=isEmpty(configuration.get(BLUR_ZOOKEEPER_CONNECTION),BLUR_ZOOKEEPER_CONNECTION);
  BlurQueryChecker queryChecker=new BlurQueryChecker(configuration);
  boolean crazyMode=false;
  if (args.length == 1 && args[1].equals(CRAZY)) {
    crazyMode=true;
  }
  final ZooKeeper zooKeeper=ZkUtils.newZooKeeper(zkConnectionStr);
  ZookeeperSystemTime.checkSystemTime(zooKeeper,configuration.getLong(BLUR_ZOOKEEPER_SYSTEM_TIME_TOLERANCE,3000));
  final ZookeeperClusterStatus clusterStatus=new ZookeeperClusterStatus(zooKeeper);
  BlurClient client=new BlurClientRemote();
  final BlurControllerServer controllerServer=new BlurControllerServer();
  controllerServer.setClient(client);
  controllerServer.setClusterStatus(clusterStatus);
  controllerServer.setZookeeper(zooKeeper);
  controllerServer.setNodeName(nodeName);
  controllerServer.setRemoteFetchCount(configuration.getInt(BLUR_CONTROLLER_REMOTE_FETCH_COUNT,100));
  controllerServer.setMaxQueryCacheElements(configuration.getInt(BLUR_CONTROLLER_CACHE_MAX_QUERYCACHE_ELEMENTS,128));
  controllerServer.setMaxTimeToLive(configuration.getLong(BLUR_CONTROLLER_CACHE_MAX_TIMETOLIVE,TimeUnit.MINUTES.toMillis(1)));
  controllerServer.setQueryChecker(queryChecker);
  controllerServer.setThreadCount(configuration.getInt(BLUR_CONTROLLER_SERVER_REMOTE_THREAD_COUNT,64));
  controllerServer.setMaxFetchRetries(configuration.getInt(BLUR_CONTROLLER_RETRY_MAX_FETCH_RETRIES,1));
  controllerServer.setMaxMutateRetries(configuration.getInt(BLUR_CONTROLLER_RETRY_MAX_MUTATE_RETRIES,1));
  controllerServer.setMaxDefaultRetries(configuration.getInt(BLUR_CONTROLLER_RETRY_MAX_DEFAULT_RETRIES,1));
  controllerServer.setFetchDelay(configuration.getInt(BLUR_CONTROLLER_RETRY_FETCH_DELAY,500));
  controllerServer.setMutateDelay(configuration.getInt(BLUR_CONTROLLER_RETRY_MUTATE_DELAY,500));
  controllerServer.setDefaultDelay(configuration.getInt(BLUR_CONTROLLER_RETRY_DEFAULT_DELAY,500));
  controllerServer.setMaxFetchDelay(configuration.getInt(BLUR_CONTROLLER_RETRY_MAX_FETCH_DELAY,2000));
  controllerServer.setMaxMutateDelay(configuration.getInt(BLUR_CONTROLLER_RETRY_MAX_MUTATE_DELAY,2000));
  controllerServer.setMaxDefaultDelay(configuration.getInt(BLUR_CONTROLLER_RETRY_MAX_DEFAULT_DELAY,2000));
  controllerServer.init();
  Iface iface=BlurUtil.recordMethodCallsAndAverageTimes(blurMetrics,controllerServer,Iface.class);
  int threadCount=configuration.getInt(BLUR_CONTROLLER_SERVER_THRIFT_THREAD_COUNT,32);
  final ThriftBlurControllerServer server=new ThriftBlurControllerServer();
  server.setNodeName(nodeName);
  server.setConfiguration(configuration);
  server.setBindAddress(bindAddress);
  server.setBindPort(bindPort);
  server.setThreadCount(threadCount);
  if (crazyMode) {
    System.err.println(""String_Node_Str"");
    server.setIface(ThriftBlurShardServer.crazyMode(iface));
  }
 else {
    server.setIface(iface);
  }
  new BlurServerShutDown().register(new BlurShutdown(){
    @Override public void shutdown(){
      ThreadWatcher threadWatcher=ThreadWatcher.instance();
      quietClose(server,controllerServer,clusterStatus,zooKeeper,threadWatcher);
      System.exit(0);
    }
  }
,zooKeeper);
  server.start();
}","public static void main(String[] args) throws TTransportException, IOException, KeeperException, InterruptedException, BlurException {
  int serverIndex=getServerIndex(args);
  LOG.info(""String_Node_Str"");
  Thread.setDefaultUncaughtExceptionHandler(new SimpleUncaughtExceptionHandler());
  BlurConfiguration configuration=new BlurConfiguration();
  String bindAddress=configuration.get(BLUR_CONTROLLER_BIND_ADDRESS);
  int bindPort=configuration.getInt(BLUR_CONTROLLER_BIND_PORT,-1);
  bindPort+=serverIndex;
  LOG.info(""String_Node_Str"",serverIndex,bindAddress + ""String_Node_Str"" + bindPort);
  Configuration config=new Configuration();
  BlurMetrics blurMetrics=new BlurMetrics(config);
  String nodeName=ThriftBlurShardServer.getNodeName(configuration,BLUR_CONTROLLER_HOSTNAME);
  nodeName=nodeName + ""String_Node_Str"" + bindPort;
  String zkConnectionStr=isEmpty(configuration.get(BLUR_ZOOKEEPER_CONNECTION),BLUR_ZOOKEEPER_CONNECTION);
  BlurQueryChecker queryChecker=new BlurQueryChecker(configuration);
  final ZooKeeper zooKeeper=ZkUtils.newZooKeeper(zkConnectionStr);
  ZookeeperSystemTime.checkSystemTime(zooKeeper,configuration.getLong(BLUR_ZOOKEEPER_SYSTEM_TIME_TOLERANCE,3000));
  final ZookeeperClusterStatus clusterStatus=new ZookeeperClusterStatus(zooKeeper);
  BlurClient client=new BlurClientRemote();
  final BlurControllerServer controllerServer=new BlurControllerServer();
  controllerServer.setClient(client);
  controllerServer.setClusterStatus(clusterStatus);
  controllerServer.setZookeeper(zooKeeper);
  controllerServer.setNodeName(nodeName);
  controllerServer.setRemoteFetchCount(configuration.getInt(BLUR_CONTROLLER_REMOTE_FETCH_COUNT,100));
  controllerServer.setMaxQueryCacheElements(configuration.getInt(BLUR_CONTROLLER_CACHE_MAX_QUERYCACHE_ELEMENTS,128));
  controllerServer.setMaxTimeToLive(configuration.getLong(BLUR_CONTROLLER_CACHE_MAX_TIMETOLIVE,TimeUnit.MINUTES.toMillis(1)));
  controllerServer.setQueryChecker(queryChecker);
  controllerServer.setThreadCount(configuration.getInt(BLUR_CONTROLLER_SERVER_REMOTE_THREAD_COUNT,64));
  controllerServer.setMaxFetchRetries(configuration.getInt(BLUR_CONTROLLER_RETRY_MAX_FETCH_RETRIES,1));
  controllerServer.setMaxMutateRetries(configuration.getInt(BLUR_CONTROLLER_RETRY_MAX_MUTATE_RETRIES,1));
  controllerServer.setMaxDefaultRetries(configuration.getInt(BLUR_CONTROLLER_RETRY_MAX_DEFAULT_RETRIES,1));
  controllerServer.setFetchDelay(configuration.getInt(BLUR_CONTROLLER_RETRY_FETCH_DELAY,500));
  controllerServer.setMutateDelay(configuration.getInt(BLUR_CONTROLLER_RETRY_MUTATE_DELAY,500));
  controllerServer.setDefaultDelay(configuration.getInt(BLUR_CONTROLLER_RETRY_DEFAULT_DELAY,500));
  controllerServer.setMaxFetchDelay(configuration.getInt(BLUR_CONTROLLER_RETRY_MAX_FETCH_DELAY,2000));
  controllerServer.setMaxMutateDelay(configuration.getInt(BLUR_CONTROLLER_RETRY_MAX_MUTATE_DELAY,2000));
  controllerServer.setMaxDefaultDelay(configuration.getInt(BLUR_CONTROLLER_RETRY_MAX_DEFAULT_DELAY,2000));
  controllerServer.init();
  Iface iface=BlurUtil.recordMethodCallsAndAverageTimes(blurMetrics,controllerServer,Iface.class);
  int threadCount=configuration.getInt(BLUR_CONTROLLER_SERVER_THRIFT_THREAD_COUNT,32);
  final ThriftBlurControllerServer server=new ThriftBlurControllerServer();
  server.setNodeName(nodeName);
  server.setConfiguration(configuration);
  server.setBindAddress(bindAddress);
  server.setBindPort(bindPort);
  server.setThreadCount(threadCount);
  server.setIface(iface);
  new BlurServerShutDown().register(new BlurShutdown(){
    @Override public void shutdown(){
      ThreadWatcher threadWatcher=ThreadWatcher.instance();
      quietClose(server,controllerServer,clusterStatus,zooKeeper,threadWatcher);
      System.exit(0);
    }
  }
,zooKeeper);
  server.start();
}",0.9671649418678931
1459,"public void deleteDocuments(boolean wal,Term term) throws CorruptIndexException, IOException {
  _dirty.incrementAndGet();
  deleteDocuments(wal,term);
}","public void deleteDocuments(boolean wal,Term... terms) throws CorruptIndexException, IOException {
  _dirty.incrementAndGet();
  if (wal) {
    Future<Boolean> valid=walWriterDelete(terms);
    super.deleteDocuments(terms);
    try {
      if (!valid.get()) {
        throw new IOException(""String_Node_Str"");
      }
    }
 catch (    InterruptedException e) {
      throw new IOException(e);
    }
catch (    ExecutionException e) {
      throw new IOException(e);
    }
  }
 else {
    super.deleteDocuments(terms);
  }
}",0.3574593796159527
1460,"@Override public void action(WalIndexWriter indexWriter) throws CorruptIndexException, IOException {
  Collection<Document> docs=getDocs();
  indexWriter.updateDocuments(false,new Term(""String_Node_Str"",""String_Node_Str""),docs);
}","@Override public void action(WalIndexWriter indexWriter) throws CorruptIndexException, IOException {
  indexWriter.deleteDocuments(true,new Term(""String_Node_Str"",""String_Node_Str""));
}",0.8626506024096385
1461,"public SuperParser(Version matchVersion,Analyzer a,boolean superSearch,Filter queryFilter,ScoreType scoreType){
  super(matchVersion,SUPER,a);
  this.setAllowLeadingWildcard(true);
  this.superSearch=superSearch;
  this.queryFilter=queryFilter;
  this.scoreType=scoreType;
}","public SuperParser(Version matchVersion,Analyzer a,boolean superSearch,Filter queryFilter,ScoreType scoreType){
  super(matchVersion,SUPER,a);
  this.setAutoGeneratePhraseQueries(true);
  this.setAllowLeadingWildcard(true);
  this.superSearch=superSearch;
  this.queryFilter=queryFilter;
  this.scoreType=scoreType;
}",0.9272419627749576
1462,"private void watchForTables(){
  _tablesToCluster=new Thread(new Runnable(){
    @Override public void run(){
      try {
        doWatch();
      }
 catch (      KeeperException e) {
        LOG.error(""String_Node_Str"",e);
      }
catch (      InterruptedException e) {
        return;
      }
    }
    private void doWatch() throws KeeperException, InterruptedException {
      while (_running.get()) {
synchronized (_tableToClusterCache) {
          String clusterPath=ZookeeperPathConstants.getClustersPath();
          List<String> clusters=_zk.getChildren(clusterPath,new Watcher(){
            @Override public void process(            WatchedEvent event){
synchronized (_tableToClusterCache) {
                _tableToClusterCache.notifyAll();
              }
            }
          }
);
          for (          String cluster : clusters) {
            List<String> tables=_zk.getChildren(ZookeeperPathConstants.getTablesPath(cluster),new Watcher(){
              @Override public void process(              WatchedEvent event){
synchronized (_tableToClusterCache) {
                  _tableToClusterCache.notifyAll();
                }
              }
            }
);
            Map<String,List<String>> newValue=new HashMap<String,List<String>>();
            for (            String table : tables) {
              List<String> clusterList=newValue.get(table);
              if (clusterList == null) {
                clusterList=new ArrayList<String>();
                newValue.put(table,clusterList);
              }
              clusterList.add(cluster);
            }
            _tableToClusterCache.set(newValue);
          }
          _tableToClusterCache.wait();
        }
      }
    }
  }
);
  _tablesToCluster.setDaemon(true);
  _tablesToCluster.setName(""String_Node_Str"");
  _tablesToCluster.start();
}","private void watchForTables(){
  _tablesToCluster=new Thread(new Runnable(){
    @Override public void run(){
      try {
        doWatch();
      }
 catch (      KeeperException e) {
        LOG.error(""String_Node_Str"",e);
      }
catch (      InterruptedException e) {
        return;
      }
    }
    private void doWatch() throws KeeperException, InterruptedException {
      while (_running.get()) {
synchronized (_tableToClusterCache) {
          String clusterPath=ZookeeperPathConstants.getClustersPath();
          List<String> clusters=_zk.getChildren(clusterPath,new Watcher(){
            @Override public void process(            WatchedEvent event){
synchronized (_tableToClusterCache) {
                _tableToClusterCache.notifyAll();
              }
            }
          }
);
          Map<String,List<String>> newValue=new HashMap<String,List<String>>();
          for (          String cluster : clusters) {
            List<String> tables=_zk.getChildren(ZookeeperPathConstants.getTablesPath(cluster),new Watcher(){
              @Override public void process(              WatchedEvent event){
synchronized (_tableToClusterCache) {
                  _tableToClusterCache.notifyAll();
                }
              }
            }
);
            for (            String table : tables) {
              List<String> clusterList=newValue.get(table);
              if (clusterList == null) {
                clusterList=new ArrayList<String>();
                newValue.put(table,clusterList);
              }
              clusterList.add(cluster);
            }
          }
          _tableToClusterCache.set(newValue);
          _tableToClusterCache.wait();
        }
      }
    }
  }
);
  _tablesToCluster.setDaemon(true);
  _tablesToCluster.setName(""String_Node_Str"");
  _tablesToCluster.start();
}",0.7857923497267759
1463,"@Override public String getCluster(boolean useCache,String table){
  if (useCache) {
    Map<String,List<String>> map=_tableToClusterCache.get();
    List<String> clusters=map.get(table);
    if (clusters == null || clusters.size() == 0) {
      return null;
    }
 else     if (clusters.size() == 1) {
      return clusters.get(0);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + table + ""String_Node_Str""+ clusters+ ""String_Node_Str"");
    }
  }
  List<String> clusterList=getClusterList();
  for (  String cluster : clusterList) {
    try {
      Stat stat=_zk.exists(ZookeeperPathConstants.getTablePath(cluster,table),false);
      if (stat != null) {
        return cluster;
      }
    }
 catch (    KeeperException e) {
      throw new RuntimeException(e);
    }
catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
  }
  return null;
}","@Override public String getCluster(boolean useCache,String table){
  if (useCache) {
    Map<String,List<String>> map=_tableToClusterCache.get();
    List<String> clusters=map.get(table);
    if (clusters == null || clusters.size() == 0) {
      throw new RuntimeException(""String_Node_Str"" + table + ""String_Node_Str"");
    }
 else     if (clusters.size() == 1) {
      return clusters.get(0);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + table + ""String_Node_Str""+ clusters+ ""String_Node_Str"");
    }
  }
  List<String> clusterList=getClusterList();
  for (  String cluster : clusterList) {
    try {
      Stat stat=_zk.exists(ZookeeperPathConstants.getTablePath(cluster,table),false);
      if (stat != null) {
        return cluster;
      }
    }
 catch (    KeeperException e) {
      throw new RuntimeException(e);
    }
catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
  }
  throw new RuntimeException(""String_Node_Str"" + table + ""String_Node_Str"");
}",0.9116719242902208
1464,"@Override public void run(){
  clearMapOfOldTables(_tableAnalyzers);
  clearMapOfOldTables(_tableDescriptors);
  clearMapOfOldTables(_layoutManagers);
  clearMapOfOldTables(_layoutCache);
  clearMapOfOldTables(_tableSimilarity);
  Map<String,Map<String,BlurIndex>> oldIndexesThatNeedToBeClosed=clearMapOfOldTables(_indexes);
  for (  String table : oldIndexesThatNeedToBeClosed.keySet()) {
    Map<String,BlurIndex> indexes=oldIndexesThatNeedToBeClosed.get(table);
    if (indexes == null) {
      continue;
    }
    for (    String shard : indexes.keySet()) {
      BlurIndex index=indexes.get(shard);
      if (index == null) {
        continue;
      }
      close(index,table,shard);
    }
  }
  for (  String table : _indexes.keySet()) {
    Map<String,BlurIndex> shardMap=_indexes.get(table);
    if (shardMap != null) {
      Set<String> shards=new HashSet<String>(shardMap.keySet());
      Set<String> shardsToServe=getShardsToServe(table);
      shards.removeAll(shardsToServe);
      if (!shards.isEmpty()) {
        LOG.info(""String_Node_Str"",table,shards);
      }
      for (      String shard : shards) {
        LOG.info(""String_Node_Str"",table,shard);
        BlurIndex index=shardMap.remove(shard);
        close(index,table,shard);
      }
    }
  }
}","@Override public void run(){
  try {
    cleanup();
  }
 catch (  Throwable e) {
    LOG.error(""String_Node_Str"",e);
  }
}",0.1522988505747126
1465,"private void removeAnyTableLocks(){
  List<String> tableList=_clusterStatus.getTableList();
  for (  String table : tableList) {
    _clusterStatus.clearLocks(cluster,table);
  }
}","private void removeAnyTableLocks(){
  List<String> tableList=_clusterStatus.getTableList(cluster);
  for (  String table : tableList) {
    _clusterStatus.clearLocks(cluster,table);
  }
}",0.9809264305177112
1466,"private void setupTableWarmer(){
  _timerTableWarmer=new Timer(""String_Node_Str"",true);
  _timerTableWarmer.schedule(new TimerTask(){
    @Override public void run(){
      List<String> tableList=_clusterStatus.getTableList();
      _blurMetrics.tableCount.set(tableList.size());
      long indexCount=0;
      AtomicLong segmentCount=new AtomicLong();
      AtomicLong indexMemoryUsage=new AtomicLong();
      for (      String table : tableList) {
        try {
          Map<String,BlurIndex> indexes=getIndexes(table);
          int count=indexes.size();
          indexCount+=count;
          updateMetrics(_blurMetrics,indexes,segmentCount,indexMemoryUsage);
          LOG.debug(""String_Node_Str"",table,count);
        }
 catch (        IOException e) {
          LOG.error(""String_Node_Str"",e,table);
        }
      }
      _blurMetrics.indexCount.set(indexCount);
      _blurMetrics.segmentCount.set(segmentCount.get());
      _blurMetrics.indexMemoryUsage.set(indexMemoryUsage.get());
    }
    private void updateMetrics(    BlurMetrics blurMetrics,    Map<String,BlurIndex> indexes,    AtomicLong segmentCount,    AtomicLong indexMemoryUsage) throws IOException {
      for (      BlurIndex index : indexes.values()) {
        IndexReader reader=index.getIndexReader(false);
        try {
          IndexReader[] readers=reader.getSequentialSubReaders();
          if (readers != null) {
            segmentCount.addAndGet(readers.length);
          }
          indexMemoryUsage.addAndGet(BlurUtil.getMemoryUsage(reader));
        }
  finally {
          reader.decRef();
        }
      }
    }
  }
,_delay,_delay);
}","private void setupTableWarmer(){
  _timerTableWarmer=new Timer(""String_Node_Str"",true);
  _timerTableWarmer.schedule(new TimerTask(){
    @Override public void run(){
      try {
        warmup();
      }
 catch (      Throwable e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
    private void warmup(){
      List<String> tableList=_clusterStatus.getTableList(cluster);
      _blurMetrics.tableCount.set(tableList.size());
      long indexCount=0;
      AtomicLong segmentCount=new AtomicLong();
      AtomicLong indexMemoryUsage=new AtomicLong();
      for (      String table : tableList) {
        try {
          Map<String,BlurIndex> indexes=getIndexes(table);
          int count=indexes.size();
          indexCount+=count;
          updateMetrics(_blurMetrics,indexes,segmentCount,indexMemoryUsage);
          LOG.debug(""String_Node_Str"",table,count);
        }
 catch (        IOException e) {
          LOG.error(""String_Node_Str"",e,table);
        }
      }
      _blurMetrics.indexCount.set(indexCount);
      _blurMetrics.segmentCount.set(segmentCount.get());
      _blurMetrics.indexMemoryUsage.set(indexMemoryUsage.get());
    }
    private void updateMetrics(    BlurMetrics blurMetrics,    Map<String,BlurIndex> indexes,    AtomicLong segmentCount,    AtomicLong indexMemoryUsage) throws IOException {
      for (      BlurIndex index : indexes.values()) {
        IndexReader reader=index.getIndexReader(false);
        try {
          IndexReader[] readers=reader.getSequentialSubReaders();
          if (readers != null) {
            segmentCount.addAndGet(readers.length);
          }
          indexMemoryUsage.addAndGet(BlurUtil.getMemoryUsage(reader));
        }
  finally {
          reader.decRef();
        }
      }
    }
  }
,_delay,_delay);
}",0.9546120058565154
1467,"private void setupFlushCacheTimer(){
  _timerCacheFlush=new Timer(""String_Node_Str"",true);
  _timerCacheFlush.schedule(new TimerTask(){
    @Override public void run(){
      clearMapOfOldTables(_tableAnalyzers);
      clearMapOfOldTables(_tableDescriptors);
      clearMapOfOldTables(_layoutManagers);
      clearMapOfOldTables(_layoutCache);
      clearMapOfOldTables(_tableSimilarity);
      Map<String,Map<String,BlurIndex>> oldIndexesThatNeedToBeClosed=clearMapOfOldTables(_indexes);
      for (      String table : oldIndexesThatNeedToBeClosed.keySet()) {
        Map<String,BlurIndex> indexes=oldIndexesThatNeedToBeClosed.get(table);
        if (indexes == null) {
          continue;
        }
        for (        String shard : indexes.keySet()) {
          BlurIndex index=indexes.get(shard);
          if (index == null) {
            continue;
          }
          close(index,table,shard);
        }
      }
      for (      String table : _indexes.keySet()) {
        Map<String,BlurIndex> shardMap=_indexes.get(table);
        if (shardMap != null) {
          Set<String> shards=new HashSet<String>(shardMap.keySet());
          Set<String> shardsToServe=getShardsToServe(table);
          shards.removeAll(shardsToServe);
          if (!shards.isEmpty()) {
            LOG.info(""String_Node_Str"",table,shards);
          }
          for (          String shard : shards) {
            LOG.info(""String_Node_Str"",table,shard);
            BlurIndex index=shardMap.remove(shard);
            close(index,table,shard);
          }
        }
      }
    }
  }
,_delay,_delay);
}","private void setupFlushCacheTimer(){
  _timerCacheFlush=new Timer(""String_Node_Str"",true);
  _timerCacheFlush.schedule(new TimerTask(){
    @Override public void run(){
      try {
        cleanup();
      }
 catch (      Throwable e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
    private void cleanup(){
      clearMapOfOldTables(_tableAnalyzers);
      clearMapOfOldTables(_tableDescriptors);
      clearMapOfOldTables(_layoutManagers);
      clearMapOfOldTables(_layoutCache);
      clearMapOfOldTables(_tableSimilarity);
      Map<String,Map<String,BlurIndex>> oldIndexesThatNeedToBeClosed=clearMapOfOldTables(_indexes);
      for (      String table : oldIndexesThatNeedToBeClosed.keySet()) {
        Map<String,BlurIndex> indexes=oldIndexesThatNeedToBeClosed.get(table);
        if (indexes == null) {
          continue;
        }
        for (        String shard : indexes.keySet()) {
          BlurIndex index=indexes.get(shard);
          if (index == null) {
            continue;
          }
          close(index,table,shard);
        }
      }
      for (      String table : _indexes.keySet()) {
        Map<String,BlurIndex> shardMap=_indexes.get(table);
        if (shardMap != null) {
          Set<String> shards=new HashSet<String>(shardMap.keySet());
          Set<String> shardsToServe=getShardsToServe(table);
          shards.removeAll(shardsToServe);
          if (!shards.isEmpty()) {
            LOG.info(""String_Node_Str"",table,shards);
          }
          for (          String shard : shards) {
            LOG.info(""String_Node_Str"",table,shard);
            BlurIndex index=shardMap.remove(shard);
            close(index,table,shard);
          }
        }
      }
    }
  }
,_delay,_delay);
}",0.2841726618705036
1468,"public void init(){
  _timer=new Timer(""String_Node_Str"",true);
  _timer.schedule(new TimerTask(){
    @Override public void run(){
      sampleAll();
    }
  }
,_delay,_period);
}","public void init(){
  _timer=new Timer(""String_Node_Str"",true);
  _timer.schedule(new TimerTask(){
    @Override public void run(){
      try {
        sampleAll();
      }
 catch (      Throwable e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
,_delay,_period);
}",0.7843137254901961
1469,"@Override public void run(){
  sampleAll();
}","@Override public void run(){
  try {
    sampleAll();
  }
 catch (  Throwable e) {
    LOG.error(""String_Node_Str"",e);
  }
}",0.5325443786982249
1470,"public void init(){
  statusCleanupTimer=new Timer(""String_Node_Str"",true);
  statusCleanupTimer.schedule(new TimerTask(){
    @Override public void run(){
      try {
        cleanupFinishedQueryStatuses();
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
,statusCleanupTimerDelay,statusCleanupTimerDelay);
}","public void init(){
  statusCleanupTimer=new Timer(""String_Node_Str"",true);
  statusCleanupTimer.schedule(new TimerTask(){
    @Override public void run(){
      try {
        cleanupFinishedQueryStatuses();
      }
 catch (      Throwable e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
,statusCleanupTimerDelay,statusCleanupTimerDelay);
}",0.9746478873239436
1471,"@Override public void run(){
  try {
    cleanupFinishedQueryStatuses();
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
}","@Override public void run(){
  try {
    cleanupFinishedQueryStatuses();
  }
 catch (  Throwable e) {
    LOG.error(""String_Node_Str"",e);
  }
}",0.944055944055944
1472,"@Override public void run(){
  for (  BlurIndex index : _indexes) {
    try {
      index.refresh();
    }
 catch (    IOException e) {
      LOG.error(""String_Node_Str"",e,index);
    }
  }
}","@Override public void run(){
  try {
    refreshInternal();
  }
 catch (  Throwable e) {
    LOG.error(""String_Node_Str"",e);
  }
}",0.7102803738317757
1473,"private synchronized void updateLayout(){
  List<String> tableList=_clusterStatus.getTableList();
  HashMap<String,Map<String,String>> newLayout=new HashMap<String,Map<String,String>>();
  for (  String table : tableList) {
    DistributedLayoutManager layoutManager=new DistributedLayoutManager();
    String cluster=_clusterStatus.getCluster(true,table);
    List<String> shardServerList=_clusterStatus.getShardServerList(cluster);
    List<String> offlineShardServers=_clusterStatus.getOfflineShardServers(cluster);
    List<String> shardList=getShardList(cluster,table);
    layoutManager.setNodes(shardServerList);
    layoutManager.setNodesOffline(offlineShardServers);
    layoutManager.setShards(shardList);
    layoutManager.init();
    Map<String,String> layout=layoutManager.getLayout();
    newLayout.put(table,layout);
  }
  _shardServerLayout.set(newLayout);
}","private synchronized void updateLayout(){
  List<String> tableList=_clusterStatus.getTableList();
  HashMap<String,Map<String,String>> newLayout=new HashMap<String,Map<String,String>>();
  for (  String table : tableList) {
    DistributedLayoutManager layoutManager=new DistributedLayoutManager();
    String cluster=_clusterStatus.getCluster(false,table);
    List<String> shardServerList=_clusterStatus.getShardServerList(cluster);
    List<String> offlineShardServers=_clusterStatus.getOfflineShardServers(cluster);
    List<String> shardList=getShardList(cluster,table);
    layoutManager.setNodes(shardServerList);
    layoutManager.setNodesOffline(offlineShardServers);
    layoutManager.setShards(shardList);
    layoutManager.init();
    Map<String,String> layout=layoutManager.getLayout();
    newLayout.put(table,layout);
  }
  _shardServerLayout.set(newLayout);
}",0.9959977129788452
1474,"private boolean inSafeMode(boolean useCache,String table){
  String cluster=_clusterStatus.getCluster(true,table);
  return _clusterStatus.isInSafeMode(cluster);
}","private boolean inSafeMode(boolean useCache,String table){
  String cluster=_clusterStatus.getCluster(useCache,table);
  return _clusterStatus.isInSafeMode(cluster);
}",0.9757575757575756
1475,"@Override public final void removeTable(String table,boolean deleteIndexFiles) throws BlurException, TException {
  try {
    String cluster=_clusterStatus.getCluster(true,table);
    RemoveTable.removeTable(_zookeeper,cluster,table,deleteIndexFiles);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e,table);
    throw new BException(e.getMessage(),e);
  }
}","@Override public final void removeTable(String table,boolean deleteIndexFiles) throws BlurException, TException {
  try {
    String cluster=_clusterStatus.getCluster(false,table);
    RemoveTable.removeTable(_zookeeper,cluster,table,deleteIndexFiles);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e,table);
    throw new BException(e.getMessage(),e);
  }
}",0.9906040268456376
1476,"@Override public final void enableTable(String table) throws BlurException, TException {
  try {
    String cluster=_clusterStatus.getCluster(true,table);
    EnableTable.enableTable(_zookeeper,cluster,table);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e,table);
    throw new BException(e.getMessage(),e);
  }
}","@Override public final void enableTable(String table) throws BlurException, TException {
  try {
    String cluster=_clusterStatus.getCluster(false,table);
    EnableTable.enableTable(_zookeeper,cluster,table);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e,table);
    throw new BException(e.getMessage(),e);
  }
}",0.989409984871407
1477,"@Override public final TableDescriptor describe(final String table) throws BlurException, TException {
  try {
    String cluster=_clusterStatus.getCluster(true,table);
    return _clusterStatus.getTableDescriptor(true,cluster,table);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"" + table + ""String_Node_Str"",e);
    throw new BException(""String_Node_Str"" + table + ""String_Node_Str"",e);
  }
}","@Override public final TableDescriptor describe(final String table) throws BlurException, TException {
  try {
    String cluster=_clusterStatus.getCluster(false,table);
    return _clusterStatus.getTableDescriptor(true,cluster,table);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"" + table + ""String_Node_Str"",e);
    throw new BException(""String_Node_Str"" + table + ""String_Node_Str"",e);
  }
}",0.9914320685434516
1478,"@Override public final void disableTable(String table) throws BlurException, TException {
  try {
    String cluster=_clusterStatus.getCluster(true,table);
    DisableTable.disableTable(_zookeeper,cluster,table);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e,table);
    throw new BException(e.getMessage(),e);
  }
}","@Override public final void disableTable(String table) throws BlurException, TException {
  try {
    String cluster=_clusterStatus.getCluster(false,table);
    DisableTable.disableTable(_zookeeper,cluster,table);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e,table);
    throw new BException(e.getMessage(),e);
  }
}",0.9895052473763118
1479,"public void init(){
  _timer=new Timer(""String_Node_Str"",true);
  _timer.schedule(new TimerTask(){
    @Override public void run(){
      tryToInterrupt();
    }
  }
,_delay,_delay);
}","public void init(){
  _timer=new Timer(""String_Node_Str"",true);
  _timer.schedule(new TimerTask(){
    @Override public void run(){
      try {
        tryToInterrupt();
      }
 catch (      Throwable e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
,_delay,_delay);
}",0.6852248394004282
1480,"@Override public void run(){
  tryToInterrupt();
}","@Override public void run(){
  try {
    tryToInterrupt();
  }
 catch (  Throwable e) {
    LOG.error(""String_Node_Str"",e);
  }
}",0.5586592178770949
1481,"public void init(){
  _timer=new Timer(""String_Node_Str"",true);
  _timer.schedule(new TimerTask(){
    @Override public void run(){
      processRunningThreads();
    }
  }
,TimeUnit.SECONDS.toMillis(5),TimeUnit.SECONDS.toMillis(5));
}","public void init(){
  _timer=new Timer(""String_Node_Str"",true);
  _timer.schedule(new TimerTask(){
    @Override public void run(){
      try {
        processRunningThreads();
      }
 catch (      Throwable e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
,TimeUnit.SECONDS.toMillis(5),TimeUnit.SECONDS.toMillis(5));
}",0.8260105448154658
1482,"public static Row getRow(Iterable<Document> docs){
  Row row=new Row();
  boolean empty=true;
  if (docs == null) {
    return null;
  }
  for (  Document document : docs) {
    empty=false;
    Record record=new Record();
    String rowId=populateRecord(record,document);
    if (record.getColumns() != null) {
      row.addToRecords(record);
    }
    if (row.id == null) {
      row.setId(rowId);
    }
    row.recordCount++;
  }
  if (empty) {
    return null;
  }
  return row;
}","public static Row getRow(Iterable<Document> docs){
  Row row=new Row();
  boolean empty=true;
  if (docs == null) {
    return null;
  }
  for (  Document document : docs) {
    empty=false;
    Record record=new Record();
    String rowId=populateRecord(record,document);
    if (record.getColumns() != null) {
      row.addToRecords(record);
    }
    if (row.id == null) {
      row.setId(rowId);
    }
    row.recordCount++;
  }
  if (empty) {
    return null;
  }
  if (row.records == null) {
    row.records=new ArrayList<Record>();
  }
  return row;
}",0.9040307101727448
1483,"private boolean findEmptyLocation(BlockCacheLocation location){
  OUTER:   for (int bankId=0; bankId < _banks.length; bankId++) {
    AtomicInteger bitSetCounter=_lockCounters[bankId];
    BlockLocks bitSet=_locks[bankId];
    if (bitSetCounter.get() == _numberOfBlocksPerBank) {
      continue OUTER;
    }
    int bit=bitSet.nextClearBit(0);
    INNER:     while (bit != -1) {
      if (bit >= _numberOfBlocksPerBank) {
        continue OUTER;
      }
      if (!bitSet.set(bit)) {
        bit=bitSet.nextClearBit(0);
        continue INNER;
      }
 else {
        location.setBankId(bankId);
        location.setBlock(bit);
        bitSetCounter.incrementAndGet();
        return true;
      }
    }
  }
  return false;
}","private boolean findEmptyLocation(BlockCacheLocation location){
  for (int j=0; j < 10; j++) {
    OUTER:     for (int bankId=0; bankId < _banks.length; bankId++) {
      AtomicInteger bitSetCounter=_lockCounters[bankId];
      BlockLocks bitSet=_locks[bankId];
      if (bitSetCounter.get() == _numberOfBlocksPerBank) {
        continue OUTER;
      }
      int bit=bitSet.nextClearBit(0);
      INNER:       while (bit != -1) {
        if (bit >= _numberOfBlocksPerBank) {
          continue OUTER;
        }
        if (!bitSet.set(bit)) {
          bit=bitSet.nextClearBit(0);
          continue INNER;
        }
 else {
          location.setBankId(bankId);
          location.setBlock(bit);
          bitSetCounter.incrementAndGet();
          return true;
        }
      }
    }
  }
  return false;
}",0.928897586431833
1484,"private void setupFlushCacheTimer(){
  _timerCacheFlush=new Timer(""String_Node_Str"",true);
  _timerCacheFlush.schedule(new TimerTask(){
    @Override public void run(){
      clearMapOfOldTables(_tableAnalyzers);
      clearMapOfOldTables(_tableDescriptors);
      clearMapOfOldTables(_layoutManagers);
      clearMapOfOldTables(_layoutCache);
      Map<String,Map<String,BlurIndex>> oldIndexesThatNeedToBeClosed=clearMapOfOldTables(_indexes);
      for (      String table : oldIndexesThatNeedToBeClosed.keySet()) {
        Map<String,BlurIndex> indexes=oldIndexesThatNeedToBeClosed.get(table);
        if (indexes == null) {
          continue;
        }
        for (        String shard : indexes.keySet()) {
          BlurIndex index=indexes.get(shard);
          if (index == null) {
            continue;
          }
          LOG.info(""String_Node_Str"",index,table,shard);
          try {
            _filterCache.closing(table,shard,index);
            index.close();
          }
 catch (          IOException e) {
            LOG.error(""String_Node_Str"",e,index,table,shard);
          }
        }
      }
    }
  }
,_delay,_delay);
}","private void setupFlushCacheTimer(){
  _timerCacheFlush=new Timer(""String_Node_Str"",true);
  _timerCacheFlush.schedule(new TimerTask(){
    @Override public void run(){
      clearMapOfOldTables(_tableAnalyzers);
      clearMapOfOldTables(_tableDescriptors);
      clearMapOfOldTables(_layoutManagers);
      clearMapOfOldTables(_layoutCache);
      Map<String,Map<String,BlurIndex>> oldIndexesThatNeedToBeClosed=clearMapOfOldTables(_indexes);
      for (      String table : oldIndexesThatNeedToBeClosed.keySet()) {
        Map<String,BlurIndex> indexes=oldIndexesThatNeedToBeClosed.get(table);
        if (indexes == null) {
          continue;
        }
        for (        String shard : indexes.keySet()) {
          BlurIndex index=indexes.get(shard);
          if (index == null) {
            continue;
          }
          close(index,table,shard);
        }
      }
      for (      String table : _indexes.keySet()) {
        Map<String,BlurIndex> shardMap=_indexes.get(table);
        if (shardMap != null) {
          Set<String> shards=new HashSet<String>(shardMap.keySet());
          Set<String> shardsToServe=getShardsToServe(table);
          shards.removeAll(shardsToServe);
          if (!shards.isEmpty()) {
            LOG.info(""String_Node_Str"",table,shards);
          }
          for (          String shard : shards) {
            LOG.info(""String_Node_Str"",table,shard);
            BlurIndex index=shardMap.remove(shard);
            close(index,table,shard);
          }
        }
      }
    }
  }
,_delay,_delay);
}",0.7295690936106983
1485,"@Override public void run(){
  clearMapOfOldTables(_tableAnalyzers);
  clearMapOfOldTables(_tableDescriptors);
  clearMapOfOldTables(_layoutManagers);
  clearMapOfOldTables(_layoutCache);
  Map<String,Map<String,BlurIndex>> oldIndexesThatNeedToBeClosed=clearMapOfOldTables(_indexes);
  for (  String table : oldIndexesThatNeedToBeClosed.keySet()) {
    Map<String,BlurIndex> indexes=oldIndexesThatNeedToBeClosed.get(table);
    if (indexes == null) {
      continue;
    }
    for (    String shard : indexes.keySet()) {
      BlurIndex index=indexes.get(shard);
      if (index == null) {
        continue;
      }
      LOG.info(""String_Node_Str"",index,table,shard);
      try {
        _filterCache.closing(table,shard,index);
        index.close();
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e,index,table,shard);
      }
    }
  }
}","@Override public void run(){
  clearMapOfOldTables(_tableAnalyzers);
  clearMapOfOldTables(_tableDescriptors);
  clearMapOfOldTables(_layoutManagers);
  clearMapOfOldTables(_layoutCache);
  Map<String,Map<String,BlurIndex>> oldIndexesThatNeedToBeClosed=clearMapOfOldTables(_indexes);
  for (  String table : oldIndexesThatNeedToBeClosed.keySet()) {
    Map<String,BlurIndex> indexes=oldIndexesThatNeedToBeClosed.get(table);
    if (indexes == null) {
      continue;
    }
    for (    String shard : indexes.keySet()) {
      BlurIndex index=indexes.get(shard);
      if (index == null) {
        continue;
      }
      close(index,table,shard);
    }
  }
  for (  String table : _indexes.keySet()) {
    Map<String,BlurIndex> shardMap=_indexes.get(table);
    if (shardMap != null) {
      Set<String> shards=new HashSet<String>(shardMap.keySet());
      Set<String> shardsToServe=getShardsToServe(table);
      shards.removeAll(shardsToServe);
      if (!shards.isEmpty()) {
        LOG.info(""String_Node_Str"",table,shards);
      }
      for (      String shard : shards) {
        LOG.info(""String_Node_Str"",table,shard);
        BlurIndex index=shardMap.remove(shard);
        close(index,table,shard);
      }
    }
  }
}",0.7035271687321258
1486,"private void setupSafeMode() throws KeeperException, InterruptedException {
  String shardsPath=ZookeeperPathConstants.getBlurOnlineShardsPath();
  List<String> children=_zookeeper.getChildren(shardsPath,false);
  if (children.size() == 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (children.size() != 1) {
    return;
  }
  LOG.info(""String_Node_Str"");
  long timestamp=System.currentTimeMillis() + SAFE_MODE_DELAY;
  String blurSafemodePath=ZookeeperPathConstants.getBlurSafemodePath();
  Stat stat=_zookeeper.exists(blurSafemodePath,false);
  if (stat == null) {
    _zookeeper.create(blurSafemodePath,Long.toString(timestamp).getBytes(),Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  }
 else {
    _zookeeper.setData(blurSafemodePath,Long.toString(timestamp).getBytes(),-1);
  }
}","private void setupSafeMode() throws KeeperException, InterruptedException {
  String shardsPath=ZookeeperPathConstants.getBlurOnlineShardsPath();
  List<String> children=_zookeeper.getChildren(shardsPath,false);
  if (children.size() == 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (children.size() != 1) {
    return;
  }
  LOG.info(""String_Node_Str"");
  long timestamp=System.currentTimeMillis() + SAFE_MODE_DELAY;
  String blurSafemodePath=ZookeeperPathConstants.getBlurSafemodePath();
  Stat stat=_zookeeper.exists(blurSafemodePath,false);
  if (stat == null) {
    _zookeeper.create(blurSafemodePath,Long.toString(timestamp).getBytes(),Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  }
 else {
    _zookeeper.setData(blurSafemodePath,Long.toString(timestamp).getBytes(),-1);
  }
  removeAnyTableLocks();
}",0.9846719803801348
1487,"private void setupTableWarmer(){
  _timerTableWarmer=new Timer(""String_Node_Str"",true);
  _timerTableWarmer.schedule(new TimerTask(){
    @Override public void run(){
      List<String> tableList=_clusterStatus.getTableList();
      for (      String table : tableList) {
        try {
          int count=getIndexes(table).size();
          LOG.info(""String_Node_Str"",table,count);
        }
 catch (        IOException e) {
          LOG.error(""String_Node_Str"",e,table);
        }
      }
    }
  }
,_delay,_delay);
}","private void setupTableWarmer(){
  _timerTableWarmer=new Timer(""String_Node_Str"",true);
  _timerTableWarmer.schedule(new TimerTask(){
    @Override public void run(){
      List<String> tableList=_clusterStatus.getTableList();
      for (      String table : tableList) {
        try {
          int count=getIndexes(table).size();
          LOG.debug(""String_Node_Str"",table,count);
        }
 catch (        IOException e) {
          LOG.error(""String_Node_Str"",e,table);
        }
      }
    }
  }
,_delay,_delay);
}",0.9913544668587896
1488,"private ClusterStatus getClusterStatus(){
  return new ClusterStatus(){
    @Override public List<String> getClusterList(){
      return Arrays.asList(""String_Node_Str"");
    }
    @Override public List<String> getControllerServerList(){
      throw new RuntimeException(""String_Node_Str"");
    }
    @Override public List<String> getOnlineShardServers(    String cluster){
      return getShardServerList(cluster);
    }
    @Override public List<String> getShardServerList(    String cluster){
      List<String> nodes=new ArrayList<String>(shardServers.keySet());
      Collections.sort(nodes);
      return nodes;
    }
    @Override public TableDescriptor getTableDescriptor(    String table){
      TableDescriptor tableDescriptor=new TableDescriptor();
      tableDescriptor.cluster=""String_Node_Str"";
      tableDescriptor.shardCount=3;
      return tableDescriptor;
    }
    @Override public List<String> getTableList(){
      return Arrays.asList(TABLE);
    }
    @Override public String getCluster(    String table){
      return ""String_Node_Str"";
    }
    @Override public boolean exists(    String table){
      return false;
    }
    @Override public boolean isEnabled(    String table){
      return false;
    }
  }
;
}","private ClusterStatus getClusterStatus(){
  return new ClusterStatus(){
    @Override public List<String> getClusterList(){
      return Arrays.asList(""String_Node_Str"");
    }
    @Override public List<String> getControllerServerList(){
      throw new RuntimeException(""String_Node_Str"");
    }
    @Override public List<String> getOnlineShardServers(    String cluster){
      return getShardServerList(cluster);
    }
    @Override public List<String> getShardServerList(    String cluster){
      List<String> nodes=new ArrayList<String>(shardServers.keySet());
      Collections.sort(nodes);
      return nodes;
    }
    @Override public TableDescriptor getTableDescriptor(    String table){
      TableDescriptor tableDescriptor=new TableDescriptor();
      tableDescriptor.cluster=""String_Node_Str"";
      tableDescriptor.shardCount=3;
      return tableDescriptor;
    }
    @Override public List<String> getTableList(){
      return Arrays.asList(TABLE);
    }
    @Override public String getCluster(    String table){
      return ""String_Node_Str"";
    }
    @Override public boolean exists(    String table){
      return false;
    }
    @Override public boolean isEnabled(    String table){
      return false;
    }
    @Override public void clearLocks(    String table){
    }
  }
;
}",0.9740361919748228
1489,"@Override public boolean obtain() throws IOException {
  try {
    LOG.info(""String_Node_Str"",_instanceIndexLockPath);
    Stat stat=_zk.exists(_instanceIndexLockPath,false);
    if (stat != null) {
      byte[] data=_zk.getData(_instanceIndexLockPath,false,stat);
      if (_nodeName.equals(new String(data))) {
        LOG.warn(""String_Node_Str"",_instanceIndexLockPath);
        _zk.delete(_instanceIndexLockPath,-1);
      }
 else {
        LOG.info(""String_Node_Str"",_instanceIndexLockPath,new String(data));
        return false;
      }
    }
    _zk.create(_instanceIndexLockPath,_nodeName.getBytes(),Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL);
    _stat=stat;
    return true;
  }
 catch (  KeeperException e) {
    if (e.code() == Code.NODEEXISTS) {
      return false;
    }
    throw new IOException(e);
  }
catch (  InterruptedException e) {
    throw new IOException(e);
  }
}","@Override public boolean obtain() throws IOException {
  try {
    LOG.info(""String_Node_Str"",_instanceIndexLockPath);
    Stat stat=_zk.exists(_instanceIndexLockPath,false);
    if (stat != null) {
      byte[] data=_zk.getData(_instanceIndexLockPath,false,stat);
      if (_nodeName.equals(new String(data))) {
        LOG.warn(""String_Node_Str"",_instanceIndexLockPath);
        _zk.delete(_instanceIndexLockPath,-1);
      }
 else {
        LOG.info(""String_Node_Str"",_instanceIndexLockPath,new String(data));
        return false;
      }
    }
    _zk.create(_instanceIndexLockPath,_nodeName.getBytes(),Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL);
    return true;
  }
 catch (  KeeperException e) {
    if (e.code() == Code.NODEEXISTS) {
      return false;
    }
    throw new IOException(e);
  }
catch (  InterruptedException e) {
    throw new IOException(e);
  }
}",0.990909090909091
1490,"@Override public void release() throws IOException {
  try {
    _zk.delete(_instanceIndexLockPath,_stat.getVersion());
  }
 catch (  InterruptedException e) {
    throw new IOException(e);
  }
catch (  KeeperException e) {
    throw new IOException(e);
  }
}","@Override public void release() throws IOException {
  try {
    _zk.delete(_instanceIndexLockPath,-1);
  }
 catch (  InterruptedException e) {
    throw new IOException(e);
  }
catch (  KeeperException e) {
    throw new IOException(e);
  }
}",0.9601593625498008
1491,"@Override protected BlurIndex openShard(String table,String shard) throws IOException {
  LOG.info(""String_Node_Str"",shard,table);
  URI tableUri=getTableURI(table);
  Path tablePath=new Path(tableUri.toString());
  Path hdfsDirPath=new Path(tablePath,shard);
  String shardPath=ZookeeperPathConstants.getBlurLockPath(table) + ""String_Node_Str"" + shard;
  ZookeeperLockFactory lockFactory=new ZookeeperLockFactory(_zookeeper,shardPath);
  HdfsDirectory directory=new HdfsDirectory(hdfsDirPath);
  directory.setLockFactory(lockFactory);
  BlockDirectory baseDirectory=new BlockDirectory(table + ""String_Node_Str"" + shard,directory,_cache);
  BlurIndexWriter writer=new BlurIndexWriter();
  writer.setCloser(_closer);
  writer.setCommiter(_commiter);
  writer.setAnalyzer(getAnalyzer(table));
  writer.setDirectory(baseDirectory);
  writer.setRefresher(_refresher);
  writer.init();
  return warmUp(writer);
}","@Override protected BlurIndex openShard(String table,String shard) throws IOException {
  LOG.info(""String_Node_Str"",shard,table);
  URI tableUri=getTableURI(table);
  Path tablePath=new Path(tableUri.toString());
  Path hdfsDirPath=new Path(tablePath,shard);
  String shardPath=ZookeeperPathConstants.getBlurLockPath(table) + ""String_Node_Str"" + shard;
  ZookeeperLockFactory lockFactory=new ZookeeperLockFactory(_zookeeper,shardPath);
  DirectIODirectory directory=new HdfsDirectory(hdfsDirPath);
  directory.setLockFactory(lockFactory);
  TableDescriptor descriptor=_clusterStatus.getTableDescriptor(table);
  String compressionClass=descriptor.compressionClass;
  int compressionBlockSize=descriptor.compressionBlockSize;
  if (compressionClass != null) {
    CompressionCodec compressionCodec;
    try {
      compressionCodec=CreateTable.getInstance(compressionClass);
      directory=new CompressedFieldDataDirectory(directory,compressionCodec,compressionBlockSize);
    }
 catch (    Exception e) {
      throw new IOException(e);
    }
  }
  BlockDirectory baseDirectory=new BlockDirectory(table + ""String_Node_Str"" + shard,directory,_cache);
  BlurIndexWriter writer=new BlurIndexWriter();
  writer.setCloser(_closer);
  writer.setCommiter(_commiter);
  writer.setAnalyzer(getAnalyzer(table));
  writer.setDirectory(baseDirectory);
  writer.setRefresher(_refresher);
  writer.init();
  return warmUp(writer);
}",0.7761065749892565
1492,"private void fetchBlock(int blockId) throws IOException {
  long position=_blockPositions[blockId];
  int length=_blockLengths[blockId];
  _indexInput.seek(position);
  _indexInput.readBytes(_decompressionBuffer,0,length);
  _decompressor.reset();
  _decompressor.setInput(_decompressionBuffer,0,length);
  _blockBufferLength=_decompressor.decompress(_blockBuffer,0,_blockBuffer.length);
  _currentBlockId=blockId;
}","private void fetchBlock(int blockId) throws IOException {
  long position=_blockPositions[blockId];
  int length=_blockLengths[blockId];
  _indexInput.seek(position);
  _indexInput.readBytes(_decompressionBuffer,0,length);
synchronized (_decompressor) {
    _decompressor.reset();
    _decompressor.setInput(_decompressionBuffer,0,length);
    _blockBufferLength=_decompressor.decompress(_blockBuffer,0,_blockBuffer.length);
  }
  _currentBlockId=blockId;
}",0.8957617411225659
1493,"public void close() throws IOException {
  _decompressor.end();
  if (!_isClone) {
    _indexInput.close();
  }
}","public void close() throws IOException {
  if (!_isClone) {
    _decompressor.end();
    _indexInput.close();
  }
}",0.8245614035087719
1494,"public CompressedIndexInput(String name,Directory directory,CompressionCodec codec) throws IOException {
  _codec=codec;
  _decompressor=_codec.createDecompressor();
  _indexInput=directory.openInput(name);
  _realLength=_indexInput.length();
  _indexInput.seek(_realLength - _SIZES_META_DATA);
  long metaDataLength=_indexInput.readLong();
  int blockCount=_indexInput.readInt();
  _blockSize=_indexInput.readInt();
  _origLength=_indexInput.readLong();
  _blockLengths=new int[blockCount];
  _blockPositions=new long[blockCount];
  _indexInput.seek(_realLength - _SIZES_META_DATA - metaDataLength);
  for (int i=0; i < blockCount; i++) {
    _blockPositions[i]=_indexInput.readVLong();
    _blockLengths[i]=_indexInput.readVInt();
  }
  _blockBuffer=new byte[_blockSize];
  int dsize=_blockSize * 2;
  if (dsize < _MIN_BUFFER_SIZE) {
    dsize=_MIN_BUFFER_SIZE;
  }
  _decompressionBuffer=new byte[dsize];
}","public CompressedIndexInput(String name,Directory directory,CompressionCodec codec) throws IOException {
  _decompressor=codec.createDecompressor();
  _indexInput=directory.openInput(name);
  _realLength=_indexInput.length();
  _indexInput.seek(_realLength - _SIZES_META_DATA);
  long metaDataLength=_indexInput.readLong();
  int blockCount=_indexInput.readInt();
  _blockSize=_indexInput.readInt();
  _origLength=_indexInput.readLong();
  _blockLengths=new int[blockCount];
  _blockPositions=new long[blockCount];
  _indexInput.seek(_realLength - _SIZES_META_DATA - metaDataLength);
  for (int i=0; i < blockCount; i++) {
    _blockPositions[i]=_indexInput.readVLong();
    _blockLengths[i]=_indexInput.readVInt();
  }
  setupBuffers(this);
}",0.8825665859564165
1495,"public CompressedFieldDataDirectory(Directory dir,CompressionCodec compression,int blockSize){
  _directory=dir;
  if (compression == null) {
    _compression=DEFAULT_COMPRESSION;
  }
 else {
    _compression=compression;
  }
  _writingBlockSize=blockSize;
}","public CompressedFieldDataDirectory(DirectIODirectory dir,CompressionCodec compression,int blockSize){
  _directory=dir;
  if (compression == null) {
    _compression=DEFAULT_COMPRESSION;
  }
 else {
    _compression=compression;
  }
  _writingBlockSize=blockSize;
}",0.9847328244274808
1496,"public Object clone(){
  CompressedIndexInput clone=(CompressedIndexInput)super.clone();
  clone._isClone=true;
  clone._decompressor=_codec.createDecompressor();
  clone._indexInput=(IndexInput)_indexInput.clone();
  return clone;
}","public Object clone(){
  CompressedIndexInput clone=(CompressedIndexInput)super.clone();
  clone._isClone=true;
  clone._indexInput=(IndexInput)_indexInput.clone();
  setupBuffers(clone);
  return clone;
}",0.6529680365296804
1497,"@Test public void testCompressedFieldDataDirectoryBasic() throws CorruptIndexException, IOException {
  RAMDirectory dir=new RAMDirectory();
  CompressedFieldDataDirectory directory=new CompressedFieldDataDirectory(dir,COMPRESSION_CODEC);
  IndexWriterConfig config=new IndexWriterConfig(Version.LUCENE_33,new KeywordAnalyzer());
  TieredMergePolicy mergePolicy=(TieredMergePolicy)config.getMergePolicy();
  mergePolicy.setUseCompoundFile(false);
  IndexWriter writer=new IndexWriter(directory,config);
  addDocs(writer,0,10);
  writer.close();
  testFetches(directory);
}","@Test public void testCompressedFieldDataDirectoryBasic() throws CorruptIndexException, IOException {
  RAMDirectory dir=new RAMDirectory();
  CompressedFieldDataDirectory directory=new CompressedFieldDataDirectory(DirectIODirectory.wrap(dir),COMPRESSION_CODEC);
  IndexWriterConfig config=new IndexWriterConfig(Version.LUCENE_33,new KeywordAnalyzer());
  TieredMergePolicy mergePolicy=(TieredMergePolicy)config.getMergePolicy();
  mergePolicy.setUseCompoundFile(false);
  IndexWriter writer=new IndexWriter(directory,config);
  addDocs(writer,0,10);
  writer.close();
  testFetches(directory);
}",0.9743150684931506
1498,"@Test public void testCompressedFieldDataDirectoryTransition() throws CorruptIndexException, LockObtainFailedException, IOException {
  RAMDirectory dir=new RAMDirectory();
  IndexWriterConfig config=new IndexWriterConfig(Version.LUCENE_33,new KeywordAnalyzer());
  TieredMergePolicy mergePolicy=(TieredMergePolicy)config.getMergePolicy();
  mergePolicy.setUseCompoundFile(false);
  IndexWriter writer=new IndexWriter(dir,config);
  addDocs(writer,0,5);
  writer.close();
  CompressedFieldDataDirectory directory=new CompressedFieldDataDirectory(dir,COMPRESSION_CODEC);
  config=new IndexWriterConfig(Version.LUCENE_33,new KeywordAnalyzer());
  mergePolicy=(TieredMergePolicy)config.getMergePolicy();
  mergePolicy.setUseCompoundFile(false);
  writer=new IndexWriter(directory,config);
  addDocs(writer,5,5);
  writer.close();
  testFetches(directory);
}","@Test public void testCompressedFieldDataDirectoryTransition() throws CorruptIndexException, LockObtainFailedException, IOException {
  RAMDirectory dir=new RAMDirectory();
  IndexWriterConfig config=new IndexWriterConfig(Version.LUCENE_33,new KeywordAnalyzer());
  TieredMergePolicy mergePolicy=(TieredMergePolicy)config.getMergePolicy();
  mergePolicy.setUseCompoundFile(false);
  IndexWriter writer=new IndexWriter(dir,config);
  addDocs(writer,0,5);
  writer.close();
  CompressedFieldDataDirectory directory=new CompressedFieldDataDirectory(DirectIODirectory.wrap(dir),COMPRESSION_CODEC);
  config=new IndexWriterConfig(Version.LUCENE_33,new KeywordAnalyzer());
  mergePolicy=(TieredMergePolicy)config.getMergePolicy();
  mergePolicy.setUseCompoundFile(false);
  writer=new IndexWriter(directory,config);
  addDocs(writer,5,5);
  writer.close();
  testFetches(directory);
}",0.9826789838337182
1499,"@Test public void testCompressedFieldDataDirectoryMixedBlockSize() throws CorruptIndexException, LockObtainFailedException, IOException {
  RAMDirectory dir=new RAMDirectory();
  IndexWriterConfig config=new IndexWriterConfig(Version.LUCENE_33,new KeywordAnalyzer());
  TieredMergePolicy mergePolicy=(TieredMergePolicy)config.getMergePolicy();
  mergePolicy.setUseCompoundFile(false);
  IndexWriter writer=new IndexWriter(dir,config);
  addDocs(writer,0,5);
  writer.close();
  CompressedFieldDataDirectory directory1=new CompressedFieldDataDirectory(dir,COMPRESSION_CODEC,2);
  config=new IndexWriterConfig(Version.LUCENE_33,new KeywordAnalyzer());
  mergePolicy=(TieredMergePolicy)config.getMergePolicy();
  mergePolicy.setUseCompoundFile(false);
  writer=new IndexWriter(directory1,config);
  addDocs(writer,5,2);
  writer.close();
  CompressedFieldDataDirectory directory2=new CompressedFieldDataDirectory(dir,COMPRESSION_CODEC,4);
  config=new IndexWriterConfig(Version.LUCENE_33,new KeywordAnalyzer());
  mergePolicy=(TieredMergePolicy)config.getMergePolicy();
  mergePolicy.setUseCompoundFile(false);
  writer=new IndexWriter(directory2,config);
  addDocs(writer,7,3);
  writer.close();
  testFetches(directory2);
}","@Test public void testCompressedFieldDataDirectoryMixedBlockSize() throws CorruptIndexException, LockObtainFailedException, IOException {
  RAMDirectory dir=new RAMDirectory();
  IndexWriterConfig config=new IndexWriterConfig(Version.LUCENE_33,new KeywordAnalyzer());
  TieredMergePolicy mergePolicy=(TieredMergePolicy)config.getMergePolicy();
  mergePolicy.setUseCompoundFile(false);
  IndexWriter writer=new IndexWriter(dir,config);
  addDocs(writer,0,5);
  writer.close();
  CompressedFieldDataDirectory directory1=new CompressedFieldDataDirectory(DirectIODirectory.wrap(dir),COMPRESSION_CODEC,2);
  config=new IndexWriterConfig(Version.LUCENE_33,new KeywordAnalyzer());
  mergePolicy=(TieredMergePolicy)config.getMergePolicy();
  mergePolicy.setUseCompoundFile(false);
  writer=new IndexWriter(directory1,config);
  addDocs(writer,5,2);
  writer.close();
  CompressedFieldDataDirectory directory2=new CompressedFieldDataDirectory(DirectIODirectory.wrap(dir),COMPRESSION_CODEC,4);
  config=new IndexWriterConfig(Version.LUCENE_33,new KeywordAnalyzer());
  mergePolicy=(TieredMergePolicy)config.getMergePolicy();
  mergePolicy.setUseCompoundFile(false);
  writer=new IndexWriter(directory2,config);
  addDocs(writer,7,3);
  writer.close();
  testFetches(directory2);
}",0.9759229534510432
1500,"@Override public void onError(Exception exception){
  _pool._numberOfConnections.decrementAndGet();
  _realCallback.onError(exception);
}","@Override public void onError(Exception exception){
  AtomicInteger counter=_pool._numberOfConnections.get(_connection._host);
  if (counter != null) {
    counter.decrementAndGet();
  }
  _realCallback.onError(exception);
}",0.7590027700831025
1501,"private TAsyncClient newClient(Class<?> c,Connection connection) throws InterruptedException {
  BlockingQueue<TAsyncClient> blockingQueue=getQueue(connection);
  TAsyncClient client=blockingQueue.poll();
  if (client != null) {
    return client;
  }
  int numOfConnections=_numberOfConnections.get();
  while (numOfConnections >= _maxConnectionsPerHost) {
    client=blockingQueue.poll(_pollTime,TimeUnit.MILLISECONDS);
    if (client != null) {
      return client;
    }
    LOG.debug(""String_Node_Str"",numOfConnections,_maxConnectionsPerHost);
    numOfConnections=_numberOfConnections.get();
  }
  LOG.info(""String_Node_Str"",connection);
  String name=c.getName();
  Constructor<?> constructor=_constructorCache.get(name);
  if (constructor == null) {
    String clientClassName=name.replace(""String_Node_Str"",""String_Node_Str"");
    try {
      Class<?> clazz=Class.forName(clientClassName);
      constructor=clazz.getConstructor(new Class[]{TProtocolFactory.class,TAsyncClientManager.class,TNonblockingTransport.class});
      _constructorCache.put(name,constructor);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  try {
    client=(TAsyncClient)constructor.newInstance(new Object[]{_protocolFactory,_clientManager,newTransport(connection)});
    client.setTimeout(_timeout);
    _numberOfConnections.incrementAndGet();
    return client;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","private TAsyncClient newClient(Class<?> c,Connection connection) throws InterruptedException {
  BlockingQueue<TAsyncClient> blockingQueue=getQueue(connection);
  TAsyncClient client=blockingQueue.poll();
  if (client != null) {
    return client;
  }
  AtomicInteger counter;
synchronized (_numberOfConnections) {
    counter=_numberOfConnections.get(connection._host);
    if (counter == null) {
      counter=new AtomicInteger();
      _numberOfConnections.put(connection._host,counter);
    }
  }
synchronized (counter) {
    int numOfConnections=counter.get();
    while (numOfConnections >= _maxConnectionsPerHost) {
      client=blockingQueue.poll(_pollTime,TimeUnit.MILLISECONDS);
      if (client != null) {
        return client;
      }
      LOG.debug(""String_Node_Str"" + numOfConnections + ""String_Node_Str""+ _maxConnectionsPerHost+ ""String_Node_Str"");
      numOfConnections=counter.get();
    }
    LOG.info(""String_Node_Str"" + connection + ""String_Node_Str"");
    String name=c.getName();
    Constructor<?> constructor=_constructorCache.get(name);
    if (constructor == null) {
      String clientClassName=name.replace(""String_Node_Str"",""String_Node_Str"");
      try {
        Class<?> clazz=Class.forName(clientClassName);
        constructor=clazz.getConstructor(new Class[]{TProtocolFactory.class,TAsyncClientManager.class,TNonblockingTransport.class});
        _constructorCache.put(name,constructor);
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
    try {
      client=(TAsyncClient)constructor.newInstance(new Object[]{_protocolFactory,_clientManager,newTransport(connection)});
      client.setTimeout(_timeout);
      counter.incrementAndGet();
      return client;
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
}",0.810149801284011
1502,"private void returnClient(Connection connection,TAsyncClient client) throws InterruptedException {
  if (!client.hasError()) {
    getQueue(connection).put(client);
  }
 else {
    _numberOfConnections.decrementAndGet();
  }
}","private void returnClient(Connection connection,TAsyncClient client) throws InterruptedException {
  if (!client.hasError()) {
    getQueue(connection).put(client);
  }
 else {
    AtomicInteger counter=_numberOfConnections.get(connection._host);
    if (counter != null) {
      counter.decrementAndGet();
    }
  }
}",0.8308823529411765
1503,"@Override public void sync(String name) throws IOException {
  File file=_localFileCache.getLocalFile(_dirName,name);
  Path dest=new Path(hdfsDirPath,name + ""String_Node_Str"");
  Path source=new Path(file.getAbsolutePath());
  int count=0;
  while (true) {
    try {
      LOG.debug(""String_Node_Str"",file.getAbsolutePath(),hdfsDirPath);
      fileSystem.copyFromLocalFile(source,dest);
      rename(name + ""String_Node_Str"",name);
      return;
    }
 catch (    IOException e) {
      if (count < _retryCount) {
        count++;
        LOG.error(""String_Node_Str"",e,count,source,dest);
      }
 else {
        throw e;
      }
    }
  }
}","@Override public void sync(String name) throws IOException {
  File file=_localFileCache.getLocalFile(_dirName,name);
  int count=0;
  while (true) {
    Path dest=new Path(hdfsDirPath,name + ""String_Node_Str"" + count);
    try {
      LOG.debug(""String_Node_Str"",file.getAbsolutePath(),hdfsDirPath);
      FSDataOutputStream outputStream=fileSystem.create(dest);
      InputStream inputStream=new BufferedInputStream(new FileInputStream(file));
      byte[] buffer=new byte[4096];
      int num;
      while ((num=inputStream.read(buffer)) != -1) {
        outputStream.write(buffer,0,num);
        _progressable.progress();
      }
      rename(name + ""String_Node_Str"" + count,name);
      return;
    }
 catch (    IOException e) {
      if (count < _retryCount) {
        LOG.error(""String_Node_Str"",e,count,file.getAbsolutePath(),dest);
        count++;
        try {
          fileSystem.delete(dest,false);
        }
 catch (        IOException ex) {
          LOG.error(""String_Node_Str"",ex,dest);
        }
      }
 else {
        throw e;
      }
    }
  }
}",0.5493863237872589
1504,"public IndexInput openFromLocal(String name,int bufferSize) throws IOException {
  if (Constants.WINDOWS) {
    return new FileIndexInput(_localFileCache.getLocalFile(_dirName,name),bufferSize);
  }
 else   if (name.endsWith(""String_Node_Str"")) {
    return new FileNIOIndexInput(_localFileCache.getLocalFile(_dirName,name),bufferSize);
  }
 else {
    return new MMapIndexInput(_localFileCache.getLocalFile(_dirName,name));
  }
}","public IndexInput openFromLocal(String name,int bufferSize) throws IOException {
  if (Constants.WINDOWS) {
    return new FileIndexInput(_localFileCache.getLocalFile(_dirName,name),bufferSize);
  }
 else   if (name.endsWith(""String_Node_Str"") || !Constants.JRE_IS_64BIT) {
    return new FileNIOIndexInput(_localFileCache.getLocalFile(_dirName,name),bufferSize);
  }
 else {
    return new MMapIndexInput(_localFileCache.getLocalFile(_dirName,name));
  }
}",0.9695603156708004
1505,"private File newFile(String dirName,String name){
  int index=random.nextInt(files.length);
  for (int i=0; i < files.length; i++) {
    File dir=new File(files[index],dirName);
    if (!dir.exists()) {
      dir.mkdirs();
    }
    try {
      File file=new File(dir,name);
      file.createNewFile();
      return file;
    }
 catch (    IOException e) {
      LOG.error(""String_Node_Str"",dir);
    }
    index++;
    if (index >= files.length) {
      index=0;
    }
  }
  fatalNoLocalDirs();
  return null;
}","private File newFile(String dirName,String name){
  int index=random.nextInt(files.length);
  for (int i=0; i < files.length; i++) {
    File dir=new File(files[index],dirName);
    if (!dir.exists()) {
      dir.mkdirs();
    }
    try {
      createDir(dir);
      File file=new File(dir,name);
      return file;
    }
 catch (    IOException e) {
      LOG.error(""String_Node_Str"",dir);
    }
    index++;
    if (index >= files.length) {
      index=0;
    }
  }
  fatalNoLocalDirs();
  return null;
}",0.950884086444008
1506,"private static FieldSelector getFieldSelector(final Selector selector){
  return new FieldSelector(){
    private static final long serialVersionUID=4089164344758433000L;
    @Override public FieldSelectorResult accept(    String fieldName){
      if (ROW_ID.equals(fieldName)) {
        return FieldSelectorResult.LOAD;
      }
      if (RECORD_ID.equals(fieldName)) {
        return FieldSelectorResult.LOAD;
      }
      if (PRIME_DOC.equals(fieldName)) {
        return FieldSelectorResult.NO_LOAD;
      }
      if (selector.columnFamiliesToFetch == null && selector.columnsToFetch == null) {
        return FieldSelectorResult.LOAD;
      }
      String columnFamily=getColumnFamily(fieldName);
      if (selector.columnFamiliesToFetch != null) {
        if (selector.columnFamiliesToFetch.contains(columnFamily)) {
          return FieldSelectorResult.LOAD;
        }
        return FieldSelectorResult.NO_LOAD;
      }
      String columnName=getColumnName(fieldName);
      if (selector.columnsToFetch != null) {
        Set<String> columns=selector.columnsToFetch.get(columnFamily);
        if (columns != null && columns.contains(columnName)) {
          return FieldSelectorResult.LOAD;
        }
      }
      return FieldSelectorResult.NO_LOAD;
    }
  }
;
}","private static FieldSelector getFieldSelector(final Selector selector){
  return new FieldSelector(){
    private static final long serialVersionUID=4089164344758433000L;
    @Override public FieldSelectorResult accept(    String fieldName){
      if (ROW_ID.equals(fieldName)) {
        return FieldSelectorResult.LOAD;
      }
      if (RECORD_ID.equals(fieldName)) {
        return FieldSelectorResult.LOAD;
      }
      if (PRIME_DOC.equals(fieldName)) {
        return FieldSelectorResult.NO_LOAD;
      }
      if (selector.columnFamiliesToFetch == null && selector.columnsToFetch == null) {
        return FieldSelectorResult.LOAD;
      }
      String columnFamily=getColumnFamily(fieldName);
      if (selector.columnFamiliesToFetch != null) {
        if (selector.columnFamiliesToFetch.contains(columnFamily)) {
          return FieldSelectorResult.LOAD;
        }
      }
      String columnName=getColumnName(fieldName);
      if (selector.columnsToFetch != null) {
        Set<String> columns=selector.columnsToFetch.get(columnFamily);
        if (columns != null && columns.contains(columnName)) {
          return FieldSelectorResult.LOAD;
        }
      }
      return FieldSelectorResult.NO_LOAD;
    }
  }
;
}",0.7442046362909672
1507,"@Override public FieldSelectorResult accept(String fieldName){
  if (ROW_ID.equals(fieldName)) {
    return FieldSelectorResult.LOAD;
  }
  if (RECORD_ID.equals(fieldName)) {
    return FieldSelectorResult.LOAD;
  }
  if (PRIME_DOC.equals(fieldName)) {
    return FieldSelectorResult.NO_LOAD;
  }
  if (selector.columnFamiliesToFetch == null && selector.columnsToFetch == null) {
    return FieldSelectorResult.LOAD;
  }
  String columnFamily=getColumnFamily(fieldName);
  if (selector.columnFamiliesToFetch != null) {
    if (selector.columnFamiliesToFetch.contains(columnFamily)) {
      return FieldSelectorResult.LOAD;
    }
    return FieldSelectorResult.NO_LOAD;
  }
  String columnName=getColumnName(fieldName);
  if (selector.columnsToFetch != null) {
    Set<String> columns=selector.columnsToFetch.get(columnFamily);
    if (columns != null && columns.contains(columnName)) {
      return FieldSelectorResult.LOAD;
    }
  }
  return FieldSelectorResult.NO_LOAD;
}","@Override public FieldSelectorResult accept(String fieldName){
  if (ROW_ID.equals(fieldName)) {
    return FieldSelectorResult.LOAD;
  }
  if (RECORD_ID.equals(fieldName)) {
    return FieldSelectorResult.LOAD;
  }
  if (PRIME_DOC.equals(fieldName)) {
    return FieldSelectorResult.NO_LOAD;
  }
  if (selector.columnFamiliesToFetch == null && selector.columnsToFetch == null) {
    return FieldSelectorResult.LOAD;
  }
  String columnFamily=getColumnFamily(fieldName);
  if (selector.columnFamiliesToFetch != null) {
    if (selector.columnFamiliesToFetch.contains(columnFamily)) {
      return FieldSelectorResult.LOAD;
    }
  }
  String columnName=getColumnName(fieldName);
  if (selector.columnsToFetch != null) {
    Set<String> columns=selector.columnsToFetch.get(columnFamily);
    if (columns != null && columns.contains(columnName)) {
      return FieldSelectorResult.LOAD;
    }
  }
  return FieldSelectorResult.NO_LOAD;
}",0.7023060796645703
1508,"public void init(){
  super.init();
  startIndexReaderCloserDaemon();
  startIndexReopenerDaemon();
}","public void init(){
  super.init();
  startIndexReaderCloserDaemon();
}",0.8255813953488372
1509,"protected void closeOldReaders(String table){
  Set<String> shardsToServe=getShardsToServe(table);
  Map<String,IndexReader> tableReaders=readers.get(table);
  if (tableReaders == null) {
    return;
  }
  Set<String> shardsOpen=new HashSet<String>(tableReaders.keySet());
  shardsOpen.removeAll(shardsToServe);
  if (shardsOpen.isEmpty()) {
    return;
  }
  for (  String shard : shardsOpen) {
    LOG.info(""String_Node_Str"",table,shard);
    IndexReader indexReader=tableReaders.remove(shard);
    beforeClose(shard,indexReader);
    try {
      indexReader.close();
    }
 catch (    IOException e) {
      LOG.error(""String_Node_Str"",e,indexReader);
    }
    cleanupLocallyCachedIndexes(table,shard);
  }
}","protected void closeOldReaders(String table){
  Set<String> shardsToServe=getShardsToServe(table);
  Map<String,IndexReader> tableReaders=readers.get(table);
  if (tableReaders == null) {
    return;
  }
  Set<String> shardsOpen=new HashSet<String>(tableReaders.keySet());
  shardsOpen.removeAll(shardsToServe);
  if (shardsOpen.isEmpty()) {
    return;
  }
  for (  String shard : shardsOpen) {
    IndexReader indexReader=tableReaders.remove(shard);
    closeIndex(table,shard,indexReader);
  }
}",0.6909090909090909
1510,"@Override protected IndexReader openShard(String table,String shard) throws IOException {
  LOG.info(""String_Node_Str"",shard,table);
  Path tablePath=new Path(blurBasePath,table);
  if (!exists(tablePath)) {
    throw new FileNotFoundException(tablePath.toString());
  }
  Path hdfsDirPath=new Path(tablePath,shard);
  if (!exists(hdfsDirPath)) {
    throw new FileNotFoundException(hdfsDirPath.toString());
  }
  ReplicaHdfsDirectory directory=new ReplicaHdfsDirectory(table,shard,hdfsDirPath,fileSystem,localFileCache,lockFactory,new Progressable(){
    @Override public void progress(){
    }
  }
,replicationDaemon);
  touchFiles(directory,table,shard);
  return IndexReader.open(directory);
}","@Override protected IndexReader openShard(String table,String shard) throws IOException {
  LOG.info(""String_Node_Str"",shard,table);
  Path tablePath=new Path(blurBasePath,table);
  if (!exists(tablePath)) {
    throw new FileNotFoundException(tablePath.toString());
  }
  Path hdfsDirPath=new Path(tablePath,shard);
  if (!exists(hdfsDirPath)) {
    throw new FileNotFoundException(hdfsDirPath.toString());
  }
  ReplicaHdfsDirectory directory=new ReplicaHdfsDirectory(table,shard,hdfsDirPath,fileSystem,localFileCache,lockFactory,new Progressable(){
    @Override public void progress(){
    }
  }
,replicationDaemon);
  return warmUp(IndexReader.open(directory));
}",0.9582417582417584
1511,"@Override public List<String> getShardList(String table){
  List<String> result=new ArrayList<String>();
  try {
    FileStatus[] listStatus=fileSystem.listStatus(new Path(blurBasePath,table));
    for (    FileStatus status : listStatus) {
      if (status.isDir()) {
        result.add(status.getPath().getName());
      }
    }
    return result;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","@Override public List<String> getShardList(String table){
  List<String> result=new ArrayList<String>();
  try {
    FileStatus[] listStatus=fileSystem.listStatus(new Path(blurBasePath,table));
    for (    FileStatus status : listStatus) {
      if (status.isDir()) {
        String name=status.getPath().getName();
        if (name.startsWith(SHARD_PREFIX)) {
          result.add(name);
        }
      }
    }
    return result;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.8605405405405405
1512,"public static void main(String[] args) throws TTransportException, IOException {
  Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler(){
    @Override public void uncaughtException(    Thread t,    Throwable e){
      LOG.error(""String_Node_Str"",e,t);
    }
  }
);
  String nodeName=args[0];
  String zkConnectionStr=args[1];
  String hdfsPath=args[2];
  List<File> localFileCaches=new ArrayList<File>();
  for (  String cachePath : args[3].split(""String_Node_Str"")) {
    localFileCaches.add(new File(cachePath));
  }
  boolean crazyMode=false;
  if (args.length == 5 && args[4].equals(CRAZY)) {
    crazyMode=true;
  }
  ZooKeeper zooKeeper=new ZooKeeper(zkConnectionStr,10000,new Watcher(){
    @Override public void process(    WatchedEvent event){
    }
  }
);
  ZookeeperDistributedManager dzk=new ZookeeperDistributedManager();
  dzk.setZooKeeper(zooKeeper);
  FileSystem fileSystem=FileSystem.get(new Configuration());
  Path blurBasePath=new Path(hdfsPath);
  HdfsExistenceCheck existenceCheck=new HdfsExistenceCheck(fileSystem,blurBasePath);
  LocalFileCache localFileCache=new LocalFileCache();
  localFileCache.setLocalFileCacheCheck(existenceCheck);
  localFileCache.setPotentialFiles(localFileCaches.toArray(new File[]{}));
  localFileCache.open();
  LockFactory lockFactory=new NoLockFactory();
  ReplicationDaemon replicationDaemon=new ReplicationDaemon(localFileCache);
  HdfsIndexServer indexServer=new HdfsIndexServer();
  indexServer.setType(NODE_TYPE.SHARD);
  indexServer.setLocalFileCache(localFileCache);
  indexServer.setLockFactory(lockFactory);
  indexServer.setFileSystem(fileSystem);
  indexServer.setBlurBasePath(blurBasePath);
  indexServer.setNodeName(nodeName);
  indexServer.setDistributedManager(dzk);
  indexServer.setReplicationDaemon(replicationDaemon);
  indexServer.init();
  localFileCache.setLocalFileCacheCheck(getLocalFileCacheCheck(indexServer));
  IndexManager indexManager=new IndexManager();
  indexManager.setIndexServer(indexServer);
  indexManager.init();
  BlurShardServer shardServer=new BlurShardServer();
  shardServer.setIndexServer(indexServer);
  shardServer.setIndexManager(indexManager);
  ThriftBlurShardServer server=new ThriftBlurShardServer();
  server.setNodeName(nodeName);
  if (crazyMode) {
    System.err.println(""String_Node_Str"");
    server.setIface(crazyMode(shardServer));
  }
 else {
    server.setIface(shardServer);
  }
  server.start();
}","public static void main(String[] args) throws TTransportException, IOException {
  Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler(){
    @Override public void uncaughtException(    Thread t,    Throwable e){
      LOG.error(""String_Node_Str"",e,t);
    }
  }
);
  String nodeName=args[0];
  String zkConnectionStr=args[1];
  String hdfsPath=args[2];
  List<File> localFileCaches=new ArrayList<File>();
  for (  String cachePath : args[3].split(""String_Node_Str"")) {
    localFileCaches.add(new File(cachePath));
  }
  boolean crazyMode=false;
  if (args.length == 5 && args[4].equals(CRAZY)) {
    crazyMode=true;
  }
  ZooKeeper zooKeeper=new ZooKeeper(zkConnectionStr,10000,new Watcher(){
    @Override public void process(    WatchedEvent event){
    }
  }
);
  ZookeeperDistributedManager dzk=new ZookeeperDistributedManager();
  dzk.setZooKeeper(zooKeeper);
  FileSystem fileSystem=FileSystem.get(new Configuration());
  Path blurBasePath=new Path(hdfsPath);
  LocalFileCache localFileCache=new LocalFileCache();
  localFileCache.setPotentialFiles(localFileCaches.toArray(new File[]{}));
  localFileCache.open();
  LockFactory lockFactory=new NoLockFactory();
  ReplicationDaemon replicationDaemon=new ReplicationDaemon(localFileCache);
  HdfsIndexServer indexServer=new HdfsIndexServer();
  indexServer.setType(NODE_TYPE.SHARD);
  indexServer.setLocalFileCache(localFileCache);
  indexServer.setLockFactory(lockFactory);
  indexServer.setFileSystem(fileSystem);
  indexServer.setBlurBasePath(blurBasePath);
  indexServer.setNodeName(nodeName);
  indexServer.setDistributedManager(dzk);
  indexServer.setReplicationDaemon(replicationDaemon);
  indexServer.init();
  localFileCache.setLocalFileCacheCheck(getLocalFileCacheCheck(indexServer));
  IndexManager indexManager=new IndexManager();
  indexManager.setIndexServer(indexServer);
  indexManager.init();
  BlurShardServer shardServer=new BlurShardServer();
  shardServer.setIndexServer(indexServer);
  shardServer.setIndexManager(indexManager);
  ThriftBlurShardServer server=new ThriftBlurShardServer();
  server.setNodeName(nodeName);
  if (crazyMode) {
    System.err.println(""String_Node_Str"");
    server.setIface(crazyMode(shardServer));
  }
 else {
    server.setIface(shardServer);
  }
  server.start();
}",0.9539112050739956
1513,"@Override protected boolean authUser(Session session,byte[] password) throws Exception {
  super.authUser(session,password);
  byte[] passphrase=null;
  final Set<Identity> identities=IdentityManager.getManager().getIdentities();
synchronized (identities) {
    if (identities.isEmpty()) {
      return false;
    }
    identityLoop:     for (    Identity identity : identities) {
      byte[] pubkeyblob=identity.getPublicKeyBlob();
      if (pubkeyblob != null) {
        _packet.reset();
        _buffer.putByte(SSH_MSG_USERAUTH_REQUEST);
        _buffer.putString(session.getUserName());
        _buffer.putString(SSH_CONNECTION);
        _buffer.putString(UserAuth.PUBLICKEY);
        _buffer.putByte((byte)0);
        _buffer.putString(identity.getAlgorithmName());
        _buffer.putString(pubkeyblob);
        session.write(_packet);
        loop1:         while (true) {
switch (session.read(_buffer).getCommand() & 0xff) {
case SSH_MSG_USERAUTH_BANNER:
            userAuthBanner();
          continue loop1;
case SSH_MSG_USERAUTH_PK_OK:
        break loop1;
case SSH_MSG_USERAUTH_FAILURE:
default :
      continue identityLoop;
  }
}
}
int count=5;
while (count-- > 0) {
if (identity.isEncrypted()) {
  if (_userinfo == null) {
    throw new JSchException(""String_Node_Str"");
  }
 else   if (!_userinfo.promptPassphrase(String.format(MessageConstants.PROMPT_PASSPHRASE,identity.getName()))) {
    throw new AuthCancelException(""String_Node_Str"");
  }
  if (_userinfo.getPassphrase() != null) {
    passphrase=Util.str2byte(_userinfo.getPassphrase());
  }
}
if ((!identity.isEncrypted() || passphrase != null) && identity.setPassphrase(passphrase)) {
  break;
}
Util.bzero(passphrase);
passphrase=null;
}
Util.bzero(passphrase);
passphrase=null;
if (identity.isEncrypted()) {
continue;
}
if (pubkeyblob == null) {
pubkeyblob=identity.getPublicKeyBlob();
}
if (pubkeyblob == null) {
continue;
}
_packet.reset();
_buffer.setOffSet(0);
_buffer.putByte(SSH_MSG_USERAUTH_REQUEST);
_buffer.putString(session.getUserName());
_buffer.putString(SSH_CONNECTION);
_buffer.putString(UserAuth.PUBLICKEY);
_buffer.putByte((byte)1);
_buffer.putString(identity.getAlgorithmName());
_buffer.putString(pubkeyblob);
byte[] sid=session.getSessionId();
byte[] tmpData=new byte[4 + sid.length + _buffer.getLength() - 5];
Buffer tmp=new Buffer(tmpData);
tmp.putString(sid);
tmp.putBytes(_buffer,5,_buffer.getLength() - 5);
byte[] signature=identity.getSignature(tmpData);
if (signature == null) {
break;
}
_buffer.putString(signature);
session.write(_packet);
loop2: while (true) {
switch (session.read(_buffer).getCommand() & 0xff) {
case SSH_MSG_USERAUTH_SUCCESS:
  return true;
case SSH_MSG_USERAUTH_BANNER:
userAuthBanner();
continue loop2;
case SSH_MSG_USERAUTH_FAILURE:
userAuthFailure();
break loop2;
}
break;
}
}
}
return false;
}","@Override protected boolean authUser(Session session,byte[] password) throws Exception {
  super.authUser(session,password);
  byte[] passphrase=null;
  final Set<Identity> identities=IdentityManager.getManager().getIdentities();
synchronized (identities) {
    if (identities.isEmpty()) {
      return false;
    }
    for (    Identity identity : identities) {
      byte[] pubkeyblob=identity.getPublicKeyBlob();
      if (pubkeyblob != null) {
        _packet.reset();
        _buffer.putByte(SSH_MSG_USERAUTH_REQUEST);
        _buffer.putString(session.getUserName());
        _buffer.putString(SSH_CONNECTION);
        _buffer.putString(UserAuth.PUBLICKEY);
        _buffer.putByte((byte)0);
        _buffer.putString(identity.getAlgorithmName());
        _buffer.putString(pubkeyblob);
        session.write(_packet);
        boolean read_more=true;
        boolean failed=false;
        while (read_more) {
switch (session.read(_buffer).getCommand() & 0xff) {
case SSH_MSG_USERAUTH_BANNER:
            userAuthBanner();
          break;
case SSH_MSG_USERAUTH_PK_OK:
        read_more=false;
      break;
case SSH_MSG_USERAUTH_FAILURE:
default :
    failed=true;
  read_more=false;
}
}
if (failed) continue;
}
int count=5;
while (count-- > 0) {
if (identity.isEncrypted()) {
if (_userinfo == null) {
throw new JSchException(""String_Node_Str"");
}
 else if (!_userinfo.promptPassphrase(String.format(MessageConstants.PROMPT_PASSPHRASE,identity.getName()))) {
throw new AuthCancelException(""String_Node_Str"");
}
if (_userinfo.getPassphrase() != null) {
passphrase=Util.str2byte(_userinfo.getPassphrase());
}
}
if ((!identity.isEncrypted() || passphrase != null) && identity.setPassphrase(passphrase)) {
break;
}
Util.bzero(passphrase);
passphrase=null;
}
Util.bzero(passphrase);
passphrase=null;
if (identity.isEncrypted()) {
continue;
}
if (pubkeyblob == null) {
pubkeyblob=identity.getPublicKeyBlob();
}
if (pubkeyblob == null) {
continue;
}
_packet.reset();
_buffer.setOffSet(0);
_buffer.putByte(SSH_MSG_USERAUTH_REQUEST);
_buffer.putString(session.getUserName());
_buffer.putString(SSH_CONNECTION);
_buffer.putString(UserAuth.PUBLICKEY);
_buffer.putByte((byte)1);
_buffer.putString(identity.getAlgorithmName());
_buffer.putString(pubkeyblob);
byte[] sid=session.getSessionId();
byte[] tmpData=new byte[4 + sid.length + _buffer.getLength() - 5];
Buffer tmp=new Buffer(tmpData);
tmp.putString(sid);
tmp.putBytes(_buffer,5,_buffer.getLength() - 5);
byte[] signature=identity.getSignature(tmpData);
if (signature == null) {
break;
}
_buffer.putString(signature);
session.write(_packet);
boolean read_more=true;
while (read_more) {
switch (session.read(_buffer).getCommand() & 0xff) {
case SSH_MSG_USERAUTH_SUCCESS:
return true;
case SSH_MSG_USERAUTH_BANNER:
userAuthBanner();
break;
case SSH_MSG_USERAUTH_FAILURE:
userAuthFailure();
read_more=false;
}
}
}
}
return false;
}",0.9423110643520954
1514,"private void populateFields(){
  try {
    Cursor note=NotesDbAdapter.getInstance(this).fetchNote(mRowId);
    startManagingCursor(note);
    blob=note.getBlob(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_DATA));
    setupView(blob != null);
    if (blob != null) {
      BitmapFactory.Options bmpFactoryOptions=new BitmapFactory.Options();
      bmpFactoryOptions.inSampleSize=3;
      Bitmap blobb=BitmapFactory.decodeByteArray(blob,0,blob.length,bmpFactoryOptions);
      mImageView.setImageBitmap(blobb);
    }
 else {
      mBodyText.setText(note.getString(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_BODY)));
    }
    mTitleText.setText(note.getString(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_TITLE)));
  }
 catch (  Exception e) {
    Log.e(""String_Node_Str"",""String_Node_Str"",e);
  }
}","private void populateFields(){
  try {
    Cursor note=NotesDbAdapter.getInstance(this).fetchNote(mRowId);
    startManagingCursor(note);
    blob=note.getBlob(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_DATA));
    setupView(blob != null);
    if (blob != null) {
      BitmapFactory.Options bmpFactoryOptions=new BitmapFactory.Options();
      bmpFactoryOptions.inSampleSize=4;
      Bitmap blobb=BitmapFactory.decodeByteArray(blob,0,blob.length,bmpFactoryOptions);
      mImageView.setImageBitmap(blobb);
      System.gc();
    }
 else {
      mBodyText.setText(note.getString(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_BODY)));
    }
    mTitleText.setText(note.getString(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_TITLE)));
  }
 catch (  Exception e) {
    Log.e(""String_Node_Str"",""String_Node_Str"",e);
    Toast.makeText(this,""String_Node_Str"" + e.getMessage(),Toast.LENGTH_LONG).show();
  }
}",0.9373902867173786
1515,"@Override protected void onResume(){
  super.onResume();
  Bundle extras=getIntent().getExtras();
  if (mRowId != -1) {
    populateFields();
  }
 else   if (extras != null) {
    mRowId=extras.getLong(NotesDbAdapter.KEY_ROWID);
    populateFields();
  }
 else {
    setupView(false);
  }
  populateFields();
}","@Override protected void onResume(){
  super.onResume();
  Bundle extras=getIntent().getExtras();
  if (mRowId != -1) {
    populateFields();
  }
 else   if (extras != null) {
    mRowId=extras.getLong(NotesDbAdapter.KEY_ROWID);
    populateFields();
  }
 else {
    setupView(false);
  }
}",0.9633333333333334
1516,"private void importDataStream(){
  Intent passingIntent=new Intent(this,ImageStore.class);
  passingIntent.setData(dataStream);
  startActivityForResult(passingIntent,1);
  dataStream=null;
}","private void importDataStream(){
  try {
    InputStream is=getContentResolver().openInputStream(dataStream);
    String mimeType=getContentResolver().getType(dataStream);
    byte[] data=NoteUtils.readBytesAndClose(is);
    String title=dataStream.getLastPathSegment();
    String body=dataStream.getPath();
    NotesDbAdapter.getInstance(this).createNote(title,body,data,mimeType);
    data=null;
    Toast.makeText(this,""String_Node_Str"" + title,Toast.LENGTH_LONG).show();
    handleDelete();
    fillData();
  }
 catch (  FileNotFoundException e) {
    Log.e(TAG,e.getMessage(),e);
  }
catch (  IOException e) {
    Log.e(TAG,e.getMessage(),e);
  }
catch (  OutOfMemoryError e) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
  }
 finally {
  }
}",0.0954356846473029
1517,"private void unlockDatabase(String password){
  try {
    mDbHelper.open(password);
    fillData();
  }
 catch (  Exception e) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
    showPassword();
  }
}","private void unlockDatabase(String password){
  try {
    mDbHelper.open(password);
    if (dataStream != null)     importDataStream();
 else     fillData();
  }
 catch (  Exception e) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
    showPassword();
  }
}",0.8849206349206349
1518,"@Override public void onAttachedToWindow(){
  super.onAttachedToWindow();
  findViewById(R.id.listlayout).setOnTouchListener(new OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      createNote();
      return false;
    }
  }
);
}","@Override public void onAttachedToWindow(){
  super.onAttachedToWindow();
  findViewById(R.id.listlayout).setOnTouchListener(new OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      if (mDbHelper != null && mDbHelper.isOpen())       createNote();
      return false;
    }
  }
);
}",0.9148580968280468
1519,"@Override protected void onResume(){
  super.onResume();
  mDbHelper=NotesDbAdapter.getInstance(this);
  if (!mDbHelper.isOpen())   showPassword();
 else   fillData();
  if (dataStream != null)   importDataStream();
}","@Override protected void onResume(){
  super.onResume();
  mDbHelper=NotesDbAdapter.getInstance(this);
  if (!mDbHelper.isOpen())   showPassword();
 else   if (dataStream != null)   importDataStream();
 else   fillData();
}",0.9227272727272728
1520,"@Override public boolean onTouch(View v,MotionEvent event){
  createNote();
  return false;
}","@Override public boolean onTouch(View v,MotionEvent event){
  if (mDbHelper != null && mDbHelper.isOpen())   createNote();
  return false;
}",0.7982832618025751
1521,"private void populateFields(){
  try {
    Cursor note=NotesDbAdapter.getInstance(this).fetchNote(mRowId);
    startManagingCursor(note);
    blob=note.getBlob(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_DATA));
    setupView(blob != null);
    if (blob != null) {
      BitmapFactory.Options bmpFactoryOptions=new BitmapFactory.Options();
      bmpFactoryOptions.inSampleSize=4;
      Bitmap blobb=BitmapFactory.decodeByteArray(blob,0,blob.length,bmpFactoryOptions);
      mImageView.setImageBitmap(blobb);
      System.gc();
    }
 else {
      mBodyText.setText(note.getString(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_BODY)));
    }
    mTitleText.setText(note.getString(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_TITLE)));
  }
 catch (  Exception e) {
    Log.e(""String_Node_Str"",""String_Node_Str"",e);
    Toast.makeText(this,""String_Node_Str"" + e.getMessage(),Toast.LENGTH_LONG).show();
  }
}","private void populateFields(){
  try {
    Cursor note=NotesDbAdapter.getInstance(this).fetchNote(mRowId);
    startManagingCursor(note);
    blob=note.getBlob(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_DATA));
    setupView(blob != null);
    if (blob != null) {
      BitmapFactory.Options bmpFactoryOptions=new BitmapFactory.Options();
      if (blob.length > 100000)       bmpFactoryOptions.inSampleSize=4;
 else       bmpFactoryOptions.inSampleSize=2;
      Bitmap blobb=BitmapFactory.decodeByteArray(blob,0,blob.length,bmpFactoryOptions);
      mImageView.setImageBitmap(blobb);
      System.gc();
    }
 else {
      mBodyText.setText(note.getString(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_BODY)));
    }
    mTitleText.setText(note.getString(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_TITLE)));
  }
 catch (  Exception e) {
    Log.e(""String_Node_Str"",""String_Node_Str"",e);
    Toast.makeText(this,""String_Node_Str"" + e.getMessage(),Toast.LENGTH_LONG).show();
  }
}",0.9587737843551796
1522,"@Override protected void onSaveInstanceState(Bundle outState){
  super.onSaveInstanceState(outState);
  if (mRowId != -1)   outState.putLong(NotesDbAdapter.KEY_ROWID,mRowId);
}","@Override protected void onSaveInstanceState(Bundle outState){
  super.onSaveInstanceState(outState);
  saveState();
  if (mRowId != -1)   outState.putLong(NotesDbAdapter.KEY_ROWID,mRowId);
}",0.9591280653950952
1523,"@Override protected void onPause(){
  super.onPause();
  saveState();
}","@Override protected void onPause(){
  super.onPause();
  saveState();
  if (mTitleText != null)   mTitleText.setText(ZERO_TEXT);
  if (mBodyText != null)   mBodyText.setText(ZERO_TEXT);
  if (mImageView != null)   mImageView.setImageBitmap(null);
}",0.445141065830721
1524,"private void importDataStream(){
  try {
    InputStream is=getContentResolver().openInputStream(dataStream);
    String mimeType=getContentResolver().getType(dataStream);
    byte[] data=NoteUtils.readBytesAndClose(is);
    String title=dataStream.getLastPathSegment();
    String body=dataStream.getPath();
    NotesDbAdapter.getInstance(this).createNote(title,body,data,mimeType);
    data=null;
    Toast.makeText(this,""String_Node_Str"" + title,Toast.LENGTH_LONG).show();
    handleDelete();
    fillData();
  }
 catch (  FileNotFoundException e) {
    Log.e(TAG,e.getMessage(),e);
  }
catch (  IOException e) {
    Log.e(TAG,e.getMessage(),e);
  }
catch (  OutOfMemoryError e) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
  }
 finally {
  }
}","private void importDataStream(){
  try {
    InputStream is=getContentResolver().openInputStream(dataStream);
    String mimeType=getContentResolver().getType(dataStream);
    byte[] data=NoteUtils.readBytesAndClose(is);
    String title=dataStream.getLastPathSegment();
    String body=dataStream.getPath();
    NotesDbAdapter.getInstance(this).createNote(title,body,data,mimeType);
    Toast.makeText(this,getString(R.string.on_import) + ""String_Node_Str"" + title,Toast.LENGTH_LONG).show();
    handleDelete();
    data=null;
    dataStream=null;
    title=null;
    body=null;
    System.gc();
    fillData();
  }
 catch (  FileNotFoundException e) {
    Log.e(TAG,e.getMessage(),e);
  }
catch (  IOException e) {
    Log.e(TAG,e.getMessage(),e);
  }
catch (  OutOfMemoryError e) {
    Toast.makeText(this,getString(R.string.err_size),Toast.LENGTH_LONG).show();
  }
 finally {
  }
}",0.8950542822677925
1525,"private void fillData(){
  Cursor notesCursor=mDbHelper.fetchAllNotes();
  startManagingCursor(notesCursor);
  String[] from=new String[]{NotesDbAdapter.KEY_TITLE};
  int[] to=new int[]{R.id.text1};
  SimpleCursorAdapter notes=new SimpleCursorAdapter(this,R.layout.notes_row,notesCursor,from,to);
  setListAdapter(notes);
  if (notes.isEmpty()) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
  }
}","private void fillData(){
  Cursor notesCursor=mDbHelper.fetchAllNotes();
  startManagingCursor(notesCursor);
  String[] from=new String[]{NotesDbAdapter.KEY_TITLE};
  int[] to=new int[]{R.id.text1};
  SimpleCursorAdapter notes=new SimpleCursorAdapter(this,R.layout.notes_row,notesCursor,from,to);
  setListAdapter(notes);
  if (notes.isEmpty()) {
    Toast.makeText(this,getString(R.string.on_start),Toast.LENGTH_LONG).show();
  }
}",0.9636576787807736
1526,"private void unlockDatabase(String password){
  try {
    mDbHelper.open(password);
    if (dataStream != null)     importDataStream();
 else     fillData();
  }
 catch (  Exception e) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
    showPassword();
  }
}","private void unlockDatabase(String password){
  try {
    mDbHelper.open(password);
    if (dataStream != null)     importDataStream();
 else     fillData();
  }
 catch (  Exception e) {
    Toast.makeText(this,getString(R.string.err_pin),Toast.LENGTH_LONG).show();
    showPassword();
  }
}",0.9265734265734266
1527,"private void shareEntry(long id){
  Cursor note=mDbHelper.fetchNote(id);
  startManagingCursor(note);
  byte[] blob=note.getBlob(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_DATA));
  if (blob != null) {
    try {
      NoteUtils.shareImage(this,blob);
    }
 catch (    IOException e) {
      Toast.makeText(this,""String_Node_Str"" + e.getMessage(),Toast.LENGTH_LONG).show();
    }
  }
 else {
    String body=note.getString(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_BODY));
    NoteUtils.shareText(this,body);
  }
  note.close();
}","private void shareEntry(long id){
  Cursor note=mDbHelper.fetchNote(id);
  startManagingCursor(note);
  byte[] blob=note.getBlob(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_DATA));
  if (blob != null) {
    try {
      NoteUtils.shareImage(this,blob);
    }
 catch (    IOException e) {
      Toast.makeText(this,getString(R.string.err_export) + e.getMessage(),Toast.LENGTH_LONG).show();
    }
  }
 else {
    String body=note.getString(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_BODY));
    NoteUtils.shareText(this,body);
  }
  note.close();
}",0.969641214351426
1528,"private void showPassword(){
  LayoutInflater factory=LayoutInflater.from(this);
  final View textEntryView=factory.inflate(R.layout.alert_dialog_text_entry,null);
  new AlertDialog.Builder(this).setTitle(getString(R.string.app_name)).setView(textEntryView).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
      EditText eText=((android.widget.EditText)textEntryView.findViewById(R.id.password_edit));
      String password=eText.getText().toString();
      unlockDatabase(password);
      eText.setText(""String_Node_Str"");
      System.gc();
    }
  }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
    }
  }
).create().show();
}","private void showPassword(){
  String dialogMessage;
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
  boolean firstTime=prefs.getBoolean(""String_Node_Str"",true);
  if (firstTime) {
    dialogMessage=getString(R.string.new_pin);
    Editor pEdit=prefs.edit();
    pEdit.putBoolean(""String_Node_Str"",false);
    pEdit.commit();
  }
 else   dialogMessage=getString(R.string.enter_pin);
  LayoutInflater factory=LayoutInflater.from(this);
  final View textEntryView=factory.inflate(R.layout.alert_dialog_text_entry,null);
  new AlertDialog.Builder(this).setTitle(getString(R.string.app_name)).setView(textEntryView).setMessage(dialogMessage).setPositiveButton(getString(R.string.button_ok),new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
      EditText eText=((android.widget.EditText)textEntryView.findViewById(R.id.password_edit));
      String password=eText.getText().toString();
      unlockDatabase(password);
      eText.setText(""String_Node_Str"");
      System.gc();
    }
  }
).setNegativeButton(getString(R.string.button_cancel),new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
    }
  }
).create().show();
}",0.7587844254510921
1529,"private void showRekeyDialog(){
  LayoutInflater factory=LayoutInflater.from(this);
  final View textEntryView=factory.inflate(R.layout.alert_dialog_text_entry,null);
  new AlertDialog.Builder(this).setTitle(getString(R.string.app_name)).setView(textEntryView).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
      EditText eText=((android.widget.EditText)textEntryView.findViewById(R.id.password_edit));
      String newPassword=eText.getText().toString();
      rekeyDatabase(newPassword);
      eText.setText(""String_Node_Str"");
      System.gc();
    }
  }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
    }
  }
).create().show();
}","private void showRekeyDialog(){
  LayoutInflater factory=LayoutInflater.from(this);
  final View textEntryView=factory.inflate(R.layout.alert_dialog_text_entry,null);
  new AlertDialog.Builder(this).setTitle(getString(R.string.app_name)).setView(textEntryView).setMessage(getString(R.string.rekey_message)).setPositiveButton(getString(R.string.button_ok),new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
      EditText eText=((android.widget.EditText)textEntryView.findViewById(R.id.password_edit));
      String newPassword=eText.getText().toString();
      rekeyDatabase(newPassword);
      eText.setText(""String_Node_Str"");
      System.gc();
    }
  }
).setNegativeButton(getString(R.string.button_cancel),new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
    }
  }
).create().show();
}",0.4749430523917995
1530,"private void rekeyDatabase(String password){
  try {
    mDbHelper.rekey(password);
  }
 catch (  Exception e) {
    Toast.makeText(this,e.getMessage(),Toast.LENGTH_LONG).show();
  }
}","private void rekeyDatabase(String password){
  try {
    Toast.makeText(this,getString(R.string.do_rekey),Toast.LENGTH_LONG).show();
    mDbHelper.rekey(password);
  }
 catch (  Exception e) {
    Toast.makeText(this,e.getMessage(),Toast.LENGTH_LONG).show();
  }
}",0.8214285714285714
1531,"private void loadInputStream(){
  try {
    InputStream is=getContentResolver().openInputStream(stream);
    byte[] data=null;
    data=readBytesAndClose(is);
    String title=stream.getLastPathSegment();
    String body=stream.getPath();
    mDbHelper.createNote(title,body,data);
    data=null;
    Toast.makeText(this,""String_Node_Str"" + title,Toast.LENGTH_LONG).show();
    mDbHelper.close();
    handleDelete();
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  OutOfMemoryError e) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
  }
 finally {
  }
}","private void loadInputStream(){
  try {
    InputStream is=getContentResolver().openInputStream(stream);
    String mimeType=getContentResolver().getType(stream);
    byte[] data=readBytesAndClose(is);
    String title=stream.getLastPathSegment();
    String body=stream.getPath();
    mDbHelper.createNote(title,body,data,mimeType);
    data=null;
    Toast.makeText(this,""String_Node_Str"" + title,Toast.LENGTH_LONG).show();
    mDbHelper.close();
    handleDelete();
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  OutOfMemoryError e) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
  }
 finally {
  }
}",0.940406976744186
1532,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mDbHelper=new NotesDbAdapter(this);
  String password=this.getIntent().getStringExtra(""String_Node_Str"");
  mDbHelper.open(password);
  setContentView(R.layout.note_edit);
  mTitleText=(EditText)findViewById(R.id.title);
  mBodyText=(EditText)findViewById(R.id.body);
  mImageView=(ImageView)findViewById(R.id.odata);
  mRowId=savedInstanceState != null ? savedInstanceState.getLong(NotesDbAdapter.KEY_ROWID) : null;
  if (mRowId == null) {
    Bundle extras=getIntent().getExtras();
    mRowId=extras != null ? extras.getLong(NotesDbAdapter.KEY_ROWID) : null;
    if (mRowId == 0)     mRowId=null;
  }
  populateFields();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mDbHelper=new NotesDbAdapter(this);
  String password=this.getIntent().getStringExtra(""String_Node_Str"");
  mDbHelper.open(password);
  mRowId=savedInstanceState != null ? savedInstanceState.getLong(NotesDbAdapter.KEY_ROWID) : null;
  if (mRowId == null) {
    Bundle extras=getIntent().getExtras();
    mRowId=extras != null ? extras.getLong(NotesDbAdapter.KEY_ROWID) : null;
    if (mRowId == 0)     mRowId=null;
  }
  populateFields();
}",0.8548895899053628
1533,"private void populateFields(){
  try {
    if (mRowId != null) {
      Cursor note=mDbHelper.fetchNote(mRowId);
      startManagingCursor(note);
      mTitleText.setText(note.getString(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_TITLE)));
      mBodyText.setText(note.getString(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_BODY)));
      byte[] blob=note.getBlob(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_DATA));
      if (blob != null) {
        BitmapFactory.Options bmpFactoryOptions=new BitmapFactory.Options();
        bmpFactoryOptions.inSampleSize=3;
        Bitmap blobb=BitmapFactory.decodeByteArray(blob,0,blob.length,bmpFactoryOptions);
        mImageView.setImageBitmap(blobb);
      }
    }
  }
 catch (  Exception e) {
    Log.e(""String_Node_Str"",""String_Node_Str"",e);
  }
}","private void populateFields(){
  try {
    if (mRowId != null) {
      Cursor note=mDbHelper.fetchNote(mRowId);
      startManagingCursor(note);
      byte[] blob=note.getBlob(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_DATA));
      setupView(blob != null);
      if (blob != null) {
        BitmapFactory.Options bmpFactoryOptions=new BitmapFactory.Options();
        bmpFactoryOptions.inSampleSize=3;
        Bitmap blobb=BitmapFactory.decodeByteArray(blob,0,blob.length,bmpFactoryOptions);
        mImageView.setImageBitmap(blobb);
      }
      mTitleText.setText(note.getString(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_TITLE)));
      mBodyText.setText(note.getString(note.getColumnIndexOrThrow(NotesDbAdapter.KEY_BODY)));
    }
 else     setupView(false);
  }
 catch (  Exception e) {
    Log.e(""String_Node_Str"",""String_Node_Str"",e);
  }
}",0.5178896300788357
1534,"private void saveState(){
  String title=mTitleText.getText().toString();
  String body=mBodyText.getText().toString();
  if (title != null && title.length() > 0) {
    if (mRowId == null) {
      long id=mDbHelper.createNote(title,body,null);
      if (id > 0) {
        mRowId=id;
      }
    }
 else {
      mDbHelper.updateNote(mRowId,title,body,null);
    }
  }
  mDbHelper.close();
}","private void saveState(){
  if (mTitleText != null && mTitleText.getText() != null) {
    String title=mTitleText.getText().toString();
    String body=mBodyText.getText().toString();
    if (title != null && title.length() > 0) {
      if (mRowId == null) {
        long id=mDbHelper.createNote(title,body,null,null);
        if (id > 0) {
          mRowId=id;
        }
      }
 else {
        mDbHelper.updateNote(mRowId,title,body,null,null);
      }
    }
    mDbHelper.close();
  }
}",0.6173120728929385
1535,"private void fillData(){
  Cursor notesCursor=mDbHelper.fetchAllNotes();
  startManagingCursor(notesCursor);
  String[] from=new String[]{NotesDbAdapter.KEY_TITLE};
  int[] to=new int[]{R.id.text1};
  SimpleCursorAdapter notes=new SimpleCursorAdapter(this,R.layout.notes_row,notesCursor,from,to);
  setListAdapter(notes);
}","private void fillData(){
  Cursor notesCursor=mDbHelper.fetchAllNotes();
  startManagingCursor(notesCursor);
  String[] from=new String[]{NotesDbAdapter.KEY_TITLE};
  int[] to=new int[]{R.id.text1};
  SimpleCursorAdapter notes=new SimpleCursorAdapter(this,R.layout.notes_row,notesCursor,from,to);
  setListAdapter(notes);
  if (notes.isEmpty()) {
    createNote();
  }
}",0.9321789321789322
1536,"private boolean savePublicImage(String title,byte[] outdata){
  File path=getExternalFilesDir(""String_Node_Str"");
  File file=new File(path,title + ""String_Node_Str"");
  try {
    path.mkdirs();
    InputStream is=new ByteArrayInputStream(outdata);
    OutputStream os=new FileOutputStream(file);
    byte[] data=new byte[is.available()];
    is.read(data);
    os.write(data);
    is.close();
    os.close();
    MediaScannerConnection.scanFile(this,new String[]{file.toString()},null,new MediaScannerConnection.OnScanCompletedListener(){
      public void onScanCompleted(      String path,      Uri uri){
        Log.i(""String_Node_Str"",""String_Node_Str"" + path + ""String_Node_Str"");
        Log.i(""String_Node_Str"",""String_Node_Str"" + uri);
        Intent intent=new Intent();
        intent.setAction(android.content.Intent.ACTION_VIEW);
        intent.setDataAndType(uri,""String_Node_Str"");
        startActivity(intent);
      }
    }
);
    MediaScannerConnection.scanFile(this,new String[]{path.toString()},null,new MediaScannerConnection.OnScanCompletedListener(){
      public void onScanCompleted(      String path,      Uri uri){
      }
    }
);
    return true;
  }
 catch (  IOException e) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + file,e);
    return false;
  }
}","private boolean savePublicImage(String title,byte[] outdata){
  File path=getExternalFilesDirEclair(""String_Node_Str"");
  File file=new File(path,title);
  try {
    path.mkdirs();
    InputStream is=new ByteArrayInputStream(outdata);
    OutputStream os=new FileOutputStream(file);
    byte[] data=new byte[is.available()];
    is.read(data);
    os.write(data);
    is.close();
    os.close();
    return true;
  }
 catch (  IOException e) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + file,e);
    return false;
  }
}",0.5717439293598234
1537,"@Override protected void onStop(){
  super.onStop();
  File file=new File(getExternalFilesDir(null),""String_Node_Str"");
  if (file.exists())   file.delete();
}","@Override protected void onStop(){
  super.onStop();
  File file=new File(getExternalFilesDirEclair(null),""String_Node_Str"");
  if (file.exists())   file.delete();
}",0.9814814814814816
1538,"private boolean saveTmpImage(byte[] outdata){
  File path=this.getExternalFilesDir(null);
  File file=new File(path,""String_Node_Str"");
  try {
    path.mkdirs();
    InputStream is=new ByteArrayInputStream(outdata);
    OutputStream os=new FileOutputStream(file);
    byte[] data=new byte[is.available()];
    is.read(data);
    os.write(data);
    is.close();
    os.close();
    tmpImageUri=Uri.fromFile(file);
    return true;
  }
 catch (  IOException e) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + file,e);
    return false;
  }
}","private boolean saveTmpImage(byte[] outdata){
  File path=getExternalFilesDirEclair(null);
  File file=new File(path,""String_Node_Str"");
  try {
    path.mkdirs();
    InputStream is=new ByteArrayInputStream(outdata);
    OutputStream os=new FileOutputStream(file);
    byte[] data=new byte[is.available()];
    is.read(data);
    os.write(data);
    is.close();
    os.close();
    tmpImageUri=Uri.fromFile(file);
    return true;
  }
 catch (  IOException e) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + file,e);
    return false;
  }
}",0.9898617511520738
1539,"/** 
 * Return a Cursor positioned at the note that matches the given rowId
 * @param rowId id of note to retrieve
 * @return Cursor positioned to matching note, if found
 * @throws SQLException if note could not be found/retrieved
 */
public Cursor fetchNote(long rowId) throws SQLException {
  Cursor mCursor=mDb.query(true,DATABASE_TABLE,new String[]{KEY_ROWID,KEY_TITLE,KEY_BODY,KEY_DATA},KEY_ROWID + ""String_Node_Str"" + rowId,null,null,null,null,null);
  if (mCursor != null) {
    mCursor.moveToFirst();
  }
  return mCursor;
}","/** 
 * Return a Cursor positioned at the note that matches the given rowId
 * @param rowId id of note to retrieve
 * @return Cursor positioned to matching note, if found
 * @throws SQLException if note could not be found/retrieved
 */
public Cursor fetchNote(long rowId) throws SQLException {
  Cursor mCursor=mDb.query(true,DATABASE_TABLE,new String[]{KEY_ROWID,KEY_TITLE,KEY_BODY,KEY_DATA,KEY_TYPE},KEY_ROWID + ""String_Node_Str"" + rowId,null,null,null,null,null);
  if (mCursor != null) {
    mCursor.moveToFirst();
  }
  return mCursor;
}",0.9916279069767442
1540,"/** 
 * Update the note using the details provided. The note to be updated is specified using the rowId, and it is altered to use the title and body values passed in
 * @param rowId id of note to update
 * @param title value to set note title to
 * @param body value to set note body to
 * @return true if the note was successfully updated, false otherwise
 */
public boolean updateNote(long rowId,String title,String body,byte[] data){
  ContentValues args=new ContentValues();
  args.put(KEY_TITLE,title);
  args.put(KEY_BODY,body);
  if (data != null)   args.put(KEY_DATA,data);
  return mDb.update(DATABASE_TABLE,args,KEY_ROWID + ""String_Node_Str"" + rowId,null) > 0;
}","/** 
 * Update the note using the details provided. The note to be updated is specified using the rowId, and it is altered to use the title and body values passed in
 * @param rowId id of note to update
 * @param title value to set note title to
 * @param body value to set note body to
 * @return true if the note was successfully updated, false otherwise
 */
public boolean updateNote(long rowId,String title,String body,byte[] data,String dataType){
  ContentValues args=new ContentValues();
  args.put(KEY_TITLE,title);
  args.put(KEY_BODY,body);
  if (data != null) {
    args.put(KEY_DATA,data);
    args.put(KEY_DATA,dataType);
  }
  return mDb.update(DATABASE_TABLE,args,KEY_ROWID + ""String_Node_Str"" + rowId,null) > 0;
}",0.9593147751605996
1541,"/** 
 * Create a new note using the title and body provided. If the note is successfully created return the new rowId for that note, otherwise return a -1 to indicate failure.
 * @param title the title of the note
 * @param body the body of the note
 * @return rowId or -1 if failed
 */
public long createNote(String title,String body,byte[] data){
  ContentValues initialValues=new ContentValues();
  initialValues.put(KEY_TITLE,title);
  initialValues.put(KEY_BODY,body);
  if (data != null)   initialValues.put(KEY_DATA,data);
  return mDb.insert(DATABASE_TABLE,null,initialValues);
}","/** 
 * Create a new note using the title and body provided. If the note is successfully created return the new rowId for that note, otherwise return a -1 to indicate failure.
 * @param title the title of the note
 * @param body the body of the note
 * @return rowId or -1 if failed
 */
public long createNote(String title,String body,byte[] data,String dataType){
  ContentValues initialValues=new ContentValues();
  initialValues.put(KEY_TITLE,title);
  initialValues.put(KEY_BODY,body);
  if (data != null) {
    initialValues.put(KEY_DATA,data);
    initialValues.put(KEY_TYPE,dataType);
  }
  return mDb.insert(DATABASE_TABLE,null,initialValues);
}",0.9467741935483872
1542,"public final void process(){
  processEntities(actives);
}","public final void process(){
  begin();
  processEntities(actives);
  end();
}",0.8529411764705882
1543,"@Override protected final void processEntities(ImmutableBag<Entity> entities,int accumulatedDelta){
  for (int i=0, s=entities.size(); s > i; i++) {
    Entity entity=entities.get(i);
    if (entity != null)     process(entity,accumulatedDelta);
  }
}","@Override protected final void processEntities(ImmutableBag<Entity> entities,int accumulatedDelta){
  for (int i=0, s=entities.size(); s > i; i++) {
    process(entities.get(i),accumulatedDelta);
  }
}",0.7743362831858407
1544,"protected Entity(World world,int id){
  this.entityManager=world.getEntityManager();
  this.id=id;
}","protected Entity(World world,int id){
  this.world=world;
  this.entityManager=world.getEntityManager();
  this.id=id;
}",0.9090909090909092
1545,"/** 
 * Refresh all changes to components for this entity. After adding or removing components, you must call this method. It will update all relevant systems. It is typical to call this after adding components to a newly created entity.
 */
public void refresh(){
  entityManager.refresh(this);
}","/** 
 * Refresh all changes to components for this entity. After adding or removing components, you must call this method. It will update all relevant systems. It is typical to call this after adding components to a newly created entity.
 */
public void refresh(){
  world.refreshEntity(this);
}",0.9324324324324323
1546,"@Override protected final void processEntities(ImmutableBag<Entity> entities){
  for (int i=0, s=entities.size(); s > i; i++) {
    Entity entity=entities.get(i);
    if (entity != null)     process(entity);
  }
}","@Override protected final void processEntities(ImmutableBag<Entity> entities){
  for (int i=0, s=entities.size(); s > i; i++) {
    process(entities.get(i));
  }
}",0.8297872340425532
1547,"@Override protected void processEntities(ImmutableBag<Entity> entities){
  for (int i=0, s=entities.size(); s > i; i++) {
    Entity entity=entities.get(i);
    if (entity != null)     process(entity);
  }
}","@Override protected void processEntities(ImmutableBag<Entity> entities){
  for (int i=0, s=entities.size(); s > i; i++) {
    process(entities.get(i));
  }
}",0.8241758241758241
1548,"public void deleteEntity(Entity e){
  groupManager.remove(e);
  entityManager.remove(e);
}","public void deleteEntity(Entity e){
  deleted.add(e);
}",0.6206896551724138
1549,"public World(){
  entityManager=new EntityManager(this);
  systemManager=new SystemManager(this);
  tagManager=new TagManager(this);
  groupManager=new GroupManager(this);
}","public World(){
  entityManager=new EntityManager(this);
  systemManager=new SystemManager(this);
  tagManager=new TagManager(this);
  groupManager=new GroupManager(this);
  refreshed=new Bag<Entity>();
  deleted=new Bag<Entity>();
}",0.8522167487684729
1550,"public ComponentMapper(Class<T> type,World world){
  this.em=world.getEntityManager();
  this.type=ComponentTypeManager.getTypeFor(type);
  this.classType=type;
}","public ComponentMapper(Class<T> type,World world){
  this.em=world.getEntityManager();
  this.type=ComponentTypeManager.getTypeFor(type,world);
  this.classType=type;
}",0.9818181818181818
1551,"public static final ComponentType getTypeFor(Class<? extends Component> c){
  ComponentType type=componentTypes.get(c);
  if (type == null) {
    type=new ComponentType();
    componentTypes.put(c,type);
  }
  return type;
}","public static final ComponentType getTypeFor(Class<? extends Component> c,World world){
  ComponentType type=componentTypes.get(c);
  if (type == null) {
    type=new ComponentType();
    componentTypes.put(c,type);
    world.getEntityManager().componentTypeAdded(type);
  }
  return type;
}",0.8699029126213592
1552,"public static int getId(Class<? extends Component> c){
  return getTypeFor(c).getId();
}","public static int getId(Class<? extends Component> c,World world){
  return getTypeFor(c,world).getId();
}",0.9072164948453608
1553,"public static long getBit(Class<? extends Component> c){
  return getTypeFor(c).getBit();
}","public static long getBit(Class<? extends Component> c,World world){
  return getTypeFor(c,world).getBit();
}",0.91
1554,"/** 
 * Slower retrieval of components from this entity. Minimize usage of this, but is fine to use e.g. when creating new entities and setting data in components.
 * @param < T > the expected return component type.
 * @param type the expected return component type.
 * @return component that matches, or null if none is found.
 */
public <T extends Component>T getComponent(Class<T> type){
  return type.cast(getComponent(ComponentTypeManager.getTypeFor(type)));
}","/** 
 * Slower retrieval of components from this entity. Minimize usage of this, but is fine to use e.g. when creating new entities and setting data in components.
 * @param < T > the expected return component type.
 * @param type the expected return component type.
 * @return component that matches, or null if none is found.
 */
public <T extends Component>T getComponent(Class<T> type){
  return type.cast(getComponent(ComponentTypeManager.getTypeFor(type,world)));
}",0.9935897435897436
1555,"protected void addComponent(Entity e,Component component){
  ComponentType type=ComponentTypeManager.getTypeFor(component.getClass());
  if (type.getId() >= componentsByType.getCapacity()) {
    componentsByType.set(type.getId(),null);
  }
  Bag<Component> components=componentsByType.get(type.getId());
  if (components == null) {
    components=new Bag<Component>();
    componentsByType.set(type.getId(),components);
  }
  components.set(e.getId(),component);
  e.addTypeBit(type.getBit());
}","protected void addComponent(Entity e,Component component){
  ComponentType type=ComponentTypeManager.getTypeFor(component.getClass(),world);
  if (type.getId() >= componentsByType.getCapacity()) {
    componentsByType.set(type.getId(),null);
  }
  Bag<Component> components=componentsByType.get(type.getId());
  if (components == null) {
    components=new Bag<Component>();
    componentsByType.set(type.getId(),components);
  }
  components.set(e.getId(),component);
  e.addTypeBit(type.getBit());
}",0.993975903614458
1556,"public EntitySystem(Class<? extends Component>... types){
  actives=new Bag<Entity>();
  for (  Class<? extends Component> type : types) {
    ComponentType ct=ComponentTypeManager.getTypeFor(type);
    typeFlags|=ct.getBit();
  }
}","public EntitySystem(Class<? extends Component>... types){
  actives=new Bag<Entity>();
  this.types=types;
}",0.6058823529411764
1557,"/** 
 * After adding all systems to the world, you must initialize them all.
 */
public void initializeAll(){
  for (int i=0; i < bagged.size(); i++) {
    bagged.get(i).initialize();
  }
}","/** 
 * After adding all systems to the world, you must initialize them all.
 */
public void initializeAll(){
  for (int i=0; i < bagged.size(); i++) {
    bagged.get(i).applyTypeFlags();
    bagged.get(i).initialize();
  }
}",0.9130434782608696
1558,"/** 
 * Set element at specified index in the bag.
 * @param index position of element
 * @param o the element
 */
public void set(int index,E o){
  if (index >= data.length) {
    grow(index * 2);
  }
  data[index]=o;
  size=index + 1;
}","/** 
 * Set element at specified index in the bag.
 * @param index position of element
 * @param o the element
 */
public void set(int index,E o){
  if (index >= data.length) {
    grow(index * 2);
    size=index + 1;
  }
 else   if (index >= size) {
    size=index + 1;
  }
  data[index]=o;
}",0.8286252354048964
1559,"protected Entity create(){
  Entity e=removedAndAvailable.removeLast();
  if (e == null) {
    e=new Entity(world,nextAvailableId++);
    activeEntities.add(e);
  }
 else {
    activeEntities.set(e.getId(),e);
    e.reset();
  }
  count++;
  totalCreated++;
  return e;
}","protected Entity create(){
  Entity e=removedAndAvailable.removeLast();
  if (e == null) {
    e=new Entity(world,nextAvailableId++);
  }
 else {
    e.reset();
  }
  activeEntities.set(e.getId(),e);
  count++;
  totalCreated++;
  return e;
}",0.7251461988304093
1560,"protected void remove(Entity e){
  activeEntities.set(e.getId(),null);
  removedAndAvailable.add(e);
  e.setTypeBits(0);
  refresh(e);
  count--;
  totalRemoved++;
}","protected void remove(Entity e){
  activeEntities.set(e.getId(),null);
  e.setTypeBits(0);
  refresh(e);
  count--;
  totalRemoved++;
  removedAndAvailable.add(e);
}",0.8181818181818182
1561,"private void remove(Entity e){
  if ((systemBit & e.getSystemBits()) == systemBit) {
    actives.remove(e);
    e.removeSystemBit(systemBit);
    removed(e);
  }
}","private void remove(Entity e){
  actives.remove(e);
  e.removeSystemBit(systemBit);
  removed(e);
}",0.7557251908396947
1562,"public void deleteEntity(Entity e){
  entityManager.remove(e);
  groupManager.remove(e);
}","public void deleteEntity(Entity e){
  groupManager.remove(e);
  entityManager.remove(e);
}",0.7111111111111111
1563,"public void remove(Entity e){
  if (e.getId() < groupByEntity.size()) {
    String group=groupByEntity.get(e.getId());
    if (group != null) {
      groupByEntity.set(e.getId(),null);
      Bag<Entity> entities=entitiesByGroup.get(group);
      if (entities != null) {
        entities.remove(e);
      }
    }
  }
}","public void remove(Entity e){
  if (e.getId() < groupByEntity.getCapacity()) {
    String group=groupByEntity.get(e.getId());
    if (group != null) {
      groupByEntity.set(e.getId(),null);
      Bag<Entity> entities=entitiesByGroup.get(group);
      if (entities != null) {
        entities.remove(e);
      }
    }
  }
}",0.9765990639625584
1564,"/** 
 * Converts a list of arguments into points.
 * @param original The original string necessary to convert inside of.
 * @param arguments The list of arguments, multiple arguments are seperated by commas for a single point.
 * @param points The point used to alter the argument.
 * @return <code>String</code> - The parsed string after converting arguments to variables (points)
 */
public static String argument(String original,Object[] arguments,Object[] points){
  for (int i=0; i < arguments.length; i++) {
    if (String.valueOf(arguments[i]).contains(""String_Node_Str"")) {
      for (      String arg : String.valueOf(arguments[i]).split(""String_Node_Str"")) {
        original=original.replace(arg,String.valueOf(points[i]));
      }
    }
 else {
      original=original.replace(String.valueOf(arguments[i]),String.valueOf(points[i]));
    }
  }
  return original;
}","/** 
 * Converts a list of arguments into points.
 * @param original The original string necessary to convert inside of.
 * @param arguments The list of arguments, multiple arguments are seperated by commas for a single point.
 * @param points The point used to alter the argument.
 * @return <code>String</code> - The parsed string after converting arguments to variables (points)
 */
public static String argument(String original,Object[] arguments,Object[] points){
  if (arguments.length < 1)   return original;
  for (int i=0; i < arguments.length; i++) {
    if (String.valueOf(arguments[i]).contains(""String_Node_Str"")) {
      for (      String arg : String.valueOf(arguments[i]).split(""String_Node_Str"")) {
        original=original.replace(arg,String.valueOf(points[i]));
      }
    }
 else {
      original=original.replace(String.valueOf(arguments[i]),String.valueOf(points[i]));
    }
  }
  return original;
}",0.9738743746525848
1565,"public void showBalance(CommandSender to){
  if (to != null) {
    String tag=iConomy.Template.raw(Template.Node.TAG_MONEY);
    Template template=iConomy.Template;
    template.set(Template.Node.PLAYER_BALANCE);
    template.add(""String_Node_Str"",name);
    template.add(""String_Node_Str"",toString());
    Messaging.send(to,tag + template.parse());
  }
  Player player=iConomy.Server.getPlayer(name);
  if (iConomy.Server.getPlayer(name) == null)   return;
  String tag=iConomy.Template.color(Template.Node.TAG_MONEY);
  Template template=iConomy.Template;
  template.set(Template.Node.PERSONAL_BALANCE);
  template.add(""String_Node_Str"",toString());
  Messaging.send(player,tag + template.parse());
}","public void showBalance(CommandSender to){
  if (to != null) {
    String tag=iConomy.Template.raw(Template.Node.TAG_MONEY);
    Template template=iConomy.Template;
    template.set(Template.Node.PLAYER_BALANCE);
    template.add(""String_Node_Str"",name);
    template.add(""String_Node_Str"",toString());
    Messaging.send(to,tag + template.parse());
    return;
  }
  Player player=iConomy.Server.getPlayer(name);
  String tag=iConomy.Template.color(Template.Node.TAG_MONEY);
  if (iConomy.Server.getPlayer(name) == null)   return;
  Template template=iConomy.Template;
  template.set(Template.Node.PERSONAL_BALANCE);
  template.add(""String_Node_Str"",toString());
  Messaging.send(player,tag + template.parse());
}",0.903954802259887
1566,"static List<Account> topAccounts(int amount){
  Accounts Accounts=new Accounts();
  List<Account> accounts=new ArrayList<Account>();
  List<Account> finals=new ArrayList<Account>();
  List<String> total=new ArrayList<String>();
  if (useMiniDB() || useInventoryDB() || useOrbDB()) {
    if (useInventoryDB())     total.addAll(inventory.getAllPlayers());
    if (useOrbDB())     for (    Player p : iConomy.Server.getOnlinePlayers())     total.add(p.getName());
    total.addAll(database.getIndices().keySet());
  }
 else {
    try {
      QueryRunner run=new QueryRunner();
      Connection c=iConomy.Database.getConnection();
      try {
        String t=Constants.Nodes.DatabaseTable.toString();
        total=run.query(c,""String_Node_Str"" + t,returnList);
      }
 catch (      SQLException ex) {
        System.out.println(""String_Node_Str"" + ex);
      }
 finally {
        DbUtils.close(c);
      }
    }
 catch (    SQLException ex) {
      System.out.println(""String_Node_Str"" + ex);
    }
  }
  for (Iterator<String> it=total.iterator(); it.hasNext(); ) {
    String player=it.next();
    accounts.add(Accounts.get(player));
  }
  Collections.sort(accounts,new MoneyComparator());
  if (amount > accounts.size())   amount=accounts.size();
  for (int i=0; i < amount; i++) {
    if (accounts.get(i).getStatus() == 1) {
      i--;
      continue;
    }
    finals.add(accounts.get(i));
  }
  return finals;
}","static List<Account> topAccounts(int amount){
  Accounts Accounts=new Accounts();
  List<Account> accounts=new ArrayList<Account>();
  List<Account> finals=new ArrayList<Account>();
  List<String> total=new ArrayList<String>();
  if (useMiniDB() || useInventoryDB() || useOrbDB()) {
    if (useInventoryDB())     total.addAll(inventory.getAllPlayers());
    if (useOrbDB())     for (    Player p : iConomy.Server.getOnlinePlayers())     total.add(p.getName());
    total.addAll(database.getIndices().keySet());
  }
 else {
    try {
      QueryRunner run=new QueryRunner();
      Connection c=iConomy.Database.getConnection();
      try {
        String t=Constants.Nodes.DatabaseTable.toString();
        total=run.query(c,""String_Node_Str"" + t + ""String_Node_Str""+ amount,returnList);
      }
 catch (      SQLException ex) {
        System.out.println(""String_Node_Str"" + ex);
      }
 finally {
        DbUtils.close(c);
      }
    }
 catch (    SQLException ex) {
      System.out.println(""String_Node_Str"" + ex);
    }
  }
  for (Iterator<String> it=total.iterator(); it.hasNext(); ) {
    String player=it.next();
    if (useMiniDB() || useInventoryDB() || useOrbDB()) {
      accounts.add(Accounts.get(player));
    }
 else {
      finals.add(new Account(player));
    }
  }
  if (useMiniDB() || useInventoryDB() || useOrbDB()) {
    Collections.sort(accounts,new MoneyComparator());
    if (amount > accounts.size())     amount=accounts.size();
    for (int i=0; i < amount; i++) {
      if (accounts.get(i).getStatus() == 1) {
        i--;
        continue;
      }
      finals.add(accounts.get(i));
    }
  }
  return finals;
}",0.9198036006546644
1567,"public void onEnable(){
  final long startTime=System.nanoTime();
  final long endTime;
  try {
    Locale.setDefault(Locale.US);
    Server=getServer();
    TerminalSupport=((CraftServer)getServer()).getReader().getTerminal().isANSISupported();
    info=getDescription();
    directory=getDataFolder();
    if (!directory.exists())     directory.mkdir();
    Common.extract(""String_Node_Str"",""String_Node_Str"");
    Constants.load(new Configuration(new File(directory,""String_Node_Str"")));
    Template=new Template(directory.getPath(),""String_Node_Str"");
    Type type=Database.getType(Constants.Nodes.DatabaseType.toString());
    if (!(type.equals(Type.InventoryDB) || type.equals(Type.MiniDB))) {
      Drivers driver=null;
switch (type) {
case H2DB:
        driver=Constants.Drivers.H2;
      break;
case MySQL:
    driver=Constants.Drivers.MySQL;
  break;
case SQLite:
driver=Constants.Drivers.SQLite;
break;
case Postgre:
driver=Constants.Drivers.Postgre;
break;
}
if (driver != null) if (!(new File(""String_Node_Str"",driver.getFilename()).exists())) {
System.out.println(""String_Node_Str"" + driver.getFilename() + ""String_Node_Str"");
wget.fetch(driver.getUrl(),driver.getFilename());
System.out.println(""String_Node_Str"");
}
}
Commands.add(""String_Node_Str"",new Money(this));
Commands.add(""String_Node_Str"",new Create(this));
Commands.add(""String_Node_Str"",new Remove(this));
Commands.add(""String_Node_Str"",new Give(this));
Commands.add(""String_Node_Str"",new Take(this));
Commands.add(""String_Node_Str"",new Set(this));
try {
Database=new Database(Constants.Nodes.DatabaseType.toString(),Constants.Nodes.DatabaseUrl.toString(),Constants.Nodes.DatabaseUsername.toString(),Constants.Nodes.DatabasePassword.toString());
if (Database.getDatabase() == null) if (!Database.tableExists(Constants.Nodes.DatabaseTable.toString())) {
System.out.println(""String_Node_Str"");
String SQL=Common.resourceToString(""String_Node_Str"" + Database.getType().toString().toLowerCase() + ""String_Node_Str"");
SQL=String.format(SQL,Constants.Nodes.DatabaseTable.getValue());
try {
QueryRunner run=new QueryRunner();
Connection c=iConomy.Database.getConnection();
try {
run.update(c,SQL);
}
 catch (SQLException ex) {
System.out.println(""String_Node_Str"" + ex);
}
 finally {
DbUtils.close(c);
}
}
 catch (SQLException ex) {
System.out.println(""String_Node_Str"" + ex);
}
}
}
 catch (MissingDriver ex) {
System.out.println(ex.getMessage());
}
String name=""String_Node_Str"";
System.out.println(name + ""String_Node_Str"" + Accounts.exists(name));
Account Nijikokun=Accounts.get(name);
Holdings holdings=Nijikokun.getHoldings();
System.out.println(""String_Node_Str"" + holdings.getBalance());
}
  finally {
endTime=System.nanoTime();
}
final long duration=endTime - startTime;
System.out.println(""String_Node_Str"" + info.getName() + ""String_Node_Str""+ Common.readableProfile(duration)+ ""String_Node_Str"");
}","public void onEnable(){
  final long startTime=System.nanoTime();
  final long endTime;
  try {
    Locale.setDefault(Locale.US);
    Server=getServer();
    TerminalSupport=((CraftServer)getServer()).getReader().getTerminal().isANSISupported();
    info=getDescription();
    directory=getDataFolder();
    if (!directory.exists())     directory.mkdir();
    Common.extract(""String_Node_Str"",""String_Node_Str"");
    Constants.load(new Configuration(new File(directory,""String_Node_Str"")));
    Template=new Template(directory.getPath(),""String_Node_Str"");
    Type type=Database.getType(Constants.Nodes.DatabaseType.toString());
    if (!(type.equals(Type.InventoryDB) || type.equals(Type.MiniDB))) {
      Drivers driver=null;
switch (type) {
case H2DB:
        driver=Constants.Drivers.H2;
      break;
case MySQL:
    driver=Constants.Drivers.MySQL;
  break;
case SQLite:
driver=Constants.Drivers.SQLite;
break;
case Postgre:
driver=Constants.Drivers.Postgre;
break;
}
if (driver != null) if (!(new File(""String_Node_Str"",driver.getFilename()).exists())) {
System.out.println(""String_Node_Str"" + driver.getFilename() + ""String_Node_Str"");
wget.fetch(driver.getUrl(),driver.getFilename());
System.out.println(""String_Node_Str"");
}
}
Commands.add(""String_Node_Str"",new Money(this));
Commands.add(""String_Node_Str"",new Create(this));
Commands.add(""String_Node_Str"",new Remove(this));
Commands.add(""String_Node_Str"",new Give(this));
Commands.add(""String_Node_Str"",new Take(this));
Commands.add(""String_Node_Str"",new Set(this));
try {
Database=new Database(Constants.Nodes.DatabaseType.toString(),Constants.Nodes.DatabaseUrl.toString(),Constants.Nodes.DatabaseUsername.toString(),Constants.Nodes.DatabasePassword.toString());
if (Database.getDatabase() == null && Database.getInventoryDatabase() == null) if (!Database.tableExists(Constants.Nodes.DatabaseTable.toString())) {
System.out.println(""String_Node_Str"");
String SQL=Common.resourceToString(""String_Node_Str"" + Database.getType().toString().toLowerCase() + ""String_Node_Str"");
SQL=String.format(SQL,Constants.Nodes.DatabaseTable.getValue());
try {
QueryRunner run=new QueryRunner();
Connection c=iConomy.Database.getConnection();
try {
run.update(c,SQL);
}
 catch (SQLException ex) {
System.out.println(""String_Node_Str"" + ex);
}
 finally {
DbUtils.close(c);
}
}
 catch (SQLException ex) {
System.out.println(""String_Node_Str"" + ex);
}
}
}
 catch (MissingDriver ex) {
System.out.println(ex.getMessage());
}
String name=""String_Node_Str"";
System.out.println(name + ""String_Node_Str"" + Accounts.exists(name));
Account Nijikokun=Accounts.get(name);
Holdings holdings=Nijikokun.getHoldings();
System.out.println(""String_Node_Str"" + holdings.getBalance());
}
  finally {
endTime=System.nanoTime();
}
final long duration=endTime - startTime;
System.out.println(""String_Node_Str"" + info.getName() + ""String_Node_Str""+ Common.readableProfile(duration)+ ""String_Node_Str"");
}",0.9925925925925926
1568,"@Override public boolean perform(CommandSender sender,LinkedHashMap<String,Argument> arguments) throws InvalidUsage {
  String name=arguments.get(""String_Node_Str"").getStringValue();
  String tag=template.color(Template.Node.TAG_MONEY);
  Double amount;
  if (name.equals(""String_Node_Str""))   throw new InvalidUsage(""String_Node_Str"");
  if (arguments.get(""String_Node_Str"").getStringValue().equals(""String_Node_Str""))   throw new InvalidUsage(""String_Node_Str"");
  try {
    amount=arguments.get(""String_Node_Str"").getDoubleValue();
  }
 catch (  NumberFormatException e) {
    throw new InvalidUsage(""String_Node_Str"");
  }
  if (Double.isInfinite(amount) || Double.isNaN(amount))   throw new InvalidUsage(""String_Node_Str"");
  if (!Accounts.exists(name)) {
    template.set(Template.Node.ERROR_ACCOUNT);
    template.add(""String_Node_Str"",name);
    Messaging.send(sender,tag + template.parse());
    return false;
  }
  Account account=new Account(name);
  account.getHoldings().add(amount);
  template.set(Template.Node.PLAYER_CREDIT);
  template.add(""String_Node_Str"",name);
  template.add(""String_Node_Str"",account.getHoldings().toString());
  Messaging.send(sender,tag + template.parse());
  return false;
}","@Override public boolean perform(CommandSender sender,LinkedHashMap<String,Argument> arguments) throws InvalidUsage {
  String name=arguments.get(""String_Node_Str"").getStringValue();
  String tag=template.color(Template.Node.TAG_MONEY);
  Double amount;
  if (name.equals(""String_Node_Str""))   throw new InvalidUsage(""String_Node_Str"");
  if (arguments.get(""String_Node_Str"").getStringValue().equals(""String_Node_Str""))   throw new InvalidUsage(""String_Node_Str"");
  try {
    amount=arguments.get(""String_Node_Str"").getDoubleValue();
  }
 catch (  NumberFormatException e) {
    throw new InvalidUsage(""String_Node_Str"");
  }
  if (Double.isInfinite(amount) || Double.isNaN(amount))   throw new InvalidUsage(""String_Node_Str"");
  if (!Accounts.exists(name)) {
    template.set(Template.Node.ERROR_ACCOUNT);
    template.add(""String_Node_Str"",name);
    Messaging.send(sender,tag + template.parse());
    return false;
  }
  Account account=new Account(name);
  account.getHoldings().add(amount);
  template.set(Template.Node.PLAYER_CREDIT);
  template.add(""String_Node_Str"",name);
  template.add(""String_Node_Str"",iConomy.format(amount));
  Messaging.send(sender,tag + template.parse());
  return false;
}",0.9785301403798512
1569,"@Override public boolean perform(CommandSender sender,LinkedHashMap<String,Argument> arguments) throws InvalidUsage {
  String name=arguments.get(""String_Node_Str"").getStringValue();
  String tag=template.color(Template.Node.TAG_MONEY);
  Double amount;
  if (name.equals(""String_Node_Str""))   throw new InvalidUsage(""String_Node_Str"");
  if (arguments.get(""String_Node_Str"").getStringValue().equals(""String_Node_Str""))   throw new InvalidUsage(""String_Node_Str"");
  try {
    amount=arguments.get(""String_Node_Str"").getDoubleValue();
  }
 catch (  NumberFormatException e) {
    throw new InvalidUsage(""String_Node_Str"");
  }
  if (Double.isInfinite(amount) || Double.isNaN(amount))   throw new InvalidUsage(""String_Node_Str"");
  if (!Accounts.exists(name)) {
    template.set(Template.Node.ERROR_ACCOUNT);
    template.add(""String_Node_Str"",name);
    Messaging.send(sender,tag + template.parse());
    return false;
  }
  Account account=new Account(name);
  account.getHoldings().subtract(amount);
  template.set(Template.Node.PLAYER_DEBIT);
  template.add(""String_Node_Str"",name);
  template.add(""String_Node_Str"",account.getHoldings().toString());
  Messaging.send(sender,tag + template.parse());
  return false;
}","@Override public boolean perform(CommandSender sender,LinkedHashMap<String,Argument> arguments) throws InvalidUsage {
  String name=arguments.get(""String_Node_Str"").getStringValue();
  String tag=template.color(Template.Node.TAG_MONEY);
  Double amount;
  if (name.equals(""String_Node_Str""))   throw new InvalidUsage(""String_Node_Str"");
  if (arguments.get(""String_Node_Str"").getStringValue().equals(""String_Node_Str""))   throw new InvalidUsage(""String_Node_Str"");
  try {
    amount=arguments.get(""String_Node_Str"").getDoubleValue();
  }
 catch (  NumberFormatException e) {
    throw new InvalidUsage(""String_Node_Str"");
  }
  if (Double.isInfinite(amount) || Double.isNaN(amount))   throw new InvalidUsage(""String_Node_Str"");
  if (!Accounts.exists(name)) {
    template.set(Template.Node.ERROR_ACCOUNT);
    template.add(""String_Node_Str"",name);
    Messaging.send(sender,tag + template.parse());
    return false;
  }
  Account account=new Account(name);
  account.getHoldings().subtract(amount);
  template.set(Template.Node.PLAYER_DEBIT);
  template.add(""String_Node_Str"",name);
  template.add(""String_Node_Str"",iConomy.format(amount));
  Messaging.send(sender,tag + template.parse());
  return false;
}",0.9786008230452676
1570,"public void showBalance(CommandSender to){
  if (to != null) {
    String tag=iConomy.Template.raw(Template.Node.TAG_MONEY);
    Template template=iConomy.Template;
    template.set(Template.Node.PLAYER_BALANCE);
    template.add(""String_Node_Str"",name);
    template.add(""String_Node_Str"",getBalance());
    Messaging.send(to,tag + template.parse());
  }
  Player player=iConomy.Server.getPlayer(name);
  if (iConomy.Server.getPlayer(name) == null)   return;
  String tag=iConomy.Template.color(Template.Node.TAG_MONEY);
  Template template=iConomy.Template;
  template.set(Template.Node.PERSONAL_BALANCE);
  template.add(""String_Node_Str"",getBalance());
  Messaging.send(player,tag + template.parse());
}","public void showBalance(CommandSender to){
  if (to != null) {
    String tag=iConomy.Template.raw(Template.Node.TAG_MONEY);
    Template template=iConomy.Template;
    template.set(Template.Node.PLAYER_BALANCE);
    template.add(""String_Node_Str"",name);
    template.add(""String_Node_Str"",toString());
    Messaging.send(to,tag + template.parse());
  }
  Player player=iConomy.Server.getPlayer(name);
  if (iConomy.Server.getPlayer(name) == null)   return;
  String tag=iConomy.Template.color(Template.Node.TAG_MONEY);
  Template template=iConomy.Template;
  template.set(Template.Node.PERSONAL_BALANCE);
  template.add(""String_Node_Str"",toString());
  Messaging.send(player,tag + template.parse());
}",0.9744318181818182
1571,"static void setBalance(String name,double balance){
  if (!hasAccount(name)) {
    createAccount(name,balance,0);
    return;
  }
  if (useMiniDB() || useInventoryDB() || useOrbDB()) {
    if (useInventoryDB())     if (inventory.dataExists(name)) {
      inventory.setBalance(name,balance);
      return;
    }
    if (useOrbDB()) {
      Player gainer=iConomy.Server.getPlayer(name);
      if (gainer != null) {
        for (int i=0; i < balance; i++)         gainer.setExperience(i);
        return;
      }
    }
    if (database.hasIndex(name)) {
      database.setArgument(name,""String_Node_Str"",balance);
      database.update();
    }
    return;
  }
  try {
    QueryRunner run=new QueryRunner();
    Connection c=iConomy.Database.getConnection();
    try {
      String t=Constants.Nodes.DatabaseTable.toString();
      int update=run.update(c,""String_Node_Str"" + t + ""String_Node_Str"",balance,name.toLowerCase());
    }
 catch (    SQLException ex) {
      System.out.println(""String_Node_Str"" + ex);
    }
 finally {
      DbUtils.close(c);
    }
  }
 catch (  SQLException ex) {
    System.out.println(""String_Node_Str"" + ex);
  }
}","static void setBalance(String name,double balance){
  if (!hasAccount(name)) {
    createAccount(name,balance,0);
    return;
  }
  if (useMiniDB() || useInventoryDB() || useOrbDB()) {
    if (useInventoryDB())     if (inventory.dataExists(name)) {
      inventory.setBalance(name,balance);
      return;
    }
    if (useOrbDB()) {
      Player gainer=iConomy.Server.getPlayer(name);
      if (gainer != null) {
        gainer.setTotalExperience((int)balance);
        return;
      }
    }
    if (database.hasIndex(name)) {
      database.setArgument(name,""String_Node_Str"",balance);
      database.update();
    }
    return;
  }
  try {
    QueryRunner run=new QueryRunner();
    Connection c=iConomy.Database.getConnection();
    try {
      String t=Constants.Nodes.DatabaseTable.toString();
      int update=run.update(c,""String_Node_Str"" + t + ""String_Node_Str"",balance,name.toLowerCase());
    }
 catch (    SQLException ex) {
      System.out.println(""String_Node_Str"" + ex);
    }
 finally {
      DbUtils.close(c);
    }
  }
 catch (  SQLException ex) {
    System.out.println(""String_Node_Str"" + ex);
  }
}",0.965547703180212
1572,"@Override public boolean perform(CommandSender sender,LinkedHashMap<String,Argument> arguments) throws InvalidUsage {
  if (!hasPermissions(sender,""String_Node_Str""))   throw new InvalidUsage(""String_Node_Str"");
  String name=arguments.get(""String_Node_Str"").getStringValue();
  String tag=template.color(Template.Node.TAG_MONEY);
  boolean self=false;
  if (!isConsole(sender))   if (((Player)sender).getName().equalsIgnoreCase(name))   self=true;
  if (name.equals(""String_Node_Str""))   throw new InvalidUsage(""String_Node_Str"");
  if (!Accounts.exists(name)) {
    template.set(Template.Node.ERROR_ACCOUNT);
    template.add(""String_Node_Str"",name);
    Messaging.send(sender,tag + template.parse());
    return false;
  }
  Account account=new Account(name);
  if (arguments.get(""String_Node_Str"").getStringValue().equalsIgnoreCase(""String_Node_Str"")) {
    int current=account.getStatus();
    if (self)     template.set(Template.Node.PERSONAL_STATUS);
 else {
      template.set(Template.Node.PLAYER_STATUS);
      template.add(""String_Node_Str"",name);
    }
    Messaging.send(sender,tag + template.parse());
    return false;
  }
  if (!hasPermissions(sender,""String_Node_Str""))   throw new InvalidUsage(""String_Node_Str"");
  int status=arguments.get(""String_Node_Str"").getIntegerValue();
  account.setStatus(status);
  template.set(Template.Node.ACCOUNTS_STATUS);
  template.add(""String_Node_Str"",status);
  Messaging.send(sender,tag + template.parse());
  return false;
}","@Override public boolean perform(CommandSender sender,LinkedHashMap<String,Argument> arguments) throws InvalidUsage {
  if (!hasPermissions(sender,""String_Node_Str""))   throw new InvalidUsage(""String_Node_Str"");
  String name=arguments.get(""String_Node_Str"").getStringValue();
  String tag=template.color(Template.Node.TAG_MONEY);
  boolean self=false;
  if (!isConsole(sender))   if (((Player)sender).getName().equalsIgnoreCase(name))   self=true;
  if (name.equals(""String_Node_Str""))   throw new InvalidUsage(""String_Node_Str"");
  if (!Accounts.exists(name)) {
    template.set(Template.Node.ERROR_ACCOUNT);
    template.add(""String_Node_Str"",name);
    Messaging.send(sender,tag + template.parse());
    return false;
  }
  Account account=new Account(name);
  if (arguments.get(""String_Node_Str"").getStringValue().equalsIgnoreCase(""String_Node_Str"")) {
    int current=account.getStatus();
    if (self)     template.set(Template.Node.PERSONAL_STATUS);
 else {
      template.set(Template.Node.PLAYER_STATUS);
      template.add(""String_Node_Str"",name);
    }
    template.add(""String_Node_Str"",current);
    Messaging.send(sender,tag + template.parse());
  }
 else {
    if (!hasPermissions(sender,""String_Node_Str""))     throw new InvalidUsage(""String_Node_Str"");
    int status=arguments.get(""String_Node_Str"").getIntegerValue();
    account.setStatus(status);
    template.set(Template.Node.ACCOUNTS_STATUS);
    template.add(""String_Node_Str"",status);
    Messaging.send(sender,tag + template.parse());
  }
  return false;
}",0.970480928689884
1573,"public InventoryDB(){
  server=Bukkit.getServer();
  dataDir=new File(server.getWorlds().get(0).getName(),""String_Node_Str"");
}","public InventoryDB(){
  dataDir=new File(iConomy.Server.getWorlds().get(0).getName(),""String_Node_Str"");
}",0.8326180257510729
1574,"private void writeInventory(String name,ItemStack[] stacks){
  try {
    NBTInputStream in=new NBTInputStream(new FileInputStream(new File(dataDir,name + ""String_Node_Str"")));
    CompoundTag tag=(CompoundTag)in.readTag();
    in.close();
    ListTag inventory=(ListTag)tag.getValue().get(""String_Node_Str"");
    inventory.getValue().clear();
    for (int i=0; i < stacks.length; ++i) {
      if (stacks[i] == null)       continue;
      ByteTag count=new ByteTag(""String_Node_Str"",(byte)stacks[i].getAmount());
      ByteTag slot=new ByteTag(""String_Node_Str"",(byte)i);
      ShortTag damage=new ShortTag(""String_Node_Str"",stacks[i].getDurability());
      ShortTag id=new ShortTag(""String_Node_Str"",(short)stacks[i].getTypeId());
      HashMap<String,Tag> tagMap=new HashMap<String,Tag>();
      tagMap.put(""String_Node_Str"",count);
      tagMap.put(""String_Node_Str"",slot);
      tagMap.put(""String_Node_Str"",damage);
      tagMap.put(""String_Node_Str"",id);
      inventory.getValue().add(new CompoundTag(""String_Node_Str"",tagMap));
    }
    NBTOutputStream out=new NBTOutputStream(new FileOutputStream(new File(dataDir,name + ""String_Node_Str"")));
    out.writeTag(tag);
  }
 catch (  IOException ex) {
  }
}","private void writeInventory(String name,ItemStack[] stacks){
  try {
    NBTInputStream in=new NBTInputStream(new FileInputStream(new File(dataDir,name + ""String_Node_Str"")));
    CompoundTag tag=(CompoundTag)in.readTag();
    in.close();
    ArrayList tagList=new ArrayList<Tag>();
    for (int i=0; i < stacks.length; ++i) {
      if (stacks[i] == null)       continue;
      ByteTag count=new ByteTag(""String_Node_Str"",(byte)stacks[i].getAmount());
      ByteTag slot=new ByteTag(""String_Node_Str"",(byte)i);
      ShortTag damage=new ShortTag(""String_Node_Str"",stacks[i].getDurability());
      ShortTag id=new ShortTag(""String_Node_Str"",(short)stacks[i].getTypeId());
      HashMap<String,Tag> tagMap=new HashMap<String,Tag>();
      tagMap.put(""String_Node_Str"",count);
      tagMap.put(""String_Node_Str"",slot);
      tagMap.put(""String_Node_Str"",damage);
      tagMap.put(""String_Node_Str"",id);
      tagList.add(new CompoundTag(""String_Node_Str"",tagMap));
    }
    ListTag inventory=new ListTag(""String_Node_Str"",CompoundTag.class,tagList);
    HashMap<String,Tag> tagCompound=new HashMap<String,Tag>(tag.getValue());
    tagCompound.put(""String_Node_Str"",inventory);
    tag=new CompoundTag(""String_Node_Str"",tagCompound);
    NBTOutputStream out=new NBTOutputStream(new FileOutputStream(new File(dataDir,name + ""String_Node_Str"")));
    out.writeTag(tag);
    out.close();
  }
 catch (  IOException ex) {
    iConomy.Server.getLogger().warning(""String_Node_Str"" + name + ""String_Node_Str""+ ex.getMessage());
  }
}",0.2675438596491228
1575,"private void setBalance(ItemStack[] contents,double balance){
  int major=Constants.Nodes.DatabaseMajorItem.getInteger();
  int minor=Constants.Nodes.DatabaseMinorItem.getInteger();
  for (int i=0; i < contents.length; ++i) {
    ItemStack item=contents[i];
    if (item != null) {
      if (item.getTypeId() == major || item.getTypeId() == minor) {
        contents[i]=null;
      }
    }
  }
  for (int i=0; i < contents.length; ++i) {
    if (contents[i] == null) {
      if (balance >= 1) {
        int add=(int)balance;
        if (add > Material.getMaterial(major).getMaxStackSize()) {
          add=Material.getMaterial(major).getMaxStackSize();
        }
        contents[i]=new ItemStack(major,add);
        balance-=add;
      }
 else       if (balance > 0) {
        int add=(int)((balance - (int)balance) * 100);
        if (add > Material.getMaterial(minor).getMaxStackSize()) {
          add=Material.getMaterial(minor).getMaxStackSize();
        }
        contents[i]=new ItemStack(minor,add);
        balance=0;
        break;
      }
    }
  }
}","private void setBalance(ItemStack[] contents,double balance){
  int major=Constants.Nodes.DatabaseMajorItem.getInteger();
  int minor=Constants.Nodes.DatabaseMinorItem.getInteger();
  for (int i=0; i < contents.length; ++i) {
    ItemStack item=contents[i];
    if (item != null) {
      if (item.getTypeId() == major || item.getTypeId() == minor) {
        contents[i]=null;
      }
    }
  }
  for (int i=0; i < contents.length; ++i) {
    if (contents[i] == null) {
      if (balance >= 1) {
        int add=(int)balance;
        if (add > Material.getMaterial(major).getMaxStackSize()) {
          add=Material.getMaterial(major).getMaxStackSize();
        }
        contents[i]=new ItemStack(major,add);
        balance-=add;
      }
 else       if (balance > 0) {
        int add=(int)((balance - (int)balance) * 100);
        if (add > Material.getMaterial(minor).getMaxStackSize()) {
          add=Material.getMaterial(minor).getMaxStackSize();
        }
        contents[i]=new ItemStack(minor,add);
        balance=0;
        break;
      }
    }
  }
  if (balance > 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.9654545454545456
1576,"private ItemStack[] readInventory(String name){
  try {
    NBTInputStream in=new NBTInputStream(new FileInputStream(new File(dataDir,name + ""String_Node_Str"")));
    CompoundTag tag=(CompoundTag)in.readTag();
    in.close();
    ListTag inventory=(ListTag)tag.getValue().get(""String_Node_Str"");
    ItemStack[] stacks=new ItemStack[40];
    for (int i=0; i < inventory.getValue().size(); ++i) {
      CompoundTag item=(CompoundTag)inventory.getValue().get(i);
      byte count=((ByteTag)item.getValue().get(""String_Node_Str"")).getValue();
      byte slot=((ByteTag)item.getValue().get(""String_Node_Str"")).getValue();
      short damage=((ShortTag)item.getValue().get(""String_Node_Str"")).getValue();
      short id=((ShortTag)item.getValue().get(""String_Node_Str"")).getValue();
      stacks[slot]=new ItemStack(id,damage,count);
    }
    return stacks;
  }
 catch (  IOException ex) {
    return null;
  }
}","private ItemStack[] readInventory(String name){
  try {
    NBTInputStream in=new NBTInputStream(new FileInputStream(new File(dataDir,name + ""String_Node_Str"")));
    CompoundTag tag=(CompoundTag)in.readTag();
    in.close();
    ListTag inventory=(ListTag)tag.getValue().get(""String_Node_Str"");
    ItemStack[] stacks=new ItemStack[40];
    for (int i=0; i < inventory.getValue().size(); ++i) {
      CompoundTag item=(CompoundTag)inventory.getValue().get(i);
      byte count=((ByteTag)item.getValue().get(""String_Node_Str"")).getValue();
      byte slot=((ByteTag)item.getValue().get(""String_Node_Str"")).getValue();
      short damage=((ShortTag)item.getValue().get(""String_Node_Str"")).getValue();
      short id=((ShortTag)item.getValue().get(""String_Node_Str"")).getValue();
      stacks[slot]=new ItemStack(id,count,damage);
    }
    return stacks;
  }
 catch (  IOException ex) {
    iConomy.Server.getLogger().warning(""String_Node_Str"" + name + ""String_Node_Str""+ ex.getMessage());
    return null;
  }
}",0.934861907243356
1577,"public void createBankAccount(CommandSender sender,String name,String player){
  Bank bank=iConomy.getBank(name);
  if (!iConomy.hasAccount(player)) {
    Messaging.send(sender,Template.color(""String_Node_Str""));
    return;
  }
  Account account=iConomy.getAccount(player);
  if (bank == null) {
    Messaging.send(sender,Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{name}));
    return;
  }
  int count=iConomy.Banks.count(player);
  if (count > 1 && !Constants.BankingMultiple || !iConomy.hasPermissions(sender,""String_Node_Str"")) {
    Messaging.send(sender,Template.color(""String_Node_Str""));
    return;
  }
  if (bank != null) {
    double fee=bank.getFee();
    if (fee < account.getHoldings().balance()) {
      Messaging.send(sender,Template.color(""String_Node_Str""));
      return;
    }
    if (bank.createAccount(player)) {
      account.getHoldings().subtract(fee);
      Messaging.send(sender,Template.color(""String_Node_Str"") + Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{name,player}));
      if (count == 0) {
        iConomy.getAccount(player).setMainBank(bank.getId());
      }
      return;
    }
 else {
      Messaging.send(sender,Template.color(""String_Node_Str""));
    }
  }
 else {
    Messaging.send(sender,Template.color(""String_Node_Str""));
  }
}","public void createBankAccount(CommandSender sender,String name,String player){
  Bank bank=iConomy.getBank(name);
  if (!iConomy.hasAccount(player)) {
    Messaging.send(sender,Template.color(""String_Node_Str""));
    return;
  }
  Account account=iConomy.getAccount(player);
  if (bank == null) {
    Messaging.send(sender,Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{name}));
    return;
  }
  int count=iConomy.Banks.count(player);
  if (count > 1 && !Constants.BankingMultiple || !iConomy.hasPermissions(sender,""String_Node_Str"")) {
    Messaging.send(sender,Template.color(""String_Node_Str""));
    return;
  }
  if (bank != null) {
    double fee=bank.getFee();
    if (fee > account.getHoldings().balance()) {
      Messaging.send(sender,Template.color(""String_Node_Str""));
      return;
    }
    if (bank.createAccount(player)) {
      account.getHoldings().subtract(fee);
      Messaging.send(sender,Template.color(""String_Node_Str"") + Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{name,player}));
      if (count == 0) {
        iConomy.getAccount(player).setMainBank(bank.getId());
      }
      return;
    }
 else {
      Messaging.send(sender,Template.color(""String_Node_Str""));
    }
  }
 else {
    Messaging.send(sender,Template.color(""String_Node_Str""));
  }
}",0.9992647058823528
1578,"public Database(){
  if (Misc.is(Constants.Database_Type,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""})) {
    driver=""String_Node_Str"";
    dsn=""String_Node_Str"" + Constants.Plugin_Directory + File.separator+ Constants.SQL_Database+ ""String_Node_Str"";
    username=""String_Node_Str"";
    password=""String_Node_Str"";
  }
 else   if (Constants.Database_Type.equalsIgnoreCase(""String_Node_Str"")) {
    driver=""String_Node_Str"";
    dsn=""String_Node_Str"" + Constants.SQL_Hostname + ""String_Node_Str""+ Constants.SQL_Port+ ""String_Node_Str""+ Constants.SQL_Database;
    username=Constants.SQL_Username;
    password=Constants.SQL_Password;
  }
  try {
    Class.forName(driver).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
  }
}","public Database(){
  if (Misc.is(Constants.Database_Type,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""})) {
    driver=""String_Node_Str"";
    dsn=""String_Node_Str"" + Constants.Plugin_Directory + File.separator+ Constants.SQL_Database+ ""String_Node_Str"";
    username=""String_Node_Str"";
    password=""String_Node_Str"";
  }
 else   if (Constants.Database_Type.equalsIgnoreCase(""String_Node_Str"")) {
    driver=""String_Node_Str"";
    dsn=""String_Node_Str"" + Constants.SQL_Hostname + ""String_Node_Str""+ Constants.SQL_Port+ ""String_Node_Str""+ Constants.SQL_Database;
    username=Constants.SQL_Username;
    password=Constants.SQL_Password;
  }
  try {
    Class.forName(driver).newInstance();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
  }
  if (Misc.is(Constants.Database_Type,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""})) {
    if (h2pool == null) {
      h2pool=JdbcConnectionPool.create(dsn,username,password);
    }
  }
}",0.8659003831417624
1579,"public Connection checkOut(){
  try {
    if (username.equalsIgnoreCase(""String_Node_Str"") && password.equalsIgnoreCase(""String_Node_Str""))     return (DriverManager.getConnection(dsn));
 else {
      return (DriverManager.getConnection(dsn,username,password));
    }
  }
 catch (  SQLException e) {
    System.out.println(""String_Node_Str"" + e);
    return (null);
  }
}","public Connection checkOut(){
  try {
    if (username.equalsIgnoreCase(""String_Node_Str"") && password.equalsIgnoreCase(""String_Node_Str""))     return (DriverManager.getConnection(dsn));
 else {
      if (Misc.is(Constants.Database_Type,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""})) {
        return h2pool.getConnection();
      }
 else {
        return (DriverManager.getConnection(dsn,username,password));
      }
    }
  }
 catch (  SQLException e) {
    System.out.println(""String_Node_Str"" + e);
    return (null);
  }
}",0.7731629392971247
1580,"public void subtract(double amount){
  if (Constants.Database_Cache) {
    this.balance=this.balance - amount;
    this.setAltered(true);
    return;
  }
  this.setBalance(this.getBalance() / amount);
}","public void subtract(double amount){
  if (Constants.Database_Cache) {
    this.balance=this.balance - amount;
    this.setAltered(true);
    return;
  }
  this.setBalance(this.getBalance() - amount);
}",0.995049504950495
1581,"/** 
 * @param account
 * @param controller If set to null, won't display messages.
 * @param amount
 * @param console Is it sent via console?
 */
public void showGrant(String name,Player controller,double amount,boolean console){
  Player online=iConomy.getBukkitServer().getPlayer(name);
  Account account=iConomy.getBank().getAccount(name);
  account.add(amount);
  account.save();
  if (amount < 0.0) {
    iConomy.getTransactions().insert(""String_Node_Str"",name,0.0,account.getBalance(),0.0,0.0,amount);
  }
 else {
    iConomy.getTransactions().insert(""String_Node_Str"",name,0.0,account.getBalance(),0.0,amount,0.0);
  }
  if (online != null) {
    Messaging.send(online,Template.color(""String_Node_Str"") + Template.parse((amount < 0.0) ? ""String_Node_Str"" : ""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{(console) ? ""String_Node_Str"" : controller.getName(),iConomy.getBank().format(((amount < 0.0) ? amount * -1 : amount))}));
    showBalance(name,online,true);
  }
  if (controller != null) {
    Messaging.send(Template.color(""String_Node_Str"") + Template.parse((amount < 0.0) ? ""String_Node_Str"" : ""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{name,iConomy.getBank().format(amount)}));
  }
  if (console) {
    System.out.println(""String_Node_Str"" + account.getName() + ""String_Node_Str""+ amount+ ""String_Node_Str"");
  }
 else {
    System.out.println(Messaging.bracketize(""String_Node_Str"") + ""String_Node_Str"" + account.getName()+ ""String_Node_Str""+ amount+ ""String_Node_Str""+ controller.getName()+ ""String_Node_Str"");
  }
}","/** 
 * @param account
 * @param controller If set to null, won't display messages.
 * @param amount
 * @param console Is it sent via console?
 */
public void showGrant(String name,Player controller,double amount,boolean console){
  Player online=iConomy.getBukkitServer().getPlayer(name);
  if (online != null) {
    name=online.getName();
  }
  Account account=iConomy.getBank().getAccount(name);
  if (account != null) {
    account.add(amount);
    account.save();
    if (amount < 0.0) {
      iConomy.getTransactions().insert(""String_Node_Str"",name,0.0,account.getBalance(),0.0,0.0,amount);
    }
 else {
      iConomy.getTransactions().insert(""String_Node_Str"",name,0.0,account.getBalance(),0.0,amount,0.0);
    }
    if (online != null) {
      Messaging.send(online,Template.color(""String_Node_Str"") + Template.parse((amount < 0.0) ? ""String_Node_Str"" : ""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{(console) ? ""String_Node_Str"" : controller.getName(),iConomy.getBank().format(((amount < 0.0) ? amount * -1 : amount))}));
      showBalance(name,online,true);
    }
    if (controller != null) {
      Messaging.send(Template.color(""String_Node_Str"") + Template.parse((amount < 0.0) ? ""String_Node_Str"" : ""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{name,iConomy.getBank().format(amount)}));
    }
    if (console) {
      System.out.println(""String_Node_Str"" + account.getName() + ""String_Node_Str""+ amount+ ""String_Node_Str"");
    }
 else {
      System.out.println(Messaging.bracketize(""String_Node_Str"") + ""String_Node_Str"" + account.getName()+ ""String_Node_Str""+ amount+ ""String_Node_Str""+ controller.getName()+ ""String_Node_Str"");
    }
  }
}",0.76124775044991
1582,"/** 
 * Reset a players account easily.
 * @param resetting The player being reset. Cannot be null.
 * @param by The player resetting the account. Cannot be null.
 * @param notify Do we want to show the updates to each player?
 */
public void showPayment(String from,String to,double amount){
  Player paymentFrom=iConomy.getBukkitServer().getPlayer(from);
  Player paymentTo=iConomy.getBukkitServer().getPlayer(to);
  Account balanceFrom=iConomy.getBank().getAccount(from);
  Account balanceTo=iConomy.getBank().getAccount(to);
  if (from.equals(to)) {
    if (paymentFrom != null) {
      Messaging.send(paymentFrom,Template.color(""String_Node_Str""));
    }
  }
 else   if (amount < 0.0 || !balanceFrom.hasEnough(amount)) {
    if (paymentFrom != null) {
      Messaging.send(paymentFrom,Template.color(""String_Node_Str""));
    }
  }
 else {
    balanceFrom.subtract(amount);
    balanceFrom.save();
    balanceTo.add(amount);
    balanceTo.save();
    iConomy.getTransactions().insert(from,to,balanceFrom.getBalance(),balanceTo.getBalance(),0.0,0.0,amount);
    iConomy.getTransactions().insert(to,from,balanceTo.getBalance(),balanceFrom.getBalance(),0.0,amount,0.0);
    if (paymentFrom != null) {
      Messaging.send(paymentFrom,Template.color(""String_Node_Str"") + Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{to,iConomy.getBank().format(amount)}));
      showBalance(from,paymentFrom,true);
    }
    if (paymentTo != null) {
      Messaging.send(paymentTo,Template.color(""String_Node_Str"") + Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{from,iConomy.getBank().format(amount)}));
      showBalance(to,paymentTo,true);
    }
  }
}","/** 
 * Reset a players account easily.
 * @param resetting The player being reset. Cannot be null.
 * @param by The player resetting the account. Cannot be null.
 * @param notify Do we want to show the updates to each player?
 */
public void showPayment(String from,String to,double amount){
  Player paymentFrom=iConomy.getBukkitServer().getPlayer(from);
  Player paymentTo=iConomy.getBukkitServer().getPlayer(to);
  if (paymentFrom != null) {
    from=paymentFrom.getName();
  }
  if (paymentTo != null) {
    to=paymentTo.getName();
  }
  Account balanceFrom=iConomy.getBank().getAccount(from);
  Account balanceTo=iConomy.getBank().getAccount(to);
  if (from.equals(to)) {
    if (paymentFrom != null) {
      Messaging.send(paymentFrom,Template.color(""String_Node_Str""));
    }
  }
 else   if (amount < 0.0 || !balanceFrom.hasEnough(amount)) {
    if (paymentFrom != null) {
      Messaging.send(paymentFrom,Template.color(""String_Node_Str""));
    }
  }
 else {
    balanceFrom.subtract(amount);
    balanceFrom.save();
    balanceTo.add(amount);
    balanceTo.save();
    iConomy.getTransactions().insert(from,to,balanceFrom.getBalance(),balanceTo.getBalance(),0.0,0.0,amount);
    iConomy.getTransactions().insert(to,from,balanceTo.getBalance(),balanceFrom.getBalance(),0.0,amount,0.0);
    if (paymentFrom != null) {
      Messaging.send(paymentFrom,Template.color(""String_Node_Str"") + Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{to,iConomy.getBank().format(amount)}));
      showBalance(from,paymentFrom,true);
    }
    if (paymentTo != null) {
      Messaging.send(paymentTo,Template.color(""String_Node_Str"") + Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{from,iConomy.getBank().format(amount)}));
      showBalance(to,paymentTo,true);
    }
  }
}",0.9655555555555556
1583,"/** 
 * Reset a players account, accessable via Console & In-Game
 * @param account The account we are resetting.
 * @param controller If set to null, won't display messages.
 * @param console Is it sent via console?
 */
public void showReset(String account,Player controller,boolean console){
  Player player=iConomy.getBukkitServer().getPlayer(account);
  iConomy.getTransactions().insert(account,""String_Node_Str"",0.0,0.0,0.0,0.0,iConomy.getBank().getAccount(account).getBalance());
  iConomy.getBank().resetAccount(account);
  if (player != null) {
    Messaging.send(player,Template.color(""String_Node_Str""));
  }
  if (controller != null) {
    Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{account}));
  }
  if (console) {
    System.out.println(""String_Node_Str"" + account + ""String_Node_Str"");
  }
 else {
    System.out.println(Messaging.bracketize(""String_Node_Str"") + ""String_Node_Str"" + account+ ""String_Node_Str""+ controller.getName()+ ""String_Node_Str"");
  }
}","/** 
 * Reset a players account, accessable via Console & In-Game
 * @param account The account we are resetting.
 * @param controller If set to null, won't display messages.
 * @param console Is it sent via console?
 */
public void showReset(String account,Player controller,boolean console){
  Player player=iConomy.getBukkitServer().getPlayer(account);
  if (player != null) {
    account=player.getName();
  }
  iConomy.getTransactions().insert(account,""String_Node_Str"",0.0,0.0,0.0,0.0,iConomy.getBank().getAccount(account).getBalance());
  iConomy.getBank().resetAccount(account);
  if (player != null) {
    Messaging.send(player,Template.color(""String_Node_Str""));
  }
  if (controller != null) {
    Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{account}));
  }
  if (console) {
    System.out.println(""String_Node_Str"" + account + ""String_Node_Str"");
  }
 else {
    System.out.println(Messaging.bracketize(""String_Node_Str"") + ""String_Node_Str"" + account+ ""String_Node_Str""+ controller.getName()+ ""String_Node_Str"");
  }
}",0.972407231208373
1584,"/** 
 * @param account
 * @param controller If set to null, won't display messages.
 * @param amount
 * @param console Is it sent via console?
 */
public void showSet(String name,Player controller,double amount,boolean console){
  Player online=iConomy.getBukkitServer().getPlayer(name);
  Account account=iConomy.getBank().getAccount(name);
  account.setBalance(amount);
  account.save();
  iConomy.getTransactions().insert(""String_Node_Str"",name,0.0,account.getBalance(),amount,0.0,0.0);
  if (online != null) {
    Messaging.send(online,Template.color(""String_Node_Str"") + Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{(console) ? ""String_Node_Str"" : controller.getName(),iConomy.getBank().format(amount)}));
    showBalance(name,online,true);
  }
  if (controller != null) {
    Messaging.send(Template.color(""String_Node_Str"") + Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{name,iConomy.getBank().format(amount)}));
  }
  if (console) {
    System.out.println(""String_Node_Str"" + account + ""String_Node_Str""+ amount+ ""String_Node_Str"");
  }
 else {
    System.out.println(Messaging.bracketize(""String_Node_Str"") + ""String_Node_Str"" + account+ ""String_Node_Str""+ amount+ ""String_Node_Str""+ controller.getName()+ ""String_Node_Str"");
  }
}","/** 
 * @param account
 * @param controller If set to null, won't display messages.
 * @param amount
 * @param console Is it sent via console?
 */
public void showSet(String name,Player controller,double amount,boolean console){
  Player online=iConomy.getBukkitServer().getPlayer(name);
  if (online != null) {
    name=online.getName();
  }
  Account account=iConomy.getBank().getAccount(name);
  if (account != null) {
    account.setBalance(amount);
    account.save();
    iConomy.getTransactions().insert(""String_Node_Str"",name,0.0,account.getBalance(),amount,0.0,0.0);
    if (online != null) {
      Messaging.send(online,Template.color(""String_Node_Str"") + Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{(console) ? ""String_Node_Str"" : controller.getName(),iConomy.getBank().format(amount)}));
      showBalance(name,online,true);
    }
    if (controller != null) {
      Messaging.send(Template.color(""String_Node_Str"") + Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{name,iConomy.getBank().format(amount)}));
    }
    if (console) {
      System.out.println(""String_Node_Str"" + account + ""String_Node_Str""+ amount+ ""String_Node_Str"");
    }
 else {
      System.out.println(Messaging.bracketize(""String_Node_Str"") + ""String_Node_Str"" + account+ ""String_Node_Str""+ amount+ ""String_Node_Str""+ controller.getName()+ ""String_Node_Str"");
    }
  }
}",0.8148677626876341
1585,"/** 
 * Commands sent from in-game are parsed and evaluated here.
 * @param player
 * @param split
 */
public void onPlayerCommand(CommandSender sender,String[] split){
  Messaging.save(sender);
  boolean isPlayer=(sender instanceof Player);
  Player player=(sender instanceof Player) ? (Player)sender : null;
  if (split[0].equalsIgnoreCase(""String_Node_Str"")) {
switch (split.length) {
case 1:
      if (isPlayer)       showBalance(""String_Node_Str"",player,true);
 else {
        Messaging.send(""String_Node_Str"");
      }
    return;
case 2:
  if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
    if (!iConomy.hasPermissions(sender,""String_Node_Str"") || !isPlayer) {
      return;
    }
    showRank(player,player.getName());
    return;
  }
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
  if (!iConomy.hasPermissions(player,""String_Node_Str"")) {
    return;
  }
  showTop(sender,5);
  return;
}
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
if (!iConomy.hasPermissions(sender,""String_Node_Str"")) {
  return;
}
Collection<Double> money=iConomy.getBank().getAccounts().values();
double totalMoney=0;
int totalPlayers=money.size();
for (Object o : money.toArray()) {
  totalMoney+=(Double)o;
}
Messaging.send(Template.color(""String_Node_Str""));
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new Object[]{iConomy.getBank().getCurrency(),iConomy.getBank().format(totalMoney)}));
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new Object[]{iConomy.getBank().getCurrency(),iConomy.getBank().format(totalMoney / totalPlayers)}));
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new Object[]{iConomy.getBank().getCurrency(),totalPlayers}));
return;
}
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""})) {
showHelp(player);
return;
}
 else {
if (!iConomy.hasPermissions(sender,""String_Node_Str"")) {
return;
}
if (iConomy.getBank().hasAccount(split[1])) {
showBalance(split[1],sender,false);
}
 else {
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{split[1]}));
}
return;
}
case 3:
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
if (!iConomy.hasPermissions(sender,""String_Node_Str"")) {
return;
}
if (iConomy.getBank().hasAccount(split[2])) {
showRank(sender,split[2]);
}
 else {
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{split[2]}));
}
return;
}
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
if (!iConomy.hasPermissions(player,""String_Node_Str"")) {
return;
}
try {
showTop(sender,Integer.parseInt(split[2]) < 0 ? 5 : Integer.parseInt(split[2]));
}
 catch (Exception e) {
showTop(sender,5);
}
return;
}
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
if (!iConomy.hasPermissions(sender,""String_Node_Str"")) {
return;
}
if (iConomy.getBank().hasAccount(split[2])) {
if (isPlayer) showReset(split[2],player,false);
 else {
showReset(split[2],null,true);
}
}
 else {
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{split[2]}));
}
return;
}
break;
case 4:
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
if (!iConomy.hasPermissions(sender,""String_Node_Str"") || !isPlayer) {
return;
}
String name=""String_Node_Str"";
double amount=0.0;
if (iConomy.getBank().hasAccount(split[2])) {
name=split[2];
}
 else {
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{split[2]}));
return;
}
try {
amount=Double.parseDouble(split[3]);
if (amount < 0.01) {
throw new NumberFormatException();
}
}
 catch (NumberFormatException ex) {
Messaging.send(""String_Node_Str"" + amount);
Messaging.send(""String_Node_Str"");
return;
}
showPayment(player.getName(),name,amount);
return;
}
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
if (!iConomy.hasPermissions(sender,""String_Node_Str"")) {
return;
}
String name=""String_Node_Str"";
double amount=0.0;
if (iConomy.getBank().hasAccount(split[2])) {
name=split[2];
}
 else {
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{split[2]}));
}
try {
amount=Double.parseDouble(split[3]);
}
 catch (NumberFormatException e) {
Messaging.send(""String_Node_Str"" + split[3]);
Messaging.send(""String_Node_Str"");
}
if (isPlayer) showGrant(name,player,amount,false);
 else {
showGrant(name,null,amount,true);
}
return;
}
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
if (!iConomy.hasPermissions(player,""String_Node_Str"")) {
return;
}
String name=""String_Node_Str"";
double amount=0.0;
if (iConomy.getBank().hasAccount(split[2])) {
name=split[2];
}
 else {
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{split[2]}));
}
try {
amount=Double.parseDouble(split[3]);
}
 catch (NumberFormatException e) {
Messaging.send(""String_Node_Str"" + split[3]);
Messaging.send(""String_Node_Str"");
}
if (isPlayer) showSet(name,player,amount,false);
 else {
showSet(name,null,amount,true);
}
return;
}
break;
}
showHelp(player);
}
return;
}","/** 
 * Commands sent from in-game are parsed and evaluated here.
 * @param player
 * @param split
 */
public void onPlayerCommand(CommandSender sender,String[] split){
  Messaging.save(sender);
  boolean isPlayer=(sender instanceof Player);
  Player player=(sender instanceof Player) ? (Player)sender : null;
  if (split[0].equalsIgnoreCase(""String_Node_Str"")) {
switch (split.length) {
case 1:
      if (isPlayer)       showBalance(""String_Node_Str"",player,true);
 else {
        Messaging.send(""String_Node_Str"");
      }
    return;
case 2:
  if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
    if (!iConomy.hasPermissions(sender,""String_Node_Str"") || !isPlayer) {
      return;
    }
    showRank(player,player.getName());
    return;
  }
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
  if (!iConomy.hasPermissions(player,""String_Node_Str"")) {
    return;
  }
  showTop(sender,5);
  return;
}
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
if (!iConomy.hasPermissions(sender,""String_Node_Str"")) {
  return;
}
Collection<Double> money=iConomy.getBank().getAccounts().values();
double totalMoney=0;
int totalPlayers=money.size();
for (Object o : money.toArray()) {
  totalMoney+=(Double)o;
}
Messaging.send(Template.color(""String_Node_Str""));
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new Object[]{iConomy.getBank().getCurrency(),iConomy.getBank().format(totalMoney)}));
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new Object[]{iConomy.getBank().getCurrency(),iConomy.getBank().format(totalMoney / totalPlayers)}));
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new Object[]{iConomy.getBank().getCurrency(),totalPlayers}));
return;
}
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""})) {
showHelp(player);
return;
}
 else {
if (!iConomy.hasPermissions(sender,""String_Node_Str"")) {
return;
}
Player online=iConomy.getBukkitServer().getPlayer(split[1]);
if (online != null) {
split[1]=online.getName();
}
if (iConomy.getBank().hasAccount(split[1])) {
showBalance(split[1],sender,false);
}
 else {
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{split[1]}));
}
return;
}
case 3:
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
if (!iConomy.hasPermissions(sender,""String_Node_Str"")) {
return;
}
if (iConomy.getBank().hasAccount(split[2])) {
showRank(sender,split[2]);
}
 else {
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{split[2]}));
}
return;
}
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
if (!iConomy.hasPermissions(player,""String_Node_Str"")) {
return;
}
try {
showTop(sender,Integer.parseInt(split[2]) < 0 ? 5 : Integer.parseInt(split[2]));
}
 catch (Exception e) {
showTop(sender,5);
}
return;
}
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
if (!iConomy.hasPermissions(sender,""String_Node_Str"")) {
return;
}
if (iConomy.getBank().hasAccount(split[2])) {
if (isPlayer) showReset(split[2],player,false);
 else {
showReset(split[2],null,true);
}
}
 else {
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{split[2]}));
}
return;
}
break;
case 4:
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
if (!iConomy.hasPermissions(sender,""String_Node_Str"") || !isPlayer) {
return;
}
String name=""String_Node_Str"";
double amount=0.0;
if (iConomy.getBank().hasAccount(split[2])) {
name=split[2];
}
 else {
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{split[2]}));
return;
}
try {
amount=Double.parseDouble(split[3]);
if (amount < 0.01) {
throw new NumberFormatException();
}
}
 catch (NumberFormatException ex) {
Messaging.send(""String_Node_Str"" + amount);
Messaging.send(""String_Node_Str"");
return;
}
showPayment(player.getName(),name,amount);
return;
}
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
if (!iConomy.hasPermissions(sender,""String_Node_Str"")) {
return;
}
String name=""String_Node_Str"";
double amount=0.0;
if (iConomy.getBank().hasAccount(split[2])) {
name=split[2];
}
 else {
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{split[2]}));
}
try {
amount=Double.parseDouble(split[3]);
}
 catch (NumberFormatException e) {
Messaging.send(""String_Node_Str"" + split[3]);
Messaging.send(""String_Node_Str"");
}
if (isPlayer) showGrant(name,player,amount,false);
 else {
showGrant(name,null,amount,true);
}
return;
}
if (Misc.is(split[1],new String[]{""String_Node_Str"",""String_Node_Str""})) {
if (!iConomy.hasPermissions(player,""String_Node_Str"")) {
return;
}
String name=""String_Node_Str"";
double amount=0.0;
if (iConomy.getBank().hasAccount(split[2])) {
name=split[2];
}
 else {
Messaging.send(Template.parse(""String_Node_Str"",new String[]{""String_Node_Str""},new String[]{split[2]}));
}
try {
amount=Double.parseDouble(split[3]);
}
 catch (NumberFormatException e) {
Messaging.send(""String_Node_Str"" + split[3]);
Messaging.send(""String_Node_Str"");
}
if (isPlayer) showSet(name,player,amount,false);
 else {
showSet(name,null,amount,true);
}
return;
}
break;
}
showHelp(player);
}
return;
}",0.9898403483309144
1586,"@Override public void onEnable(){
  Server=getServer();
  getDataFolder().mkdir();
  getDataFolder().setWritable(true);
  getDataFolder().setExecutable(true);
  Constants.Plugin_Directory=getDataFolder().getPath();
  PluginManager pm=Server.getPluginManager();
  PluginDescriptionFile pdfFile=this.getDescription();
  FileManager file=new FileManager(getDataFolder().getPath(),""String_Node_Str"",false);
  extractDefaultFile(""String_Node_Str"");
  extractDefaultFile(""String_Node_Str"");
  try {
    Constants.load(new Configuration(new File(getDataFolder(),""String_Node_Str"")));
  }
 catch (  Exception e) {
    Server.getPluginManager().disablePlugin(this);
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    return;
  }
  try {
    iDatabase=new iDatabase();
  }
 catch (  Exception e) {
    Server.getPluginManager().disablePlugin(this);
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
  try {
    Transactions=new Transactions();
    Transactions.load();
  }
 catch (  Exception e) {
    Server.getPluginManager().disablePlugin(this);
    System.out.println(""String_Node_Str"" + e.getMessage());
  }
  update(file,Double.valueOf(pdfFile.getVersion()));
  try {
    Bank=new Bank();
    Bank.load();
  }
 catch (  Exception e) {
    Server.getPluginManager().disablePlugin(this);
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
  try {
    if (Constants.Interest) {
      Interest_Timer=new Timer();
      Interest_Timer.scheduleAtFixedRate(new Interest(),Constants.Interest_Interval * 1000L,Constants.Interest_Interval * 1000L);
    }
  }
 catch (  Exception e) {
    Server.getPluginManager().disablePlugin(this);
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
  pluginListener=new iPluginListener();
  playerListener=new iPlayerListener(getDataFolder().getPath());
  pm.registerEvent(Event.Type.PLAYER_JOIN,playerListener,Priority.Normal,this);
  pm.registerEvent(Event.Type.PLUGIN_ENABLE,pluginListener,Priority.Monitor,this);
  System.out.println(""String_Node_Str"" + pdfFile.getVersion() + ""String_Node_Str""+ Constants.Codename+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + pdfFile.getAuthors());
}","@Override public void onEnable(){
  Server=getServer();
  getDataFolder().mkdir();
  getDataFolder().setWritable(true);
  getDataFolder().setExecutable(true);
  Constants.Plugin_Directory=getDataFolder().getPath();
  PluginManager pm=Server.getPluginManager();
  PluginDescriptionFile pdfFile=this.getDescription();
  FileManager file=new FileManager(getDataFolder().getPath(),""String_Node_Str"",false);
  extractDefaultFile(""String_Node_Str"");
  extractDefaultFile(""String_Node_Str"");
  try {
    Constants.load(new Configuration(new File(getDataFolder(),""String_Node_Str"")));
  }
 catch (  Exception e) {
    Server.getPluginManager().disablePlugin(this);
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    return;
  }
  try {
    iDatabase=new iDatabase();
  }
 catch (  Exception e) {
    Server.getPluginManager().disablePlugin(this);
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
  try {
    Transactions=new Transactions();
    Transactions.load();
  }
 catch (  Exception e) {
    Server.getPluginManager().disablePlugin(this);
    System.out.println(""String_Node_Str"" + e.getMessage());
  }
  update(file,Double.valueOf(pdfFile.getVersion()));
  try {
    Bank=new Bank();
    Bank.load();
  }
 catch (  Exception e) {
    Server.getPluginManager().disablePlugin(this);
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
  try {
    if (Constants.Interest) {
      Interest_Timer=new Timer();
      Interest_Timer.scheduleAtFixedRate(new Interest(),Constants.Interest_Interval * 1000L,Constants.Interest_Interval * 1000L);
    }
  }
 catch (  Exception e) {
    Server.getPluginManager().disablePlugin(this);
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
  try {
    Plugin PermissionsPlugin=this.getServer().getPluginManager().getPlugin(""String_Node_Str"");
    if (PermissionsPlugin == null)     pm.registerEvent(Event.Type.PLUGIN_ENABLE,pluginListener,Priority.Monitor,this);
 else     setPermissions(((Permissions)PermissionsPlugin).getHandler());
  }
 catch (  Exception e) {
    Server.getPluginManager().disablePlugin(this);
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
  pluginListener=new iPluginListener();
  playerListener=new iPlayerListener(getDataFolder().getPath());
  pm.registerEvent(Event.Type.PLAYER_JOIN,playerListener,Priority.Normal,this);
  pm.registerEvent(Event.Type.PLUGIN_ENABLE,pluginListener,Priority.Monitor,this);
  System.out.println(""String_Node_Str"" + pdfFile.getVersion() + ""String_Node_Str""+ Constants.Codename+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + pdfFile.getAuthors());
}",0.8351559335763467
1587,"/** 
 * Call this method in your Activity's onPause() method body.
 */
public void onPause(Activity activity){
  if (mNfcAdapter == null) {
    return;
  }
  mActivity=activity;
  mState=STATE_PAUSING;
  mNfcAdapter.disableForegroundDispatch(mActivity);
  mNfcAdapter.disableForegroundNdefPush(mActivity);
  mState=STATE_PAUSED;
}","/** 
 * Call this method in your Activity's onPause() method body.
 */
public void onPause(Activity activity){
  if (mNfcAdapter == null) {
    return;
  }
  mActivity=activity;
synchronized (this) {
    mState=STATE_PAUSING;
    mNfcAdapter.disableForegroundDispatch(mActivity);
    mNfcAdapter.disableForegroundNdefPush(mActivity);
    mState=STATE_PAUSED;
  }
}",0.9510086455331412
1588,"/** 
 * Call this method in your Activity's onResume() method body.
 */
public void onResume(Activity activity){
  if (mNfcAdapter == null) {
    return;
  }
  mActivity=activity;
  mState=STATE_RESUMING;
  if (mInterfaceMode != MODE_PASSTHROUGH) {
    installNfcHandler();
    if (mInterfaceMode == MODE_EXCHANGE) {
      enableNdefPush();
    }
  }
  mState=STATE_RESUMED;
}","/** 
 * Call this method in your Activity's onResume() method body.
 */
public void onResume(Activity activity){
  if (mNfcAdapter == null) {
    return;
  }
  mActivity=activity;
synchronized (this) {
    mState=STATE_RESUMING;
    if (mInterfaceMode != MODE_PASSTHROUGH) {
      installNfcHandler();
      if (mInterfaceMode == MODE_EXCHANGE) {
        enableNdefPush();
      }
    }
    mState=STATE_RESUMED;
  }
}",0.947103274559194
1589,"/** 
 * Sets an ndef message to be read via android.npp protocol. This method may be called off the main thread.
 */
private void enableNdefPush(){
  if (mNfcAdapter == null) {
    return;
  }
  final NdefMessage ndef=mForegroundMessage;
  if (ndef == null) {
    return;
  }
  mActivity.runOnUiThread(new Runnable(){
    @Override public void run(){
synchronized (Nfc.this) {
        if (mState < STATE_RESUMING) {
          return;
        }
        mNfcAdapter.enableForegroundNdefPush(mActivity,ndef);
      }
    }
  }
);
}","/** 
 * Sets an ndef message to be read via android.npp protocol. This method may be called off the main thread.
 */
private void enableNdefPush(){
  if (mNfcAdapter == null) {
    return;
  }
  final NdefMessage ndef=mForegroundMessage;
  if (ndef == null) {
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
synchronized (Nfc.this) {
          if (mState < STATE_RESUMING) {
            return;
          }
          mNfcAdapter.disableForegroundNdefPush(mActivity);
        }
      }
    }
);
    return;
  }
  mActivity.runOnUiThread(new Runnable(){
    @Override public void run(){
synchronized (Nfc.this) {
        if (mState < STATE_RESUMING) {
          return;
        }
        mNfcAdapter.enableForegroundNdefPush(mActivity,ndef);
      }
    }
  }
);
}",0.7781983345950038
1590,"/** 
 * Issues a connection handover of the given type.
 * @param handoverRequest The connection handover request record.
 * @param outboundNdef The ndef message to send from this device. May be null.
 * @throws IOException
 */
public void doConnectionHandover(NdefRecord handoverRequest,NdefProxy ndefProxy) throws IOException ;","/** 
 * Issues a connection handover of the given type.
 * @param handoverRequest The connection handover request record.
 * @param ndefProxy The ndef proxy for sending and receiving ndef messages.
 * @throws IOException
 */
public void doConnectionHandover(NdefRecord handoverRequest,NdefProxy ndefProxy) throws IOException ;",0.8519083969465648
1591,"public Nfc(Activity activity){
  mActivity=activity;
  try {
    mNfcAdapter=NfcAdapter.getDefaultAdapter(mActivity);
  }
 catch (  Exception e) {
    Log.i(TAG,""String_Node_Str"");
    return;
  }
  addNdefHandler(ConnectionHandoverManager.HANDOVER_PRIORITY,mConnectionHandoverManager);
}","public Nfc(Activity activity){
  mActivity=activity;
  try {
    mNfcAdapter=NfcAdapter.getDefaultAdapter(mActivity);
  }
 catch (  NoSuchMethodError e) {
    Log.i(TAG,""String_Node_Str"");
    return;
  }
  addNdefHandler(ConnectionHandoverManager.HANDOVER_PRIORITY,mConnectionHandoverManager);
}",0.958904109589041
1592,"private DeploymentActionsCompleteBuilder undeployAndRemoveUndeployed(final DeploymentPlanBuilder builder,final List<String> deploymentNames){
  DeploymentActionsCompleteBuilder completeBuilder=null;
  for (  String deploymentName : deploymentNames) {
    completeBuilder=builder.undeploy(deploymentName).andRemoveUndeployed();
    if (matchPatternStrategy == MatchPatternStrategy.FIRST) {
      break;
    }
  }
  return completeBuilder;
}","private DeploymentActionsCompleteBuilder undeployAndRemoveUndeployed(final DeploymentPlanBuilder builder,final List<String> deploymentNames){
  DeploymentActionsCompleteBuilder completeBuilder=null;
  for (  String deploymentName : deploymentNames) {
    DeploymentPlanBuilder actualBuilder=(completeBuilder == null ? builder : completeBuilder);
    completeBuilder=actualBuilder.undeploy(deploymentName).andRemoveUndeployed();
    if (matchPatternStrategy == MatchPatternStrategy.FIRST) {
      break;
    }
  }
  return completeBuilder;
}",0.86414708886619
1593,"@Override public final void execute() throws MojoExecutionException, MojoFailureException {
  if (skip) {
    getLog().debug(String.format(""String_Node_Str"",project.getGroupId(),project.getArtifactId()));
    return;
  }
  try {
    final PackageType packageType=getPackageType();
    if (checkPackaging() && packageType.isIgnored()) {
      getLog().debug(String.format(""String_Node_Str"",packageType.getPackaging()));
    }
 else {
synchronized (CLIENT_LOCK) {
        validate();
        final ModelControllerClient client=getClient();
        final Deployment deployment;
        if (isDomainServer()) {
          deployment=DomainDeployment.create((DomainClient)getClient(),domain,file(),name,getType());
        }
 else {
          deployment=StandaloneDeployment.create(client,file(),name,getType());
        }
        if (beforeDeployment != null)         beforeDeployment.execute(client);
        getLog().debug(""String_Node_Str"");
        deployment.execute();
        if (afterDeployment != null)         afterDeployment.execute(client);
      }
    }
  }
 catch (  MojoFailureException e) {
    throw e;
  }
catch (  MojoExecutionException e) {
    throw e;
  }
catch (  Exception e) {
    throw new MojoExecutionException(String.format(""String_Node_Str"",goal(),file(),e.getMessage()),e);
  }
 finally {
    close();
  }
}","@Override public final void execute() throws MojoExecutionException, MojoFailureException {
  if (skip) {
    getLog().debug(String.format(""String_Node_Str"",project.getGroupId(),project.getArtifactId()));
    return;
  }
  final PackageType packageType=getPackageType();
  if (checkPackaging() && packageType.isIgnored()) {
    getLog().debug(String.format(""String_Node_Str"",packageType.getPackaging()));
  }
 else {
    doExecute();
  }
}",0.4808126410835214
1594,"@Override public final void execute() throws MojoExecutionException, MojoFailureException {
  try {
    final File file=new File(targetDirectory(),filename());
    final InetAddress host=hostAddress();
    getLog().info(String.format(""String_Node_Str"",goal(),file,host.getHostName(),host.getHostAddress(),port()));
    if (force()) {
      getLog().debug(""String_Node_Str"");
    }
    final ServerDeploymentManager manager=ServerDeploymentManager.Factory.create(client());
    final DeploymentPlanBuilder builder=manager.newDeploymentPlan();
    final DeploymentPlan plan=createPlan(builder);
    if (plan.getDeploymentActions().size() > 0) {
      final ServerDeploymentPlanResult result=manager.execute(plan).get();
      getLog().debug(String.format(""String_Node_Str"",result.getDeploymentPlanId()));
    }
 else {
      getLog().warn(String.format(""String_Node_Str"",goal(),filename(),plan));
    }
  }
 catch (  Exception e) {
    throw new MojoExecutionException(String.format(""String_Node_Str"",goal(),filename(),e.getMessage()),e);
  }
}","@Override public final void execute() throws MojoExecutionException, MojoFailureException {
  try {
    final File file=new File(targetDirectory(),filename());
    final InetAddress host=hostAddress();
    getLog().info(String.format(""String_Node_Str"",goal(),file,host.getHostName(),host.getHostAddress(),port()));
    if (force()) {
      getLog().debug(""String_Node_Str"");
    }
    final ServerDeploymentManager manager=ServerDeploymentManager.Factory.create(client());
    final DeploymentPlanBuilder builder=manager.newDeploymentPlan();
    final DeploymentPlan plan=createPlan(builder);
    if (plan.getDeploymentActions().size() > 0) {
      final ServerDeploymentPlanResult planResult=manager.execute(plan).get();
      for (      DeploymentAction action : plan.getDeploymentActions()) {
        final ServerDeploymentActionResult actionResult=planResult.getDeploymentActionResult(action.getId());
        final ServerUpdateActionResult.Result result=actionResult.getResult();
switch (result) {
case FAILED:
          throw new MojoExecutionException(""String_Node_Str"",actionResult.getDeploymentException());
case NOT_EXECUTED:
        throw new MojoExecutionException(""String_Node_Str"",actionResult.getDeploymentException());
case ROLLED_BACK:
      throw new MojoExecutionException(""String_Node_Str"",actionResult.getDeploymentException());
case CONFIGURATION_MODIFIED_REQUIRES_RESTART:
    getLog().warn(""String_Node_Str"");
  break;
default :
break;
}
getLog().debug(String.format(""String_Node_Str"",planResult.getDeploymentPlanId()));
}
}
 else {
getLog().warn(String.format(""String_Node_Str"",goal(),filename(),plan));
}
}
 catch (Exception e) {
throw new MojoExecutionException(String.format(""String_Node_Str"",goal(),filename(),e.getMessage()),e);
}
}",0.579885877318117
1595,"public void retrieve(final SimpleStorageData data,final PrivateStorageResponseHandler handler){
  final IQ iq=new IQ(Type.get);
  iq.addQuery(XMLNS).addChild(data);
  session.sendIQ(ID,iq,new IQResponseHandler(){
    @Override public void onIQ(    final IQ iq){
      if (!IQ.isSuccess(iq)) {
        handler.onStorageResponse(new PrivateStorageResponseEvent(iq));
      }
    }
  }
);
}","public void retrieve(final SimpleStorageData data,final PrivateStorageResponseHandler handler){
  final IQ iq=new IQ(Type.get);
  iq.addQuery(XMLNS).addChild(data);
  session.sendIQ(ID,iq,new IQResponseHandler(){
    @Override public void onIQ(    final IQ iq){
      if (IQ.isSuccess(iq)) {
        handler.onStorageResponse(new PrivateStorageResponseEvent(iq));
      }
    }
  }
);
}",0.998706338939198
1596,"@Override public ChatProperties extractProperties(final BasicStanza stanza){
  ChatProperties properties=new ChatProperties(stanza.getFrom());
  boolean messageHasBody=stanza.getFirstChild(""String_Node_Str"") != NoPacket.INSTANCE;
  String stanzaType=stanza.getAttribute(""String_Node_Str"");
  boolean isGroupChatMessage=stanzaType != null && stanzaType.equals(""String_Node_Str"");
  properties.setShouldCreateNewChat(messageHasBody && !isGroupChatMessage);
  return properties;
}","@Override public ChatProperties extractProperties(final BasicStanza stanza){
  ChatProperties properties=new ChatProperties(stanza.getFrom());
  boolean messageHasBody=stanza.getFirstChild(""String_Node_Str"") != NoPacket.INSTANCE;
  boolean shouldCreate=messageHasBody && !((""String_Node_Str"").equals(stanza.getAttribute(""String_Node_Str"")));
  shouldCreate=shouldCreate && (stanza.getFirstChildInDeep(mucMatcher) == NoPacket.INSTANCE);
  properties.setShouldCreateNewChat(shouldCreate);
  return properties;
}",0.565922920892495
1597,"private void handleItemChanged(final RosterItem item){
  final RosterItem old=getItemByJID(item.getJID());
  RosterItemChangedEvent event;
  if (old == null) {
    storeItem(item);
    event=new RosterItemChangedEvent(ChangeTypes.added,item);
  }
 else {
    final SubscriptionState subscriptionState=item.getSubscriptionState();
    if (subscriptionState == SubscriptionState.remove) {
      removeItem(old);
      event=new RosterItemChangedEvent(ChangeTypes.removed,item);
    }
 else {
      updateExistingItem(old,item);
      event=new RosterItemChangedEvent(ChangeTypes.modified,item);
    }
  }
  eventBus.fireEvent(event);
}","private void handleItemChanged(final RosterItem item){
  final RosterItem old=getItemByJID(item.getJID());
  RosterItemChangedEvent event;
  if (old == null) {
    storeItem(item);
    event=new RosterItemChangedEvent(ChangeTypes.added,item);
  }
 else {
    final SubscriptionState subscriptionState=item.getSubscriptionState();
    if (subscriptionState == SubscriptionState.remove) {
      removeItem(old);
      event=new RosterItemChangedEvent(ChangeTypes.removed,old);
    }
 else {
      updateExistingItem(old,item);
      event=new RosterItemChangedEvent(ChangeTypes.modified,old);
    }
  }
  eventBus.fireEvent(event);
}",0.9889240506329114
1598,"@Override public void onIQ(IQ iq){
  if (IQ.isSuccess(iq)) {
    clearGroupAll();
    final List<? extends IPacket> children=iq.getFirstChild(""String_Node_Str"").getChildren();
    for (    final IPacket child : children) {
      final RosterItem item=RosterItem.parse(child);
      storeItem(item);
    }
    if (!rosterReady) {
      rosterReady=true;
      session.setSessionState(SessionStates.rosterReady);
    }
    eventBus.fireEvent(new RosterRetrievedEvent(getItems()));
  }
 else {
    eventBus.fireEvent(new RequestFailedEvent(""String_Node_Str"",""String_Node_Str"",iq));
  }
}","@Override public void onIQ(IQ iq){
  if (!IQ.isSuccess(iq)) {
    eventBus.fireEvent(new RequestFailedEvent(""String_Node_Str"",""String_Node_Str"",iq));
  }
}",0.4167794316644114
1599,"public ErrorEvent(String errorType,String description,IPacket stanza){
  this.errorType=errorType;
  this.description=description;
  this.stanza=stanza;
}","public ErrorEvent(String errorType,String description,IPacket stanza){
  this.errorType=errorType;
  this.description=description;
  this.stanza=stanza;
  this.errorStanza=stanza.getFirstChild(ERROR_STANZA_MATCHER);
}",0.8301886792452831
1600,"public ErrorEvent(String errorType,String description,IPacket stanza){
  this.errorType=errorType;
  this.description=description;
  this.stanza=stanza;
  this.errorStanza=stanza.getFirstChild(ERROR_STANZA_MATCHER);
}","public ErrorEvent(String errorType,String description,IPacket stanza){
  this.errorType=errorType;
  this.description=description;
  this.stanza=stanza != null ? stanza : NoPacket.INSTANCE;
  this.errorStanza=this.stanza.getFirstChild(ERROR_STANZA_MATCHER);
}",0.8235294117647058
1601,"public IPacket getErrorStanza(){
  return errorStanza;
}","/** 
 * The associated error stanza if any
 * @return the error stanza of NoPacket.INSTANCE if none
 * @see http://xmpp.org/rfcs/rfc3920.html#rfc.section.4.7
 */
public IPacket getErrorStanza(){
  return errorStanza;
}",0.4087591240875912
1602,"public IPacket getStanza(){
  return stanza;
}","/** 
 * The server side stanza that fired the error event
 * @return never null: NoPacket.INSTANCE if the is a client side error
 */
public IPacket getStanza(){
  return stanza;
}",0.4088888888888889
1603,"/** 
 * Know if a item is available or not
 * @return true if contact is available
 */
public boolean isAvailable(){
  return isAvailable;
}","/** 
 * Know if a item is available or not
 * @return true if contact is available
 */
public boolean isAvailable(){
  return !availableResources.isEmpty();
}",0.9194630872483222
1604,"/** 
 * Change the current available state of this item. Does NOT have any effect on server side. This method is called by the roster to reflect the state change of the items: usually you don't call this method.
 * @param status the new status
 */
public void setAvailable(final boolean isAvailable){
  this.isAvailable=isAvailable;
}","/** 
 * Change the current available state of this item. Availability is set per resource. If no resource given, this method has no effect. Does NOT have any effect on server side. This method is called by the roster to reflect the state change of the items: usually you don't call this method.
 * @param status the new status
 * @param resource the resource (if any)
 */
public void setAvailable(final boolean isAvailable,String resource){
  if (isAvailable) {
    availableResources.add(resource);
  }
 else {
    availableResources.remove(resource);
  }
}",0.7107623318385651
1605,"/** 
 * Create a RosterItem object
 * @param jid the item jabber id
 * @param subscriptionState the subscription state
 * @param name the name in the roster
 * @param ask
 */
public RosterItem(final XmppURI jid,final SubscriptionState subscriptionState,final String name,final Type ask){
  this.ask=ask;
  this.jid=jid.getJID();
  this.subscriptionState=subscriptionState;
  this.name=name;
  groups=new ArrayList<String>();
  show=Show.unknown;
  isAvailable=false;
  status=null;
}","/** 
 * Create a RosterItem object
 * @param jid the item jabber id
 * @param subscriptionState the subscription state
 * @param name the name in the roster
 * @param ask
 */
public RosterItem(final XmppURI jid,final SubscriptionState subscriptionState,final String name,final Type ask){
  this.ask=ask;
  this.jid=jid.getJID();
  this.subscriptionState=subscriptionState;
  this.name=name;
  groups=new ArrayList<String>();
  availableResources=new HashSet<String>();
  show=Show.unknown;
  status=null;
}",0.9342770475227502
1606,"private void setPresence(final Presence presence,final RosterItem item){
  final Presence.Type type=presence.getType();
  if (type == Presence.Type.unavailable) {
    item.setAvailable(false);
  }
 else {
    item.setAvailable(true);
  }
  final Show showReceived=presence.getShow();
  item.setShow(showReceived == null ? Show.notSpecified : showReceived);
  item.setStatus(presence.getStatus());
  fireItemChanged(item);
}","private void setPresence(final Presence presence,final RosterItem item){
  final Presence.Type type=presence.getType();
  final String resource=presence.getFrom().getResource();
  if (type == Presence.Type.unavailable) {
    item.setAvailable(false,resource);
  }
 else {
    item.setAvailable(true,resource);
  }
  final Show showReceived=presence.getShow();
  item.setShow(showReceived == null ? Show.notSpecified : showReceived);
  item.setStatus(presence.getStatus());
  fireItemChanged(item);
}",0.9175704989154012
1607,"private void handleItemChanged(final RosterItem item){
  final RosterItem old=getItemByJID(item.getJID());
  if (old == null) {
    storeItem(item);
    fireItemAdded(item);
  }
 else {
    removeItem(old);
    final SubscriptionState subscriptionState=item.getSubscriptionState();
    if (subscriptionState == SubscriptionState.remove) {
      fireItemRemoved(item);
    }
 else {
      if (subscriptionState == SubscriptionState.to || subscriptionState == SubscriptionState.both) {
        item.setAvailable(old.isAvailable());
        item.setShow(old.getShow());
        item.setStatus(old.getStatus());
      }
      storeItem(item);
      fireItemChanged(item);
    }
  }
}","private void handleItemChanged(final RosterItem item){
  final RosterItem old=getItemByJID(item.getJID());
  if (old == null) {
    storeItem(item);
    fireItemAdded(item);
  }
 else {
    removeItem(old);
    final SubscriptionState subscriptionState=item.getSubscriptionState();
    if (subscriptionState == SubscriptionState.remove) {
      fireItemRemoved(item);
    }
 else {
      if (subscriptionState == SubscriptionState.to || subscriptionState == SubscriptionState.both) {
        item.setAvaialableResources(old.getAvailableResources());
        item.setShow(old.getShow());
        item.setStatus(old.getStatus());
      }
      storeItem(item);
      fireItemChanged(item);
    }
  }
}",0.9680696661828736
1608,"public RosterOldImpl(final Session session){
  GWT.log(""String_Node_Str"");
  this.session=session;
  session.onStateChanged(new Listener<Session>(){
    @Override public void onEvent(    final Session session){
      if (session.getState() == Session.State.loggedIn) {
        requestRoster(session.getCurrentUser());
      }
    }
  }
);
  session.onPresence(new Listener<Presence>(){
    @Override public void onEvent(    final Presence presence){
      final RosterItem item=getItemByJID(presence.getFrom());
      if (item != null) {
        setPresence(presence,item);
      }
    }
    private void setPresence(    final Presence presence,    final RosterItem item){
      final Presence.Type type=presence.getType();
      if (type == Presence.Type.unavailable) {
        item.setAvailable(false);
      }
 else {
        item.setAvailable(true);
      }
      final Show showReceived=presence.getShow();
      item.setShow(showReceived == null ? Show.notSpecified : showReceived);
      item.setStatus(presence.getStatus());
      fireItemChanged(item);
    }
  }
);
  session.onIQ(new Listener<IQ>(){
    @Override public void onEvent(    final IQ iq){
      if (iq.isType(IQ.Type.set)) {
        final IPacket query=iq.getFirstChild(ROSTER_QUERY_FILTER);
        if (query != null) {
          for (          final IPacket child : query.getChildren()) {
            handleItemChanged(RosterItem.parse(child));
          }
        }
        session.send(new IQ(Type.result).With(""String_Node_Str"",iq.getFromAsString()).With(""String_Node_Str"",iq.getId()));
      }
    }
  }
);
}","public RosterOldImpl(final Session session){
  GWT.log(""String_Node_Str"");
  this.session=session;
  session.onStateChanged(new Listener<Session>(){
    @Override public void onEvent(    final Session session){
      if (session.getState() == Session.State.loggedIn) {
        requestRoster(session.getCurrentUser());
      }
    }
  }
);
  session.onPresence(new Listener<Presence>(){
    @Override public void onEvent(    final Presence presence){
      final RosterItem item=getItemByJID(presence.getFrom());
      if (item != null) {
        setPresence(presence,item);
      }
    }
    private void setPresence(    final Presence presence,    final RosterItem item){
      final Presence.Type type=presence.getType();
      final String resource=presence.getFrom().getResource();
      if (type == Presence.Type.unavailable) {
        item.setAvailable(false,resource);
      }
 else {
        item.setAvailable(true,resource);
      }
      final Show showReceived=presence.getShow();
      item.setShow(showReceived == null ? Show.notSpecified : showReceived);
      item.setStatus(presence.getStatus());
      fireItemChanged(item);
    }
  }
);
  session.onIQ(new Listener<IQ>(){
    @Override public void onEvent(    final IQ iq){
      if (iq.isType(IQ.Type.set)) {
        final IPacket query=iq.getFirstChild(ROSTER_QUERY_FILTER);
        if (query != null) {
          for (          final IPacket child : query.getChildren()) {
            handleItemChanged(RosterItem.parse(child));
          }
        }
        session.send(new IQ(Type.result).With(""String_Node_Str"",iq.getFromAsString()).With(""String_Node_Str"",iq.getId()));
      }
    }
  }
);
}",0.9754148740012292
1609,"private void setPresence(final Presence presence,final RosterItem item){
  final Presence.Type type=presence.getType();
  if (type == Presence.Type.unavailable) {
    item.setAvailable(false);
  }
 else {
    item.setAvailable(true);
  }
  final Show showReceived=presence.getShow();
  item.setShow(showReceived == null ? Show.notSpecified : showReceived);
  item.setStatus(presence.getStatus());
  eventBus.fireEvent(new RosterItemChangedEvent(ChangeTypes.modified,item));
}","private void setPresence(final Presence presence,final RosterItem item){
  final Presence.Type type=presence.getType();
  final String resource=presence.getFrom().getResource();
  if (type == Presence.Type.unavailable) {
    item.setAvailable(false,resource);
  }
 else {
    item.setAvailable(true,resource);
  }
  final Show showReceived=presence.getShow();
  item.setShow(showReceived == null ? Show.notSpecified : showReceived);
  item.setStatus(presence.getStatus());
  eventBus.fireEvent(new RosterItemChangedEvent(ChangeTypes.modified,item));
}",0.925925925925926
1610,"private void handleItemChanged(final RosterItem item){
  final RosterItem old=getItemByJID(item.getJID());
  if (old == null) {
    storeItem(item);
    eventBus.fireEvent(new RosterItemChangedEvent(ChangeTypes.added,item));
  }
 else {
    removeItem(old);
    final SubscriptionState subscriptionState=item.getSubscriptionState();
    if (subscriptionState == SubscriptionState.remove) {
      eventBus.fireEvent(new RosterItemChangedEvent(ChangeTypes.removed,item));
    }
 else {
      if (subscriptionState == SubscriptionState.to || subscriptionState == SubscriptionState.both) {
        item.setAvailable(old.isAvailable());
        item.setShow(old.getShow());
        item.setStatus(old.getStatus());
      }
      storeItem(item);
      eventBus.fireEvent(new RosterItemChangedEvent(ChangeTypes.modified,item));
    }
  }
}","private void handleItemChanged(final RosterItem item){
  final RosterItem old=getItemByJID(item.getJID());
  if (old == null) {
    storeItem(item);
    eventBus.fireEvent(new RosterItemChangedEvent(ChangeTypes.added,item));
  }
 else {
    removeItem(old);
    final SubscriptionState subscriptionState=item.getSubscriptionState();
    if (subscriptionState == SubscriptionState.remove) {
      eventBus.fireEvent(new RosterItemChangedEvent(ChangeTypes.removed,item));
    }
 else {
      if (subscriptionState == SubscriptionState.to || subscriptionState == SubscriptionState.both) {
        item.setAvaialableResources(old.getAvailableResources());
        item.setShow(old.getShow());
        item.setStatus(old.getStatus());
      }
      storeItem(item);
      eventBus.fireEvent(new RosterItemChangedEvent(ChangeTypes.modified,item));
    }
  }
}",0.9739027283511268
1611,"public XmppRosterLogic(final XmppSession session){
  super(session);
  session.addSessionStateChangedHandler(true,new StateChangedHandler(){
    @Override public void onStateChanged(    StateChangedEvent event){
      if (event.is(SessionStates.loggedIn)) {
        reRequestRoster();
      }
    }
  }
);
  session.addPresenceReceivedHandler(new PresenceHandler(){
    @Override public void onPresence(    PresenceEvent event){
      Presence presence=event.getPresence();
      final RosterItem item=getItemByJID(presence.getFrom());
      if (item != null) {
        setPresence(presence,item);
      }
    }
    private void setPresence(    final Presence presence,    final RosterItem item){
      final Presence.Type type=presence.getType();
      if (type == Presence.Type.unavailable) {
        item.setAvailable(false);
      }
 else {
        item.setAvailable(true);
      }
      final Show showReceived=presence.getShow();
      item.setShow(showReceived == null ? Show.notSpecified : showReceived);
      item.setStatus(presence.getStatus());
      eventBus.fireEvent(new RosterItemChangedEvent(ChangeTypes.modified,item));
    }
  }
);
  session.addIQReceivedHandler(new IQHandler(){
    @Override public void onPacket(    IQEvent event){
      IQ iq=event.getIQ();
      if (iq.isType(IQ.Type.set)) {
        final IPacket query=iq.getFirstChild(ROSTER_QUERY_FILTER);
        if (query != NoPacket.INSTANCE) {
          for (          final IPacket child : query.getChildren()) {
            handleItemChanged(RosterItem.parse(child));
          }
        }
        session.send(new IQ(Type.result).With(""String_Node_Str"",iq.getFromAsString()).With(""String_Node_Str"",iq.getId()));
      }
    }
  }
);
}","public XmppRosterLogic(final XmppSession session){
  super(session);
  session.addSessionStateChangedHandler(true,new StateChangedHandler(){
    @Override public void onStateChanged(    StateChangedEvent event){
      if (event.is(SessionStates.loggedIn)) {
        reRequestRoster();
      }
    }
  }
);
  session.addPresenceReceivedHandler(new PresenceHandler(){
    @Override public void onPresence(    PresenceEvent event){
      Presence presence=event.getPresence();
      final RosterItem item=getItemByJID(presence.getFrom());
      if (item != null) {
        setPresence(presence,item);
      }
    }
    private void setPresence(    final Presence presence,    final RosterItem item){
      final Presence.Type type=presence.getType();
      final String resource=presence.getFrom().getResource();
      if (type == Presence.Type.unavailable) {
        item.setAvailable(false,resource);
      }
 else {
        item.setAvailable(true,resource);
      }
      final Show showReceived=presence.getShow();
      item.setShow(showReceived == null ? Show.notSpecified : showReceived);
      item.setStatus(presence.getStatus());
      eventBus.fireEvent(new RosterItemChangedEvent(ChangeTypes.modified,item));
    }
  }
);
  session.addIQReceivedHandler(new IQHandler(){
    @Override public void onPacket(    IQEvent event){
      IQ iq=event.getIQ();
      if (iq.isType(IQ.Type.set)) {
        final IPacket query=iq.getFirstChild(ROSTER_QUERY_FILTER);
        if (query != NoPacket.INSTANCE) {
          for (          final IPacket child : query.getChildren()) {
            handleItemChanged(RosterItem.parse(child));
          }
        }
        session.send(new IQ(Type.result).With(""String_Node_Str"",iq.getFromAsString()).With(""String_Node_Str"",iq.getId()));
      }
    }
  }
);
}",0.977259806708357
1612,"public void setText(final String value){
  children.clear();
  children.add(new TextPacket(TextUtils.escape(value)));
}","public void setText(final String value){
  children.clear();
  if (value != null) {
    children.add(new TextPacket(TextUtils.escape(value)));
  }
}",0.8913857677902621
1613,"public void setText(final String text){
  final String escaped=TextUtils.escape(text);
  final NodeList nodes=element.getChildNodes();
  for (int index=0; index < nodes.getLength(); index++) {
    final Node child=nodes.item(index);
    if (child.getNodeType() == Node.TEXT_NODE) {
      element.removeChild(child);
    }
  }
  element.appendChild(element.getOwnerDocument().createTextNode(escaped));
}","public void setText(final String text){
  final NodeList nodes=element.getChildNodes();
  for (int index=0; index < nodes.getLength(); index++) {
    final Node child=nodes.item(index);
    if (child.getNodeType() == Node.TEXT_NODE) {
      element.removeChild(child);
    }
  }
  if (text != null) {
    element.appendChild(element.getOwnerDocument().createTextNode(TextUtils.escape(text)));
  }
}",0.86
1614,"public Credentials(final XmppURI uri,final String encodedPassword,final String encodingMethod){
  if (uri == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  this.uri=uri;
  this.encodedPassword=encodedPassword;
  this.encodingMethod=encodingMethod;
}","public Credentials(final XmppURI uri,final String encodedPassword,final String encodingMethod){
  if (uri == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (uri.getResource() == null) {
    this.uri=XmppURI.uri(uri.getNode(),uri.getHost(),""String_Node_Str"" + System.currentTimeMillis());
  }
 else {
    this.uri=uri;
  }
  this.encodedPassword=encodedPassword;
  this.encodingMethod=encodingMethod;
}",0.7431850789096126
1615,"public static void setFactory(Factory factory){
  EventBusFactory.factory=factory;
}","/** 
 * Changes the event bus factory
 * @param factory
 */
public static void setFactory(Factory factory){
  EventBusFactory.factory=factory;
}",0.7368421052631579
1616,"@Override public EmiteEventBus create(String eventBusName){
  return new GwtEmiteEventBus(eventBusName);
}","/** 
 * Create an event bus with the given name
 * @param eventBusName the bus name: using for logging
 * @return a new event bus
 */
public static EmiteEventBus create(String eventBusName){
  return EventBusFactory.factory.create(eventBusName);
}",0.4305949008498583
1617,"/** 
 * Will try to login session if PARAM_JID and PARAM_PASSWORD are present. <br/> PARAM_PASSWORD is optional if PARAM_JID value is set to 'anonymous'
 * @param session the session to be logged in
 * @return true if meta parameters value are presents, false otherwise
 */
public static final boolean loginFromMeta(final Session session){
  final String userJID=getMeta(PARAM_JID);
  final String password=getMeta(PARAM_PASSWORD);
  if (password != null && userJID != null) {
    final XmppURI jid=uri(userJID);
    session.login(jid,password);
    return true;
  }
 else   if (userJID != null && ""String_Node_Str"".equals(userJID.toLowerCase())) {
    session.login(Session.ANONYMOUS,null);
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Will try to login session if PARAM_JID and PARAM_PASSWORD are present. <br/> PARAM_PASSWORD is optional if PARAM_JID value is set to 'anonymous'
 * @param session the session to be logged in
 * @return true if meta parameters value are presents, false otherwise
 */
public static final boolean loginFromMeta(final Session session){
  final String userJID=getMeta(PARAM_JID);
  final String password=getMeta(PARAM_PASSWORD);
  String encodingMethod=getMeta(PARAM_PASSWORD_ENCODING);
  encodingMethod=encodingMethod != null ? encodingMethod : Credentials.ENCODING_NONE;
  if (password != null && userJID != null) {
    final XmppURI jid=uri(userJID);
    session.login(new Credentials(jid,password,encodingMethod));
    return true;
  }
 else   if (userJID != null && ""String_Node_Str"".equals(userJID.toLowerCase())) {
    session.login(Credentials.createAnonymous());
    return true;
  }
 else {
    return false;
  }
}",0.59245960502693
1618,"@Override public void onInstall(){
  registerDecorator(SessionComponent.class,new SessionComponent(container));
  register(Singleton.class,new Factory<Services>(Services.class){
    @Override public Services create(){
      return new GWTServices();
    }
  }
);
  register(Singleton.class,new Factory<Connection>(Connection.class){
    @Override public Connection create(){
      return new BoshConnection($(Services.class));
    }
  }
,new Factory<IMSessionManager>(IMSessionManager.class){
    @Override public IMSessionManager create(){
      return new IMSessionManager($(Connection.class));
    }
  }
,new Factory<Session>(Session.class){
    @Override public Session create(){
      GWT.log(""String_Node_Str"");
      final SessionImpl session=new SessionImpl($(Connection.class),$(SASLManager.class),$(ResourceBindingManager.class),$(IMSessionManager.class));
      return session;
    }
    @Override public void onAfterCreated(    final Session session){
      GWT.log(""String_Node_Str"");
      $(SessionComponent.class).init();
    }
  }
,new Factory<ResourceBindingManager>(ResourceBindingManager.class){
    @Override public ResourceBindingManager create(){
      return new ResourceBindingManager($(Connection.class));
    }
  }
,new Factory<SASLManager>(SASLManager.class){
    @Override public SASLManager create(){
      return new SASLManager($(Connection.class));
    }
  }
);
  register(SessionComponent.class,new Factory<SessionReady>(SessionReady.class){
    @Override public SessionReady create(){
      return new SessionReady($(Session.class));
    }
  }
);
}","@Override public void onInstall(){
  registerDecorator(SessionComponent.class,new SessionComponent(container));
  register(Singleton.class,new Factory<Services>(Services.class){
    @Override public Services create(){
      return new GWTServices();
    }
  }
);
  register(Singleton.class,new Factory<Connection>(Connection.class){
    @Override public Connection create(){
      return new BoshConnection($(Services.class));
    }
  }
,new Factory<IMSessionManager>(IMSessionManager.class){
    @Override public IMSessionManager create(){
      return new IMSessionManager($(Connection.class));
    }
  }
,new Factory<Session>(Session.class){
    @Override public Session create(){
      GWT.log(""String_Node_Str"");
      final SessionImpl session=new SessionImpl($(Connection.class),$(SASLManager.class),$(ResourceBindingManager.class),$(IMSessionManager.class));
      return session;
    }
    @Override public void onAfterCreated(    final Session session){
      GWT.log(""String_Node_Str"");
      $(SessionComponent.class).init();
    }
  }
,new Factory<ResourceBindingManager>(ResourceBindingManager.class){
    @Override public ResourceBindingManager create(){
      return new ResourceBindingManager($(Connection.class));
    }
  }
,new Factory<DecoderRegistry>(DecoderRegistry.class){
    @Override public DecoderRegistry create(){
      return new DecoderRegistry();
    }
  }
,new Factory<SASLManager>(SASLManager.class){
    @Override public SASLManager create(){
      return new SASLManager($(Connection.class),$(DecoderRegistry.class));
    }
  }
);
  register(SessionComponent.class,new Factory<SessionReady>(SessionReady.class){
    @Override public SessionReady create(){
      return new SessionReady($(Session.class));
    }
  }
);
}",0.865787896944278
1619,"public void setState(final State state){
  this.state=state;
  this.password=null;
}","public void setState(final State state){
  this.state=state;
}",0.8493150684931506
1620,"/** 
 * Testing purposes only! Not state logic!
 */
public AuthorizationTransaction(final XmppURI uri,final String password,final State state){
  this(uri,password);
  this.state=state;
}","public AuthorizationTransaction(final Credentials credentials){
  this.credentials=credentials;
}",0.4577464788732394
1621,"public SASLManager(final Connection connection){
  this.connection=connection;
  onAuthorized=new Event<AuthorizationTransaction>(""String_Node_Str"");
  install();
}","public SASLManager(final Connection connection,final DecoderRegistry decoders){
  this.connection=connection;
  this.decoders=decoders;
  onAuthorized=new Event<AuthorizationTransaction>(""String_Node_Str"");
  install();
}",0.8519480519480519
1622,"private boolean isAnonymous(final AuthorizationTransaction authorizationTransaction){
  return authorizationTransaction.uri == SASLManager.ANONYMOUS;
}","private boolean isAnonymous(final AuthorizationTransaction authorizationTransaction){
  return authorizationTransaction.getCredentials().isAnoymous();
}",0.8448844884488449
1623,"private IPacket createPlainAuthorization(final AuthorizationTransaction authorizationTransaction){
  final IPacket auth=new Packet(""String_Node_Str"",XMLNS).With(""String_Node_Str"",""String_Node_Str"");
  final String encoded=encode(authorizationTransaction.uri.getHost(),authorizationTransaction.uri.getNode(),authorizationTransaction.getPassword());
  auth.setText(encoded);
  return auth;
}","private IPacket createPlainAuthorization(final AuthorizationTransaction authorizationTransaction){
  final IPacket auth=new Packet(""String_Node_Str"",XMLNS).With(""String_Node_Str"",""String_Node_Str"");
  final Credentials credentials=authorizationTransaction.getCredentials();
  GWT.log(""String_Node_Str"" + credentials.getEncodingMethod());
  final PasswordDecoder decoder=decoders.getDecoder(credentials.getEncodingMethod());
  if (decoder == null) {
    throw new RuntimeException(""String_Node_Str"" + credentials.getEncodingMethod() + ""String_Node_Str""+ Credentials.ENCODING_BASE64);
  }
  final String decodedPassword=decoder.decode(credentials.getEncodingMethod(),credentials.getEncodedPassword());
  GWT.log(""String_Node_Str"" + decodedPassword);
  final String encoded=encodeForPlainMethod(credentials.getXmppUri().getHost(),credentials.getXmppUri().getNode(),decodedPassword);
  auth.setText(encoded);
  return auth;
}",0.3954198473282442
1624,"protected void fireMessage(Message message){
  onMessage.fire(message);
}","protected void fireMessage(final Message message){
  onMessage.fire(message);
}",0.9605263157894736
1625,"protected void fireIQ(IQ iq){
  onIQ.fire(iq);
}","protected void fireIQ(final IQ iq){
  onIQ.fire(iq);
}",0.9411764705882352
1626,"protected void setState(State state){
  this.state=state;
  onStateChanged.fire(this);
}","protected void setState(final State state){
  this.state=state;
  onStateChanged.fire(this);
}",0.967032967032967
1627,"protected void firePresence(Presence presence){
  onPresence.fire(presence);
}","protected void firePresence(final Presence presence){
  onPresence.fire(presence);
}",0.9629629629629628
1628,"public AbstractSession(){
  this.onStateChanged=new Event<Session>(""String_Node_Str"");
  this.onPresence=new Event<Presence>(""String_Node_Str"");
  this.onMessage=new Event<Message>(""String_Node_Str"");
  this.onIQ=new Event<IQ>(""String_Node_Str"");
  state=State.disconnected;
}","public AbstractSession(){
  onStateChanged=new Event<Session>(""String_Node_Str"");
  onPresence=new Event<Presence>(""String_Node_Str"");
  onMessage=new Event<Message>(""String_Node_Str"");
  onIQ=new Event<IQ>(""String_Node_Str"");
  state=State.disconnected;
}",0.962406015037594
1629,"public SessionImpl(final Connection connection,final SASLManager saslManager,final ResourceBindingManager bindingManager,final IMSessionManager iMSessionManager){
  this.connection=connection;
  iqManager=new IQManager();
  queuedStanzas=new ArrayList<IPacket>();
  connection.onStanzaReceived(new Listener<IPacket>(){
    public void onEvent(    final IPacket stanza){
      final String name=stanza.getName();
      if (name.equals(""String_Node_Str"")) {
        fireMessage(new Message(stanza));
      }
 else       if (name.equals(""String_Node_Str"")) {
        firePresence(new Presence(stanza));
      }
 else       if (name.equals(""String_Node_Str"")) {
        final String type=stanza.getAttribute(""String_Node_Str"");
        if (""String_Node_Str"".equals(type) || ""String_Node_Str"".equals(type)) {
          fireIQ(new IQ(stanza));
        }
 else {
          iqManager.handle(stanza);
        }
      }
 else       if (transaction != null && ""String_Node_Str"".equals(name) && stanza.hasChild(""String_Node_Str"")) {
        saslManager.sendAuthorizationRequest(transaction);
        transaction=null;
      }
    }
  }
);
  connection.onError(new Listener<String>(){
    public void onEvent(    final String msg){
      GWT.log(""String_Node_Str"" + msg,null);
      setState(State.error);
    }
  }
);
  connection.onDisconnected(new Listener<String>(){
    public void onEvent(    final String parameter){
      setState(State.disconnected);
    }
  }
);
  saslManager.onAuthorized(new Listener<AuthorizationTransaction>(){
    public void onEvent(    final AuthorizationTransaction ticket){
      if (ticket.getState() == AuthorizationTransaction.State.succeed) {
        setState(Session.State.authorized);
        connection.restartStream();
        bindingManager.bindResource(ticket.getXmppUri().getResource());
      }
 else {
        setState(Session.State.notAuthorized);
        disconnect();
      }
    }
  }
);
  bindingManager.onBinded(new Listener<XmppURI>(){
    public void onEvent(    final XmppURI uri){
      iMSessionManager.requestSession(uri);
    }
  }
);
  iMSessionManager.onSessionCreated(new Listener<XmppURI>(){
    public void onEvent(    final XmppURI uri){
      setLoggedIn(uri);
    }
  }
);
}","public SessionImpl(final Connection connection,final SASLManager saslManager,final ResourceBindingManager bindingManager,final IMSessionManager iMSessionManager){
  this.connection=connection;
  iqManager=new IQManager();
  queuedStanzas=new ArrayList<IPacket>();
  connection.onStanzaReceived(new Listener<IPacket>(){
    public void onEvent(    final IPacket stanza){
      final String name=stanza.getName();
      if (name.equals(""String_Node_Str"")) {
        fireMessage(new Message(stanza));
      }
 else       if (name.equals(""String_Node_Str"")) {
        firePresence(new Presence(stanza));
      }
 else       if (name.equals(""String_Node_Str"")) {
        final String type=stanza.getAttribute(""String_Node_Str"");
        if (""String_Node_Str"".equals(type) || ""String_Node_Str"".equals(type)) {
          fireIQ(new IQ(stanza));
        }
 else {
          iqManager.handle(stanza);
        }
      }
 else       if (transaction != null && ""String_Node_Str"".equals(name) && stanza.hasChild(""String_Node_Str"")) {
        saslManager.sendAuthorizationRequest(transaction);
        transaction=null;
      }
    }
  }
);
  connection.onError(new Listener<String>(){
    public void onEvent(    final String msg){
      GWT.log(""String_Node_Str"" + msg,null);
      setState(State.error);
    }
  }
);
  connection.onDisconnected(new Listener<String>(){
    public void onEvent(    final String parameter){
      setState(State.disconnected);
    }
  }
);
  saslManager.onAuthorized(new Listener<AuthorizationTransaction>(){
    public void onEvent(    final AuthorizationTransaction ticket){
      if (ticket.getState() == AuthorizationTransaction.State.succeed) {
        setState(Session.State.authorized);
        connection.restartStream();
        String resource=ticket.getXmppUri().getResource();
        if (resource == null) {
          resource=""String_Node_Str"" + System.currentTimeMillis();
        }
        bindingManager.bindResource(resource);
      }
 else {
        setState(Session.State.notAuthorized);
        disconnect();
      }
    }
  }
);
  bindingManager.onBinded(new Listener<XmppURI>(){
    public void onEvent(    final XmppURI uri){
      iMSessionManager.requestSession(uri);
    }
  }
);
  iMSessionManager.onSessionCreated(new Listener<XmppURI>(){
    public void onEvent(    final XmppURI uri){
      setLoggedIn(uri);
    }
  }
);
}",0.956786102062975
1630,"public void setShow(final Show value){
  setTextToChild(""String_Node_Str"",(value != null && (value != Show.notSpecified || value != Show.unknown)) ? value.toString() : null);
}","public void setShow(final Show value){
  setTextToChild(""String_Node_Str"",value != null && value != Show.notSpecified && value != Show.unknown ? value.toString() : null);
}",0.9770114942528736
1631,"@Test public void shouldSetShow(){
  final Presence presence=new Presence();
  for (  final Show value : Show.values()) {
    presence.setShow(value);
    assertSame(value,presence.getShow());
  }
}","@Test public void shouldSetShow(){
  final Presence presence=new Presence();
  for (  final Show value : Show.values()) {
    presence.setShow(value);
    if (value == Show.unknown) {
      assertSame(Show.notSpecified,presence.getShow());
    }
 else {
      assertSame(value,presence.getShow());
    }
  }
}",0.7613412228796844
1632,"public static void send(final String httpBase,final String request,final ConnectorCallback listener) throws ConnectorException {
  GWT.log((""String_Node_Str"" + request),null);
  final RequestBuilder builder=new RequestBuilder(RequestBuilder.POST,httpBase);
  try {
    Request req=builder.sendRequest(request,new RequestCallback(){
      public void onError(      final Request req,      final Throwable throwable){
        GWT.log((""String_Node_Str"" + throwable),null);
        activeRequests.remove(req);
        listener.onError(request,throwable);
      }
      public void onResponseReceived(      final Request req,      final Response res){
        GWT.log((""String_Node_Str"" + res.getText()),null);
        activeRequests.remove(req);
        listener.onResponseReceived(res.getStatusCode(),res.getText(),request);
      }
    }
);
    activeRequests.add(req);
  }
 catch (  final RequestException e) {
    throw new ConnectorException(e.getMessage());
  }
catch (  final Exception e) {
    GWT.log((""String_Node_Str"" + e),null);
    throw new ConnectorException(e.getMessage());
  }
}","public static void send(final String httpBase,final String request,final ConnectorCallback listener) throws ConnectorException {
  GWT.log((""String_Node_Str"" + request),null);
  final RequestBuilder builder=new RequestBuilder(RequestBuilder.POST,httpBase);
  builder.setHeader(""String_Node_Str"",""String_Node_Str"");
  try {
    Request req=builder.sendRequest(request,new RequestCallback(){
      public void onError(      final Request req,      final Throwable throwable){
        GWT.log((""String_Node_Str"" + throwable),null);
        activeRequests.remove(req);
        listener.onError(request,throwable);
      }
      public void onResponseReceived(      final Request req,      final Response res){
        GWT.log((""String_Node_Str"" + res.getText()),null);
        activeRequests.remove(req);
        listener.onResponseReceived(res.getStatusCode(),res.getText(),request);
      }
    }
);
    activeRequests.add(req);
  }
 catch (  final RequestException e) {
    throw new ConnectorException(e.getMessage());
  }
catch (  final Exception e) {
    GWT.log((""String_Node_Str"" + e),null);
    throw new ConnectorException(e.getMessage());
  }
}",0.9741532976827094
1633,"public void onModuleLoad(){
  Suco.install(this);
  if (!PageAssist.isMetaTrue(""String_Node_Str"")) {
    Suco.get(AutoConfig.class);
  }
}","public void onModuleLoad(){
  Suco.install(this);
  if (PageAssist.isMetaTrue(""String_Node_Str"")) {
    Suco.get(AutoConfig.class);
  }
}",0.9963636363636365
1634,"@Override public void search(final HashMap<String,String> query,final ResultListener<List<SearchResultItem>> listener){
  final List<IPacket> queryPacket=new ArrayList<IPacket>();
  for (  final String field : query.keySet()) {
    final Packet child=new Packet(field);
    child.setText(query.get(field));
    queryPacket.add(child);
  }
  searchGeneric(queryPacket,new Listener<IPacket>(){
    @Override public void onEvent(    final IPacket received){
      final IQ response=new IQ(received);
      if (IQ.isSuccess(response)) {
        listener.onSuccess(processResults(session.getCurrentUser(),response.getFirstChild(filterQuery)));
      }
 else {
        listener.onFailure(null);
      }
    }
  }
);
}","@Override public void search(final HashMap<String,String> query,final ResultListener<List<SearchResultItem>> listener){
  final List<IPacket> queryPacket=new ArrayList<IPacket>();
  for (  final String field : query.keySet()) {
    final Packet child=new Packet(field);
    child.setText(query.get(field));
    queryPacket.add(child);
  }
  searchGeneric(IQ.Type.get,queryPacket,new Listener<IPacket>(){
    @Override public void onEvent(    final IPacket received){
      final IQ response=new IQ(received);
      if (IQ.isSuccess(response)) {
        listener.onSuccess(processResults(session.getCurrentUser(),response.getFirstChild(filterQuery)));
      }
 else {
        listener.onFailure(null);
      }
    }
  }
);
}",0.99163179916318
1635,"public SearchManagerImpl(final Session session){
  this.session=session;
  this.filterQuery=MatcherFactory.byNameAndXMLNS(""String_Node_Str"",IQ_SEARCH);
}","public SearchManagerImpl(final Session session){
  this.session=session;
  filterQuery=MatcherFactory.byNameAndXMLNS(""String_Node_Str"",IQ_SEARCH);
}",0.9833887043189368
1636,"private void searchGeneric(final List<IPacket> queryChilds,final Listener<IPacket> onResult){
  if (session.getState() == State.ready) {
    final IQ iq=new IQ(Type.set,host).From(session.getCurrentUser()).With(XML_LANG,""String_Node_Str"");
    final IPacket queryPacket=iq.addQuery(IQ_SEARCH);
    for (    final IPacket child : queryChilds) {
      queryPacket.addChild(child);
    }
    session.sendIQ(SEARCH_CATEGORY,iq,new Listener<IPacket>(){
      public void onEvent(      final IPacket received){
        onResult.onEvent(received);
      }
    }
);
  }
 else {
    throw new RuntimeException(SHOULD_BE_CONNECTED);
  }
}","private void searchGeneric(final IQ.Type type,final List<IPacket> queryChilds,final Listener<IPacket> onResult){
  if (session.getState() == State.ready) {
    final IQ iq=new IQ(type,host).From(session.getCurrentUser()).With(XML_LANG,""String_Node_Str"");
    final IPacket queryPacket=iq.addQuery(IQ_SEARCH);
    for (    final IPacket child : queryChilds) {
      queryPacket.addChild(child);
    }
    session.sendIQ(SEARCH_CATEGORY,iq,new Listener<IPacket>(){
      public void onEvent(      final IPacket received){
        onResult.onEvent(received);
      }
    }
);
  }
 else {
    throw new RuntimeException(SHOULD_BE_CONNECTED);
  }
}",0.980330448465775
1637,"/** 
 * Generates a new signature key pair. Uses up to <code>B+1</code> threads if multiple processors are available.
 * @return a key pair
 */
public SignatureKeyPair generateKeyPair(){
  int processors=Runtime.getRuntime().availableProcessors();
  SignaturePrivateKey priv=new SignaturePrivateKey();
  if (processors == 1)   for (int k=params.B; k >= 0; k--)   priv.add(generateBoundedBasis());
 else {
    List<Future<Basis>> bases=new ArrayList<Future<Basis>>();
    int numThreads=Math.min(params.B,processors - 1);
    if (numThreads > 0) {
      ExecutorService executor=Executors.newFixedThreadPool(numThreads);
      for (int k=params.B - 1; k >= 0; k--)       bases.add(executor.submit(new BasisGenerationTask()));
      executor.shutdown();
    }
    Basis basis0=generateBoundedBasis();
    priv.add(basis0);
    for (    Future<Basis> basis : bases)     try {
      priv.add(basis.get());
    }
 catch (    Exception e) {
      throw new NtruException(e);
    }
  }
  SignaturePublicKey pub=new SignaturePublicKey(priv.getBasis(0).h,params);
  SignatureKeyPair kp=new SignatureKeyPair(priv,pub);
  return kp;
}","/** 
 * Generates a new signature key pair. Uses up to <code>B+1</code> threads if multiple processors are available.
 * @return a key pair
 */
public SignatureKeyPair generateKeyPair(){
  int processors=Runtime.getRuntime().availableProcessors();
  SignaturePrivateKey priv=new SignaturePrivateKey();
  if (processors == 1)   for (int k=params.B; k >= 0; k--)   priv.add(generateBoundedBasis());
 else {
    List<Future<Basis>> bases=new ArrayList<Future<Basis>>();
    int numThreads=Math.min(params.B,processors - 1);
    if (numThreads > 0) {
      ExecutorService executor=Executors.newFixedThreadPool(numThreads);
      for (int k=params.B - 1; k >= 0; k--)       bases.add(executor.submit(new BasisGenerationTask()));
      executor.shutdown();
    }
    Basis basis0=generateBoundedBasis();
    for (    Future<Basis> basis : bases)     try {
      priv.add(basis.get());
    }
 catch (    Exception e) {
      throw new NtruException(e);
    }
    priv.add(basis0);
  }
  SignaturePublicKey pub=new SignaturePublicKey(priv.getBasis(params.B).h,params);
  SignatureKeyPair kp=new SignatureKeyPair(priv,pub);
  return kp;
}",0.9764758100310696
1638,"/** 
 * Start MinecraftLandGenerator (Command Line Interface)
 * @author Corrodias, Morlok8k
 * @param args
 */
private static void runCLI(){
  final File backupLevel;
  final File serverLevel;
  Startup.initialStart();
  if (Startup.programArguments()) {
    Out.err(""String_Node_Str"");
    return;
  }
  if (Startup.confFile()) {
    Out.err(""String_Node_Str"");
    return;
  }
  try {
    if (Setup.doSetup()) {
      Out.err(""String_Node_Str"");
      return;
    }
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  Out.out(""String_Node_Str"" + var.worldPath + ""String_Node_Str""+ var.increment+ ""String_Node_Str""+ var.javaLine);
  Out.out(""String_Node_Str"");
  try {
    final long generationStartTimeTracking=System.currentTimeMillis();
    final boolean serverLaunch=Server.runMinecraft();
    if (!(serverLaunch)) {
      System.exit(1);
    }
    if ((var.xRange == 0) & (var.zRange == 0)) {
      return;
    }
    FileWrite.AppendTxtFile(var.worldPath + var.fileSeparator + var.logFile,""String_Node_Str"" + var.PROG_NAME + ""String_Node_Str""+ var.VERSION+ ""String_Node_Str""+ SelfAware.JVMinfo()+ var.newLine+ ""String_Node_Str""+ var.MC_Server_Version+ var.newLine+ ""String_Node_Str""+ var.dateFormat.format(generationStartTimeTracking)+ var.newLine+ ""String_Node_Str""+ var.xRange+ ""String_Node_Str""+ var.zRange+ var.newLine);
    Out.out(""String_Node_Str"");
    serverLevel=new File(var.worldPath + var.fileSeparator + ""String_Node_Str"");
    backupLevel=new File(var.worldPath + var.fileSeparator + ""String_Node_Str"");
    Out.out(""String_Node_Str"");
    Misc.copyFile(serverLevel,backupLevel);
    Out.out(""String_Node_Str"");
    final Coordinates spawn=SpawnPoint.getSpawn(serverLevel);
    Out.out(""String_Node_Str"" + spawn);
    FileWrite.AppendTxtFile(var.worldPath + var.fileSeparator + var.logFile,""String_Node_Str"" + var.randomSeed + var.newLine+ ""String_Node_Str""+ spawn.toString()+ var.newLine);
    boolean overridden=false;
    if (var.xOffset == null) {
      var.xOffset=spawn.getX();
    }
 else {
      overridden=true;
    }
    if (var.zOffset == null) {
      var.zOffset=spawn.getZ();
    }
 else {
      overridden=true;
    }
    if (var.useChunks) {
      var.xRange=(int)(Math.ceil(((double)var.xRange) / ((double)16))) * 16;
      var.zRange=(int)(Math.ceil(((double)var.zRange) / ((double)16))) * 16;
      var.xOffset=(int)(Math.ceil(((double)var.xOffset) / ((double)16))) * 16;
      var.zOffset=(int)(Math.ceil(((double)var.zOffset) / ((double)16))) * 16;
    }
 else {
      var.xRange=(int)(Math.ceil(((double)var.xRange) / ((double)512))) * 512;
      var.zRange=(int)(Math.ceil(((double)var.zRange) / ((double)512))) * 512;
      var.xOffset=(int)(Math.ceil(((double)var.xOffset) / ((double)512))) * 512;
      var.zOffset=(int)(Math.ceil(((double)var.zOffset) / ((double)512))) * 512;
    }
    if (overridden) {
      Out.out(""String_Node_Str"" + var.xOffset + ""String_Node_Str""+ var.zOffset+ ""String_Node_Str"");
    }
    Out.out(""String_Node_Str"");
    double xLoops, zLoops;
    int curXloops=0;
    int curZloops=0;
    int xRangeAdj=0;
    int zRangeAdj=0;
    xLoops=((double)var.xRange / (double)var.increment);
    xLoops=Math.ceil(xLoops);
    xRangeAdj=(int)(xLoops * var.increment);
    xLoops=xLoops + 1;
    zLoops=((double)var.zRange / (double)var.increment);
    zLoops=Math.ceil(zLoops);
    zRangeAdj=(int)(zLoops * var.increment);
    zLoops=zLoops + 1;
    Out.out(""String_Node_Str"");
    int totalIterations=(int)(xLoops * zLoops);
    int currentIteration=0;
    long differenceTime=System.currentTimeMillis();
    Long timeTracking=0L;
    final ArrayList<Coordinates> launchList=new ArrayList<Coordinates>(totalIterations);
    for (int currentX=0; currentX <= (xRangeAdj / 2); currentX+=var.increment) {
      curXloops++;
      boolean eastEdgeReached=false;
      if (curXloops == 1) {
        currentX=(((0 - var.xRange) / 2) + (var.incrementFull / 2));
      }
 else       if (currentX >= ((xRangeAdj / 2) - (var.increment / 2))) {
        currentX=((var.xRange / 2) - (var.incrementFull / 2));
        eastEdgeReached=true;
      }
      for (int currentZ=0; currentZ <= (zRangeAdj / 2); currentZ+=var.increment) {
        currentIteration++;
        curZloops++;
        boolean southEdgeReached=false;
        if (curZloops == 1) {
          currentZ=(((0 - var.zRange) / 2) + (var.incrementFull / 2));
        }
 else         if (currentZ >= ((zRangeAdj / 2) - (var.increment / 2))) {
          currentZ=((var.zRange / 2) - (var.incrementFull / 2));
          southEdgeReached=true;
        }
{
          final Coordinates tempCoords=new Coordinates(currentX + var.xOffset,64,currentZ + var.zOffset);
          launchList.add(tempCoords);
          if (var.testing) {
            System.out.println(tempCoords);
          }
        }
        if (curZloops == 1) {
          currentZ=(int)((Math.ceil((((0 - zRangeAdj) / 2) / var.increment))) * var.increment);
        }
        if (southEdgeReached) {
          currentZ=zRangeAdj;
        }
      }
      curZloops=0;
      if (curXloops == 1) {
        currentX=(int)((Math.ceil((((0 - xRangeAdj) / 2) / var.increment))) * var.increment);
      }
      if (eastEdgeReached) {
        currentX=xRangeAdj;
      }
    }
    final ArrayList<Coordinates> removeList=FileRead.readArrayListCoordLog(var.worldPath + var.fileSeparator + var.logFile);
    if (!(removeList.isEmpty())) {
      Arraylist.arrayListRemove(launchList,removeList);
    }
    removeList.clear();
    System.gc();
    currentIteration=0;
    totalIterations=launchList.size();
    Coordinates xyz=null;
    final Iterator<Coordinates> coordArrayIterator=launchList.iterator();
    while (coordArrayIterator.hasNext()) {
      currentIteration++;
      xyz=coordArrayIterator.next();
      String percentDone=Double.toString((((double)currentIteration - 1) / totalIterations) * 100);
      final int percentIndex=((percentDone.indexOf(""String_Node_Str"") + 3) > percentDone.length()) ? percentDone.length() : (percentDone.indexOf(""String_Node_Str"") + 3);
      percentDone=percentDone.substring(0,(percentDone.indexOf(""String_Node_Str"") == -1 ? percentDone.length() : percentIndex));
      Out.out(""String_Node_Str"" + xyz + ""String_Node_Str""+ currentIteration+ ""String_Node_Str""+ totalIterations+ ""String_Node_Str""+ percentDone+ ""String_Node_Str"");
      timeTracking=System.currentTimeMillis();
      differenceTime=(timeTracking - generationStartTimeTracking) / (currentIteration + 1);
      differenceTime*=1 + (totalIterations - currentIteration);
      Out.out(""String_Node_Str"" + Time.displayTime(differenceTime));
      SpawnPoint.setSpawn(serverLevel,xyz);
      boolean serverSuccess=false;
      serverSuccess=Server.runMinecraft();
      Out.out(""String_Node_Str"");
      if (serverSuccess) {
        FileWrite.AppendTxtFile(var.worldPath + var.fileSeparator + var.logFile,xyz.toString() + var.newLine);
      }
 else {
        System.exit(1);
      }
    }
    if (currentIteration == 0) {
      Out.out(""String_Node_Str"");
    }
 else {
      Out.out(""String_Node_Str"");
    }
    Misc.copyFile(backupLevel,serverLevel);
    backupLevel.delete();
    Out.out(""String_Node_Str"");
    Out.out(""String_Node_Str"" + Time.displayTime(var.startTime,System.currentTimeMillis()));
    Time.waitTenSec(false);
    if (var.webLaunch) {
      if (java.awt.GraphicsEnvironment.isHeadless()) {
        var.webLaunch=false;
      }
      final File web1=new File(""String_Node_Str"");
      final File web2=new File(""String_Node_Str"");
      final File web3=new File(""String_Node_Str"");
      if (web2.exists() || (web1.exists() || web3.exists())) {
        var.webLaunch=false;
      }
    }
    if (var.webLaunch && java.awt.Desktop.isDesktopSupported()) {
      final URI splashPage=URI.create(""String_Node_Str"");
      try {
        java.awt.Desktop.getDesktop().browse(splashPage);
      }
 catch (      final IOException e) {
        Out.err(""String_Node_Str"" + e.getLocalizedMessage());
      }
    }
 else {
      Out.out(""String_Node_Str"");
      Out.out(""String_Node_Str"" + var.WEBSITE);
      Out.out(""String_Node_Str"");
    }
  }
 catch (  final IOException ex) {
    Logger.getLogger(Main.class.getName()).log(Level.SEVERE,ex.getMessage(),ex);
  }
}","/** 
 * Start MinecraftLandGenerator (Command Line Interface)
 * @author Corrodias, Morlok8k
 * @param args
 */
private static void runCLI(){
  final File backupLevel;
  final File serverLevel;
  Startup.initialStart();
  if (Startup.programArguments()) {
    Out.err(""String_Node_Str"");
    return;
  }
  if (Startup.confFile()) {
    Out.err(""String_Node_Str"");
    return;
  }
  try {
    if (Setup.doSetup()) {
      Out.err(""String_Node_Str"");
      return;
    }
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  Out.out(""String_Node_Str"" + var.worldPath + ""String_Node_Str""+ var.increment+ ""String_Node_Str""+ var.javaLine);
  Out.out(""String_Node_Str"");
  try {
    final long generationStartTimeTracking=System.currentTimeMillis();
    final boolean serverLaunch=true;
    if (!(serverLaunch)) {
      System.exit(1);
    }
    if ((var.xRange == 0) & (var.zRange == 0)) {
      return;
    }
    FileWrite.AppendTxtFile(var.worldPath + var.fileSeparator + var.logFile,""String_Node_Str"" + var.PROG_NAME + ""String_Node_Str""+ var.VERSION+ ""String_Node_Str""+ SelfAware.JVMinfo()+ var.newLine+ ""String_Node_Str""+ var.MC_Server_Version+ var.newLine+ ""String_Node_Str""+ var.dateFormat.format(generationStartTimeTracking)+ var.newLine+ ""String_Node_Str""+ var.xRange+ ""String_Node_Str""+ var.zRange+ var.newLine);
    Out.out(""String_Node_Str"");
    serverLevel=new File(var.worldPath + var.fileSeparator + ""String_Node_Str"");
    backupLevel=new File(var.worldPath + var.fileSeparator + ""String_Node_Str"");
    Out.out(""String_Node_Str"");
    Misc.copyFile(serverLevel,backupLevel);
    Out.out(""String_Node_Str"");
    final Coordinates spawn=SpawnPoint.getSpawn(serverLevel);
    Out.out(""String_Node_Str"" + spawn);
    FileWrite.AppendTxtFile(var.worldPath + var.fileSeparator + var.logFile,""String_Node_Str"" + var.randomSeed + var.newLine+ ""String_Node_Str""+ spawn.toString()+ var.newLine);
    boolean overridden=false;
    if (var.xOffset == null) {
      var.xOffset=spawn.getX();
    }
 else {
      overridden=true;
    }
    if (var.zOffset == null) {
      var.zOffset=spawn.getZ();
    }
 else {
      overridden=true;
    }
    double xR=0, zR=0, xO=0, zO=0;
    if (var.useChunks) {
      xR=var.xRange;
      xR=xR / 16;
      xR=Math.ceil(xR);
      xR=xR * 16;
      zR=var.zRange;
      zR=zR / 16;
      zR=Math.ceil(zR);
      zR=zR * 16;
      xO=var.xOffset;
      xO=xO / 16;
      xO=Math.round(xO);
      xO=xO * 16;
      zO=var.zOffset;
      zO=zO / 16;
      zO=Math.round(zO);
      zO=zO * 16;
    }
 else {
      xR=var.xRange;
      xR=xR / 512;
      xR=Math.ceil(xR);
      xR=xR * 512;
      zR=var.zRange;
      zR=zR / 512;
      zR=Math.ceil(zR);
      zR=zR * 512;
      xO=var.xOffset;
      xO=xO / 512;
      xO=Math.round(xO);
      xO=xO * 512;
      zO=var.zOffset;
      zO=zO / 512;
      zO=Math.round(zO);
      zO=zO * 512;
    }
    var.xRange=(int)Math.ceil(xR);
    var.zRange=(int)Math.ceil(zR);
    var.xOffset=(int)Math.ceil(xO);
    var.zOffset=(int)Math.ceil(zO);
    if (overridden) {
      Out.out(""String_Node_Str"" + var.xOffset + ""String_Node_Str""+ var.zOffset+ ""String_Node_Str"");
    }
 else {
      Out.out(""String_Node_Str"" + var.xOffset + ""String_Node_Str""+ var.zOffset+ ""String_Node_Str"");
    }
    Out.out(""String_Node_Str"");
    double xLoops, zLoops;
    long curXloops=0;
    long curZloops=0;
    double xRangeAdj=0;
    double zRangeAdj=0;
    xRangeAdj=var.xRange - var.incrementFull;
    xRangeAdj=xRangeAdj / var.increment;
    xRangeAdj=Math.ceil(xRangeAdj);
    xRangeAdj=xRangeAdj + 1;
    xRangeAdj=xRangeAdj * var.increment;
    double inc=var.increment * 2;
    xLoops=(var.xRange - var.incrementFull) / inc;
    xLoops=Math.ceil(xLoops);
    xLoops=xLoops + xLoops + 1;
    zRangeAdj=var.zRange - var.incrementFull;
    zRangeAdj=zRangeAdj / var.increment;
    zRangeAdj=Math.ceil(zRangeAdj);
    zRangeAdj=zRangeAdj + 1;
    zRangeAdj=zRangeAdj * var.increment;
    zLoops=(var.zRange - var.incrementFull) / inc;
    zLoops=Math.ceil(zLoops);
    zLoops=zLoops + zLoops + 1;
    Out.out(""String_Node_Str"");
    long totalIterations=(long)(xLoops * zLoops);
    Out.out(""String_Node_Str"" + totalIterations);
    if (totalIterations > Integer.MAX_VALUE) {
      Out.err(""String_Node_Str"");
      backupLevel.delete();
      Out.out(""String_Node_Str"");
      System.exit(0);
    }
    long currentIteration=0;
    long differenceTime=System.currentTimeMillis();
    Long timeTracking=0L;
    ArrayList<Coordinates> launchList=new ArrayList<>(0);
    try {
      launchList=new ArrayList<>((int)totalIterations);
    }
 catch (    Exception e1) {
      e1.printStackTrace();
      Out.err(""String_Node_Str"");
      backupLevel.delete();
      Out.out(""String_Node_Str"");
      System.exit(0);
    }
    for (long currentX=0; currentX <= (xRangeAdj / 2); currentX+=var.increment) {
      curXloops++;
      boolean eastEdgeReached=false;
      if (curXloops == 1) {
        currentX=(((0 - var.xRange) / 2) + (var.incrementFull / 2));
      }
 else       if (currentX >= ((xRangeAdj / 2) - (var.increment / 2))) {
        currentX=((var.xRange / 2) - (var.incrementFull / 2));
        eastEdgeReached=true;
      }
      for (long currentZ=0; currentZ <= (zRangeAdj / 2); currentZ+=var.increment) {
        currentIteration++;
        curZloops++;
        boolean southEdgeReached=false;
        if (curZloops == 1) {
          currentZ=(((0 - var.zRange) / 2) + (var.incrementFull / 2));
        }
 else         if (currentZ >= ((zRangeAdj / 2) - (var.increment / 2))) {
          currentZ=((var.zRange / 2) - (var.incrementFull / 2));
          southEdgeReached=true;
        }
{
          if (currentIteration % 10000000 == 0) {
            String percentDone=Double.toString((((double)currentIteration) / totalIterations) * 100);
            final int percentIndex=((percentDone.indexOf(""String_Node_Str"") + 3) > percentDone.length()) ? percentDone.length() : (percentDone.indexOf(""String_Node_Str"") + 3);
            percentDone=percentDone.substring(0,(percentDone.indexOf(""String_Node_Str"") == -1 ? percentDone.length() : percentIndex));
            Out.out(""String_Node_Str"" + currentIteration + ""String_Node_Str""+ totalIterations+ ""String_Node_Str""+ percentDone+ ""String_Node_Str"");
          }
          final Coordinates tempCoords=new Coordinates((int)currentX + var.xOffset,64,(int)currentZ + var.zOffset);
          if (var.testing) {
            System.out.println(tempCoords);
          }
        }
        if (curZloops == 1) {
          currentZ=(long)((Math.ceil((((0 - zRangeAdj) / 2) / var.increment))) * var.increment);
        }
        if (southEdgeReached) {
          currentZ=(long)zRangeAdj;
        }
      }
      curZloops=0;
      if (curXloops == 1) {
        currentX=(long)((Math.ceil((((0 - xRangeAdj) / 2) / var.increment))) * var.increment);
      }
      if (eastEdgeReached) {
        currentX=(long)xRangeAdj;
      }
    }
    String pD=Double.toString((((double)currentIteration) / totalIterations) * 100);
    final int pI=((pD.indexOf(""String_Node_Str"") + 3) > pD.length()) ? pD.length() : (pD.indexOf(""String_Node_Str"") + 3);
    pD=pD.substring(0,(pD.indexOf(""String_Node_Str"") == -1 ? pD.length() : pI));
    Out.out(""String_Node_Str"" + currentIteration + ""String_Node_Str""+ totalIterations+ ""String_Node_Str""+ pD+ ""String_Node_Str"");
    final ArrayList<Coordinates> removeList=FileRead.readArrayListCoordLog(var.worldPath + var.fileSeparator + var.logFile);
    Out.out(""String_Node_Str"");
    if (!(removeList.isEmpty())) {
      Arraylist.arrayListRemove(launchList,removeList);
    }
    removeList.clear();
    System.gc();
    currentIteration=0;
    Coordinates xyz=null;
    final Iterator<Coordinates> coordArrayIterator=launchList.iterator();
    while (coordArrayIterator.hasNext()) {
      currentIteration++;
      xyz=coordArrayIterator.next();
      String percentDone=Double.toString((((double)currentIteration - 1) / totalIterations) * 100);
      final int percentIndex=((percentDone.indexOf(""String_Node_Str"") + 3) > percentDone.length()) ? percentDone.length() : (percentDone.indexOf(""String_Node_Str"") + 3);
      percentDone=percentDone.substring(0,(percentDone.indexOf(""String_Node_Str"") == -1 ? percentDone.length() : percentIndex));
      Out.out(""String_Node_Str"" + xyz + ""String_Node_Str""+ currentIteration+ ""String_Node_Str""+ totalIterations+ ""String_Node_Str""+ percentDone+ ""String_Node_Str"");
      timeTracking=System.currentTimeMillis();
      differenceTime=(timeTracking - generationStartTimeTracking) / (currentIteration + 1);
      differenceTime*=1 + (totalIterations - currentIteration);
      Out.out(""String_Node_Str"" + Time.displayTime(differenceTime));
      SpawnPoint.setSpawn(serverLevel,xyz);
      boolean serverSuccess=false;
      serverSuccess=Server.runMinecraft();
      Out.out(""String_Node_Str"");
      if (serverSuccess) {
        FileWrite.AppendTxtFile(var.worldPath + var.fileSeparator + var.logFile,xyz.toString() + var.newLine);
      }
 else {
        System.exit(1);
      }
    }
    if (currentIteration == 0) {
      Out.out(""String_Node_Str"");
    }
 else {
      Out.out(""String_Node_Str"");
    }
    Misc.copyFile(backupLevel,serverLevel);
    backupLevel.delete();
    Out.out(""String_Node_Str"");
    Out.out(""String_Node_Str"" + Time.displayTime(var.startTime,System.currentTimeMillis()));
    Time.waitTenSec(false);
    if (var.webLaunch) {
      if (java.awt.GraphicsEnvironment.isHeadless()) {
        var.webLaunch=false;
      }
      final File web1=new File(""String_Node_Str"");
      final File web2=new File(""String_Node_Str"");
      final File web3=new File(""String_Node_Str"");
      if (web2.exists() || (web1.exists() || web3.exists())) {
        var.webLaunch=false;
      }
    }
    if (var.webLaunch && java.awt.Desktop.isDesktopSupported()) {
      final URI splashPage=URI.create(""String_Node_Str"");
      try {
        java.awt.Desktop.getDesktop().browse(splashPage);
      }
 catch (      final IOException e) {
        Out.err(""String_Node_Str"" + e.getLocalizedMessage());
      }
    }
 else {
      Out.out(""String_Node_Str"");
      Out.out(""String_Node_Str"" + var.WEBSITE);
      Out.out(""String_Node_Str"");
    }
  }
 catch (  final IOException ex) {
    Logger.getLogger(Main.class.getName()).log(Level.SEVERE,ex.getMessage(),ex);
  }
}",0.7164627602489805
1639,"/** 
 * Displays or returns Help information
 * @param SysOut <br> Set TRUE to display info to System.out. (Returns null) <br> Set FALSE to return info as String.
 * @return
 * @author Morlok8k
 */
public static String showHelp(final boolean SysOut){
  String Str=null;
  String n=var.newLine;
  if (SysOut) {
    n=n + var.MLG;
  }
  Str=""String_Node_Str"" + var.MLGFileNameShort + ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MinecraftLandGeneratorConf+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.defaultReadmeFile+ n+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ var.MinecraftLandGeneratorConf+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ var.MinecraftLandGeneratorConf+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n;
  String returnString=null;
  if (SysOut) {
    Out.out(Str);
    Out.out(""String_Node_Str"");
  }
 else {
    returnString=Str;
  }
  return returnString;
}","/** 
 * Displays or returns Help information
 * @param SysOut <br> Set TRUE to display info to System.out. (Returns null) <br> Set FALSE to return info as String.
 * @return
 * @author Morlok8k
 */
public static String showHelp(final boolean SysOut){
  String Str=null;
  String n=var.newLine;
  if (SysOut) {
    n=n + var.MLG;
  }
  Str=""String_Node_Str"" + var.MLGFileNameShort + ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.increment+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MinecraftLandGeneratorConf+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.defaultReadmeFile+ n+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ var.MLGFileNameShort+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ var.MinecraftLandGeneratorConf+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ var.MinecraftLandGeneratorConf+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n;
  String returnString=null;
  if (SysOut) {
    Out.out(Str);
    Out.out(""String_Node_Str"");
  }
 else {
    returnString=Str;
  }
  return returnString;
}",0.9841849148418492
1640,"/** 
 * Saves a Readme file.
 * @param readmeFile
 * @author Morlok8k
 */
public static void readMe(String readmeFile){
  if ((readmeFile == ""String_Node_Str"") || (readmeFile == null)) {
    readmeFile=var.defaultReadmeFile;
  }
  final String MLG_Last_Modified_MDY=var.dateFormat_MDY.format(var.MLG_Last_Modified_Date);
  final String PROG_NAME=var.PROG_NAME;
  final String VERSION=var.VERSION;
  String showHelpSTR=""String_Node_Str"";
  String ReadMeText=""String_Node_Str"";
  String VersionInfo=""String_Node_Str"";
  final String n=var.newLine;
  ReadMeText=PROG_NAME + ""String_Node_Str"" + VERSION+ n+ n+ ""String_Node_Str""+ MLG_Last_Modified_MDY+ n+ ""String_Node_Str""+ var.MLG_Last_Modified_Date.getTime()+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ MLG_Last_Modified_MDY+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ PROG_NAME+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n;
  showHelpSTR=showHelp(false);
  VersionInfo=n + ""String_Node_Str"" + n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n;
  FileWrite.writeTxtFile(readmeFile,ReadMeText + showHelpSTR + VersionInfo);
}","/** 
 * Saves a Readme file.
 * @param readmeFile
 * @author Morlok8k
 */
public static void readMe(String readmeFile){
  if ((readmeFile == ""String_Node_Str"") || (readmeFile == null)) {
    readmeFile=var.defaultReadmeFile;
  }
  final String MLG_Last_Modified_MDY=var.dateFormat_MDY.format(var.MLG_Last_Modified_Date);
  final String PROG_NAME=var.PROG_NAME;
  final String VERSION=var.VERSION;
  String showHelpSTR=""String_Node_Str"";
  String ReadMeText=""String_Node_Str"";
  String VersionInfo=""String_Node_Str"";
  final String n=var.newLine;
  ReadMeText=PROG_NAME + ""String_Node_Str"" + VERSION+ n+ n+ ""String_Node_Str""+ MLG_Last_Modified_MDY+ n+ ""String_Node_Str""+ var.MLG_Last_Modified_Date.getTime()+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ MLG_Last_Modified_MDY+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ PROG_NAME+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n;
  showHelpSTR=showHelp(false);
  VersionInfo=n + ""String_Node_Str"" + n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ ""String_Node_Str""+ n+ n+ ""String_Node_Str""+ n;
  FileWrite.writeTxtFile(readmeFile,ReadMeText + showHelpSTR + VersionInfo);
}",0.9879570834245676
1641,"/** 
 * CLI only: Reads arguments from command line
 * @return
 */
public static boolean programArguments(){
  String[] newArgs=new String[var.args.length];
  newArgs=var.args;
  newArgs=StringArrayParse.Parse(newArgs,""String_Node_Str"");
  newArgs=StringArrayParse.Parse(newArgs,""String_Node_Str"");
  if (!(var.args.equals(newArgs))) {
    var.dontWait=true;
    var.args=newArgs;
    Out.out(""String_Node_Str"");
  }
  if (var.args.length == 0) {
    Out.out(""String_Node_Str"");
    Out.outP(var.MLG + ""String_Node_Str"");
    var.xRange=Input_CLI.getInt(""String_Node_Str"");
    Out.outP(var.MLG + ""String_Node_Str"");
    var.zRange=Input_CLI.getInt(""String_Node_Str"");
    var.args=new String[]{String.valueOf(var.xRange),String.valueOf(var.zRange)};
  }
  if (var.args[0].equalsIgnoreCase(""String_Node_Str"") || var.args[0].equalsIgnoreCase(""String_Node_Str"") || var.args[0].equals(""String_Node_Str"")) {
    Readme_and_HelpInfo.showHelp(true);
    return true;
  }
  if (var.args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (var.args.length == 2) {
      if (var.args[1].equalsIgnoreCase(""String_Node_Str"")) {
        final boolean fileSuccess=DownloadFile.downloadFile(var.github_MLG_Conf_URL,var.testing);
        if (fileSuccess) {
          Out.out(var.MinecraftLandGeneratorConf + ""String_Node_Str"");
          return true;
        }
      }
    }
    FileWrite.saveConf(true);
    return true;
  }
 else   if (var.args[0].equalsIgnoreCase(""String_Node_Str"") || var.args[0].equalsIgnoreCase(""String_Node_Str"")) {
    Misc.printSpawn();
    Time.waitTenSec(false);
    return true;
  }
 else   if (var.args[0].equalsIgnoreCase(""String_Node_Str"")) {
    Update.buildID(false);
    return true;
  }
 else   if (var.args[0].equalsIgnoreCase(""String_Node_Str"")) {
    Update.updateMLG();
    Time.waitTenSec(false);
    return true;
  }
 else   if (var.args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (var.args.length == 2) {
      Readme_and_HelpInfo.readMe(var.args[1]);
    }
 else {
      Readme_and_HelpInfo.readMe(null);
    }
    return true;
  }
 else   if (var.args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (var.args.length == 2) {
      DownloadFile.downloadFile(var.args[1],true);
    }
 else {
      Out.out(""String_Node_Str"");
      Time.waitTenSec(false);
    }
    return true;
  }
 else   if (var.args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (var.args.length == 2) {
      String origMD5=""String_Node_Str"";
      String recheckMD5=""String_Node_Str"";
      try {
        final File config=new File(var.args[1]);
        try {
          origMD5=MD5.fileMD5(config.toString());
        }
 catch (        final NoSuchAlgorithmException e) {
          e.printStackTrace();
        }
        final BufferedReader in=new BufferedReader(new FileReader(config));
        String line;
        while ((line=in.readLine()) != null) {
          if (line.contains(""String_Node_Str"")) {
            var.recheckFlag=!var.recheckFlag;
          }
 else {
            DownloadFile.downloadFile(line,true);
          }
        }
        in.close();
        if (var.recheckFlag == true) {
          try {
            recheckMD5=MD5.fileMD5(config.toString());
          }
 catch (          final NoSuchAlgorithmException e) {
            e.printStackTrace();
          }
          if (!origMD5.contentEquals(recheckMD5)) {
            final BufferedReader in_recheck=new BufferedReader(new FileReader(config));
            String line_recheck;
            while ((line_recheck=in_recheck.readLine()) != null) {
              if (line_recheck.contains(""String_Node_Str"")) {
                var.recheckFlag=!var.recheckFlag;
              }
 else {
                DownloadFile.downloadFile(line_recheck,true);
              }
            }
            in_recheck.close();
          }
        }
      }
 catch (      final FileNotFoundException ex) {
        System.err.println(var.args[1] + ""String_Node_Str"");
        Time.waitTenSec(false);
        return true;
      }
catch (      final IOException ex) {
        System.err.println(var.args[1] + ""String_Node_Str"");
        Time.waitTenSec(false);
        return true;
      }
    }
 else {
      Out.out(""String_Node_Str"");
      Time.waitTenSec(false);
    }
    return true;
  }
 else   if (var.args.length == 1) {
    Out.out(""String_Node_Str"" + var.MLGFileNameShort + ""String_Node_Str"");
    Time.waitTenSec(false);
    return true;
  }
  try {
    var.xRange=Integer.parseInt(var.args[0]);
    var.zRange=Integer.parseInt(var.args[1]);
    if ((var.xRange < 1000) && (var.xRange != 0)) {
      var.xRange=1000;
      Out.err(""String_Node_Str"");
    }
    if ((var.zRange < 1000) && (var.zRange != 0)) {
      var.zRange=1000;
      Out.err(""String_Node_Str"");
    }
  }
 catch (  final NumberFormatException ex) {
    Out.err(""String_Node_Str"");
    Out.err(""String_Node_Str"");
    var.xRange=Input_CLI.getInt(""String_Node_Str"");
    var.zRange=Input_CLI.getInt(""String_Node_Str"");
  }
  try {
    for (int i=0; i < (var.args.length - 2); i++) {
      final String nextSwitch=var.args[i + 2].toLowerCase();
      if (nextSwitch.equals(""String_Node_Str"") || nextSwitch.equals(""String_Node_Str"")) {
        var.verbose=true;
        Out.out(""String_Node_Str"");
      }
 else       if (nextSwitch.startsWith(""String_Node_Str"")) {
        var.increment=Integer.parseInt(var.args[i + 2].substring(2));
        Out.out(""String_Node_Str"" + var.increment);
      }
 else       if (nextSwitch.startsWith(""String_Node_Str"")) {
        var.ignoreWarnings=true;
        Out.out(""String_Node_Str"");
      }
 else       if (nextSwitch.equals(""String_Node_Str"") || nextSwitch.equals(""String_Node_Str"")) {
        var.alternate=true;
        Out.out(""String_Node_Str"");
      }
 else       if (nextSwitch.startsWith(""String_Node_Str"")) {
        var.xOffset=Integer.valueOf(var.args[i + 2].substring(2));
        Out.out(""String_Node_Str"" + var.xOffset);
      }
 else       if (nextSwitch.startsWith(""String_Node_Str"") || nextSwitch.startsWith(""String_Node_Str"")) {
        var.zOffset=Integer.valueOf(var.args[i + 2].substring(2));
        Out.out(""String_Node_Str"" + var.zOffset);
        if (nextSwitch.startsWith(""String_Node_Str"")) {
          Out.out(""String_Node_Str"");
          Time.waitTenSec(false);
        }
      }
 else {
        var.serverPath=var.args[i + 2];
        Out.out(""String_Node_Str"" + var.serverPath);
      }
    }
  }
 catch (  final NumberFormatException ex) {
    Out.err(""String_Node_Str"");
    return true;
  }
  return false;
}","/** 
 * CLI only: Reads arguments from command line
 * @return
 */
public static boolean programArguments(){
  String[] newArgs=new String[var.args.length];
  newArgs=var.args;
  newArgs=StringArrayParse.Parse(newArgs,""String_Node_Str"");
  newArgs=StringArrayParse.Parse(newArgs,""String_Node_Str"");
  if (!(var.args.equals(newArgs))) {
    var.dontWait=true;
    var.args=newArgs;
    Out.out(""String_Node_Str"");
  }
  if (var.args.length == 0) {
    Out.out(""String_Node_Str"");
    Out.outP(var.MLG + ""String_Node_Str"");
    var.xRange=Input_CLI.getInt(""String_Node_Str"");
    Out.outP(var.MLG + ""String_Node_Str"");
    var.zRange=Input_CLI.getInt(""String_Node_Str"");
    var.args=new String[]{String.valueOf(var.xRange),String.valueOf(var.zRange)};
  }
  if (var.args[0].equalsIgnoreCase(""String_Node_Str"") || var.args[0].equalsIgnoreCase(""String_Node_Str"") || var.args[0].equals(""String_Node_Str"")) {
    Readme_and_HelpInfo.showHelp(true);
    return true;
  }
  if (var.args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (var.args.length == 2) {
      if (var.args[1].equalsIgnoreCase(""String_Node_Str"")) {
        final boolean fileSuccess=DownloadFile.downloadFile(var.github_MLG_Conf_URL,var.testing);
        if (fileSuccess) {
          Out.out(var.MinecraftLandGeneratorConf + ""String_Node_Str"");
          return true;
        }
      }
    }
    FileWrite.saveConf(true);
    return true;
  }
 else   if (var.args[0].equalsIgnoreCase(""String_Node_Str"") || var.args[0].equalsIgnoreCase(""String_Node_Str"")) {
    Misc.printSpawn();
    Time.waitTenSec(false);
    return true;
  }
 else   if (var.args[0].equalsIgnoreCase(""String_Node_Str"")) {
    Update.buildID(false);
    return true;
  }
 else   if (var.args[0].equalsIgnoreCase(""String_Node_Str"")) {
    Update.updateMLG();
    Time.waitTenSec(false);
    return true;
  }
 else   if (var.args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (var.args.length == 2) {
      Readme_and_HelpInfo.readMe(var.args[1]);
    }
 else {
      Readme_and_HelpInfo.readMe(null);
    }
    return true;
  }
 else   if (var.args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (var.args.length == 2) {
      DownloadFile.downloadFile(var.args[1],true);
    }
 else {
      Out.out(""String_Node_Str"");
      Time.waitTenSec(false);
    }
    return true;
  }
 else   if (var.args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (var.args.length == 2) {
      String origMD5=""String_Node_Str"";
      String recheckMD5=""String_Node_Str"";
      try {
        final File config=new File(var.args[1]);
        try {
          origMD5=MD5.fileMD5(config.toString());
        }
 catch (        final NoSuchAlgorithmException e) {
          e.printStackTrace();
        }
        final BufferedReader in=new BufferedReader(new FileReader(config));
        String line;
        while ((line=in.readLine()) != null) {
          if (line.contains(""String_Node_Str"")) {
            var.recheckFlag=!var.recheckFlag;
          }
 else {
            DownloadFile.downloadFile(line,true);
          }
        }
        in.close();
        if (var.recheckFlag == true) {
          try {
            recheckMD5=MD5.fileMD5(config.toString());
          }
 catch (          final NoSuchAlgorithmException e) {
            e.printStackTrace();
          }
          if (!origMD5.contentEquals(recheckMD5)) {
            final BufferedReader in_recheck=new BufferedReader(new FileReader(config));
            String line_recheck;
            while ((line_recheck=in_recheck.readLine()) != null) {
              if (line_recheck.contains(""String_Node_Str"")) {
                var.recheckFlag=!var.recheckFlag;
              }
 else {
                DownloadFile.downloadFile(line_recheck,true);
              }
            }
            in_recheck.close();
          }
        }
      }
 catch (      final FileNotFoundException ex) {
        System.err.println(var.args[1] + ""String_Node_Str"");
        Time.waitTenSec(false);
        return true;
      }
catch (      final IOException ex) {
        System.err.println(var.args[1] + ""String_Node_Str"");
        Time.waitTenSec(false);
        return true;
      }
    }
 else {
      Out.out(""String_Node_Str"");
      Time.waitTenSec(false);
    }
    return true;
  }
 else   if (var.args.length == 1) {
    Out.out(""String_Node_Str"" + var.MLGFileNameShort + ""String_Node_Str"");
    Time.waitTenSec(false);
    return true;
  }
  try {
    var.xRange=Integer.parseInt(var.args[0]);
    var.zRange=Integer.parseInt(var.args[1]);
    if ((var.xRange < 1000) && (var.xRange != 0)) {
      var.xRange=1000;
      Out.err(""String_Node_Str"");
    }
    if ((var.zRange < 1000) && (var.zRange != 0)) {
      var.zRange=1000;
      Out.err(""String_Node_Str"");
    }
  }
 catch (  final NumberFormatException ex) {
    Out.err(""String_Node_Str"");
    Out.err(""String_Node_Str"");
    var.xRange=Input_CLI.getInt(""String_Node_Str"");
    var.zRange=Input_CLI.getInt(""String_Node_Str"");
  }
  try {
    for (int i=0; i < (var.args.length - 2); i++) {
      final String nextSwitch=var.args[i + 2].toLowerCase();
      if (nextSwitch.equals(""String_Node_Str"") || nextSwitch.equals(""String_Node_Str"")) {
        var.verbose=true;
        Out.out(""String_Node_Str"");
      }
 else       if (nextSwitch.startsWith(""String_Node_Str"")) {
        var.increment=Integer.parseInt(var.args[i + 2].substring(2));
        Out.out(""String_Node_Str"" + var.increment);
      }
 else       if (nextSwitch.startsWith(""String_Node_Str"")) {
        var.ignoreWarnings=true;
        Out.out(""String_Node_Str"");
      }
 else       if (nextSwitch.equals(""String_Node_Str"") || nextSwitch.equals(""String_Node_Str"")) {
        var.alternate=true;
        Out.out(""String_Node_Str"");
      }
 else       if (nextSwitch.equals(""String_Node_Str"") || nextSwitch.equals(""String_Node_Str"")) {
        var.useChunks=true;
        Out.out(""String_Node_Str"");
      }
 else       if (nextSwitch.startsWith(""String_Node_Str"")) {
        var.xOffset=Integer.valueOf(var.args[i + 2].substring(2));
        Out.out(""String_Node_Str"" + var.xOffset);
      }
 else       if (nextSwitch.startsWith(""String_Node_Str"") || nextSwitch.startsWith(""String_Node_Str"")) {
        var.zOffset=Integer.valueOf(var.args[i + 2].substring(2));
        Out.out(""String_Node_Str"" + var.zOffset);
        if (nextSwitch.startsWith(""String_Node_Str"")) {
          Out.out(""String_Node_Str"");
          Time.waitTenSec(false);
        }
      }
 else {
        var.serverPath=var.args[i + 2];
        Out.out(""String_Node_Str"" + var.serverPath);
      }
    }
  }
 catch (  final NumberFormatException ex) {
    Out.err(""String_Node_Str"");
    return true;
  }
  return false;
}",0.9872996673722408
1642,"/** 
 * Start MinecraftLandGenerator (Command Line Interface)
 * @author Corrodias, Morlok8k
 * @param args
 */
private static void runCLI(){
  final File backupLevel;
  final File serverLevel;
  Startup.initialStart();
  if (Startup.programArguments()) {
    return;
  }
  if (Startup.confFile()) {
    return;
  }
  try {
    if (Setup.doSetup()) {
      return;
    }
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  Out.out(""String_Node_Str"" + var.worldPath + ""String_Node_Str""+ var.increment+ ""String_Node_Str""+ var.javaLine);
  Out.out(""String_Node_Str"");
  try {
    final long generationStartTimeTracking=System.currentTimeMillis();
    if ((var.xRange == 0) & (var.zRange == 0)) {
      return;
    }
    FileWrite.AppendTxtFile(var.worldPath + var.fileSeparator + var.logFile,""String_Node_Str"" + var.PROG_NAME + ""String_Node_Str""+ var.VERSION+ ""String_Node_Str""+ SelfAware.JVMinfo()+ var.newLine+ ""String_Node_Str""+ var.MC_Server_Version+ var.newLine+ ""String_Node_Str""+ var.dateFormat.format(generationStartTimeTracking)+ var.newLine+ ""String_Node_Str""+ var.xRange+ ""String_Node_Str""+ var.zRange+ var.newLine);
    Out.out(""String_Node_Str"");
    serverLevel=new File(var.worldPath + var.fileSeparator + ""String_Node_Str"");
    backupLevel=new File(var.worldPath + var.fileSeparator + ""String_Node_Str"");
    Out.out(""String_Node_Str"");
    Misc.copyFile(serverLevel,backupLevel);
    Out.out(""String_Node_Str"");
    final Coordinates spawn=SpawnPoint.getSpawn(serverLevel);
    Out.out(""String_Node_Str"" + spawn);
    FileWrite.AppendTxtFile(var.worldPath + var.fileSeparator + var.logFile,""String_Node_Str"" + var.randomSeed + var.newLine+ ""String_Node_Str""+ spawn.toString()+ var.newLine);
    boolean overridden=false;
    if (var.xOffset == null) {
      var.xOffset=spawn.getX();
    }
 else {
      overridden=true;
    }
    if (var.zOffset == null) {
      var.zOffset=spawn.getZ();
    }
 else {
      overridden=true;
    }
    if (var.useChunks) {
      var.xRange=(int)(Math.ceil(((double)var.xRange) / ((double)16))) * 16;
      var.zRange=(int)(Math.ceil(((double)var.zRange) / ((double)16))) * 16;
      var.xOffset=(int)(Math.ceil(((double)var.xOffset) / ((double)16))) * 16;
      var.zOffset=(int)(Math.ceil(((double)var.zOffset) / ((double)16))) * 16;
    }
 else {
      var.xRange=(int)(Math.ceil(((double)var.xRange) / ((double)512))) * 512;
      var.zRange=(int)(Math.ceil(((double)var.zRange) / ((double)512))) * 512;
      var.xOffset=(int)(Math.ceil(((double)var.xOffset) / ((double)512))) * 512;
      var.zOffset=(int)(Math.ceil(((double)var.zOffset) / ((double)512))) * 512;
    }
    if (overridden) {
      Out.out(""String_Node_Str"" + var.xOffset + ""String_Node_Str""+ var.zOffset+ ""String_Node_Str"");
    }
    Out.out(""String_Node_Str"");
    double xLoops, zLoops;
    int curXloops=0;
    int curZloops=0;
    int xRangeAdj=0;
    int zRangeAdj=0;
    xLoops=((double)var.xRange / (double)var.increment);
    xLoops=Math.ceil(xLoops);
    xRangeAdj=(int)(xLoops * var.increment);
    xLoops=xLoops + 1;
    zLoops=((double)var.zRange / (double)var.increment);
    zLoops=Math.ceil(zLoops);
    zRangeAdj=(int)(zLoops * var.increment);
    zLoops=zLoops + 1;
    Out.out(""String_Node_Str"");
    int totalIterations=(int)(xLoops * zLoops);
    int currentIteration=0;
    long differenceTime=System.currentTimeMillis();
    Long timeTracking=0L;
    final ArrayList<Coordinates> launchList=new ArrayList<Coordinates>(totalIterations);
    for (int currentX=0; currentX <= (xRangeAdj / 2); currentX+=var.increment) {
      curXloops++;
      boolean eastEdgeReached=false;
      if (curXloops == 1) {
        currentX=(((0 - var.xRange) / 2) + (var.incrementFull / 2));
      }
 else       if (currentX >= ((xRangeAdj / 2) - (var.increment / 2))) {
        currentX=((var.xRange / 2) - (var.incrementFull / 2));
        eastEdgeReached=true;
      }
      for (int currentZ=0; currentZ <= (zRangeAdj / 2); currentZ+=var.increment) {
        currentIteration++;
        curZloops++;
        boolean southEdgeReached=false;
        if (curZloops == 1) {
          currentZ=(((0 - var.zRange) / 2) + (var.incrementFull / 2));
        }
 else         if (currentZ >= ((zRangeAdj / 2) - (var.increment / 2))) {
          currentZ=((var.zRange / 2) - (var.incrementFull / 2));
          southEdgeReached=true;
        }
{
          final Coordinates tempCoords=new Coordinates(currentX + var.xOffset,64,currentZ + var.zOffset);
          launchList.add(tempCoords);
          if (var.testing) {
            System.out.println(tempCoords);
          }
        }
        if (curZloops == 1) {
          currentZ=(int)((Math.ceil((((0 - zRangeAdj) / 2) / var.increment))) * var.increment);
        }
        if (southEdgeReached) {
          currentZ=zRangeAdj;
        }
      }
      curZloops=0;
      if (curXloops == 1) {
        currentX=(int)((Math.ceil((((0 - xRangeAdj) / 2) / var.increment))) * var.increment);
      }
      if (eastEdgeReached) {
        currentX=xRangeAdj;
      }
    }
    final ArrayList<Coordinates> removeList=FileRead.readArrayListCoordLog(var.worldPath + var.fileSeparator + var.logFile);
    if (!(removeList.isEmpty())) {
      Arraylist.arrayListRemove(launchList,removeList);
    }
    removeList.clear();
    System.gc();
    currentIteration=0;
    totalIterations=launchList.size();
    Coordinates xyz=null;
    final Iterator<Coordinates> coordArrayIterator=launchList.iterator();
    while (coordArrayIterator.hasNext()) {
      currentIteration++;
      xyz=coordArrayIterator.next();
      String percentDone=Double.toString((((double)currentIteration - 1) / totalIterations) * 100);
      final int percentIndex=((percentDone.indexOf(""String_Node_Str"") + 3) > percentDone.length()) ? percentDone.length() : (percentDone.indexOf(""String_Node_Str"") + 3);
      percentDone=percentDone.substring(0,(percentDone.indexOf(""String_Node_Str"") == -1 ? percentDone.length() : percentIndex));
      Out.out(""String_Node_Str"" + xyz + ""String_Node_Str""+ currentIteration+ ""String_Node_Str""+ totalIterations+ ""String_Node_Str""+ percentDone+ ""String_Node_Str"");
      timeTracking=System.currentTimeMillis();
      differenceTime=(timeTracking - generationStartTimeTracking) / (currentIteration + 1);
      differenceTime*=1 + (totalIterations - currentIteration);
      Out.out(""String_Node_Str"" + Time.displayTime(differenceTime));
      SpawnPoint.setSpawn(serverLevel,xyz);
      boolean serverSuccess=false;
      serverSuccess=Server.runMinecraft();
      Out.out(""String_Node_Str"");
      if (serverSuccess) {
        FileWrite.AppendTxtFile(var.worldPath + var.fileSeparator + var.logFile,xyz.toString() + var.newLine);
      }
 else {
        System.exit(1);
      }
    }
    if (currentIteration == 0) {
      Out.out(""String_Node_Str"");
    }
 else {
      Out.out(""String_Node_Str"");
    }
    Misc.copyFile(backupLevel,serverLevel);
    backupLevel.delete();
    Out.out(""String_Node_Str"");
    Out.out(""String_Node_Str"" + Time.displayTime(var.startTime,System.currentTimeMillis()));
    Time.waitTenSec(false);
    if (var.webLaunch) {
      if (java.awt.GraphicsEnvironment.isHeadless()) {
        var.webLaunch=false;
      }
      final File web1=new File(""String_Node_Str"");
      final File web2=new File(""String_Node_Str"");
      final File web3=new File(""String_Node_Str"");
      if (web2.exists() || (web1.exists() || web3.exists())) {
        var.webLaunch=false;
      }
    }
    if (var.webLaunch && java.awt.Desktop.isDesktopSupported()) {
      final URI splashPage=URI.create(""String_Node_Str"");
      try {
        java.awt.Desktop.getDesktop().browse(splashPage);
      }
 catch (      final IOException e) {
        Out.err(""String_Node_Str"" + e.getLocalizedMessage());
      }
    }
 else {
      Out.out(""String_Node_Str"");
      Out.out(""String_Node_Str"" + var.WEBSITE);
      Out.out(""String_Node_Str"");
    }
  }
 catch (  final IOException ex) {
    Logger.getLogger(Main.class.getName()).log(Level.SEVERE,ex.getMessage(),ex);
  }
}","/** 
 * Start MinecraftLandGenerator (Command Line Interface)
 * @author Corrodias, Morlok8k
 * @param args
 */
private static void runCLI(){
  final File backupLevel;
  final File serverLevel;
  Startup.initialStart();
  if (Startup.programArguments()) {
    Out.err(""String_Node_Str"");
    return;
  }
  if (Startup.confFile()) {
    Out.err(""String_Node_Str"");
    return;
  }
  try {
    if (Setup.doSetup()) {
      Out.err(""String_Node_Str"");
      return;
    }
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  Out.out(""String_Node_Str"" + var.worldPath + ""String_Node_Str""+ var.increment+ ""String_Node_Str""+ var.javaLine);
  Out.out(""String_Node_Str"");
  try {
    final long generationStartTimeTracking=System.currentTimeMillis();
    final boolean serverLaunch=Server.runMinecraft();
    if (!(serverLaunch)) {
      System.exit(1);
    }
    if ((var.xRange == 0) & (var.zRange == 0)) {
      return;
    }
    FileWrite.AppendTxtFile(var.worldPath + var.fileSeparator + var.logFile,""String_Node_Str"" + var.PROG_NAME + ""String_Node_Str""+ var.VERSION+ ""String_Node_Str""+ SelfAware.JVMinfo()+ var.newLine+ ""String_Node_Str""+ var.MC_Server_Version+ var.newLine+ ""String_Node_Str""+ var.dateFormat.format(generationStartTimeTracking)+ var.newLine+ ""String_Node_Str""+ var.xRange+ ""String_Node_Str""+ var.zRange+ var.newLine);
    Out.out(""String_Node_Str"");
    serverLevel=new File(var.worldPath + var.fileSeparator + ""String_Node_Str"");
    backupLevel=new File(var.worldPath + var.fileSeparator + ""String_Node_Str"");
    Out.out(""String_Node_Str"");
    Misc.copyFile(serverLevel,backupLevel);
    Out.out(""String_Node_Str"");
    final Coordinates spawn=SpawnPoint.getSpawn(serverLevel);
    Out.out(""String_Node_Str"" + spawn);
    FileWrite.AppendTxtFile(var.worldPath + var.fileSeparator + var.logFile,""String_Node_Str"" + var.randomSeed + var.newLine+ ""String_Node_Str""+ spawn.toString()+ var.newLine);
    boolean overridden=false;
    if (var.xOffset == null) {
      var.xOffset=spawn.getX();
    }
 else {
      overridden=true;
    }
    if (var.zOffset == null) {
      var.zOffset=spawn.getZ();
    }
 else {
      overridden=true;
    }
    if (var.useChunks) {
      var.xRange=(int)(Math.ceil(((double)var.xRange) / ((double)16))) * 16;
      var.zRange=(int)(Math.ceil(((double)var.zRange) / ((double)16))) * 16;
      var.xOffset=(int)(Math.ceil(((double)var.xOffset) / ((double)16))) * 16;
      var.zOffset=(int)(Math.ceil(((double)var.zOffset) / ((double)16))) * 16;
    }
 else {
      var.xRange=(int)(Math.ceil(((double)var.xRange) / ((double)512))) * 512;
      var.zRange=(int)(Math.ceil(((double)var.zRange) / ((double)512))) * 512;
      var.xOffset=(int)(Math.ceil(((double)var.xOffset) / ((double)512))) * 512;
      var.zOffset=(int)(Math.ceil(((double)var.zOffset) / ((double)512))) * 512;
    }
    if (overridden) {
      Out.out(""String_Node_Str"" + var.xOffset + ""String_Node_Str""+ var.zOffset+ ""String_Node_Str"");
    }
    Out.out(""String_Node_Str"");
    double xLoops, zLoops;
    int curXloops=0;
    int curZloops=0;
    int xRangeAdj=0;
    int zRangeAdj=0;
    xLoops=((double)var.xRange / (double)var.increment);
    xLoops=Math.ceil(xLoops);
    xRangeAdj=(int)(xLoops * var.increment);
    xLoops=xLoops + 1;
    zLoops=((double)var.zRange / (double)var.increment);
    zLoops=Math.ceil(zLoops);
    zRangeAdj=(int)(zLoops * var.increment);
    zLoops=zLoops + 1;
    Out.out(""String_Node_Str"");
    int totalIterations=(int)(xLoops * zLoops);
    int currentIteration=0;
    long differenceTime=System.currentTimeMillis();
    Long timeTracking=0L;
    final ArrayList<Coordinates> launchList=new ArrayList<Coordinates>(totalIterations);
    for (int currentX=0; currentX <= (xRangeAdj / 2); currentX+=var.increment) {
      curXloops++;
      boolean eastEdgeReached=false;
      if (curXloops == 1) {
        currentX=(((0 - var.xRange) / 2) + (var.incrementFull / 2));
      }
 else       if (currentX >= ((xRangeAdj / 2) - (var.increment / 2))) {
        currentX=((var.xRange / 2) - (var.incrementFull / 2));
        eastEdgeReached=true;
      }
      for (int currentZ=0; currentZ <= (zRangeAdj / 2); currentZ+=var.increment) {
        currentIteration++;
        curZloops++;
        boolean southEdgeReached=false;
        if (curZloops == 1) {
          currentZ=(((0 - var.zRange) / 2) + (var.incrementFull / 2));
        }
 else         if (currentZ >= ((zRangeAdj / 2) - (var.increment / 2))) {
          currentZ=((var.zRange / 2) - (var.incrementFull / 2));
          southEdgeReached=true;
        }
{
          final Coordinates tempCoords=new Coordinates(currentX + var.xOffset,64,currentZ + var.zOffset);
          launchList.add(tempCoords);
          if (var.testing) {
            System.out.println(tempCoords);
          }
        }
        if (curZloops == 1) {
          currentZ=(int)((Math.ceil((((0 - zRangeAdj) / 2) / var.increment))) * var.increment);
        }
        if (southEdgeReached) {
          currentZ=zRangeAdj;
        }
      }
      curZloops=0;
      if (curXloops == 1) {
        currentX=(int)((Math.ceil((((0 - xRangeAdj) / 2) / var.increment))) * var.increment);
      }
      if (eastEdgeReached) {
        currentX=xRangeAdj;
      }
    }
    final ArrayList<Coordinates> removeList=FileRead.readArrayListCoordLog(var.worldPath + var.fileSeparator + var.logFile);
    if (!(removeList.isEmpty())) {
      Arraylist.arrayListRemove(launchList,removeList);
    }
    removeList.clear();
    System.gc();
    currentIteration=0;
    totalIterations=launchList.size();
    Coordinates xyz=null;
    final Iterator<Coordinates> coordArrayIterator=launchList.iterator();
    while (coordArrayIterator.hasNext()) {
      currentIteration++;
      xyz=coordArrayIterator.next();
      String percentDone=Double.toString((((double)currentIteration - 1) / totalIterations) * 100);
      final int percentIndex=((percentDone.indexOf(""String_Node_Str"") + 3) > percentDone.length()) ? percentDone.length() : (percentDone.indexOf(""String_Node_Str"") + 3);
      percentDone=percentDone.substring(0,(percentDone.indexOf(""String_Node_Str"") == -1 ? percentDone.length() : percentIndex));
      Out.out(""String_Node_Str"" + xyz + ""String_Node_Str""+ currentIteration+ ""String_Node_Str""+ totalIterations+ ""String_Node_Str""+ percentDone+ ""String_Node_Str"");
      timeTracking=System.currentTimeMillis();
      differenceTime=(timeTracking - generationStartTimeTracking) / (currentIteration + 1);
      differenceTime*=1 + (totalIterations - currentIteration);
      Out.out(""String_Node_Str"" + Time.displayTime(differenceTime));
      SpawnPoint.setSpawn(serverLevel,xyz);
      boolean serverSuccess=false;
      serverSuccess=Server.runMinecraft();
      Out.out(""String_Node_Str"");
      if (serverSuccess) {
        FileWrite.AppendTxtFile(var.worldPath + var.fileSeparator + var.logFile,xyz.toString() + var.newLine);
      }
 else {
        System.exit(1);
      }
    }
    if (currentIteration == 0) {
      Out.out(""String_Node_Str"");
    }
 else {
      Out.out(""String_Node_Str"");
    }
    Misc.copyFile(backupLevel,serverLevel);
    backupLevel.delete();
    Out.out(""String_Node_Str"");
    Out.out(""String_Node_Str"" + Time.displayTime(var.startTime,System.currentTimeMillis()));
    Time.waitTenSec(false);
    if (var.webLaunch) {
      if (java.awt.GraphicsEnvironment.isHeadless()) {
        var.webLaunch=false;
      }
      final File web1=new File(""String_Node_Str"");
      final File web2=new File(""String_Node_Str"");
      final File web3=new File(""String_Node_Str"");
      if (web2.exists() || (web1.exists() || web3.exists())) {
        var.webLaunch=false;
      }
    }
    if (var.webLaunch && java.awt.Desktop.isDesktopSupported()) {
      final URI splashPage=URI.create(""String_Node_Str"");
      try {
        java.awt.Desktop.getDesktop().browse(splashPage);
      }
 catch (      final IOException e) {
        Out.err(""String_Node_Str"" + e.getLocalizedMessage());
      }
    }
 else {
      Out.out(""String_Node_Str"");
      Out.out(""String_Node_Str"" + var.WEBSITE);
      Out.out(""String_Node_Str"");
    }
  }
 catch (  final IOException ex) {
    Logger.getLogger(Main.class.getName()).log(Level.SEVERE,ex.getMessage(),ex);
  }
}",0.9873107337706124
1643,"public MessageElement next(){
  StringBuilder str=new StringBuilder();
  int i=this.bufferIndex;
  for (; i < this.buffer.length; ++i) {
    if (this.buffer[i] == ESCAPE_CHAR) {
      int nb=countEscaping(i);
      int iNext=i + nb;
      if (iNext == this.buffer.length) {
        i=iNext;
        break;
      }
 else {
        if (isMessageIndex(iNext) > iNext) {
          str.append(this.buffer,this.bufferIndex,iNext - 1 - this.bufferIndex);
          i=iNext;
          this.bufferIndex=i;
          if (nb > 1) {
            this.previousWasDoubleEscaped=true;
            this.currentMessageElement=new MessageString(str.toString());
            return this.currentMessageElement;
          }
        }
 else {
          i=iNext;
        }
      }
    }
 else     if (this.buffer[i] == ARGUMENT_START) {
      int iNext=isMessageIndex(i);
      if (iNext != i) {
        if (this.bufferIndex == i) {
          String messageIndexString=new String(this.buffer,i,iNext - i);
          int messageIndex;
          if (this.translations && messageIndexString.length() > 2) {
            messageIndex=Integer.parseInt(messageIndexString.substring(1,messageIndexString.length() - 1));
          }
 else {
            messageIndex=this.currentMessageIndex;
          }
          ++this.currentMessageIndex;
          if (this.previousWasDoubleEscaped) {
            this.currentMessageElement=new MessageIndex(""String_Node_Str"" + messageIndexString,messageIndex);
          }
 else {
            this.currentMessageElement=new MessageIndex(messageIndexString,messageIndex);
          }
          this.bufferIndex=iNext;
          return this.currentMessageElement;
        }
 else {
          this.currentMessageElement=new MessageString(new String(this.buffer,this.bufferIndex,i - this.bufferIndex));
          this.bufferIndex=i;
          return this.currentMessageElement;
        }
      }
    }
  }
  if (i == this.bufferIndex) {
    return null;
  }
  this.currentMessageElement=new MessageString(new String(this.buffer,this.bufferIndex,i - this.bufferIndex));
  this.bufferIndex=i;
  return this.currentMessageElement;
}","public MessageElement next(){
  StringBuilder str=new StringBuilder();
  int i=this.bufferIndex;
  for (; i < this.buffer.length; ++i) {
    if (this.buffer[i] == ESCAPE_CHAR) {
      int nb=countEscaping(i);
      int iNext=i + nb;
      if (iNext == this.buffer.length) {
        i=iNext;
        break;
      }
 else {
        if (isMessageIndex(iNext) > iNext) {
          str.append(this.buffer,this.bufferIndex,iNext - 1 - this.bufferIndex);
          i=iNext;
          this.bufferIndex=i;
          if (nb > 1) {
            this.previousWasDoubleEscaped=true;
            this.currentMessageElement=new MessageString(str.toString());
            return this.currentMessageElement;
          }
        }
 else {
          i=iNext;
        }
      }
    }
 else     if (this.buffer[i] == ARGUMENT_START) {
      int iNext=isMessageIndex(i);
      if (iNext != i) {
        if (this.bufferIndex == i) {
          String messageIndexString=String.valueOf(this.buffer,i,iNext - i);
          int messageIndex;
          if (this.translations && messageIndexString.length() > 2) {
            messageIndex=Integer.parseInt(messageIndexString.substring(1,messageIndexString.length() - 1));
          }
 else {
            messageIndex=this.currentMessageIndex;
          }
          ++this.currentMessageIndex;
          if (this.previousWasDoubleEscaped) {
            this.currentMessageElement=new MessageIndex(""String_Node_Str"" + messageIndexString,messageIndex);
          }
 else {
            this.currentMessageElement=new MessageIndex(messageIndexString,messageIndex);
          }
          this.bufferIndex=iNext;
          return this.currentMessageElement;
        }
 else {
          this.currentMessageElement=new MessageString(String.valueOf(this.buffer,this.bufferIndex,i - this.bufferIndex));
          this.bufferIndex=i;
          return this.currentMessageElement;
        }
      }
    }
  }
  if (i == this.bufferIndex) {
    return null;
  }
  this.currentMessageElement=new MessageString(String.valueOf(this.buffer,this.bufferIndex,i - this.bufferIndex));
  this.bufferIndex=i;
  return this.currentMessageElement;
}",0.8614232209737828
1644,"@Test public void testGetWithNoProvider() throws Exception {
  Object safe=new String();
  Assert.assertSame(safe,this.mocker.getComponentUnderTest().get(safe));
}","@Test public void testGetWithNoProvider() throws Exception {
  Object safe=""String_Node_Str"";
  Assert.assertSame(safe,this.mocker.getComponentUnderTest().get(safe));
}",0.9486404833836858
1645,"@Override public void characters(char[] ch,int start,int length) throws SAXException {
  int offset=this.lowerBound - this.counter;
  if (offset > 0) {
    if (offset > length) {
      this.counter+=length;
      return;
    }
 else {
      this.counter=this.lowerBound;
      openTags();
      characters(ch,start + offset,length - offset);
      return;
    }
  }
  int remainingLength=this.upperBound - this.counter;
  if (remainingLength <= length) {
    String content=new String(ch,start,remainingLength);
    int spaceIndex=remainingLength;
    if (length > remainingLength && ch[start + remainingLength] != ' ') {
      spaceIndex=content.lastIndexOf(' ');
    }
    if (spaceIndex >= 0) {
      this.counter+=spaceIndex;
      this.result.append(content.substring(0,spaceIndex));
    }
 else {
      this.counter=this.upperBound;
      this.result.append(content);
    }
    endDocument();
    throw new SAXException(""String_Node_Str"");
  }
 else {
    this.counter+=length;
    this.result.append(ch,start,length);
  }
}","@Override public void characters(char[] ch,int start,int length) throws SAXException {
  int offset=this.lowerBound - this.counter;
  if (offset > 0) {
    if (offset > length) {
      this.counter+=length;
      return;
    }
 else {
      this.counter=this.lowerBound;
      openTags();
      characters(ch,start + offset,length - offset);
      return;
    }
  }
  int remainingLength=this.upperBound - this.counter;
  if (remainingLength <= length) {
    String content=String.valueOf(ch,start,remainingLength);
    int spaceIndex=remainingLength;
    if (length > remainingLength && ch[start + remainingLength] != ' ') {
      spaceIndex=content.lastIndexOf(' ');
    }
    if (spaceIndex >= 0) {
      this.counter+=spaceIndex;
      this.result.append(content.substring(0,spaceIndex));
    }
 else {
      this.counter=this.upperBound;
      this.result.append(content);
    }
    endDocument();
    throw new SAXException(""String_Node_Str"");
  }
 else {
    this.counter+=length;
    this.result.append(ch,start,length);
  }
}",0.994186046511628
1646,"@Override public void characters(char[] ch,int start,int length){
  Node currentNode=this.nodes.peek();
  if (currentNode != this.document) {
    final String text=new String(ch,start,length);
    currentNode.appendChild(this.document.createTextNode(text));
  }
}","@Override public void characters(char[] ch,int start,int length){
  Node currentNode=this.nodes.peek();
  if (currentNode != this.document) {
    final String text=String.valueOf(ch,start,length);
    currentNode.appendChild(this.document.createTextNode(text));
  }
}",0.9773584905660376
1647,"@Override public void comment(char[] ch,int start,int length){
  Comment comment=this.document.createComment(new String(ch,start,length));
  if (comment != null) {
    this.nodes.peek().appendChild(comment);
  }
}","@Override public void comment(char[] ch,int start,int length){
  Comment comment=this.document.createComment(String.valueOf(ch,start,length));
  if (comment != null) {
    this.nodes.peek().appendChild(comment);
  }
}",0.972093023255814
1648,"/** 
 * Create the XAR by zipping the resource files.
 * @throws Exception if the zipping failed for some reason
 */
private void performArchive() throws Exception {
  File sourceDir=new File(this.project.getBuild().getOutputDirectory());
  if (sourceDir.listFiles() == null) {
    throw new Exception(String.format(""String_Node_Str"",sourceDir));
  }
  File xarFile=new File(this.project.getBuild().getDirectory(),this.project.getArtifactId() + ""String_Node_Str"");
  ZipArchiver archiver=new ZipArchiver();
  archiver.setEncoding(this.encoding);
  archiver.setDestFile(xarFile);
  archiver.setIncludeEmptyDirs(false);
  archiver.setCompress(true);
  if (this.includeDependencies) {
    unpackDependentXARs();
  }
  performTransformations();
  File resourcesDir=getResourcesDirectory();
  FilenameFilter packageXmlFiler=new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      return (name.equals(PACKAGE_XML));
    }
  }
;
  String[] fileNames=resourcesDir.list(packageXmlFiler);
  if (fileNames != null) {
    if (!resourcesDir.exists() || fileNames.length == 0) {
      addFilesToArchive(archiver,sourceDir);
    }
 else {
      File packageXml=new File(resourcesDir,PACKAGE_XML);
      addFilesToArchive(archiver,sourceDir,packageXml);
    }
  }
 else {
    throw new MojoExecutionException(String.format(""String_Node_Str"",resourcesDir));
  }
  archiver.createArchive();
  this.project.getArtifact().setFile(xarFile);
}","/** 
 * Create the XAR by zipping the resource files.
 * @throws Exception if the zipping failed for some reason
 */
private void performArchive() throws Exception {
  File sourceDir=new File(this.project.getBuild().getOutputDirectory());
  if (sourceDir.listFiles() == null) {
    throw new Exception(String.format(""String_Node_Str"",sourceDir));
  }
  File xarFile=new File(this.project.getBuild().getDirectory(),this.project.getArtifactId() + ""String_Node_Str"");
  ZipArchiver archiver=new ZipArchiver();
  archiver.setEncoding(this.encoding);
  archiver.setDestFile(xarFile);
  archiver.setIncludeEmptyDirs(false);
  archiver.setCompress(true);
  if (this.includeDependencies) {
    unpackDependentXARs();
  }
  performTransformations();
  File resourcesDir=getResourcesDirectory();
  if (!hasPackageXmlFile(resourcesDir)) {
    addFilesToArchive(archiver,sourceDir);
  }
 else {
    File packageXml=new File(resourcesDir,PACKAGE_XML);
    addFilesToArchive(archiver,sourceDir,packageXml);
  }
  archiver.createArchive();
  this.project.getArtifact().setFile(xarFile);
}",0.6608764311093565
1649,"@Test public void testMd5SignatureVerification() throws Exception {
  test(mockerMD5);
}","@Test public void testMd5SignatureVerification() throws Exception {
  runTest(mockerMD5);
}",0.9720670391061452
1650,"@Test public void testPssSignatureVerification() throws Exception {
  test(mockerPss);
}","@Test public void testPssSignatureVerification() throws Exception {
  runTest(mockerPss);
}",0.9720670391061452
1651,"@Test public void testSha1SignatureVerification() throws Exception {
  test(mockerSha1);
}","@Test public void testSha1SignatureVerification() throws Exception {
  runTest(mockerSha1);
}",0.9726775956284152
1652,"@Test public void testSha512SignatureVerification() throws Exception {
  test(mockerSha512);
}","@Test public void testSha512SignatureVerification() throws Exception {
  runTest(mockerSha512);
}",0.9738219895287958
1653,"@Test public void testSha224SignatureVerification() throws Exception {
  test(mockerSha224);
}","@Test public void testSha224SignatureVerification() throws Exception {
  runTest(mockerSha224);
}",0.9738219895287958
1654,"@Test public void testSha384SignatureVerification() throws Exception {
  test(mockerSha384);
}","@Test public void testSha384SignatureVerification() throws Exception {
  runTest(mockerSha384);
}",0.9738219895287958
1655,"@Test public void testSha256SignatureVerification() throws Exception {
  test(mockerSha256);
}","@Test public void testSha256SignatureVerification() throws Exception {
  runTest(mockerSha256);
}",0.9738219895287958
1656,"@Test public void testPBES2ConformanceTestDesEde3() throws Exception {
  byte[] data=Base64.decode(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  testPBES2Conformance(""String_Node_Str"",""String_Node_Str"",-1,""String_Node_Str"",data);
}","@Test public void testPBES2ConformanceTestDesEde3() throws Exception {
  byte[] data=Base64.decode(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  runTestPBES2Conformance(""String_Node_Str"",""String_Node_Str"",-1,""String_Node_Str"",data);
}",0.9965445749827228
1657,"@Test public void testPBES2ConformanceTestDes() throws Exception {
  byte[] data=Base64.decode(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  testPBES2Conformance(""String_Node_Str"",""String_Node_Str"",-1,""String_Node_Str"",data);
}","@Test public void testPBES2ConformanceTestDes() throws Exception {
  byte[] data=Base64.decode(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  runTestPBES2Conformance(""String_Node_Str"",""String_Node_Str"",-1,""String_Node_Str"",data);
}",0.9964311206281228
1658,"@Test public void testPBES2ConformanceTestRC2() throws Exception {
  byte[] data=Base64.decode(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  testPBES2Conformance(""String_Node_Str"",""String_Node_Str"",16,""String_Node_Str"",data);
}","@Test public void testPBES2ConformanceTestRC2() throws Exception {
  byte[] data=Base64.decode(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  runTestPBES2Conformance(""String_Node_Str"",""String_Node_Str"",16,""String_Node_Str"",data);
}",0.9965253648366922
1659,"@Test public void testPBES2ConformanceTestAES128() throws Exception {
  byte[] data=Base64.decode(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  testPBES2Conformance(""String_Node_Str"",""String_Node_Str"",16,""String_Node_Str"",data);
}","@Test public void testPBES2ConformanceTestAES128() throws Exception {
  byte[] data=Base64.decode(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  runTestPBES2Conformance(""String_Node_Str"",""String_Node_Str"",16,""String_Node_Str"",data);
}",0.9965397923875432
1660,"@Test public void testPBES2ConformanceTestBlowfish() throws Exception {
  byte[] data=Base64.decode(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  testPBES2Conformance(""String_Node_Str"",""String_Node_Str"",-1,""String_Node_Str"",data);
}","@Test public void testPBES2ConformanceTestBlowfish() throws Exception {
  byte[] data=Base64.decode(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  runTestPBES2Conformance(""String_Node_Str"",""String_Node_Str"",-1,""String_Node_Str"",data);
}",0.9965493443754312
1661,"@Test public void testDSASignatureVerification() throws Exception {
  testSignatureVerification(mocker.getComponentUnderTest().getInstance(true,privateKey),mocker.getComponentUnderTest().getInstance(false,publicKey));
}","@Test public void testDSASignatureVerification() throws Exception {
  runTestSignatureVerification(mocker.getComponentUnderTest().getInstance(true,privateKey),mocker.getComponentUnderTest().getInstance(false,publicKey));
}",0.9886621315192744
1662,"@Test public void testMd5SignatureVerification() throws Exception {
  test(mockerMD5);
}","@Test public void testMd5SignatureVerification() throws Exception {
  runTest(mockerMD5);
}",0.9720670391061452
1663,"@Test public void testSha1SignatureVerification() throws Exception {
  test(mocker);
}","@Test public void testSha1SignatureVerification() throws Exception {
  runTest(mocker);
}",0.9714285714285714
1664,"@Test public void testSha512SignatureVerification() throws Exception {
  test(mockerSha512);
}","@Test public void testSha512SignatureVerification() throws Exception {
  runTest(mockerSha512);
}",0.9738219895287958
1665,"@Test public void testSha224SignatureVerification() throws Exception {
  test(mockerSha224);
}","@Test public void testSha224SignatureVerification() throws Exception {
  runTest(mockerSha224);
}",0.9738219895287958
1666,"@Test public void testSha384SignatureVerification() throws Exception {
  test(mockerSha384);
}","@Test public void testSha384SignatureVerification() throws Exception {
  runTest(mockerSha384);
}",0.9738219895287958
1667,"@Test public void testSha256SignatureVerification() throws Exception {
  test(mockerSha256);
}","@Test public void testSha256SignatureVerification() throws Exception {
  runTest(mockerSha256);
}",0.9738219895287958
1668,"@Test public void testSha512SignatureVerification() throws Exception {
  testSignatureVerification(factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1)),factory.getInstance(false,new PssSignerParameters(publicKey,""String_Node_Str"",-1)));
}","@Test public void testSha512SignatureVerification() throws Exception {
  runTestSignatureVerification(factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1)),factory.getInstance(false,new PssSignerParameters(publicKey,""String_Node_Str"",-1)));
}",0.9907235621521336
1669,"@Test public void testEncodedSha256SignatureVerification() throws Exception {
  Signer signer=factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1));
  Signer verifier=factory.getInstance(false,publicKey,signer.getEncoded());
  testSignatureVerification(signer,verifier);
}","@Test public void testEncodedSha256SignatureVerification() throws Exception {
  Signer signer=factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1));
  Signer verifier=factory.getInstance(false,publicKey,signer.getEncoded());
  runTestSignatureVerification(signer,verifier);
}",0.9917355371900828
1670,"@Test public void testSha224SignatureVerification() throws Exception {
  testSignatureVerification(factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1)),factory.getInstance(false,new PssSignerParameters(publicKey,""String_Node_Str"",-1)));
}","@Test public void testSha224SignatureVerification() throws Exception {
  runTestSignatureVerification(factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1)),factory.getInstance(false,new PssSignerParameters(publicKey,""String_Node_Str"",-1)));
}",0.9907235621521336
1671,"@Test public void testEncodedSha512SignatureVerification() throws Exception {
  Signer signer=factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1));
  Signer verifier=factory.getInstance(false,publicKey,signer.getEncoded());
  testSignatureVerification(signer,verifier);
}","@Test public void testEncodedSha512SignatureVerification() throws Exception {
  Signer signer=factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1));
  Signer verifier=factory.getInstance(false,publicKey,signer.getEncoded());
  runTestSignatureVerification(signer,verifier);
}",0.9917355371900828
1672,"@Test public void testSha256SignatureVerification() throws Exception {
  testSignatureVerification(factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1)),factory.getInstance(false,new PssSignerParameters(publicKey,""String_Node_Str"",-1)));
}","@Test public void testSha256SignatureVerification() throws Exception {
  runTestSignatureVerification(factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1)),factory.getInstance(false,new PssSignerParameters(publicKey,""String_Node_Str"",-1)));
}",0.9907235621521336
1673,"@Test public void testEncodedSha384SignatureVerification() throws Exception {
  Signer signer=factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1));
  Signer verifier=factory.getInstance(false,publicKey,signer.getEncoded());
  testSignatureVerification(signer,verifier);
}","@Test public void testEncodedSha384SignatureVerification() throws Exception {
  Signer signer=factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1));
  Signer verifier=factory.getInstance(false,publicKey,signer.getEncoded());
  runTestSignatureVerification(signer,verifier);
}",0.9917355371900828
1674,"@Test public void testEncodedDefaultSignatureVerification() throws Exception {
  Signer signer=factory.getInstance(true,privateKey);
  Signer verifier=factory.getInstance(false,publicKey,signer.getEncoded());
  testSignatureVerification(signer,verifier);
}","@Test public void testEncodedDefaultSignatureVerification() throws Exception {
  Signer signer=factory.getInstance(true,privateKey);
  Signer verifier=factory.getInstance(false,publicKey,signer.getEncoded());
  runTestSignatureVerification(signer,verifier);
}",0.9902912621359224
1675,"@Test public void testEncodedSha224SignatureVerification() throws Exception {
  Signer signer=factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1));
  Signer verifier=factory.getInstance(false,publicKey,signer.getEncoded());
  testSignatureVerification(signer,verifier);
}","@Test public void testEncodedSha224SignatureVerification() throws Exception {
  Signer signer=factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1));
  Signer verifier=factory.getInstance(false,publicKey,signer.getEncoded());
  runTestSignatureVerification(signer,verifier);
}",0.9917355371900828
1676,"@Test public void testDefaultSignatureVerification() throws Exception {
  testSignatureVerification(factory.getInstance(true,privateKey),factory.getInstance(false,publicKey));
}","@Test public void testDefaultSignatureVerification() throws Exception {
  runTestSignatureVerification(factory.getInstance(true,privateKey),factory.getInstance(false,publicKey));
}",0.9859943977591036
1677,"@Test public void testSha384SignatureVerification() throws Exception {
  testSignatureVerification(factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1)),factory.getInstance(false,new PssSignerParameters(publicKey,""String_Node_Str"",-1)));
}","@Test public void testSha384SignatureVerification() throws Exception {
  runTestSignatureVerification(factory.getInstance(true,new PssSignerParameters(privateKey,""String_Node_Str"",-1)),factory.getInstance(false,new PssSignerParameters(publicKey,""String_Node_Str"",-1)));
}",0.9907235621521336
1678,"private void runTest(MockitoComponentMockingRule<SignerFactory> mocker) throws Exception {
  Signer signer=mocker.getComponentUnderTest().getInstance(true,privateKey);
  testSignatureVerification(signer,factory.getInstance(false,publicKey,signer.getEncoded()));
}","private void runTest(MockitoComponentMockingRule<SignerFactory> mocker) throws Exception {
  Signer signer=mocker.getComponentUnderTest().getInstance(true,privateKey);
  runTestSignatureVerification(signer,factory.getInstance(false,publicKey,signer.getEncoded()));
}",0.9905482041587902
1679,"/** 
 * @param rawConstraint the constraint to parse
 * @return the list of version ranges
 * @throws InvalidVersionConstraintException invalid constraint range syntax
 */
private List<VersionRangeCollection> parseRanges(String rawConstraint) throws InvalidVersionConstraintException {
  String constraint=rawConstraint;
  List<VersionRangeCollection> newRanges=new ArrayList<VersionRangeCollection>();
  while (VersionUtils.startsWith(constraint,'{')) {
    int index=constraint.indexOf('}');
    if (index < 0) {
      throw new InvalidVersionConstraintException(String.format(""String_Node_Str"",rawConstraint));
    }
    String range=constraint.substring(1,index);
    try {
      newRanges.add(new DefaultVersionRangeCollection(range));
    }
 catch (    InvalidVersionRangeException e) {
      throw new InvalidVersionConstraintException(String.format(""String_Node_Str"",range,rawConstraint,e));
    }
    constraint=constraint.substring(index + 1).trim();
    if (VersionUtils.startsWith(constraint,RANGE_SEPARATOR)) {
      constraint=constraint.substring(1).trim();
    }
  }
  if (!constraint.isEmpty()) {
    if (newRanges.isEmpty()) {
      try {
        newRanges.add(new DefaultVersionRangeCollection(constraint));
      }
 catch (      InvalidVersionRangeException e) {
        throw new InvalidVersionConstraintException(String.format(""String_Node_Str"",constraint),e);
      }
    }
 else {
      throw new InvalidVersionConstraintException(String.format(""String_Node_Str"",rawConstraint,constraint));
    }
  }
  return newRanges;
}","/** 
 * @param rawConstraint the constraint to parse
 * @return the list of version ranges
 * @throws InvalidVersionConstraintException invalid constraint range syntax
 */
private List<VersionRangeCollection> parseRanges(String rawConstraint) throws InvalidVersionConstraintException {
  String constraint=rawConstraint;
  List<VersionRangeCollection> newRanges=new ArrayList<VersionRangeCollection>();
  while (VersionUtils.startsWith(constraint,'{')) {
    int index=constraint.indexOf('}');
    if (index < 0) {
      throw new InvalidVersionConstraintException(String.format(""String_Node_Str"",rawConstraint));
    }
    String range=constraint.substring(1,index);
    try {
      newRanges.add(new DefaultVersionRangeCollection(range));
    }
 catch (    InvalidVersionRangeException e) {
      throw new InvalidVersionConstraintException(String.format(""String_Node_Str"",range,rawConstraint),e);
    }
    constraint=constraint.substring(index + 1).trim();
    if (VersionUtils.startsWith(constraint,RANGE_SEPARATOR)) {
      constraint=constraint.substring(1).trim();
    }
  }
  if (!constraint.isEmpty()) {
    if (newRanges.isEmpty()) {
      try {
        newRanges.add(new DefaultVersionRangeCollection(constraint));
      }
 catch (      InvalidVersionRangeException e) {
        throw new InvalidVersionConstraintException(String.format(""String_Node_Str"",constraint),e);
      }
    }
 else {
      throw new InvalidVersionConstraintException(String.format(""String_Node_Str"",rawConstraint,constraint));
    }
  }
  return newRanges;
}",0.999353169469599
1680,"public AetherExtensionRepository(ExtensionRepositoryDescriptor repositoryDescriptor,AetherExtensionRepositoryFactory repositoryFactory,PlexusComponentManager mavenComponentManager,ComponentManager componentManager) throws Exception {
  super(repositoryDescriptor);
  this.repositoryFactory=repositoryFactory;
  this.plexusComponentManager=mavenComponentManager;
  this.remoteRepository=new RemoteRepository(repositoryDescriptor.getId(),""String_Node_Str"",repositoryDescriptor.getURI().toString());
  String user=getDescriptor().getProperty(""String_Node_Str"");
  if (user != null) {
    this.remoteRepository.setAuthentication(new Authentication(user,getDescriptor().getProperty(""String_Node_Str"")));
  }
  try {
    this.remoteRepository.setProxy(determineProxy(repositoryDescriptor.getURI()));
  }
 catch (  Exception e) {
    LOGGER.warn(""String_Node_Str"",repositoryDescriptor.getURI());
  }
  this.converter=componentManager.getInstance(ConverterManager.class);
  this.licenseManager=componentManager.getInstance(ExtensionLicenseManager.class);
  this.versionRangeResolver=this.plexusComponentManager.getPlexus().lookup(VersionRangeResolver.class);
  try {
    this.mavenDescriptorReader=this.plexusComponentManager.getPlexus().lookup(ArtifactDescriptorReader.class);
    if (loadPomMethod == null) {
      loadPomMethod=this.mavenDescriptorReader.getClass().getDeclaredMethod(""String_Node_Str"",RepositorySystemSession.class,ArtifactDescriptorRequest.class,ArtifactDescriptorResult.class);
      loadPomMethod.setAccessible(true);
      convertMethod=this.mavenDescriptorReader.getClass().getDeclaredMethod(""String_Node_Str"",org.apache.maven.model.Dependency.class,ArtifactTypeRegistry.class);
      convertMethod.setAccessible(true);
    }
  }
 catch (  ComponentLookupException e) {
  }
}","public AetherExtensionRepository(ExtensionRepositoryDescriptor repositoryDescriptor,AetherExtensionRepositoryFactory repositoryFactory,PlexusComponentManager mavenComponentManager,ComponentManager componentManager) throws Exception {
  super(repositoryDescriptor);
  this.repositoryFactory=repositoryFactory;
  this.plexusComponentManager=mavenComponentManager;
  this.remoteRepository=new RemoteRepository(repositoryDescriptor.getId(),""String_Node_Str"",repositoryDescriptor.getURI().toString());
  String user=getDescriptor().getProperty(""String_Node_Str"");
  if (user != null) {
    this.remoteRepository.setAuthentication(new Authentication(user,getDescriptor().getProperty(""String_Node_Str"")));
  }
  try {
    this.remoteRepository.setProxy(determineProxy(repositoryDescriptor.getURI()));
  }
 catch (  Exception e) {
    LOGGER.warn(""String_Node_Str"",repositoryDescriptor.getURI());
  }
  this.converter=componentManager.getInstance(ConverterManager.class);
  this.licenseManager=componentManager.getInstance(ExtensionLicenseManager.class);
  this.versionRangeResolver=this.plexusComponentManager.getPlexus().lookup(VersionRangeResolver.class);
  try {
    this.mavenDescriptorReader=this.plexusComponentManager.getPlexus().lookup(ArtifactDescriptorReader.class);
    this.loadPomMethod=this.mavenDescriptorReader.getClass().getDeclaredMethod(""String_Node_Str"",RepositorySystemSession.class,ArtifactDescriptorRequest.class,ArtifactDescriptorResult.class);
    this.loadPomMethod.setAccessible(true);
    this.convertMethod=this.mavenDescriptorReader.getClass().getDeclaredMethod(""String_Node_Str"",org.apache.maven.model.Dependency.class,ArtifactTypeRegistry.class);
    this.convertMethod.setAccessible(true);
  }
 catch (  ComponentLookupException e) {
  }
}",0.9811639021647456
1681,"public URL findResource(String name){
  return this.loader.findResource(getUrls(),name);
}","@Override public URL findResource(String name){
  return this.loader.findResource(getUrls(),name);
}",0.9473684210526316
1682,"/** 
 * Returns an Enumeration of ResourceHandle objects representing all of the resources having the specified name.
 * @param name the name of the resource
 * @return the ResourceHandle of the resource
 */
protected Enumeration<ResourceHandle> getResourceHandles(final String name){
  return AccessController.doPrivileged(new PrivilegedAction<Enumeration<ResourceHandle>>(){
    public Enumeration<ResourceHandle> run(){
      return URIClassLoader.this.finder.getResources(name);
    }
  }
,this.acc);
}","/** 
 * Returns an Enumeration of ResourceHandle objects representing all of the resources having the specified name.
 * @param name the name of the resource
 * @return the ResourceHandle of the resource
 */
protected Enumeration<ResourceHandle> getResourceHandles(final String name){
  return AccessController.doPrivileged(new PrivilegedAction<Enumeration<ResourceHandle>>(){
    @Override public Enumeration<ResourceHandle> run(){
      return URIClassLoader.this.finder.getResources(name);
    }
  }
,this.acc);
}",0.9902152641878668
1683,"public ResourceHandle getResource(String name){
  return this.loader.getResource(getUrls(),name);
}","@Override public ResourceHandle getResource(String name){
  return this.loader.getResource(getUrls(),name);
}",0.9519230769230768
1684,"public Enumeration<URL> findResources(String name){
  return this.loader.findResources(getUrls(),name);
}","@Override public Enumeration<URL> findResources(String name){
  return this.loader.findResources(getUrls(),name);
}",0.9545454545454546
1685,"public Enumeration<ResourceHandle> run(){
  return URIClassLoader.this.finder.getResources(name);
}","@Override public Enumeration<ResourceHandle> run(){
  return URIClassLoader.this.finder.getResources(name);
}",0.9519230769230768
1686,"/** 
 * Finds and loads the class with the specified name.
 * @param name the name of the class
 * @return the resulting class
 * @exception ClassNotFoundException if the class could not be found
 */
@Override protected Class<?> findClass(final String name) throws ClassNotFoundException {
  try {
    return AccessController.doPrivileged(new PrivilegedExceptionAction<Class<?>>(){
      public Class<?> run() throws ClassNotFoundException {
        String path=name.replace('.','/').concat(""String_Node_Str"");
        ResourceHandle h=URIClassLoader.this.finder.getResource(path);
        if (h != null) {
          try {
            return defineClass(name,h);
          }
 catch (          IOException e) {
            throw new ClassNotFoundException(name,e);
          }
        }
 else {
          throw new ClassNotFoundException(name);
        }
      }
    }
,this.acc);
  }
 catch (  java.security.PrivilegedActionException pae) {
    throw (ClassNotFoundException)pae.getException();
  }
}","/** 
 * Finds and loads the class with the specified name.
 * @param name the name of the class
 * @return the resulting class
 * @exception ClassNotFoundException if the class could not be found
 */
@Override protected Class<?> findClass(final String name) throws ClassNotFoundException {
  try {
    return AccessController.doPrivileged(new PrivilegedExceptionAction<Class<?>>(){
      @Override public Class<?> run() throws ClassNotFoundException {
        String path=name.replace('.','/').concat(""String_Node_Str"");
        ResourceHandle h=URIClassLoader.this.finder.getResource(path);
        if (h != null) {
          try {
            return defineClass(name,h);
          }
 catch (          IOException e) {
            throw new ClassNotFoundException(name,e);
          }
        }
 else {
          throw new ClassNotFoundException(name);
        }
      }
    }
,this.acc);
  }
 catch (  java.security.PrivilegedActionException pae) {
    throw (ClassNotFoundException)pae.getException();
  }
}",0.9950248756218906
1687,"/** 
 * Finds the ResourceHandle object for the resource with the specified name.
 * @param name the name of the resource
 * @return the ResourceHandle of the resource
 */
protected ResourceHandle getResourceHandle(final String name){
  return AccessController.doPrivileged(new PrivilegedAction<ResourceHandle>(){
    public ResourceHandle run(){
      return URIClassLoader.this.finder.getResource(name);
    }
  }
,this.acc);
}","/** 
 * Finds the ResourceHandle object for the resource with the specified name.
 * @param name the name of the resource
 * @return the ResourceHandle of the resource
 */
protected ResourceHandle getResourceHandle(final String name){
  return AccessController.doPrivileged(new PrivilegedAction<ResourceHandle>(){
    @Override public ResourceHandle run(){
      return URIClassLoader.this.finder.getResource(name);
    }
  }
,this.acc);
}",0.988479262672811
1688,"public Enumeration<ResourceHandle> getResources(String name){
  return this.loader.getResources(getUrls(),name);
}","@Override public Enumeration<ResourceHandle> getResources(String name){
  return this.loader.getResources(getUrls(),name);
}",0.957983193277311
1689,"public boolean hasMoreElements(){
  fetchNext();
  return (this.next != null);
}","@Override public boolean hasMoreElements(){
  fetchNext();
  return (this.next != null);
}",0.9411764705882352
1690,"public T nextElement(){
  fetchNext();
  if (this.next == null) {
    throw new NoSuchElementException();
  }
  ;
  T nextElement=this.next;
  this.next=null;
  return nextElement;
}","@Override public T nextElement(){
  fetchNext();
  if (this.next == null) {
    throw new NoSuchElementException();
  }
  ;
  T nextElement=this.next;
  this.next=null;
  return nextElement;
}",0.9732620320855616
1691,"/** 
 * @param actions the actions to apply
 * @throws InstallException failed to install extension
 * @throws UninstallException failed to uninstall extension
 * @throws LocalExtensionRepositoryException failed to store extension
 * @throws ResolveException could not find extension in the local repository
 */
protected void applyActions(Collection<ExtensionPlanAction> actions) throws LocalExtensionRepositoryException, InstallException, UninstallException, ResolveException {
  notifyPushLevelProgress(actions.size());
  try {
    for (    ExtensionPlanAction action : actions) {
      if (action.getAction() != Action.NONE) {
        applyAction(action);
      }
      notifyStepPropress();
    }
  }
  finally {
    notifyPopLevelProgress();
  }
}","/** 
 * @param actions the actions to apply
 * @throws InstallException failed to install extension
 * @throws UninstallException failed to uninstall extension
 * @throws ResolveException could not find extension in the local repository
 */
protected void applyActions(Collection<ExtensionPlanAction> actions) throws InstallException, UninstallException, ResolveException {
  notifyPushLevelProgress(actions.size());
  try {
    for (    ExtensionPlanAction action : actions) {
      if (action.getAction() != Action.NONE) {
        applyAction(action);
      }
      notifyStepPropress();
    }
  }
  finally {
    notifyPopLevelProgress();
  }
}",0.9242857142857144
1692,"/** 
 * @param action the action to perform
 * @throws InstallException failed to install extension
 * @throws UninstallException failed to uninstall extension
 * @throws LocalExtensionRepositoryException failed to store extension
 * @throws ResolveException could not find extension in the local repository
 */
protected void applyAction(ExtensionPlanAction action) throws InstallException, UninstallException, LocalExtensionRepositoryException, ResolveException {
  Extension extension=action.getExtension();
  String namespace=action.getNamespace();
  if (namespace != null) {
    this.logger.info(""String_Node_Str"",new Object[]{action.getAction(),extension.getId(),namespace});
  }
 else {
    this.logger.info(""String_Node_Str"",action.getAction(),extension.getId());
  }
  notifyPushLevelProgress(2);
  try {
    if (action.getAction() == Action.UNINSTALL) {
      InstalledExtension installedExtension=(InstalledExtension)action.getExtension();
      notifyStepPropress();
      uninstallExtension(installedExtension,namespace);
    }
 else {
      LocalExtension localExtension=this.localExtensionRepository.resolve(extension.getId());
      notifyStepPropress();
      installExtension(localExtension,action.getPreviousExtension(),namespace,action.isDependency());
    }
    if (namespace != null) {
      this.logger.info(""String_Node_Str"",new Object[]{action.getAction(),extension.getId(),namespace});
    }
 else {
      this.logger.info(""String_Node_Str"",action.getAction(),extension.getId());
    }
  }
  finally {
    notifyPopLevelProgress();
  }
}","/** 
 * @param action the action to perform
 * @throws InstallException failed to install extension
 * @throws UninstallException failed to uninstall extension
 * @throws ResolveException could not find extension in the local repository
 */
protected void applyAction(ExtensionPlanAction action) throws InstallException, UninstallException, ResolveException {
  Extension extension=action.getExtension();
  String namespace=action.getNamespace();
  if (namespace != null) {
    this.logger.info(""String_Node_Str"",new Object[]{action.getAction(),extension.getId(),namespace});
  }
 else {
    this.logger.info(""String_Node_Str"",action.getAction(),extension.getId());
  }
  notifyPushLevelProgress(2);
  try {
    if (action.getAction() == Action.UNINSTALL) {
      InstalledExtension installedExtension=(InstalledExtension)action.getExtension();
      notifyStepPropress();
      uninstallExtension(installedExtension,namespace);
    }
 else {
      LocalExtension localExtension=this.localExtensionRepository.resolve(extension.getId());
      notifyStepPropress();
      installExtension(localExtension,action.getPreviousExtension(),namespace,action.isDependency());
    }
    if (namespace != null) {
      this.logger.info(""String_Node_Str"",new Object[]{action.getAction(),extension.getId(),namespace});
    }
 else {
      this.logger.info(""String_Node_Str"",action.getAction(),extension.getId());
    }
  }
  finally {
    notifyPopLevelProgress();
  }
}",0.9649006622516556
1693,"/** 
 * @param action the action containing the extension to download
 * @throws LocalExtensionRepositoryException failed to store extension
 * @throws InstallException unsupported action
 */
private void store(ExtensionPlanAction action) throws LocalExtensionRepositoryException, InstallException {
  if (action.getAction() == Action.INSTALL || action.getAction() == Action.UPGRADE || action.getAction() == Action.DOWNGRADE) {
    storeExtension(action.getExtension());
  }
}","/** 
 * @param action the action containing the extension to download
 * @throws LocalExtensionRepositoryException failed to store extension
 */
private void store(ExtensionPlanAction action) throws LocalExtensionRepositoryException {
  if (action.getAction() == Action.INSTALL || action.getAction() == Action.UPGRADE || action.getAction() == Action.DOWNGRADE) {
    storeExtension(action.getExtension());
  }
}",0.9267192784667418
1694,"/** 
 * Uninstall provided extension.
 * @param feature the feature to uninstall
 * @param namespace the namespace
 * @throws UninstallException error when trying to uninstall extension
 * @see #uninstallExtension(LocalExtension,String)
 */
private void removeInstalledFeature(String feature,String namespace) throws UninstallException {
  if (namespace == null) {
    this.extensionNamespaceByFeature.remove(feature);
  }
 else {
    Map<String,InstalledFeature> namespaceInstalledExtension=this.extensionNamespaceByFeature.get(feature);
    namespaceInstalledExtension.remove(namespace);
  }
}","/** 
 * Uninstall provided extension.
 * @param feature the feature to uninstall
 * @param namespace the namespace
 * @see #uninstallExtension(LocalExtension,String)
 */
private void removeInstalledFeature(String feature,String namespace){
  if (namespace == null) {
    this.extensionNamespaceByFeature.remove(feature);
  }
 else {
    Map<String,InstalledFeature> namespaceInstalledExtension=this.extensionNamespaceByFeature.get(feature);
    namespaceInstalledExtension.remove(namespace);
  }
}",0.9102564102564102
1695,"/** 
 * Uninstall provided extension.
 * @param installedExtension the extension to uninstall
 * @param namespace the namespace
 * @throws UninstallException error when trying to uninstall extension
 * @see #uninstallExtension(LocalExtension,String)
 */
private void removeInstalledExtension(DefaultInstalledExtension installedExtension,String namespace) throws UninstallException {
  removeInstalledFeature(installedExtension.getId().getId(),namespace);
  for (  String feature : installedExtension.getFeatures()) {
    removeInstalledFeature(feature,namespace);
  }
  removeFromBackwardDependencies(installedExtension,namespace);
  if (!installedExtension.isInstalled()) {
    removeCachedExtension(installedExtension);
  }
}","/** 
 * Uninstall provided extension.
 * @param installedExtension the extension to uninstall
 * @param namespace the namespace
 * @see #uninstallExtension(LocalExtension,String)
 */
private void removeInstalledExtension(DefaultInstalledExtension installedExtension,String namespace){
  removeInstalledFeature(installedExtension.getId().getId(),namespace);
  for (  String feature : installedExtension.getFeatures()) {
    removeInstalledFeature(feature,namespace);
  }
  removeFromBackwardDependencies(installedExtension,namespace);
  if (!installedExtension.isInstalled()) {
    removeCachedExtension(installedExtension);
  }
}",0.9277286135693216
1696,"/** 
 * @return a new collection
 */
protected Set createCollection(){
  return new HashSet();
}","/** 
 * @return a new collection
 */
@Override protected Set createCollection(){
  return new HashSet();
}",0.9504950495049505
1697,"public void generateExtension(String classPackageFolder,URL descriptorUrl) throws IOException {
  String descriptorUrlStr=descriptorUrl.toString();
  String descriptorFolderURL=descriptorUrlStr.substring(0,descriptorUrlStr.length() - PACKAGEFILE_DESCRIPTOR.length());
  InputStream descriptorStream=descriptorUrl.openStream();
  Properties descriptorProperties=new Properties();
  descriptorProperties.load(descriptorStream);
  String type=descriptorProperties.getProperty(""String_Node_Str"");
  if (type == null) {
    type=""String_Node_Str"";
  }
  String id=descriptorProperties.getProperty(""String_Node_Str"");
  if (id == null) {
    id=descriptorFolderURL.substring(0,descriptorFolderURL.length() - 1);
    id=id.substring(id.lastIndexOf('/') + 1);
  }
  String version=descriptorProperties.getProperty(""String_Node_Str"");
  if (version == null) {
    version=""String_Node_Str"";
  }
  File packageFile;
  String directory=descriptorProperties.getProperty(""String_Node_Str"");
  String fileName=descriptorProperties.getProperty(""String_Node_Str"");
  if (directory == null) {
    if (fileName == null) {
      packageFile=new File(this.defaultDirectory,URLEncoder.encode(id + '-' + version+ '.'+ type,""String_Node_Str""));
    }
 else {
      packageFile=new File(this.defaultDirectory,fileName);
    }
  }
 else {
    if (fileName == null) {
      fileName=URLEncoder.encode(id + '-' + version+ '.'+ type,""String_Node_Str"");
    }
    packageFile=new File(this.workingDirectory,directory);
    packageFile=new File(packageFile,fileName);
  }
  packageFile.getParentFile().mkdirs();
  FileOutputStream fos=new FileOutputStream(packageFile);
  try {
    ZipOutputStream zos;
    if (type.equals(""String_Node_Str"")) {
      Manifest manifest=new Manifest();
      manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION,""String_Node_Str"");
      zos=new JarOutputStream(fos,manifest);
    }
 else {
      zos=new ZipOutputStream(fos);
    }
    try {
      for (      Vfs.File resourceFile : Vfs.fromURL(new URL(descriptorFolderURL)).getFiles()) {
        if (!resourceFile.getRelativePath().equals(PACKAGEFILE_DESCRIPTOR)) {
          addZipEntry(classPackageFolder,resourceFile,zos,type);
        }
      }
    }
  finally {
      zos.close();
    }
    this.extensionsFiles.put(new ExtensionId(id,version),packageFile);
  }
  finally {
    fos.close();
  }
}","public void generateExtension(String classPackageFolder,URL descriptorUrl) throws IOException {
  String descriptorUrlStr=descriptorUrl.toString();
  String descriptorFolderURL=descriptorUrlStr.substring(0,descriptorUrlStr.length() - PACKAGEFILE_DESCRIPTOR.length());
  Properties descriptorProperties=new Properties();
  InputStream descriptorStream=descriptorUrl.openStream();
  try {
    descriptorProperties.load(descriptorStream);
  }
  finally {
    descriptorStream.close();
  }
  String type=descriptorProperties.getProperty(""String_Node_Str"");
  if (type == null) {
    type=""String_Node_Str"";
  }
  String id=descriptorProperties.getProperty(""String_Node_Str"");
  if (id == null) {
    id=descriptorFolderURL.substring(0,descriptorFolderURL.length() - 1);
    id=id.substring(id.lastIndexOf('/') + 1);
  }
  String version=descriptorProperties.getProperty(""String_Node_Str"");
  if (version == null) {
    version=""String_Node_Str"";
  }
  File packageFile;
  String directory=descriptorProperties.getProperty(""String_Node_Str"");
  String fileName=descriptorProperties.getProperty(""String_Node_Str"");
  if (directory == null) {
    if (fileName == null) {
      packageFile=new File(this.defaultDirectory,URLEncoder.encode(id + '-' + version+ '.'+ type,""String_Node_Str""));
    }
 else {
      packageFile=new File(this.defaultDirectory,fileName);
    }
  }
 else {
    if (fileName == null) {
      fileName=URLEncoder.encode(id + '-' + version+ '.'+ type,""String_Node_Str"");
    }
    packageFile=new File(this.workingDirectory,directory);
    packageFile=new File(packageFile,fileName);
  }
  packageFile.getParentFile().mkdirs();
  FileOutputStream fos=new FileOutputStream(packageFile);
  try {
    ZipOutputStream zos;
    if (type.equals(""String_Node_Str"")) {
      Manifest manifest=new Manifest();
      manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION,""String_Node_Str"");
      zos=new JarOutputStream(fos,manifest);
    }
 else {
      zos=new ZipOutputStream(fos);
    }
    try {
      for (      Vfs.File resourceFile : Vfs.fromURL(new URL(descriptorFolderURL)).getFiles()) {
        if (!resourceFile.getRelativePath().equals(PACKAGEFILE_DESCRIPTOR)) {
          addZipEntry(classPackageFolder,resourceFile,zos,type);
        }
      }
    }
  finally {
      zos.close();
    }
    this.extensionsFiles.put(new ExtensionId(id,version),packageFile);
  }
  finally {
    fos.close();
  }
}",0.9616346955796498
1698,"/** 
 * Unzip xar artifact and its dependencies.
 * @throws ArchiverException error when unzip package.
 * @throws IOException error when unzip package.
 * @throws MojoExecutionException error when unzip package.
 */
private void performUnArchive() throws ArchiverException, IOException, MojoExecutionException {
  Artifact artifact=findArtifact();
  getLog().debug(String.format(""String_Node_Str"",artifact.getFile()));
  unpack(artifact.getFile(),this.outputDirectory,""String_Node_Str"",true);
  unpackDependentXars(artifact);
}","/** 
 * Unzip xar artifact and its dependencies.
 * @throws ArchiverException error when unzip package.O
 * @throws MojoExecutionException error when unzip package.
 */
private void performUnArchive() throws ArchiverException, MojoExecutionException {
  Artifact artifact=findArtifact();
  getLog().debug(String.format(""String_Node_Str"",artifact.getFile()));
  unpack(artifact.getFile(),this.outputDirectory,""String_Node_Str"",true);
  unpackDependentXars(artifact);
}",0.9386934673366836
1699,"/** 
 * @param directoryName the name of the directory to initialize (ensure it exists, create thedirectory)
 * @param isTemp true if we are initializing a temporary directory.
 * @param tempOrPermanent a string describing the type of directory,namely ""temporary"" or ""permanent"", to aid logging.
 * @return the initialized directory as a {@link File} or null if the directory doesn't existand cannot be created or if the process doesn't have permission to write to it.
 */
private File initializeDirectory(final String directoryName,final boolean isTemp,final String tempOrPermanent){
  final File dir=(isTemp) ? new File(directoryName,TEMP_NAME) : new File(directoryName);
  if (dir.exists()) {
    if (dir.isDirectory() && dir.canWrite()) {
      return this.initDir(dir,isTemp);
    }
    final String[] params=new String[]{tempOrPermanent,dir.getAbsolutePath(),(dir.isDirectory()) ? ""String_Node_Str"" : ""String_Node_Str""};
    this.logger.error(""String_Node_Str"",params);
    return null;
  }
 else   if (dir.mkdirs()) {
    return this.initDir(dir,isTemp);
  }
  this.logger.error(""String_Node_Str"",tempOrPermanent,dir.getAbsolutePath());
  return null;
}","/** 
 * @param directoryName the name of the directory to initialize (ensure it exists, create thedirectory)
 * @param isTemp true if we are initializing a temporary directory.
 * @param tempOrPermanent a string describing the type of directory,namely ""temporary"" or ""permanent"", to aid logging.
 * @return the initialized directory as a {@link File} or null if the directory doesn't existand cannot be created or if the process doesn't have permission to write to it.
 */
private File initializeDirectory(final String directoryName,final boolean isTemp,final String tempOrPermanent){
  final File dir=(isTemp) ? new File(directoryName,TEMP_NAME) : new File(directoryName);
  if (dir.exists()) {
    if (dir.isDirectory() && dir.canWrite()) {
      return initDir(dir,isTemp);
    }
    final String[] params=new String[]{tempOrPermanent,dir.getAbsolutePath(),(dir.isDirectory()) ? ""String_Node_Str"" : ""String_Node_Str""};
    this.logger.error(""String_Node_Str"",params);
    return null;
  }
 else   if (dir.mkdirs()) {
    return initDir(dir,isTemp);
  }
  this.logger.error(""String_Node_Str"",tempOrPermanent,dir.getAbsolutePath());
  return null;
}",0.9956709956709956
1700,"/** 
 * Initialize the internal xwiki-temp directory. This function clears the directory out.
 * @param tempDir the xwiki-temp subdirectory which is internal/deleted per load.
 */
private void initTempDir(final File tempDir){
  final File permDir=this.getPermanentDirectory();
  try {
    if (tempDir.equals(permDir) || FileUtils.directoryContains(tempDir,permDir)) {
      throw new RuntimeException(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",TEMP_NAME));
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  try {
    FileUtils.cleanDirectory(tempDir);
  }
 catch (  IOException e) {
    throw new RuntimeException(String.format(""String_Node_Str"" + ""String_Node_Str"",tempDir.getAbsolutePath()));
  }
}","/** 
 * Initialize the internal xwiki-temp directory. This function clears the directory out.
 * @param tempDir the xwiki-temp subdirectory which is internal/deleted per load.
 */
private void initTempDir(final File tempDir){
  final File permDir=getPermanentDirectory();
  try {
    if (tempDir.equals(permDir) || FileUtils.directoryContains(tempDir,permDir)) {
      throw new RuntimeException(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",TEMP_NAME));
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  try {
    FileUtils.cleanDirectory(tempDir);
  }
 catch (  IOException e) {
    throw new RuntimeException(String.format(""String_Node_Str"" + ""String_Node_Str"",tempDir.getAbsolutePath()));
  }
}",0.996845425867508
1701,"/** 
 * {@inheritDoc}Rather than overriding this, it is safer to override   {@link #getPermanentDirectoryName()}This is because this function does a number of checks to make sure the directory exists, is a directory (not a file) and the XWiki process has permission to write to it. If the directory doesn't exist it is created and if it cannot be written to, an error is printed in the log and it is passed over for the default permanent directory.
 * @see Environment#getPermanentDirectory()
 */
@Override public File getPermanentDirectory(){
  if (this.permanentDirectory == null) {
    final String classSpecified=this.getPermanentDirectoryName();
    final String configured=this.configurationProvider.get().getPermanentDirectoryPath();
    if (classSpecified == null && configured == null) {
      this.logger.warn(""String_Node_Str"",DEFAULT_TMP_DIRECTORY);
    }
    final String[] locations=new String[]{classSpecified,configured,this.getTemporaryDirectoryName(),DEFAULT_TMP_DIRECTORY};
    this.permanentDirectory=this.initializeDirectory(locations,false);
  }
  return this.permanentDirectory;
}","/** 
 * {@inheritDoc}<p> Rather than overriding this, it is safer to override   {@link #getPermanentDirectoryName()} if you need to changethe default behavior. This is because this method does a number of checks to make sure the directory exists, is a directory (not a file) and the XWiki process has permission to write to it. If the directory doesn't exist it is created and if it cannot be written to, an error is printed in the log and it is passed over for the default permanent directory. Thus by overriding {@link #getPermanentDirectoryName()} you'll still benefit from all those checks.</p>
 */
@Override public File getPermanentDirectory(){
  if (this.permanentDirectory == null) {
    final String classSpecified=getPermanentDirectoryName();
    final String configured=this.configurationProvider.get().getPermanentDirectoryPath();
    if (classSpecified == null && configured == null) {
      this.logger.warn(""String_Node_Str"",DEFAULT_TMP_DIRECTORY);
    }
    final String[] locations=new String[]{classSpecified,configured,getTemporaryDirectoryName(),DEFAULT_TMP_DIRECTORY};
    this.permanentDirectory=initializeDirectory(locations,false);
  }
  return this.permanentDirectory;
}",0.9238136700043535
1702,"/** 
 * {@inheritDoc}Rather than overriding this, it is safer to override   {@link #getTemporaryDirectoryName()}This is because this function does a number of checks to make sure the directory exists, is a directory (not a file) and the XWiki process has permission to write to it. If the directory doesn't exist it is created and if it cannot be written to, an erroris printed in the log and it is passed over for the default temporary directory.
 * @see Environment#getTemporaryDirectory()
 */
@Override public File getTemporaryDirectory(){
  if (this.temporaryDirectory == null) {
    final String[] locations=new String[]{this.getTemporaryDirectoryName(),DEFAULT_TMP_DIRECTORY};
    this.temporaryDirectory=this.initializeDirectory(locations,true);
  }
  return this.temporaryDirectory;
}","/** 
 * {@inheritDoc}Rather than overriding this, it is safer to override   {@link #getTemporaryDirectoryName()}This is because this function does a number of checks to make sure the directory exists, is a directory (not a file) and the XWiki process has permission to write to it. If the directory doesn't exist it is created and if it cannot be written to, an erroris printed in the log and it is passed over for the default temporary directory.
 * @see Environment#getTemporaryDirectory()
 */
@Override public File getTemporaryDirectory(){
  if (this.temporaryDirectory == null) {
    final String[] locations=new String[]{getTemporaryDirectoryName(),DEFAULT_TMP_DIRECTORY};
    this.temporaryDirectory=initializeDirectory(locations,true);
  }
  return this.temporaryDirectory;
}",0.9936467598475224
1703,"/** 
 * Initialize temporary or permanent directory for use.
 * @param directory the directory to initialize.
 * @param isTemp true if it is a temporary directory.
 * @return the newly initialized directory.
 */
private File initDir(final File directory,final boolean isTemp){
  if (isTemp) {
    this.initTempDir(directory);
  }
  return directory;
}","/** 
 * Initialize temporary or permanent directory for use.
 * @param directory the directory to initialize.
 * @param isTemp true if it is a temporary directory.
 * @return the newly initialized directory.
 */
private File initDir(final File directory,final boolean isTemp){
  if (isTemp) {
    initTempDir(directory);
  }
  return directory;
}",0.9928263988522238
1704,"@Override protected String getTemporaryDirectoryName(){
  final String tmpDirectory=super.getTemporaryDirectoryName();
  try {
    if (tmpDirectory == null) {
      return ((File)this.getServletContext().getAttribute(""String_Node_Str"")).getCanonicalPath();
    }
  }
 catch (  IOException e) {
    this.logger.warn(""String_Node_Str"" + ""String_Node_Str"",e.getMessage());
  }
  return tmpDirectory;
}","@Override protected String getTemporaryDirectoryName(){
  final String tmpDirectory=super.getTemporaryDirectoryName();
  try {
    if (tmpDirectory == null) {
      File tempDir=(File)this.getServletContext().getAttribute(""String_Node_Str"");
      return tempDir == null ? null : tempDir.getCanonicalPath();
    }
  }
 catch (  IOException e) {
    this.logger.warn(""String_Node_Str"" + ""String_Node_Str"",ExceptionUtils.getMessage(e));
  }
  return tmpDirectory;
}",0.8989547038327527
1705,"@Test public void testGetTemporaryDirectoryWhenNotSet(){
  final ServletContext servletContext=getMockery().mock(ServletContext.class);
  getMockery().checking(new Expectations(){
{
      atLeast(1).of(servletContext).getAttribute(""String_Node_Str"");
      will(returnValue(servletTmpDir));
    }
  }
);
  this.environment.setServletContext(servletContext);
  final File tmpDir=this.environment.getTemporaryDirectory();
  Assert.assertEquals(this.servletTmpDir.listFiles()[0],tmpDir);
}","@Test public void testGetTemporaryDirectoryWhenNotSet() throws Exception {
  final ServletContext servletContext=getMockery().mock(ServletContext.class);
  getMockery().checking(new Expectations(){
{
      atLeast(1).of(servletContext).getAttribute(""String_Node_Str"");
      will(returnValue(servletTmpDir));
    }
  }
);
  this.environment.setServletContext(servletContext);
  final File tmpDir=this.environment.getTemporaryDirectory();
  Assert.assertEquals(this.servletTmpDir.listFiles()[0].getCanonicalFile(),tmpDir.getCanonicalFile());
}",0.9455252918287936
1706,"@Test public void testGetPermanentDirectory(){
  File permanentDirectory=new File(""String_Node_Str"");
  this.environment.setPermanentDirectory(permanentDirectory);
  Assert.assertEquals(permanentDirectory,this.environment.getPermanentDirectory());
}","@Test public void testGetPermanentDirectory() throws Exception {
  File permanentDirectory=new File(""String_Node_Str"");
  this.environment.setPermanentDirectory(permanentDirectory);
  Assert.assertEquals(permanentDirectory.getCanonicalFile(),this.environment.getPermanentDirectory().getCanonicalFile());
}",0.8989169675090253
1707,"@Test public void testGetPermanentDirectoryWhenNotSet(){
  final ServletContext servletContext=getMockery().mock(ServletContext.class);
  getMockery().checking(new Expectations(){
{
      oneOf(servletContext).getAttribute(""String_Node_Str"");
      will(returnValue(servletTmpDir));
    }
  }
);
  this.environment.setServletContext(servletContext);
  final Logger logger=getMockery().mock(Logger.class);
  getMockery().checking(new Expectations(){
{
      oneOf(logger).warn(with(startsWith(""String_Node_Str"")),with(any(String.class)));
    }
  }
);
  ReflectionUtils.setFieldValue(this.environment,""String_Node_Str"",logger);
  Assert.assertEquals(this.servletTmpDir,this.environment.getPermanentDirectory());
}","@Test public void testGetPermanentDirectoryWhenNotSet() throws Exception {
  final ServletContext servletContext=getMockery().mock(ServletContext.class);
  getMockery().checking(new Expectations(){
{
      oneOf(servletContext).getAttribute(""String_Node_Str"");
      will(returnValue(servletTmpDir));
    }
  }
);
  this.environment.setServletContext(servletContext);
  final Logger logger=getMockery().mock(Logger.class);
  getMockery().checking(new Expectations(){
{
      oneOf(logger).warn(with(startsWith(""String_Node_Str"")),with(any(String.class)));
    }
  }
);
  ReflectionUtils.setFieldValue(this.environment,""String_Node_Str"",logger);
  Assert.assertEquals(this.servletTmpDir.getCanonicalFile(),this.environment.getPermanentDirectory().getCanonicalFile());
}",0.9621621621621622
1708,"@Before public void setUp() throws Exception {
  EmbeddableComponentManager ecm=new EmbeddableComponentManager();
  ecm.initialize(getClass().getClassLoader());
  this.environment=(ServletEnvironment)ecm.getInstance(Environment.class);
}","@Before public void setUp() throws Exception {
  this.servletTmpDir=new File(System.getProperty(""String_Node_Str""),""String_Node_Str"");
  this.systemTmpDir=new File(System.getProperty(""String_Node_Str""),""String_Node_Str"");
  EmbeddableComponentManager ecm=new EmbeddableComponentManager();
  ecm.initialize(getClass().getClassLoader());
  this.environment=(ServletEnvironment)ecm.getInstance(Environment.class);
}",0.7303543913713405
1709,"@Test public void testGetTemporaryDirectory(){
  File tmpDir=new File(""String_Node_Str"");
  this.environment.setTemporaryDirectory(tmpDir);
  Assert.assertEquals(tmpDir,this.environment.getTemporaryDirectory());
}","@Test public void testGetTemporaryDirectory() throws Exception {
  File tmpDir=new File(""String_Node_Str"");
  this.environment.setTemporaryDirectory(tmpDir);
  Assert.assertEquals(tmpDir.getCanonicalFile(),this.environment.getTemporaryDirectory().getCanonicalFile());
}",0.8838174273858921
1710,"@Override public List<ExtensionRepositoryId> getRepositories(){
  List<ExtensionRepositoryId> repositories=new ArrayList<ExtensionRepositoryId>();
  List<String> repositoryStrings=this.configuration.get().getProperty(""String_Node_Str"");
  if (!repositoryStrings.isEmpty()) {
    for (    String repositoryString : repositoryStrings) {
      if (StringUtils.isNotBlank(repositoryString)) {
        try {
          ExtensionRepositoryId extensionRepositoryId=parseRepository(repositoryString);
          repositories.add(extensionRepositoryId);
        }
 catch (        Exception e) {
          this.logger.warn(""String_Node_Str"" + repositoryString + ""String_Node_Str"",e);
        }
      }
 else {
        this.logger.debug(""String_Node_Str"");
      }
    }
  }
 else {
    try {
      repositories.add(new ExtensionRepositoryId(""String_Node_Str"",TYPE_MAVEN,new URI(""String_Node_Str"")));
      repositories.add(new ExtensionRepositoryId(""String_Node_Str"",TYPE_XWIKI,new URI(""String_Node_Str"")));
    }
 catch (    Exception e) {
    }
  }
  return repositories;
}","@Override public List<ExtensionRepositoryId> getRepositories(){
  List<ExtensionRepositoryId> repositories=new ArrayList<ExtensionRepositoryId>();
  List<String> repositoryStrings=this.configuration.get().getProperty(""String_Node_Str"");
  if (repositoryStrings != null && !repositoryStrings.isEmpty()) {
    for (    String repositoryString : repositoryStrings) {
      if (StringUtils.isNotBlank(repositoryString)) {
        try {
          ExtensionRepositoryId extensionRepositoryId=parseRepository(repositoryString);
          repositories.add(extensionRepositoryId);
        }
 catch (        Exception e) {
          this.logger.warn(""String_Node_Str"" + repositoryString + ""String_Node_Str"",e);
        }
      }
 else {
        this.logger.debug(""String_Node_Str"");
      }
    }
  }
 else {
    try {
      repositories.add(new ExtensionRepositoryId(""String_Node_Str"",TYPE_MAVEN,new URI(""String_Node_Str"")));
      repositories.add(new ExtensionRepositoryId(""String_Node_Str"",TYPE_XWIKI,new URI(""String_Node_Str"")));
    }
 catch (    Exception e) {
    }
  }
  return repositories;
}",0.9865429234338748
1711,"@Override public void initialize() throws InitializationException {
  Set<URL> licenseURLs=ClasspathHelper.forPackage(LICENSE_PACKAGE);
  Reflections reflections=new Reflections(new ConfigurationBuilder().setScanners(new ResourcesScanner()).setUrls(licenseURLs).filterInputsBy(new FilterBuilder.Include(FilterBuilder.prefix(LICENSE_PACKAGE))));
  for (  String licenseFile : reflections.getResources(Pattern.compile(""String_Node_Str""))) {
    URL licenseUrl=getClass().getClassLoader().getResource(licenseFile);
    try {
      String path=decode(licenseUrl.getPath());
      String name=path.substring(path.lastIndexOf('/') + 1);
      name=name.substring(0,name.length() - ""String_Node_Str"".length());
      InputStream is=licenseUrl.openStream();
      try {
        List<String> content=IOUtils.readLines(is);
        ExtensionLicense license=new ExtensionLicense(name,content);
        List<String> aliases=new ArrayList<String>();
        aliases.add(name);
        for (        String line : content) {
          if (!line.startsWith(ALIAS_PREFIX)) {
            break;
          }
          aliases.add(line.substring(ALIAS_PREFIX.length()));
        }
        content=content.subList(aliases.size() - 1,content.size());
        for (        String alias : aliases) {
          this.licenses.put(alias.toLowerCase(),license);
        }
      }
  finally {
        is.close();
      }
    }
 catch (    Exception e) {
      this.logger.error(""String_Node_Str"" + licenseUrl + ""String_Node_Str"",e);
    }
  }
}","@Override public void initialize() throws InitializationException {
  Set<URL> licenseURLs=ClasspathHelper.forPackage(LICENSE_PACKAGE);
  Reflections reflections=new Reflections(new ConfigurationBuilder().setScanners(new ResourcesScanner()).setUrls(licenseURLs).filterInputsBy(new FilterBuilder.Include(FilterBuilder.prefix(LICENSE_PACKAGE))));
  for (  String licenseFile : reflections.getResources(Pattern.compile(""String_Node_Str""))) {
    URL licenseUrl=getClass().getClassLoader().getResource(licenseFile);
    try {
      String path=decode(licenseUrl.getPath());
      String name=path.substring(path.lastIndexOf('/') + 1);
      name=name.substring(0,name.length() - ""String_Node_Str"".length());
      InputStream is=licenseUrl.openStream();
      try {
        List<String> content=IOUtils.readLines(is);
        List<String> aliases=new ArrayList<String>();
        aliases.add(name);
        for (        String line : content) {
          if (!line.startsWith(ALIAS_PREFIX)) {
            break;
          }
          aliases.add(line.substring(ALIAS_PREFIX.length()));
        }
        content=content.subList(aliases.size() - 1,content.size());
        ExtensionLicense license=new ExtensionLicense(name,content);
        for (        String alias : aliases) {
          this.licenses.put(alias.toLowerCase(),license);
        }
      }
  finally {
        is.close();
      }
    }
 catch (    Exception e) {
      this.logger.error(""String_Node_Str"" + licenseUrl + ""String_Node_Str"",e);
    }
  }
}",0.9544554455445544
1712,"@Override public String toString(){
  StringBuilder buffer=new StringBuilder(super.toString());
  buffer.append(""String_Node_Str"").append(getImplementation().getName()).append(""String_Node_Str"");
  buffer.append(""String_Node_Str"").append(getInstantiationStrategy()).append(""String_Node_Str"");
  return buffer.toString();
}","@Override public String toString(){
  StringBuilder buffer=new StringBuilder(super.toString());
  buffer.append(""String_Node_Str"").append(getImplementation() == null ? null : getImplementation().getName()).append(""String_Node_Str"");
  buffer.append(""String_Node_Str"").append(getInstantiationStrategy()).append(""String_Node_Str"");
  return buffer.toString();
}",0.945668135095448
1713,"@Override public File getLocalRepository(){
  if (this.localRepository == null) {
    String localRepositoryPath=this.configurationSource.getProperty(""String_Node_Str"");
    if (localRepositoryPath == null) {
      this.localRepository=new File(getHome(),""String_Node_Str"");
    }
 else {
      this.localRepository=new File(localRepositoryPath);
    }
  }
  System.out.println(this.localRepository.getAbsolutePath());
  return this.localRepository;
}","@Override public File getLocalRepository(){
  if (this.localRepository == null) {
    String localRepositoryPath=this.configurationSource.getProperty(""String_Node_Str"");
    if (localRepositoryPath == null) {
      this.localRepository=new File(getHome(),""String_Node_Str"");
    }
 else {
      this.localRepository=new File(localRepositoryPath);
    }
  }
  return this.localRepository;
}",0.861904761904762
1714,"/** 
 * Generate a DOM4J Document containing the generated XML.
 * @param files the list of files that we want to include in the generated package XML file.
 * @return the DOM4J Document containing the generated XML
 */
private Document toXML(Collection files){
  Document doc=new DOMDocument();
  Element docel=new DOMElement(""String_Node_Str"");
  doc.setRootElement(docel);
  Element infosel=new DOMElement(""String_Node_Str"");
  docel.add(infosel);
  Element el=new DOMElement(""String_Node_Str"");
  el.addText(this.project.getName());
  infosel.add(el);
  el=new DOMElement(""String_Node_Str"");
  el.addText(this.project.getDescription());
  infosel.add(el);
  el=new DOMElement(""String_Node_Str"");
  el.addText(""String_Node_Str"");
  infosel.add(el);
  el=new DOMElement(""String_Node_Str"");
  el.addText(""String_Node_Str"");
  infosel.add(el);
  el=new DOMElement(""String_Node_Str"");
  el.addText(this.project.getVersion());
  infosel.add(el);
  el=new DOMElement(""String_Node_Str"");
  el.addText(""String_Node_Str"");
  infosel.add(el);
  Element filesel=new DOMElement(""String_Node_Str"");
  docel.add(filesel);
  for (Iterator it=files.iterator(); it.hasNext(); ) {
    ArchiveEntry entry=(ArchiveEntry)it.next();
    if (entry.getFile().getPath().indexOf(""String_Node_Str"") == -1) {
      XWikiDocument xdoc=getDocFromXML(entry.getFile());
      if (xdoc != null) {
        String fullName=xdoc.getFullName();
        Element el2=new DOMElement(""String_Node_Str"");
        el2.setText(fullName);
        el2.addAttribute(""String_Node_Str"",xdoc.getLanguage());
        el2.addAttribute(""String_Node_Str"",""String_Node_Str"");
        filesel.add(el2);
      }
    }
  }
  return doc;
}","/** 
 * Generate a DOM4J Document containing the generated XML.
 * @param files the list of files that we want to include in the generated package XML file.
 * @return the DOM4J Document containing the generated XML
 */
private Document toXML(Collection files){
  Document doc=new DOMDocument();
  Element packageElement=new DOMElement(""String_Node_Str"");
  doc.setRootElement(packageElement);
  Element infoElement=new DOMElement(""String_Node_Str"");
  packageElement.add(infoElement);
  addInfoElements(infoElement);
  Element filesElement=new DOMElement(""String_Node_Str"");
  packageElement.add(filesElement);
  addFileElements(files,filesElement);
  return doc;
}",0.389953171562367
1715,"/** 
 * Get the root uri for resources There are 3 conditions this will vary under: + the assets are in internal storage under the assets directory + the assets are on the sd card at a pre-specified location + the assets have been previously pulled via update
 * @return
 */
public String getAssetsBaseUrl(){
  String rootPath=getAssetsRootPath();
  if (shouldUseAssetsOrSdCard()) {
    if (assetsOnExternalStorage()) {
      return ""String_Node_Str"" + rootPath;
    }
    return ""String_Node_Str"" + rootPath;
  }
 else   return FileContentProvider.getBaseUri() + rootPath;
}","/** 
 * Get the root uri for resources There are 3 conditions this will vary under: + the assets are in internal storage under the assets directory + the assets are on the sd card at a pre-specified location + the assets have been previously pulled via update
 * @return
 */
public String getAssetsBaseUrl(){
  String rootPath=getAssetsRootPath();
  if (shouldUseAssetsOrSdCard()) {
    if (assetsOnExternalStorage()) {
      return ""String_Node_Str"" + rootPath;
    }
    return ""String_Node_Str"" + rootPath;
  }
 else   return rootPath;
}",0.9632286995515696
1716,"/** 
 * Creates the default WebView where we'll run javascript and render content
 */
public WebView createDefaultWebView(){
  WebView webView=new com.openmeap.android.WebView(this,this);
  JsApiCoreImpl jsApi=new JsApiCoreImpl(this,webView,updateHandler);
  webView.addJavascriptInterface(jsApi,JS_API_NAME);
  webView.getSettings().setJavaScriptEnabled(true);
  webView.setWebViewClient(new WebViewClient(){
    public boolean shouldOverrideUrlLoading(    WebView view,    String url){
      view.loadUrl(url);
      return true;
    }
  }
);
  webView.getSettings().setDatabaseEnabled(true);
  webView.getSettings().setDomStorageEnabled(true);
  String databasePath=this.getApplicationContext().getDir(""String_Node_Str"",Context.MODE_PRIVATE).getPath();
  webView.getSettings().setDatabasePath(""String_Node_Str"");
  webView.getSettings().setGeolocationEnabled(true);
  webView.getSettings().setGeolocationDatabasePath(""String_Node_Str"");
  webView.setVerticalScrollBarEnabled(false);
  webView.setHorizontalScrollBarEnabled(false);
  webView.setWebChromeClient(new WebChromeClient(){
    @Override public void onGeolocationPermissionsShowPrompt(    String origin,    Callback callback){
      callback.invoke(origin,true,false);
    }
    @Override public void onExceededDatabaseQuota(    String url,    String databaseIdentifier,    long quota,    long estimatedDatabaseSize,    long totalQuota,    QuotaUpdater quotaUpdater){
      super.onExceededDatabaseQuota(url,databaseIdentifier,quota,estimatedDatabaseSize,totalQuota,quotaUpdater);
    }
  }
);
  webView.setLayoutParams(new LinearLayout.LayoutParams(android.view.ViewGroup.LayoutParams.FILL_PARENT,android.view.ViewGroup.LayoutParams.WRAP_CONTENT));
  return webView;
}","/** 
 * Creates the default WebView where we'll run javascript and render content
 */
public WebView createDefaultWebView(){
  WebView webView=new com.openmeap.android.WebView(this,this);
  JsApiCoreImpl jsApi=new JsApiCoreImpl(this,webView,updateHandler);
  webView.addJavascriptInterface(jsApi,JS_API_NAME);
  webView.getSettings().setJavaScriptEnabled(true);
  webView.setWebViewClient(new WebViewClient(){
    public boolean shouldOverrideUrlLoading(    WebView view,    String url){
      view.loadUrl(url);
      return true;
    }
  }
);
  webView.getSettings().setDatabaseEnabled(true);
  webView.getSettings().setDomStorageEnabled(true);
  String databasePath=this.getApplicationContext().getDir(""String_Node_Str"",Context.MODE_PRIVATE).getPath();
  webView.getSettings().setDatabasePath(""String_Node_Str"" + webView.getContext().getPackageName() + ""String_Node_Str"");
  webView.getSettings().setGeolocationEnabled(true);
  webView.getSettings().setGeolocationDatabasePath(""String_Node_Str"" + webView.getContext().getPackageName() + ""String_Node_Str"");
  webView.setVerticalScrollBarEnabled(false);
  webView.setHorizontalScrollBarEnabled(false);
  webView.setWebChromeClient(new WebChromeClient(){
    @Override public void onGeolocationPermissionsShowPrompt(    String origin,    Callback callback){
      callback.invoke(origin,true,false);
    }
    @Override public void onExceededDatabaseQuota(    String url,    String databaseIdentifier,    long quota,    long estimatedDatabaseSize,    long totalQuota,    QuotaUpdater quotaUpdater){
      super.onExceededDatabaseQuota(url,databaseIdentifier,quota,estimatedDatabaseSize,totalQuota,quotaUpdater);
    }
  }
);
  webView.setLayoutParams(new LinearLayout.LayoutParams(android.view.ViewGroup.LayoutParams.FILL_PARENT,android.view.ViewGroup.LayoutParams.WRAP_CONTENT));
  return webView;
}",0.966499162479062
1717,"private void fillInApplicationVersionFromParameters(Application app,ApplicationVersion version,List<ProcessingEvent> events,Map<Object,Object> parameterMap){
  version.setIdentifier(firstValue(""String_Node_Str"",parameterMap));
  if (version.getArchive() == null) {
    version.setArchive(new ApplicationArchive());
    version.getArchive().setApplication(app);
  }
  version.setApplication(app);
  version.setNotes(firstValue(""String_Node_Str"",parameterMap));
  Boolean archiveUncreated=true;
  if (parameterMap.get(""String_Node_Str"") != null) {
    if (!(parameterMap.get(""String_Node_Str"") instanceof FileItem)) {
      events.add(new MessagesEvent(""String_Node_Str""));
    }
 else {
      FileItem item=(FileItem)parameterMap.get(""String_Node_Str"");
      Long size=item.getSize();
      if (size > 0) {
        try {
          File tempFile=ServletUtils.tempFileFromFileItem(modelManager.getGlobalSettings().getTemporaryStoragePath(),item);
          ApplicationArchive archive=version.getArchive();
          archive.setNewFileUploaded(tempFile.getAbsolutePath());
          archiveUncreated=false;
        }
 catch (        Exception ioe) {
          logger.error(""String_Node_Str"",ioe);
          events.add(new MessagesEvent(ioe.getMessage()));
          return;
        }
 finally {
          item.delete();
        }
      }
 else {
        events.add(new MessagesEvent(""String_Node_Str""));
      }
    }
  }
  if (archiveUncreated) {
    ApplicationArchive archive=version.getArchive();
    archive.setUrl(firstValue(""String_Node_Str"",parameterMap));
    archive.setHashAlgorithm(firstValue(""String_Node_Str"",parameterMap));
    archive.setHash(firstValue(""String_Node_Str"",parameterMap));
    if (notEmpty(""String_Node_Str"",parameterMap)) {
      archive.setBytesLength(Integer.valueOf(firstValue(""String_Node_Str"",parameterMap)));
    }
    if (notEmpty(""String_Node_Str"",parameterMap)) {
      archive.setBytesLengthUncompressed(Integer.valueOf(firstValue(""String_Node_Str"",parameterMap)));
    }
  }
}","private void fillInApplicationVersionFromParameters(Application app,ApplicationVersion version,List<ProcessingEvent> events,Map<Object,Object> parameterMap){
  version.setIdentifier(firstValue(""String_Node_Str"",parameterMap));
  if (version.getArchive() == null) {
    version.setArchive(new ApplicationArchive());
    version.getArchive().setApplication(app);
  }
  version.setApplication(app);
  version.setNotes(firstValue(""String_Node_Str"",parameterMap));
  Boolean archiveUncreated=true;
  if (parameterMap.get(""String_Node_Str"") != null) {
    if (!(parameterMap.get(""String_Node_Str"") instanceof FileItem)) {
      events.add(new MessagesEvent(""String_Node_Str""));
    }
 else {
      FileItem item=(FileItem)parameterMap.get(""String_Node_Str"");
      Long size=item.getSize();
      if (size > 0) {
        try {
          File tempFile=ServletUtils.tempFileFromFileItem(modelManager.getGlobalSettings().getTemporaryStoragePath(),item);
          ApplicationArchive archive=version.getArchive();
          archive.setNewFileUploaded(tempFile.getAbsolutePath());
          archiveUncreated=false;
        }
 catch (        Exception ioe) {
          logger.error(""String_Node_Str"",ioe);
          events.add(new MessagesEvent(ioe.getMessage()));
          return;
        }
 finally {
          item.delete();
        }
      }
 else {
        events.add(new MessagesEvent(""String_Node_Str""));
      }
    }
  }
  if (archiveUncreated) {
    ApplicationArchive archive=version.getArchive();
    archive.setHashAlgorithm(firstValue(""String_Node_Str"",parameterMap));
    archive.setHash(firstValue(""String_Node_Str"",parameterMap));
    ApplicationArchive arch=modelManager.getModelService().findApplicationArchiveByHashAndAlgorithm(app,archive.getHash(),archive.getHashAlgorithm());
    if (arch != null) {
      version.setArchive(arch);
      archive=arch;
    }
    archive.setUrl(firstValue(""String_Node_Str"",parameterMap));
    if (notEmpty(""String_Node_Str"",parameterMap)) {
      archive.setBytesLength(Integer.valueOf(firstValue(""String_Node_Str"",parameterMap)));
    }
    if (notEmpty(""String_Node_Str"",parameterMap)) {
      archive.setBytesLengthUncompressed(Integer.valueOf(firstValue(""String_Node_Str"",parameterMap)));
    }
  }
}",0.8797186400937866
1718,"@Test public void adminTest() throws Exception {
  testLogin();
  testUpdateGlobalSettings();
  testAddApplication();
  testModifyApplication();
  testCreateApplicationVersion();
  testDeleteApplicationVersion();
  testCreateDeployments();
  testDeleteApplication();
}","@Test public void adminTest() throws Exception {
  testLogin();
  testUpdateGlobalSettings();
  testAddApplication();
  testModifyApplication();
  testCreateApplicationVersion();
  testDeleteApplicationVersion();
  testUpdateApplicationVersion();
  testCreateDeployments();
  testDeleteApplication();
}",0.9403508771929824
1719,"private <T extends ModelEntity>void _delete(T entity,List<ProcessingEvent> events) throws PersistenceException {
  this._refresh(entity);
  entity.remove();
  entityManager.remove(entity);
}","private <T extends ModelEntity>void _delete(T entity,List<ProcessingEvent> events) throws PersistenceException {
  entity.remove();
  entityManager.remove(entity);
}",0.9295774647887324
1720,"@SuppressWarnings(""String_Node_Str"") private ApplicationArchive processApplicationArchiveFileUpload(ApplicationArchive archive,List<ProcessingEvent> events){
  GlobalSettings settings=modelManager.getGlobalSettings();
  File tempFile=new File(archive.getNewFileUploaded());
  Long size=tempFile.length();
  String pathError=settings.validateTemporaryStoragePath();
  if (pathError != null) {
    logger.error(""String_Node_Str"" + settings.validateTemporaryStoragePath() + ""String_Node_Str"",pathError);
    events.add(new MessagesEvent(""String_Node_Str"" + settings.validateTemporaryStoragePath() + ""String_Node_Str""+ pathError));
    return null;
  }
  FileInputStream is=null;
  File destinationFile=null;
  try {
    if (archive.getId() != null) {
      ArchiveFileHelper.maintainFileSystemCleanliness(modelManager,fileManager,archive,events);
    }
    String hashValue=null;
    ApplicationArchive archiveExists=null;
    try {
      is=new FileInputStream(tempFile);
      hashValue=Utils.hashInputStream(""String_Node_Str"",is);
      archiveExists=modelManager.getModelService().findApplicationArchiveByHashAndAlgorithm(archive.getApplication(),hashValue,""String_Node_Str"");
      if (archiveExists != null) {
        if (!tempFile.delete()) {
          String mesg=String.format(""String_Node_Str"",tempFile.getName());
          logger.error(mesg);
          events.add(new MessagesEvent(mesg));
        }
        return archiveExists;
      }
    }
 catch (    DigestException de) {
      throw new PersistenceException(de);
    }
 finally {
      is.close();
    }
    archive.setHashAlgorithm(""String_Node_Str"");
    archive.setHash(hashValue);
    destinationFile=archive.getFile(settings.getTemporaryStoragePath());
    if (destinationFile.exists() && !destinationFile.delete()) {
      String mesg=String.format(""String_Node_Str"",destinationFile.getName());
      logger.error(mesg);
      events.add(new MessagesEvent(mesg));
      if (!tempFile.delete()) {
        mesg=String.format(""String_Node_Str"",tempFile.getName());
        logger.error(mesg);
        events.add(new MessagesEvent(mesg));
      }
    }
 else     if (tempFile.renameTo(destinationFile)) {
      String mesg=String.format(""String_Node_Str"",tempFile.getName(),destinationFile.getName());
      logger.debug(mesg);
      events.add(new MessagesEvent(mesg));
      ArchiveFileHelper.unzipFile(modelManager,fileManager,archive,destinationFile,events);
    }
 else {
      String mesg=String.format(""String_Node_Str"",tempFile.getName(),destinationFile.getName());
      logger.error(mesg);
      events.add(new MessagesEvent(mesg));
      return null;
    }
  }
 catch (  IOException ioe) {
    events.add(new MessagesEvent(ioe.getMessage()));
    return null;
  }
  try {
    archive.setBytesLength(size.intValue());
    ZipFile zipFile=null;
    try {
      zipFile=new ZipFile(destinationFile);
      Integer uncompressedSize=ZipUtils.getUncompressedSize(zipFile).intValue();
      archive.setBytesLengthUncompressed(new Long(uncompressedSize).intValue());
    }
  finally {
      if (zipFile != null) {
        zipFile.close();
      }
    }
  }
 catch (  IOException ioe) {
    logger.error(""String_Node_Str"",ioe);
    events.add(new MessagesEvent(String.format(""String_Node_Str"",ioe.getMessage())));
    return null;
  }
  archive.setUrl(ApplicationArchive.URL_TEMPLATE);
  return archive;
}","@SuppressWarnings(""String_Node_Str"") private ApplicationArchive processApplicationArchiveFileUpload(ApplicationArchive archive,List<ProcessingEvent> events){
  GlobalSettings settings=modelManager.getGlobalSettings();
  File tempFile=new File(archive.getNewFileUploaded());
  Long size=tempFile.length();
  String pathError=settings.validateTemporaryStoragePath();
  if (pathError != null) {
    logger.error(""String_Node_Str"" + settings.validateTemporaryStoragePath() + ""String_Node_Str"",pathError);
    events.add(new MessagesEvent(""String_Node_Str"" + settings.validateTemporaryStoragePath() + ""String_Node_Str""+ pathError));
    return null;
  }
  FileInputStream is=null;
  File destinationFile=null;
  try {
    if (archive.getId() != null) {
      ArchiveFileHelper.maintainFileSystemCleanliness(modelManager,fileManager,archive,events);
    }
    String hashValue=null;
    ApplicationArchive archiveExists=null;
    try {
      is=new FileInputStream(tempFile);
      hashValue=Utils.hashInputStream(""String_Node_Str"",is);
      archiveExists=modelManager.getModelService().findApplicationArchiveByHashAndAlgorithm(archive.getApplication(),hashValue,""String_Node_Str"");
      if (archiveExists != null) {
        if (!tempFile.delete()) {
          String mesg=String.format(""String_Node_Str"",tempFile.getName());
          logger.error(mesg);
          events.add(new MessagesEvent(mesg));
        }
        return archiveExists;
      }
 else {
        archive=archive.clone();
        archive.setId(null);
      }
    }
 catch (    DigestException de) {
      throw new PersistenceException(de);
    }
 finally {
      is.close();
    }
    archive.setHashAlgorithm(""String_Node_Str"");
    archive.setHash(hashValue);
    destinationFile=archive.getFile(settings.getTemporaryStoragePath());
    if (destinationFile.exists() && !destinationFile.delete()) {
      String mesg=String.format(""String_Node_Str"",destinationFile.getName());
      logger.error(mesg);
      events.add(new MessagesEvent(mesg));
      if (!tempFile.delete()) {
        mesg=String.format(""String_Node_Str"",tempFile.getName());
        logger.error(mesg);
        events.add(new MessagesEvent(mesg));
      }
    }
 else     if (tempFile.renameTo(destinationFile)) {
      String mesg=String.format(""String_Node_Str"",tempFile.getName(),destinationFile.getName());
      logger.debug(mesg);
      events.add(new MessagesEvent(mesg));
      ArchiveFileHelper.unzipFile(modelManager,fileManager,archive,destinationFile,events);
    }
 else {
      String mesg=String.format(""String_Node_Str"",tempFile.getName(),destinationFile.getName());
      logger.error(mesg);
      events.add(new MessagesEvent(mesg));
      return null;
    }
  }
 catch (  IOException ioe) {
    events.add(new MessagesEvent(ioe.getMessage()));
    return null;
  }
  try {
    archive.setBytesLength(size.intValue());
    ZipFile zipFile=null;
    try {
      zipFile=new ZipFile(destinationFile);
      Integer uncompressedSize=ZipUtils.getUncompressedSize(zipFile).intValue();
      archive.setBytesLengthUncompressed(new Long(uncompressedSize).intValue());
    }
  finally {
      if (zipFile != null) {
        zipFile.close();
      }
    }
  }
 catch (  IOException ioe) {
    logger.error(""String_Node_Str"",ioe);
    events.add(new MessagesEvent(String.format(""String_Node_Str"",ioe.getMessage())));
    return null;
  }
  archive.setUrl(ApplicationArchive.URL_TEMPLATE);
  return archive;
}",0.9885764499121266
1721,"@Override public <E extends Event<Deployment>>void onAfterOperation(E event,List<ProcessingEvent> events) throws EventNotificationException {
  Deployment deployment2Delete=(Deployment)event.getPayload();
  ApplicationArchive archive=deployment2Delete.getApplicationArchive();
  Application app=deployment2Delete.getApplication();
  List<Deployment> deployments=archiveDeleteHandler.getModelManager().getModelService().findDeploymentsByApplicationArchive(archive);
  if (deployments.size() > 1) {
    return;
  }
  archiveDeleteNotifier.notify(new ModelEntityEvent(ModelServiceOperation.DELETE,archive),events);
  List<ApplicationVersion> versions=archiveDeleteHandler.getModelManager().getModelService().findVersionsByApplicationArchive(archive);
  if (versions.size() != 0) {
    return;
  }
  Map<String,Object> map=new HashMap<String,Object>();
  map.put(""String_Node_Str"",archive);
  try {
    int archivesWithHashAndAlg=archiveDeleteHandler.getModelManager().getModelService().countApplicationArchivesByHashAndHashAlg(archive.getHash(),archive.getHashAlgorithm());
    if (archivesWithHashAndAlg == 1) {
      GlobalSettings settings=archiveDeleteHandler.getModelManager().getGlobalSettings();
      archiveDeleteHandler.setFileSystemStoragePathPrefix(settings.getTemporaryStoragePath());
      archiveDeleteHandler.handle(new MapPayloadEvent(map));
    }
    archiveDeleteHandler.getModelManager().delete(archive,events);
  }
 catch (  EventHandlingException e) {
    throw new ClusterNotificationException(""String_Node_Str"",e);
  }
}","@Override public <E extends Event<Deployment>>void onAfterOperation(E event,List<ProcessingEvent> events) throws EventNotificationException {
  Deployment deployment2Delete=(Deployment)event.getPayload();
  ApplicationArchive archive=deployment2Delete.getApplicationArchive();
  List<Deployment> deployments=archiveDeleteHandler.getModelManager().getModelService().findDeploymentsByApplicationArchive(archive);
  if (deployments.size() != 0) {
    return;
  }
 else {
    int deplCount=archiveDeleteHandler.getModelManager().getModelService().countDeploymentsByHashAndHashAlg(archive.getHash(),archive.getHashAlgorithm());
    if (deplCount == 0) {
      archiveDeleteNotifier.notify(new ModelEntityEvent(ModelServiceOperation.DELETE,archive),events);
    }
  }
  List<ApplicationVersion> versions=archiveDeleteHandler.getModelManager().getModelService().findVersionsByApplicationArchive(archive);
  if (versions.size() != 0) {
    return;
  }
  Map<String,Object> map=new HashMap<String,Object>();
  map.put(""String_Node_Str"",archive);
  try {
    int archivesWithHashAndAlg=archiveDeleteHandler.getModelManager().getModelService().countApplicationArchivesByHashAndHashAlg(archive.getHash(),archive.getHashAlgorithm());
    if (archivesWithHashAndAlg == 1) {
      GlobalSettings settings=archiveDeleteHandler.getModelManager().getGlobalSettings();
      archiveDeleteHandler.setFileSystemStoragePathPrefix(settings.getTemporaryStoragePath());
      archiveDeleteHandler.handle(new MapPayloadEvent(map));
    }
    archiveDeleteHandler.getModelManager().delete(archive,events);
  }
 catch (  EventHandlingException e) {
    throw new ClusterNotificationException(""String_Node_Str"",e);
  }
}",0.8353960396039604
1722,"/** 
 * The application main entry point.
 * @param args           the command-line parameters
 */
public static void main(String[] args){
  if (args.length < 1) {
    printHelp(""String_Node_Str"");
    System.exit(1);
  }
  ArrayList<Object> queue=new ArrayList<>();
  for (  String arg : args) {
    try {
      if (arg.contains(""String_Node_Str"")) {
        queue.add(new URL(arg));
      }
 else {
        File file=new File(arg);
        if (!file.exists()) {
          System.out.println(""String_Node_Str"" + arg + ""String_Node_Str"");
        }
 else         if (file.isDirectory()) {
          addMibs(file,queue);
        }
 else {
          queue.add(file);
        }
      }
    }
 catch (    MalformedURLException e) {
      System.out.println(""String_Node_Str"" + arg + ""String_Node_Str""+ e.getMessage());
    }
  }
  MibLoader loader=new MibLoader();
  int errors=0;
  int warnings=0;
  for (int i=0; i < queue.size(); i++) {
    Object src=queue.get(i);
    System.out.print(i);
    System.out.print(""String_Node_Str"");
    System.out.print(queue.size());
    System.out.print(""String_Node_Str"" + src + ""String_Node_Str"");
    System.out.flush();
    try {
      loader.unloadAll();
      Mib mib=null;
      if (src instanceof URL) {
        loader.removeAllDirs();
        mib=loader.load((URL)src);
      }
 else {
        File file=(File)src;
        if (!loader.hasDir(file.getParentFile())) {
          loader.removeAllDirs();
          loader.addDir(file.getParentFile());
        }
        mib=loader.load(file);
      }
      System.out.println(""String_Node_Str"");
      if (mib.getLog().warningCount() > 0) {
        mib.getLog().printTo(System.out);
        warnings++;
      }
    }
 catch (    FileNotFoundException e) {
      System.out.println(""String_Node_Str"");
      printError(src.toString(),e);
      errors++;
    }
catch (    IOException e) {
      System.out.println(""String_Node_Str"");
      printError(src.toString(),e);
      errors++;
    }
catch (    MibLoaderException e) {
      System.out.println(""String_Node_Str"");
      e.getLog().printTo(System.out);
      errors++;
    }
catch (    RuntimeException e) {
      System.out.println();
      printInternalError(e);
      System.exit(1);
    }
  }
  System.out.println();
  System.out.println(""String_Node_Str"" + queue.size());
  System.out.println(""String_Node_Str"" + errors);
  System.out.println(""String_Node_Str"" + warnings);
  if (errors > 0) {
    System.err.println(""String_Node_Str"");
  }
  System.exit(errors);
}","/** 
 * The application main entry point.
 * @param args           the command-line parameters
 */
public static void main(String[] args){
  if (args.length < 1) {
    printHelp(""String_Node_Str"");
    System.exit(1);
  }
  ArrayList<Object> queue=new ArrayList<>();
  for (  String arg : args) {
    try {
      if (arg.contains(""String_Node_Str"")) {
        queue.add(new URL(arg));
      }
 else {
        File file=new File(arg);
        if (!file.exists()) {
          System.out.println(""String_Node_Str"" + arg + ""String_Node_Str"");
        }
 else         if (file.isDirectory()) {
          addMibs(file,queue);
        }
 else {
          queue.add(file);
        }
      }
    }
 catch (    MalformedURLException e) {
      System.out.println(""String_Node_Str"" + arg + ""String_Node_Str""+ e.getMessage());
    }
  }
  MibLoader loader=new MibLoader();
  int errors=0;
  int warnings=0;
  for (int i=0; i < queue.size(); i++) {
    Object src=queue.get(i);
    System.out.print(i + 1);
    System.out.print(""String_Node_Str"");
    System.out.print(queue.size());
    System.out.print(""String_Node_Str"" + src + ""String_Node_Str"");
    System.out.flush();
    try {
      loader.unloadAll();
      Mib mib=null;
      if (src instanceof URL) {
        loader.removeAllDirs();
        mib=loader.load((URL)src);
      }
 else {
        File file=(File)src;
        if (!loader.hasDir(file.getParentFile())) {
          loader.removeAllDirs();
          loader.addDir(file.getParentFile());
        }
        mib=loader.load(file);
      }
      System.out.println(""String_Node_Str"");
      if (mib.getLog().warningCount() > 0) {
        mib.getLog().printTo(System.out);
        warnings++;
      }
    }
 catch (    FileNotFoundException e) {
      System.out.println(""String_Node_Str"");
      printError(src.toString(),e);
      errors++;
    }
catch (    IOException e) {
      System.out.println(""String_Node_Str"");
      printError(src.toString(),e);
      errors++;
    }
catch (    MibLoaderException e) {
      System.out.println(""String_Node_Str"");
      e.getLog().printTo(System.out);
      errors++;
    }
catch (    RuntimeException e) {
      System.out.println();
      printInternalError(e);
      System.exit(1);
    }
  }
  System.out.println();
  System.out.println(""String_Node_Str"" + queue.size());
  System.out.println(""String_Node_Str"" + errors);
  System.out.println(""String_Node_Str"" + warnings);
  if (errors > 0) {
    System.err.println(""String_Node_Str"");
  }
  System.exit(errors);
}",0.9992050874403816
1723,"/** 
 * Loads MIB file or URL.
 * @param src            the MIB file or URL
 * @throws IOException if the MIB file couldn't be found in theMIB search path
 * @throws MibLoaderException if the MIB file couldn't be loadedcorrectly
 */
public void loadMib(String src) throws IOException, MibLoaderException {
  Mib mib=null;
  File file=new File(src);
  if (file.exists()) {
    if (loader.getMib(file) != null) {
      return;
    }
    if (!loader.hasDir(file.getParentFile())) {
      loader.removeAllDirs();
      loader.addDir(file.getParentFile());
    }
    mib=loader.load(file);
    addFilePref(file.getAbsolutePath());
  }
 else {
    mib=loader.load(src);
    addFilePref(src);
  }
  MibTreeBuilder.getInstance().addMib(mib);
}","/** 
 * Loads MIB file or URL.
 * @param src            the MIB file or URL
 * @throws IOException if the MIB file couldn't be found in theMIB search path
 * @throws MibLoaderException if the MIB file couldn't be loadedcorrectly
 */
public void loadMib(String src) throws IOException, MibLoaderException {
  Mib mib=null;
  File file=new File(src);
  if (loader.getMib(src) != null || loader.getMib(file) != null) {
    return;
  }
 else   if (file.exists()) {
    if (!loader.hasDir(file.getParentFile())) {
      loader.removeAllDirs();
      loader.addDir(file.getParentFile());
    }
    mib=loader.load(file);
    addFilePref(file.getAbsolutePath());
  }
 else {
    mib=loader.load(src);
    addFilePref(src);
  }
  MibTreeBuilder.getInstance().addMib(mib);
}",0.9253333333333332
1724,"/** 
 * Initializes the MIB value. This will remove all levels of indirection present, such as references to other values. No value information is lost by this operation. This method may modify this object as a side-effect, and will return the basic value.<p> <strong>NOTE:</strong> This is an internal method that should only be called by the MIB loader.
 * @param log            the MIB loader log
 * @param type           the value type
 * @return the basic MIB value
 * @throws MibException if an error was encountered during theinitialization
 */
public MibValue initialize(MibLoaderLog log,MibType type) throws MibException {
  ValueReference ref=null;
  ObjectIdentifierValue oid;
  if (parent == null) {
    return this;
  }
 else   if (parent instanceof ValueReference) {
    ref=(ValueReference)parent;
  }
  parent=parent.initialize(log,type);
  if (ref != null) {
    if (parent instanceof ObjectIdentifierValue) {
      oid=(ObjectIdentifierValue)parent;
      oid.addChild(log,location,this);
    }
 else {
      throw new MibException(ref.getLocation(),""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  location=null;
  if (parent instanceof ObjectIdentifierValue) {
    return ((ObjectIdentifierValue)parent).getChildByValue(value);
  }
 else {
    return this;
  }
}","/** 
 * Initializes the MIB value. This will remove all levels of indirection present, such as references to other values. No value information is lost by this operation. This method may modify this object as a side-effect, and will return the basic value.<p> <strong>NOTE:</strong> This is an internal method that should only be called by the MIB loader.
 * @param log            the MIB loader log
 * @param type           the value type
 * @return the basic MIB value
 * @throws MibException if an error was encountered during theinitialization
 */
public MibValue initialize(MibLoaderLog log,MibType type) throws MibException {
  ValueReference ref=null;
  ObjectIdentifierValue oid;
  if (parent == null) {
    return this;
  }
 else   if (parent instanceof ValueReference) {
    ref=(ValueReference)parent;
  }
  parent=parent.initialize(log,type);
  if (ref != null) {
    if (parent instanceof ObjectIdentifierValue) {
      oid=(ObjectIdentifierValue)parent;
      oid.addChild(log,location,this);
    }
 else {
      throw new MibException(ref.getLocation(),""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  location=null;
  cachedNumericValue=null;
  if (parent instanceof ObjectIdentifierValue) {
    return ((ObjectIdentifierValue)parent).getChildByValue(value);
  }
 else {
    return this;
  }
}",0.9896033885252216
1725,"/** 
 * Parses the MIB input source and returns the MIB modules found. This method will read the MIB either from file, URL or input stream.
 * @param loader         the MIB loader to use for imports
 * @param log            the MIB log to use for errors
 * @return the list of MIB modules created
 * @throws IOException if the MIB couldn't be found
 * @throws MibLoaderException if the MIB couldn't be parsedor analyzed correctly
 */
public ArrayList parseMib(MibLoader loader,MibLoaderLog log) throws IOException, MibLoaderException {
  MibAnalyzer analyzer;
  String msg;
  if (input != null) {
  }
 else   if (url != null) {
    input=new InputStreamReader(url.openStream());
  }
 else {
    input=new FileReader(file);
  }
  analyzer=new MibAnalyzer(file,loader,log);
  try {
    if (parser == null) {
      parser=new Asn1Parser(input,analyzer);
      parser.getTokenizer().setUseTokenList(true);
    }
 else {
      parser.reset(input,analyzer);
    }
    parser.parse();
    return analyzer.getMibs();
  }
 catch (  ParserCreationException e) {
    msg=""String_Node_Str"" + e.getMessage();
    log.addInternalError(file,msg);
    throw new MibLoaderException(log);
  }
catch (  ParserLogException e) {
    log.addAll(file,e);
    throw new MibLoaderException(log);
  }
 finally {
    analyzer.reset();
  }
}","/** 
 * Parses the MIB input source and returns the MIB modules found. This method will read the MIB either from file, URL or input stream.
 * @param loader         the MIB loader to use for imports
 * @param log            the MIB log to use for errors
 * @return the list of MIB modules created
 * @throws IOException if the MIB couldn't be found
 * @throws MibLoaderException if the MIB couldn't be parsedor analyzed correctly
 */
public ArrayList parseMib(MibLoader loader,MibLoaderLog log) throws IOException, MibLoaderException {
  MibAnalyzer analyzer;
  String msg;
  if (input != null) {
  }
 else   if (url != null) {
    input=new InputStreamReader(url.openStream());
  }
 else {
    input=new FileReader(file);
  }
  analyzer=new MibAnalyzer(file,loader,log);
  try {
    if (parser == null) {
      parser=new Asn1Parser(input,analyzer);
      parser.getTokenizer().setUseTokenList(true);
    }
 else {
      parser.reset(input,analyzer);
    }
    parser.parse();
    return analyzer.getMibs();
  }
 catch (  ParserCreationException e) {
    msg=""String_Node_Str"" + e.getMessage();
    log.addInternalError(file,msg);
    throw new MibLoaderException(log);
  }
catch (  ParserLogException e) {
    log.addAll(file,e);
    throw new MibLoaderException(log);
  }
 finally {
    try {
      input.close();
    }
 catch (    Throwable ignore) {
    }
    analyzer.reset();
  }
}",0.9722325064790818
1726,"/** 
 * Removes the specified number of leading spaces from a string. All tab characters in the string will be converted to spaces before processing. If the stringcontains fewer than the specified number of leading spaces, all will be removed. If the indentation count is less than zero (0), all leading spaces in the input string will be removed.
 * @param str            the input string
 * @param indent         the indentation space count
 * @return the unindented string
 */
private static String removeIndent(String str,int indent){
  int pos=0;
  str=replaceTabs(str);
  if (indent < 0) {
    return str.trim();
  }
  for (pos=0; pos < str.length() && pos < indent; pos++) {
    if (str.charAt(pos) != ' ') {
      break;
    }
  }
  return str.substring(pos);
}","/** 
 * Removes the specified number of leading spaces from a string. All tab characters in the string will be converted to spaces before processing. If the string contains fewer than the specified number of leading spaces, all will be removed. If the indentation count is less than zero (0), all leading spaces in the input string will be removed.
 * @param str            the input string
 * @param indent         the indentation space count
 * @return the unindented string
 */
private static String removeIndent(String str,int indent){
  int pos=0;
  str=replaceTabs(str);
  if (indent < 0) {
    return str.trim();
  }
  for (pos=0; pos < str.length() && pos < indent; pos++) {
    if (str.charAt(pos) != ' ') {
      break;
    }
  }
  return str.substring(pos);
}",0.9987012987012988
1727,"private int getByteSize(Constraint c){
  ArrayList list;
  ValueConstraint value;
  int size;
  if (c instanceof CompoundConstraint) {
    list=((CompoundConstraint)c).getConstraintList();
    for (int i=0; i < list.size(); i++) {
      size=getByteSize((Constraint)list.get(i));
      if (size > 0) {
        return size;
      }
    }
  }
 else   if (c instanceof SizeConstraint) {
    value=(ValueConstraint)((SizeConstraint)c).getValues().get(0);
    if (value.getValue().toObject() instanceof Number) {
      return ((Number)value.getValue().toObject()).intValue();
    }
  }
  return -1;
}","private int getByteSize(Constraint c){
  ArrayList list;
  MibValue value;
  int size;
  if (c instanceof CompoundConstraint) {
    list=((CompoundConstraint)c).getConstraintList();
    for (int i=0; i < list.size(); i++) {
      size=getByteSize((Constraint)list.get(i));
      if (size > 0) {
        return size;
      }
    }
  }
 else   if (c instanceof SizeConstraint) {
    c=(Constraint)((SizeConstraint)c).getValues().get(0);
    value=null;
    if (c instanceof ValueConstraint) {
      value=((ValueConstraint)c).getValue();
    }
 else     if (c instanceof ValueRangeConstraint) {
      value=((ValueRangeConstraint)c).getLowerBound();
    }
    if (value != null && value.toObject() instanceof Number) {
      return ((Number)value.toObject()).intValue();
    }
  }
  return -1;
}",0.7550432276657061
1728,"private int getByteSize(Constraint c){
  ArrayList list;
  ValueConstraint value;
  int size;
  if (c instanceof CompoundConstraint) {
    list=((CompoundConstraint)c).getConstraintList();
    for (int i=0; i < list.size(); i++) {
      size=getByteSize((Constraint)list.get(i));
      if (size >= 0) {
        return size;
      }
    }
  }
 else   if (c instanceof SizeConstraint) {
    value=(ValueConstraint)((SizeConstraint)c).getValues().get(0);
    if (value.getValue().toObject() instanceof Number) {
      return ((Number)value.getValue().toObject()).intValue();
    }
  }
  return -1;
}","private int getByteSize(Constraint c){
  ArrayList list;
  MibValue value;
  int size;
  if (c instanceof CompoundConstraint) {
    list=((CompoundConstraint)c).getConstraintList();
    for (int i=0; i < list.size(); i++) {
      size=getByteSize((Constraint)list.get(i));
      if (size >= 0) {
        return size;
      }
    }
  }
 else   if (c instanceof SizeConstraint) {
    c=(Constraint)((SizeConstraint)c).getValues().get(0);
    value=null;
    if (c instanceof ValueConstraint) {
      value=((ValueConstraint)c).getValue();
    }
 else     if (c instanceof ValueRangeConstraint) {
      value=((ValueRangeConstraint)c).getLowerBound();
    }
    if (value != null && value.toObject() instanceof Number) {
      return ((Number)value.toObject()).intValue();
    }
  }
  return -1;
}",0.7553956834532374
1729,"/** 
 * Finds the first SNMP textual convention reference for a type. If the type specified is a textual convention, it will be returned directly.
 * @param type           the MIB type
 * @return the SNMP textual convention reference, ornull if none was found
 * @since 2.7
 */
public static SnmpTextualConvention findReference(MibType type){
  MibTypeSymbol sym;
  if (type instanceof SnmpTextualConvention) {
    return (SnmpTextualConvention)type;
  }
  sym=type.getReferenceSymbol();
  if (sym == null) {
    return null;
  }
 else {
    return findReference(sym.getType());
  }
}","/** 
 * Finds the first SNMP textual convention reference for a type. If the type specified is a textual convention, it will be returned directly.
 * @param type           the MIB type
 * @return the SNMP textual convention reference, ornull if none was found
 * @since 2.7
 */
public static SnmpTextualConvention findReference(MibType type){
  MibTypeSymbol sym;
  if (type instanceof SnmpObjectType) {
    type=((SnmpObjectType)type).getSyntax();
  }
  if (type instanceof SnmpTextualConvention) {
    return (SnmpTextualConvention)type;
  }
  sym=type.getReferenceSymbol();
  return (sym == null) ? null : findReference(sym.getType());
}",0.7696078431372549
1730,"/** 
 * Unloads a MIB. This method will remove the loader reference to a previously loaded MIB if no other MIBs are depending on it. This method does not free the memory used by the MIB, but only releases all the loader references (thereby allowing the garbage collector to recover the memory used by the MIB).
 * @param mib            the MIB
 * @throws MibLoaderException if the MIB couldn't be unloadeddue to dependencies from other loaded MIBs
 * @see #reset
 * @since 2.3
 */
public void unload(Mib mib) throws MibLoaderException {
  Mib referer;
  String message;
  int pos;
  pos=mibs.indexOf(mib);
  if (pos >= 0) {
    for (int i=0; i < mibs.size(); i++) {
      referer=(Mib)mibs.get(i);
      if (referer.getImport(mib.getName()) != null) {
        message=""String_Node_Str"" + referer;
        throw new MibLoaderException(mib.getFile(),message);
      }
    }
    mibs.remove(pos);
  }
}","/** 
 * Unloads a MIB. This method will remove the loader reference to a previously loaded MIB if no other MIBs are depending on it. This method does not free the memory used by the MIB, but only releases all the loader references (thereby allowing the garbage collector to recover the memory used by the MIB).
 * @param mib            the MIB
 * @throws MibLoaderException if the MIB couldn't be unloadeddue to dependencies from other loaded MIBs
 * @see #reset
 * @since 2.3
 */
public void unload(Mib mib) throws MibLoaderException {
  Mib referer;
  String message;
  int pos;
  pos=mibs.indexOf(mib);
  if (pos >= 0) {
    for (int i=0; i < mibs.size(); i++) {
      referer=(Mib)mibs.get(i);
      if (referer.getImport(mib.getName()) != null) {
        message=""String_Node_Str"" + referer;
        throw new MibLoaderException(mib.getFile(),message);
      }
    }
    mib=(Mib)mibs.remove(pos);
    mib.clear();
  }
}",0.9857456140350878
1731,"/** 
 * Sets the symbol connected to this object identifier. This method is called during the value symbol initialization.
 * @param symbol         the value symbol
 */
public void setSymbol(MibValueSymbol symbol){
  if (name == null) {
    name=symbol.getName();
  }
  this.symbol=symbol;
}","/** 
 * Sets the symbol connected to this object identifier.<p> <strong>NOTE:</strong> This is an internal method that should only be called by the MIB loader.
 * @param symbol         the value symbol
 */
public void setSymbol(MibValueSymbol symbol){
  if (name == null) {
    name=symbol.getName();
  }
  this.symbol=symbol;
}",0.752827140549273
1732,"/** 
 * Creates a new SNMP module compliance declaration.
 * @param group          the group compliance flag
 * @param value          the compliance value
 * @param syntax         the value syntax, or null
 * @param writeSyntax    the value write syntax, or null
 * @param access         the access mode, or null
 * @param description    the compliance description
 */
public SnmpCompliance(boolean group,MibValue value,MibType syntax,MibType writeSyntax,SnmpAccess access,String description){
  this.value=value;
  this.syntax=syntax;
  this.writeSyntax=writeSyntax;
  this.access=access;
  this.description=description;
}","/** 
 * Creates a new SNMP module compliance declaration.
 * @param group          the group compliance flag
 * @param value          the compliance value
 * @param syntax         the value syntax, or null
 * @param writeSyntax    the value write syntax, or null
 * @param access         the access mode, or null
 * @param description    the compliance description
 */
public SnmpCompliance(boolean group,MibValue value,MibType syntax,MibType writeSyntax,SnmpAccess access,String description){
  this.group=group;
  this.value=value;
  this.syntax=syntax;
  this.writeSyntax=writeSyntax;
  this.access=access;
  this.description=description;
}",0.9842022116903634
1733,"/** 
 * Initializes the MIB symbol. This will remove all levels of indirection present, such as references to types or values. No information is lost by this operation. This method may modify this object as a side-effect.<p> <strong>NOTE:</strong> This is an internal method that should only be called by the MIB loader.
 * @param log            the MIB loader log
 * @throws MibException if an error was encountered during theinitialization
 */
public void initialize(MibLoaderLog log) throws MibException {
  if (type != null) {
    type=type.initialize(this,log);
  }
}","/** 
 * Initializes the MIB symbol. This will remove all levels of indirection present, such as references to types or values. No information is lost by this operation. This method may modify this object as a side-effect.<p> <strong>NOTE:</strong> This is an internal method that should only be called by the MIB loader.
 * @param log            the MIB loader log
 * @throws MibException if an error was encountered during theinitialization
 */
public void initialize(MibLoaderLog log) throws MibException {
  if (type != null) {
    try {
      type=type.initialize(this,log);
    }
 catch (    MibException e) {
      log.addError(e.getLocation(),e.getMessage());
      type=null;
    }
  }
}",0.9029202841357538
1734,"/** 
 * Initializes the MIB symbol. This will remove all levels of indirection present, such as references to types or values. No information is lost by this operation. This method may modify this object as a side-effect.<p> <strong>NOTE:</strong> This is an internal method that should only be called by the MIB loader.
 * @param log            the MIB loader log
 * @throws MibException if an error was encountered during theinitialization
 */
public void initialize(MibLoaderLog log) throws MibException {
  ObjectIdentifierValue oid;
  if (type != null) {
    type=type.initialize(this,log);
  }
  if (value != null) {
    value=value.initialize(log);
  }
  if (type != null && value != null && !type.isCompatible(value)) {
    throw new MibException(getLocation(),""String_Node_Str"");
  }
  if (value instanceof ObjectIdentifierValue) {
    oid=(ObjectIdentifierValue)value;
    if (oid.getSymbol() == null) {
      oid.setSymbol(this);
    }
  }
}","/** 
 * Initializes the MIB symbol. This will remove all levels of indirection present, such as references to types or values. No information is lost by this operation. This method may modify this object as a side-effect.<p> <strong>NOTE:</strong> This is an internal method that should only be called by the MIB loader.
 * @param log            the MIB loader log
 * @throws MibException if an error was encountered during theinitialization
 */
public void initialize(MibLoaderLog log) throws MibException {
  ObjectIdentifierValue oid;
  if (type != null) {
    try {
      type=type.initialize(this,log);
    }
 catch (    MibException e) {
      log.addError(e.getLocation(),e.getMessage());
      type=null;
    }
  }
  if (value != null) {
    try {
      value=value.initialize(log);
    }
 catch (    MibException e) {
      log.addError(e.getLocation(),e.getMessage());
      value=null;
    }
  }
  if (type != null && value != null && !type.isCompatible(value)) {
    log.addError(getLocation(),""String_Node_Str"");
  }
  if (value instanceof ObjectIdentifierValue) {
    oid=(ObjectIdentifierValue)value;
    if (oid.getSymbol() == null) {
      oid.setSymbol(this);
    }
  }
}",0.8696870621205044
1735,"/** 
 * Initializes the MIB type. This will remove all levels of indirection present, such as references to types or values. No information is lost by this operation. This method may modify this object as a side-effect, and will return the basic type.<p> <strong>NOTE:</strong> This is an internal method that should only be called by the MIB loader.
 * @param symbol         the MIB symbol containing this type
 * @param log            the MIB loader log
 * @return the basic MIB type
 * @throws MibException if an error was encountered during theinitialization
 * @since 2.2
 */
public MibType initialize(MibSymbol symbol,MibLoaderLog log) throws MibException {
  base=base.initialize(symbol,log);
  if (constraint != null) {
    constraint.initialize(this,log);
  }
  return this;
}","/** 
 * Initializes the MIB type. This will remove all levels of indirection present, such as references to types or values. No information is lost by this operation. This method may modify this object as a side-effect, and will return the basic type.<p> <strong>NOTE:</strong> This is an internal method that should only be called by the MIB loader.
 * @param symbol         the MIB symbol containing this type
 * @param log            the MIB loader log
 * @return the basic MIB type
 * @throws MibException if an error was encountered during theinitialization
 * @since 2.2
 */
public MibType initialize(MibSymbol symbol,MibLoaderLog log) throws MibException {
  base=base.initialize(symbol,log);
  if (base != null && constraint != null) {
    constraint.initialize(this,log);
  }
  return this;
}",0.9773013871374528
1736,"/** 
 * Initializes the referenced MIB type symbol. This will remove all levels of indirection present, such as references to other types, and returns the basic type. This method will add any constraints or defined values if possible.
 * @param symbol         the MIB symbol containing this type
 * @param log            the MIB loader log
 * @param ref            the referenced MIB type symbol
 * @return the basic MIB type
 * @throws MibException if an error was encountered during theinitialization
 */
private MibType initializeReference(MibSymbol symbol,MibLoaderLog log,MibTypeSymbol ref) throws MibException {
  MibType type=ref.getType();
  type=type.initialize(symbol,log);
  try {
    if (constraint != null) {
      type=type.createReference(constraint);
    }
 else     if (values != null) {
      type=type.createReference(values);
    }
 else {
      type=type.createReference();
    }
    type=type.initialize(symbol,log);
  }
 catch (  UnsupportedOperationException e) {
    throw new MibException(location,e.getMessage());
  }
  type.setReferenceSymbol(ref);
  initializeTypeTag(type,tag);
  return type;
}","/** 
 * Initializes the referenced MIB type symbol. This will remove all levels of indirection present, such as references to other types, and returns the basic type. This method will add any constraints or defined values if possible.
 * @param symbol         the MIB symbol containing this type
 * @param log            the MIB loader log
 * @param ref            the referenced MIB type symbol
 * @return the basic MIB type
 * @throws MibException if an error was encountered during theinitialization
 */
private MibType initializeReference(MibSymbol symbol,MibLoaderLog log,MibTypeSymbol ref) throws MibException {
  MibType type=ref.getType();
  if (type != null) {
    type=type.initialize(symbol,log);
  }
  if (type == null) {
    return null;
  }
  try {
    if (constraint != null) {
      type=type.createReference(constraint);
    }
 else     if (values != null) {
      type=type.createReference(values);
    }
 else {
      type=type.createReference();
    }
    type=type.initialize(symbol,log);
  }
 catch (  UnsupportedOperationException e) {
    throw new MibException(location,e.getMessage());
  }
  type.setReferenceSymbol(ref);
  initializeTypeTag(type,tag);
  return type;
}",0.8753773178094006
1737,"/** 
 * Initializes the MIB value. This will remove all levels of indirection present, such as references to other values. No value information is lost by this operation. This method may modify this object as a side-effect, and will return the basic value.<p> <strong>NOTE:</strong> This is an internal method that should only be called by the MIB loader.
 * @param log            the MIB loader log
 * @return the basic MIB value
 * @throws MibException if an error was encountered during theinitialization
 */
public MibValue initialize(MibLoaderLog log) throws MibException {
  MibSymbol ref;
  MibValue value;
  String message;
  ref=context.findSymbol(name,false);
  if (ref == null) {
    ref=context.findSymbol(name,true);
    if (ref != null) {
      message=""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str""+ ref.getMib().getName();
      log.addWarning(location,message);
    }
  }
  if (ref instanceof MibValueSymbol) {
    value=((MibValueSymbol)ref).getValue().initialize(log);
    try {
      value=value.createReference();
    }
 catch (    UnsupportedOperationException e) {
      throw new MibException(location,e.getMessage());
    }
    if (!(value instanceof ObjectIdentifierValue)) {
      value.setReferenceSymbol((MibValueSymbol)ref);
    }
    return value;
  }
 else   if (ref == null) {
    message=""String_Node_Str"" + name + ""String_Node_Str"";
    throw new MibException(location,message);
  }
 else {
    message=""String_Node_Str"" + name + ""String_Node_Str"";
    throw new MibException(location,message);
  }
}","/** 
 * Initializes the MIB value. This will remove all levels of indirection present, such as references to other values. No value information is lost by this operation. This method may modify this object as a side-effect, and will return the basic value.<p> <strong>NOTE:</strong> This is an internal method that should only be called by the MIB loader.
 * @param log            the MIB loader log
 * @return the basic MIB value
 * @throws MibException if an error was encountered during theinitialization
 */
public MibValue initialize(MibLoaderLog log) throws MibException {
  MibSymbol ref;
  MibValue value;
  String message;
  ref=context.findSymbol(name,false);
  if (ref == null) {
    ref=context.findSymbol(name,true);
    if (ref != null) {
      message=""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str""+ ref.getMib().getName();
      log.addWarning(location,message);
    }
  }
  if (ref instanceof MibValueSymbol) {
    value=((MibValueSymbol)ref).getValue();
    if (value != null) {
      value=value.initialize(log);
    }
    if (value == null) {
      return null;
    }
    try {
      value=value.createReference();
    }
 catch (    UnsupportedOperationException e) {
      throw new MibException(location,e.getMessage());
    }
    if (!(value instanceof ObjectIdentifierValue)) {
      value.setReferenceSymbol((MibValueSymbol)ref);
    }
    return value;
  }
 else   if (ref == null) {
    message=""String_Node_Str"" + name + ""String_Node_Str"";
    throw new MibException(location,message);
  }
 else {
    message=""String_Node_Str"" + name + ""String_Node_Str"";
    throw new MibException(location,message);
  }
}",0.968789013732834
1738,"/** 
 * Creates a new log entry.
 * @param type           the log entry type
 * @param location       the log entry file reference
 * @param message        the log entry message
 */
public LogEntry(int type,FileLocation location,String message){
  this.type=type;
  this.location=location;
  this.message=message;
}","/** 
 * Creates a new log entry.
 * @param type           the log entry type
 * @param location       the log entry file reference
 * @param message        the log entry message
 */
public LogEntry(int type,FileLocation location,String message){
  this.type=type;
  if (location == null || location.getFile() == null) {
    this.location=new FileLocation(new File(""String_Node_Str""));
  }
 else {
    this.location=location;
  }
  this.message=message;
}",0.7100130039011704
1739,"/** 
 * Transfers the contents of one object identifier to another one. The transfer can only be made under certain conditions, for example that no children OID:s conflict. It is also assumed that the two OID:s have the name numerical value.
 * @param location       the file location on error
 * @param src            the source OID value
 * @param dest           the destination OID value
 * @return the destination object identifier value
 * @throws MibException if the transfer couldn't be performed dueto some conflict or invalid state
 */
private ObjectIdentifierValue transfer(FileLocation location,ObjectIdentifierValue src,ObjectIdentifierValue dest) throws MibException {
  ObjectIdentifierValue child;
  if (dest.name == null) {
    dest.name=src.name;
  }
 else   if (src.name != null && !src.name.equals(dest.name)) {
    throw new MibException(location,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (src.symbol != null) {
    throw new MibException(location,""String_Node_Str"" + ""String_Node_Str"");
  }
  for (int i=0; i < src.children.size(); i++) {
    child=(ObjectIdentifierValue)src.children.get(i);
    child.parent=dest;
    dest.addChild(location,child);
  }
  src.children.clear();
  return dest;
}","/** 
 * Transfers the contents of one object identifier to another one. The transfer can only be made under certain conditions, for example that no children OID:s conflict. It is also assumed that the two OID:s have the name numerical value.
 * @param location       the file location on error
 * @param src            the source OID value
 * @param dest           the destination OID value
 * @return the destination object identifier value
 * @throws MibException if the transfer couldn't be performed dueto some conflict or invalid state
 */
private ObjectIdentifierValue transfer(FileLocation location,ObjectIdentifierValue src,ObjectIdentifierValue dest) throws MibException {
  ObjectIdentifierValue child;
  if (dest.name == null) {
    dest.name=src.name;
  }
 else   if (src.name != null && !src.name.equals(dest.name)) {
    throw new MibException(location,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (src.symbol != null) {
    throw new MibException(location,""String_Node_Str"" + ""String_Node_Str"");
  }
  for (int i=0; i < src.children.size(); i++) {
    child=(ObjectIdentifierValue)src.children.get(i);
    child.parent=dest;
    dest.addChild(location,child);
  }
  src.children=null;
  return dest;
}",0.9946786737617684
1740,"/** 
 * Initializes the MIB value. This will remove all levels of indirection present, such as references to other values. No value information is lost by this operation. This method may modify this object as a side-effect, and will return the basic value.<p> <strong>NOTE:</strong> This is an internal method that should only be called by the MIB loader.
 * @param log            the MIB loader log
 * @return the basic MIB value
 * @throws MibException if an error was encountered during theinitialization
 */
public MibValue initialize(MibLoaderLog log) throws MibException {
  ValueReference ref=null;
  ObjectIdentifierValue result=this;
  if (parent == null) {
    return this;
  }
 else   if (parent instanceof ValueReference) {
    ref=(ValueReference)parent;
  }
  parent=parent.initialize(log);
  if (ref != null) {
    if (parent instanceof ObjectIdentifierValue) {
      result=(ObjectIdentifierValue)parent;
      result=result.addChild(location,this);
    }
 else {
      throw new MibException(ref.getLocation(),""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  location=null;
  return result;
}","/** 
 * Initializes the MIB value. This will remove all levels of indirection present, such as references to other values. No value information is lost by this operation. This method may modify this object as a side-effect, and will return the basic value.<p> <strong>NOTE:</strong> This is an internal method that should only be called by the MIB loader.
 * @param log            the MIB loader log
 * @return the basic MIB value
 * @throws MibException if an error was encountered during theinitialization
 */
public MibValue initialize(MibLoaderLog log) throws MibException {
  ValueReference ref=null;
  ObjectIdentifierValue oid;
  if (parent == null) {
    return this;
  }
 else   if (parent instanceof ValueReference) {
    ref=(ValueReference)parent;
  }
  parent=parent.initialize(log);
  if (ref != null) {
    if (parent instanceof ObjectIdentifierValue) {
      oid=(ObjectIdentifierValue)parent;
      oid.addChild(location,this);
    }
 else {
      throw new MibException(ref.getLocation(),""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  location=null;
  if (parent instanceof ObjectIdentifierValue) {
    return ((ObjectIdentifierValue)parent).getChildByValue(value);
  }
 else {
    return this;
  }
}",0.9156316916488224
1741,"/** 
 * Creates a type symbol and adds it to the MIB. Also removes this node from the parse tree.
 * @param node           the node being exited
 * @return the node to add to the parse tree
 * @throws ParseException if the node analysis discovered errors
 */
protected Node exitTypeAssignment(Production node) throws ParseException {
  String name;
  MibType type;
  MibTypeSymbol symbol;
  name=getStringValue(getChildAt(node,0),0);
  if (mib.getSymbol(name) != null) {
    throw new ParseException(ParseException.ANALYSIS_ERROR,""String_Node_Str"" + name + ""String_Node_Str"",node.getStartLine(),node.getStartColumn());
  }
  if (!Character.isUpperCase(name.charAt(0))) {
    log.addWarning(getLocation(node),""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
  }
  type=(MibType)getValue(getChildAt(node,2),0);
  symbol=new MibTypeSymbol(getLocation(node),mib,name,type);
  return null;
}","/** 
 * Creates a type symbol and adds it to the MIB. Also removes this node from the parse tree.
 * @param node           the node being exited
 * @return the node to add to the parse tree
 * @throws ParseException if the node analysis discovered errors
 */
protected Node exitTypeAssignment(Production node) throws ParseException {
  String name;
  MibType type;
  name=getStringValue(getChildAt(node,0),0);
  if (mib.getSymbol(name) != null) {
    throw new ParseException(ParseException.ANALYSIS_ERROR,""String_Node_Str"" + name + ""String_Node_Str"",node.getStartLine(),node.getStartColumn());
  }
  if (!Character.isUpperCase(name.charAt(0))) {
    log.addWarning(getLocation(node),""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
  }
  type=(MibType)getValue(getChildAt(node,2),0);
  new MibTypeSymbol(getLocation(node),mib,name,type);
  return null;
}",0.9825352112676056
1742,"/** 
 * Creates a value symbol and adds it to the MIB. Also removes this node from the parse tree.
 * @param node           the node being exited
 * @return the node to add to the parse tree
 * @throws ParseException if the node analysis discovered errors
 */
protected Node exitValueAssignment(Production node) throws ParseException {
  MibValueSymbol symbol;
  String name;
  MibType type;
  MibValue value;
  name=getStringValue(getChildAt(node,0),0);
  if (mib.getSymbol(name) != null) {
    throw new ParseException(ParseException.ANALYSIS_ERROR,""String_Node_Str"" + name + ""String_Node_Str"",node.getStartLine(),node.getStartColumn());
  }
  if (!Character.isLowerCase(name.charAt(0))) {
    log.addWarning(getLocation(node),""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
  }
  type=(MibType)getValue(getChildAt(node,1),0);
  value=(MibValue)getValue(getChildAt(node,3),0);
  symbol=new MibValueSymbol(getLocation(node),mib,name,type,value);
  return null;
}","/** 
 * Creates a value symbol and adds it to the MIB. Also removes this node from the parse tree.
 * @param node           the node being exited
 * @return the node to add to the parse tree
 * @throws ParseException if the node analysis discovered errors
 */
protected Node exitValueAssignment(Production node) throws ParseException {
  String name;
  MibType type;
  MibValue value;
  name=getStringValue(getChildAt(node,0),0);
  if (mib.getSymbol(name) != null) {
    throw new ParseException(ParseException.ANALYSIS_ERROR,""String_Node_Str"" + name + ""String_Node_Str"",node.getStartLine(),node.getStartColumn());
  }
  if (!Character.isLowerCase(name.charAt(0))) {
    log.addWarning(getLocation(node),""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
  }
  type=(MibType)getValue(getChildAt(node,1),0);
  value=(MibValue)getValue(getChildAt(node,3),0);
  new MibValueSymbol(getLocation(node),mib,name,type,value);
  return null;
}",0.9398963730569948
1743,"/** 
 * Returns a previously loaded MIB file. If the MIB file hasn't been loaded, null will be returned. The MIB is identified by it's MIB name (i.e. the module name).
 * @param name           the MIB (module) name
 * @return the MIB module if found, ornull otherwise
 */
public Mib getMib(String name){
  Mib mib;
  for (int i=0; i < mibs.size(); i++) {
    mib=(Mib)mibs.get(i);
    if (name.equals(mib.getName())) {
      return mib;
    }
  }
  return null;
}","/** 
 * Returns a previously loaded MIB file. If the MIB file hasn't been loaded, null will be returned. The MIB is identified by it's file name.
 * @param file           the MIB file
 * @return the MIB module if found, ornull otherwise
 * @since 2.3
 */
public Mib getMib(File file){
  Mib mib;
  for (int i=0; i < mibs.size(); i++) {
    mib=(Mib)mibs.get(i);
    if (mib.equals(file)) {
      return mib;
    }
  }
  return null;
}",0.8695652173913043
1744,"/** 
 * Schedules the loading of a MIB. The MIB source is added to the queue of MIB:s to be loaded, unless it is already loaded or in the queue.
 * @param src            the MIB source
 */
void scheduleLoad(MibSource src){
  if (!mibs.contains(src.getFile()) && !queue.contains(src)) {
    queue.add(src);
  }
}","/** 
 * Schedules the loading of a MIB. The MIB source is added to the queue of MIB:s to be loaded, unless it is already loaded or in the queue.
 * @param src            the MIB source
 */
private void scheduleLoad(MibSource src){
  if (!mibs.contains(src.getFile()) && !queue.contains(src)) {
    queue.add(src);
  }
}",0.9873015873015872
1745,"/** 
 * Returns a value symbol from this MIB.
 * @param value          the symbol value
 * @return the MIB value symbol, or null if not found
 */
public MibValueSymbol getSymbolByValue(MibValue value){
  return (MibValueSymbol)symbolValueMap.get(value);
}","/** 
 * Returns a value symbol from this MIB.
 * @param value          the symbol value
 * @return the MIB value symbol, or null if not found
 */
public MibValueSymbol getSymbolByValue(MibValue value){
  return (MibValueSymbol)symbolValueMap.get(value.toString());
}",0.9788867562380038
1746,"/** 
 * Validates the MIB file. This will resolve all type and value references in the MIB symbols, while also validating them for consistency. Note that this method shouldn't be called until all referenced MIB files (and their respective references)  have been initialized.
 * @throws MibLoaderException if the MIB file couldn't be analyzed correctly
 * @see #initialize()
 */
void validate() throws MibLoaderException {
  MibSymbol symbol;
  MibValueSymbol value;
  int errors=log.errorCount();
  for (int i=0; i < symbolList.size(); i++) {
    symbol=(MibSymbol)symbolList.get(i);
    try {
      symbol.initialize(log);
    }
 catch (    MibException e) {
      log.addError(e.getLocation(),e.getMessage());
    }
    if (symbol instanceof MibValueSymbol) {
      value=(MibValueSymbol)symbol;
      if (value.getValue() instanceof NumberValue || value.getValue() instanceof ObjectIdentifierValue) {
        symbolValueMap.put(value.getValue(),value);
      }
    }
  }
  if (errors != log.errorCount()) {
    throw new MibLoaderException(log);
  }
}","/** 
 * Validates the MIB file. This will resolve all type and value references in the MIB symbols, while also validating them for consistency. Note that this method shouldn't be called until all referenced MIB files (and their respective references)  have been initialized.
 * @throws MibLoaderException if the MIB file couldn't be analyzed correctly
 * @see #initialize()
 */
void validate() throws MibLoaderException {
  MibSymbol symbol;
  MibValueSymbol value;
  int errors=log.errorCount();
  for (int i=0; i < symbolList.size(); i++) {
    symbol=(MibSymbol)symbolList.get(i);
    try {
      symbol.initialize(log);
    }
 catch (    MibException e) {
      log.addError(e.getLocation(),e.getMessage());
    }
    if (symbol instanceof MibValueSymbol) {
      value=(MibValueSymbol)symbol;
      if (value.getValue() instanceof NumberValue || value.getValue() instanceof ObjectIdentifierValue) {
        symbolValueMap.put(value.getValue().toString(),symbol);
      }
    }
  }
  if (errors != log.errorCount()) {
    throw new MibLoaderException(log);
  }
}",0.989622641509434
1747,"/** 
 * List albums with filter
 * @param filter
 */
public static void list(String filter){
  List<Album> albums=Album.findAll(filter);
  render(albums);
}","/** 
 * List albums
 */
public static void list(){
  List<Album> albums=Album.all().fetch(100);
  render(albums);
}",0.7749077490774908
1748,"/** 
 * Update album
 * @param id
 */
@Check(""String_Node_Str"") public static void form(Long id){
  Album album=Album.findById(id);
  Artist artist=album.artist;
  render(album,artist);
}","/** 
 * Update album
 * @param id
 */
@Check(""String_Node_Str"") public static void form(Long id){
  Album album=Album.findById(id);
  Artist artist=album.artist;
  render(""String_Node_Str"",album,artist);
}",0.9285714285714286
1749,"/** 
 * Delete album
 * @param id
 */
@Check(""String_Node_Str"") public static void delete(Long id){
  if (id == null) {
    render();
  }
  Album album=Album.findById(id);
  album.delete();
  Application.list(null);
}","/** 
 * Delete album
 * @param id
 */
@Check(""String_Node_Str"") public static void delete(Long id){
  Album album=Album.findById(id);
  album.delete();
  Application.list(null);
}",0.904040404040404
1750,"/** 
 * filter by year
 * @param albums
 * @return
 */
public static List<Album> filterByYear(List<Album> albums,String year){
  SimpleDateFormat formatYear=new SimpleDateFormat(""String_Node_Str"");
  List filteredAlbums=new ArrayList<Album>();
  for (  Album album : albums) {
    if (formatYear.format(album.releaseDate).equals(year)) {
      filteredAlbums.add(album);
    }
  }
  return filteredAlbums;
}","/** 
 * filter by year
 * @param albums
 * @return
 */
public static List<Album> filterByYear(List<Album> albums,String year){
  return select(albums,having(on(Album.class).getReleaseYear(),equalTo(year)));
}",0.4390243902439024
1751,"/** 
 * Create or update album
 * @param id
 */
public static void form(Long id){
  if (id == null) {
    render();
  }
  Album album=Album.findById(id);
  Artist artist=album.artist;
  render(album,artist);
}","/** 
 * Create album
 * @param id
 */
public static void form(){
  render();
}",0.5435540069686411
1752,"/** 
 * Create or update album
 * @param album
 * @param artist
 */
public static void save(@Valid Album album,Artist artist){
  if (Validation.hasErrors())   render(""String_Node_Str"",album);
  album.artist=artist;
  album.save();
  for (int i=0; i < 101; i++) {
    Album a=new Album(album.name);
    a.genre=album.genre;
    a.releaseDate=album.releaseDate;
    a.artist=album.artist;
    a.save();
  }
  list(null);
}","/** 
 * Create or update album
 * @param album
 * @param artist
 */
public static void save(@Valid Album album,@Valid Artist artist){
  if (Validation.hasErrors())   render(""String_Node_Str"",album);
  album.artist=artist;
  album.save();
  for (int i=0; i < 101; i++) {
    Album a=new Album(album.name);
    a.genre=album.genre;
    a.releaseDate=album.releaseDate;
    a.artist=album.artist;
    a.save();
  }
  list(null);
}",0.9917355371900828
1753,"/** 
 * @param filter
 * @return
 */
public static List<Album> findAll(String filter){
  List<Album> albums;
  if (filter != null) {
    albums=Album.find(""String_Node_Str"",filter,filter).fetch(100);
  }
 else   albums=Album.find(""String_Node_Str"").fetch(100);
  return albums;
}","/** 
 * @param filter
 * @return
 */
public static List<Album> findAll(String filter){
  List<Album> albums;
  if (filter != null) {
    Query query=Album.em().createNamedQuery(""String_Node_Str"");
    query.setParameter(""String_Node_Str"",""String_Node_Str"" + filter + ""String_Node_Str"");
    query.setMaxResults(100);
    albums=query.getResultList();
  }
 else   albums=Album.find(""String_Node_Str"").fetch(100);
  return albums;
}",0.7023977433004231
1754,"/** 
 * creates a indexes where each entry looks like: { ""name"" : ""default"", //the default index ""categories"" : [ { ""category"" : ""admin"", //name of the category ""routes"" : [ {""route"" : ""/"" , ""abstract"" : ""blah blah""} ] } ] } individual entries are created by the createIndexEntry method.
 * @param routes
 * @return
 */
public List<DynMap> createIndexes(List<DynMap> routes){
  DynMap indexes=new DynMap();
  for (  DynMap route : routes) {
    route.putIfAbsent(""String_Node_Str"",""String_Node_Str"");
    for (    String indexName : route.getList(String.class,""String_Node_Str"",""String_Node_Str"")) {
      indexes.putIfAbsent(indexName,new DynMap(""String_Node_Str"",indexName));
      DynMap index=indexes.getMap(indexName);
      String category=route.getString(""String_Node_Str"",""String_Node_Str"");
      DynMap mp=this.createIndexEntry(route);
      if (mp == null)       continue;
      index.addToListWithDot(""String_Node_Str"" + category,mp);
    }
  }
  List<DynMap> inds=new ArrayList<DynMap>();
  for (  String ind : indexes.keySet()) {
    DynMap cats=indexes.getMap(ind + ""String_Node_Str"");
    List<DynMap> catList=new ArrayList<DynMap>();
    for (    String c : cats.keySet()) {
      DynMap ct=this.createIndexCategory(c,cats.getList(DynMap.class,""String_Node_Str""));
      if (ct != null) {
        catList.add(ct);
      }
    }
    Collections.sort(catList,new Comparator<DynMap>(){
      @Override public int compare(      DynMap o1,      DynMap o2){
        return o1.getString(""String_Node_Str"").compareTo(o2.getString(""String_Node_Str""));
      }
    }
);
    indexes.getMap(ind).put(""String_Node_Str"",catList);
    inds.add(indexes.getMap(ind));
  }
  return inds;
}","/** 
 * creates a indexes where each entry looks like: { ""name"" : ""default"", //the default index ""categories"" : [ { ""category"" : ""admin"", //name of the category ""routes"" : [ {""route"" : ""/"" , ""abstract"" : ""blah blah""} ] } ] } individual entries are created by the createIndexEntry method.
 * @param routes
 * @return
 */
public List<DynMap> createIndexes(List<DynMap> routes){
  DynMap indexes=new DynMap();
  for (  DynMap route : routes) {
    route.putIfAbsent(""String_Node_Str"",""String_Node_Str"");
    for (    String indexName : route.getList(String.class,""String_Node_Str"",""String_Node_Str"")) {
      indexes.putIfAbsent(indexName,new DynMap(""String_Node_Str"",indexName));
      DynMap index=indexes.getMap(indexName);
      String category=route.getString(""String_Node_Str"",""String_Node_Str"");
      DynMap mp=this.createIndexEntry(route);
      if (mp == null)       continue;
      index.addToListWithDot(""String_Node_Str"" + category,mp);
    }
  }
  List<DynMap> inds=new ArrayList<DynMap>();
  for (  String ind : indexes.keySet()) {
    DynMap cats=indexes.getMap(ind + ""String_Node_Str"");
    List<DynMap> catList=new ArrayList<DynMap>();
    for (    String c : cats.keySet()) {
      DynMap ct=this.createIndexCategory(c,cats.getList(DynMap.class,c));
      if (ct != null) {
        catList.add(ct);
      }
    }
    Collections.sort(catList,new Comparator<DynMap>(){
      @Override public int compare(      DynMap o1,      DynMap o2){
        return o1.getString(""String_Node_Str"").compareTo(o2.getString(""String_Node_Str""));
      }
    }
);
    indexes.getMap(ind).put(""String_Node_Str"",catList);
    inds.add(indexes.getMap(ind));
  }
  return inds;
}",0.9946428571428572
1755,"@Override public void incoming(ZMQChannel channel,byte[] arg1){
}","@Override public void incoming(ZMQChannel channel,byte[] bytes){
  StrestZMQChannel c=StrestZMQChannel.get(channel);
  try {
    String json=new String(bytes,""String_Node_Str"");
    StrestJsonRequest request=new StrestJsonRequest(DynMap.instance(json));
    c.setLastIncoming();
    request.setConnectionChannel(c);
    this.master.getRouter().incoming(request);
  }
 catch (  UnsupportedEncodingException e) {
    this.error(e);
    c.cleanup();
  }
}",0.2359767891682785
1756,"@Override public void stop(){
  server.close();
}","@Override public void stop(){
  server.close();
  this.connectionReaper.cancel();
}",0.7424242424242424
1757,"@Override public void start(Executor bossExecutor,Executor workerExecutor){
  this.server=new ZMQServer();
  server.listen(this.config.getInteger(""String_Node_Str""),this,true);
}","@Override public void start(Executor bossExecutor,Executor workerExecutor){
  this.server=new ZMQServer();
  int port=this.config.getInteger(""String_Node_Str"");
  server.listen(port,this,true);
  this.connectionReaper.schedule(new TimerTask(){
    @Override public void run(){
      try {
        StrestZMQChannel.reaper();
      }
 catch (      Exception x) {
        log.error(""String_Node_Str"",x);
      }
    }
  }
,60 * 1000,60 * 1000);
  System.out.println(""String_Node_Str"" + port + '.');
}",0.4474074074074074
1758,"@Override public void error(Exception arg0){
}","@Override public void error(Exception e){
  log.error(""String_Node_Str"",e);
}",0.6829268292682927
1759,"public void incoming(StrestRequest request){
  boolean isStrest=StrestUtil.isStrest(request);
  try {
    StrestUtil.validateRequest(request);
  }
 catch (  StrestException x) {
    log.error(""String_Node_Str"",x);
    if (request.getConnectionChannel() != null) {
      request.getConnectionChannel().cleanup();
    }
    return;
  }
  ResponseBuilder response=new ResponseBuilder(request);
  String txnId=request.getTxnId();
  request.getConnectionChannel().incoming(request);
  log.info(""String_Node_Str"" + request);
  StrestController controller=null;
  try {
    try {
      controller=this.getRouteLookup().find(request.getUri());
      if (controller == null) {
        throw StrestHttpException.NOT_FOUND();
      }
      controller.setRouter(this);
      controller.setStrest(isStrest);
      if (isStrest) {
        controller.setStrestTxnId(txnId);
      }
      controller.setParamsGET(DynMapFactory.instanceFromURL(request.getUri()));
      controller.getParams().putAll(request.getParams());
      String contentType=request.getHeader(CONTENT_TYPE);
      if (contentType != null) {
        String pms=request.getContent().toString();
        if (pms != null) {
          if (contentType.contains(""String_Node_Str"")) {
            controller.setParamsPOST(DynMapFactory.instanceFromURLEncoded(pms));
          }
 else           if (contentType.contains(""String_Node_Str"")) {
            controller.setParamsPOST(DynMapFactory.instanceFromJSON(pms));
          }
        }
      }
      controller.getParams().putAll(controller.getParamsGET());
      controller.getParams().putAll(controller.getParamsPOST());
      controller.setRequest(request);
      controller.setResponse(response.getResponse());
      for (      StrestControllerFilter f : this.getFilters(controller)) {
        f.before(controller);
      }
      if (!controller.isSkipExecution()) {
        if (request.getMethod() == StrestHeader.Method.GET) {
          controller.handleGET(controller.getParams());
        }
 else         if (request.getMethod() == StrestHeader.Method.POST) {
          controller.handlePOST(controller.getParams());
        }
 else         if (request.getMethod() == StrestHeader.Method.PUT) {
          controller.handlePUT(controller.getParams());
        }
 else         if (request.getMethod() == StrestHeader.Method.DELETE) {
          controller.handleDELETE(controller.getParams());
        }
 else {
          throw StrestHttpException.METHOD_NOT_ALLOWED();
        }
        if (this.isAsync(controller,request.getMethod())) {
        }
      }
    }
 catch (    StrestHttpException e) {
      throw e;
    }
catch (    Exception x) {
      StrestHttpException e=StrestHttpException.INTERNAL_SERVER_ERROR();
      e.setCause(x);
      log.error(""String_Node_Str"",x);
      throw e;
    }
  }
 catch (  StrestHttpException e) {
    response.status(e.getCode(),e.getMessage());
    response.txnStatus(TxnStatus.COMPLETED);
    if (controller != null) {
      for (      StrestControllerFilter f : this.getFilters(controller)) {
        f.error(controller,response.getResponse(),e);
      }
    }
    try {
      this.sendResponse(request,response);
    }
 catch (    Exception e1) {
      log.error(""String_Node_Str"",e);
    }
    return;
  }
  this.finishResponse(controller,response);
}","public void incoming(StrestRequest request){
  boolean isStrest=StrestUtil.isStrest(request);
  try {
    StrestUtil.validateRequest(request);
  }
 catch (  StrestException x) {
    log.error(""String_Node_Str"",x);
    if (request.getConnectionChannel() != null) {
      request.getConnectionChannel().cleanup();
    }
    return;
  }
  ResponseBuilder response=new ResponseBuilder(request);
  String txnId=request.getTxnId();
  request.getConnectionChannel().incoming(request);
  StrestController controller=null;
  try {
    try {
      controller=this.getRouteLookup().find(request.getUri());
      if (controller == null) {
        throw StrestHttpException.NOT_FOUND();
      }
      controller.setRouter(this);
      controller.setStrest(isStrest);
      if (isStrest) {
        controller.setStrestTxnId(txnId);
      }
      controller.setParamsGET(DynMapFactory.instanceFromURL(request.getUri()));
      controller.getParams().putAll(request.getParams());
      String contentType=request.getHeader(CONTENT_TYPE);
      if (contentType != null) {
        String pms=request.getContent().toString();
        if (pms != null) {
          if (contentType.contains(""String_Node_Str"")) {
            controller.setParamsPOST(DynMapFactory.instanceFromURLEncoded(pms));
          }
 else           if (contentType.contains(""String_Node_Str"")) {
            controller.setParamsPOST(DynMapFactory.instanceFromJSON(pms));
          }
        }
      }
      controller.getParams().putAll(controller.getParamsGET());
      controller.getParams().putAll(controller.getParamsPOST());
      controller.setRequest(request);
      controller.setResponse(response.getResponse());
      for (      StrestControllerFilter f : this.getFilters(controller)) {
        f.before(controller);
      }
      if (!controller.isSkipExecution()) {
        if (request.getMethod() == StrestHeader.Method.GET) {
          controller.handleGET(controller.getParams());
        }
 else         if (request.getMethod() == StrestHeader.Method.POST) {
          controller.handlePOST(controller.getParams());
        }
 else         if (request.getMethod() == StrestHeader.Method.PUT) {
          controller.handlePUT(controller.getParams());
        }
 else         if (request.getMethod() == StrestHeader.Method.DELETE) {
          controller.handleDELETE(controller.getParams());
        }
 else {
          throw StrestHttpException.METHOD_NOT_ALLOWED();
        }
        if (this.isAsync(controller,request.getMethod())) {
        }
      }
    }
 catch (    StrestHttpException e) {
      throw e;
    }
catch (    Exception x) {
      StrestHttpException e=StrestHttpException.INTERNAL_SERVER_ERROR();
      e.setCause(x);
      log.error(""String_Node_Str"",x);
      throw e;
    }
  }
 catch (  StrestHttpException e) {
    response.status(e.getCode(),e.getMessage());
    response.txnStatus(TxnStatus.COMPLETED);
    if (controller != null) {
      for (      StrestControllerFilter f : this.getFilters(controller)) {
        f.error(controller,response.getResponse(),e);
      }
    }
    try {
      this.sendResponse(request,response);
    }
 catch (    Exception e1) {
      log.error(""String_Node_Str"",e);
    }
    return;
  }
  this.finishResponse(controller,response);
}",0.9937547600913936
1760,"/** 
 * initializes the passed in server.  Use this if you need to override the  StrestServer or set a new Router, ect.   In other cases you should use the the StrestServer.instance methods
 * @param server
 * @param config
 * @throws Exception
 */
public void initialize(DynMap config) throws Exception {
  if (config == null) {
    throw new Exception(""String_Node_Str"");
  }
  this.setMaxWorkerThreads(config.getInteger(""String_Node_Str"",10));
  this.setMaxIOThreads(config.getInteger(""String_Node_Str"",8));
  List<String> controllerPackages=config.getList(String.class,""String_Node_Str"");
  if (controllerPackages != null) {
    for (    String c : controllerPackages) {
      this.getRouter().addControllerPackage(c);
    }
  }
  List<String> filters=config.getList(String.class,""String_Node_Str"");
  if (filters != null) {
    this.getRouter().setFilters(""String_Node_Str"",filters);
  }
  this.getRouter().setServer(this);
  DynMap listeners=config.getMap(""String_Node_Str"",new DynMap());
  for (  String name : listeners.keySet()) {
    DynMap listenerConfig=listeners.getMap(name,new DynMap());
    ServerListenerBase listener=null;
    if (listenerConfig.containsKey(""String_Node_Str"")) {
      listener=Reflection.instance(ServerListenerBase.class,listenerConfig.getString(""String_Node_Str""),this,listenerConfig);
    }
 else {
      Class cls=this.listenerClasses.get(name);
      if (cls == null) {
        log.warn(""String_Node_Str"" + name + ""String_Node_Str"");
        continue;
      }
      listener=Reflection.instance(cls,this,listenerConfig);
    }
    if (listener == null) {
      log.warn(""String_Node_Str"" + name + ""String_Node_Str"");
      continue;
    }
    this.listeners.put(name,listener);
  }
}","/** 
 * initializes the passed in server.  Use this if you need to override the  StrestServer or set a new Router, ect.   In other cases you should use the the StrestServer.instance methods
 * @param server
 * @param config
 * @throws Exception
 */
public void initialize(DynMap config) throws Exception {
  if (config == null) {
    throw new Exception(""String_Node_Str"");
  }
  this.setMaxWorkerThreads(config.getInteger(""String_Node_Str"",10));
  this.setMaxIOThreads(config.getInteger(""String_Node_Str"",8));
  List<String> controllerPackages=config.getList(String.class,""String_Node_Str"");
  if (controllerPackages != null) {
    for (    String c : controllerPackages) {
      this.getRouter().addControllerPackage(c);
    }
  }
  List<String> filters=config.getList(String.class,""String_Node_Str"");
  if (filters != null) {
    this.getRouter().setFilters(""String_Node_Str"",filters);
  }
  this.getRouter().setServer(this);
  DynMap listeners=config.getMap(""String_Node_Str"",new DynMap());
  for (  String name : listeners.keySet()) {
    DynMap listenerConfig=listeners.getMap(name,new DynMap());
    ServerListenerBase listener=null;
    if (listenerConfig.containsKey(""String_Node_Str"")) {
      listener=Reflection.instance(ServerListenerBase.class,listenerConfig.getString(""String_Node_Str""),this,listenerConfig);
    }
 else {
      Class<? extends ServerListenerBase> cls=this.listenerClasses.get(name);
      if (cls == null) {
        log.warn(""String_Node_Str"" + name + ""String_Node_Str"");
        continue;
      }
      listener=Reflection.instance(cls,this,listenerConfig);
    }
    if (listener == null) {
      log.warn(""String_Node_Str"" + name + ""String_Node_Str"");
      continue;
    }
    this.listeners.put(name,listener);
  }
}",0.9913743530764808
1761,"public static <T>T getAnnotationVal(Class annotation,Object obj,Class<T> cls,String name){
  try {
    return TypeCast.cast(cls,obj.getClass().getAnnotation(annotation).getClass().getMethod(name).invoke(obj));
  }
 catch (  IllegalArgumentException e) {
    e.printStackTrace();
  }
catch (  SecurityException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
  }
catch (  NoSuchMethodException e) {
    e.printStackTrace();
  }
  return null;
}","public static <T>T getAnnotationVal(Class annotation,Object obj,Class<T> cls,String name){
  try {
    Object annotationObj=obj.getClass().getAnnotation(annotation);
    return TypeCast.cast(cls,annotationObj.getClass().getMethod(name).invoke(annotationObj));
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
  }
  return null;
}",0.4773480662983425
1762,"public ResponseBuilder getResponseAsBuilder(){
  return ResponseBuilder.instance(this.getRequest());
}","public ResponseBuilder getResponseAsBuilder(){
  return ResponseBuilder.instance(this.getResponse());
}",0.9560975609756096
1763,"@Override public void before(StrestController controller) throws StrestException {
  if (controller.isStrest()) {
    return;
  }
  String sessionId=null;
  String cookieString=controller.getRequest().getHeader(HttpHeaders.Names.COOKIE);
  if (cookieString != null) {
    CookieDecoder cookieDecoder=new CookieDecoder();
    Set<Cookie> cookies=cookieDecoder.decode(cookieString);
    for (    Cookie cookie : cookies) {
      if (cookie.getName().equals(SESSION)) {
        sessionId=cookie.getValue();
      }
    }
    if (!cookies.isEmpty()) {
      CookieEncoder cookieEncoder=new CookieEncoder(true);
      for (      Cookie cookie : cookies) {
        cookieEncoder.addCookie(cookie);
      }
    }
  }
  if (sessionId != null) {
    Map<String,Object> vals=this.getSessionPersistence(controller).loadSession(sessionId);
    Date expires=TypeCast.cast(Date.class,""String_Node_Str"",new Date());
    if (new Date().before(expires)) {
      log.info(""String_Node_Str"");
      return;
    }
    if (vals != null) {
      controller.getSessionStorage().putAll(vals);
    }
    controller.getConnectionStorage().put(SESSION,sessionId);
  }
}","@Override public void before(StrestController controller) throws StrestException {
  if (controller.isStrest()) {
    return;
  }
  String sessionId=null;
  String cookieString=controller.getRequest().getHeader(HttpHeaders.Names.COOKIE);
  if (cookieString != null) {
    CookieDecoder cookieDecoder=new CookieDecoder();
    Set<Cookie> cookies=cookieDecoder.decode(cookieString);
    for (    Cookie cookie : cookies) {
      if (cookie.getName().equals(SESSION)) {
        sessionId=cookie.getValue();
      }
    }
    if (!cookies.isEmpty()) {
      CookieEncoder cookieEncoder=new CookieEncoder(true);
      for (      Cookie cookie : cookies) {
        cookieEncoder.addCookie(cookie);
      }
    }
  }
  if (""String_Node_Str"".equals(sessionId)) {
    sessionId=null;
  }
  if (sessionId != null) {
    Map<String,Object> vals=this.getSessionPersistence(controller).loadSession(sessionId);
    Date expires=TypeCast.cast(Date.class,""String_Node_Str"");
    if (expires != null && expires.before(new Date())) {
      log.info(""String_Node_Str"");
      return;
    }
    if (vals != null) {
      controller.getSessionStorage().putAll(vals);
    }
    controller.getConnectionStorage().put(SESSION,sessionId);
  }
}",0.9428208386277002
1764,"@Override public void after(StrestController controller) throws StrestException {
  if (controller.isStrest()) {
    return;
  }
  String sessionId=(String)controller.getConnectionStorage().get(SESSION);
  if (sessionId == null && !controller.getSessionStorage().isEmpty()) {
    CookieEncoder cookieEncoder=new CookieEncoder(true);
    sessionId=UUID.randomUUID().toString();
    Cookie cookie=new DefaultCookie(SESSION,sessionId);
    cookie.setMaxAge(this.maxAge);
    cookieEncoder.addCookie(cookie);
    controller.getResponse().setHeader(HttpHeaders.Names.COOKIE,cookieEncoder.encode());
    controller.getSessionStorage().put(""String_Node_Str"",IsoDateUtil.getIsoDate(new Date(new Date().getTime() + (1000 * this.maxAge))));
  }
  if (sessionId != null) {
    this.getSessionPersistence(controller).saveSession(sessionId,controller.getSessionStorage());
  }
}","@Override public void after(StrestController controller) throws StrestException {
  if (controller.isStrest()) {
    return;
  }
  String sessionId=(String)controller.getConnectionStorage().get(SESSION);
  if (TypeCast.cast(Boolean.class,controller.getConnectionStorage().get(""String_Node_Str""),false)) {
    log.info(""String_Node_Str"");
    if (sessionId == null) {
      return;
    }
    CookieEncoder cookieEncoder=new CookieEncoder(true);
    Cookie cookie=new DefaultCookie(SESSION,""String_Node_Str"");
    cookie.setMaxAge(0);
    cookieEncoder.addCookie(cookie);
    controller.getResponse().setHeader(HttpHeaders.Names.SET_COOKIE,cookieEncoder.encode());
    this.getSessionPersistence(controller).deleteSession(sessionId);
    return;
  }
  if (sessionId == null && !controller.getSessionStorage().isEmpty()) {
    CookieEncoder cookieEncoder=new CookieEncoder(true);
    sessionId=UUID.randomUUID().toString();
    Cookie cookie=new DefaultCookie(SESSION,sessionId);
    cookie.setMaxAge(this.maxAge);
    cookieEncoder.addCookie(cookie);
    controller.getResponse().setHeader(HttpHeaders.Names.SET_COOKIE,cookieEncoder.encode());
  }
  controller.getSessionStorage().put(""String_Node_Str"",IsoDateUtil.getIsoDate(new Date(new Date().getTime() + (1000 * this.maxAge))));
  if (sessionId != null) {
    this.getSessionPersistence(controller).saveSession(sessionId,controller.getSessionStorage());
  }
}",0.7565905096660809
1765,"public void incoming(Channel channel,HttpRequest request){
  boolean isStrest=StrestUtil.isStrest(request);
  ResponseBuilder response=new ResponseBuilder(request);
  this.connections.putIfAbsent(channel,new StrestConnectionChannel(channel));
  StrestConnectionChannel con=this.connections.get(channel);
  String txnId=request.getHeader(StrestUtil.HEADERS.TXN_ID);
  con.incoming(request);
  StrestController controller=null;
  try {
    try {
      controller=this.getRouteLookup().find(request.getUri());
      if (controller == null) {
        throw StrestHttpException.NOT_FOUND();
      }
      controller.setStrest(isStrest);
      if (isStrest) {
        controller.setStrestTxnId(txnId);
      }
      controller.setParamsGET(DynMapFactory.instanceFromURL(request.getUri()));
      String contentType=request.getHeader(CONTENT_TYPE);
      if (contentType != null && contentType.contains(""String_Node_Str"")) {
        String pms=request.getContent().toString(Charset.forName(""String_Node_Str""));
        if (pms != null) {
          controller.setParamsPOST(DynMapFactory.instanceFromURL(pms));
        }
      }
      controller.getParams().putAll(controller.getParamsGET());
      controller.getParams().putAll(controller.getParamsPOST());
      controller.setRequest(request);
      controller.setResponse(response.getResponse());
      controller.setChannelConnection(con);
      for (      StrestControllerFilter f : controller.getFilters()) {
        f.before(controller);
      }
      for (      StrestControllerFilter f : this.defaultFilters) {
        f.before(controller);
      }
      if (request.getMethod() == HttpMethod.GET) {
        controller.handleGET(controller.getParams());
      }
 else       if (request.getMethod() == HttpMethod.POST) {
        controller.handlePOST(controller.getParams());
      }
 else       if (request.getMethod() == HttpMethod.PUT) {
        controller.handlePUT(controller.getParams());
      }
 else       if (request.getMethod() == HttpMethod.DELETE) {
        controller.handleDELETE(controller.getParams());
      }
 else {
        throw StrestHttpException.METHOD_NOT_ALLOWED();
      }
      for (      StrestControllerFilter f : controller.getFilters()) {
        f.after(controller);
      }
      for (      StrestControllerFilter f : this.defaultFilters) {
        f.after(controller);
      }
      response.setResponse(controller.getResponse());
      if (!controller.isSendResponse()) {
        log.info(""String_Node_Str"");
        return;
      }
    }
 catch (    StrestHttpException e) {
      throw e;
    }
catch (    Exception x) {
      StrestHttpException e=StrestHttpException.INTERNAL_SERVER_ERROR();
      e.setCause(x);
      log.error(""String_Node_Str"",x);
      throw e;
    }
  }
 catch (  StrestHttpException e) {
    response.status(e.getCode(),e.getMessage());
    response.txnStatus(StrestUtil.HEADERS.TXN_STATUS_VALUES.COMPLETE);
    if (controller != null) {
      for (      StrestControllerFilter f : controller.getFilters()) {
        f.error(controller,response.getResponse(),e);
      }
    }
    for (    StrestControllerFilter f : this.defaultFilters) {
      f.error(controller,response.getResponse(),e);
    }
  }
  String txnStatus=response.getTxnStatus();
  if (txnStatus == null) {
    txnStatus=StrestUtil.HEADERS.TXN_STATUS_VALUES.COMPLETE;
  }
  if (StrestUtil.HEADERS.TXN_ACCEPT_VALUES.SINGLE.equalsIgnoreCase(request.getHeader(StrestUtil.HEADERS.TXN_ACCEPT))) {
    txnStatus=StrestUtil.HEADERS.TXN_STATUS_VALUES.COMPLETE;
  }
  response.txnStatus(txnStatus);
  ChannelFuture future=con.sendMessage(response);
  if (!isStrest) {
    future.addListener(ChannelFutureListener.CLOSE);
    this.removeChannel(channel);
  }
}","public void incoming(Channel channel,HttpRequest request){
  boolean isStrest=StrestUtil.isStrest(request);
  ResponseBuilder response=new ResponseBuilder(request);
  this.connections.putIfAbsent(channel,new StrestConnectionChannel(channel));
  StrestConnectionChannel con=this.connections.get(channel);
  String txnId=request.getHeader(StrestUtil.HEADERS.TXN_ID);
  con.incoming(request);
  StrestController controller=null;
  try {
    try {
      controller=this.getRouteLookup().find(request.getUri());
      if (controller == null) {
        throw StrestHttpException.NOT_FOUND();
      }
      controller.setStrest(isStrest);
      if (isStrest) {
        controller.setStrestTxnId(txnId);
      }
      controller.setParamsGET(DynMapFactory.instanceFromURL(request.getUri()));
      String contentType=request.getHeader(CONTENT_TYPE);
      if (contentType != null && contentType.contains(""String_Node_Str"")) {
        String pms=request.getContent().toString(Charset.forName(""String_Node_Str""));
        if (pms != null) {
          controller.setParamsPOST(DynMapFactory.instanceFromURLEncoded(pms));
        }
      }
      controller.getParams().putAll(controller.getParamsGET());
      controller.getParams().putAll(controller.getParamsPOST());
      controller.setRequest(request);
      controller.setResponse(response.getResponse());
      controller.setChannelConnection(con);
      for (      StrestControllerFilter f : controller.getFilters()) {
        f.before(controller);
      }
      for (      StrestControllerFilter f : this.defaultFilters) {
        f.before(controller);
      }
      if (request.getMethod() == HttpMethod.GET) {
        controller.handleGET(controller.getParams());
      }
 else       if (request.getMethod() == HttpMethod.POST) {
        controller.handlePOST(controller.getParams());
      }
 else       if (request.getMethod() == HttpMethod.PUT) {
        controller.handlePUT(controller.getParams());
      }
 else       if (request.getMethod() == HttpMethod.DELETE) {
        controller.handleDELETE(controller.getParams());
      }
 else {
        throw StrestHttpException.METHOD_NOT_ALLOWED();
      }
      for (      StrestControllerFilter f : controller.getFilters()) {
        f.after(controller);
      }
      for (      StrestControllerFilter f : this.defaultFilters) {
        f.after(controller);
      }
      response.setResponse(controller.getResponse());
      if (!controller.isSendResponse()) {
        log.info(""String_Node_Str"");
        return;
      }
    }
 catch (    StrestHttpException e) {
      throw e;
    }
catch (    Exception x) {
      StrestHttpException e=StrestHttpException.INTERNAL_SERVER_ERROR();
      e.setCause(x);
      log.error(""String_Node_Str"",x);
      throw e;
    }
  }
 catch (  StrestHttpException e) {
    response.status(e.getCode(),e.getMessage());
    response.txnStatus(StrestUtil.HEADERS.TXN_STATUS_VALUES.COMPLETE);
    if (controller != null) {
      for (      StrestControllerFilter f : controller.getFilters()) {
        f.error(controller,response.getResponse(),e);
      }
    }
    for (    StrestControllerFilter f : this.defaultFilters) {
      f.error(controller,response.getResponse(),e);
    }
  }
  String txnStatus=response.getTxnStatus();
  if (txnStatus == null) {
    txnStatus=StrestUtil.HEADERS.TXN_STATUS_VALUES.COMPLETE;
  }
  if (StrestUtil.HEADERS.TXN_ACCEPT_VALUES.SINGLE.equalsIgnoreCase(request.getHeader(StrestUtil.HEADERS.TXN_ACCEPT))) {
    txnStatus=StrestUtil.HEADERS.TXN_STATUS_VALUES.COMPLETE;
  }
  response.txnStatus(txnStatus);
  ChannelFuture future=con.sendMessage(response);
  if (!isStrest) {
    future.addListener(ChannelFutureListener.CLOSE);
    this.removeChannel(channel);
  }
}",0.9990622906898862
1766,"public void incoming(Channel channel,HttpRequest request){
  boolean isStrest=""String_Node_Str"".equalsIgnoreCase(request.getProtocolVersion().getProtocolName());
  ResponseBuilder response=new ResponseBuilder(request);
  this.connections.putIfAbsent(channel,new StrestConnectionChannel(channel));
  StrestConnectionChannel con=this.connections.get(channel);
  String txnId=request.getHeader(StrestUtil.HEADERS.TXN_ID);
  con.incoming(request);
  StrestController controller=null;
  try {
    try {
      controller=this.getRouteLookup().find(request.getUri());
      if (controller == null) {
        throw StrestHttpException.NOT_FOUND();
      }
      controller.setStrest(isStrest);
      if (isStrest) {
        controller.setStrestTxnId(txnId);
      }
      DynMap params=DynMapFactory.instanceFromURL(request.getUri());
      String contentType=request.getHeader(CONTENT_TYPE);
      if (contentType != null && contentType.contains(""String_Node_Str"")) {
        String pms=request.getContent().toString(Charset.forName(""String_Node_Str""));
        if (pms != null) {
          controller.getParams().putAll(DynMapFactory.instanceFromURL(pms));
        }
      }
      controller.getParams().putAll(params);
      controller.setRequest(request);
      controller.setResponse(response.getResponse());
      controller.setChannelConnection(con);
      for (      StrestControllerFilter f : controller.getFilters()) {
        f.before(controller);
      }
      for (      StrestControllerFilter f : this.defaultFilters) {
        f.before(controller);
      }
      if (request.getMethod() == HttpMethod.GET) {
        controller.handleGET(controller.getParams());
      }
 else       if (request.getMethod() == HttpMethod.POST) {
        controller.handlePOST(controller.getParams());
      }
 else       if (request.getMethod() == HttpMethod.PUT) {
        controller.handlePUT(controller.getParams());
      }
 else       if (request.getMethod() == HttpMethod.DELETE) {
        controller.handleDELETE(controller.getParams());
      }
 else {
        throw StrestHttpException.METHOD_NOT_ALLOWED();
      }
      for (      StrestControllerFilter f : controller.getFilters()) {
        f.after(controller);
      }
      for (      StrestControllerFilter f : this.defaultFilters) {
        f.after(controller);
      }
      response.setResponse(controller.getResponse());
      if (!controller.isSendResponse()) {
        log.info(""String_Node_Str"");
        return;
      }
    }
 catch (    StrestHttpException e) {
      throw e;
    }
catch (    Exception x) {
      StrestHttpException e=StrestHttpException.INTERNAL_SERVER_ERROR();
      e.setCause(x);
      log.error(""String_Node_Str"",x);
      throw e;
    }
  }
 catch (  StrestHttpException e) {
    response.status(e.getCode(),e.getMessage());
    response.txnStatus(StrestUtil.HEADERS.TXN_STATUS_VALUES.COMPLETE);
    for (    StrestControllerFilter f : controller.getFilters()) {
      f.error(controller,response.getResponse(),e);
    }
    if (controller != null) {
      for (      StrestControllerFilter f : this.defaultFilters) {
        f.error(controller,response.getResponse(),e);
      }
    }
  }
  String txnStatus=response.getTxnStatus();
  if (txnStatus == null) {
    txnStatus=StrestUtil.HEADERS.TXN_STATUS_VALUES.COMPLETE;
  }
  if (StrestUtil.HEADERS.TXN_ACCEPT_VALUES.SINGLE.equalsIgnoreCase(request.getHeader(StrestUtil.HEADERS.TXN_ACCEPT))) {
    txnStatus=StrestUtil.HEADERS.TXN_STATUS_VALUES.COMPLETE;
  }
  response.txnStatus(txnStatus);
  ChannelFuture future=con.sendMessage(response);
  if (!isStrest) {
    future.addListener(ChannelFutureListener.CLOSE);
    this.removeChannel(channel);
  }
}","public void incoming(Channel channel,HttpRequest request){
  boolean isStrest=""String_Node_Str"".equalsIgnoreCase(request.getProtocolVersion().getProtocolName());
  ResponseBuilder response=new ResponseBuilder(request);
  this.connections.putIfAbsent(channel,new StrestConnectionChannel(channel));
  StrestConnectionChannel con=this.connections.get(channel);
  String txnId=request.getHeader(StrestUtil.HEADERS.TXN_ID);
  con.incoming(request);
  StrestController controller=null;
  try {
    try {
      controller=this.getRouteLookup().find(request.getUri());
      if (controller == null) {
        throw StrestHttpException.NOT_FOUND();
      }
      controller.setStrest(isStrest);
      if (isStrest) {
        controller.setStrestTxnId(txnId);
      }
      DynMap params=DynMapFactory.instanceFromURL(request.getUri());
      String contentType=request.getHeader(CONTENT_TYPE);
      if (contentType != null && contentType.contains(""String_Node_Str"")) {
        String pms=request.getContent().toString(Charset.forName(""String_Node_Str""));
        if (pms != null) {
          controller.getParams().putAll(DynMapFactory.instanceFromURL(pms));
        }
      }
      controller.getParams().putAll(params);
      controller.setRequest(request);
      controller.setResponse(response.getResponse());
      controller.setChannelConnection(con);
      for (      StrestControllerFilter f : controller.getFilters()) {
        f.before(controller);
      }
      for (      StrestControllerFilter f : this.defaultFilters) {
        f.before(controller);
      }
      if (request.getMethod() == HttpMethod.GET) {
        controller.handleGET(controller.getParams());
      }
 else       if (request.getMethod() == HttpMethod.POST) {
        controller.handlePOST(controller.getParams());
      }
 else       if (request.getMethod() == HttpMethod.PUT) {
        controller.handlePUT(controller.getParams());
      }
 else       if (request.getMethod() == HttpMethod.DELETE) {
        controller.handleDELETE(controller.getParams());
      }
 else {
        throw StrestHttpException.METHOD_NOT_ALLOWED();
      }
      for (      StrestControllerFilter f : controller.getFilters()) {
        f.after(controller);
      }
      for (      StrestControllerFilter f : this.defaultFilters) {
        f.after(controller);
      }
      response.setResponse(controller.getResponse());
      if (!controller.isSendResponse()) {
        log.info(""String_Node_Str"");
        return;
      }
    }
 catch (    StrestHttpException e) {
      throw e;
    }
catch (    Exception x) {
      StrestHttpException e=StrestHttpException.INTERNAL_SERVER_ERROR();
      e.setCause(x);
      log.error(""String_Node_Str"",x);
      throw e;
    }
  }
 catch (  StrestHttpException e) {
    response.status(e.getCode(),e.getMessage());
    response.txnStatus(StrestUtil.HEADERS.TXN_STATUS_VALUES.COMPLETE);
    if (controller != null) {
      for (      StrestControllerFilter f : controller.getFilters()) {
        f.error(controller,response.getResponse(),e);
      }
    }
    for (    StrestControllerFilter f : this.defaultFilters) {
      f.error(controller,response.getResponse(),e);
    }
  }
  String txnStatus=response.getTxnStatus();
  if (txnStatus == null) {
    txnStatus=StrestUtil.HEADERS.TXN_STATUS_VALUES.COMPLETE;
  }
  if (StrestUtil.HEADERS.TXN_ACCEPT_VALUES.SINGLE.equalsIgnoreCase(request.getHeader(StrestUtil.HEADERS.TXN_ACCEPT))) {
    txnStatus=StrestUtil.HEADERS.TXN_STATUS_VALUES.COMPLETE;
  }
  response.txnStatus(txnStatus);
  ChannelFuture future=con.sendMessage(response);
  if (!isStrest) {
    future.addListener(ChannelFutureListener.CLOSE);
    this.removeChannel(channel);
  }
}",0.9634443541835904
1767,"@Test public void keywordMatching(){
}","@Test public void keywordMatching(){
  highlight(""String_Node_Str"",1);
  highlight(""String_Node_Str"",2);
  highlight(""String_Node_Str"",1);
  highlight(""String_Node_Str"",2);
}",0.3584905660377358
1768,"@Before public void setup(){
}","@Before public void setup(){
  keywords(""String_Node_Str"");
}",0.6593406593406593
1769,"public Configuration(String name,String keywords,List<Mapping> mappings){
}","public Configuration(String name,List<Mapping> mappings){
  this.name=name;
  this.mappings=mappings;
}",0.6629213483146067
1770,"protected void highlight(Content content,String id){
  ICompositeNode node=NodeModelUtils.getNode(content);
  if (node == null) {
    return;
  }
  int offset=node.getOffset() + content.getIntend().size();
  int length=node.getLength();
  acceptor.addPosition(offset,length,id);
}","protected void highlight(Content content,String id){
  ICompositeNode node=NodeModelUtils.getNode(content);
  if (node == null) {
    return;
  }
  int offset=node.getOffset();
  int length=node.getLength();
  acceptor.addPosition(offset,length,id);
}",0.9453860640301318
1771,"@Override public String getLang(){
  if (lang == null) {
    lang=Strings2.firstWord(getValue());
  }
  return lang;
}","@Override public String getLang(){
  if (lang == null) {
    lang=Strings2.firstWord(getText().substring(PREFIX.length()));
  }
  return lang;
}",0.8778625954198473
1772,"@Override protected void internalCustomizeDocumentCommand(IDocument document,DocumentCommand command) throws BadLocationException {
  if (!isIntend(document,command)) {
    return;
  }
  IRegion region=document.getLineInformationOfOffset(command.offset);
  document.replace(region.getOffset(),0,""String_Node_Str"");
  command.text=""String_Node_Str"";
}","@Override protected void internalCustomizeDocumentCommand(IDocument document,DocumentCommand command) throws BadLocationException {
  if (!isIntend(document,command)) {
    return;
  }
  IRegion region=document.getLineInformationOfOffset(command.offset);
  String line=document.get(region.getOffset(),region.getLength());
  if (line.trim().length() == 0) {
    return;
  }
  document.replace(region.getOffset(),0,""String_Node_Str"");
  command.text=""String_Node_Str"";
}",0.8557457212713936
1773,"@Override public Properties getProperties(){
  return new AlchemistProperties();
}","@Override public Properties getProperties(){
  return AlchemistProperties.INSTANCE;
}",0.9101796407185628
1774,"@Override public CommandHandler getCommands(){
  return new AlchemistCommands();
}","@Override public CommandHandler getCommands(){
  return AlchemistCommands.INSTANCE;
}",0.9101796407185628
1775,"@Override public Properties getProperties(){
  return new BlacksmithProperties();
}","@Override public Properties getProperties(){
  return BlacksmithProperties.INSTANCE;
}",0.9112426035502958
1776,"@Override public CommandHandler getCommands(){
  return new BlacksmithCommands();
}","@Override public CommandHandler getCommands(){
  return BlacksmithCommands.INSTANCE;
}",0.9112426035502958
1777,"/** 
 * Get the current version of Citizens
 * @return
 */
public static String getVersion(){
  return version;
}","public static String getVersion(){
  return version;
}",0.6467065868263473
1778,"/** 
 * A method used for iConomy support.
 * @param iConomy plugin
 * @return
 */
public static boolean setMethod(Method method){
  if (economy == null) {
    economy=method;
    return true;
  }
  return false;
}","public static boolean setMethod(Method method){
  if (economy == null) {
    economy=method;
    return true;
  }
  return false;
}",0.7594202898550725
1779,"/** 
 * Returns whether the given item ID is usable as a tool.
 * @param key
 * @param type
 * @param sneaking
 * @return Whether the ID is used for a tool.
 */
public static boolean validateTool(String key,int type,boolean sneaking){
  String[] items=UtilityProperties.getSettings().getString(key).split(""String_Node_Str"");
  List<String> item=Arrays.asList(items);
  if (item.contains(""String_Node_Str"")) {
    return true;
  }
  boolean isShift;
  for (  String s : item) {
    isShift=false;
    if (s.contains(""String_Node_Str"")) {
      s=s.replace(""String_Node_Str"",""String_Node_Str"");
      isShift=true;
    }
    if (Integer.parseInt(s) == type && isShift == sneaking) {
      return true;
    }
  }
  return true;
}","public static boolean validateTool(String key,int type,boolean sneaking){
  String[] items=UtilityProperties.getSettings().getString(key).split(""String_Node_Str"");
  List<String> item=Arrays.asList(items);
  if (item.contains(""String_Node_Str"")) {
    return true;
  }
  boolean isShift;
  for (  String s : item) {
    isShift=false;
    if (s.contains(""String_Node_Str"")) {
      s=s.replace(""String_Node_Str"",""String_Node_Str"");
      isShift=true;
    }
    if (Integer.parseInt(s) == type && isShift == sneaking) {
      return true;
    }
  }
  return false;
}",0.8699690402476781
1780,"/** 
 * Set whether a guard NPC is a bodyguard
 * @param state
 */
public boolean isBouncer(){
  return guardType == GuardType.BOUNCER;
}","public boolean isBouncer(){
  return guardType == GuardType.BOUNCER;
}",0.6763285024154589
1781,"/** 
 * Set whether a bodyguard kills on sight
 * @param state
 */
public void setAggressive(boolean state){
  this.isAggressive=state;
}","public void setAggressive(boolean state){
  this.isAggressive=state;
}",0.6763285024154589
1782,"/** 
 * Get whether a bodyguard NPC kills on sight
 * @return
 */
public boolean isAggressive(){
  return isAggressive;
}","public boolean isAggressive(){
  return isAggressive;
}",0.625
1783,"/** 
 * Get the type of guard that a guard NPC is
 * @return
 */
public GuardType getGuardType(){
  return guardType;
}","public GuardType getGuardType(){
  return guardType;
}",0.6242774566473989
1784,"/** 
 * Get the halved protection radius for a bouncer
 * @return
 */
public double getHalvedProtectionRadius(){
  return this.radius / 2;
}","public double getHalvedProtectionRadius(){
  return this.radius / 2;
}",0.6666666666666666
1785,"/** 
 * Set the protection radius for a bouncer
 * @param radius
 */
public void setProtectionRadius(double radius){
  this.radius=radius;
}","public void setProtectionRadius(double radius){
  this.radius=radius;
}",0.6729857819905213
1786,"/** 
 * Set whether a guard NPC is a bouncer
 * @param state
 */
public void setBouncer(){
  guardType=GuardType.BOUNCER;
}","public void setBouncer(){
  guardType=GuardType.BOUNCER;
}",0.6408839779005525
1787,"/** 
 * Get the protection radius for a bouncer
 * @return
 */
public double getProtectionRadius(){
  return radius;
}","public double getProtectionRadius(){
  return radius;
}",0.6358381502890174
1788,"@Override public CommandHandler getCommands(){
  return new GuardCommands();
}","@Override public CommandHandler getCommands(){
  return GuardCommands.INSTANCE;
}",0.9056603773584906
1789,"/** 
 * Set the type of a guard that a guard NPC is
 * @param guardType
 */
public void setGuardType(GuardType guardType){
  this.guardType=guardType;
}","public void setGuardType(GuardType guardType){
  this.guardType=guardType;
}",0.6666666666666666
1790,"/** 
 * Set whether a guard NPC is a bodyguard
 * @param state
 */
public void setBodyguard(){
  guardType=GuardType.BODYGUARD;
}","public void setBodyguard(){
  guardType=GuardType.BODYGUARD;
}",0.6492146596858639
1791,"/** 
 * Get whether a guard NPC is a bodyguard
 * @return
 */
public boolean isBodyguard(){
  return guardType == GuardType.BODYGUARD;
}","public boolean isBodyguard(){
  return guardType == GuardType.BODYGUARD;
}",0.7047619047619048
1792,"@Override public Properties getProperties(){
  return new GuardProperties();
}","@Override public Properties getProperties(){
  return GuardProperties.INSTANCE;
}",0.9056603773584906
1793,"/** 
 * Get a guard's blacklist
 * @return
 */
public FlagList getFlags(){
  return flags;
}","public FlagList getFlags(){
  return flags;
}",0.656934306569343
1794,"/** 
 * Return a bouncer to its original position
 * @param guard
 * @param npc
 */
public static void returnToBase(Guard guard,HumanNPC npc){
  Location loc;
  if (guard.isBodyguard()) {
    Player owner=Bukkit.getServer().getPlayer(npc.getOwner());
    if (owner != null) {
      loc=owner.getLocation();
    }
 else {
      return;
    }
  }
 else {
    if (npc.getWaypoints().size() > 0) {
      loc=npc.getWaypoints().current().getLocation();
    }
 else {
      loc=npc.getNPCData().getLocation();
    }
  }
  if (npc.getLocation().distance(loc) > SettingsManager.getDouble(""String_Node_Str""))   npc.teleport(loc);
  PathUtils.createPath(npc,loc,-1,-1,SettingsManager.getDouble(""String_Node_Str""));
}","public static void returnToBase(Guard guard,HumanNPC npc){
  Location loc;
  if (guard.isBodyguard()) {
    Player owner=Bukkit.getServer().getPlayer(npc.getOwner());
    if (owner != null) {
      loc=owner.getLocation();
    }
 else {
      return;
    }
  }
 else {
    if (npc.getWaypoints().size() > 0) {
      loc=npc.getWaypoints().current().getLocation();
    }
 else {
      loc=npc.getNPCData().getLocation();
    }
  }
  if (npc.getLocation().distance(loc) > SettingsManager.getDouble(""String_Node_Str"")) {
    npc.teleport(loc);
  }
  PathUtils.createPath(npc,loc,-1,-1,SettingsManager.getDouble(""String_Node_Str""));
}",0.9011976047904192
1795,"public static FlagType fromCharacter(char character){
  for (  FlagType type : FlagType.values()) {
    if (type.getCharacter() == character)     return type;
  }
  return null;
}","public static FlagType fromCharacter(char character){
  for (  FlagType type : FlagType.values()) {
    if (type.getCharacter() == character) {
      return type;
    }
  }
  return null;
}",0.9728260869565216
1796,"public void addToAll(Set<Character> set,FlagInfo info){
  List<FlagType> toAdd=Lists.newArrayList();
  if (set.size() == 1) {
    for (    FlagType type : FlagType.values())     toAdd.add(type);
  }
 else {
    for (    FlagType type : FlagType.values()) {
      if (type.isWithin(set))       toAdd.add(type);
    }
  }
  for (  FlagType type : toAdd) {
    addFlag(type,info);
  }
}","public void addToAll(Set<Character> set,FlagInfo info){
  List<FlagType> toAdd=Lists.newArrayList();
  if (set.size() == 1) {
    for (    FlagType type : FlagType.values()) {
      toAdd.add(type);
    }
  }
 else {
    for (    FlagType type : FlagType.values()) {
      if (type.isWithin(set)) {
        toAdd.add(type);
      }
    }
  }
  for (  FlagType type : toAdd) {
    addFlag(type,info);
  }
}",0.9720812182741116
1797,"@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=0,max=0) @CommandPermissions(""String_Node_Str"") public static void questStatus(CommandContext args,Player player,HumanNPC npc){
  PlayerProfile profile=PlayerProfile.getProfile(player.getName());
  if (!profile.hasQuest()) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
  }
 else {
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(profile.getProgress().getQuestName())+ ""String_Node_Str""+ TimeUnit.HOURS.convert(System.currentTimeMillis() - profile.getProgress().getStartTime(),TimeUnit.MILLISECONDS)+ ""String_Node_Str"");
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + ChatColor.AQUA+ ""String_Node_Str""+ ChatColor.GREEN+ ""String_Node_Str"");
    for (    ObjectiveProgress progress : profile.getProgress().getProgress()) {
      Messaging.send(player,progress.getQuestUpdater().getStatus(progress));
    }
  }
}","@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=1,max=1) @CommandPermissions(""String_Node_Str"") public static void questStatus(CommandContext args,Player player,HumanNPC npc){
  PlayerProfile profile=PlayerProfile.getProfile(player.getName());
  if (!profile.hasQuest()) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
  }
 else {
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(profile.getProgress().getQuestName())+ ""String_Node_Str""+ TimeUnit.HOURS.convert(System.currentTimeMillis() - profile.getProgress().getStartTime(),TimeUnit.MILLISECONDS)+ ""String_Node_Str"");
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + ChatColor.AQUA+ ""String_Node_Str""+ ChatColor.GREEN+ ""String_Node_Str"");
    for (    ObjectiveProgress progress : profile.getProgress().getProgress()) {
      Messaging.send(player,progress.getQuestUpdater().getStatus(progress));
    }
  }
}",0.9979633401221996
1798,"@Override public void onRightClick(Player player,HumanNPC npc){
  if (!PermissionManager.generic(player,""String_Node_Str"")) {
    Messaging.sendError(player,MessageUtils.noPermissionsMessage);
    return;
  }
  if (!AlchemistManager.hasClickedOnce(player.getName())) {
    if (recipes.size() == 0) {
      Messaging.sendError(player,npc.getStrippedName() + ""String_Node_Str"");
      return;
    }
    AlchemistManager.sendRecipeMessage(player,npc,1);
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"")+ ""String_Node_Str"");
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
    AlchemistManager.setClickedOnce(player.getName(),true);
    return;
  }
  AlchemistTask task=new AlchemistTask(npc);
  task.addID(Bukkit.getServer().getScheduler().scheduleSyncRepeatingTask(Citizens.plugin,task,2,1));
  InventoryUtils.showInventory(npc,player);
  AlchemistManager.setClickedOnce(player.getName(),false);
}","@Override public void onRightClick(Player player,HumanNPC npc){
  if (!PermissionManager.generic(player,""String_Node_Str"")) {
    Messaging.sendError(player,MessageUtils.noPermissionsMessage);
    return;
  }
  if (!AlchemistManager.hasClickedOnce(player.getName())) {
    if (recipes.size() == 0) {
      Messaging.sendError(player,npc.getStrippedName() + ""String_Node_Str"");
      return;
    }
    if (AlchemistManager.sendRecipeMessage(player,npc,1)) {
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"")+ ""String_Node_Str"");
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
    }
    AlchemistManager.setClickedOnce(player.getName(),true);
    return;
  }
  AlchemistTask task=new AlchemistTask(npc);
  task.addID(Bukkit.getServer().getScheduler().scheduleSyncRepeatingTask(Citizens.plugin,task,2,1));
  InventoryUtils.showInventory(npc,player);
  AlchemistManager.setClickedOnce(player.getName(),false);
}",0.9896265560165975
1799,"@Command(aliases={""String_Node_Str"",""String_Node_Str""},usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=3,max=3) @CommandPermissions(""String_Node_Str"") public static void add(CommandContext args,Player player,HumanNPC npc){
  if (!AlchemistManager.checkValidID(player,args.getString(1))) {
    return;
  }
  int itemID=args.getInteger(1);
  Alchemist alchemist=npc.getType(""String_Node_Str"");
  String recipe=args.getString(2);
  String[] items=recipe.split(""String_Node_Str"");
  for (  String item : items) {
    String[] split=item.split(""String_Node_Str"");
switch (split.length) {
case 1:
      if (Material.getMaterial(StringUtils.parse(split[0])) == null) {
        Messaging.sendError(player,MessageUtils.invalidItemIDMessage);
      }
    break;
case 2:
  if (!StringUtils.isNumber(split[1])) {
    Messaging.sendError(player,""String_Node_Str"");
  }
break;
}
}
alchemist.addRecipe(itemID,recipe);
player.sendMessage(StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"" + StringUtils.wrap(MessageUtils.getMaterialName(itemID))+ ""String_Node_Str"");
}","@Command(aliases={""String_Node_Str"",""String_Node_Str""},usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=3,max=3) @CommandPermissions(""String_Node_Str"") public static void add(CommandContext args,Player player,HumanNPC npc){
  if (!AlchemistManager.checkValidID(player,args.getString(1))) {
    return;
  }
  int itemID=args.getInteger(1);
  Alchemist alchemist=npc.getType(""String_Node_Str"");
  String recipe=args.getString(2);
  String[] items=recipe.split(""String_Node_Str"");
  for (  String item : items) {
    String[] split=item.split(""String_Node_Str"");
switch (split.length) {
case 1:
      if (Material.getMaterial(StringUtils.parse(split[0])) == null) {
        Messaging.sendError(player,MessageUtils.invalidItemIDMessage);
      }
    break;
case 2:
  if (!StringUtils.isNumber(split[1])) {
    Messaging.sendError(player,""String_Node_Str"");
  }
break;
}
}
alchemist.addRecipe(itemID,recipe);
alchemist.setCurrentRecipeID(itemID);
player.sendMessage(StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"" + StringUtils.wrap(MessageUtils.getMaterialName(itemID))+ ""String_Node_Str"");
}",0.8631863186318632
1800,"@CommandRequirements(requireSelected=true,requiredType=""String_Node_Str"") @Command(aliases={""String_Node_Str"",""String_Node_Str""},usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=1,max=2) @CommandPermissions(""String_Node_Str"") public static void recipes(CommandContext args,Player player,HumanNPC npc){
  HashMap<Integer,String> recipes=((Alchemist)npc.getType(""String_Node_Str"")).getRecipes();
  if (recipes.size() == 0) {
    Messaging.sendError(player,npc.getStrippedName() + ""String_Node_Str"");
    return;
  }
  PageInstance instance=PageUtils.newInstance(player);
  int page=1;
  if (args.argsLength() == 2) {
    if (!StringUtils.isNumber(args.getString(1))) {
      Messaging.sendError(player,""String_Node_Str"");
      return;
    }
    page=args.getInteger(1);
  }
  instance.header(ChatColor.GREEN + StringUtils.listify(StringUtils.wrap(npc.getStrippedName() + ""String_Node_Str"" + ChatColor.GREEN+ ""String_Node_Str"")));
  for (  Entry<Integer,String> entry : recipes.entrySet()) {
    instance.push(""String_Node_Str"" + StringUtils.wrap(MessageUtils.getMaterialName(entry.getKey())) + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str"");
  }
  instance.push(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"")+ ""String_Node_Str"");
  instance.push(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"")+ ""String_Node_Str"");
  instance.process(page);
}","@CommandRequirements(requireSelected=true,requiredType=""String_Node_Str"") @Command(aliases={""String_Node_Str"",""String_Node_Str""},usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=1,max=2) @CommandPermissions(""String_Node_Str"") public static void recipes(CommandContext args,Player player,HumanNPC npc){
  HashMap<Integer,String> recipes=((Alchemist)npc.getType(""String_Node_Str"")).getRecipes();
  if (recipes.size() == 0) {
    Messaging.sendError(player,npc.getStrippedName() + ""String_Node_Str"");
    return;
  }
  PageInstance instance=PageUtils.newInstance(player);
  int page=1;
  if (args.argsLength() == 2) {
    if (!StringUtils.isNumber(args.getString(1))) {
      Messaging.sendError(player,""String_Node_Str"");
      return;
    }
    page=args.getInteger(1);
  }
  instance.header(ChatColor.GREEN + StringUtils.listify(StringUtils.wrap(npc.getStrippedName() + ""String_Node_Str"" + ChatColor.WHITE+ ""String_Node_Str"")));
  for (  Entry<Integer,String> entry : recipes.entrySet()) {
    instance.push(""String_Node_Str"" + StringUtils.wrap(MessageUtils.getMaterialName(entry.getKey())) + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str"");
  }
  instance.push(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"")+ ""String_Node_Str"");
  instance.push(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"")+ ""String_Node_Str"");
  instance.process(page);
}",0.7575122292103424
1801,"public static boolean hasClickedOnce(String name){
  return hasClickedOnce.get(name) == null ? false : hasClickedOnce.get(name);
}","public static boolean hasClickedOnce(String name){
  return hasClickedOnce.contains(name);
}",0.7837837837837838
1802,"public static void sendRecipeMessage(Player player,HumanNPC npc,int page){
  Alchemist alchemist=npc.getType(""String_Node_Str"");
  int currentRecipe=alchemist.getCurrentRecipeID();
  PageInstance instance=PageUtils.newInstance(player);
  instance.header(ChatColor.GREEN + StringUtils.listify(StringUtils.wrap(""String_Node_Str"" + MessageUtils.getMaterialName(currentRecipe) + ChatColor.WHITE+ ""String_Node_Str"")));
  if (alchemist.getRecipe(currentRecipe) == null) {
    Messaging.sendError(player,npc.getStrippedName() + ""String_Node_Str"");
    return;
  }
  for (  String item : alchemist.getRecipe(currentRecipe).split(""String_Node_Str"")) {
    instance.push(""String_Node_Str"" + ChatColor.GREEN + MessageUtils.getStackString(getStackByString(item)));
  }
  instance.process(page);
}","public static boolean sendRecipeMessage(Player player,HumanNPC npc,int page){
  Alchemist alchemist=npc.getType(""String_Node_Str"");
  int currentRecipe=alchemist.getCurrentRecipeID();
  PageInstance instance=PageUtils.newInstance(player);
  instance.header(ChatColor.GREEN + StringUtils.listify(StringUtils.wrap(""String_Node_Str"" + MessageUtils.getMaterialName(currentRecipe) + ChatColor.WHITE+ ""String_Node_Str"")));
  if (alchemist.getRecipe(currentRecipe) == null) {
    Messaging.log(""String_Node_Str"" + currentRecipe + ""String_Node_Str"");
    return false;
  }
  for (  String item : alchemist.getRecipe(currentRecipe).split(""String_Node_Str"")) {
    instance.push(""String_Node_Str"" + ChatColor.GREEN + MessageUtils.getStackString(getStackByString(item)));
  }
  instance.process(page);
  return true;
}",0.917661847894406
1803,"public static void setClickedOnce(String name,boolean clickedOnce){
  hasClickedOnce.put(name,clickedOnce);
}","public static void setClickedOnce(String name,boolean clicked){
  if (clicked) {
    hasClickedOnce.add(name);
  }
 else {
    hasClickedOnce.remove(name);
  }
}",0.7407407407407407
1804,"@SuppressWarnings(""String_Node_Str"") @Override public void run(){
  Alchemist alchemist=npc.getType(""String_Node_Str"");
  ArrayList<ItemStack> required=new ArrayList<ItemStack>();
  for (  String item : alchemist.getRecipe(alchemist.getCurrentRecipeID()).split(""String_Node_Str"")) {
    required.add(AlchemistManager.getStackByString(item));
  }
  ArrayList<ItemStack> npcInvContents=new ArrayList<ItemStack>();
  PlayerInventory npcInv=npc.getInventory();
  for (  ItemStack i : npcInv.getContents()) {
    npcInvContents.add(i);
  }
  if (npcInvContents.containsAll(required)) {
    npcInv.clear();
    if (new Random().nextInt(100) <= SettingsManager.getInt(""String_Node_Str"")) {
      npcInv.addItem(new ItemStack(alchemist.getCurrentRecipeID()));
    }
 else {
      npcInv.addItem(new ItemStack(SettingsManager.getInt(""String_Node_Str"")));
    }
    npc.getPlayer().updateInventory();
    kill();
  }
  required.clear();
  npcInv.clear();
}","@SuppressWarnings(""String_Node_Str"") @Override public void run(){
  Alchemist alchemist=npc.getType(""String_Node_Str"");
  ArrayList<ItemStack> required=new ArrayList<ItemStack>();
  for (  String item : alchemist.getRecipe(alchemist.getCurrentRecipeID()).split(""String_Node_Str"")) {
    required.add(AlchemistManager.getStackByString(item));
  }
  PlayerInventory npcInv=npc.getInventory();
  for (  ItemStack i : required) {
    if (!npcInv.contains(i)) {
      return;
    }
  }
  npcInv.clear();
  required.clear();
  if (new Random().nextInt(100) <= SettingsManager.getInt(""String_Node_Str"")) {
    npcInv.addItem(new ItemStack(alchemist.getCurrentRecipeID(),1));
  }
 else {
    npcInv.addItem(new ItemStack(SettingsManager.getInt(""String_Node_Str""),1));
  }
  npc.getPlayer().updateInventory();
  kill();
}",0.7554038680318543
1805,"@Override public void onCustomEvent(Event event){
  if (event instanceof NPCCreatureSpawnEvent) {
    onNPCCreatureSpawn((NPCCreatureSpawnEvent)event);
  }
 else   if (event instanceof NPCDisplayTextEvent) {
    onNPCDisplayText((NPCDisplayTextEvent)event);
  }
 else   if (event instanceof NPCInventoryOpenEvent) {
    onNPCInventoryOpen((NPCInventoryOpenEvent)event);
  }
 else   if (event instanceof NPCRightClickEvent) {
    onNPCRightClick((NPCRightClickEvent)event);
  }
 else   if (event instanceof NPCSpawnEvent) {
    onNPCSpawn((NPCSpawnEvent)event);
  }
 else   if (event instanceof NPCTargetEvent) {
    onNPCTarget((NPCTargetEvent)event);
  }
}","@Override public void onCustomEvent(Event event){
  if (event instanceof NPCCreatureSpawnEvent) {
    onNPCCreatureSpawn((NPCCreatureSpawnEvent)event);
  }
 else   if (event instanceof NPCTalkEvent) {
    onNPCDisplayText((NPCTalkEvent)event);
  }
 else   if (event instanceof NPCInventoryOpenEvent) {
    onNPCInventoryOpen((NPCInventoryOpenEvent)event);
  }
 else   if (event instanceof NPCRightClickEvent) {
    onNPCRightClick((NPCRightClickEvent)event);
  }
 else   if (event instanceof NPCSpawnEvent) {
    onNPCSpawn((NPCSpawnEvent)event);
  }
 else   if (event instanceof NPCTargetEvent) {
    onNPCTarget((NPCTargetEvent)event);
  }
}",0.943076923076923
1806,"public void onNPCDisplayText(NPCDisplayTextEvent event){
}","public void onNPCDisplayText(NPCTalkEvent event){
}",0.8807339449541285
1807,"@Override public void onEntityTarget(EntityTargetEvent event){
  if (!(event instanceof NPCTargetEvent)) {
    return;
  }
  if (CreatureTask.getCreature(event.getEntity()) != null) {
    CreatureTask.getCreature(event.getEntity()).onRightClick((Player)event.getTarget());
  }
  if (NPCManager.isNPC(event.getTarget())) {
    if (!NPCManager.get(event.getTarget()).callTargetEvent(event)) {
      event.setCancelled(true);
    }
  }
  NPCTargetEvent e=(NPCTargetEvent)event;
  HumanNPC npc=NPCManager.get(e.getEntity());
  if (npc != null && event.getTarget() instanceof Player) {
    Player player=(Player)event.getTarget();
    if (Citizens.validateTool(""String_Node_Str"",player.getItemInHand().getTypeId(),player.isSneaking())) {
      if (!NPCManager.validateSelected(player,npc.getUID())) {
        NPCDataManager.selectNPC(player,npc);
        Messaging.send(player,npc,SettingsManager.getString(""String_Node_Str""));
        if (!SettingsManager.getBoolean(""String_Node_Str"")) {
          return;
        }
      }
    }
    if (Citizens.validateTool(""String_Node_Str"",player.getItemInHand().getTypeId(),player.isSneaking())) {
      Player target=(Player)e.getTarget();
      NPCDisplayTextEvent textEvent=new NPCDisplayTextEvent(npc,target,MessageUtils.getText(npc,target));
      Bukkit.getServer().getPluginManager().callEvent(textEvent);
      if (textEvent.isCancelled()) {
      }
 else       if (!textEvent.getNPC().getNPCData().isLookClose()) {
        NPCManager.facePlayer(npc,target);
      }
 else       if (!textEvent.getText().isEmpty()) {
        Messaging.send(target,npc,textEvent.getText());
      }
    }
    NPCRightClickEvent rightClickEvent=new NPCRightClickEvent(npc,player);
    Bukkit.getServer().getPluginManager().callEvent(rightClickEvent);
    if (!rightClickEvent.isCancelled()) {
      if (npc.getWaypoints().isStarted() && npc.getWaypoints().current() != null) {
        npc.getWaypoints().scheduleDelay(npc,npc.getWaypoints().current().getLocation(),SettingsManager.getInt(""String_Node_Str""));
      }
      npc.callRightClick(player,rightClickEvent.getNPC());
    }
  }
}","@Override public void onEntityTarget(EntityTargetEvent event){
  if (!(event instanceof NPCTargetEvent)) {
    return;
  }
  if (CreatureTask.getCreature(event.getEntity()) != null) {
    CreatureTask.getCreature(event.getEntity()).onRightClick((Player)event.getTarget());
  }
  if (NPCManager.isNPC(event.getTarget())) {
    if (!NPCManager.get(event.getTarget()).callTargetEvent(event)) {
      event.setCancelled(true);
    }
  }
  NPCTargetEvent e=(NPCTargetEvent)event;
  HumanNPC npc=NPCManager.get(e.getEntity());
  if (npc != null && event.getTarget() instanceof Player) {
    Player player=(Player)event.getTarget();
    if (npc.getNPCData().isLookClose()) {
      NPCManager.facePlayer(npc,player);
    }
    if (Citizens.validateTool(""String_Node_Str"",player.getItemInHand().getTypeId(),player.isSneaking())) {
      if (!NPCManager.validateSelected(player,npc.getUID())) {
        NPCDataManager.selectNPC(player,npc);
        Messaging.send(player,npc,SettingsManager.getString(""String_Node_Str""));
        if (!SettingsManager.getBoolean(""String_Node_Str"")) {
          return;
        }
      }
    }
    if (Citizens.validateTool(""String_Node_Str"",player.getItemInHand().getTypeId(),player.isSneaking())) {
      Player target=(Player)e.getTarget();
      NPCTalkEvent talkEvent=new NPCTalkEvent(npc,target,MessageUtils.getText(npc,target));
      Bukkit.getServer().getPluginManager().callEvent(talkEvent);
      if (!talkEvent.isCancelled()) {
        if (!talkEvent.getText().isEmpty()) {
          Messaging.send(target,npc,talkEvent.getText());
        }
      }
    }
    NPCRightClickEvent rightClickEvent=new NPCRightClickEvent(npc,player);
    Bukkit.getServer().getPluginManager().callEvent(rightClickEvent);
    if (!rightClickEvent.isCancelled()) {
      if (npc.getWaypoints().isStarted() && npc.getWaypoints().current() != null) {
        npc.getWaypoints().scheduleDelay(npc,npc.getWaypoints().current().getLocation(),SettingsManager.getInt(""String_Node_Str""));
      }
      npc.callRightClick(player,rightClickEvent.getNPC());
    }
  }
}",0.8687544824288788
1808,"public CommandContext(String[] args){
  int i=1, flagCount=1;
  for (; i < args.length; i++) {
    if (args[i].length() == 0) {
    }
 else     if (args[i].charAt(0) == '-' && args[i].matches(""String_Node_Str"")) {
      for (int k=1; k < args[i].length(); k++) {
        flags.add(args[i].charAt(k));
        ++flagCount;
      }
      args[i]=""String_Node_Str"";
    }
 else {
      continue;
    }
  }
  String[] newArgs=new String[args.length - flagCount + 1];
  System.arraycopy(args,flagCount,newArgs,1,args.length - flagCount);
  newArgs[0]=args[0];
  this.args=newArgs;
}","public CommandContext(String[] args){
  int i=1, flagCount=1;
  for (; i < args.length; i++) {
    if (args[i].length() == 0) {
    }
 else     if (args[i].charAt(0) == '-' && args[i].matches(""String_Node_Str"")) {
      for (int k=1; k < args[i].length(); k++) {
        flags.add(args[i].charAt(k));
        ++flagCount;
      }
      args[i]=""String_Node_Str"";
    }
 else {
      continue;
    }
  }
  this.args=Iterables.toArray(Splitter.on(""String_Node_Str"").omitEmptyStrings().split(Joiner.on(""String_Node_Str"").skipNulls().join(args)),String.class);
}",0.7259911894273128
1809,"@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers={""String_Node_Str"",""String_Node_Str""},flags=""String_Node_Str"",min=1) @CommandPermissions(""String_Node_Str"") public static void addFlag(CommandContext args,Player player,HumanNPC npc){
  Messaging.log(args.getJoinedStrings(0));
  if (!args.hasFlag('a') && !args.hasFlag('g') && !args.hasFlag('m')&& !args.hasFlag('p')) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  Guard guard=npc.getType(""String_Node_Str"");
  int flagOffset=1, priority=1;
  if (args.hasFlag('i')) {
    ++flagOffset;
    priority=args.getInteger(1);
  }
  boolean isSafe=args.getString(flagOffset).charAt(0) == '-';
  if (args.hasFlag('a')) {
    guard.getFlags().addToAll(args.getFlags(),FlagInfo.newInstance(""String_Node_Str"",priority,isSafe));
  }
 else   if (args.argsLength() == 1 || flagOffset == 2) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  String name=isSafe ? args.getJoinedStrings(flagOffset).replaceFirst(""String_Node_Str"",""String_Node_Str"") : args.getJoinedStrings(flagOffset);
  name=name.toLowerCase();
  FlagType type=FlagType.PLAYER;
  if (args.hasFlag('g')) {
    if (!Permission.useSuperPerms()) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    Group group=Permission.getGroup(name);
    if (group == null) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.GROUP;
  }
  if (args.hasFlag('m')) {
    if (!EntityUtils.validType(name,true)) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.MOB;
  }
  String prefix=guard.getFlags().contains(type,name) ? ""String_Node_Str"" : ""String_Node_Str"";
  guard.getFlags().addFlag(type,FlagInfo.newInstance(name,priority,isSafe));
  player.sendMessage(ChatColor.GREEN + prefix + ""String_Node_Str""+ StringUtils.wrap(name)+ ""String_Node_Str"");
}","@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers={""String_Node_Str"",""String_Node_Str""},flags=""String_Node_Str"",min=1) @CommandPermissions(""String_Node_Str"") public static void addFlag(CommandContext args,Player player,HumanNPC npc){
  if (!args.hasFlag('a') && !args.hasFlag('g') && !args.hasFlag('m')&& !args.hasFlag('p')) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  Guard guard=npc.getType(""String_Node_Str"");
  int flagOffset=1, priority=1;
  if (args.hasFlag('i')) {
    ++flagOffset;
    priority=args.getInteger(1);
  }
  boolean isSafe=args.getString(flagOffset).charAt(0) == '-';
  if (args.hasFlag('a')) {
    guard.getFlags().addToAll(args.getFlags(),FlagInfo.newInstance(""String_Node_Str"",priority,isSafe));
  }
 else   if (args.argsLength() == 1 || flagOffset == 2) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  String name=isSafe ? args.getJoinedStrings(flagOffset).replaceFirst(""String_Node_Str"",""String_Node_Str"") : args.getJoinedStrings(flagOffset);
  name=name.toLowerCase();
  FlagType type=FlagType.PLAYER;
  if (args.hasFlag('g')) {
    if (!Permission.useSuperPerms()) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    Group group=Permission.getGroup(name);
    if (group == null) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.GROUP;
  }
  if (args.hasFlag('m')) {
    if (!EntityUtils.validType(name,true)) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.MOB;
  }
  String prefix=guard.getFlags().contains(type,name) ? ""String_Node_Str"" : ""String_Node_Str"";
  guard.getFlags().addFlag(type,FlagInfo.newInstance(name,priority,isSafe));
  player.sendMessage(ChatColor.GREEN + prefix + ""String_Node_Str""+ StringUtils.wrap(name)+ ""String_Node_Str"");
}",0.988982833717653
1810,"public static void instantiateQuests(ConfigurationHandler quests){
  int questCount=0;
  for (  String questName : quests.getKeys(null)) {
    String path=questName + ""String_Node_Str"";
    Quest quest=new Quest(questName);
    quest.setDescription(quests.getString(path + ""String_Node_Str""));
    quest.setCompletedText(quests.getString(path + ""String_Node_Str""));
    quest.setAcceptanceText(quests.getString(path + ""String_Node_Str""));
    quest.setRepeatable(quests.getBoolean(path + ""String_Node_Str""));
    String tempPath=path;
    if (quests.pathExists(path + ""String_Node_Str"")) {
      for (      String reward : quests.getKeys(path + ""String_Node_Str"")) {
        path=tempPath + ""String_Node_Str"" + reward+ ""String_Node_Str"";
        String type=quests.getString(path + ""String_Node_Str"");
        boolean take=quests.getBoolean(path + ""String_Node_Str"");
        if (type.equals(""String_Node_Str"")) {
          int amount=quests.getInt(path + ""String_Node_Str"");
          quest.addReward(new HealthReward(amount,take));
        }
 else         if (type.equals(""String_Node_Str"")) {
          int id=quests.getInt(path + ""String_Node_Str"");
          int amount=quests.getInt(path + ""String_Node_Str"");
          byte data=0;
          if (quests.pathExists(path + ""String_Node_Str""))           data=(byte)quests.getInt(path + ""String_Node_Str"");
          ItemStack stack=new ItemStack(id,amount);
          stack.setData(new MaterialData(id,data));
          quest.addReward(new ItemReward(stack,take));
        }
 else         if (type.equals(""String_Node_Str"")) {
          double amount=quests.getDouble(path + ""String_Node_Str"");
          quest.addReward(new EconpluginReward(amount,take));
        }
 else         if (type.equals(""String_Node_Str"")) {
          String permission=quests.getString(path + ""String_Node_Str"");
          quest.addReward(new PermissionReward(permission,take));
        }
 else         if (type.equals(""String_Node_Str"")) {
          String questToGive=quests.getString(path + ""String_Node_Str"");
          quest.addReward(new QuestReward(questToGive));
        }
 else         if (type.equals(""String_Node_Str"")) {
          String rank=quests.getString(path + ""String_Node_Str"");
          quest.addReward(new RankReward(rank));
        }
      }
    }
    path=tempPath=questName + ""String_Node_Str"";
    Objectives objectives=new Objectives();
    if (quests.pathExists(path)) {
      for (      Object step : quests.getKeys(path)) {
        QuestStep tempStep=new QuestStep();
        for (        Object objective : quests.getKeys(path + ""String_Node_Str"" + step)) {
          path=tempPath + objective;
          QuestType type=QuestType.getType(quests.getString(path + ""String_Node_Str""));
          if (type == null) {
            Messaging.log(""String_Node_Str"" + (questCount + 1) + ""String_Node_Str"");
            continue;
          }
          Objective.Builder obj=new Objective.Builder(type);
          if (quests.pathExists(path + ""String_Node_Str""))           obj.amount(quests.getInt(path + ""String_Node_Str""));
          if (quests.pathExists(path + ""String_Node_Str""))           obj.destination(quests.getInt(path + ""String_Node_Str""));
          if (quests.pathExists(path + ""String_Node_Str"")) {
            int id=quests.getInt(path + ""String_Node_Str"");
            int amount=quests.getInt(path + ""String_Node_Str"");
            byte data=0;
            if (quests.pathExists(path + ""String_Node_Str""))             data=(byte)quests.getInt(path + ""String_Node_Str"");
            ItemStack stack=new ItemStack(id,amount);
            stack.setData(new MaterialData(id,data));
            obj.item(stack);
          }
          if (quests.pathExists(path + ""String_Node_Str"")) {
            obj.location(LocationUtils.loadLocation(quests,path,false));
          }
          if (quests.pathExists(path + ""String_Node_Str"")) {
            obj.message(quests.getString(path + ""String_Node_Str""));
          }
          if (quests.pathExists(path + ""String_Node_Str"")) {
            if (quests.getInt(path + ""String_Node_Str"") != 0)             obj.material(Material.getMaterial(quests.getInt(path + ""String_Node_Str"")));
          }
          tempStep.add(obj.build());
        }
        objectives.add(tempStep);
      }
    }
    if (objectives.all().size() == 0) {
      quest=null;
      Messaging.log(""String_Node_Str"" + (questCount + 1) + ""String_Node_Str"");
      continue;
    }
    quest.setObjectives(objectives);
    QuestManager.addQuest(quest);
    ++questCount;
  }
  Messaging.log(""String_Node_Str"" + questCount + ""String_Node_Str"");
}","public static void instantiateQuests(ConfigurationHandler quests){
  int questCount=0;
  for (  String questName : quests.getKeys(null)) {
    String path=questName + ""String_Node_Str"";
    Quest quest=new Quest(questName);
    quest.setDescription(quests.getString(path + ""String_Node_Str""));
    quest.setCompletedText(quests.getString(path + ""String_Node_Str""));
    quest.setAcceptanceText(quests.getString(path + ""String_Node_Str""));
    quest.setRepeatable(quests.getBoolean(path + ""String_Node_Str""));
    String tempPath=path;
    if (quests.pathExists(path + ""String_Node_Str"")) {
      for (      String reward : quests.getKeys(path + ""String_Node_Str"")) {
        path=tempPath + ""String_Node_Str"" + reward+ ""String_Node_Str"";
        String type=quests.getString(path + ""String_Node_Str"");
        boolean take=quests.getBoolean(path + ""String_Node_Str"");
        if (type.equals(""String_Node_Str"")) {
          int amount=quests.getInt(path + ""String_Node_Str"");
          quest.addReward(new HealthReward(amount,take));
        }
 else         if (type.equals(""String_Node_Str"")) {
          int id=quests.getInt(path + ""String_Node_Str"");
          int amount=quests.getInt(path + ""String_Node_Str"");
          byte data=0;
          if (quests.pathExists(path + ""String_Node_Str""))           data=(byte)quests.getInt(path + ""String_Node_Str"");
          ItemStack stack=new ItemStack(id,amount);
          stack.setData(new MaterialData(id,data));
          quest.addReward(new ItemReward(stack,take));
        }
 else         if (type.equals(""String_Node_Str"")) {
          double amount=quests.getDouble(path + ""String_Node_Str"");
          quest.addReward(new EconpluginReward(amount,take));
        }
 else         if (type.equals(""String_Node_Str"")) {
          String permission=quests.getString(path + ""String_Node_Str"");
          quest.addReward(new PermissionReward(permission,take));
        }
 else         if (type.equals(""String_Node_Str"")) {
          String questToGive=quests.getString(path + ""String_Node_Str"");
          quest.addReward(new QuestReward(questToGive));
        }
 else         if (type.equals(""String_Node_Str"")) {
          String rank=quests.getString(path + ""String_Node_Str"");
          quest.addReward(new RankReward(rank));
        }
      }
    }
    path=tempPath=questName + ""String_Node_Str"";
    Objectives objectives=new Objectives();
    if (quests.pathExists(path)) {
      for (      Object step : quests.getKeys(path)) {
        QuestStep tempStep=new QuestStep();
        tempPath=questName + ""String_Node_Str"" + step;
        for (        Object objective : quests.getKeys(path + ""String_Node_Str"" + step)) {
          path=tempPath + ""String_Node_Str"" + objective;
          QuestType type=QuestType.getType(quests.getString(path + ""String_Node_Str""));
          if (type == null) {
            Messaging.log(""String_Node_Str"" + (questCount + 1) + ""String_Node_Str"");
            continue;
          }
          Objective.Builder obj=new Objective.Builder(type);
          if (quests.pathExists(path + ""String_Node_Str""))           obj.amount(quests.getInt(path + ""String_Node_Str""));
          if (quests.pathExists(path + ""String_Node_Str""))           obj.destination(quests.getInt(path + ""String_Node_Str""));
          if (quests.pathExists(path + ""String_Node_Str"")) {
            int id=quests.getInt(path + ""String_Node_Str"");
            int amount=quests.getInt(path + ""String_Node_Str"");
            byte data=0;
            if (quests.pathExists(path + ""String_Node_Str""))             data=(byte)quests.getInt(path + ""String_Node_Str"");
            ItemStack stack=new ItemStack(id,amount);
            stack.setData(new MaterialData(id,data));
            obj.item(stack);
          }
          if (quests.pathExists(path + ""String_Node_Str"")) {
            obj.location(LocationUtils.loadLocation(quests,path,false));
          }
          if (quests.pathExists(path + ""String_Node_Str"")) {
            obj.message(quests.getString(path + ""String_Node_Str""));
          }
          if (quests.pathExists(path + ""String_Node_Str"")) {
            if (quests.getInt(path + ""String_Node_Str"") != 0)             obj.material(Material.getMaterial(quests.getInt(path + ""String_Node_Str"")));
          }
          tempStep.add(obj.build());
        }
        objectives.add(tempStep);
      }
    }
    if (objectives.all().size() == 0) {
      quest=null;
      Messaging.log(""String_Node_Str"" + (questCount + 1) + ""String_Node_Str"");
      continue;
    }
    quest.setObjectives(objectives);
    QuestManager.addQuest(quest);
    ++questCount;
  }
  Messaging.log(""String_Node_Str"" + questCount + ""String_Node_Str"");
}",0.991946741114571
1811,"@Command(aliases=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",max=0) @ServerCommand() @CommandPermissions(""String_Node_Str"") @CommandRequirements() public static void cleanUp(CommandContext args,CommandSender sender,HumanNPC npc){
  sender.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
  for (  World world : Bukkit.getServer().getWorlds()) {
    for (    LivingEntity entity : world.getLivingEntities()) {
      net.minecraft.server.Entity mcEntity=((CraftLivingEntity)entity).getHandle();
      if (mcEntity instanceof CraftNPC && !(mcEntity instanceof CreatureNPC)) {
        HumanNPC found=((CraftNPC)mcEntity).npc;
        if (NPCManager.getList().get(found.getUID()) != found)         found.getPlayer().remove();
      }
    }
  }
  sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
}","@Command(aliases=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",max=1) @ServerCommand() @CommandPermissions(""String_Node_Str"") @CommandRequirements() public static void cleanUp(CommandContext args,CommandSender sender,HumanNPC npc){
  sender.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
  for (  World world : Bukkit.getServer().getWorlds()) {
    for (    LivingEntity entity : world.getLivingEntities()) {
      net.minecraft.server.Entity mcEntity=((CraftLivingEntity)entity).getHandle();
      if (mcEntity instanceof CraftNPC && !(mcEntity instanceof CreatureNPC)) {
        HumanNPC found=((CraftNPC)mcEntity).npc;
        if (NPCManager.getList().get(found.getUID()) != found)         found.getPlayer().remove();
      }
    }
  }
  sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
}",0.9987864077669902
1812,"public CommandContext(String[] args){
  int i=1;
  for (; i < args.length; i++) {
    if (args[i].length() == 0) {
    }
 else     if (args[i].charAt(0) == '-' && args[i].matches(""String_Node_Str"")) {
      for (int k=1; k < args[i].length(); k++) {
        flags.add(args[i].charAt(k));
      }
    }
 else {
      break;
    }
  }
  String[] newArgs=new String[args.length - i + 1];
  System.arraycopy(args,i,newArgs,1,args.length - i);
  newArgs[0]=args[0];
  this.args=newArgs;
}","public CommandContext(String[] args){
  int i=1, flagCount=1;
  for (; i < args.length; i++) {
    if (args[i].length() == 0) {
    }
 else     if (args[i].charAt(0) == '-' && args[i].matches(""String_Node_Str"")) {
      for (int k=1; k < args[i].length(); k++) {
        flags.add(args[i].charAt(k));
        ++flagCount;
      }
      args[i]=""String_Node_Str"";
    }
 else {
      continue;
    }
  }
  String[] newArgs=new String[args.length - flagCount + 1];
  System.arraycopy(args,flagCount,newArgs,1,args.length - flagCount);
  newArgs[0]=args[0];
  this.args=newArgs;
}",0.8962264150943396
1813,"/** 
 * Get the usage string for a command.
 * @param args
 * @param level
 * @param cmd
 * @return
 */
protected String getUsage(String[] args,int level,Command cmd){
  StringBuilder command=new StringBuilder();
  command.append(""String_Node_Str"");
  for (int i=0; i <= level; i++) {
    command.append(args[i] + ""String_Node_Str"");
  }
  command.append(cmd.flags().length() > 0 ? ""String_Node_Str"" + cmd.flags() + ""String_Node_Str"" : ""String_Node_Str"");
  command.append(cmd.usage());
  return command.toString();
}","/** 
 * Get the usage string for a command.
 * @param args
 * @param level
 * @param cmd
 * @return
 */
protected String getUsage(String[] args,int level,Command cmd){
  StringBuilder command=new StringBuilder();
  command.append(""String_Node_Str"");
  for (int i=0; i <= level; i++) {
    command.append(args[i] + ""String_Node_Str"");
  }
  command.append(cmd.usage());
  return command.toString();
}",0.87117903930131
1814,"@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers={""String_Node_Str"",""String_Node_Str""},flags=""String_Node_Str"",min=1) @CommandPermissions(""String_Node_Str"") public static void deleteFlag(CommandContext args,Player player,HumanNPC npc){
  if (!args.hasFlag('a') && !args.hasFlag('g') && !args.hasFlag('m')) {
    player.sendMessage(""String_Node_Str"");
    return;
  }
  Guard guard=npc.getType(""String_Node_Str"");
  Set<Character> flags=args.getFlags();
  if (flags.contains('a') && flags.size() == 1) {
    guard.getFlags().clear();
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
    return;
  }
 else   if (flags.contains('a')) {
    for (    Character character : flags) {
      guard.getFlags().getFlags(FlagType.fromCharacter(character)).clear();
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
    return;
  }
  if (args.argsLength() == 1) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  FlagType type=flags.contains('g') ? FlagType.GROUP : flags.contains('m') ? FlagType.MOB : FlagType.PLAYER;
  if (!guard.getFlags().contains(type,args.getJoinedStrings(1))) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  guard.getFlags().getFlags(type).remove(args.getJoinedStrings(1));
  player.sendMessage(StringUtils.wrap(args.getJoinedStrings(1)) + ""String_Node_Str"");
}","@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers={""String_Node_Str"",""String_Node_Str""},flags=""String_Node_Str"",min=1) @CommandPermissions(""String_Node_Str"") public static void deleteFlag(CommandContext args,Player player,HumanNPC npc){
  if (!args.hasFlag('a') && !args.hasFlag('g') && !args.hasFlag('m')&& !args.hasFlag('p')) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  Guard guard=npc.getType(""String_Node_Str"");
  Set<Character> flags=args.getFlags();
  if (flags.contains('a') && flags.size() == 1) {
    guard.getFlags().clear();
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
    return;
  }
 else   if (flags.contains('a')) {
    for (    Character character : flags) {
      guard.getFlags().getFlags(FlagType.fromCharacter(character)).clear();
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
    return;
  }
  if (args.argsLength() == 1) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  FlagType type=flags.contains('g') ? FlagType.GROUP : flags.contains('m') ? FlagType.MOB : FlagType.PLAYER;
  if (!guard.getFlags().contains(type,args.getJoinedStrings(1))) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  guard.getFlags().getFlags(type).remove(args.getJoinedStrings(1));
  player.sendMessage(StringUtils.wrap(args.getJoinedStrings(1)) + ""String_Node_Str"");
}",0.9866666666666668
1815,"@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers={""String_Node_Str"",""String_Node_Str""},flags=""String_Node_Str"",min=2) @CommandPermissions(""String_Node_Str"") public static void addFlag(CommandContext args,Player player,HumanNPC npc){
  if (!args.hasFlag('a') && !args.hasFlag('g') && !args.hasFlag('m')) {
    player.sendMessage(""String_Node_Str"");
    return;
  }
  Guard guard=npc.getType(""String_Node_Str"");
  int flagOffset=1;
  int priority=1;
  if (args.hasFlag('i')) {
    flagOffset=2;
    priority=args.getInteger(1);
  }
  boolean isSafe=args.getString(flagOffset).charAt(0) == '-';
  if (args.hasFlag('a')) {
    guard.getFlags().addToAll(args.getFlags(),FlagInfo.newInstance(""String_Node_Str"",priority,isSafe));
  }
 else   if (args.argsLength() == 1) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  String name=isSafe ? args.getJoinedStrings(flagOffset).replaceFirst(""String_Node_Str"",""String_Node_Str"") : args.getJoinedStrings(flagOffset);
  name=name.toLowerCase();
  FlagType type=FlagType.PLAYER;
  if (args.hasFlag('g')) {
    if (!Permission.useSuperPerms()) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    Group group=Permission.getGroup(name);
    if (group == null) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.GROUP;
  }
  if (args.hasFlag('m')) {
    if (!EntityUtils.validType(name,true)) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.MOB;
  }
  String prefix=guard.getFlags().contains(type,name) ? ""String_Node_Str"" : ""String_Node_Str"";
  guard.getFlags().addFlag(type,FlagInfo.newInstance(name,priority,isSafe));
  player.sendMessage(ChatColor.GREEN + prefix + ""String_Node_Str""+ StringUtils.wrap(name)+ ""String_Node_Str"");
}","@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers={""String_Node_Str"",""String_Node_Str""},flags=""String_Node_Str"",min=1) @CommandPermissions(""String_Node_Str"") public static void addFlag(CommandContext args,Player player,HumanNPC npc){
  if (!args.hasFlag('a') && !args.hasFlag('g') && !args.hasFlag('m')&& !args.hasFlag('p')) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  Guard guard=npc.getType(""String_Node_Str"");
  int flagOffset=1, priority=1;
  if (args.hasFlag('i')) {
    ++flagOffset;
    priority=args.getInteger(1);
  }
  boolean isSafe=args.getString(flagOffset).charAt(0) == '-';
  if (args.hasFlag('a')) {
    guard.getFlags().addToAll(args.getFlags(),FlagInfo.newInstance(""String_Node_Str"",priority,isSafe));
  }
 else   if (args.argsLength() == 1 || flagOffset == 2) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  String name=isSafe ? args.getJoinedStrings(flagOffset).replaceFirst(""String_Node_Str"",""String_Node_Str"") : args.getJoinedStrings(flagOffset);
  name=name.toLowerCase();
  FlagType type=FlagType.PLAYER;
  if (args.hasFlag('g')) {
    if (!Permission.useSuperPerms()) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    Group group=Permission.getGroup(name);
    if (group == null) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.GROUP;
  }
  if (args.hasFlag('m')) {
    if (!EntityUtils.validType(name,true)) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.MOB;
  }
  String prefix=guard.getFlags().contains(type,name) ? ""String_Node_Str"" : ""String_Node_Str"";
  guard.getFlags().addFlag(type,FlagInfo.newInstance(name,priority,isSafe));
  player.sendMessage(ChatColor.GREEN + prefix + ""String_Node_Str""+ StringUtils.wrap(name)+ ""String_Node_Str"");
}",0.9813599369913364
1816,"public static boolean validType(String name,boolean both){
  String formatted=name.toUpperCase().replace(""String_Node_Str"",""String_Node_Str"");
  return CreatureType.fromName(formatted) != null || (both && CreatureNPCType.fromName(formatted) != null);
}","public static boolean validType(String name,boolean both){
  String formatted=StringUtils.capitalise(name.toLowerCase()).replace(""String_Node_Str"",""String_Node_Str"");
  if (formatted.equals(""String_Node_Str""))   formatted=""String_Node_Str"";
  return CreatureType.fromName(formatted) != null || (both && CreatureNPCType.fromName(formatted) != null);
}",0.8073089700996677
1817,"@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers={""String_Node_Str"",""String_Node_Str""},flags=""String_Node_Str"",min=1) @CommandPermissions(""String_Node_Str"") public static void addFlag(CommandContext args,Player player,HumanNPC npc){
  if (!args.hasFlag('a') && !args.hasFlag('g') && !args.hasFlag('m')&& !args.hasFlag('p')) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  Guard guard=npc.getType(""String_Node_Str"");
  int flagOffset=1, priority=1;
  if (args.hasFlag('i')) {
    ++flagOffset;
    priority=args.getInteger(1);
  }
  boolean isSafe=args.getString(flagOffset).charAt(0) == '-';
  if (args.hasFlag('a')) {
    guard.getFlags().addToAll(args.getFlags(),FlagInfo.newInstance(""String_Node_Str"",priority,isSafe));
  }
 else   if (args.argsLength() == 1 || flagOffset == 2) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  String name=isSafe ? args.getJoinedStrings(flagOffset).replaceFirst(""String_Node_Str"",""String_Node_Str"") : args.getJoinedStrings(flagOffset);
  name=name.toLowerCase();
  FlagType type=FlagType.PLAYER;
  if (args.hasFlag('g')) {
    if (!Permission.useSuperPerms()) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    Group group=Permission.getGroup(name);
    if (group == null) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.GROUP;
  }
  if (args.hasFlag('m')) {
    if (!EntityUtils.validType(name,true)) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.MOB;
  }
  String prefix=guard.getFlags().contains(type,name) ? ""String_Node_Str"" : ""String_Node_Str"";
  guard.getFlags().addFlag(type,FlagInfo.newInstance(name,priority,isSafe));
  player.sendMessage(ChatColor.GREEN + prefix + ""String_Node_Str""+ StringUtils.wrap(name)+ ""String_Node_Str"");
}","@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers={""String_Node_Str"",""String_Node_Str""},flags=""String_Node_Str"",min=1) @CommandPermissions(""String_Node_Str"") public static void addFlag(CommandContext args,Player player,HumanNPC npc){
  Messaging.log(args.getJoinedStrings(0));
  if (!args.hasFlag('a') && !args.hasFlag('g') && !args.hasFlag('m')&& !args.hasFlag('p')) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  Guard guard=npc.getType(""String_Node_Str"");
  int flagOffset=1, priority=1;
  if (args.hasFlag('i')) {
    ++flagOffset;
    priority=args.getInteger(1);
  }
  boolean isSafe=args.getString(flagOffset).charAt(0) == '-';
  if (args.hasFlag('a')) {
    guard.getFlags().addToAll(args.getFlags(),FlagInfo.newInstance(""String_Node_Str"",priority,isSafe));
  }
 else   if (args.argsLength() == 1 || flagOffset == 2) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  String name=isSafe ? args.getJoinedStrings(flagOffset).replaceFirst(""String_Node_Str"",""String_Node_Str"") : args.getJoinedStrings(flagOffset);
  name=name.toLowerCase();
  FlagType type=FlagType.PLAYER;
  if (args.hasFlag('g')) {
    if (!Permission.useSuperPerms()) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    Group group=Permission.getGroup(name);
    if (group == null) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.GROUP;
  }
  if (args.hasFlag('m')) {
    if (!EntityUtils.validType(name,true)) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.MOB;
  }
  String prefix=guard.getFlags().contains(type,name) ? ""String_Node_Str"" : ""String_Node_Str"";
  guard.getFlags().addFlag(type,FlagInfo.newInstance(name,priority,isSafe));
  player.sendMessage(ChatColor.GREEN + prefix + ""String_Node_Str""+ StringUtils.wrap(name)+ ""String_Node_Str"");
}",0.988982833717653
1818,"private void jump(boolean inWater,boolean inLava){
  if (inWater || inLava) {
    this.motY+=0.03999999910593033D;
  }
 else   if (this.onGround) {
    this.motY=0.41999998688697815D + jumpFactor;
  }
}","private void jump(boolean inWater,boolean inLava){
  if (inWater || inLava) {
    this.motY+=0.03999999910593033D;
  }
 else   if (this.onGround) {
    this.motY=0.41999998688697815D + JUMP_FACTOR;
  }
}",0.9530864197530864
1819,"private void updateTarget(){
  if (!this.hasAttacked && this.targetEntity != null) {
    this.path=this.world.findPath(this,this.targetEntity,pathingRange);
  }
  if (targetEntity != null) {
    if (this.targetEntity.dead) {
      resetTarget();
    }
    if (targetEntity != null && targetAggro) {
      if (this.e(this.targetEntity)) {
        if (isWithinAttackRange(this.targetEntity,this.bukkitEntity.getLocation().distance(this.targetEntity.getBukkitEntity().getLocation()))) {
          this.attackEntity(this.targetEntity);
        }
      }
    }
  }
}","private void updateTarget(){
  if (!this.hasAttacked && this.targetEntity != null && autoPathToTarget) {
    this.path=this.world.findPath(this,this.targetEntity,pathingRange);
  }
  if (targetEntity != null) {
    if (this.targetEntity.dead) {
      resetTarget();
    }
    if (targetEntity != null && targetAggro) {
      if (this.e(this.targetEntity)) {
        if (isWithinAttackRange(this.targetEntity,this.bukkitEntity.getLocation().distance(this.targetEntity.getBukkitEntity().getLocation()))) {
          this.attackEntity(this.targetEntity);
        }
      }
    }
  }
}",0.9824868651488616
1820,"private boolean isWithinAttackRange(Entity entity,double distanceToEntity){
  return (isHoldingBow() && distanceToEntity < 10) || (this.attackTicks <= 0 && distanceToEntity < 1.5F && entity.boundingBox.e > this.boundingBox.b && entity.boundingBox.b < this.boundingBox.e);
}","private boolean isWithinAttackRange(Entity entity,double distanceToEntity){
  return this.attackTicks <= 0 && ((isHoldingBow() && distanceToEntity < 10) || (distanceToEntity < 1.5F && entity.boundingBox.e > this.boundingBox.b && entity.boundingBox.b < this.boundingBox.e));
}",0.9051094890510948
1821,"private void reset(){
  this.pathTicks=0;
  this.stationaryTicks=0;
  this.path=null;
  this.pathTickLimit=-1;
  this.stationaryTickLimit=-1;
  this.pathingRange=16;
}","private void reset(){
  this.path=null;
  this.pathTicks=this.stationaryTicks=0;
  this.pathTickLimit=this.stationaryTickLimit=-1;
  this.pathingRange=16;
}",0.8544891640866873
1822,"@Override public void onEnable(){
  plugin=this;
  loadNPCTypes();
  SettingsManager.setupVariables();
  Commands.registerCommands();
  new EntityListen().registerEvents();
  new WorldListen().registerEvents();
  new ServerListen().registerEvents();
  new PlayerListen().registerEvents();
  PermissionManager.initialize(Bukkit.getServer());
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new CreatureTask(),SettingsManager.getInt(""String_Node_Str""),SettingsManager.getInt(""String_Node_Str""));
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new CreatureTask.CreatureTick(),0,1);
  if (getServer().getScheduler().scheduleSyncDelayedTask(this,new Runnable(){
    @Override public void run(){
      setupNPCs();
    }
  }
) == -1) {
    Messaging.log(""String_Node_Str"");
    setupNPCs();
  }
  if (SettingsManager.getBoolean(""String_Node_Str"")) {
    getServer().getScheduler().scheduleSyncRepeatingTask(this,new Runnable(){
      @Override public void run(){
        Messaging.log(""String_Node_Str"");
        PropertyManager.saveState();
        Messaging.log(""String_Node_Str"");
      }
    }
,SettingsManager.getInt(""String_Node_Str""),SettingsManager.getInt(""String_Node_Str""));
  }
  for (  String loaded : loadedTypes) {
    CitizensNPC type=CitizensNPCManager.getType(loaded);
    type.onEnable();
    type.addListeners();
    for (    Listener listener : CitizensNPCManager.getListeners()) {
      listener.registerEvents();
    }
  }
  Messaging.log(""String_Node_Str"" + getVersion() + ""String_Node_Str"");
}","@Override public void onEnable(){
  plugin=this;
  loadNPCTypes();
  SettingsManager.setupVariables();
  Commands.registerCommands();
  new EntityListen().registerEvents();
  new WorldListen().registerEvents();
  new ServerListen().registerEvents();
  new PlayerListen().registerEvents();
  PermissionManager.initialize(Bukkit.getServer());
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new CreatureTask(),SettingsManager.getInt(""String_Node_Str""),SettingsManager.getInt(""String_Node_Str""));
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new CreatureTask.CreatureTick(),0,1);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new TickTask(),SettingsManager.getInt(""String_Node_Str""),SettingsManager.getInt(""String_Node_Str""));
  if (getServer().getScheduler().scheduleSyncDelayedTask(this,new Runnable(){
    @Override public void run(){
      setupNPCs();
    }
  }
) == -1) {
    Messaging.log(""String_Node_Str"");
    setupNPCs();
  }
  if (SettingsManager.getBoolean(""String_Node_Str"")) {
    getServer().getScheduler().scheduleSyncRepeatingTask(this,new Runnable(){
      @Override public void run(){
        Messaging.log(""String_Node_Str"");
        PropertyManager.saveState();
        Messaging.log(""String_Node_Str"");
      }
    }
,SettingsManager.getInt(""String_Node_Str""),SettingsManager.getInt(""String_Node_Str""));
  }
  for (  String loaded : loadedTypes) {
    CitizensNPC type=CitizensNPCManager.getType(loaded);
    type.onEnable();
    type.addListeners();
    for (    Listener listener : CitizensNPCManager.getListeners()) {
      listener.registerEvents();
    }
  }
  Messaging.log(""String_Node_Str"" + getVersion() + ""String_Node_Str"");
}",0.9502010516548096
1823,"private Vec3D getPathVector(){
  Vec3D vec3d=path.a(this);
  double length=(this.length * 1.85F);
  while (vec3d != null && vec3d.d(this.locX,vec3d.b,this.locZ) < length * length) {
    this.path.a();
    if (this.path.b()) {
      vec3d=null;
      reset();
    }
 else {
      vec3d=this.path.a(this);
    }
  }
  return vec3d;
}","private Vec3D getPathVector(){
  Vec3D vec3d=path.a(this);
  double length=(this.length * 1.82F);
  while (vec3d != null && vec3d.d(this.locX,vec3d.b,this.locZ) < length * length) {
    this.path.a();
    if (this.path.b()) {
      vec3d=null;
      reset();
    }
 else {
      vec3d=this.path.a(this);
    }
  }
  return vec3d;
}",0.9969788519637462
1824,"private void updateTarget(){
  if (!this.hasAttacked && this.targetEntity != null) {
    this.path=this.world.findPath(this,this.targetEntity,pathingRange);
  }
  if (targetEntity != null) {
    if (this.targetEntity.dead) {
      resetTarget();
    }
    if (targetEntity != null && targetAggro) {
      double distanceToEntity=distance(this,this.targetEntity);
      if (this.e(this.targetEntity)) {
        if (isWithinAttackRange(this.targetEntity,distanceToEntity)) {
          this.attackEntity(this.targetEntity);
        }
      }
    }
  }
}","private void updateTarget(){
  if (!this.hasAttacked && this.targetEntity != null) {
    this.path=this.world.findPath(this,this.targetEntity,pathingRange);
  }
  if (targetEntity != null) {
    if (this.targetEntity.dead) {
      resetTarget();
    }
    if (targetEntity != null && targetAggro) {
      if (this.e(this.targetEntity)) {
        if (isWithinAttackRange(this.targetEntity,this.bukkitEntity.getLocation().distance(this.targetEntity.getBukkitEntity().getLocation()))) {
          this.attackEntity(this.targetEntity);
        }
      }
    }
  }
}",0.6228622862286228
1825,"/** 
 * Get whether a guard NPC is a bouncer
 * @return
 */
public boolean isBouncer(){
  return guardType == GuardType.BOUNCER;
}","/** 
 * Set whether a guard NPC is a bodyguard
 * @param state
 */
public boolean isBouncer(){
  return guardType == GuardType.BOUNCER;
}",0.9138576779026216
1826,"@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers={""String_Node_Str"",""String_Node_Str""},flags=""String_Node_Str"",min=1) @CommandPermissions(""String_Node_Str"") public static void addFlag(CommandContext args,Player player,HumanNPC npc){
  if (!args.hasFlag('a') && !args.hasFlag('g') && !args.hasFlag('m')&& !args.hasFlag('p')) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  Guard guard=npc.getType(""String_Node_Str"");
  int flagOffset=1, priority=1;
  if (args.hasFlag('i')) {
    ++flagOffset;
    priority=args.getInteger(1);
  }
  boolean isSafe=args.getString(flagOffset).charAt(0) == '-';
  if (args.hasFlag('a')) {
    guard.getFlags().addToAll(args.getFlags(),FlagInfo.newInstance(""String_Node_Str"",priority,isSafe));
  }
 else   if (args.argsLength() == 1 || flagOffset == 2) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  String name=isSafe ? args.getJoinedStrings(flagOffset).replaceFirst(""String_Node_Str"",""String_Node_Str"") : args.getJoinedStrings(flagOffset);
  name=name.toLowerCase();
  FlagType type=FlagType.PLAYER;
  if (args.hasFlag('g')) {
    if (!PermissionManager.useSuperPerms()) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    Group group=PermissionManager.getGroup(name);
    if (group == null) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.GROUP;
  }
  if (args.hasFlag('m')) {
    if (!EntityUtils.validType(name,true)) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.MOB;
  }
  String prefix=guard.getFlags().contains(type,name) ? ""String_Node_Str"" : ""String_Node_Str"";
  guard.getFlags().addFlag(type,FlagInfo.newInstance(name,priority,isSafe));
  player.sendMessage(ChatColor.GREEN + prefix + ""String_Node_Str""+ StringUtils.wrap(name)+ ""String_Node_Str"");
}","@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers={""String_Node_Str"",""String_Node_Str""},flags=""String_Node_Str"",min=1) @CommandPermissions(""String_Node_Str"") public static void addFlag(CommandContext args,Player player,HumanNPC npc){
  if (!args.hasFlag('a') && !args.hasFlag('g') && !args.hasFlag('m')&& !args.hasFlag('p')) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  Guard guard=npc.getType(""String_Node_Str"");
  int flagOffset=1, priority=1;
  if (args.hasFlag('i')) {
    ++flagOffset;
    priority=args.getInteger(1);
  }
  if (args.hasFlag('a')) {
    guard.getFlags().addToAll(args.getFlags(),FlagInfo.newInstance(""String_Node_Str"",priority,args.argsLength() > flagOffset ? args.getString(flagOffset).charAt(0) == '-' : false));
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
    return;
  }
 else   if (args.argsLength() == 1 || flagOffset == 2) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  boolean isSafe=args.getString(flagOffset).charAt(0) == '-';
  String name=isSafe ? args.getJoinedStrings(flagOffset).replaceFirst(""String_Node_Str"",""String_Node_Str"") : args.getJoinedStrings(flagOffset);
  name=name.toLowerCase();
  FlagType type=FlagType.PLAYER;
  if (args.hasFlag('g')) {
    if (!PermissionManager.useSuperPerms()) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    Group group=PermissionManager.getGroup(name);
    if (group == null) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.GROUP;
  }
  if (args.hasFlag('m')) {
    if (!EntityUtils.validType(name,true)) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
    type=FlagType.MOB;
  }
  String prefix=guard.getFlags().contains(type,name) ? ""String_Node_Str"" : ""String_Node_Str"";
  guard.getFlags().addFlag(type,FlagInfo.newInstance(name,priority,isSafe));
  player.sendMessage(ChatColor.GREEN + prefix + ""String_Node_Str""+ StringUtils.wrap(name)+ ""String_Node_Str"");
}",0.8913097301312206
1827,"/** 
 * Return a bouncer to its original position
 * @param guard
 * @param npc
 */
public static void returnToBase(Guard guard,HumanNPC npc){
  Location loc;
  if (guard.isBodyguard()) {
    Player owner=Bukkit.getServer().getPlayer(npc.getOwner());
    if (owner != null) {
      loc=owner.getLocation();
    }
 else {
      return;
    }
  }
 else {
    if (npc.getWaypoints().size() > 0) {
      loc=npc.getWaypoints().current().getLocation();
    }
 else {
      loc=npc.getNPCData().getLocation();
    }
  }
  PathUtils.createPath(npc,loc,-1,-1,SettingsManager.getDouble(""String_Node_Str""));
}","/** 
 * Return a bouncer to its original position
 * @param guard
 * @param npc
 */
public static void returnToBase(Guard guard,HumanNPC npc){
  Location loc;
  if (guard.isBodyguard()) {
    Player owner=Bukkit.getServer().getPlayer(npc.getOwner());
    if (owner != null) {
      loc=owner.getLocation();
    }
 else {
      return;
    }
  }
 else {
    if (npc.getWaypoints().size() > 0) {
      loc=npc.getWaypoints().current().getLocation();
    }
 else {
      loc=npc.getNPCData().getLocation();
    }
  }
  if (npc.getLocation().distance(loc) > SettingsManager.getDouble(""String_Node_Str""))   npc.teleport(loc);
  PathUtils.createPath(npc,loc,-1,-1,SettingsManager.getDouble(""String_Node_Str""));
}",0.918007662835249
1828,"@Override public void run(){
  for (  Entry<Integer,HumanNPC> entry : NPCManager.getList().entrySet()) {
    HumanNPC npc=entry.getValue();
    if (npc.isType(""String_Node_Str"")) {
      Guard guard=npc.getType(""String_Node_Str"");
      if (guard.isAttacking() && !npc.getHandle().hasTarget()) {
        GuardManager.returnToBase(guard,npc);
        guard.setAttacking(false);
      }
      if (guard.isAttacking() && npc.getHandle().hasTarget() && (!LocationUtils.withinRange(npc.getLocation(),npc.getHandle().getTarget().getLocation(),guard.getProtectionRadius()) || !LocationUtils.withinRange(npc.getLocation(),npc.getNPCData().getLocation(),guard.getProtectionRadius()))) {
        npc.getHandle().cancelTarget();
        GuardManager.returnToBase(guard,npc);
        guard.setAttacking(false);
      }
      if (guard.isAttacking()) {
        continue;
      }
      if (npc.isPaused() && LocationUtils.withinRange(npc.getLocation(),npc.getNPCData().getLocation())) {
        npc.setPaused(false);
      }
      if (guard.isBouncer()) {
        handleTarget(npc.getPlayer(),npc,guard);
      }
 else       if (guard.isBodyguard()) {
        if (!npc.isPaused()) {
          npc.setPaused(true);
        }
        Player p=Bukkit.getServer().getPlayer(npc.getOwner());
        if (p != null) {
          handleTarget(p,npc,guard);
          if (LocationUtils.withinRange(npc.getLocation(),p.getLocation(),25)) {
            PathUtils.target(npc,p,false,-1,-1,25);
          }
 else {
            npc.teleport(p.getLocation());
          }
        }
 else {
          if (NPCManager.get(npc.getUID()) != null) {
            toRespawn.put(npc.getOwner(),new NPCLocation(npc.getLocation(),npc.getUID(),npc.getOwner()));
            NPCManager.despawn(npc.getUID());
          }
        }
      }
    }
  }
}","@Override public void run(){
  for (  Entry<Integer,HumanNPC> entry : NPCManager.getList().entrySet()) {
    HumanNPC npc=entry.getValue();
    if (npc.isType(""String_Node_Str"")) {
      Guard guard=npc.getType(""String_Node_Str"");
      if (guard.isAttacking() && !npc.getHandle().hasTarget()) {
        GuardManager.returnToBase(guard,npc);
        guard.setAttacking(false);
      }
      if (guard.isAttacking() && npc.getHandle().hasTarget() && (!LocationUtils.withinRange(npc.getLocation(),npc.getHandle().getTarget().getLocation(),guard.getProtectionRadius()))) {
        npc.getHandle().cancelTarget();
        GuardManager.returnToBase(guard,npc);
        guard.setAttacking(false);
      }
      if (guard.isAttacking()) {
        continue;
      }
      if (npc.isPaused() && LocationUtils.withinRange(npc.getLocation(),npc.getNPCData().getLocation())) {
        npc.setPaused(false);
      }
      if (guard.isBouncer()) {
        handleTarget(npc.getPlayer(),npc,guard);
      }
 else       if (guard.isBodyguard()) {
        if (!npc.isPaused()) {
          npc.setPaused(true);
        }
        Player p=Bukkit.getServer().getPlayer(npc.getOwner());
        if (p != null) {
          handleTarget(p,npc,guard);
          if (LocationUtils.withinRange(npc.getLocation(),p.getLocation(),25)) {
            PathUtils.target(npc,p,false,-1,-1,25);
          }
 else {
            npc.teleport(p.getLocation());
          }
        }
 else {
          if (NPCManager.get(npc.getUID()) != null) {
            toRespawn.put(npc.getOwner(),new NPCLocation(npc.getLocation(),npc.getUID(),npc.getOwner()));
            NPCManager.despawn(npc.getUID());
          }
        }
      }
    }
  }
}",0.8432155074116305
1829,"static boolean isTargetable(Map<String,FlagInfo> search,String key){
  if (search.containsKey(""String_Node_Str"")) {
    return !search.get(""String_Node_Str"").isSafe();
  }
  return search.containsKey(key) && !search.get(key).isSafe();
}","static boolean isTargetable(Map<String,FlagInfo> search,String key){
  if (!search.containsKey(key)) {
    key=""String_Node_Str"";
  }
  return search.containsKey(key) && !search.get(key).isSafe();
}",0.8341013824884793
1830,"List<LivingEntity> getPossible(Iterable<LivingEntity> toProcess){
  List<LivingEntity> processed=Lists.newArrayList();
  FlagInfo retrieved=null;
  for (  LivingEntity entity : toProcess) {
    if (CreatureTask.getCreature(entity) != null) {
      retrieved=getByType(MOBS).get(StringUtils.format(CreatureTask.getCreature(entity).getType(),false));
    }
 else     if (entity instanceof Player) {
      String name=((Player)entity).getName().toLowerCase();
      retrieved=getByType(PLAYERS).get(name) == null ? groupMap.get(name) : getByType(PLAYERS).get(name);
    }
 else {
      retrieved=getByType(MOBS).get(EntityUtils.getMonsterName(entity));
    }
    if (retrieved.priority() == lowestFound) {
      processed.add(entity);
    }
  }
  reset();
  return processed;
}","List<LivingEntity> getPossible(Iterable<LivingEntity> toProcess){
  List<LivingEntity> processed=Lists.newArrayList();
  FlagInfo retrieved=null;
  for (  LivingEntity entity : toProcess) {
    if (CreatureTask.getCreature(entity) != null) {
      retrieved=get(getByType(MOBS),StringUtils.format(CreatureTask.getCreature(entity).getType(),false));
    }
 else     if (entity instanceof Player) {
      String name=((Player)entity).getName().toLowerCase();
      retrieved=get(getByType(PLAYERS),name) == null ? groupMap.get(name) : get(getByType(PLAYERS),name);
    }
 else {
      retrieved=get(getByType(MOBS),EntityUtils.getMonsterName(entity));
    }
    if (retrieved.priority() == lowestFound) {
      processed.add(entity);
    }
  }
  reset();
  return processed;
}",0.9741602067183462
1831,"private FlagInfo get(Map<String,FlagInfo> source,String name){
  if (!source.containsKey(name))   return source.get(""String_Node_Str"");
  return source.get(name);
}","private FlagInfo get(Map<String,FlagInfo> source,String name){
  if (!source.containsKey(name))   name=""String_Node_Str"";
  return source.get(name);
}",0.929936305732484
1832,"/** 
 * Toggles an NPC state.
 * @param player
 * @param register
 * @param toggleable
 */
private static void toggleState(Player player,HumanNPC npc,CitizensNPC type,boolean register){
  if (register) {
    PropertyManager.get(type.getType());
  }
  if (!npc.isType(type.getType())) {
    npc.addType(type.getType());
    player.sendMessage(StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"" + type.getType()+ ""String_Node_Str"");
  }
 else {
    npc.removeType(type.getType());
    player.sendMessage(StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"" + type.getType()+ ""String_Node_Str"");
  }
}","/** 
 * Toggles an NPC state.
 * @param player
 * @param npc
 * @param type
 * @param register
 */
private static void toggleState(Player player,HumanNPC npc,CitizensNPC type){
  if (!npc.isType(type.getType())) {
    PropertyManager.get(type.getType()).setEnabled(npc,true);
    npc.addType(type.getType());
    player.sendMessage(StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"" + type.getType()+ ""String_Node_Str"");
  }
 else {
    PropertyManager.get(type.getType()).setEnabled(npc,false);
    npc.removeType(type.getType());
    player.sendMessage(StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"" + type.getType()+ ""String_Node_Str"");
  }
}",0.2513661202185792
1833,"/** 
 * Buys an NPC state.
 * @param player
 * @param toggleable
 */
private static void buyState(Player player,HumanNPC npc,CitizensNPC type){
  String toggle=type.getType();
  if (!Permission.generic(player,""String_Node_Str"" + toggle)) {
    Messaging.send(player,npc,MessageUtils.noPermissionsMessage);
    return;
  }
  if (EconomyManager.hasEnough(player,UtilityProperties.getPrice(toggle + ""String_Node_Str""))) {
    double paid=EconomyManager.pay(player,UtilityProperties.getPrice(toggle + ""String_Node_Str""));
    if (paid > 0) {
      Messaging.send(player,MessageUtils.getPaidMessage(player,toggle,toggle + ""String_Node_Str"",npc.getStrippedName(),true));
    }
    toggleState(player,npc,type,true);
  }
 else {
    Messaging.send(player,npc,MessageUtils.getNoMoneyMessage(player,toggle + ""String_Node_Str""));
  }
}","/** 
 * Buys an NPC state.
 * @param player
 * @param npc
 * @param type
 */
private static void buyState(Player player,HumanNPC npc,CitizensNPC type){
  String toggle=type.getType();
  if (!Permission.generic(player,""String_Node_Str"" + toggle)) {
    Messaging.send(player,npc,MessageUtils.noPermissionsMessage);
    return;
  }
  if (EconomyManager.hasEnough(player,UtilityProperties.getPrice(toggle + ""String_Node_Str""))) {
    double paid=EconomyManager.pay(player,UtilityProperties.getPrice(toggle + ""String_Node_Str""));
    if (paid > 0) {
      Messaging.send(player,MessageUtils.getPaidMessage(player,toggle,toggle + ""String_Node_Str"",npc.getStrippedName(),true));
    }
    toggleState(player,npc,type);
  }
 else {
    Messaging.send(player,npc,MessageUtils.getNoMoneyMessage(player,toggle + ""String_Node_Str""));
  }
}",0.9812462189957653
1834,"/** 
 * Toggles all types of NPCs
 * @param player
 * @param npc
 * @param on
 */
private static void toggleAll(Player player,HumanNPC npc,boolean on){
  if (on) {
    for (    CitizensNPC type : npc.types()) {
      if (!npc.isType(type.getType())) {
        toggleState(player,npc,type,false);
      }
    }
  }
 else {
    for (    CitizensNPC type : npc.types()) {
      toggleState(player,npc,type,false);
    }
  }
}","/** 
 * Toggles all types of NPCs
 * @param player
 * @param npc
 * @param on
 */
private static void toggleAll(Player player,HumanNPC npc,boolean on){
  if (on) {
    for (    Entry<String,CitizensNPC> entry : CitizensNPCManager.getTypes().entrySet()) {
      if (!npc.isType(entry.getValue().getType())) {
        toggleState(player,npc,entry.getValue());
      }
    }
  }
 else {
    for (    Entry<String,CitizensNPC> entry : CitizensNPCManager.getTypes().entrySet()) {
      toggleState(player,npc,entry.getValue());
    }
  }
}",0.4686192468619247
1835,"@CommandRequirements(requireSelected=true,requireOwnership=true) @Command(aliases={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=1,max=1) public static void toggle(CommandContext args,Player player,HumanNPC npc){
  String type=args.getString(0).toLowerCase();
  if (!CitizensNPCManager.validType(type)) {
    Messaging.sendError(player,""String_Node_Str"");
    return;
  }
  if (!PropertyManager.npcHasType(npc,type)) {
    buyState(player,npc,CitizensNPCManager.getType(type));
  }
 else {
    toggleState(player,npc,CitizensNPCManager.getType(type),false);
  }
}","@CommandRequirements(requireSelected=true,requireOwnership=true) @Command(aliases={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=1,max=1) public static void toggle(CommandContext args,Player player,HumanNPC npc){
  String type=args.getString(0).toLowerCase();
  if (!CitizensNPCManager.validType(type)) {
    Messaging.sendError(player,""String_Node_Str"");
    return;
  }
  if (!PropertyManager.npcHasType(npc,type)) {
    buyState(player,npc,CitizensNPCManager.getType(type));
  }
 else {
    toggleState(player,npc,CitizensNPCManager.getType(type));
  }
}",0.9953703703703703
1836,"public static CitizensNPC registerType(CitizensNPC type,boolean autosave){
  if (autosave) {
    PropertyManager.add(type.getType(),type.getProperties());
  }
  return registerType(type);
}","public static CitizensNPC registerType(CitizensNPC type){
  types.put(type.getType(),type);
  PropertyManager.add(type.getType(),type.getProperties());
  Citizens.commands.register(type.getCommands().getClass());
  return type;
}",0.2822966507177033
1837,"/** 
 * Sets the next location in the list as active.
 * @return
 */
public void cycle(HumanNPC npc,WizardMode mode){
  Wizard wizard=npc.getType(""String_Node_Str"");
switch (mode) {
case TELEPORT:
    currentLocation++;
  if (currentLocation >= numberOfLocations) {
    currentLocation=0;
  }
break;
case SPAWN_MOB:
CreatureType type=wizard.getMob();
CreatureType newType=null;
switch (type) {
case PIG:
newType=CreatureType.WOLF;
break;
case WOLF:
newType=CreatureType.COW;
break;
case COW:
newType=CreatureType.CHICKEN;
break;
case CHICKEN:
newType=CreatureType.SHEEP;
break;
case SHEEP:
newType=CreatureType.SQUID;
break;
case SQUID:
newType=CreatureType.PIG_ZOMBIE;
break;
case PIG_ZOMBIE:
newType=CreatureType.GHAST;
break;
case GHAST:
newType=CreatureType.GIANT;
break;
case GIANT:
newType=CreatureType.CREEPER;
break;
case CREEPER:
newType=CreatureType.ZOMBIE;
break;
case ZOMBIE:
newType=CreatureType.SPIDER;
break;
case SPIDER:
newType=CreatureType.SKELETON;
break;
case SKELETON:
newType=CreatureType.PIG;
break;
}
wizard.setMob(newType);
break;
case CHANGE_TIME:
String time=wizard.getTime();
String newTime=""String_Node_Str"";
if (time.equals(""String_Node_Str"")) {
newTime=""String_Node_Str"";
}
 else if (time.equals(""String_Node_Str"")) {
newTime=""String_Node_Str"";
}
 else if (time.equals(""String_Node_Str"")) {
newTime=""String_Node_Str"";
}
 else if (time.equals(""String_Node_Str"")) {
newTime=""String_Node_Str"";
}
wizard.setTime(newTime);
break;
}
}","/** 
 * Sets the next location in the list as active.
 * @return
 */
public void cycle(HumanNPC npc,WizardMode mode){
  Wizard wizard=npc.getType(""String_Node_Str"");
switch (mode) {
case TELEPORT:
    currentLocation++;
  if (currentLocation >= numberOfLocations) {
    currentLocation=0;
  }
break;
case SPAWN:
CreatureType type=wizard.getMob();
CreatureType newType=null;
switch (type) {
case PIG:
newType=CreatureType.WOLF;
break;
case WOLF:
newType=CreatureType.COW;
break;
case COW:
newType=CreatureType.CHICKEN;
break;
case CHICKEN:
newType=CreatureType.SHEEP;
break;
case SHEEP:
newType=CreatureType.SQUID;
break;
case SQUID:
newType=CreatureType.PIG_ZOMBIE;
break;
case PIG_ZOMBIE:
newType=CreatureType.GHAST;
break;
case GHAST:
newType=CreatureType.GIANT;
break;
case GIANT:
newType=CreatureType.CREEPER;
break;
case CREEPER:
newType=CreatureType.ZOMBIE;
break;
case ZOMBIE:
newType=CreatureType.SPIDER;
break;
case SPIDER:
newType=CreatureType.SKELETON;
break;
case SKELETON:
newType=CreatureType.PIG;
break;
}
wizard.setMob(newType);
break;
case TIME:
String time=wizard.getTime();
String newTime=""String_Node_Str"";
if (time.equals(""String_Node_Str"")) {
newTime=""String_Node_Str"";
}
 else if (time.equals(""String_Node_Str"")) {
newTime=""String_Node_Str"";
}
 else if (time.equals(""String_Node_Str"")) {
newTime=""String_Node_Str"";
}
 else if (time.equals(""String_Node_Str"")) {
newTime=""String_Node_Str"";
}
wizard.setTime(newTime);
break;
}
}",0.996216030271758
1838,"@Override public void onLeftClick(Player player,HumanNPC npc){
  if (Permission.generic(player,""String_Node_Str"")) {
    if (player.getItemInHand().getTypeId() == SettingsManager.getInt(""String_Node_Str"")) {
      Wizard wizard=npc.getType(""String_Node_Str"");
      String msg=ChatColor.GREEN + ""String_Node_Str"";
switch (wizard.getMode()) {
case EXECUTE_COMMAND:
        return;
case TELEPORT:
      if (wizard.getNumberOfLocations() > 0) {
        wizard.cycle(npc,WizardMode.TELEPORT);
        msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getCurrentLocationName());
      }
 else {
        msg+=ChatColor.RED + npc.getStrippedName() + ""String_Node_Str"";
      }
    break;
case SPAWN_MOB:
  wizard.cycle(npc,WizardMode.SPAWN_MOB);
msg+=""String_Node_Str"" + StringUtils.wrap(StringUtils.format(wizard.getMob()));
break;
case CHANGE_TIME:
wizard.cycle(npc,WizardMode.CHANGE_TIME);
msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getTime());
break;
case TOGGLE_STORM:
return;
default :
msg=ChatColor.RED + ""String_Node_Str"";
break;
}
player.sendMessage(msg);
}
}
 else {
player.sendMessage(MessageUtils.noPermissionsMessage);
}
}","@Override public void onLeftClick(Player player,HumanNPC npc){
  if (Permission.generic(player,""String_Node_Str"")) {
    if (player.getItemInHand().getTypeId() == SettingsManager.getInt(""String_Node_Str"")) {
      Wizard wizard=npc.getType(""String_Node_Str"");
      String msg=ChatColor.GREEN + ""String_Node_Str"";
switch (wizard.getMode()) {
case COMMAND:
        return;
case TELEPORT:
      if (wizard.getNumberOfLocations() > 0) {
        wizard.cycle(npc,WizardMode.TELEPORT);
        msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getCurrentLocationName());
      }
 else {
        msg+=ChatColor.RED + npc.getStrippedName() + ""String_Node_Str"";
      }
    break;
case SPAWN:
  wizard.cycle(npc,WizardMode.SPAWN);
msg+=""String_Node_Str"" + StringUtils.wrap(StringUtils.format(wizard.getMob()));
break;
case TIME:
wizard.cycle(npc,WizardMode.TIME);
msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getTime());
break;
case WEATHER:
return;
default :
msg=ChatColor.RED + ""String_Node_Str"";
break;
}
player.sendMessage(msg);
}
}
 else {
player.sendMessage(MessageUtils.noPermissionsMessage);
}
}",0.9798296727924698
1839,"@Override public void onRightClick(Player player,HumanNPC npc){
  if (Permission.generic(player,""String_Node_Str"")) {
    Wizard wizard=npc.getType(""String_Node_Str"");
    if (Citizens.validateTool(""String_Node_Str"",player.getItemInHand().getTypeId(),player.isSneaking())) {
      WizardManager.buy(player,npc,""String_Node_Str"" + StringUtils.format(wizard.getMode()));
    }
 else     if (player.getItemInHand().getTypeId() == SettingsManager.getInt(""String_Node_Str"")) {
      String msg=StringUtils.wrap(npc.getStrippedName() + ""String_Node_Str"");
      int mana=0;
      if (wizard.getMana() + 10 < SettingsManager.getInt(""String_Node_Str"")) {
        mana=wizard.getMana() + 10;
        msg+=""String_Node_Str"" + StringUtils.wrap(mana) + ""String_Node_Str"";
      }
 else       if (wizard.getMana() + 10 == SettingsManager.getInt(""String_Node_Str"")) {
        mana=SettingsManager.getInt(""String_Node_Str"");
        msg+=""String_Node_Str"";
      }
 else {
        msg+=""String_Node_Str"";
        return;
      }
      InventoryUtils.decreaseItemInHand(player);
      player.sendMessage(msg);
      wizard.setMana(mana);
    }
  }
 else {
    player.sendMessage(MessageUtils.noPermissionsMessage);
  }
}","@Override public void onRightClick(Player player,HumanNPC npc){
  if (Permission.generic(player,""String_Node_Str"")) {
    Wizard wizard=npc.getType(""String_Node_Str"");
    if (player.getItemInHand().getTypeId() == SettingsManager.getInt(""String_Node_Str"")) {
      String op=""String_Node_Str"";
switch (wizard.getMode()) {
case COMMAND:
        op=""String_Node_Str"";
      break;
case TELEPORT:
    op=""String_Node_Str"";
  break;
case TIME:
op=""String_Node_Str"";
break;
case SPAWN:
op=""String_Node_Str"";
break;
case WEATHER:
op=""String_Node_Str"";
break;
}
WizardManager.buy(player,npc,""String_Node_Str"" + op);
}
 else if (player.getItemInHand().getTypeId() == SettingsManager.getInt(""String_Node_Str"")) {
String msg=StringUtils.wrap(npc.getStrippedName() + ""String_Node_Str"");
int mana=0;
if (wizard.getMana() + 10 < SettingsManager.getInt(""String_Node_Str"")) {
mana=wizard.getMana() + 10;
msg+=""String_Node_Str"" + StringUtils.wrap(mana) + ""String_Node_Str"";
}
 else if (wizard.getMana() + 10 == SettingsManager.getInt(""String_Node_Str"")) {
mana=SettingsManager.getInt(""String_Node_Str"");
msg+=""String_Node_Str"";
}
 else {
msg+=""String_Node_Str"";
return;
}
InventoryUtils.decreaseItemInHand(player);
player.sendMessage(msg);
wizard.setMana(mana);
}
}
 else {
player.sendMessage(MessageUtils.noPermissionsMessage);
}
}",0.7309523809523809
1840,"/** 
 * Purchase a teleport
 * @param player
 * @param wizard
 * @param op
 */
public static void buy(Player player,HumanNPC npc,String op){
  if (EconomyManager.hasEnough(player,UtilityProperties.getPrice(op)) || !EconomyManager.useEconPlugin()) {
    boolean canSend=false;
    Wizard wizard=npc.getType(""String_Node_Str"");
    String msg=ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(EconomyManager.format(EconomyManager.pay(player,UtilityProperties.getPrice(op))));
    if (op.equals(""String_Node_Str"")) {
      msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getCurrentLocationName()) + ""String_Node_Str"";
      if (teleportPlayer(player,npc)) {
        canSend=true;
      }
    }
 else     if (op.equals(""String_Node_Str"")) {
      msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getMob().name().toLowerCase().replace(""String_Node_Str"",""String_Node_Str"")) + ""String_Node_Str"";
      if (spawnMob(player,npc)) {
        canSend=true;
      }
    }
 else     if (op.equals(""String_Node_Str"")) {
      msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getTime()) + ""String_Node_Str"";
      if (changeTime(player,npc)) {
        canSend=true;
      }
    }
 else     if (op.equals(""String_Node_Str"")) {
      msg+=""String_Node_Str"" + StringUtils.wrap(player.getWorld().getName()) + ""String_Node_Str"";
      if (toggleStorm(player,npc)) {
        canSend=true;
      }
    }
 else     if (op.equals(""String_Node_Str"")) {
      msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getCommand()) + ""String_Node_Str"";
      if (executeCommand(player,npc)) {
        canSend=true;
      }
    }
 else {
      msg=ChatColor.RED + ""String_Node_Str"";
      canSend=true;
    }
    if (canSend) {
      player.sendMessage(msg);
    }
  }
 else {
    player.sendMessage(MessageUtils.getNoMoneyMessage(player,op));
  }
}","/** 
 * Purchase a teleport
 * @param player
 * @param wizard
 * @param op
 */
public static void buy(Player player,HumanNPC npc,String op){
  if (EconomyManager.hasEnough(player,UtilityProperties.getPrice(op)) || !EconomyManager.useEconPlugin()) {
    boolean canSend=false;
    Wizard wizard=npc.getType(""String_Node_Str"");
    String msg=ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(EconomyManager.format(EconomyManager.pay(player,UtilityProperties.getPrice(op))));
    if (op.equals(""String_Node_Str"")) {
      msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getCurrentLocationName()) + ""String_Node_Str"";
      if (teleportPlayer(player,npc)) {
        canSend=true;
      }
    }
 else     if (op.equals(""String_Node_Str"")) {
      msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getMob().name().toLowerCase().replace(""String_Node_Str"",""String_Node_Str"")) + ""String_Node_Str"";
      if (spawnMob(player,npc)) {
        canSend=true;
      }
    }
 else     if (op.equals(""String_Node_Str"")) {
      msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getTime()) + ""String_Node_Str"";
      if (changeTime(player,npc)) {
        canSend=true;
      }
    }
 else     if (op.equals(""String_Node_Str"")) {
      msg+=""String_Node_Str"" + StringUtils.wrap(player.getWorld().getName()) + ""String_Node_Str"";
      if (toggleStorm(player,npc)) {
        canSend=true;
      }
    }
 else     if (op.equals(""String_Node_Str"")) {
      msg+=""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"" + wizard.getCommand()) + ""String_Node_Str"";
      if (executeCommand(player,npc)) {
        canSend=true;
      }
    }
 else {
      msg=ChatColor.RED + ""String_Node_Str"";
      canSend=true;
    }
    if (canSend) {
      player.sendMessage(msg);
    }
  }
 else {
    player.sendMessage(MessageUtils.getNoMoneyMessage(player,op));
  }
}",0.9945295404814004
1841,"/** 
 * Executes a command
 * @param player
 * @param npc
 */
public static boolean executeCommand(Player player,HumanNPC npc){
  if (decreaseMana(player,npc,5)) {
    return player.performCommand(((Wizard)npc.getType(""String_Node_Str"")).getCommand());
  }
  return false;
}","/** 
 * Executes a command
 * @param player
 * @param npc
 */
public static boolean executeCommand(Player player,HumanNPC npc){
  if (player.performCommand(((Wizard)npc.getType(""String_Node_Str"")).getCommand())) {
    return decreaseMana(player,npc,5);
  }
  return false;
}",0.8503649635036497
1842,"/** 
 * Sets up miscellaneous variables, mostly reading from property files.
 */
public static void setupVariables(){
  Messaging.log(""String_Node_Str"");
  PropertyManager.registerProperties();
  Storage local=null;
  loadSettings();
  for (  String t : Citizens.loadedTypes) {
    nodes.add(new Node(""String_Node_Str"",SettingsType.ECONOMY,""String_Node_Str"" + t + ""String_Node_Str"",100));
    for (    Node node : CitizensNPCManager.getType(t).getNodes()) {
      nodes.add(node);
    }
  }
  for (  Node node : nodes) {
    local=node.getFile();
    if (!local.keyExists(node.getPath())) {
      Messaging.log(""String_Node_Str"" + node.getPath() + ""String_Node_Str"");
      local.setRaw(node.getPath(),node.getValue());
    }
 else {
      node.set(node.getFile().getRaw(node.getPath()));
    }
    loadedNodes.put(node.getName(),node.getValue());
    local.save();
  }
}","/** 
 * Sets up miscellaneous variables, mostly reading from property files.
 */
public static void setupVariables(){
  PropertyManager.registerProperties();
  Storage local=null;
  loadSettings();
  for (  String t : Citizens.loadedTypes) {
    nodes.add(new Node(""String_Node_Str"",SettingsType.ECONOMY,""String_Node_Str"" + t + ""String_Node_Str"",100));
    for (    Node node : CitizensNPCManager.getType(t).getNodes()) {
      nodes.add(node);
    }
  }
  for (  Node node : nodes) {
    local=node.getFile();
    if (!local.keyExists(node.getPath())) {
      Messaging.log(""String_Node_Str"" + node.getPath() + ""String_Node_Str"");
      local.setRaw(node.getPath(),node.getValue());
    }
 else {
      node.set(node.getFile().getRaw(node.getPath()));
    }
    loadedNodes.put(node.getName(),node.getValue());
    local.save();
  }
}",0.9788980070339977
1843,"private void saveWaypoints(int UID,List<Waypoint> list){
  int count=0, innercount=0;
  String path=""String_Node_Str"", root=""String_Node_Str"";
  for (  Waypoint waypoint : list) {
    innercount=0;
    path=UID + this.waypoints + ""String_Node_Str""+ count;
    LocationUtils.saveLocation(profiles,waypoint.getLocation(),path,true);
    profiles.setInt(path + ""String_Node_Str"",waypoint.getDelay());
    path+=""String_Node_Str"";
    for (    WaypointModifier modifier : waypoint.getModifiers()) {
      root=path + innercount;
      profiles.setString(root + ""String_Node_Str"",modifier.getType().name());
      modifier.save(profiles,root);
      ++innercount;
    }
    ++count;
  }
}","private void saveWaypoints(int UID,List<Waypoint> list){
  profiles.removeKey(UID + this.waypoints);
  int count=0, innercount=0;
  String path=""String_Node_Str"", root=""String_Node_Str"";
  for (  Waypoint waypoint : list) {
    innercount=0;
    path=UID + this.waypoints + ""String_Node_Str""+ count;
    LocationUtils.saveLocation(profiles,waypoint.getLocation(),path,true);
    profiles.setInt(path + ""String_Node_Str"",waypoint.getDelay());
    path+=""String_Node_Str"";
    for (    WaypointModifier modifier : waypoint.getModifiers()) {
      root=path + innercount;
      profiles.setString(root + ""String_Node_Str"",modifier.getType().name());
      modifier.save(profiles,root);
      ++innercount;
    }
    ++count;
  }
}",0.9687943262411348
1844,"public static String format(Enum toFormat){
  String[] split=toFormat.name().toLowerCase().split(""String_Node_Str"");
  split[0]=capitalise(split[0]);
  return Joiner.on(""String_Node_Str"").join(split);
}","public static String format(Enum<?> toFormat){
  String[] split=toFormat.name().toLowerCase().split(""String_Node_Str"");
  split[0]=capitalise(split[0]);
  return Joiner.on(""String_Node_Str"").join(split);
}",0.9926289926289926
1845,"@Override public boolean converse(Player player,ConversationMessage message){
  super.resetExit();
  if (Effects.getByName(message.getMessage()) == null) {
    player.sendMessage(""String_Node_Str"");
  }
 else {
    if (inProgress == null) {
      IEffect effect=Effects.getByName(message.getMessage());
      if (effect instanceof Effect) {
switch ((Effect)effect) {
case DISPENSER_PARTICLE_SPAWN:
          player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
        inProgress=effect;
      break;
case DIG:
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
  inProgress=effect;
break;
default :
}
}
 else {
add(player,new EffectData(effect));
}
}
 else {
if (inProgress instanceof Effect) {
int data=message.getInteger(0);
switch ((Effect)inProgress) {
case DISPENSER_PARTICLE_SPAWN:
break;
case DIG:
if (data > 255 || Material.getMaterial(data) == null) {
player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
return false;
}
player.sendMessage(super.getMessage(""String_Node_Str"",StringUtils.format(Material.getMaterial(data))));
break;
}
add(player,new EffectData(inProgress,data));
inProgress=null;
}
}
}
return false;
}","@Override public boolean converse(Player player,ConversationMessage message){
  super.resetExit();
  if (Effects.getByName(message.getMessage()) == null) {
    player.sendMessage(""String_Node_Str"");
  }
 else {
    if (inProgress == null) {
      IEffect effect=Effects.getByName(message.getMessage());
      if (effect instanceof Effect) {
        inProgress=effect;
switch ((Effect)effect) {
case DISPENSER_PARTICLE_SPAWN:
          player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
        break;
case DIG:
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
    break;
case RECORD_PLAY:
  player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
break;
default :
}
}
 else {
add(player,new EffectData(effect));
}
}
 else {
if (inProgress instanceof Effect) {
int data=0;
switch ((Effect)inProgress) {
case DISPENSER_PARTICLE_SPAWN:
data=message.getInteger(0);
if (data > 8 || data < 1) {
player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
return false;
}
player.sendMessage(getMessage(""String_Node_Str"",data));
break;
case DIG:
data=message.getInteger(0);
if (data > 255 || Material.getMaterial(data) == null) {
player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
return false;
}
player.sendMessage(super.getMessage(""String_Node_Str"",StringUtils.format(Material.getMaterial(data))));
break;
case RECORD_PLAY:
if (message.getMessage().equalsIgnoreCase(""String_Node_Str"")) data=2257;
 else if (message.getMessage().equalsIgnoreCase(""String_Node_Str"")) data=2256;
 else data=-1;
if (data != 2256 && data != 2257) {
player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
}
break;
}
add(player,new EffectData(inProgress,data));
inProgress=null;
}
}
}
return false;
}",0.676771237222418
1846,"private static ItemPrice createItemPrice(Player player,String price){
  ItemStack cost=parseItemStack(player,price,true);
  boolean econPlugin=false;
  if (cost == null) {
    econPlugin=true;
  }
  ItemPrice itemPrice;
  if (!econPlugin) {
    itemPrice=new ItemPrice(cost);
  }
 else {
    itemPrice=new ItemPrice(Double.parseDouble(price));
  }
  itemPrice.setEconPlugin(econPlugin);
  return itemPrice;
}","private static ItemPrice createItemPrice(Player player,String price){
  ItemStack cost=parseItemStack(player,price,true);
  boolean econPlugin=false;
  if (cost == null) {
    econPlugin=true;
  }
  ItemPrice itemPrice;
  if (!econPlugin) {
    itemPrice=new ItemPrice(cost);
  }
 else {
    if (Double.parseDouble(price) < 0) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return null;
    }
    itemPrice=new ItemPrice(Double.parseDouble(price));
  }
  itemPrice.setEconPlugin(econPlugin);
  return itemPrice;
}",0.864406779661017
1847,"@Override public void onLeftClick(Player player,HumanNPC npc){
  if (Permission.generic(player,""String_Node_Str"")) {
    if (player.getItemInHand().getTypeId() == SettingsManager.getInt(""String_Node_Str"")) {
      Wizard wizard=npc.getType(""String_Node_Str"");
      WizardMode mode=wizard.getMode();
      String msg=ChatColor.GREEN + ""String_Node_Str"";
switch (mode) {
case EXECUTE_COMMAND:
        return;
case TELEPORT:
      if (wizard.getNumberOfLocations() > 0) {
        wizard.cycle(npc,WizardMode.TELEPORT);
        msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getCurrentLocationName());
      }
 else {
        msg+=ChatColor.RED + npc.getStrippedName() + ""String_Node_Str"";
      }
    break;
case SPAWN_MOB:
  wizard.cycle(npc,WizardMode.SPAWN_MOB);
msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getMob().name().toLowerCase().replace(""String_Node_Str"",""String_Node_Str""));
break;
case CHANGE_TIME:
wizard.cycle(npc,WizardMode.CHANGE_TIME);
msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getTime());
break;
case TOGGLE_STORM:
return;
default :
msg=ChatColor.RED + ""String_Node_Str"";
break;
}
player.sendMessage(msg);
}
}
 else {
player.sendMessage(MessageUtils.noPermissionsMessage);
}
}","@Override public void onLeftClick(Player player,HumanNPC npc){
  if (Permission.generic(player,""String_Node_Str"")) {
    if (player.getItemInHand().getTypeId() == SettingsManager.getInt(""String_Node_Str"")) {
      Wizard wizard=npc.getType(""String_Node_Str"");
      String msg=ChatColor.GREEN + ""String_Node_Str"";
switch (wizard.getMode()) {
case EXECUTE_COMMAND:
        return;
case TELEPORT:
      if (wizard.getNumberOfLocations() > 0) {
        wizard.cycle(npc,WizardMode.TELEPORT);
        msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getCurrentLocationName());
      }
 else {
        msg+=ChatColor.RED + npc.getStrippedName() + ""String_Node_Str"";
      }
    break;
case SPAWN_MOB:
  wizard.cycle(npc,WizardMode.SPAWN_MOB);
msg+=""String_Node_Str"" + StringUtils.wrap(StringUtils.format(wizard.getMob()));
break;
case CHANGE_TIME:
wizard.cycle(npc,WizardMode.CHANGE_TIME);
msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getTime());
break;
case TOGGLE_STORM:
return;
default :
msg=ChatColor.RED + ""String_Node_Str"";
break;
}
player.sendMessage(msg);
}
}
 else {
player.sendMessage(MessageUtils.noPermissionsMessage);
}
}",0.9384615384615383
1848,"@Override public void onRightClick(Player player,HumanNPC npc){
  if (Permission.generic(player,""String_Node_Str"")) {
    Wizard wizard=npc.getType(""String_Node_Str"");
    if (Citizens.validateTool(""String_Node_Str"",player.getItemInHand().getTypeId(),player.isSneaking())) {
      WizardManager.buy(player,npc,""String_Node_Str"" + wizard.getMode().toString().toLowerCase().replace(""String_Node_Str"",""String_Node_Str""));
    }
 else     if (player.getItemInHand().getTypeId() == SettingsManager.getInt(""String_Node_Str"")) {
      String msg=StringUtils.wrap(npc.getStrippedName() + ""String_Node_Str"");
      int mana=0;
      if (wizard.getMana() + 10 < SettingsManager.getInt(""String_Node_Str"")) {
        mana=wizard.getMana() + 10;
        msg+=""String_Node_Str"" + StringUtils.wrap(mana) + ""String_Node_Str"";
      }
 else       if (wizard.getMana() + 10 == SettingsManager.getInt(""String_Node_Str"")) {
        mana=SettingsManager.getInt(""String_Node_Str"");
        msg+=""String_Node_Str"";
      }
 else {
        msg+=""String_Node_Str"";
        return;
      }
      InventoryUtils.decreaseItemInHand(player);
      player.sendMessage(msg);
      wizard.setMana(mana);
    }
  }
 else {
    player.sendMessage(MessageUtils.noPermissionsMessage);
  }
}","@Override public void onRightClick(Player player,HumanNPC npc){
  if (Permission.generic(player,""String_Node_Str"")) {
    Wizard wizard=npc.getType(""String_Node_Str"");
    if (Citizens.validateTool(""String_Node_Str"",player.getItemInHand().getTypeId(),player.isSneaking())) {
      WizardManager.buy(player,npc,""String_Node_Str"" + StringUtils.format(wizard.getMode()));
    }
 else     if (player.getItemInHand().getTypeId() == SettingsManager.getInt(""String_Node_Str"")) {
      String msg=StringUtils.wrap(npc.getStrippedName() + ""String_Node_Str"");
      int mana=0;
      if (wizard.getMana() + 10 < SettingsManager.getInt(""String_Node_Str"")) {
        mana=wizard.getMana() + 10;
        msg+=""String_Node_Str"" + StringUtils.wrap(mana) + ""String_Node_Str"";
      }
 else       if (wizard.getMana() + 10 == SettingsManager.getInt(""String_Node_Str"")) {
        mana=SettingsManager.getInt(""String_Node_Str"");
        msg+=""String_Node_Str"";
      }
 else {
        msg+=""String_Node_Str"";
        return;
      }
      InventoryUtils.decreaseItemInHand(player);
      player.sendMessage(msg);
      wizard.setMana(mana);
    }
  }
 else {
    player.sendMessage(MessageUtils.noPermissionsMessage);
  }
}",0.9641985353946296
1849,"/** 
 * Teleport a player to one of a wizard's locations
 * @param player
 * @param npc
 */
public static boolean teleportPlayer(Player player,HumanNPC npc){
  WizardNPC wizard=npc.getType(""String_Node_Str"");
  if (wizard.getNumberOfLocations() > 0) {
    if (decreaseMana(player,npc,5)) {
      player.teleport(wizard.getCurrentLocation());
      return true;
    }
    return false;
  }
  Messaging.sendError(player,npc.getStrippedName() + ""String_Node_Str"");
  return false;
}","/** 
 * Teleport a player to one of a wizard's locations
 * @param player
 * @param npc
 */
public static boolean teleportPlayer(Player player,HumanNPC npc){
  Wizard wizard=npc.getType(""String_Node_Str"");
  if (wizard.getNumberOfLocations() > 0) {
    if (decreaseMana(player,npc,5)) {
      player.teleport(wizard.getCurrentLocation());
      return true;
    }
    return false;
  }
  Messaging.sendError(player,npc.getStrippedName() + ""String_Node_Str"");
  return false;
}",0.9968586387434556
1850,"/** 
 * Executes a command
 * @param player
 * @param npc
 */
public static boolean executeCommand(Player player,HumanNPC npc){
  if (decreaseMana(player,npc,5)) {
    Bukkit.getServer().dispatchCommand(player,((Wizard)npc.getType(""String_Node_Str"")).getCommand());
  }
  return false;
}","/** 
 * Executes a command
 * @param player
 * @param npc
 */
public static boolean executeCommand(Player player,HumanNPC npc){
  if (decreaseMana(player,npc,5)) {
    return player.performCommand(((Wizard)npc.getType(""String_Node_Str"")).getCommand());
  }
  return false;
}",0.8770053475935828
1851,"@Override public void run(){
  for (  Entry<Integer,HumanNPC> entry : NPCManager.getList().entrySet()) {
    HumanNPC npc=entry.getValue();
    if (!npc.isType(""String_Node_Str"")) {
      return;
    }
    Wizard wizard=npc.getType(""String_Node_Str"");
    if (SettingsManager.getBoolean(""String_Node_Str"") && !wizard.hasUnlimitedMana()) {
      WizardManager.increaseMana(npc,1);
    }
  }
}","@Override public void run(){
  for (  Entry<Integer,HumanNPC> entry : NPCManager.getList().entrySet()) {
    if (!entry.getValue().isType(""String_Node_Str"")) {
      return;
    }
    HumanNPC npc=entry.getValue();
    Wizard wizard=npc.getType(""String_Node_Str"");
    if (SettingsManager.getBoolean(""String_Node_Str"") && !wizard.hasUnlimitedMana()) {
      WizardManager.increaseMana(npc,1);
    }
  }
}",0.8276729559748428
1852,"/** 
 * Get the currency using a payment
 * @param payment
 * @param colour
 * @return
 */
public static String getCurrency(Payment payment,ChatColor colour){
  return MessageUtils.getStackString(payment.getItem(),colour);
}","/** 
 * Gets the item currency from an operation.
 * @param op
 * @return
 */
public static String getCurrency(EconomyOperation op){
  return ChatColor.stripColor(MessageUtils.getStackString(new ItemStack(op.getItemCurrencyID(),op.getItemPrice())));
}",0.3410526315789474
1853,"/** 
 * Checks the inventory of a player for having enough for a payment.
 * @param payment
 * @param player
 * @return
 */
public static boolean hasEnough(Payment payment,Player player){
  int current=0;
  if (payment.getItem().getAmount() <= 0 || payment.getItem().getTypeId() == 0) {
    return true;
  }
  for (  ItemStack i : player.getInventory().getContents()) {
    if (i != null && i.getTypeId() == payment.getItem().getTypeId()) {
      current+=i.getAmount();
      if (current >= payment.getPrice()) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * Checks the inventory of a player for having enough for an operation.
 * @param player
 * @param op
 * @return
 */
public static boolean hasEnough(Player player,int itemCurrencyID,int itemPrice){
  int current=0;
  for (  ItemStack i : player.getInventory().getContents()) {
    if (i != null && i.getTypeId() == itemCurrencyID) {
      current+=i.getAmount();
      if (current >= itemPrice) {
        return true;
      }
    }
  }
  return false;
}",0.4046692607003891
1854,"/** 
 * Pays for a payment from the player's inventory.
 * @param player
 * @param payment
 * @param slot
 * @return
 */
public static double pay(Player player,Payment payment,int slot){
  int currencyID=payment.getItem().getTypeId();
  double current=payment.getPrice();
  if (current <= 0) {
    return current;
  }
  int count=0;
  if (slot != -1) {
    current=decreaseItemStack(player,currencyID,current,slot);
  }
  if (current <= 0) {
    return payment.getPrice();
  }
  for (  ItemStack item : player.getInventory().getContents()) {
    if (item != null) {
      current=decreaseItemStack(player,currencyID,current,count);
      if (current <= 0) {
        break;
      }
    }
    count+=1;
  }
  return payment.getPrice();
}","/** 
 * Pays from the player's inventory using an operation.
 * @param player
 * @param op
 * @return
 */
public static double pay(Player player,int itemCurrencyID,int itemPrice){
  double current=itemPrice;
  int count=0;
  for (  ItemStack i : player.getInventory().getContents()) {
    if (i != null) {
      current=decreaseItemStack(player,itemCurrencyID,current,count);
      if (current <= 0) {
        break;
      }
    }
    count+=1;
  }
  return itemPrice;
}",0.4348547717842324
1855,"/** 
 * Checks whether an npc has enough in its balance for a payment.
 * @param payment
 * @param npc
 * @return
 */
public static boolean hasEnough(Payment payment,HumanNPC npc){
  return npc.getBalance() - payment.getPrice() >= 0;
}","/** 
 * Checks whether the player has enough money for an operation.
 * @param player
 * @param op
 * @return
 */
public static boolean hasEnough(Player player,double price){
  return playerHasEnough(player.getName(),price);
}",0.5466377440347071
1856,"/** 
 * Pays for a payment using the player's money.
 * @param player
 * @param payment
 * @return
 */
public static double pay(Player player,Payment payment){
  subtract(player.getName(),payment.getPrice());
  return payment.getPrice();
}","/** 
 * Pays for an operation using the player's money.
 * @param player
 * @param op
 * @return
 */
public static double pay(Player player,double price){
  subtract(player.getName(),price);
  return price;
}",0.7829977628635347
1857,"@Override public boolean canTake(Player player){
  return take ? ItemInterface.hasEnough(new Payment(reward),player) : true;
}","@Override public boolean canTake(Player player){
  return take;
}",0.680628272251309
1858,"/** 
 * Formats the price message for an ItemPrice.
 * @param price
 * @return
 */
public static String getPriceMessage(ItemPrice price,ChatColor colour){
  String message=""String_Node_Str"";
  message+=colour + StringUtils.wrap(EconomyManager.getCurrency(new Payment(price),colour),colour);
  return message;
}","/** 
 * Formats the price message for an ItemPrice.
 * @param price
 * @return
 */
public static String getPriceMessage(ItemPrice price,ChatColor colour){
  String message=""String_Node_Str"";
  return message;
}",0.7538461538461538
1859,"@Command(aliases={""String_Node_Str"",""String_Node_Str""},usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers={""String_Node_Str"",""String_Node_Str""},min=3,max=3) @CommandPermissions(""String_Node_Str"") public static void addWaypointModifier(CommandContext args,Player player,HumanNPC npc){
  if (NPCDataManager.pathEditors.get(player.getName()) == null) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  String type=args.getString(2);
  if (WaypointModifierType.valueOf(type.toUpperCase()) == null) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  WaypointModifierType modifier=WaypointModifierType.valueOf(type.toUpperCase());
  player.sendMessage(ChatColor.AQUA + StringUtils.listify(StringUtils.wrap(StringUtils.capitalise(modifier.name().toLowerCase())) + ""String_Node_Str"" + ChatColor.AQUA));
  Waypoint waypoint=npc.getWaypoints().getLast();
  ConversationUtils.addConverser(player,modifier.create(waypoint));
}","@Command(aliases={""String_Node_Str"",""String_Node_Str""},usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers={""String_Node_Str"",""String_Node_Str""},min=3,max=3) @CommandPermissions(""String_Node_Str"") public static void addWaypointModifier(CommandContext args,Player player,HumanNPC npc){
  if (NPCDataManager.pathEditors.get(player.getName()) == null) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  String type=args.getString(2);
  WaypointModifierType modifier;
  try {
    modifier=WaypointModifierType.valueOf(type.toUpperCase());
    if (modifier == null) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
      return;
    }
  }
 catch (  Exception e) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  modifier=WaypointModifierType.valueOf(type.toUpperCase());
  player.sendMessage(ChatColor.AQUA + StringUtils.listify(StringUtils.wrap(StringUtils.capitalise(modifier.name().toLowerCase())) + ""String_Node_Str"" + ChatColor.AQUA));
  Waypoint waypoint=npc.getWaypoints().getLast();
  ConversationUtils.addConverser(player,modifier.create(waypoint));
}",0.9043560606060606
1860,"public float toFloat(){
  return (Float)this.getValue();
}","public float toFloat(){
  return this.getValue() instanceof Double ? new Float((Double)this.getValue()) : (Integer)this.getValue();
}",0.6073298429319371
1861,"public double toDouble(){
  return (Double)this.getValue();
}","public double toDouble(){
  return this.getValue() instanceof Double ? (Double)this.getValue() : (Integer)this.getValue();
}",0.6594594594594595
1862,"public int getColour(int UID){
  if (Strings.isNullOrEmpty(profiles.getString(UID + color))) {
    profiles.setInt(UID + color,0xF);
    return 0xF;
  }
  return Integer.parseInt(profiles.getString(UID + color),16);
}","public int getColour(int UID){
  if (Strings.isNullOrEmpty(profiles.getString(UID + color))) {
    profiles.setInt(UID + color,0xF);
    return 0xF;
  }
  try {
    return Integer.parseInt(profiles.getString(UID + color),16);
  }
 catch (  NumberFormatException ex) {
    return 0xF;
  }
}",0.8537549407114624
1863,"public boolean hasTarget(){
  return this.targetEntity == null;
}","public boolean hasTarget(){
  return this.targetEntity != null;
}",0.9846153846153848
1864,"@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=3,max=3) @CommandPermissions(""String_Node_Str"") public static void setNPCArmor(CommandContext args,Player player,HumanNPC npc){
  Material mat=StringUtils.parseMaterial(args.getString(2));
  if (mat == null) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  if (!player.getInventory().contains(mat)) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  if ((mat.getId() < 298 || mat.getId() > 317) && (mat.getId() != 86 && mat.getId() != 91)) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  int slot=player.getInventory().first(mat);
  ItemStack item=NPCDataManager.decreaseItemStack(player.getInventory().getItem(slot));
  player.getInventory().setItem(slot,item);
  ArrayList<Integer> items=npc.getNPCData().getItems();
  int oldhelmet=items.get(1);
  if (args.getString(1).contains(""String_Node_Str"")) {
    items.set(1,mat.getId());
  }
 else   if (args.getString(1).equalsIgnoreCase(""String_Node_Str"")) {
    items.set(2,mat.getId());
  }
 else   if (args.getString(1).contains(""String_Node_Str"")) {
    items.set(3,mat.getId());
  }
 else   if (args.getString(1).contains(""String_Node_Str"")) {
    items.set(4,mat.getId());
  }
  npc.getNPCData().setItems(items);
  NPCDataManager.addItems(npc,items);
  if ((oldhelmet != 0 && items.get(1) == 0)) {
    NPCManager.removeForRespawn(npc.getUID());
    NPCManager.register(npc.getUID(),npc.getOwner());
  }
  player.sendMessage(StringUtils.wrap(npc.getName()) + ""String_Node_Str"" + StringUtils.wrap(MessageUtils.getMaterialName(mat.getId()))+ ""String_Node_Str"");
}","@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=3,max=3) @CommandPermissions(""String_Node_Str"") public static void setNPCArmor(CommandContext args,Player player,HumanNPC npc){
  Material mat=StringUtils.parseMaterial(args.getString(2));
  if (mat == null) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  if (mat != Material.AIR && !player.getInventory().contains(mat)) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  if ((mat.getId() < 298 || mat.getId() > 317) && (mat.getId() != 86 && mat.getId() != 91)) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  int slot=player.getInventory().first(mat);
  ItemStack item=NPCDataManager.decreaseItemStack(player.getInventory().getItem(slot));
  player.getInventory().setItem(slot,item);
  ArrayList<Integer> items=npc.getNPCData().getItems();
  int oldhelmet=items.get(1);
  if (args.getString(1).contains(""String_Node_Str"")) {
    items.set(1,mat.getId());
  }
 else   if (args.getString(1).equalsIgnoreCase(""String_Node_Str"")) {
    items.set(2,mat.getId());
  }
 else   if (args.getString(1).contains(""String_Node_Str"")) {
    items.set(3,mat.getId());
  }
 else   if (args.getString(1).contains(""String_Node_Str"")) {
    items.set(4,mat.getId());
  }
  npc.getNPCData().setItems(items);
  NPCDataManager.addItems(npc,items);
  if ((oldhelmet != 0 && items.get(1) == 0)) {
    NPCManager.removeForRespawn(npc.getUID());
    NPCManager.register(npc.getUID(),npc.getOwner());
  }
  player.sendMessage(StringUtils.wrap(npc.getName()) + ""String_Node_Str"" + StringUtils.wrap(MessageUtils.getMaterialName(mat.getId()))+ ""String_Node_Str"");
}",0.993350679387106
1865,"@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=1,max=1) @CommandPermissions(""String_Node_Str"") public static void copyNPC(CommandContext args,Player player,HumanNPC npc){
  if (UtilityProperties.getNPCCount(player.getName()) >= Constants.maxNPCsPerPlayer && !Permission.isAdmin(player)) {
    player.sendMessage(MessageUtils.reachedNPCLimitMessage);
    return;
  }
  PropertyManager.save(npc);
  int newUID=NPCManager.register(npc.getName(),player.getLocation(),player.getName());
  HumanNPC newNPC=NPCManager.get(newUID);
  newNPC.teleport(player.getLocation());
  newNPC.getNPCData().setLocation(player.getLocation());
  PropertyManager.copyNPCs(npc.getUID(),newUID);
}","@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=1,max=1) @CommandPermissions(""String_Node_Str"") public static void copyNPC(CommandContext args,Player player,HumanNPC npc){
  if (UtilityProperties.getNPCCount(player.getName()) >= Constants.maxNPCsPerPlayer && !Permission.isAdmin(player)) {
    player.sendMessage(MessageUtils.reachedNPCLimitMessage);
    return;
  }
  PropertyManager.save(npc);
  int newUID=NPCManager.register(npc.getName(),player.getLocation(),player.getName());
  HumanNPC newNPC=NPCManager.get(newUID);
  newNPC.teleport(player.getLocation());
  newNPC.getNPCData().setLocation(player.getLocation());
  PropertyManager.copyNPCs(npc.getUID(),newUID);
  PropertyManager.load(newNPC);
}",0.9788079470198676
1866,"@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=2,max=2) @CommandPermissions(""String_Node_Str"") public static void selectNPC(CommandContext args,Player player,HumanNPC npc){
  npc=NPCManager.get(Integer.valueOf(args.getString(1)));
  if (npc == null) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(args.getString(1),ChatColor.RED)+ ""String_Node_Str"");
  }
 else {
    NPCManager.selectNPC(player,npc);
    Messaging.send(player,npc,Constants.selectionMessage);
  }
}","@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=2,max=2) @CommandPermissions(""String_Node_Str"") @CommandRequirements() public static void selectNPC(CommandContext args,Player player,HumanNPC npc){
  npc=NPCManager.get(Integer.valueOf(args.getString(1)));
  if (npc == null) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(args.getString(1),ChatColor.RED)+ ""String_Node_Str"");
  }
 else {
    NPCManager.selectNPC(player,npc);
    Messaging.send(player,npc,Constants.selectionMessage);
  }
}",0.979982593559617
1867,"@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=1,max=2) @CommandPermissions(""String_Node_Str"") public static void levelUp(CommandContext args,Player player,HumanNPC npc){
  if (EconomyHandler.useEconomy()) {
    HealerNPC healer=npc.getToggleable(""String_Node_Str"");
    int level=healer.getLevel();
    int levelsUp=1;
    if (args.argsLength() == 2) {
      if (StringUtils.isNumber(args.getString(1))) {
        levelsUp=args.getInteger(1);
      }
    }
    double paid=EconomyHandler.pay(Operation.HEALER_LEVELUP,player,levelsUp);
    if (paid > 0) {
      if (level < 10) {
        int newLevel=level + levelsUp;
        healer.setLevel(newLevel);
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(""String_Node_Str"" + newLevel)+ ""String_Node_Str""+ StringUtils.wrap(EconomyHandler.getPaymentType(Operation.HEALER_LEVELUP,""String_Node_Str"" + paid * levelsUp) + ""String_Node_Str""));
      }
 else {
        player.sendMessage(StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"");
      }
    }
  }
 else {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
  }
}","@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=1,max=2) @CommandPermissions(""String_Node_Str"") public static void levelUp(CommandContext args,Player player,HumanNPC npc){
  if (EconomyHandler.useEconomy()) {
    HealerNPC healer=npc.getToggleable(""String_Node_Str"");
    int level=healer.getLevel();
    int levelsUp=1;
    if (args.argsLength() == 2 && StringUtils.isNumber(args.getString(1))) {
      levelsUp=args.getInteger(1);
    }
    if ((level + levelsUp) > 10) {
      levelsUp=(10 - level);
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"" + StringUtils.wrap(levelsUp)+ ""String_Node_Str"");
    }
    double paid=EconomyHandler.pay(Operation.HEALER_LEVELUP,player,levelsUp);
    if (paid > 0) {
      if (level < 10) {
        int newLevel=level + levelsUp;
        healer.setLevel(newLevel);
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(""String_Node_Str"" + newLevel)+ ""String_Node_Str""+ StringUtils.wrap(EconomyHandler.getPaymentType(Operation.HEALER_LEVELUP,""String_Node_Str"" + paid * levelsUp) + ""String_Node_Str""));
      }
 else {
        player.sendMessage(StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"");
      }
    }
  }
 else {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
  }
}",0.8970476911430735
1868,"@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=1,max=1) @CommandPermissions(""String_Node_Str"") public static void displayStatus(CommandContext args,Player player,HumanNPC npc){
  player.sendMessage(ChatColor.AQUA + StringUtils.listify(ChatColor.GOLD + npc.getStrippedName() + ""String_Node_Str""+ ChatColor.AQUA));
  WizardNPC wizard=npc.getToggleable(""String_Node_Str"");
  player.sendMessage(ChatColor.AQUA + ""String_Node_Str"" + ChatColor.GOLD+ wizard.getMode());
  player.sendMessage(ChatColor.AQUA + ""String_Node_Str"" + ChatColor.GOLD+ wizard.getMana());
}","@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=1,max=1) @CommandPermissions(""String_Node_Str"") public static void displayStatus(CommandContext args,Player player,HumanNPC npc){
  player.sendMessage(ChatColor.AQUA + StringUtils.listify(ChatColor.GREEN + npc.getStrippedName() + ""String_Node_Str""+ ChatColor.AQUA));
  WizardNPC wizard=npc.getToggleable(""String_Node_Str"");
  player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(wizard.getMode()));
  player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(wizard.getMana()));
}",0.8557768924302789
1869,"/** 
 * Purchase a teleport
 * @param player
 * @param wizard
 * @param op
 */
public static void buy(Player player,HumanNPC npc,Operation op){
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(op,player)) {
    if (EconomyHandler.useEconomy()) {
      boolean canSend=false;
      WizardNPC wizard=npc.getToggleable(""String_Node_Str"");
      double paid=EconomyHandler.pay(op,player);
      if (paid > 0) {
        String msg=ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(op,""String_Node_Str"" + paid));
switch (op) {
case WIZARD_TELEPORT:
          msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getCurrentLocationName()) + ""String_Node_Str"";
        if (teleportPlayer(player,npc)) {
          canSend=true;
        }
      break;
case WIZARD_SPAWNMOB:
    msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getMob().name().toLowerCase().replace(""String_Node_Str"",""String_Node_Str"")) + ""String_Node_Str"";
  if (spawnMob(player,npc)) {
    canSend=true;
  }
break;
case WIZARD_CHANGETIME:
msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getTime()) + ""String_Node_Str"";
if (changeTime(player,npc)) {
canSend=true;
}
break;
case WIZARD_TOGGLESTORM:
msg+=""String_Node_Str"" + StringUtils.wrap(player.getWorld().getName()) + ""String_Node_Str"";
if (toggleStorm(player,npc)) {
canSend=true;
}
break;
default :
msg=ChatColor.RED + ""String_Node_Str"";
canSend=true;
break;
}
if (canSend) {
player.sendMessage(msg);
}
}
}
 else {
player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
}
}
 else if (EconomyHandler.useEconomy()) {
player.sendMessage(MessageUtils.getNoMoneyMessage(op,player));
}
}","/** 
 * Purchase a teleport
 * @param player
 * @param wizard
 * @param op
 */
public static void buy(Player player,HumanNPC npc,Operation op){
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(op,player)) {
    if (EconomyHandler.useEconomy()) {
      boolean canSend=false;
      WizardNPC wizard=npc.getToggleable(""String_Node_Str"");
      double paid=EconomyHandler.pay(op,player);
      if (paid > 0 || EconomyHandler.isFree(player,op)) {
        String msg=ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(op,""String_Node_Str"" + paid));
switch (op) {
case WIZARD_TELEPORT:
          msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getCurrentLocationName()) + ""String_Node_Str"";
        if (teleportPlayer(player,npc)) {
          canSend=true;
        }
      break;
case WIZARD_SPAWNMOB:
    msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getMob().name().toLowerCase().replace(""String_Node_Str"",""String_Node_Str"")) + ""String_Node_Str"";
  if (spawnMob(player,npc)) {
    canSend=true;
  }
break;
case WIZARD_CHANGETIME:
msg+=""String_Node_Str"" + StringUtils.wrap(wizard.getTime()) + ""String_Node_Str"";
if (changeTime(player,npc)) {
canSend=true;
}
break;
case WIZARD_TOGGLESTORM:
msg+=""String_Node_Str"" + StringUtils.wrap(player.getWorld().getName()) + ""String_Node_Str"";
if (toggleStorm(player,npc)) {
canSend=true;
}
break;
default :
msg=ChatColor.RED + ""String_Node_Str"";
canSend=true;
break;
}
if (canSend) {
player.sendMessage(msg);
}
}
}
 else {
player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
}
}
 else if (EconomyHandler.useEconomy()) {
player.sendMessage(MessageUtils.getNoMoneyMessage(op,player));
}
}",0.9891238670694864
1870,"/** 
 * Sets the in-hand item of an npc.
 * @param player
 * @param npc
 * @param material
 */
public static void setItemInHand(Player player,HumanNPC npc,String material){
  Material mat=StringUtils.parseMaterial(material);
  if (mat == null) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  if (!player.getInventory().contains(mat)) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  if (npc.isType(""String_Node_Str"")) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  int slot=player.getInventory().first(mat);
  ItemStack item=decreaseItemStack(player.getInventory().getItem(slot));
  player.getInventory().setItem(slot,item);
  ArrayList<Integer> items=npc.getNPCData().getItems();
  int olditem=items.get(0);
  items.set(0,mat.getId());
  npc.getNPCData().setItems(items);
  if (mat != null && mat != Material.AIR) {
    npc.getInventory().setItem(0,new ItemStack(mat,1));
  }
 else {
    npc.getInventory().setItem(0,null);
  }
  NPCDataManager.addItems(npc,items);
  if ((olditem != 0 && items.get(0) == 0)) {
    NPCManager.removeForRespawn(npc.getUID());
    NPCManager.register(npc.getUID(),npc.getOwner());
  }
  player.sendMessage(StringUtils.wrap(npc.getName()) + ""String_Node_Str"" + StringUtils.wrap(MessageUtils.getMaterialName(mat.getId()))+ ""String_Node_Str"");
}","/** 
 * Sets the in-hand item of an npc.
 * @param player
 * @param npc
 * @param material
 */
public static void setItemInHand(Player player,HumanNPC npc,String material){
  Material mat=StringUtils.parseMaterial(material);
  if (mat == null) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  if (mat != Material.AIR && !player.getInventory().contains(mat)) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  if (npc.isType(""String_Node_Str"")) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    return;
  }
  int slot=player.getInventory().first(mat);
  ItemStack item=decreaseItemStack(player.getInventory().getItem(slot));
  player.getInventory().setItem(slot,item);
  ArrayList<Integer> items=npc.getNPCData().getItems();
  int olditem=items.get(0);
  items.set(0,mat.getId());
  npc.getNPCData().setItems(items);
  if (mat != null && mat != Material.AIR) {
    npc.getInventory().setItem(0,new ItemStack(mat,1));
  }
 else {
    npc.getInventory().setItem(0,null);
  }
  NPCDataManager.addItems(npc,items);
  if ((olditem != 0 && items.get(0) == 0)) {
    NPCManager.removeForRespawn(npc.getUID());
    NPCManager.register(npc.getUID(),npc.getOwner());
  }
  player.sendMessage(StringUtils.wrap(npc.getName()) + ""String_Node_Str"" + StringUtils.wrap(MessageUtils.getMaterialName(mat.getId()))+ ""String_Node_Str"");
}",0.9916636462486408
1871,"public static boolean validType(String type){
  return getTypes().get(type) != null;
}","public static boolean validType(String type){
  return types.get(type) != null;
}",0.9700598802395208
1872,"public static NPCType getType(String type){
  return getTypes().get(type);
}","public static NPCType getType(String type){
  return types.get(type);
}",0.9659863945578232
1873,"public static NPCFactory getFactory(String string){
  return getTypes().get(string).factory();
}","public static NPCFactory getFactory(String string){
  return types.get(string).factory();
}",0.9732620320855616
1874,"@Override public void saveState(HumanNPC npc){
  if (exists(npc)) {
    boolean is=npc.isType(""String_Node_Str"");
    setEnabled(npc,is);
    if (is) {
      WizardNPC wizard=npc.getToggleable(""String_Node_Str"");
      saveLocations(npc.getUID(),wizard.getLocations());
      saveMana(npc.getUID(),wizard.getMana());
      saveMode(npc.getUID(),wizard.getMode());
      saveTime(npc.getUID(),wizard.getTime());
      saveMob(npc.getUID(),wizard.getMob());
    }
  }
}","@Override public void saveState(HumanNPC npc){
  Messaging.log(""String_Node_Str"");
  if (exists(npc)) {
    Messaging.log(""String_Node_Str"");
    boolean is=npc.isType(""String_Node_Str"");
    setEnabled(npc,is);
    if (is) {
      Messaging.log(""String_Node_Str"");
      WizardNPC wizard=npc.getToggleable(""String_Node_Str"");
      saveLocations(npc.getUID(),wizard.getLocations());
      saveMana(npc.getUID(),wizard.getMana());
      saveMode(npc.getUID(),wizard.getMode());
      saveTime(npc.getUID(),wizard.getTime());
      saveMob(npc.getUID(),wizard.getMob());
    }
  }
}",0.8912213740458015
1875,"@Override public void setEnabled(HumanNPC npc,boolean value){
  profiles.setBoolean(npc.getUID(),value);
}","@Override public void setEnabled(HumanNPC npc,boolean value){
  profiles.setBoolean(npc.getUID() + isWizard,value);
}",0.9506726457399104
1876,"private boolean chunkLoaded(){
  return this.bukkitEntity.getWorld().isChunkLoaded(this.bukkitEntity.getLocation().getBlock().getChunk());
}","private boolean chunkLoaded(){
  return this.bukkitEntity.getWorld().isChunkLoaded(this.npc.getChunkX(),this.npc.getChunkZ());
}",0.7835820895522388
1877,"public int getChunkZ(){
  return this.getLocation().getBlockZ() << 4;
}","public int getChunkZ(){
  return this.getLocation().getBlockZ() >> 4;
}",0.971830985915493
1878,"public int getChunkX(){
  return this.getLocation().getBlockX() << 4;
}","public int getChunkX(){
  return this.getLocation().getBlockX() >> 4;
}",0.971830985915493
1879,"@Override public HumanNPC spawn(CreatureNPCType type,Location loc){
  int offsetX=0, offsetZ=0, offset=25;
  offsetX+=offset * getRandomInt(random,2);
  offsetZ+=offset * getRandomInt(random,2);
  int startX=loc.getBlockX() + offsetX;
  int startZ=loc.getBlockZ() + offsetZ;
  int searchY=3, searchXZ=4;
  World world=loc.getWorld();
  for (int y=loc.getBlockY() + searchY; y >= loc.getBlockY() - searchY; --y) {
    for (int x=startX - searchXZ; x <= startX + searchXZ; ++x) {
      for (int z=startZ - searchXZ; z <= startZ + searchXZ; ++z) {
        if (type.spawnOn().isValid(world.getBlockTypeIdAt(x,y - 1,z)) & type.spawnIn().isValid(world.getBlockTypeIdAt(x,y,z)) && type.spawnIn().isValid(world.getBlockTypeIdAt(x,y + 1,z))) {
          if (world.isChunkLoaded(world.getChunkAt(x,z))) {
            if (areEntitiesOnBlock(world.getChunkAt(x,z),x,y,z)) {
              if (canSpawn(type)) {
                HumanNPC npc=NPCSpawner.spawnNPC(0,UtilityProperties.getRandomName(type),loc.getWorld(),x,y,z,random.nextInt(360),0,type);
                NPCCreatureSpawnEvent spawnEvent=new NPCCreatureSpawnEvent(npc,loc);
                Bukkit.getServer().getPluginManager().callEvent(spawnEvent);
                if (spawnEvent.isCancelled()) {
                  return null;
                }
                return npc;
              }
            }
          }
        }
      }
    }
  }
  return null;
}","@Override public HumanNPC spawn(CreatureNPCType type,Location loc){
  int offsetX=0, offsetZ=0, offset=25;
  offsetX+=offset * getRandomInt(random,2);
  offsetZ+=offset * getRandomInt(random,2);
  int startX=loc.getBlockX() + offsetX;
  int startZ=loc.getBlockZ() + offsetZ;
  int searchY=3, searchXZ=4;
  World world=loc.getWorld();
  Chunk last=null;
  for (int y=loc.getBlockY() + searchY; y >= loc.getBlockY() - searchY; --y) {
    for (int x=startX - searchXZ; x <= startX + searchXZ; ++x) {
      for (int z=startZ - searchXZ; z <= startZ + searchXZ; ++z) {
        if (world.isChunkLoaded(x >> 4,z >> 4)) {
          if (world.getChunkAt(x >> 4,z >> 4) != last)           last=world.getChunkAt(x >> 4,z >> 4);
          if (type.spawnOn().isValid(world.getBlockTypeIdAt(x,y - 1,z)) & type.spawnIn().isValid(world.getBlockTypeIdAt(x,y,z)) && type.spawnIn().isValid(world.getBlockTypeIdAt(x,y + 1,z))) {
            if (areEntitiesOnBlock(last,x,y,z)) {
              if (canSpawn(type)) {
                HumanNPC npc=NPCSpawner.spawnNPC(0,UtilityProperties.getRandomName(type),loc.getWorld(),x,y,z,random.nextInt(360),0,type);
                NPCCreatureSpawnEvent spawnEvent=new NPCCreatureSpawnEvent(npc,loc);
                Bukkit.getServer().getPluginManager().callEvent(spawnEvent);
                if (spawnEvent.isCancelled()) {
                  return null;
                }
                return npc;
              }
            }
          }
        }
      }
    }
  }
  return null;
}",0.8947548851559822
1880,"/** 
 * Register our commands
 * @return
 */
public static void registerCommands(){
  Citizens.commands.register(BasicCommands.class);
  Citizens.commands.register(BlacksmithCommands.class);
  Citizens.commands.register(HealerCommands.class);
  Citizens.commands.register(ToggleCommands.class);
  Citizens.commands.register(TraderCommands.class);
  Citizens.commands.register(WizardCommands.class);
}","/** 
 * Register our commands
 * @return
 */
public static void registerCommands(){
  Citizens.commands.register(BasicCommands.class);
  Citizens.commands.register(BlacksmithCommands.class);
  Citizens.commands.register(GuardCommands.class);
  Citizens.commands.register(HealerCommands.class);
  Citizens.commands.register(ToggleCommands.class);
  Citizens.commands.register(TraderCommands.class);
  Citizens.commands.register(WizardCommands.class);
}",0.9400705052878966
1881,"/** 
 * Display a trader's balance
 * @param player
 * @param npc
 */
@CommandRequirements(requiredType=""String_Node_Str"",requireSelected=true) @Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=1,max=3) @CommandPermissions(""String_Node_Str"") public static void controlMoney(CommandContext args,Player player,HumanNPC npc){
  if (!EconomyHandler.useEconPlugin()) {
    player.sendMessage(MessageUtils.noEconomyMessage);
    return;
  }
switch (args.argsLength()) {
case 1:
    player.sendMessage(StringUtils.wrap(npc.getName()) + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(npc.getBalance()))+ ""String_Node_Str"");
  break;
case 3:
double amount;
try {
amount=Double.parseDouble(args.getString(2));
}
 catch (NumberFormatException e) {
player.sendMessage(ChatColor.RED + ""String_Node_Str"");
return;
}
if (args.getString(1).contains(""String_Node_Str"")) {
if (EconomyHandler.canBuy(new Payment(amount,true),player)) {
EconomyHandler.pay(new Payment(-amount,true),npc,-1);
EconomyHandler.pay(new Payment(amount,true),player,-1);
player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(amount))+ ""String_Node_Str""+ StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(ServerEconomyInterface.getFormattedBalance(player.getName()),ChatColor.GREEN)+ ""String_Node_Str"");
}
 else {
player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(amount - ServerEconomyInterface.getBalance(player.getName())),ChatColor.RED)+ ""String_Node_Str"");
}
}
 else if (args.getString(1).contains(""String_Node_Str"")) {
if (EconomyHandler.canBuy(new Payment(amount,true),npc)) {
EconomyHandler.pay(new Payment(amount,true),npc,-1);
EconomyHandler.pay(new Payment(-amount,true),player,-1);
player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(amount))+ ""String_Node_Str""+ StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(ServerEconomyInterface.getFormattedBalance(player.getName()))+ ""String_Node_Str"");
}
 else {
player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(amount - npc.getBalance()),ChatColor.RED)+ ""String_Node_Str"");
}
}
 else {
player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(args.getString(1),ChatColor.RED)+ ""String_Node_Str"");
}
break;
default :
Messaging.sendError(player,""String_Node_Str"");
break;
}
}","/** 
 * Display a trader's balance
 * @param player
 * @param npc
 */
@Command(aliases=""String_Node_Str"",usage=""String_Node_Str"",desc=""String_Node_Str"",modifiers=""String_Node_Str"",min=1,max=3) @CommandPermissions(""String_Node_Str"") public static void controlMoney(CommandContext args,Player player,HumanNPC npc){
  if (!EconomyHandler.useEconPlugin()) {
    player.sendMessage(MessageUtils.noEconomyMessage);
    return;
  }
switch (args.argsLength()) {
case 1:
    player.sendMessage(StringUtils.wrap(npc.getName()) + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(npc.getBalance()))+ ""String_Node_Str"");
  break;
case 3:
double amount;
try {
amount=Double.parseDouble(args.getString(2));
}
 catch (NumberFormatException e) {
player.sendMessage(ChatColor.RED + ""String_Node_Str"");
return;
}
if (args.getString(1).contains(""String_Node_Str"")) {
if (EconomyHandler.canBuy(new Payment(amount,true),player)) {
EconomyHandler.pay(new Payment(-amount,true),npc,-1);
EconomyHandler.pay(new Payment(amount,true),player,-1);
player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(amount))+ ""String_Node_Str""+ StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(ServerEconomyInterface.getFormattedBalance(player.getName()),ChatColor.GREEN)+ ""String_Node_Str"");
}
 else {
player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(amount - ServerEconomyInterface.getBalance(player.getName())),ChatColor.RED)+ ""String_Node_Str"");
}
}
 else if (args.getString(1).contains(""String_Node_Str"")) {
if (EconomyHandler.canBuy(new Payment(amount,true),npc)) {
EconomyHandler.pay(new Payment(amount,true),npc,-1);
EconomyHandler.pay(new Payment(-amount,true),player,-1);
player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(amount))+ ""String_Node_Str""+ StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(ServerEconomyInterface.getFormattedBalance(player.getName()))+ ""String_Node_Str"");
}
 else {
player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(amount - npc.getBalance()),ChatColor.RED)+ ""String_Node_Str"");
}
}
 else {
player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(args.getString(1),ChatColor.RED)+ ""String_Node_Str"");
}
break;
default :
Messaging.sendError(player,""String_Node_Str"");
break;
}
}",0.9852413242919824
1882,"@Override public void onChunkLoad(ChunkLoadEvent event){
  for (  NPCLocation tempLoc : toRespawn.keySet()) {
    if (tempLoc.getChunkX() == event.getChunk().getX() && tempLoc.getChunkZ() == event.getChunk().getZ()) {
      NPCManager.register(tempLoc.getUID(),tempLoc.getOwner());
      toRespawn.remove(tempLoc);
    }
  }
}","@Override public void onChunkLoad(ChunkLoadEvent event){
  for (  NPCLocation tempLoc : toRespawn.keySet()) {
    if (tempLoc.getChunkX() == event.getChunk().getX() && tempLoc.getChunkZ() == event.getChunk().getZ()) {
      if (NPCManager.get(tempLoc.getUID()) != null)       NPCManager.register(tempLoc.getUID(),tempLoc.getOwner());
      toRespawn.remove(tempLoc);
    }
  }
}",0.9034090909090908
1883,"/** 
 * Rotates an npc.
 * @param npc
 * @param player
 */
public static void facePlayer(HumanNPC npc,Player player){
  Location loc=npc.getLocation();
  double xDiff=player.getLocation().getX() - loc.getX();
  double yDiff=player.getLocation().getY() - loc.getY();
  double zDiff=player.getLocation().getZ() - loc.getZ();
  double DistanceXZ=Math.sqrt(xDiff * xDiff + zDiff * zDiff);
  double DistanceY=Math.sqrt(DistanceXZ * DistanceXZ + yDiff * yDiff);
  double yaw=(Math.acos(xDiff / DistanceXZ) * 180 / Math.PI);
  double pitch=(Math.acos(yDiff / DistanceY) * 180 / Math.PI) - 90;
  if (zDiff < 0.0) {
    yaw=yaw + (Math.abs(180 - yaw) * 2);
  }
  npc.teleport(loc.getX(),loc.getY(),loc.getZ(),(float)yaw - 90,(float)pitch);
  if (npc.getOwner().equals(player.getName())) {
    loc=npc.getNPCData().getLocation();
    loc.setPitch(npc.getLocation().getPitch());
    loc.setYaw(npc.getLocation().getYaw());
    npc.getNPCData().setLocation(loc);
  }
}","/** 
 * Rotates an npc.
 * @param npc
 * @param player
 */
public static void facePlayer(HumanNPC npc,Player player){
  Location loc=npc.getLocation(), pl=player.getLocation();
  double xDiff=pl.getX() - loc.getX();
  double yDiff=pl.getY() - loc.getY();
  double zDiff=pl.getZ() - loc.getZ();
  double DistanceXZ=Math.sqrt(xDiff * xDiff + zDiff * zDiff);
  double DistanceY=Math.sqrt(DistanceXZ * DistanceXZ + yDiff * yDiff);
  double yaw=(Math.acos(xDiff / DistanceXZ) * 180 / Math.PI);
  double pitch=(Math.acos(yDiff / DistanceY) * 180 / Math.PI) - 90;
  if (zDiff < 0.0) {
    yaw=yaw + (Math.abs(180 - yaw) * 2);
  }
  npc.teleport(loc.getX(),loc.getY(),loc.getZ(),(float)yaw - 90,(float)pitch);
  if (npc.getOwner().equals(player.getName())) {
    loc=npc.getNPCData().getLocation();
    loc.setPitch(npc.getLocation().getPitch());
    loc.setYaw(npc.getLocation().getYaw());
    npc.getNPCData().setLocation(loc);
  }
}",0.9580456718003186
1884,"/** 
 * Removes an npc.
 * @param UID
 */
public static void remove(int UID){
  PropertyManager.remove(get(UID));
  GlobalUIDs.remove(UID);
  NPCSpawner.despawnNPC(list.get(UID));
  list.remove(UID);
}","/** 
 * Removes an npc.
 * @param UID
 */
public static void remove(int UID){
  PropertyManager.remove(get(UID));
  NPCSpawner.despawnNPC(list.get(UID));
  GlobalUIDs.remove(UID);
  list.remove(UID);
}",0.8706467661691543
1885,"@Override public void save(){
  config.getAll().clear();
  for (  Entry<String,String> entry : tree.getTree().entrySet()) {
    if (entry.getValue() != null && !entry.getValue().isEmpty() && !StringUtils.isNumber(entry.getKey())) {
      this.config.setProperty(entry.getKey(),entry.getValue());
    }
  }
  this.config.save();
}","@Override public void save(){
  clear();
  for (  Entry<String,String> entry : tree.getTree().entrySet()) {
    if (entry.getValue() != null && !entry.getValue().isEmpty() && !StringUtils.isNumber(entry.getKey())) {
      this.config.setProperty(entry.getKey(),entry.getValue());
    }
  }
  this.config.save();
  clear();
}",0.9586523736600306
1886,"@Override public void load(){
  config.load();
  for (  Entry<String,Object> entry : this.config.getAll().entrySet()) {
    tree.set(entry.getKey(),entry.getValue().toString());
  }
}","@Override public void load(){
  clear();
  config.load();
  for (  Entry<String,Object> entry : this.config.getAll().entrySet()) {
    tree.set(entry.getKey(),entry.getValue().toString());
  }
  clear();
}",0.9432989690721648
1887,"public void remove(String path){
  for (  String key : tree.keySet()) {
    if (key.startsWith(path))     tree.remove(key);
  }
}","public void remove(String path){
  for (  String key : tree.keySet()) {
    if (key.startsWith(path)) {
      tree.remove(key);
    }
  }
}",0.9626865671641792
1888,"public HumanNPC getNPC(Entity entity){
  if (entity == null) {
    return null;
  }
  for (  HumanNPC bnpc : this.values()) {
    if (bnpc == null || bnpc.getPlayer() == null) {
      if (bnpc == null) {
        Messaging.log(""String_Node_Str"");
      }
 else       if (bnpc.getPlayer() == null) {
        Messaging.log(""String_Node_Str"");
      }
      continue;
    }
    if (bnpc.getPlayer().getEntityId() == entity.getEntityId()) {
      return bnpc;
    }
  }
  return null;
}","public HumanNPC getNPC(Entity entity){
  if (entity == null) {
    return null;
  }
  if (((CraftEntity)entity).getHandle() instanceof CraftNPC) {
    return ((CraftNPC)(((CraftEntity)entity).getHandle())).npc;
  }
  return null;
}",0.3230337078651685
1889,"/** 
 * Gets the text to be said for a basic NPC
 * @param npc
 * @param player
 * @return
 */
public static String getText(HumanNPC npc,Player player){
  String name=StringUtils.stripColour(npc.getStrippedName());
  ArrayDeque<String> array=NPCManager.getText(npc.getUID());
  String text=""String_Node_Str"";
  if (array != null && array.size() > 0) {
    text=array.pop();
    array.addLast(text);
    NPCManager.setText(npc.getUID(),array);
  }
  if (text.isEmpty()) {
    text=getRandomMessage(Constants.defaultText);
  }
  if (!text.isEmpty()) {
    if (Constants.useNPCColours) {
      text=StringUtils.colourise(Constants.chatFormat.replace(""String_Node_Str"",npc.getName())) + text;
    }
 else {
      text=StringUtils.colourise(Constants.chatFormat.replace(""String_Node_Str"",""String_Node_Str"" + Constants.npcColour + name+ ChatColor.WHITE)) + text;
    }
    return text;
  }
  return ""String_Node_Str"";
}","/** 
 * Gets the text to be said for a basic NPC
 * @param npc
 * @param player
 * @return
 */
public static String getText(HumanNPC npc,Player player){
  String name=StringUtils.stripColour(npc.getStrippedName());
  ArrayDeque<String> array=NPCManager.getText(npc.getUID());
  String text=""String_Node_Str"";
  if (array != null && array.size() > 0) {
    text=array.pop();
    array.addLast(text);
    NPCManager.setText(npc.getUID(),array);
  }
  if (text.isEmpty()) {
    text=getRandomMessage(Constants.defaultText);
  }
  if (!text.isEmpty()) {
    if (Constants.useNPCColours) {
      text=StringUtils.colourise(Constants.chatFormat.replace(""String_Node_Str"",npc.getStrippedName())) + text;
    }
 else {
      text=StringUtils.colourise(Constants.chatFormat.replace(""String_Node_Str"",""String_Node_Str"" + Constants.npcColour + name+ ChatColor.WHITE)) + text;
    }
    return text;
  }
  return ""String_Node_Str"";
}",0.9956379498364232
1890,"public static String pluralise(String string,int size){
  return size > 1 ? string + ""String_Node_Str"" : string;
}","public static String pluralise(String string,int size){
  return size > 1 ? string + (string.endsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"") : string;
}",0.794425087108014
1891,"@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    player.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!npc.isTrader()) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
  if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      HelpUtils.sendTraderHelp(sender);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length >= 2 && args[0].contains(""String_Node_Str"") && (args[1].contains(""String_Node_Str"") || args[1].contains(""String_Node_Str""))) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      displayList(player,npc,args,args[1].contains(""String_Node_Str""));
    }
 else {
      player.sendMessage(MessageUtils.noPermissionsMessage);
    }
    returnval=true;
  }
 else   if (args.length == 1 && args[0].contains(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      if (!EconomyHandler.useIconomy())       player.sendMessage(MessageUtils.noEconomyMessage);
 else       displayMoney(player,npc);
    }
 else     player.sendMessage(MessageUtils.noPermissionsMessage);
    returnval=true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    if (!returnval) {
      player.sendMessage(MessageUtils.notOwnerMessage);
    }
    return true;
  }
 else {
    if (args.length == 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        if (!EconomyHandler.useIconomy())         player.sendMessage(MessageUtils.noEconomyMessage);
 else         changeBalance(player,npc,args);
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 3 && (args[0].contains(""String_Node_Str"") || args[0].contains(""String_Node_Str""))) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeTraderStock(player,npc,args[1],args[2],args[0].contains(""String_Node_Str""));
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && (args[0].contains(""String_Node_Str""))) {
      if (Permission.isAdmin(player)) {
        changeUnlimited(npc,sender,args[1]);
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    PropertyManager.save(npc);
  }
  return returnval;
}","@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    player.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!npc.isTrader()) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
  if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      HelpUtils.sendTraderHelp(sender);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length >= 2 && args[0].contains(""String_Node_Str"") && (args[1].contains(""String_Node_Str"") || args[1].contains(""String_Node_Str""))) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      displayList(player,npc,args,args[1].contains(""String_Node_Str""));
    }
 else {
      player.sendMessage(MessageUtils.noPermissionsMessage);
    }
    returnval=true;
  }
 else   if (args.length == 1 && args[0].contains(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      if (!EconomyHandler.useIconomy())       player.sendMessage(MessageUtils.noEconomyMessage);
 else       displayMoney(player,npc);
    }
 else     player.sendMessage(MessageUtils.noPermissionsMessage);
    returnval=true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    if (!returnval) {
      player.sendMessage(MessageUtils.notOwnerMessage);
    }
    return true;
  }
 else {
    if (args.length == 3 && args[0].contains(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        if (!EconomyHandler.useIconomy())         player.sendMessage(MessageUtils.noEconomyMessage);
 else         changeBalance(player,npc,args);
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 3 && (args[0].contains(""String_Node_Str"") || args[0].contains(""String_Node_Str""))) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeTraderStock(player,npc,args[1],args[2],args[0].contains(""String_Node_Str""));
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && (args[0].contains(""String_Node_Str""))) {
      if (Permission.isAdmin(player)) {
        changeUnlimited(npc,sender,args[1]);
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    PropertyManager.save(npc);
  }
  return returnval;
}",0.9958861844360644
1892,"public NPCManager(Citizens plugin){
  this.plugin=plugin;
  list=new NPCList();
}","public NPCManager(Citizens plugin){
  this.plugin=plugin;
}",0.8428571428571429
1893,"public boolean setMethod(Plugin method){
  if (hasMethod())   return true;
  if (self) {
    self=false;
    return false;
  }
  int count=0;
  boolean match=false;
  Plugin plugin=null;
  PluginManager manager=method.getServer().getPluginManager();
  for (  String name : this.getDependencies()) {
    if (hasMethod())     break;
    if (method.getDescription().getName().equals(name))     plugin=method;
 else     plugin=manager.getPlugin(name);
    if (plugin == null)     continue;
    if (!plugin.isEnabled()) {
      this.self=true;
      manager.enablePlugin(plugin);
    }
    if (plugin == null)     continue;
    Method current=this.createMethod(plugin);
    if (current == null)     continue;
    if (this.preferred.isEmpty())     this.Method=current;
 else {
      this.Attachables.add(current);
    }
  }
  if (!this.preferred.isEmpty()) {
    do {
      if (hasMethod()) {
        match=true;
      }
 else {
        for (        Method attached : this.Attachables) {
          if (attached == null)           continue;
          if (hasMethod()) {
            match=true;
            break;
          }
          if (this.preferred.isEmpty())           this.Method=attached;
          if (count == 0) {
            if (this.preferred.equalsIgnoreCase(attached.getName()))             this.Method=attached;
          }
 else {
            this.Method=attached;
          }
        }
        count++;
      }
    }
 while (!match);
  }
  return hasMethod();
}","public boolean setMethod(Plugin method){
  if (hasMethod())   return true;
  if (self) {
    self=false;
    return false;
  }
  int count=0;
  boolean match=false;
  Plugin plugin=null;
  PluginManager manager=method.getServer().getPluginManager();
  for (  String name : this.getDependencies()) {
    if (hasMethod())     break;
    if (method.getDescription().getName().equals(name))     plugin=method;
 else     plugin=manager.getPlugin(name);
    if (plugin == null)     continue;
    if (!plugin.isEnabled()) {
      this.self=true;
      manager.enablePlugin(plugin);
    }
    Method current=this.createMethod(plugin);
    if (current == null)     continue;
    if (this.preferred.isEmpty())     this.Method=current;
 else {
      this.Attachables.add(current);
    }
  }
  if (!this.preferred.isEmpty()) {
    do {
      if (hasMethod()) {
        match=true;
      }
 else {
        for (        Method attached : this.Attachables) {
          if (attached == null)           continue;
          if (hasMethod()) {
            match=true;
            break;
          }
          if (this.preferred.isEmpty())           this.Method=attached;
          if (count == 0) {
            if (this.preferred.equalsIgnoreCase(attached.getName()))             this.Method=attached;
          }
 else {
            this.Method=attached;
          }
        }
        count++;
      }
    }
 while (!match);
  }
  return hasMethod();
}",0.9869236063317276
1894,"/** 
 * Moves the selected NPC to the current location of a player.
 * @param player
 * @param npc
 * @param name
 */
private void move(Player player,HumanNPC npc){
}","/** 
 * Moves the selected NPC to the current location of a player.
 * @param player
 * @param npc
 * @param name
 */
private void move(Player player,HumanNPC npc){
  if (npc != null) {
    player.sendMessage(StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"");
    npc.teleport(player.getLocation());
    npc.getNPCData().setLocation(player.getLocation());
  }
 else {
    player.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
  }
}",0.5398373983739837
1895,"@Override public void onEnable(){
  plugin=this;
  new CommandHandler().registerCommands();
  entityListener.registerEvents();
  customListener.registerEvents();
  worldListener.registerEvents();
  serverListener.registerEvents();
  playerListener.registerEvents();
  PropertyManager.registerProperties();
  Permission.initialize(Bukkit.getServer());
  Constants.setupVariables();
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new CreatureTask(),Constants.spawnTaskDelay,Constants.spawnTaskDelay);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new CreatureTask.CreatureTick(),0,1);
  if (getServer().getScheduler().scheduleSyncDelayedTask(this,new Runnable(){
    @Override public void run(){
      setupNPCs();
    }
  }
) == -1) {
    Messaging.log(""String_Node_Str"");
    setupNPCs();
  }
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new TickTask(Constants.npcRange),Constants.tickDelay,Constants.tickDelay);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new GuardTask(),Constants.tickDelay,Constants.tickDelay);
  if (Constants.useSaveTask) {
    getServer().getScheduler().scheduleSyncRepeatingTask(this,new Runnable(){
      @Override public void run(){
        Messaging.log(""String_Node_Str"");
        PropertyManager.stateSave();
        Messaging.log(""String_Node_Str"");
      }
    }
,Constants.saveDelay,Constants.saveDelay);
  }
  QuestManager.initialise();
  Messaging.log(""String_Node_Str"" + getVersion() + ""String_Node_Str""+ codename+ ""String_Node_Str"");
}","@Override public void onEnable(){
  plugin=this;
  CommandHandler.registerCommands();
  entityListener.registerEvents();
  customListener.registerEvents();
  worldListener.registerEvents();
  serverListener.registerEvents();
  playerListener.registerEvents();
  PropertyManager.registerProperties();
  Permission.initialize(Bukkit.getServer());
  Constants.setupVariables();
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new CreatureTask(),Constants.spawnTaskDelay,Constants.spawnTaskDelay);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new CreatureTask.CreatureTick(),0,1);
  if (getServer().getScheduler().scheduleSyncDelayedTask(this,new Runnable(){
    @Override public void run(){
      setupNPCs();
    }
  }
) == -1) {
    Messaging.log(""String_Node_Str"");
    setupNPCs();
  }
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new TickTask(Constants.npcRange),Constants.tickDelay,Constants.tickDelay);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,new GuardTask(),Constants.tickDelay,Constants.tickDelay);
  if (Constants.useSaveTask) {
    getServer().getScheduler().scheduleSyncRepeatingTask(this,new Runnable(){
      @Override public void run(){
        Messaging.log(""String_Node_Str"");
        PropertyManager.stateSave();
        Messaging.log(""String_Node_Str"");
      }
    }
,Constants.saveDelay,Constants.saveDelay);
  }
  QuestManager.initialize();
  Messaging.log(""String_Node_Str"" + getVersion() + ""String_Node_Str""+ codename+ ""String_Node_Str"");
}",0.9973787680209698
1896,"/** 
 * Register our commands
 * @return
 */
public void registerCommands(){
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new BasicExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new BasicExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new BasicExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new HealerExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new TraderExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new WizardExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new BlacksmithExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new QuesterExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new GuardExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new TogglerExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new QuestsExecutor());
}","/** 
 * Register our commands
 * @return
 */
public static void registerCommands(){
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new BasicExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new BasicExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new BasicExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new HealerExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new TraderExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new WizardExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new BlacksmithExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new QuesterExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new GuardExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new TogglerExecutor());
  Citizens.plugin.getCommand(""String_Node_Str"").setExecutor(new QuestsExecutor());
}",0.9964877069744104
1897,"public void setProgress(QuestProgress progress){
  this.progress=progress;
  if (this.profile.pathExists(""String_Node_Str""))   this.profile.removeKey(""String_Node_Str"");
}","public void setProgress(QuestProgress progress){
  this.progress=progress;
  if (this.profile.pathExists(""String_Node_Str"")) {
    this.profile.removeKey(""String_Node_Str"");
  }
}",0.9771428571428572
1898,"@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    sender.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (!npc.isBandit()) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        HelpUtils.sendBanditHelp(sender);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      return true;
    }
 else     if (args.length == 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          changeStealable(player,npc,args[2],true);
        }
 else         if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          changeStealable(player,npc,args[2],false);
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
  }
  return returnval;
}","@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    sender.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (!npc.isBandit()) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canHelp(player,npc,""String_Node_Str"")) {
        HelpUtils.sendBanditHelp(sender);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      return true;
    }
 else     if (args.length == 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          changeStealable(player,npc,args[2],true);
        }
 else         if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          changeStealable(player,npc,args[2],false);
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
  }
  return returnval;
}",0.9978104472943384
1899,"@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  if (NPCManager.validateSelected(player)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
  if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canCreate(player,""String_Node_Str"")) {
      if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(Operation.BASIC_CREATION,player)) {
        create(args,player);
      }
 else       if (EconomyHandler.useEconomy()) {
        sender.sendMessage(MessageUtils.getNoMoneyMessage(Operation.BASIC_CREATION,player));
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      move(player,npc,npc.getName());
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if ((args.length == 1 || args.length == 2) && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      remove(player,npc,args);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      rename(player,npc,args[1]);
      NPCManager.selectedNPCs.remove(player.getName());
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str""))) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      setColour(player,npc,args);
    }
 else {
      sender.sendMessage(MessageUtils.notOwnerMessage);
    }
    return true;
  }
 else   if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      addText(player,npc,args);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      setText(player,npc,args);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      resetText(player,npc,args);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      setItemInHand(player,npc,args[1]);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].startsWith(""String_Node_Str"") || args[0].startsWith(""String_Node_Str"")|| args[0].startsWith(""String_Node_Str""))) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      setArmor(player,npc,args);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length >= 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        player.teleport(npc.getNPCData().getLocation());
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        copy(npc.getUID(),npc.getName(),player);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      changeTalkWhenClose(player,npc,args[1]);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      changeLookWhenClose(player,npc,args[1]);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      if (!StringUtils.isNumber(args[1])) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        return true;
      }
      npc=NPCManager.get(Integer.valueOf(args[1]));
      if (npc == null) {
        sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[1]+ ""String_Node_Str"");
      }
 else {
        NPCManager.selectedNPCs.put(player.getName(),npc.getUID());
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str""+ StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str"");
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getOwner())+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      setOwner(player,npc,args[1]);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length >= 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
switch (args.length) {
case 1:
        displayList(player,player,npc,""String_Node_Str"");
      break;
case 2:
    if (StringUtils.isNumber(args[1])) {
      displayList(player,player,npc,args[1]);
    }
 else {
      if (ServerUtils.matchPlayer(player,args[1]) != null) {
        displayList(player,ServerUtils.matchPlayer(player,args[1]),npc,""String_Node_Str"");
      }
 else {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      }
    }
  break;
case 3:
if (ServerUtils.matchPlayer(player,args[1]) != null) {
  displayList(player,ServerUtils.matchPlayer(player,args[1]),npc,args[2]);
}
 else {
  player.sendMessage(ChatColor.RED + ""String_Node_Str"");
}
break;
}
}
 else {
sender.sendMessage(MessageUtils.noPermissionsMessage);
}
return true;
}
 else if ((commandLabel.equalsIgnoreCase(""String_Node_Str"") || commandLabel.equalsIgnoreCase(""String_Node_Str""))) {
if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
if (Permission.canUse(player,npc,""String_Node_Str"")) {
int page=0;
boolean canSend=false;
if (StringUtils.isNumber(args[1])) {
page=Integer.parseInt(args[1]);
canSend=true;
}
 else {
player.sendMessage(ChatColor.RED + ""String_Node_Str"");
}
if (canSend) {
HelpUtils.sendHelpPage(sender,page);
}
}
 else {
sender.sendMessage(MessageUtils.noPermissionsMessage);
}
}
 else if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
if (Permission.canUse(player,npc,""String_Node_Str"")) {
HelpUtils.sendHelpPage(sender,1);
}
 else {
sender.sendMessage(MessageUtils.noPermissionsMessage);
}
}
return true;
}
 else if (commandLabel.equalsIgnoreCase(""String_Node_Str"")) {
if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
if (Permission.canUse(player,npc,""String_Node_Str"")) {
int page=0;
if (StringUtils.isNumber(args[1])) {
page=Integer.parseInt(args[1]);
}
 else {
player.sendMessage(ChatColor.RED + ""String_Node_Str"");
return true;
}
HelpUtils.sendBasicHelpPage(sender,page);
}
 else {
sender.sendMessage(MessageUtils.noPermissionsMessage);
}
}
 else if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
if (Permission.canUse(player,npc,""String_Node_Str"")) {
HelpUtils.sendBasicHelpPage(sender,1);
}
 else {
sender.sendMessage(MessageUtils.noPermissionsMessage);
}
}
return true;
}
PropertyManager.get(""String_Node_Str"").saveState(npc);
return false;
}","@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  if (NPCManager.validateSelected(player)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
  if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canCreate(player,""String_Node_Str"")) {
      if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(Operation.BASIC_CREATION,player)) {
        create(args,player);
      }
 else       if (EconomyHandler.useEconomy()) {
        sender.sendMessage(MessageUtils.getNoMoneyMessage(Operation.BASIC_CREATION,player));
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      move(player,npc,npc.getName());
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if ((args.length == 1 || args.length == 2) && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      remove(player,npc,args);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      rename(player,npc,args[1]);
      NPCManager.selectedNPCs.remove(player.getName());
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str""))) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      setColour(player,npc,args);
    }
 else {
      sender.sendMessage(MessageUtils.notOwnerMessage);
    }
    return true;
  }
 else   if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      addText(player,npc,args);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      setText(player,npc,args);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      resetText(player,npc,args);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      setItemInHand(player,npc,args[1]);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].startsWith(""String_Node_Str"") || args[0].startsWith(""String_Node_Str"")|| args[0].startsWith(""String_Node_Str""))) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      setArmor(player,npc,args);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length >= 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        player.teleport(npc.getNPCData().getLocation());
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        copy(npc.getUID(),npc.getName(),player);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      changeTalkWhenClose(player,npc,args[1]);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      changeLookWhenClose(player,npc,args[1]);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      if (!StringUtils.isNumber(args[1])) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        return true;
      }
      npc=NPCManager.get(Integer.valueOf(args[1]));
      if (npc == null) {
        sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[1]+ ""String_Node_Str"");
      }
 else {
        NPCManager.selectedNPCs.put(player.getName(),npc.getUID());
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str""+ StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str"");
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getOwner())+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canModify(player,npc,""String_Node_Str"")) {
      setOwner(player,npc,args[1]);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length >= 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
switch (args.length) {
case 1:
        displayList(player,player,npc,""String_Node_Str"");
      break;
case 2:
    if (StringUtils.isNumber(args[1])) {
      displayList(player,player,npc,args[1]);
    }
 else {
      if (ServerUtils.matchPlayer(player,args[1]) != null) {
        displayList(player,ServerUtils.matchPlayer(player,args[1]),npc,""String_Node_Str"");
      }
 else {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      }
    }
  break;
case 3:
if (ServerUtils.matchPlayer(player,args[1]) != null) {
  displayList(player,ServerUtils.matchPlayer(player,args[1]),npc,args[2]);
}
 else {
  player.sendMessage(ChatColor.RED + ""String_Node_Str"");
}
break;
}
}
 else {
sender.sendMessage(MessageUtils.noPermissionsMessage);
}
return true;
}
 else if ((commandLabel.equalsIgnoreCase(""String_Node_Str"") || commandLabel.equalsIgnoreCase(""String_Node_Str""))) {
if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
if (Permission.canHelp(player,npc,""String_Node_Str"")) {
int page=0;
if (StringUtils.isNumber(args[1])) {
page=Integer.parseInt(args[1]);
}
 else {
player.sendMessage(ChatColor.RED + ""String_Node_Str"");
return true;
}
HelpUtils.sendHelpPage(sender,page);
}
 else {
sender.sendMessage(MessageUtils.noPermissionsMessage);
}
}
 else if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
if (Permission.canHelp(player,npc,""String_Node_Str"")) {
HelpUtils.sendHelpPage(sender,1);
}
 else {
sender.sendMessage(MessageUtils.noPermissionsMessage);
}
}
return true;
}
 else if (commandLabel.equalsIgnoreCase(""String_Node_Str"")) {
if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
if (Permission.canHelp(player,npc,""String_Node_Str"")) {
int page=0;
if (StringUtils.isNumber(args[1])) {
page=Integer.parseInt(args[1]);
}
 else {
player.sendMessage(ChatColor.RED + ""String_Node_Str"");
return true;
}
HelpUtils.sendBasicHelpPage(sender,page);
}
 else {
sender.sendMessage(MessageUtils.noPermissionsMessage);
}
}
 else if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
if (Permission.canHelp(player,npc,""String_Node_Str"")) {
HelpUtils.sendBasicHelpPage(sender,1);
}
 else {
sender.sendMessage(MessageUtils.noPermissionsMessage);
}
}
return true;
}
PropertyManager.get(""String_Node_Str"").saveState(npc);
return false;
}",0.9951244547087504
1900,"@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    sender.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (!npc.isBlacksmith()) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        HelpUtils.sendBlacksmithHelp(player);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      return true;
    }
 else     if (args.length == 2 && args[0].contains(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        repairArmor(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        listValidArmorNames(player);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        showUsesRemaining(player,npc.getBlacksmith(),Material.getMaterial(player.getItemInHand().getTypeId()));
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    PropertyManager.save(npc);
  }
  return returnval;
}","@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    sender.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (!npc.isBlacksmith()) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canHelp(player,npc,""String_Node_Str"")) {
        HelpUtils.sendBlacksmithHelp(player);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      return true;
    }
 else     if (args.length == 2 && args[0].contains(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        repairArmor(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        listValidArmorNames(player);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        showUsesRemaining(player,npc.getBlacksmith(),Material.getMaterial(player.getItemInHand().getTypeId()));
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    PropertyManager.save(npc);
  }
  return returnval;
}",0.9983185202978622
1901,"@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    sender.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (!npc.isGuard()) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        HelpUtils.sendGuardHelp(sender);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        toggleBodyguard(player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        toggleBouncer(player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        addToBlacklist(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        displayBlacklist(player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        addToWhitelist(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        displayWhitelist(player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (npc.getGuard().isBouncer() && args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        setProtectionRadius(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (!npc.getGuard().isBouncer() && args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else {
      sender.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    }
    PropertyManager.save(npc);
  }
  return returnval;
}","@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    sender.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (!npc.isGuard()) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canHelp(player,npc,""String_Node_Str"")) {
        HelpUtils.sendGuardHelp(sender);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        toggleBodyguard(player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        toggleBouncer(player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        addToBlacklist(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        displayBlacklist(player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        addToWhitelist(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        displayWhitelist(player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (npc.getGuard().isBouncer() && args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        setProtectionRadius(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (!npc.getGuard().isBouncer() && args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else {
      sender.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    }
    PropertyManager.save(npc);
  }
  return returnval;
}",0.998999857122446
1902,"@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    sender.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (!npc.isHealer()) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        HelpUtils.sendHealerHelp(sender);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        displayStatus(player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        levelUp(player,npc,1);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        if (StringUtils.isNumber(args[1])) {
          int levels=Integer.parseInt(args[1]);
          int x=npc.getHealer().getLevel() + levels;
          if (x <= 10) {
            levelUp(player,npc,levels);
          }
 else {
            sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    PropertyManager.save(npc);
  }
  return returnval;
}","@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    sender.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (!npc.isHealer()) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canHelp(player,npc,""String_Node_Str"")) {
        HelpUtils.sendHealerHelp(sender);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        displayStatus(player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        levelUp(player,npc,1);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        if (StringUtils.isNumber(args[1])) {
          int levels=Integer.parseInt(args[1]);
          int x=npc.getHealer().getLevel() + levels;
          if (x <= 10) {
            levelUp(player,npc,levels);
          }
 else {
            sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    PropertyManager.save(npc);
  }
  return returnval;
}",0.998522895125554
1903,"@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    sender.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (!npc.isQuester()) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        HelpUtils.sendQuesterHelp(sender);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      return true;
    }
 else     if (args.length == 2 && args[0].contains(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        assignQuest(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && args[0].contains(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        removeQuest(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    PropertyManager.save(npc);
  }
  return returnval;
}","@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    sender.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (!npc.isQuester()) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canHelp(player,npc,""String_Node_Str"")) {
        HelpUtils.sendQuesterHelp(sender);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      return true;
    }
 else     if (args.length == 2 && args[0].contains(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        assignQuest(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && args[0].contains(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        removeQuest(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    PropertyManager.save(npc);
  }
  return returnval;
}",0.9979514193737196
1904,"@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    player.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!npc.isTrader()) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
  if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      HelpUtils.sendTraderHelp(sender);
    }
 else {
      player.sendMessage(MessageUtils.noPermissionsMessage);
    }
    returnval=true;
  }
 else   if (args.length >= 2 && args[0].contains(""String_Node_Str"") && (args[1].contains(""String_Node_Str"") || args[1].contains(""String_Node_Str""))) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      displayList(player,npc,args,args[1].contains(""String_Node_Str""));
    }
 else {
      player.sendMessage(MessageUtils.noPermissionsMessage);
    }
    returnval=true;
  }
 else   if (args.length == 1 && args[0].contains(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      if (!EconomyHandler.useIconomy())       player.sendMessage(MessageUtils.noEconomyMessage);
 else       displayMoney(player,npc);
    }
 else     player.sendMessage(MessageUtils.noPermissionsMessage);
    returnval=true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    if (!returnval) {
      player.sendMessage(MessageUtils.notOwnerMessage);
    }
    return true;
  }
 else {
    if (args.length == 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        if (!EconomyHandler.useIconomy())         player.sendMessage(MessageUtils.noEconomyMessage);
 else         changeBalance(player,npc,args);
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 3 && (args[0].contains(""String_Node_Str"") || args[0].contains(""String_Node_Str""))) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeTraderStock(player,npc,args[1],args[2],args[0].contains(""String_Node_Str""));
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && (args[0].contains(""String_Node_Str""))) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeUnlimited(npc,sender,args[1]);
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    PropertyManager.save(npc);
  }
  return returnval;
}","@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    player.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!npc.isTrader()) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
  if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canHelp(player,npc,""String_Node_Str"")) {
      HelpUtils.sendTraderHelp(sender);
    }
 else {
      player.sendMessage(MessageUtils.noPermissionsMessage);
    }
    returnval=true;
  }
 else   if (args.length >= 2 && args[0].contains(""String_Node_Str"") && (args[1].contains(""String_Node_Str"") || args[1].contains(""String_Node_Str""))) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      displayList(player,npc,args,args[1].contains(""String_Node_Str""));
    }
 else {
      player.sendMessage(MessageUtils.noPermissionsMessage);
    }
    returnval=true;
  }
 else   if (args.length == 1 && args[0].contains(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      if (!EconomyHandler.useIconomy())       player.sendMessage(MessageUtils.noEconomyMessage);
 else       displayMoney(player,npc);
    }
 else     player.sendMessage(MessageUtils.noPermissionsMessage);
    returnval=true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    if (!returnval) {
      player.sendMessage(MessageUtils.notOwnerMessage);
    }
    return true;
  }
 else {
    if (args.length == 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        if (!EconomyHandler.useIconomy())         player.sendMessage(MessageUtils.noEconomyMessage);
 else         changeBalance(player,npc,args);
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 3 && (args[0].contains(""String_Node_Str"") || args[0].contains(""String_Node_Str""))) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeTraderStock(player,npc,args[1],args[2],args[0].contains(""String_Node_Str""));
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && (args[0].contains(""String_Node_Str""))) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeUnlimited(npc,sender,args[1]);
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    PropertyManager.save(npc);
  }
  return returnval;
}",0.9988209533434396
1905,"@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    player.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    player.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (!npc.isWizard()) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        HelpUtils.sendWizardHelp(sender);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeMode(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        displayStatus(player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        this.displayLocations(player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && args[0].contains(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        if (npc.getWizard().getNumberOfLocations() < Constants.wizardMaxLocations) {
          this.addLocation(player,npc,args[1]);
        }
 else {
          sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ Constants.wizardMaxLocations+ ""String_Node_Str"");
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && args[0].contains(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        int type=-1;
        if (StringUtils.isNumber(args[1])) {
          type=Integer.parseInt(args[1]);
        }
 else {
          sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
          type=-1;
        }
        if (type != -1) {
          if (type <= npc.getWizard().getNumberOfLocations()) {
            this.removeLocation(player,npc,type);
          }
 else {
            sender.sendMessage(StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"");
          }
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    PropertyManager.save(npc);
  }
  return returnval;
}","@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    player.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    player.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (!npc.isWizard()) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canHelp(player,npc,""String_Node_Str"")) {
        HelpUtils.sendWizardHelp(sender);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeMode(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        displayStatus(player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        this.displayLocations(player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && args[0].contains(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        if (npc.getWizard().getNumberOfLocations() < Constants.wizardMaxLocations) {
          this.addLocation(player,npc,args[1]);
        }
 else {
          sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ Constants.wizardMaxLocations+ ""String_Node_Str"");
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && args[0].contains(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        int type=-1;
        if (StringUtils.isNumber(args[1])) {
          type=Integer.parseInt(args[1]);
        }
 else {
          sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
          type=-1;
        }
        if (type != -1) {
          if (type <= npc.getWizard().getNumberOfLocations()) {
            this.removeLocation(player,npc,type);
          }
 else {
            sender.sendMessage(StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"");
          }
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    PropertyManager.save(npc);
  }
  return returnval;
}",0.9989553797940606
1906,"/** 
 * Sets up miscellaneous variables, mostly reading from property files.
 */
public static void setupVariables(){
  Storage settings=UtilityProperties.getSettings();
  convertSlashes=settings.getBoolean(""String_Node_Str"");
  defaultFollowingEnabled=settings.getBoolean(""String_Node_Str"");
  defaultTalkWhenClose=settings.getBoolean(""String_Node_Str"");
  useNPCColours=settings.getBoolean(""String_Node_Str"");
  useItemList=settings.getBoolean(""String_Node_Str"");
  saveOften=settings.getBoolean(""String_Node_Str"");
  useSaveTask=settings.getBoolean(""String_Node_Str"");
  payForHealerHeal=settings.getBoolean(""String_Node_Str"");
  regenHealerHealth=settings.getBoolean(""String_Node_Str"");
  regenWizardMana=settings.getBoolean(""String_Node_Str"");
  chatFormat=settings.getString(""String_Node_Str"");
  defaultText=settings.getString(""String_Node_Str"");
  npcColour=settings.getString(""String_Node_Str"");
  talkItems=settings.getString(""String_Node_Str"");
  selectItems=settings.getString(""String_Node_Str"");
  defaultBouncerProtectionRadius=settings.getDouble(""String_Node_Str"");
  npcRange=settings.getDouble(""String_Node_Str"");
  pathFindingRange=(float)settings.getDouble(""String_Node_Str"");
  banditStealRadius=settings.getInt(""String_Node_Str"");
  healerGiveHealthItem=settings.getInt(""String_Node_Str"");
  healerTakeHealthItem=settings.getInt(""String_Node_Str"");
  healerHealthRegenIncrement=settings.getInt(""String_Node_Str"");
  wizardManaRegenRate=settings.getInt(""String_Node_Str"");
  maxNPCsPerPlayer=settings.getInt(""String_Node_Str"");
  maxPathingTicks=settings.getInt(""String_Node_Str"");
  maxStationaryTicks=settings.getInt(""String_Node_Str"");
  saveDelay=settings.getInt(""String_Node_Str"");
  tickDelay=settings.getInt(""String_Node_Str"");
  wizardMaxLocations=settings.getInt(""String_Node_Str"");
  wizardInteractItem=settings.getInt(""String_Node_Str"");
  wizardManaRegenItem=settings.getInt(""String_Node_Str"");
  maxWizardMana=settings.getInt(""String_Node_Str"");
  Storage economy=UtilityProperties.getEconomySettings();
  useEconomy=economy.getBoolean(""String_Node_Str"");
  useEconplugin=economy.getBoolean(""String_Node_Str"");
  EconomyHandler.setUpVariables(useEconomy,useEconplugin);
  Storage mobs=UtilityProperties.getMobSettings();
  defaultEvilNames=mobs.getString(""String_Node_Str"");
  spawnEvil=mobs.getBoolean(""String_Node_Str"");
  maxEvilNPCs=mobs.getInt(""String_Node_Str"");
  spawnEvilDelay=mobs.getInt(""String_Node_Str"");
  evilLookRange=mobs.getInt(""String_Node_Str"");
  evilNPCTameItem=mobs.getInt(""String_Node_Str"");
  evilNPCTameChance=mobs.getInt(""String_Node_Str"");
  failureToTameMessages=mobs.getString(""String_Node_Str"");
}","/** 
 * Sets up miscellaneous variables, mostly reading from property files.
 */
public static void setupVariables(){
  Storage settings=UtilityProperties.getSettings();
  convertSlashes=settings.getBoolean(""String_Node_Str"");
  defaultFollowingEnabled=settings.getBoolean(""String_Node_Str"");
  defaultTalkWhenClose=settings.getBoolean(""String_Node_Str"");
  useNPCColours=settings.getBoolean(""String_Node_Str"");
  useItemList=settings.getBoolean(""String_Node_Str"");
  saveOften=settings.getBoolean(""String_Node_Str"");
  useSaveTask=settings.getBoolean(""String_Node_Str"");
  payForHealerHeal=settings.getBoolean(""String_Node_Str"");
  regenHealerHealth=settings.getBoolean(""String_Node_Str"");
  regenWizardMana=settings.getBoolean(""String_Node_Str"");
  chatFormat=settings.getString(""String_Node_Str"");
  defaultText=settings.getString(""String_Node_Str"");
  npcColour=settings.getString(""String_Node_Str"");
  talkItems=settings.getString(""String_Node_Str"");
  selectItems=settings.getString(""String_Node_Str"");
  defaultBouncerProtectionRadius=settings.getDouble(""String_Node_Str"");
  npcRange=settings.getDouble(""String_Node_Str"");
  pathFindingRange=(float)settings.getDouble(""String_Node_Str"");
  banditStealRadius=settings.getInt(""String_Node_Str"");
  healerGiveHealthItem=settings.getInt(""String_Node_Str"");
  healerTakeHealthItem=settings.getInt(""String_Node_Str"");
  healerHealthRegenIncrement=settings.getInt(""String_Node_Str"");
  wizardManaRegenRate=settings.getInt(""String_Node_Str"");
  maxNPCsPerPlayer=settings.getInt(""String_Node_Str"");
  maxPathingTicks=settings.getInt(""String_Node_Str"");
  maxStationaryTicks=settings.getInt(""String_Node_Str"");
  saveDelay=settings.getInt(""String_Node_Str"");
  tickDelay=settings.getInt(""String_Node_Str"");
  wizardMaxLocations=settings.getInt(""String_Node_Str"");
  wizardInteractItem=settings.getInt(""String_Node_Str"");
  wizardManaRegenItem=settings.getInt(""String_Node_Str"");
  maxWizardMana=settings.getInt(""String_Node_Str"");
  Storage economy=UtilityProperties.getEconomySettings();
  useEconomy=economy.getBoolean(""String_Node_Str"");
  useEconplugin=economy.getBoolean(""String_Node_Str"");
  EconomyHandler.setUpVariables(useEconomy,useEconplugin);
  Storage mobs=UtilityProperties.getMobSettings();
  defaultEvilNames=mobs.getString(""String_Node_Str"");
  spawnEvil=mobs.getBoolean(""String_Node_Str"");
  maxEvilNPCs=mobs.getInt(""String_Node_Str"");
  spawnEvilDelay=mobs.getInt(""String_Node_Str"");
  evilLookRange=mobs.getInt(""String_Node_Str"");
  evilNPCTameItem=mobs.getInt(""String_Node_Str"");
  evilNPCTameChance=mobs.getInt(""String_Node_Str"");
  failureToTameMessages=mobs.getString(""String_Node_Str"");
  evilDrops=mobs.getString(""String_Node_Str"");
}",0.9912460420934998
1907,"private static HashMap<String,String> writeMobSettings(){
  HashMap<String,String> nodes=new HashMap<String,String>();
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  return nodes;
}","private static HashMap<String,String> writeMobSettings(){
  HashMap<String,String> nodes=new HashMap<String,String>();
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  nodes.put(""String_Node_Str"",""String_Node_Str"");
  return nodes;
}",0.9554367201426024
1908,"@Override public void onEntityDamage(EntityDamageEvent event){
  CreatureTask.onDamage(event.getEntity(),event);
  if (event instanceof EntityDamageByEntityEvent) {
    EntityDamageByEntityEvent e=(EntityDamageByEntityEvent)event;
    HumanNPC npc=NPCManager.get(e.getEntity());
    if (npc != null) {
      if (e.getEntity() instanceof Player) {
        e.setCancelled(true);
      }
      if (e.getDamager() instanceof Player) {
        Player player=(Player)e.getDamager();
        if (npc.isHealer()) {
          npc.getHealer().onLeftClick(player,npc);
        }
        if (npc.isWizard()) {
          npc.getWizard().onLeftClick(player,npc);
        }
      }
    }
 else     if (e.getDamager() instanceof Player) {
      if (((LivingEntity)e.getEntity()).getHealth() - e.getDamage() <= 0) {
        QuestManager.incrementQuest((Player)e.getDamager(),new EntityDeathEvent(e.getEntity(),null));
      }
      CreatureTask.onLeftClick(e);
    }
  }
}","@Override public void onEntityDamage(EntityDamageEvent event){
  CreatureTask.onDamage(event.getEntity(),event);
  if (event instanceof EntityDamageByEntityEvent) {
    EntityDamageByEntityEvent e=(EntityDamageByEntityEvent)event;
    HumanNPC npc=NPCManager.get(e.getEntity());
    if (npc != null) {
      if (e.getEntity() instanceof Player) {
        e.setCancelled(true);
      }
      if (e.getDamager() instanceof Player) {
        Player player=(Player)e.getDamager();
        if (npc.isHealer()) {
          npc.getHealer().onLeftClick(player,npc);
        }
        if (npc.isWizard()) {
          npc.getWizard().onLeftClick(player,npc);
        }
      }
    }
 else     if (e.getDamager() instanceof Player) {
      if (((LivingEntity)e.getEntity()).getHealth() - e.getDamage() <= 0) {
        QuestManager.incrementQuest((Player)e.getDamager(),new EntityDeathEvent(e.getEntity(),null));
      }
      CreatureTask.onDamage(e.getEntity(),event);
    }
  }
}",0.9807792207792208
1909,"@Override public void onPlayerChat(PlayerChatEvent event){
  String msg=event.getMessage();
  String name=event.getPlayer().getName();
  if (!ChatManager.hasEditMode(name)) {
    return;
  }
  if (ChatManager.isAnswer(name,msg)) {
    event.setCancelled(true);
  }
}","@Override public void onPlayerChat(PlayerChatEvent event){
  String name=event.getPlayer().getName();
  if (!ChatManager.hasEditMode(name)) {
    return;
  }
  String msg=event.getMessage();
  if (ChatManager.isValidAnswer(name,msg,ChatManager.getMaxOptions(ChatManager.currentQuestion))) {
    event.setCancelled(true);
  }
}",0.4358108108108108
1910,"private CreatureType getMob(int UID){
  if (CreatureType.fromName(mob.getString(UID)) != null) {
    return CreatureType.fromName(mob.getString(UID));
  }
  System.out.println(""String_Node_Str"");
  return CreatureType.CREEPER;
}","private CreatureType getMob(int UID){
  if (CreatureType.fromName(mob.getString(UID)) != null) {
    return CreatureType.fromName(mob.getString(UID));
  }
  return CreatureType.CREEPER;
}",0.9012048192771084
1911,"/** 
 * Checks whether two locations are within range of each other.
 * @param loc
 * @param pLoc
 * @param range
 * @return
 */
public static boolean checkLocation(Location loc,Location pLoc,double range){
  if (!loc.getWorld().getName().equals(pLoc.getWorld().getName())) {
    return false;
  }
  double pX=pLoc.getX(), pY=pLoc.getY(), pZ=pLoc.getZ();
  double lX=loc.getX(), lY=loc.getY(), lZ=loc.getZ();
  if ((pX <= lX + range && pX >= lX - range) && (pY >= lY - range && pY <= lY + range) && (pZ >= lZ - range && pZ <= lZ + range)) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Checks whether two locations are within range of each other.
 * @param loc
 * @param pLoc
 * @param range
 * @return
 */
public static boolean checkLocation(Location loc,Location pLoc,double range){
  if (!loc.getWorld().getName().equals(pLoc.getWorld().getName())) {
    return false;
  }
  double pX=pLoc.getX(), pY=pLoc.getY(), pZ=pLoc.getZ();
  double lX=loc.getX(), lY=loc.getY(), lZ=loc.getZ();
  if ((pX <= lX + range && pX >= lX - range) && (pY >= lY - range && pY <= lY + range) && (pZ >= lZ - range && pZ <= lZ + range)) {
    return true;
  }
  return false;
}",0.9709897610921502
1912,"@Override public void a(EntityLiving entityliving){
  System.out.println(entityliving);
  super.a(entityliving);
}","@Override public void a(EntityLiving entityliving){
  super.a(entityliving);
}",0.8125
1913,"/** 
 * Buy an armor repair
 * @param player
 * @param npc
 * @param armor
 * @param armorName
 * @param plural
 */
private void buyArmorRepair(Player player,HumanNPC npc,ItemStack armor,String armorName,boolean plural){
  String msg=""String_Node_Str"";
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(Operation.BLACKSMITH_ARMORREPAIR,player)) {
    if (EconomyHandler.useEconomy()) {
      if (npc.getBlacksmith().validateArmor(armor)) {
        if (armor.getDurability() > 0) {
          double paid=EconomyHandler.pay(Operation.BLACKSMITH_ARMORREPAIR,player);
          if (paid > 0) {
            armor.setDurability((short)0);
            msg=ChatColor.GREEN + (""String_Node_Str"") + StringUtils.wrap(armorName);
            if (plural) {
              msg+=""String_Node_Str"";
            }
 else {
              msg+=""String_Node_Str"";
            }
            msg+=StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(Operation.BLACKSMITH_ARMORREPAIR,""String_Node_Str"" + paid,ChatColor.YELLOW))+ ""String_Node_Str"";
            player.sendMessage(msg);
          }
        }
 else {
          player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        }
      }
 else {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      }
    }
 else {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    }
  }
 else   if (EconomyHandler.useEconomy()) {
    player.sendMessage(MessageUtils.getNoMoneyMessage(Operation.BLACKSMITH_ARMORREPAIR,player));
    return;
  }
}","/** 
 * Buy an armor repair
 * @param player
 * @param npc
 * @param armor
 * @param armorName
 * @param plural
 */
private void buyArmorRepair(Player player,HumanNPC npc,ItemStack armor,String armorName,boolean plural){
  String msg=""String_Node_Str"";
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(Operation.BLACKSMITH_ARMORREPAIR,player)) {
    if (EconomyHandler.useEconomy()) {
      if (npc.getBlacksmith().validateArmor(armor)) {
        if (armor.getDurability() > 0) {
          double paid=EconomyHandler.pay(Operation.BLACKSMITH_ARMORREPAIR,player);
          if (paid > 0) {
            armor.setDurability((short)0);
            msg=ChatColor.GREEN + (""String_Node_Str"") + StringUtils.wrap(armorName);
            if (plural) {
              msg+=""String_Node_Str"";
            }
 else {
              msg+=""String_Node_Str"";
            }
            msg+=StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(Operation.BLACKSMITH_ARMORREPAIR,""String_Node_Str"" + paid))+ ""String_Node_Str"";
            player.sendMessage(msg);
          }
        }
 else {
          player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        }
      }
 else {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      }
    }
 else {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    }
  }
 else   if (EconomyHandler.useEconomy()) {
    player.sendMessage(MessageUtils.getNoMoneyMessage(Operation.BLACKSMITH_ARMORREPAIR,player));
    return;
  }
}",0.994524959742351
1914,"private String getLevelUpPaidMessage(Operation op,HumanNPC npc,double paid,int level,int multiple){
  String message=ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(""String_Node_Str"" + level)+ ""String_Node_Str""+ StringUtils.wrap(EconomyHandler.getPaymentType(op,""String_Node_Str"" + paid * multiple,ChatColor.GREEN) + ""String_Node_Str"");
  return message;
}","private String getLevelUpPaidMessage(Operation op,HumanNPC npc,double paid,int level,int multiple){
  String message=ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(""String_Node_Str"" + level)+ ""String_Node_Str""+ StringUtils.wrap(EconomyHandler.getPaymentType(op,""String_Node_Str"" + paid * multiple) + ""String_Node_Str"");
  return message;
}",0.980722891566265
1915,"/** 
 * Sets up miscellaneous variables, mostly reading from property files.
 */
public static void setupVariables(){
  Storage settings=UtilityProperties.getSettings();
  convertSlashes=settings.getBoolean(""String_Node_Str"");
  defaultFollowingEnabled=settings.getBoolean(""String_Node_Str"");
  defaultTalkWhenClose=settings.getBoolean(""String_Node_Str"");
  useNPCColours=settings.getBoolean(""String_Node_Str"");
  useItemList=settings.getBoolean(""String_Node_Str"");
  saveOften=settings.getBoolean(""String_Node_Str"");
  useSaveTask=settings.getBoolean(""String_Node_Str"");
  payForHealerHeal=settings.getBoolean(""String_Node_Str"");
  regenHealerHealth=settings.getBoolean(""String_Node_Str"");
  regenWizardMana=settings.getBoolean(""String_Node_Str"");
  chatFormat=settings.getString(""String_Node_Str"");
  defaultText=settings.getString(""String_Node_Str"");
  npcColour=settings.getString(""String_Node_Str"");
  talkItems=settings.getString(""String_Node_Str"");
  selectItems=settings.getString(""String_Node_Str"");
  defaultBouncerProtectionRadius=settings.getDouble(""String_Node_Str"");
  npcRange=settings.getDouble(""String_Node_Str"");
  pathFindingRange=(float)settings.getDouble(""String_Node_Str"");
  banditStealRadius=settings.getInt(""String_Node_Str"");
  healerGiveHealthItem=settings.getInt(""String_Node_Str"");
  healerTakeHealthItem=settings.getInt(""String_Node_Str"");
  healerHealthRegenIncrement=settings.getInt(""String_Node_Str"");
  wizardManaRegenRate=settings.getInt(""String_Node_Str"");
  maxNPCsPerPlayer=settings.getInt(""String_Node_Str"");
  maxPathingTicks=settings.getInt(""String_Node_Str"");
  maxStationaryTicks=settings.getInt(""String_Node_Str"");
  saveDelay=settings.getInt(""String_Node_Str"");
  tickDelay=settings.getInt(""String_Node_Str"");
  wizardMaxLocations=settings.getInt(""String_Node_Str"");
  wizardInteractItem=settings.getInt(""String_Node_Str"");
  wizardManaRegenItem=settings.getInt(""String_Node_Str"");
  maxWizardMana=settings.getInt(""String_Node_Str"");
  Storage economy=UtilityProperties.getEconomySettings();
  useEconplugin=economy.getBoolean(""String_Node_Str"");
  useEconomy=economy.getBoolean(""String_Node_Str"");
  EconomyHandler.setUpVariables();
  Storage mobs=UtilityProperties.getMobSettings();
  defaultEvilNames=mobs.getString(""String_Node_Str"");
  spawnEvil=mobs.getBoolean(""String_Node_Str"");
  maxEvilNPCs=mobs.getInt(""String_Node_Str"");
  spawnEvilDelay=mobs.getInt(""String_Node_Str"");
  evilLookRange=mobs.getInt(""String_Node_Str"");
  evilNPCTameItem=mobs.getInt(""String_Node_Str"");
  evilNPCTameChance=mobs.getInt(""String_Node_Str"");
  failureToTameMessages=settings.getString(""String_Node_Str"");
}","/** 
 * Sets up miscellaneous variables, mostly reading from property files.
 */
public static void setupVariables(){
  Storage settings=UtilityProperties.getSettings();
  convertSlashes=settings.getBoolean(""String_Node_Str"");
  defaultFollowingEnabled=settings.getBoolean(""String_Node_Str"");
  defaultTalkWhenClose=settings.getBoolean(""String_Node_Str"");
  useNPCColours=settings.getBoolean(""String_Node_Str"");
  useItemList=settings.getBoolean(""String_Node_Str"");
  saveOften=settings.getBoolean(""String_Node_Str"");
  useSaveTask=settings.getBoolean(""String_Node_Str"");
  payForHealerHeal=settings.getBoolean(""String_Node_Str"");
  regenHealerHealth=settings.getBoolean(""String_Node_Str"");
  regenWizardMana=settings.getBoolean(""String_Node_Str"");
  chatFormat=settings.getString(""String_Node_Str"");
  defaultText=settings.getString(""String_Node_Str"");
  npcColour=settings.getString(""String_Node_Str"");
  talkItems=settings.getString(""String_Node_Str"");
  selectItems=settings.getString(""String_Node_Str"");
  defaultBouncerProtectionRadius=settings.getDouble(""String_Node_Str"");
  npcRange=settings.getDouble(""String_Node_Str"");
  pathFindingRange=(float)settings.getDouble(""String_Node_Str"");
  banditStealRadius=settings.getInt(""String_Node_Str"");
  healerGiveHealthItem=settings.getInt(""String_Node_Str"");
  healerTakeHealthItem=settings.getInt(""String_Node_Str"");
  healerHealthRegenIncrement=settings.getInt(""String_Node_Str"");
  wizardManaRegenRate=settings.getInt(""String_Node_Str"");
  maxNPCsPerPlayer=settings.getInt(""String_Node_Str"");
  maxPathingTicks=settings.getInt(""String_Node_Str"");
  maxStationaryTicks=settings.getInt(""String_Node_Str"");
  saveDelay=settings.getInt(""String_Node_Str"");
  tickDelay=settings.getInt(""String_Node_Str"");
  wizardMaxLocations=settings.getInt(""String_Node_Str"");
  wizardInteractItem=settings.getInt(""String_Node_Str"");
  wizardManaRegenItem=settings.getInt(""String_Node_Str"");
  maxWizardMana=settings.getInt(""String_Node_Str"");
  Storage economy=UtilityProperties.getEconomySettings();
  useEconplugin=economy.getBoolean(""String_Node_Str"");
  useEconomy=economy.getBoolean(""String_Node_Str"");
  EconomyHandler.setUpVariables();
  Storage mobs=UtilityProperties.getMobSettings();
  defaultEvilNames=mobs.getString(""String_Node_Str"");
  spawnEvil=mobs.getBoolean(""String_Node_Str"");
  maxEvilNPCs=mobs.getInt(""String_Node_Str"");
  spawnEvilDelay=mobs.getInt(""String_Node_Str"");
  evilLookRange=mobs.getInt(""String_Node_Str"");
  evilNPCTameItem=mobs.getInt(""String_Node_Str"");
  evilNPCTameChance=mobs.getInt(""String_Node_Str"");
  failureToTameMessages=mobs.getString(""String_Node_Str"");
}",0.9981053429329292
1916,"public static void despawn(CreatureNPC npc){
  removeFromMaps(npc);
}","public static void despawn(CreatureNPC npc){
  removeFromMaps(npc);
  NPCSpawner.removeBasicHumanNpc(npc.npc);
}",0.7624309392265194
1917,"/** 
 * Gets what item ID or iConomy currency is being used for an operation.
 * @param op
 * @param amount
 * @return
 */
public static String getPaymentType(Operation op,String amount,ChatColor colour){
  if (useEconomy) {
    if (useIconomy()) {
      return ServerEconomyInterface.format(amount);
    }
 else {
      return ItemInterface.getCurrency(op,colour);
    }
  }
 else {
    return ""String_Node_Str"";
  }
}","/** 
 * Gets what item ID or iConomy currency is being used for an operation.
 * @param op
 * @param amount
 * @return
 */
public static String getPaymentType(Operation op,String amount){
  if (useEconomy) {
    if (useIconomy()) {
      return ServerEconomyInterface.format(amount);
    }
 else {
      return ItemInterface.getCurrency(op);
    }
  }
 else {
    return ""String_Node_Str"";
  }
}",0.5945945945945946
1918,"@Override public void onEntityTarget(EntityTargetEvent event){
  if (CreatureTask.getCreature(event.getEntity()) != null) {
    HumanNPC creature=CreatureTask.getCreature(event.getEntity()).npc;
    if (creature.isEvil()) {
      creature.getEvil().onRightClick((Player)event.getTarget(),creature);
    }
  }
  if (NPCManager.isNPC(event.getTarget())) {
    event.setCancelled(true);
  }
  if (!(event instanceof NPCEntityTargetEvent)) {
    return;
  }
  NPCEntityTargetEvent e=(NPCEntityTargetEvent)event;
  HumanNPC npc=NPCManager.get(e.getEntity());
  if (npc != null && event.getTarget() instanceof Player) {
    if (e.getNpcReason() == NpcTargetReason.NPC_RIGHTCLICKED) {
      Player player=(Player)event.getTarget();
      if (plugin.validateTool(""String_Node_Str"",player.getItemInHand().getTypeId(),player.isSneaking()) == true) {
        if (!NPCManager.validateSelected(player,npc.getUID())) {
          NPCManager.selectedNPCs.put(player.getName(),npc.getUID());
          player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str"");
          return;
        }
      }
      if (plugin.validateTool(""String_Node_Str"",player.getItemInHand().getTypeId(),player.isSneaking()) == true) {
        CitizensBasicNPCEvent ev=new CitizensBasicNPCEvent(npc,(Player)e.getTarget(),MessageUtils.getText(npc,(Player)e.getTarget()));
        plugin.getServer().getPluginManager().callEvent(ev);
      }
      if (npc.isTrader()) {
        npc.getTrader().onRightClick(player,npc);
      }
      if (npc.isWizard()) {
        npc.getWizard().onRightClick(player,npc);
      }
      if (npc.isBlacksmith()) {
        npc.getBlacksmith().onRightClick(player,npc);
      }
      if (npc.isBandit()) {
        npc.getBandit().onRightClick(player,npc);
      }
      if (npc.isQuester()) {
        npc.getQuester().onRightClick(player,npc);
      }
    }
  }
}","@Override public void onEntityTarget(EntityTargetEvent event){
  if (!(event instanceof NPCEntityTargetEvent)) {
    return;
  }
  NPCEntityTargetEvent e=(NPCEntityTargetEvent)event;
  if (CreatureTask.getCreature(event.getEntity()) != null) {
    HumanNPC creature=CreatureTask.getCreature(event.getEntity()).npc;
    if (creature.isEvil()) {
      if (e.getNpcReason() == NpcTargetReason.NPC_RIGHTCLICKED) {
        creature.getEvil().onRightClick((Player)event.getTarget(),creature);
      }
    }
  }
  if (NPCManager.isNPC(event.getTarget())) {
    event.setCancelled(true);
  }
  HumanNPC npc=NPCManager.get(e.getEntity());
  if (npc != null && event.getTarget() instanceof Player) {
    if (e.getNpcReason() == NpcTargetReason.NPC_RIGHTCLICKED) {
      Player player=(Player)event.getTarget();
      if (plugin.validateTool(""String_Node_Str"",player.getItemInHand().getTypeId(),player.isSneaking()) == true) {
        if (!NPCManager.validateSelected(player,npc.getUID())) {
          NPCManager.selectedNPCs.put(player.getName(),npc.getUID());
          player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str"");
          return;
        }
      }
      if (plugin.validateTool(""String_Node_Str"",player.getItemInHand().getTypeId(),player.isSneaking()) == true) {
        CitizensBasicNPCEvent ev=new CitizensBasicNPCEvent(npc,(Player)e.getTarget(),MessageUtils.getText(npc,(Player)e.getTarget()));
        plugin.getServer().getPluginManager().callEvent(ev);
      }
      if (npc.isTrader()) {
        npc.getTrader().onRightClick(player,npc);
      }
      if (npc.isWizard()) {
        npc.getWizard().onRightClick(player,npc);
      }
      if (npc.isBlacksmith()) {
        npc.getBlacksmith().onRightClick(player,npc);
      }
      if (npc.isBandit()) {
        npc.getBandit().onRightClick(player,npc);
      }
      if (npc.isQuester()) {
        npc.getQuester().onRightClick(player,npc);
      }
    }
  }
}",0.7888999008919723
1919,"/** 
 * Purchase an item repair
 * @param player
 * @param npc
 * @param op
 */
private void buyItemRepair(Player player,HumanNPC npc,ItemStack item,Operation op){
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(op,player)) {
    if (item.getDurability() > 0) {
      double paid=EconomyHandler.payBlacksmith(op,player);
      if (paid > 0) {
        item.setDurability((short)0);
        player.setItemInHand(item);
        String msg=StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"";
        if (EconomyHandler.useIconomy()) {
          msg+=StringUtils.wrap(EconomyHandler.getPaymentType(op,""String_Node_Str"" + paid,ChatColor.YELLOW));
        }
 else {
          msg+=StringUtils.wrap(ItemInterface.getBlacksmithPrice(player,item,op) + ""String_Node_Str"" + ItemInterface.getCurrencyName(op));
        }
        msg+=ChatColor.GREEN + ""String_Node_Str"";
        player.sendMessage(msg);
      }
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
  }
 else   if (EconomyHandler.useEconomy()) {
    player.sendMessage(MessageUtils.getNoMoneyMessage(op,player));
    return;
  }
}","/** 
 * Purchase an item repair
 * @param player
 * @param npc
 * @param op
 */
private void buyItemRepair(Player player,HumanNPC npc,ItemStack item,Operation op){
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(op,player)) {
    if (item.getDurability() > 0) {
      double paid=EconomyHandler.payBlacksmith(op,player);
      if (paid > 0) {
        item.setDurability((short)0);
        player.setItemInHand(item);
        String msg=StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"";
        if (EconomyHandler.useIconomy()) {
          msg+=StringUtils.wrap(EconomyHandler.getPaymentType(op,""String_Node_Str"" + paid));
        }
 else {
          msg+=StringUtils.wrap(ItemInterface.getBlacksmithCurrency(player,op));
        }
        msg+=ChatColor.GREEN + ""String_Node_Str"";
        player.sendMessage(msg);
      }
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
  }
 else   if (EconomyHandler.useEconomy()) {
    player.sendMessage(MessageUtils.getNoMoneyMessage(op,player));
    return;
  }
}",0.9584285061671995
1920,"@Override public void onRightClick(Player player,HumanNPC npc){
  if (player.getItemInHand().getTypeId() == Constants.evilNPCTameItem) {
    if (new Random().nextInt(100) <= Constants.evilNPCTameChance) {
      setTame(true);
      npc.setEvil(false);
      NPCManager.register(npc.getName(),player.getLocation(),player.getName());
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str"");
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + npc.getStrippedName()+ ""String_Node_Str""+ ChatColor.WHITE+ MessageUtils.getRandomMessage(Constants.failureToTameMessages));
    }
  }
}","@Override public void onRightClick(Player player,HumanNPC npc){
  if (player.getItemInHand().getTypeId() == Constants.evilNPCTameItem) {
    if (new Random().nextInt(100) <= Constants.evilNPCTameChance) {
      setTame(true);
      npc.setEvil(false);
      CreatureTask.despawn(CreatureTask.getCreature(npc.getHandle().getBukkitEntity()));
      int UID=NPCManager.register(npc.getName(),player.getLocation(),player.getName());
      PropertyManager.getBasic().saveNPCAmountPerPlayer(player.getName(),PropertyManager.getBasic().getNPCAmountPerPlayer(player.getName()) + 1);
      NPCManager.get(UID).getNPCData().setOwner(player.getName());
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str"");
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + npc.getStrippedName()+ ""String_Node_Str""+ ChatColor.WHITE+ MessageUtils.getRandomMessage(Constants.failureToTameMessages));
    }
  }
}",0.8112058465286236
1921,"/** 
 * Purchase a heal from a healer
 * @param player
 * @param npc
 * @param op
 */
private void buyHeal(Player player,HumanNPC npc,Operation op,boolean healPlayer){
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(op,player)) {
    double paid=EconomyHandler.pay(op,player);
    if (paid > 0) {
      int playerHealth=0;
      int healerHealth=0;
      String msg=StringUtils.wrap(npc.getStrippedName());
      if (healPlayer) {
        playerHealth=player.getHealth() + 1;
        healerHealth=npc.getHealer().getHealth() - 1;
        msg+=""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(op,""String_Node_Str"" + paid,ChatColor.YELLOW)) + ""String_Node_Str"";
      }
 else {
        playerHealth=player.getHealth();
        healerHealth=npc.getHealer().getHealth() + 1;
        msg+=""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(op,""String_Node_Str"" + paid,ChatColor.YELLOW)) + ""String_Node_Str"";
      }
      player.setHealth(playerHealth);
      npc.getHealer().setHealth(healerHealth);
      player.sendMessage(msg);
    }
  }
 else   if (EconomyHandler.useEconomy()) {
    player.sendMessage(MessageUtils.getNoMoneyMessage(Operation.HEALER_HEAL,player));
    return;
  }
}","/** 
 * Purchase a heal from a healer
 * @param player
 * @param npc
 * @param op
 */
private void buyHeal(Player player,HumanNPC npc,Operation op,boolean healPlayer){
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(op,player)) {
    double paid=EconomyHandler.pay(op,player);
    if (paid > 0) {
      int playerHealth=0;
      int healerHealth=0;
      String msg=StringUtils.wrap(npc.getStrippedName());
      if (healPlayer) {
        playerHealth=player.getHealth() + 1;
        healerHealth=npc.getHealer().getHealth() - 1;
        msg+=""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(op,""String_Node_Str"" + paid)) + ""String_Node_Str"";
      }
 else {
        playerHealth=player.getHealth();
        healerHealth=npc.getHealer().getHealth() + 1;
        msg+=""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(op,""String_Node_Str"" + paid)) + ""String_Node_Str"";
      }
      player.setHealth(playerHealth);
      npc.getHealer().setHealth(healerHealth);
      player.sendMessage(msg);
    }
  }
 else   if (EconomyHandler.useEconomy()) {
    player.sendMessage(MessageUtils.getNoMoneyMessage(Operation.HEALER_HEAL,player));
    return;
  }
}",0.985973597359736
1922,"/** 
 * Purchase a teleport
 * @param player
 * @param wizard
 * @param op
 */
public static void buy(Player player,HumanNPC npc,Operation op){
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(op,player)) {
    if (EconomyHandler.useEconomy()) {
      boolean canSend=false;
      double paid=EconomyHandler.pay(op,player);
      if (paid > 0) {
        String msg=ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(op,""String_Node_Str"" + paid,ChatColor.YELLOW));
switch (op) {
case WIZARD_TELEPORT:
          msg+=""String_Node_Str"" + StringUtils.wrap(npc.getWizard().getCurrentLocationName()) + ""String_Node_Str"";
        if (teleportPlayer(player,npc)) {
          canSend=true;
        }
      break;
case WIZARD_SPAWNMOB:
    msg+=""String_Node_Str"" + StringUtils.wrap(npc.getWizard().getMob().name().toLowerCase().replace(""String_Node_Str"",""String_Node_Str"")) + ""String_Node_Str"";
  if (spawnMob(player,npc)) {
    canSend=true;
  }
break;
case WIZARD_CHANGETIME:
msg+=""String_Node_Str"" + StringUtils.wrap(npc.getWizard().getTime()) + ""String_Node_Str"";
if (changeTime(player,npc)) {
canSend=true;
}
break;
case WIZARD_TOGGLESTORM:
msg+=""String_Node_Str"" + StringUtils.wrap(player.getWorld().getName()) + ""String_Node_Str"";
if (toggleStorm(player,npc)) {
canSend=true;
}
break;
default :
msg=ChatColor.RED + ""String_Node_Str"";
canSend=true;
break;
}
if (canSend) {
player.sendMessage(msg);
}
}
}
 else {
player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
}
}
 else if (EconomyHandler.useEconomy()) {
player.sendMessage(MessageUtils.getNoMoneyMessage(op,player));
return;
}
}","/** 
 * Purchase a teleport
 * @param player
 * @param wizard
 * @param op
 */
public static void buy(Player player,HumanNPC npc,Operation op){
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(op,player)) {
    if (EconomyHandler.useEconomy()) {
      boolean canSend=false;
      double paid=EconomyHandler.pay(op,player);
      if (paid > 0) {
        String msg=ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(op,""String_Node_Str"" + paid));
switch (op) {
case WIZARD_TELEPORT:
          msg+=""String_Node_Str"" + StringUtils.wrap(npc.getWizard().getCurrentLocationName()) + ""String_Node_Str"";
        if (teleportPlayer(player,npc)) {
          canSend=true;
        }
      break;
case WIZARD_SPAWNMOB:
    msg+=""String_Node_Str"" + StringUtils.wrap(npc.getWizard().getMob().name().toLowerCase().replace(""String_Node_Str"",""String_Node_Str"")) + ""String_Node_Str"";
  if (spawnMob(player,npc)) {
    canSend=true;
  }
break;
case WIZARD_CHANGETIME:
msg+=""String_Node_Str"" + StringUtils.wrap(npc.getWizard().getTime()) + ""String_Node_Str"";
if (changeTime(player,npc)) {
canSend=true;
}
break;
case WIZARD_TOGGLESTORM:
msg+=""String_Node_Str"" + StringUtils.wrap(player.getWorld().getName()) + ""String_Node_Str"";
if (toggleStorm(player,npc)) {
canSend=true;
}
break;
default :
msg=ChatColor.RED + ""String_Node_Str"";
canSend=true;
break;
}
if (canSend) {
player.sendMessage(msg);
}
}
}
 else {
player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
}
}
 else if (EconomyHandler.useEconomy()) {
player.sendMessage(MessageUtils.getNoMoneyMessage(op,player));
return;
}
}",0.9947514665020069
1923,"@SuppressWarnings(""String_Node_Str"") private int generateUID(){
  boolean found=false;
  int UID=0;
  while (found != true) {
    UID=new Random().nextInt();
    if (!GlobalUIDs.containsKey(UID)) {
      found=true;
      break;
    }
  }
  return UID;
}","@SuppressWarnings(""String_Node_Str"") private int generateUID(){
  boolean found=false;
  int UID=0;
  while (!found) {
    UID=new Random().nextInt();
    if (!GlobalUIDs.containsKey(UID)) {
      found=true;
      break;
    }
  }
  return UID;
}",0.9660678642714572
1924,"/** 
 * Checks whether two locations are within a certain distance of each other.
 * @param loc
 * @param pLoc
 * @param range
 * @return
 */
public static boolean checkLocation(Location loc,Location pLoc,double range){
  if (!loc.getWorld().getName().equals(pLoc.getWorld().getName())) {
    return false;
  }
  double pX=pLoc.getX(), pY=pLoc.getY(), pZ=pLoc.getZ();
  double lX=loc.getX(), lY=loc.getY(), lZ=loc.getZ();
  if ((pX <= lX + range && pX >= lX - range) && (pY >= lY - range && pY <= lY + range) && (pZ >= lZ - range && pZ <= lZ + range)) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Checks whether two locations are within range of each other.
 * @param loc
 * @param pLoc
 * @param range
 * @return
 */
public static boolean checkLocation(Location loc,Location pLoc,double range){
  if (!loc.getWorld().getName().equals(pLoc.getWorld().getName())) {
    return false;
  }
  double pX=pLoc.getX(), pY=pLoc.getY(), pZ=pLoc.getZ();
  double lX=loc.getX(), lY=loc.getY(), lZ=loc.getZ();
  if ((pX <= lX + range && pX >= lX - range) && (pY >= lY - range && pY <= lY + range) && (pZ >= lZ - range && pZ <= lZ + range)) {
    return true;
  }
 else {
    return false;
  }
}",0.9824854045037532
1925,"/** 
 * Formats the not enough money message for an operation.
 * @param op
 * @param player
 * @return
 */
public static String getNoMoneyMessage(Operation op,Player player){
  String message=""String_Node_Str"";
  message=ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(op,EconomyHandler.getRemainder(op,player),ChatColor.RED),ChatColor.RED)+ ""String_Node_Str"";
  return message;
}","/** 
 * Formats the not enough money message for an operation.
 * @param op
 * @param player
 * @return
 */
public static String getNoMoneyMessage(Operation op,Player player){
  String message=""String_Node_Str"";
  message=ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(op,EconomyHandler.getRemainder(op,player)),ChatColor.RED)+ ""String_Node_Str"";
  return message;
}",0.982885085574572
1926,"/** 
 * Pulls a random message from a string of messages split by a semi-colon
 * @param messages
 * @return
 */
public static String getRandomMessage(String messages){
  String[] split=messages.split(""String_Node_Str"");
  String text=""String_Node_Str"";
  text=split[new Random().nextInt(split.length)];
  if (text.equals(Constants.defaultText)) {
    return text.replace('&','');
  }
  return text;
}","/** 
 * Pulls a random message from a string of messages split by a semi-colon
 * @param messages
 * @return
 */
public static String getRandomMessage(String messages){
  String[] split=messages.split(""String_Node_Str"");
  String text=split[new Random().nextInt(split.length)];
  if (text.equals(Constants.defaultText)) {
    return text.replace('&','');
  }
  return text;
}",0.9665809768637532
1927,"/** 
 * Gets the text to be said for a basic npc.
 * @param npc
 * @param player
 * @param plugin
 * @return
 */
public static String getText(HumanNPC npc,Player player){
  String name=StringUtils.stripColour(npc.getStrippedName());
  ArrayDeque<String> array=NPCManager.getText(npc.getUID());
  String text=""String_Node_Str"";
  if (array != null && array.size() > 0) {
    text=array.pop();
    array.addLast(text);
    NPCManager.setText(npc.getUID(),array);
  }
  if (text.isEmpty()) {
    text=getRandomMessage(Constants.defaultText);
  }
  if (!text.isEmpty()) {
    if (Constants.useNPCColours) {
      text=Constants.chatFormat.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",npc.getStrippedName()) + text;
    }
 else {
      text=Constants.chatFormat.replace(""String_Node_Str"",Constants.npcColour + name + ChatColor.WHITE).replace(""String_Node_Str"",""String_Node_Str"") + text;
    }
    return text;
  }
  return ""String_Node_Str"";
}","/** 
 * Gets the text to be said for a basic NPC
 * @param npc
 * @param player
 * @return
 */
public static String getText(HumanNPC npc,Player player){
  String name=StringUtils.stripColour(npc.getStrippedName());
  ArrayDeque<String> array=NPCManager.getText(npc.getUID());
  String text=""String_Node_Str"";
  if (array != null && array.size() > 0) {
    text=array.pop();
    array.addLast(text);
    NPCManager.setText(npc.getUID(),array);
  }
  if (text.isEmpty()) {
    text=getRandomMessage(Constants.defaultText);
  }
  if (!text.isEmpty()) {
    if (Constants.useNPCColours) {
      text=Constants.chatFormat.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",npc.getStrippedName()) + text;
    }
 else {
      text=Constants.chatFormat.replace(""String_Node_Str"",Constants.npcColour + name + ChatColor.WHITE).replace(""String_Node_Str"",""String_Node_Str"") + text;
    }
    return text;
  }
  return ""String_Node_Str"";
}",0.987434554973822
1928,"/** 
 * Formats the paid message for an operation.
 * @param op
 * @param paid
 * @param npcName
 * @param type
 * @param useType
 * @return
 */
public static String getPaidMessage(Operation op,double paid,String npcName,String type,boolean useType){
  String message=""String_Node_Str"";
  message=ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(op,""String_Node_Str"" + paid,ChatColor.GREEN))+ ""String_Node_Str"";
  if (useType) {
    message+=StringUtils.wrap(npcName) + ""String_Node_Str"" + StringUtils.wrap(type)+ ""String_Node_Str"";
  }
 else {
    message+=StringUtils.wrap(npcName) + ""String_Node_Str"";
  }
  return message;
}","/** 
 * Formats the paid message for an operation.
 * @param op
 * @param paid
 * @param npcName
 * @param type
 * @param useType
 * @return
 */
public static String getPaidMessage(Operation op,double paid,String npcName,String type,boolean useType){
  String message=""String_Node_Str"";
  message=ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(op,""String_Node_Str"" + paid))+ ""String_Node_Str"";
  if (useType) {
    message+=StringUtils.wrap(npcName) + ""String_Node_Str"" + StringUtils.wrap(type)+ ""String_Node_Str"";
  }
 else {
    message+=StringUtils.wrap(npcName) + ""String_Node_Str"";
  }
  return message;
}",0.9878048780487804
1929,"/** 
 * Alters the selected trader's balance depending on the arguments given. Balance is used for iConomy.
 * @param player
 * @param npc
 * @param args
 */
private void changeBalance(Player player,HumanNPC npc,String[] args){
  double amount;
  try {
    amount=Double.parseDouble(args[2]);
  }
 catch (  NumberFormatException e) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  if (args[1].contains(""String_Node_Str"")) {
    if (EconomyHandler.canBuy(new Payment(amount,true),player)) {
      EconomyHandler.pay(new Payment(-amount,true),npc,-1);
      EconomyHandler.pay(new Payment(amount,true),player,-1);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(amount))+ ""String_Node_Str""+ StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(ServerEconomyInterface.getFormattedBalance(player.getName()),ChatColor.GREEN)+ ""String_Node_Str"");
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + ""String_Node_Str""+ StringUtils.wrap(ServerEconomyInterface.format(amount - ServerEconomyInterface.getBalance(player.getName())),ChatColor.RED)+ ""String_Node_Str"");
    }
  }
 else   if (args[1].contains(""String_Node_Str"")) {
    if (EconomyHandler.canBuy(new Payment(amount,true),npc)) {
      EconomyHandler.pay(new Payment(amount,true),npc,-1);
      EconomyHandler.pay(new Payment(-amount,true),player,-1);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(amount))+ ""String_Node_Str""+ StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(ServerEconomyInterface.getFormattedBalance(player.getName()))+ ""String_Node_Str"");
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(amount - npc.getBalance()),ChatColor.RED)+ ""String_Node_Str"");
    }
  }
 else {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(args[1],ChatColor.RED)+ ""String_Node_Str"");
  }
}","/** 
 * Alters the selected trader's balance depending on the arguments given. Balance is used for iConomy.
 * @param player
 * @param npc
 * @param args
 */
private void changeBalance(Player player,HumanNPC npc,String[] args){
  double amount;
  try {
    amount=Double.parseDouble(args[2]);
  }
 catch (  NumberFormatException e) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  if (args[1].contains(""String_Node_Str"")) {
    if (EconomyHandler.canBuy(new Payment(amount,true),player)) {
      EconomyHandler.pay(new Payment(-amount,true),npc,-1);
      EconomyHandler.pay(new Payment(amount,true),player,-1);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(amount))+ ""String_Node_Str""+ StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(ServerEconomyInterface.getFormattedBalance(player.getName()),ChatColor.GREEN)+ ""String_Node_Str"");
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(amount - ServerEconomyInterface.getBalance(player.getName())),ChatColor.RED)+ ""String_Node_Str"");
    }
  }
 else   if (args[1].contains(""String_Node_Str"")) {
    if (EconomyHandler.canBuy(new Payment(amount,true),npc)) {
      EconomyHandler.pay(new Payment(amount,true),npc,-1);
      EconomyHandler.pay(new Payment(-amount,true),player,-1);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(amount))+ ""String_Node_Str""+ StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(ServerEconomyInterface.getFormattedBalance(player.getName()))+ ""String_Node_Str"");
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(ServerEconomyInterface.format(amount - npc.getBalance()),ChatColor.RED)+ ""String_Node_Str"");
    }
  }
 else {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.wrap(args[1],ChatColor.RED)+ ""String_Node_Str"");
  }
}",0.9953872299101724
1930,"@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    player.sendMessage(ChatColor.RED + MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!npc.isTrader()) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
  if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      HelpUtils.sendTraderHelp(sender);
    }
 else {
      player.sendMessage(MessageUtils.noPermissionsMessage);
    }
    returnval=true;
  }
 else   if (args.length >= 2 && args[0].contains(""String_Node_Str"") && (args[1].contains(""String_Node_Str"") || args[1].contains(""String_Node_Str""))) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      displayList(player,npc,args,args[1].contains(""String_Node_Str""));
    }
 else {
      player.sendMessage(MessageUtils.noPermissionsMessage);
    }
    returnval=true;
  }
 else   if (args.length == 1 && args[0].contains(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      displayMoney(player,npc);
    }
 else     player.sendMessage(MessageUtils.noPermissionsMessage);
    returnval=true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    if (!returnval) {
      player.sendMessage(MessageUtils.notOwnerMessage);
    }
    return true;
  }
 else {
    if (args.length == 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        if (!EconomyHandler.useIconomy()) {
          player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
        }
 else {
          changeBalance(player,npc,args);
        }
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 3 && (args[0].contains(""String_Node_Str"") || args[0].contains(""String_Node_Str""))) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeTraderStock(player,npc,args[1],args[2],args[0].contains(""String_Node_Str""));
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && (args[0].contains(""String_Node_Str""))) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeUnlimited(npc,sender,args[1]);
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    PropertyManager.save(npc);
  }
  return returnval;
}","@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    player.sendMessage(ChatColor.RED + MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!npc.isTrader()) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
  if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      HelpUtils.sendTraderHelp(sender);
    }
 else {
      player.sendMessage(MessageUtils.noPermissionsMessage);
    }
    returnval=true;
  }
 else   if (args.length >= 2 && args[0].contains(""String_Node_Str"") && (args[1].contains(""String_Node_Str"") || args[1].contains(""String_Node_Str""))) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      displayList(player,npc,args,args[1].contains(""String_Node_Str""));
    }
 else {
      player.sendMessage(MessageUtils.noPermissionsMessage);
    }
    returnval=true;
  }
 else   if (args.length == 1 && args[0].contains(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      if (!EconomyHandler.useIconomy())       player.sendMessage(MessageUtils.noEconomyMessage);
 else       displayMoney(player,npc);
    }
 else     player.sendMessage(MessageUtils.noPermissionsMessage);
    returnval=true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    if (!returnval) {
      player.sendMessage(MessageUtils.notOwnerMessage);
    }
    return true;
  }
 else {
    if (args.length == 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        if (!EconomyHandler.useIconomy())         player.sendMessage(MessageUtils.noEconomyMessage);
 else         changeBalance(player,npc,args);
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 3 && (args[0].contains(""String_Node_Str"") || args[0].contains(""String_Node_Str""))) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeTraderStock(player,npc,args[1],args[2],args[0].contains(""String_Node_Str""));
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && (args[0].contains(""String_Node_Str""))) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeUnlimited(npc,sender,args[1]);
      }
 else {
        player.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
    PropertyManager.save(npc);
  }
  return returnval;
}",0.9518480840963038
1931,"private void saveStockables(int UID,ConcurrentHashMap<Check,Stockable> stockables){
  String string=""String_Node_Str"";
  setStockables(UID,string);
  int count=0;
  for (  Stockable entry : stockables.values()) {
    if (!string.contains(entry.toString()))     string+=entry.toString();
    count+=1;
  }
  setStockables(UID,string);
}","private void saveStockables(int UID,ConcurrentHashMap<Check,Stockable> stockables){
  String string=""String_Node_Str"";
  setStockables(UID,string);
  int count=0;
  for (  Stockable entry : stockables.values()) {
    if (!string.contains(entry.toString()))     string+=(entry.toString() + ""String_Node_Str"");
    count+=1;
  }
  setStockables(UID,string);
}",0.9682080924855492
1932,"public static HumanNPC spawnBasicHumanNpc(int UID,String name,World world,double x,double y,double z,float yaw,float pitch){
  try {
    WorldServer ws=getWorldServer(world);
    MinecraftServer ms=getMinecraftServer(ws.getServer());
    CraftNPC eh=new CraftNPC(ms,ws,name,new ItemInWorldManager(ws));
    eh.setPositionRotation(x,y,z,yaw,pitch);
    ws.addEntity(eh);
    ws.players.remove(eh);
    return new HumanNPC(eh,UID,name);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}","public static HumanNPC spawnBasicHumanNpc(int UID,String name,World world,double x,double y,double z,float yaw,float pitch){
  try {
    WorldServer ws=getWorldServer(world);
    MinecraftServer ms=getMinecraftServer(ws.getServer());
    CraftNPC eh=new CraftNPC(ms,ws,name,new ItemInWorldManager(ws));
    eh.setLocation(x,y,z,yaw,pitch);
    ws.addEntity(eh);
    ws.players.remove(eh);
    return new HumanNPC(eh,UID,name);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}",0.986138613861386
1933,"@Override public synchronized void save(){
  try {
    this.properties.store(new FileOutputStream(this.fileName),""String_Node_Str"");
  }
 catch (  IOException ex) {
    Messaging.log(""String_Node_Str"" + this.fileName,Level.SEVERE);
  }
}","@Override public synchronized void save(){
  FileOutputStream stream=null;
  try {
    stream=new FileOutputStream(this.fileName);
    this.properties.store(stream,""String_Node_Str"");
  }
 catch (  IOException ex) {
    Messaging.log(""String_Node_Str"" + this.fileName,Level.SEVERE);
  }
 finally {
    try {
      if (stream != null)       stream.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}",0.6426426426426426
1934,"@Override public synchronized void load(){
  try {
    this.properties.load(new FileInputStream(this.fileName));
  }
 catch (  Exception ex) {
    Messaging.log(""String_Node_Str"" + this.fileName,Level.SEVERE);
  }
}","@Override public synchronized void load(){
  FileInputStream stream=null;
  try {
    stream=new FileInputStream(this.fileName);
    this.properties.load(stream);
  }
 catch (  Exception ex) {
    Messaging.log(""String_Node_Str"" + this.fileName,Level.SEVERE);
  }
 finally {
    try {
      if (stream != null)       stream.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}",0.6215780998389694
1935,"/** 
 * Checks the inventory of a player for having enough for a payment.
 * @param payment
 * @param player
 * @return
 */
public static boolean hasEnough(Payment payment,Player player){
  int current=0;
  if (payment.getPrice() <= 0)   return true;
  for (  ItemStack i : player.getInventory().getContents()) {
    if (i != null && i.getTypeId() == payment.getItem().getTypeId()) {
      current+=i.getAmount();
      if (current >= payment.getPrice()) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * Checks the inventory of a player for having enough for a payment.
 * @param payment
 * @param player
 * @return
 */
public static boolean hasEnough(Payment payment,Player player){
  int current=0;
  if (payment.getItem().getAmount() <= 0 || payment.getItem().getTypeId() == 0) {
    return true;
  }
  for (  ItemStack i : player.getInventory().getContents()) {
    if (i != null && i.getTypeId() == payment.getItem().getTypeId()) {
      current+=i.getAmount();
      if (current >= payment.getPrice()) {
        return true;
      }
    }
  }
  return false;
}",0.9362880886426592
1936,"/** 
 * Pays for a payment from the player's inventory.
 * @param player
 * @param payment
 * @param slot
 * @return
 */
public static double pay(Player player,Payment payment,int slot){
  int currencyID=payment.getItem().getTypeId();
  double current=payment.getPrice();
  if (current <= 0)   return payment.getPrice();
  int count=0;
  if (slot != -1) {
    current=decreaseItemStack(player,currencyID,current,slot);
  }
  if (current <= 0)   return payment.getPrice();
  for (  ItemStack item : player.getInventory().getContents()) {
    if (item != null) {
      current=decreaseItemStack(player,currencyID,current,count);
      if (current <= 0)       break;
    }
    count+=1;
  }
  return payment.getPrice();
}","/** 
 * Pays for a payment from the player's inventory.
 * @param player
 * @param payment
 * @param slot
 * @return
 */
public static double pay(Player player,Payment payment,int slot){
  int currencyID=payment.getItem().getTypeId();
  double current=payment.getPrice();
  if (current <= 0)   return current;
  int count=0;
  if (slot != -1) {
    current=decreaseItemStack(player,currencyID,current,slot);
  }
  if (current <= 0)   return payment.getPrice();
  for (  ItemStack item : player.getInventory().getContents()) {
    if (item != null) {
      current=decreaseItemStack(player,currencyID,current,count);
      if (current <= 0)       break;
    }
    count+=1;
  }
  return payment.getPrice();
}",0.5950877192982457
1937,"/** 
 * Get the price for repairing an item
 * @param player
 * @param item
 * @param op
 * @return
 */
public static int getBlacksmithPrice(Player player,ItemStack item,Operation op){
  short maxDurability=Material.getMaterial(item.getTypeId()).getMaxDurability();
  double percentage=((double)maxDurability - item.getDurability()) / maxDurability;
  price=(1.0 - percentage) * UtilityProperties.getPrice(Operation.getString(op,addendum));
  if (price < 1.0) {
    price+=1;
  }
  return (int)price;
}","/** 
 * Get the price for repairing an item
 * @param player
 * @param item
 * @param op
 * @return
 */
public static int getBlacksmithPrice(Player player,ItemStack item,Operation op){
  short maxDurability=Material.getMaterial(item.getTypeId()).getMaxDurability();
  double percentage=((double)maxDurability - item.getDurability()) / maxDurability;
  blacksmithPrice=(1.0 - percentage) * UtilityProperties.getPrice(Operation.getString(op,addendum));
  if (blacksmithPrice < 1.0) {
    blacksmithPrice+=1;
  }
  return (int)blacksmithPrice;
}",0.9540229885057472
1938,"/** 
 * Pays for a blacksmith operation
 * @param player
 * @param item
 * @param op
 * @return
 */
public static double payBlacksmith(Player player,ItemStack item,Operation op){
  int currencyID=UtilityProperties.getCurrencyID(Operation.getString(op,currencyAddendum));
  double current=getBlacksmithPrice(player,item,op);
  int count=0;
  for (  ItemStack i : player.getInventory().getContents()) {
    if (i != null) {
      current=decreaseItemStack(player,currencyID,current,count);
      if (current <= 0)       break;
    }
    count+=1;
  }
  return price;
}","/** 
 * Pays for a blacksmith operation
 * @param player
 * @param item
 * @param op
 * @return
 */
public static double payBlacksmith(Player player,ItemStack item,Operation op){
  int currencyID=UtilityProperties.getCurrencyID(Operation.getString(op,currencyAddendum));
  double current=getBlacksmithPrice(player,item,op);
  if (current <= 0 || currencyID == 0) {
    return blacksmithPrice;
  }
  int count=0;
  for (  ItemStack i : player.getInventory().getContents()) {
    if (i != null) {
      current=decreaseItemStack(player,currencyID,current,count);
      if (current <= 0)       break;
    }
    count+=1;
  }
  return blacksmithPrice;
}",0.9300411522633744
1939,"@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    sender.sendMessage(ChatColor.RED + MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    sender.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (!npc.isBandit()) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        HelpUtils.sendBanditHelp(sender);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      return true;
    }
 else     if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        addStealableItem(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
  }
  return returnval;
}","@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
 else {
    sender.sendMessage(ChatColor.RED + MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    sender.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (!npc.isBandit()) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        HelpUtils.sendBanditHelp(sender);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      return true;
    }
 else     if (args.length == 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          changeStealable(player,npc,args[2],true);
        }
 else         if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
          changeStealable(player,npc,args[2],false);
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
  }
  return returnval;
}",0.9117355371900826
1940,"@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  if (NPCManager.validateSelected(player)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
  if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canCreate(player,""String_Node_Str"")) {
      if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(Operation.BASIC_CREATION,player)) {
        create(args,player);
      }
 else       if (EconomyHandler.useEconomy()) {
        sender.sendMessage(MessageUtils.getNoMoneyMessage(Operation.BASIC_CREATION,player));
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        move(player,npc.getName(),npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if ((args.length == 1 || args.length == 2) && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        remove(args,sender,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        rename(args[1],sender,npc);
        NPCManager.selectedNPCs.remove(player.getName());
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str""))) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        setColour(args,player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.notOwnerMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        addText(args,sender,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        setText(args,sender,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        resetText(args,sender,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        setItemInHand(args[1],sender,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].startsWith(""String_Node_Str"") || args[0].startsWith(""String_Node_Str"")|| args[0].startsWith(""String_Node_Str""))) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        setArmor(args,sender,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length >= 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        player.teleport(npc.getNPCData().getLocation());
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        copy(npc.getUID(),npc.getName(),player);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      if (!Character.isDigit(args[1].charAt(0))) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        return true;
      }
      npc=NPCManager.get(Integer.valueOf(args[1]));
      if (npc == null) {
        sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[1]+ ""String_Node_Str"");
      }
 else {
        NPCManager.selectedNPCs.put(player.getName(),npc.getUID());
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str""+ StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str"");
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getOwner())+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        setOwner(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeTalkWhenClose(args[1],player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeLookWhenClose(args[1],player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if ((command.getName().equalsIgnoreCase(""String_Node_Str"") || command.getName().equalsIgnoreCase(""String_Node_Str""))) {
    if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        HelpUtils.sendHelp(sender,1);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else     if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        int page=Integer.parseInt(args[1]);
        HelpUtils.sendHelp(sender,page);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
    return true;
  }
 else   if (command.getName().equalsIgnoreCase(""String_Node_Str"")) {
    if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        int page=Integer.parseInt(args[1]);
        HelpUtils.sendBasicHelpPage(sender,page);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      return true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        HelpUtils.sendBasicHelpPage(sender,1);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      return true;
    }
  }
 else {
    if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str"")|| args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
    }
 else     if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else {
      return false;
    }
  }
  PropertyManager.get(""String_Node_Str"").saveState(npc);
  return false;
}","@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  if (NPCManager.validateSelected(player)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
  if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canCreate(player,""String_Node_Str"")) {
      if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(Operation.BASIC_CREATION,player)) {
        create(args,player);
      }
 else       if (EconomyHandler.useEconomy()) {
        sender.sendMessage(MessageUtils.getNoMoneyMessage(Operation.BASIC_CREATION,player));
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        move(player,npc.getName(),npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if ((args.length == 1 || args.length == 2) && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        remove(args,sender,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        rename(args[1],sender,npc);
        NPCManager.selectedNPCs.remove(player.getName());
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str""))) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        setColour(args,player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.notOwnerMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        addText(args,sender,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        setText(args,sender,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        resetText(args,sender,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        setItemInHand(args[1],sender,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].startsWith(""String_Node_Str"") || args[0].startsWith(""String_Node_Str"")|| args[0].startsWith(""String_Node_Str""))) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        setArmor(args,sender,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length >= 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        player.teleport(npc.getNPCData().getLocation());
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        copy(npc.getUID(),npc.getName(),player);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.canUse(player,npc,""String_Node_Str"")) {
      if (!Character.isDigit(args[1].charAt(0))) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        return true;
      }
      npc=NPCManager.get(Integer.valueOf(args[1]));
      if (npc == null) {
        sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[1]+ ""String_Node_Str"");
      }
 else {
        NPCManager.selectedNPCs.put(player.getName(),npc.getUID());
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str""+ StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str"");
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getOwner())+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        setOwner(player,npc,args[1]);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeTalkWhenClose(args[1],player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (npc != null) {
      if (Permission.canModify(player,npc,""String_Node_Str"")) {
        changeLookWhenClose(args[1],player,npc);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
    }
    return true;
  }
 else   if ((commandLabel.equalsIgnoreCase(""String_Node_Str"") || commandLabel.equalsIgnoreCase(""String_Node_Str""))) {
    if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        int page=0;
        boolean canSend=false;
        if (StringUtils.isNumber(args[1])) {
          page=Integer.parseInt(args[1]);
          canSend=true;
        }
 else {
          player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        }
        if (canSend) {
          HelpUtils.sendHelpPage(sender,page);
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        HelpUtils.sendHelpPage(sender,1);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
    return true;
  }
 else   if (commandLabel.equalsIgnoreCase(""String_Node_Str"")) {
    if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        int page=0;
        boolean canSend=false;
        if (StringUtils.isNumber(args[1])) {
          page=Integer.parseInt(args[1]);
          canSend=true;
        }
 else {
          player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        }
        if (canSend) {
          HelpUtils.sendBasicHelpPage(sender,page);
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.canUse(player,npc,""String_Node_Str"")) {
        HelpUtils.sendBasicHelpPage(sender,1);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
    }
    return true;
  }
 else {
    if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str"")|| args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
    }
 else     if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else {
      return false;
    }
  }
  PropertyManager.get(""String_Node_Str"").saveState(npc);
  return false;
}",0.944935262757045
1941,"@Override public void onRightClick(Player player,HumanNPC npc){
  if (Permission.canUse(player,npc,getType())) {
    Operation op=null;
    if (npc.getBlacksmith().getToolType(player.getItemInHand()).equals(""String_Node_Str"")) {
      op=Operation.BLACKSMITH_TOOLREPAIR;
    }
 else     if (npc.getBlacksmith().getToolType(player.getItemInHand()).equals(""String_Node_Str"")) {
      op=Operation.BLACKSMITH_ARMORREPAIR;
    }
    if (op != null)     npc.getBlacksmith().buyItemRepair(player,npc,player.getItemInHand(),op);
  }
 else {
    player.sendMessage(MessageUtils.noPermissionsMessage);
  }
}","@Override public void onRightClick(Player player,HumanNPC npc){
  if (Permission.canUse(player,npc,getType())) {
    Operation op=null;
    if (npc.getBlacksmith().getToolType(player.getItemInHand()).equals(""String_Node_Str"")) {
      op=Operation.BLACKSMITH_TOOLREPAIR;
    }
 else     if (npc.getBlacksmith().getToolType(player.getItemInHand()).equals(""String_Node_Str"")) {
      op=Operation.BLACKSMITH_ARMORREPAIR;
    }
    if (op != null) {
      npc.getBlacksmith().buyItemRepair(player,npc,player.getItemInHand(),op);
    }
  }
 else {
    player.sendMessage(MessageUtils.noPermissionsMessage);
  }
}",0.9917081260364844
1942,"/** 
 * Validate that the item to repair is armor
 * @param armor
 * @return
 */
public boolean validateArmor(ItemStack armor){
  int id=armor.getTypeId();
  if (id >= 298 && id <= 317) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Validate that the item to repair is armor
 * @param armor
 * @return
 */
public boolean validateArmor(ItemStack armor){
  int id=armor.getTypeId();
  if (id >= 298 && id <= 317) {
    return true;
  }
  return false;
}",0.927038626609442
1943,"/** 
 * Validate that an item has a durability and can be repaired
 * @param item
 * @return
 */
public boolean validateTool(ItemStack item){
  int id=item.getTypeId();
  if (id >= 256 && id <= 259 || id >= 267 && id <= 279 || id >= 283 && id <= 286 || id >= 290 && id <= 294 || id == 346) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Validate that an item has a durability and can be repaired
 * @param item
 * @return
 */
public boolean validateTool(ItemStack item){
  int id=item.getTypeId();
  if ((id >= 256 && id <= 259) || (id >= 267 && id <= 279) || (id >= 283 && id <= 286)|| (id >= 290 && id <= 294)|| id == 346) {
    return true;
  }
  return false;
}",0.9029411764705882
1944,"private CreatureType getMob(int UID){
  return CreatureType.valueOf(mob.getString(UID));
}","private CreatureType getMob(int UID){
  if (CreatureType.fromName(mob.getString(UID)) != null) {
    return CreatureType.fromName(mob.getString(UID));
  }
  System.out.println(""String_Node_Str"");
  return CreatureType.CREEPER;
}",0.4025157232704403
1945,"/** 
 * Moves the selected NPC to the current location of a player.
 * @param sender
 * @param name
 * @param npc
 */
private void move(Player player,String name,HumanNPC npc){
  Location loc=npc.getNPCData().getLocation();
  player.sendMessage(StringUtils.wrap(name) + ""String_Node_Str"");
  npc.getNPCData().setLocation(loc);
  npc.moveTo(player.getLocation());
}","/** 
 * Moves the selected NPC to the current location of a player.
 * @param sender
 * @param name
 * @param npc
 */
private void move(Player player,String name,HumanNPC npc){
  Location loc=npc.getNPCData().getLocation();
  player.sendMessage(StringUtils.wrap(name) + ""String_Node_Str"");
  npc.getNPCData().setLocation(loc);
  npc.teleport(player.getLocation());
}",0.9808219178082191
1946,"/** 
 * Copies an npc's data and position to another npc.
 * @param npc
 * @param p
 */
private void copy(int UID,String name,Player p){
  int newUID=NPCManager.register(name,p.getLocation(),p.getName());
  HumanNPC newNPC=NPCManager.get(newUID);
  newNPC.moveTo(p.getLocation());
  newNPC.getNPCData().setLocation(p.getLocation());
  PropertyManager.copy(UID,newUID);
  NPCManager.removeForRespawn(newUID);
  NPCManager.register(name,newUID,newNPC.getOwner());
}","/** 
 * Copies an npc's data and position to another npc.
 * @param npc
 * @param p
 */
private void copy(int UID,String name,Player p){
  int newUID=NPCManager.register(name,p.getLocation(),p.getName());
  HumanNPC newNPC=NPCManager.get(newUID);
  newNPC.teleport(p.getLocation());
  newNPC.getNPCData().setLocation(p.getLocation());
  PropertyManager.copy(UID,newUID);
  NPCManager.removeForRespawn(newUID);
  NPCManager.register(name,newUID,newNPC.getOwner());
}",0.9849137931034484
1947,"@Override public void onRightClick(Player player,HumanNPC npc){
  if (Permission.canUse(player,npc,getType())) {
    Operation op=null;
    if (npc.getBlacksmith().getToolType(player.getItemInHand()).equals(""String_Node_Str"")) {
      op=Operation.BLACKSMITH_TOOLREPAIR;
    }
 else     if (npc.getBlacksmith().getToolType(player.getItemInHand()).equals(""String_Node_Str"")) {
      op=Operation.BLACKSMITH_ARMORREPAIR;
    }
    npc.getBlacksmith().buyItemRepair(player,npc,player.getItemInHand(),op);
  }
 else {
    player.sendMessage(MessageUtils.noPermissionsMessage);
  }
}","@Override public void onRightClick(Player player,HumanNPC npc){
  if (Permission.canUse(player,npc,getType())) {
    Operation op=null;
    if (npc.getBlacksmith().getToolType(player.getItemInHand()).equals(""String_Node_Str"")) {
      op=Operation.BLACKSMITH_TOOLREPAIR;
    }
 else     if (npc.getBlacksmith().getToolType(player.getItemInHand()).equals(""String_Node_Str"")) {
      op=Operation.BLACKSMITH_ARMORREPAIR;
    }
    if (op != null)     npc.getBlacksmith().buyItemRepair(player,npc,player.getItemInHand(),op);
  }
 else {
    player.sendMessage(MessageUtils.noPermissionsMessage);
  }
}",0.9829931972789115
1948,"/** 
 * Validate that an item has a durability and can be repaired
 * @param item
 * @return
 */
public boolean validateTool(ItemStack item){
  int id=item.getTypeId();
  if (id == 256 || id == 257 || id == 258 || id == 259 || id == 267 || id == 268 || id == 269 || id == 270 || id == 271 || id == 272 || id == 273 || id == 274 || id == 275 || id == 276 || id == 277 || id == 278 || id == 279 || id == 283 || id == 284 || id == 285 || id == 286 || id == 290 || id == 291 || id == 292 || id == 293 || id == 294 || id == 346) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Validate that an item has a durability and can be repaired
 * @param item
 * @return
 */
public boolean validateTool(ItemStack item){
  int id=item.getTypeId();
  if (id >= 256 && id <= 259 || id >= 267 && id <= 279 || id >= 283 && id <= 286 || id >= 290 && id <= 294 || id == 346) {
    return true;
  }
 else {
    return false;
  }
}",0.6767895878524945
1949,"@Override public void run(){
  for (  Entry<Integer,HumanNPC> entry : NPCManager.getList().entrySet()) {
    HumanNPC npc=entry.getValue();
    if (npc.isGuard()) {
      GuardNPC guard=npc.getGuard();
      if (guard.isBouncer()) {
        Location loc=npc.getLocation();
        for (        Entity temp : npc.getPlayer().getNearbyEntities(guard.getHalvedRadius(),guard.getProtectionRadius(),guard.getHalvedRadius())) {
          if (!(temp instanceof LivingEntity)) {
            continue;
          }
          entity=(LivingEntity)temp;
          String name=""String_Node_Str"";
          if (entity instanceof Player) {
            Player player=(Player)entity;
            if (!NPCManager.validateOwnership(player,npc.getUID())) {
              name=player.getName();
            }
          }
 else {
            name=getTypeFromEntity(entity);
          }
          if (LocationUtils.checkLocation(loc,entity.getLocation(),npc.getGuard().getProtectionRadius())) {
            cacheActions(npc,entity,entity.getEntityId(),name);
          }
 else {
            resetActions(entity.getEntityId(),name,npc);
          }
        }
        entity=null;
      }
 else       if (guard.isBodyguard()) {
        String owner=npc.getOwner();
        Player p=Bukkit.getServer().getPlayer(owner);
        if (p != null && p.isOnline()) {
          Location ownerloc=p.getLocation();
          if (NPCManager.get(npc.getUID()) == null) {
            npc.getNPCData().setLocation(p.getLocation());
          }
          for (          Entity temp : p.getNearbyEntities(ownerloc.getX(),ownerloc.getY(),ownerloc.getZ())) {
            if (!(temp instanceof LivingEntity)) {
              continue;
            }
            entity=(LivingEntity)temp;
            String name=""String_Node_Str"";
            if (entity instanceof Player) {
              Player player=(Player)entity;
              if (!NPCManager.validateOwnership(player,npc.getUID())) {
                name=player.getName();
              }
            }
 else {
              name=getTypeFromEntity(entity);
            }
            if (LocationUtils.checkLocation(ownerloc,entity.getLocation(),25)) {
              cacheActions(npc,entity,entity.getEntityId(),name);
            }
 else {
              resetActions(entity.getEntityId(),name,npc);
            }
          }
          entity=null;
          if (LocationUtils.checkLocation(npc.getLocation(),p.getLocation(),25)) {
            npc.target(p,false,-1,2,25);
          }
 else {
            npc.moveTo(p.getLocation());
          }
        }
 else {
          if (NPCManager.get(npc.getUID()) != null) {
            PathUtils.cancelPath(npc);
            NPCManager.despawn(npc.getUID());
          }
        }
      }
    }
  }
}","@Override public void run(){
  for (  Entry<Integer,HumanNPC> entry : NPCManager.getList().entrySet()) {
    HumanNPC npc=entry.getValue();
    if (npc.isGuard()) {
      GuardNPC guard=npc.getGuard();
      if (guard.isBouncer()) {
        Location loc=npc.getLocation();
        for (        Entity temp : npc.getPlayer().getNearbyEntities(guard.getHalvedRadius(),guard.getProtectionRadius(),guard.getHalvedRadius())) {
          if (!(temp instanceof LivingEntity)) {
            continue;
          }
          entity=(LivingEntity)temp;
          String name=""String_Node_Str"";
          if (entity instanceof Player) {
            Player player=(Player)entity;
            if (!NPCManager.validateOwnership(player,npc.getUID())) {
              name=player.getName();
            }
          }
 else {
            name=getTypeFromEntity(entity);
          }
          if (LocationUtils.checkLocation(loc,entity.getLocation(),npc.getGuard().getProtectionRadius())) {
            cacheActions(npc,entity,entity.getEntityId(),name);
          }
 else {
            resetActions(entity.getEntityId(),name,npc);
          }
        }
        entity=null;
      }
 else       if (guard.isBodyguard()) {
        String owner=npc.getOwner();
        Player p=Bukkit.getServer().getPlayer(owner);
        if (p != null && p.isOnline()) {
          Location ownerloc=p.getLocation();
          if (NPCManager.get(npc.getUID()) == null) {
            npc.getNPCData().setLocation(p.getLocation());
          }
          for (          Entity temp : p.getNearbyEntities(ownerloc.getX(),ownerloc.getY(),ownerloc.getZ())) {
            if (!(temp instanceof LivingEntity)) {
              continue;
            }
            entity=(LivingEntity)temp;
            String name=""String_Node_Str"";
            if (entity instanceof Player) {
              Player player=(Player)entity;
              if (!NPCManager.validateOwnership(player,npc.getUID())) {
                name=player.getName();
              }
            }
 else {
              name=getTypeFromEntity(entity);
            }
            if (LocationUtils.checkLocation(ownerloc,entity.getLocation(),25)) {
              cacheActions(npc,entity,entity.getEntityId(),name);
            }
 else {
              resetActions(entity.getEntityId(),name,npc);
            }
          }
          entity=null;
          if (LocationUtils.checkLocation(npc.getLocation(),p.getLocation(),25)) {
            npc.target(p,false,-1,2,25);
          }
 else {
            npc.teleport(p.getLocation());
          }
        }
 else {
          if (NPCManager.get(npc.getUID()) != null) {
            PathUtils.cancelPath(npc);
            NPCManager.despawn(npc.getUID());
          }
        }
      }
    }
  }
}",0.9974610083424011
1950,"@Override public void onRightClick(Player player,HumanNPC npc){
  if (npc.getTrader().isFree()) {
    Mode mode;
    if (NPCManager.validateOwnership(player,npc.getUID())) {
      if (!Permission.canModify(player,npc,""String_Node_Str"")) {
        return;
      }
      mode=Mode.STOCK;
    }
 else     if (npc.getTrader().isUnlimited()) {
      mode=Mode.INFINITE;
      if (!Permission.canUse(player,npc,""String_Node_Str"")) {
        return;
      }
    }
 else {
      mode=Mode.NORMAL;
      if (!Permission.canUse(player,npc,""String_Node_Str"")) {
        return;
      }
    }
    TraderTask task=new TraderTask(npc,player,Citizens.plugin,mode);
    int id=Bukkit.getServer().getScheduler().scheduleSyncRepeatingTask(Citizens.plugin,task,2,0);
    TraderManager.tasks.add(id);
    task.addID(id);
    npc.getTrader().setFree(false);
    NPCManager.showInventory(npc,player);
  }
 else {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
  }
}","@Override public void onRightClick(Player player,HumanNPC npc){
  if (npc.getTrader().isFree()) {
    Mode mode;
    if (NPCManager.validateOwnership(player,npc.getUID())) {
      if (!Permission.canModify(player,npc,""String_Node_Str"")) {
        return;
      }
      mode=Mode.STOCK;
    }
 else     if (npc.getTrader().isUnlimited()) {
      mode=Mode.INFINITE;
      if (!Permission.canUse(player,npc,""String_Node_Str"")) {
        return;
      }
    }
 else {
      mode=Mode.NORMAL;
      if (!Permission.canUse(player,npc,""String_Node_Str"")) {
        return;
      }
    }
    TraderTask task=new TraderTask(npc,player,mode);
    int id=Bukkit.getServer().getScheduler().scheduleSyncRepeatingTask(Citizens.plugin,task,2,0);
    TraderManager.tasks.add(id);
    task.addID(id);
    npc.getTrader().setFree(false);
    NPCManager.showInventory(npc,player);
  }
 else {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
  }
}",0.9915522703273496
1951,"/** 
 * Gets run every tick, checks the inventory for changes.
 * @param npc
 * @param player
 * @param plugin
 * @param mode
 */
public TraderTask(HumanNPC npc,Player player,Citizens plugin,Mode mode){
  this.npc=npc;
  this.player=(CraftPlayer)player;
  this.mcPlayer=this.player.getHandle();
  this.plugin=plugin;
  this.previousTraderInv=new CraftInventoryPlayer(new InventoryPlayer(null));
  this.previousPlayerInv=new CraftInventoryPlayer(new InventoryPlayer(null));
  clonePlayerInventory(npc.getInventory(),this.previousTraderInv);
  clonePlayerInventory(player.getInventory(),this.previousPlayerInv);
  this.mode=mode;
  sendJoinMessage();
}","/** 
 * Gets run every tick, checks the inventory for changes.
 * @param npc
 * @param player
 * @param plugin
 * @param mode
 */
public TraderTask(HumanNPC npc,Player player,Mode mode){
  this.npc=npc;
  this.player=(CraftPlayer)player;
  this.mcPlayer=this.player.getHandle();
  this.previousTraderInv=new CraftInventoryPlayer(new InventoryPlayer(null));
  this.previousPlayerInv=new CraftInventoryPlayer(new InventoryPlayer(null));
  clonePlayerInventory(npc.getInventory(),this.previousTraderInv);
  clonePlayerInventory(player.getInventory(),this.previousPlayerInv);
  this.mode=mode;
  sendJoinMessage();
}",0.294770206022187
1952,"@Override public void run(){
  if (stop) {
    return;
  }
  if (npc == null || player == null || checkContainer(player.getHandle()) || checkContainer(npc.getHandle()) || player.getHandle().activeContainer != npc.getHandle().activeContainer || !player.isOnline()) {
    kill();
    return;
  }
  if (mode == Mode.STOCK) {
    return;
  }
  stop=true;
  int count=0;
  boolean found=false;
  for (  ItemStack i : npc.getInventory().getContents()) {
    if (!previousTraderInv.getItem(count).equals(i) && player.getHandle().inventory.j() == null) {
      restoreOldState();
      break;
    }
    if (!previousTraderInv.getItem(count).equals(i) && previousTraderInv.getItem(count).getTypeId() == mcPlayer.inventory.j().id) {
      found=true;
      handleTraderClick(count,npc.getInventory());
      break;
    }
    count+=1;
  }
  count=0;
  if (!found) {
    for (    ItemStack i : player.getInventory().getContents()) {
      if (!previousPlayerInv.getItem(count).equals(i) && player.getHandle().inventory.j() == null) {
        restoreOldState();
        break;
      }
      if (!previousPlayerInv.getItem(count).equals(i) && previousPlayerInv.getItem(count).getTypeId() == mcPlayer.inventory.j().id) {
        handlePlayerClick(count,player.getInventory());
        break;
      }
      count+=1;
    }
  }
  clonePlayerInventory(npc.getInventory(),this.previousTraderInv);
  clonePlayerInventory(player.getInventory(),this.previousPlayerInv);
  mcPlayer.inventory.b((net.minecraft.server.ItemStack)null);
  Packet103SetSlot packet=new Packet103SetSlot(-1,-1,null);
  mcPlayer.netServerHandler.sendPacket(packet);
  stop=false;
}","@Override public void run(){
  if (stop) {
    return;
  }
  if (npc == null || player == null || checkContainer(player.getHandle()) || !player.isOnline()) {
    kill();
    return;
  }
  if (mode == Mode.STOCK) {
    return;
  }
  stop=true;
  int count=0;
  boolean found=false;
  for (  ItemStack i : npc.getInventory().getContents()) {
    if (!previousTraderInv.getItem(count).equals(i) && player.getHandle().inventory.j() == null) {
      restoreOldState();
      break;
    }
    if (!previousTraderInv.getItem(count).equals(i) && previousTraderInv.getItem(count).getTypeId() == mcPlayer.inventory.j().id) {
      found=true;
      handleTraderClick(count,npc.getInventory());
      break;
    }
    count+=1;
  }
  count=0;
  if (!found) {
    for (    ItemStack i : player.getInventory().getContents()) {
      if (!previousPlayerInv.getItem(count).equals(i) && player.getHandle().inventory.j() == null) {
        restoreOldState();
        break;
      }
      if (!previousPlayerInv.getItem(count).equals(i) && previousPlayerInv.getItem(count).getTypeId() == mcPlayer.inventory.j().id) {
        handlePlayerClick(count,player.getInventory());
        break;
      }
      count+=1;
    }
  }
  clonePlayerInventory(npc.getInventory(),this.previousTraderInv);
  clonePlayerInventory(player.getInventory(),this.previousPlayerInv);
  mcPlayer.inventory.b((net.minecraft.server.ItemStack)null);
  Packet103SetSlot packet=new Packet103SetSlot(-1,-1,null);
  mcPlayer.netServerHandler.sendPacket(packet);
  stop=false;
}",0.9658227848101266
1953,"public void kill(){
  stop=true;
  this.npc.getTrader().setFree(true);
  sendLeaveMessage();
  int index=TraderManager.tasks.indexOf(taskID);
  if (index != -1) {
    TraderManager.tasks.remove(TraderManager.tasks.indexOf(taskID));
  }
  plugin.getServer().getScheduler().cancelTask(taskID);
}","public void kill(){
  stop=true;
  this.npc.getTrader().setFree(true);
  sendLeaveMessage();
  int index=TraderManager.tasks.indexOf(taskID);
  if (index != -1) {
    TraderManager.tasks.remove(TraderManager.tasks.indexOf(taskID));
  }
  Bukkit.getServer().getScheduler().cancelTask(taskID);
}",0.9795221843003412
1954,"/** 
 * Rotates an npc.
 * @param npc
 * @param player
 */
public static void facePlayer(HumanNPC npc,Player player){
  Location loc=npc.getLocation();
  double xDiff=player.getLocation().getX() - loc.getX();
  double yDiff=player.getLocation().getY() - loc.getY();
  double zDiff=player.getLocation().getZ() - loc.getZ();
  double DistanceXZ=Math.sqrt(xDiff * xDiff + zDiff * zDiff);
  double DistanceY=Math.sqrt(DistanceXZ * DistanceXZ + yDiff * yDiff);
  double yaw=(Math.acos(xDiff / DistanceXZ) * 180 / Math.PI);
  double pitch=(Math.acos(yDiff / DistanceY) * 180 / Math.PI) - 90;
  if (zDiff < 0.0) {
    yaw=yaw + (Math.abs(180 - yaw) * 2);
  }
  npc.moveTo(loc.getX(),loc.getY(),loc.getZ(),(float)yaw - 90,(float)pitch);
}","/** 
 * Rotates an npc.
 * @param npc
 * @param player
 */
public static void facePlayer(HumanNPC npc,Player player){
  Location loc=npc.getLocation();
  double xDiff=player.getLocation().getX() - loc.getX();
  double yDiff=player.getLocation().getY() - loc.getY();
  double zDiff=player.getLocation().getZ() - loc.getZ();
  double DistanceXZ=Math.sqrt(xDiff * xDiff + zDiff * zDiff);
  double DistanceY=Math.sqrt(DistanceXZ * DistanceXZ + yDiff * yDiff);
  double yaw=(Math.acos(xDiff / DistanceXZ) * 180 / Math.PI);
  double pitch=(Math.acos(yDiff / DistanceY) * 180 / Math.PI) - 90;
  if (zDiff < 0.0) {
    yaw=yaw + (Math.abs(180 - yaw) * 2);
  }
  npc.teleport(loc.getX(),loc.getY(),loc.getZ(),(float)yaw - 90,(float)pitch);
}",0.9904240766073872
1955,"public Location getActualLocationFromName(int UID){
  String[] values=locations.getString(UID).split(""String_Node_Str"");
  if (values.length != 6) {
    log.info(""String_Node_Str"" + values.length);
    return null;
  }
 else {
    Location loc=new Location(Bukkit.getServer().getWorld(values[0]),NPCManager.get(UID).getX(),NPCManager.get(UID).getY(),NPCManager.get(UID).getZ(),Float.parseFloat(values[4]),Float.parseFloat(values[5]));
    return loc;
  }
}","public Location getActualLocationFromName(int UID){
  String[] values=locations.getString(UID).split(""String_Node_Str"");
  if (values.length != 6) {
    log.info(""String_Node_Str"" + values.length);
    return null;
  }
 else {
    Location loc=new Location(Bukkit.getServer().getWorld(values[0]),NPCManager.get(UID).getLocation().getX(),NPCManager.get(UID).getLocation().getY(),NPCManager.get(UID).getLocation().getZ(),Float.parseFloat(values[4]),Float.parseFloat(values[5]));
    return loc;
  }
}",0.9559748427672956
1956,"public static void saveFiles(){
  for (  Saveable saveable : properties.values()) {
    saveable.saveFiles();
  }
  QuestProperties.save();
}","public static void saveFiles(){
  for (  Saveable saveable : properties.values()) {
    saveable.saveFiles();
  }
}",0.8984375
1957,"/** 
 * Gets the text to be said for a basic npc.
 * @param npc
 * @param player
 * @param plugin
 * @return
 */
public static String getText(HumanNPC npc,Player player){
  String name=StringUtils.stripColour(npc.getStrippedName());
  ArrayDeque<String> array=NPCManager.getText(npc.getUID());
  String text=""String_Node_Str"";
  if (array != null && array.size() > 0) {
    text=array.getLast();
    array.push(array.pop());
    NPCManager.setText(npc.getUID(),array);
  }
  if (text.isEmpty()) {
    text=UtilityProperties.getDefaultText();
  }
  if (!text.isEmpty()) {
    if (Constants.useNPCColours) {
      text=Constants.chatFormat.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",npc.getStrippedName()) + text;
    }
 else {
      text=Constants.chatFormat.replace(""String_Node_Str"",Constants.npcColour + name + ChatColor.WHITE).replace(""String_Node_Str"",""String_Node_Str"") + text;
    }
    return text;
  }
  return ""String_Node_Str"";
}","/** 
 * Gets the text to be said for a basic npc.
 * @param npc
 * @param player
 * @param plugin
 * @return
 */
public static String getText(HumanNPC npc,Player player){
  String name=StringUtils.stripColour(npc.getStrippedName());
  ArrayDeque<String> array=NPCManager.getText(npc.getUID());
  String text=""String_Node_Str"";
  if (array != null && array.size() > 0) {
    text=array.pop();
    array.addLast(text);
    NPCManager.setText(npc.getUID(),array);
  }
  if (text.isEmpty()) {
    text=UtilityProperties.getDefaultText();
  }
  if (!text.isEmpty()) {
    if (Constants.useNPCColours) {
      text=Constants.chatFormat.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",npc.getStrippedName()) + text;
    }
 else {
      text=Constants.chatFormat.replace(""String_Node_Str"",Constants.npcColour + name + ChatColor.WHITE).replace(""String_Node_Str"",""String_Node_Str"") + text;
    }
    return text;
  }
  return ""String_Node_Str"";
}",0.9709241952232608
1958,"public static boolean pathFinished(HumanNPC npc){
  return npc.pathFinished();
}","public static boolean pathFinished(HumanNPC npc){
  return npc.getHandle().pathFinished();
}",0.9302325581395348
1959,"public static void cancelTarget(HumanNPC npc){
  npc.cancelTarget();
}","public static void cancelTarget(HumanNPC npc){
  npc.getHandle().cancelTarget();
}",0.9210526315789472
1960,"public static void cancelPath(HumanNPC npc){
  npc.cancelPath();
}","public static void cancelPath(HumanNPC npc){
  npc.getHandle().cancelPath();
}",0.9166666666666666
1961,"public void applyGravity(){
  if (this.motY > 0)   this.motY-=Constants.GRAVITY;
}","public void applyGravity(){
  this.motY-=Constants.GRAVITY;
}",0.8531468531468531
1962,"public void updateMovement(){
  this.moveNPCTowardsTarget();
  this.applyGravity();
}","public void updateMovement(){
  this.mcEntity.updateMove();
  this.mcEntity.applyGravity();
}",0.7752808988764045
1963,"/** 
 * Returns whether the given item ID is usable as a tool.
 * @param key , type
 * @return Whether the ID is used for a tool.
 */
public boolean validateTool(String key,int type,boolean sneaking){
  if (Constants.useItemList) {
    String[] items=UtilityProperties.settings.getString(key).split(""String_Node_Str"");
    List<String> item=Arrays.asList(items);
    if (item.contains(""String_Node_Str""))     return true;
    boolean isShift=false;
    for (    String s : item) {
      isShift=false;
      if (s.contains(""String_Node_Str"")) {
        s=s.replace(""String_Node_Str"",""String_Node_Str"");
        isShift=true;
      }
      if (Integer.parseInt(s) == type && isShift == sneaking)       return true;
    }
    return false;
  }
 else   return true;
}","/** 
 * Returns whether the given item ID is usable as a tool.
 * @param key , type
 * @return Whether the ID is used for a tool.
 */
public boolean validateTool(String key,int type,boolean sneaking){
  if (Constants.useItemList) {
    String[] items=UtilityProperties.settings.getString(key).split(""String_Node_Str"");
    List<String> item=Arrays.asList(items);
    if (item.contains(""String_Node_Str"")) {
      return true;
    }
    boolean isShift=false;
    for (    String s : item) {
      isShift=false;
      if (s.contains(""String_Node_Str"")) {
        s=s.replace(""String_Node_Str"",""String_Node_Str"");
        isShift=true;
      }
      if (Integer.parseInt(s) == type && isShift == sneaking) {
        return true;
      }
    }
    return false;
  }
 else {
    return true;
  }
}",0.889602053915276
1964,"@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  if (NPCManager.validateSelected(player)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
  if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(Operation.BASIC_NPC_CREATE,player)) {
        create(args,player);
      }
 else       if (EconomyHandler.useEconomy()) {
        sender.sendMessage(MessageUtils.getNoMoneyMessage(Operation.BASIC_NPC_CREATE,player));
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          move(player,npc.getName(),npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if ((args.length == 1 || args.length == 2) && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          remove(args,sender,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else     if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (args.length == 2 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
        remove(args,sender,npc);
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          rename(args[1],sender,npc);
          NPCManager.selectedNPCs.remove(player.getName());
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str""))) {
    if (Permission.hasPermission(""String_Node_Str"",sender) || Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"") || NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          setColour(args,player,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          addText(args,sender,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          setText(args,sender,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          resetText(args,sender,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          setItemInHand(args[1],sender,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].startsWith(""String_Node_Str"") || args[0].startsWith(""String_Node_Str"")|| args[0].startsWith(""String_Node_Str""))) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          setArmor(args,sender,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length >= 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          player.teleport(npc.getNPCData().getLocation());
          sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str"");
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          copy(npc.getUID(),npc.getName(),player);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str"");
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (!Character.isDigit(args[1].charAt(0))) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        return true;
      }
      npc=NPCManager.get(Integer.valueOf(args[1]));
      if (npc == null) {
        sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[1]+ ""String_Node_Str"");
      }
 else {
        NPCManager.selectedNPCs.put(player.getName(),npc.getUID());
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str""+ StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str"");
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getOwner())+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          setOwner(player,npc,args[1]);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          changeTalkWhenClose(args[1],player,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          changeLookWhenClose(args[1],player,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if ((command.getName().equalsIgnoreCase(""String_Node_Str"") || command.getName().equalsIgnoreCase(""String_Node_Str"")) && args.length == 1 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      HelpUtils.sendHelp(sender);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (command.getName().equalsIgnoreCase(""String_Node_Str"")) {
    if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        int page=Integer.parseInt(args[1]);
        HelpUtils.sendBasicHelpPage(sender,page);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      return true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        HelpUtils.sendBasicHelpPage(sender,1);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      return true;
    }
  }
 else {
    if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str"")|| args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
    }
 else     if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else {
      return false;
    }
  }
  PropertyManager.get(""String_Node_Str"").saveState(npc);
  return false;
}","@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  if (NPCManager.validateSelected(player)) {
    npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
  }
  if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(Operation.BASIC_CREATION,player)) {
        create(args,player);
      }
 else       if (EconomyHandler.useEconomy()) {
        sender.sendMessage(MessageUtils.getNoMoneyMessage(Operation.BASIC_CREATION,player));
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          move(player,npc.getName(),npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if ((args.length == 1 || args.length == 2) && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          remove(args,sender,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else     if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (args.length == 2 && args[1].equalsIgnoreCase(""String_Node_Str"")) {
        remove(args,sender,npc);
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          rename(args[1],sender,npc);
          NPCManager.selectedNPCs.remove(player.getName());
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str""))) {
    if (Permission.hasPermission(""String_Node_Str"",sender) || Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"") || NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          setColour(args,player,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          addText(args,sender,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          setText(args,sender,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          resetText(args,sender,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          setItemInHand(args[1],sender,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].startsWith(""String_Node_Str"") || args[0].startsWith(""String_Node_Str"")|| args[0].startsWith(""String_Node_Str""))) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          setArmor(args,sender,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length >= 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          player.teleport(npc.getNPCData().getLocation());
          sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str"");
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          copy(npc.getUID(),npc.getName(),player);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str"");
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (!Character.isDigit(args[1].charAt(0))) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        return true;
      }
      npc=NPCManager.get(Integer.valueOf(args[1]));
      if (npc == null) {
        sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[1]+ ""String_Node_Str"");
      }
 else {
        NPCManager.selectedNPCs.put(player.getName(),npc.getUID());
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str""+ StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str"");
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getOwner())+ ""String_Node_Str"");
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          setOwner(player,npc,args[1]);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          changeTalkWhenClose(args[1],player,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
          changeLookWhenClose(args[1],player,npc);
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      if (npc != null) {
        if (NPCManager.validateOwnership(player,npc.getUID(),""String_Node_Str"")) {
        }
 else {
          sender.sendMessage(MessageUtils.notOwnerMessage);
        }
      }
 else {
        sender.sendMessage(MessageUtils.mustHaveNPCSelectedMessage);
      }
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if ((command.getName().equalsIgnoreCase(""String_Node_Str"") || command.getName().equalsIgnoreCase(""String_Node_Str"")) && args.length == 1 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
    if (Permission.hasPermission(""String_Node_Str"",sender)) {
      HelpUtils.sendHelp(sender);
    }
 else {
      sender.sendMessage(MessageUtils.noPermissionsMessage);
    }
    return true;
  }
 else   if (command.getName().equalsIgnoreCase(""String_Node_Str"")) {
    if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        int page=Integer.parseInt(args[1]);
        HelpUtils.sendBasicHelpPage(sender,page);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      return true;
    }
 else     if (args.length == 1 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        HelpUtils.sendBasicHelpPage(sender,1);
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      return true;
    }
  }
 else {
    if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str"") || args[0].equalsIgnoreCase(""String_Node_Str"")|| args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
    }
 else     if (args.length >= 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 2 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else     if (args.length >= 3 && (args[0].equalsIgnoreCase(""String_Node_Str""))) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else {
      return false;
    }
  }
  PropertyManager.get(""String_Node_Str"").saveState(npc);
  return false;
}",0.9995036912959862
1965,"/** 
 * Creates an NPC given a string array, containing the name of the NPC and optional text to be added to it.
 * @param args
 * @param player
 */
private void create(String[] args,Player player){
  String text=""String_Node_Str"";
  ArrayList<String> texts=new ArrayList<String>();
  if (args.length >= 3) {
    int i=0;
    for (    String s : args) {
      if (i == 2 && !s.isEmpty() && !s.equals(""String_Node_Str"")) {
        text+=s;
      }
      if (i > 2 && !s.isEmpty() && !s.equals(""String_Node_Str"")) {
        text+=""String_Node_Str"" + s;
      }
      i+=1;
    }
    texts.add(text);
  }
  if (args[1].length() > 16) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  if ((PropertyManager.getBasic().getNPCAmountPerPlayer(player.getName()) < UtilityProperties.getMaxNPCsPerPlayer()) || (UtilityProperties.settings.getInt(""String_Node_Str"") == 0) || (Permission.hasPermission(""String_Node_Str"",(CommandSender)player))) {
    int UID=NPCManager.register(args[1],player.getLocation(),player.getName());
    PropertyManager.getBasic().saveNPCAmountPerPlayer(player.getName(),PropertyManager.getBasic().getNPCAmountPerPlayer(player.getName()) + 1);
    NPCManager.setText(UID,texts);
    NPCManager.get(UID).getNPCData().setOwner(player.getName());
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(args[1])+ ""String_Node_Str"");
    if (EconomyHandler.useEconomy()) {
      double paid=EconomyHandler.pay(Operation.BASIC_NPC_CREATE,player);
      if (paid > 0) {
        player.sendMessage(MessageUtils.getPaidMessage(Operation.BASIC_NPC_CREATE,paid,args[1],""String_Node_Str"",false));
      }
    }
    NPCManager.selectedNPCs.put(player.getName(),UID);
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(args[1])+ ""String_Node_Str""+ StringUtils.wrap(UID)+ ""String_Node_Str"");
  }
 else {
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"" + UtilityProperties.getMaxNPCsPerPlayer())+ ""String_Node_Str"");
  }
}","/** 
 * Creates an NPC given a string array, containing the name of the NPC and optional text to be added to it.
 * @param args
 * @param player
 */
private void create(String[] args,Player player){
  String text=""String_Node_Str"";
  ArrayList<String> texts=new ArrayList<String>();
  if (args.length >= 3) {
    int i=0;
    for (    String s : args) {
      if (i == 2 && !s.isEmpty() && !s.equals(""String_Node_Str"")) {
        text+=s;
      }
      if (i > 2 && !s.isEmpty() && !s.equals(""String_Node_Str"")) {
        text+=""String_Node_Str"" + s;
      }
      i+=1;
    }
    texts.add(text);
  }
  if (args[1].length() > 16) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  if ((PropertyManager.getBasic().getNPCAmountPerPlayer(player.getName()) < UtilityProperties.getMaxNPCsPerPlayer()) || (UtilityProperties.settings.getInt(""String_Node_Str"") == 0) || (Permission.hasPermission(""String_Node_Str"",(CommandSender)player))) {
    int UID=NPCManager.register(args[1],player.getLocation(),player.getName());
    PropertyManager.getBasic().saveNPCAmountPerPlayer(player.getName(),PropertyManager.getBasic().getNPCAmountPerPlayer(player.getName()) + 1);
    NPCManager.setText(UID,texts);
    NPCManager.get(UID).getNPCData().setOwner(player.getName());
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(args[1])+ ""String_Node_Str"");
    if (EconomyHandler.useEconomy()) {
      double paid=EconomyHandler.pay(Operation.BASIC_CREATION,player);
      if (paid > 0) {
        player.sendMessage(MessageUtils.getPaidMessage(Operation.BASIC_CREATION,paid,args[1],""String_Node_Str"",false));
      }
    }
    NPCManager.selectedNPCs.put(player.getName(),UID);
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(args[1])+ ""String_Node_Str""+ StringUtils.wrap(UID)+ ""String_Node_Str"");
  }
 else {
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(""String_Node_Str"" + UtilityProperties.getMaxNPCsPerPlayer())+ ""String_Node_Str"");
  }
}",0.9960861056751468
1966,"/** 
 * Buy an armor repair
 * @param player
 * @param npc
 * @param armor
 * @param armorName
 * @param plural
 */
private void buyArmorRepair(Player player,HumanNPC npc,ItemStack armor,String armorName,boolean plural){
  String msg=""String_Node_Str"";
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(Operation.BLACKSMITH_ARMOR_REPAIR,player)) {
    if (EconomyHandler.useEconomy()) {
      if (npc.getBlacksmith().validateArmor(armor)) {
        if (armor.getDurability() > 0) {
          double paid=EconomyHandler.pay(Operation.BLACKSMITH_ARMOR_REPAIR,player);
          if (paid > 0) {
            armor.setDurability((short)0);
            msg=ChatColor.GREEN + (""String_Node_Str"") + StringUtils.wrap(armorName);
            if (plural) {
              msg+=""String_Node_Str"";
            }
 else {
              msg+=""String_Node_Str"";
            }
            msg+=StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(Operation.BLACKSMITH_ARMOR_REPAIR,""String_Node_Str"" + paid,ChatColor.YELLOW))+ ""String_Node_Str"";
            player.sendMessage(msg);
          }
        }
 else {
          player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        }
      }
 else {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      }
    }
 else {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    }
  }
 else   if (EconomyHandler.useEconomy()) {
    player.sendMessage(MessageUtils.getNoMoneyMessage(Operation.BLACKSMITH_ARMOR_REPAIR,player));
    return;
  }
}","/** 
 * Buy an armor repair
 * @param player
 * @param npc
 * @param armor
 * @param armorName
 * @param plural
 */
private void buyArmorRepair(Player player,HumanNPC npc,ItemStack armor,String armorName,boolean plural){
  String msg=""String_Node_Str"";
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(Operation.BLACKSMITH_ARMORREPAIR,player)) {
    if (EconomyHandler.useEconomy()) {
      if (npc.getBlacksmith().validateArmor(armor)) {
        if (armor.getDurability() > 0) {
          double paid=EconomyHandler.pay(Operation.BLACKSMITH_ARMORREPAIR,player);
          if (paid > 0) {
            armor.setDurability((short)0);
            msg=ChatColor.GREEN + (""String_Node_Str"") + StringUtils.wrap(armorName);
            if (plural) {
              msg+=""String_Node_Str"";
            }
 else {
              msg+=""String_Node_Str"";
            }
            msg+=StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"" + StringUtils.wrap(EconomyHandler.getPaymentType(Operation.BLACKSMITH_ARMORREPAIR,""String_Node_Str"" + paid,ChatColor.YELLOW))+ ""String_Node_Str"";
            player.sendMessage(msg);
          }
        }
 else {
          player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        }
      }
 else {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      }
    }
 else {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    }
  }
 else   if (EconomyHandler.useEconomy()) {
    player.sendMessage(MessageUtils.getNoMoneyMessage(Operation.BLACKSMITH_ARMORREPAIR,player));
    return;
  }
}",0.99872040946897
1967,"private void levelUp(Player player,HumanNPC npc,int multiple){
  if (EconomyHandler.useEconomy()) {
    int level=npc.getHealer().getLevel();
    double paid=EconomyHandler.pay(Operation.HEALER_LEVEL_UP,player,multiple);
    if (paid > 0) {
      if (level < 10) {
        npc.getHealer().setLevel(level + multiple);
        player.sendMessage(getLevelUpPaidMessage(Operation.HEALER_LEVEL_UP,npc,paid,level + multiple,multiple));
      }
 else {
        player.sendMessage(StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"");
      }
    }
  }
 else {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
  }
}","private void levelUp(Player player,HumanNPC npc,int multiple){
  if (EconomyHandler.useEconomy()) {
    int level=npc.getHealer().getLevel();
    double paid=EconomyHandler.pay(Operation.HEALER_LEVELUP,player,multiple);
    if (paid > 0) {
      if (level < 10) {
        npc.getHealer().setLevel(level + multiple);
        player.sendMessage(getLevelUpPaidMessage(Operation.HEALER_LEVELUP,npc,paid,level + multiple,multiple));
      }
 else {
        player.sendMessage(StringUtils.wrap(npc.getStrippedName()) + ""String_Node_Str"");
      }
    }
  }
 else {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
  }
}",0.9984
1968,"@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender))   npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
 else {
    player.sendMessage(ChatColor.RED + MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    player.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (args.length == 0) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        if (!PropertyManager.get(""String_Node_Str"").exists(npc)) {
          buyState(player,npc.getTrader(),Operation.TRADER_NPC_CREATE);
        }
 else {
          toggleState(player,npc.getTrader());
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        if (!PropertyManager.get(""String_Node_Str"").exists(npc)) {
          buyState(player,npc.getQuester(),Operation.QUESTER_NPC_CREATE);
        }
 else {
          toggleState(player,npc.getQuester());
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        if (!PropertyManager.get(""String_Node_Str"").exists(npc)) {
          buyState(player,npc.getHealer(),Operation.HEALER_NPC_CREATE);
        }
 else {
          toggleState(player,npc.getHealer());
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        if (!PropertyManager.get(""String_Node_Str"").exists(npc)) {
          buyState(player,npc.getGuard(),Operation.GUARD_NPC_CREATE);
        }
 else {
          toggleState(player,npc.getGuard());
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        if (!PropertyManager.get(""String_Node_Str"").exists(npc)) {
          buyState(player,npc.getWizard(),Operation.WIZARD_NPC_CREATE);
        }
 else {
          toggleState(player,npc.getWizard());
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        if (!PropertyManager.get(""String_Node_Str"").exists(npc)) {
          buyState(player,npc.getBlacksmith(),Operation.BLACKSMITH_NPC_CREATE);
        }
 else {
          toggleState(player,npc.getBlacksmith());
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        if (!PropertyManager.get(""String_Node_Str"").exists(npc)) {
          buyState(player,npc.getBandit(),Operation.BANDIT_NPC_CREATE);
        }
 else {
          toggleState(player,npc.getBandit());
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (args[1].equals(""String_Node_Str"")) {
        toggleAll(npc,player,true);
      }
 else       if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        toggleAll(npc,player,false);
      }
      returnval=true;
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      returnval=true;
    }
  }
  PropertyManager.save(npc);
  return returnval;
}","@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    sender.sendMessage(MessageUtils.mustBeIngameMessage);
    return true;
  }
  Player player=(Player)sender;
  HumanNPC npc=null;
  boolean returnval=false;
  if (NPCManager.validateSelected((Player)sender))   npc=NPCManager.get(NPCManager.selectedNPCs.get(player.getName()));
 else {
    player.sendMessage(ChatColor.RED + MessageUtils.mustHaveNPCSelectedMessage);
    return true;
  }
  if (!NPCManager.validateOwnership(player,npc.getUID())) {
    player.sendMessage(MessageUtils.notOwnerMessage);
    return true;
  }
  if (args.length == 0) {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
 else {
    if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        if (!PropertyManager.get(""String_Node_Str"").exists(npc)) {
          buyState(player,npc.getTrader(),Operation.TRADER_CREATION);
        }
 else {
          toggleState(player,npc.getTrader());
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        if (!PropertyManager.get(""String_Node_Str"").exists(npc)) {
          buyState(player,npc.getQuester(),Operation.QUESTER_CREATION);
        }
 else {
          toggleState(player,npc.getQuester());
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        if (!PropertyManager.get(""String_Node_Str"").exists(npc)) {
          buyState(player,npc.getHealer(),Operation.HEALER_CREATION);
        }
 else {
          toggleState(player,npc.getHealer());
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        if (!PropertyManager.get(""String_Node_Str"").exists(npc)) {
          buyState(player,npc.getGuard(),Operation.GUARD_CREATION);
        }
 else {
          toggleState(player,npc.getGuard());
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        if (!PropertyManager.get(""String_Node_Str"").exists(npc)) {
          buyState(player,npc.getWizard(),Operation.WIZARD_CREATION);
        }
 else {
          toggleState(player,npc.getWizard());
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        if (!PropertyManager.get(""String_Node_Str"").exists(npc)) {
          buyState(player,npc.getBlacksmith(),Operation.BLACKSMITH_CREATION);
        }
 else {
          toggleState(player,npc.getBlacksmith());
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (Permission.hasPermission(""String_Node_Str"",sender)) {
        if (!PropertyManager.get(""String_Node_Str"").exists(npc)) {
          buyState(player,npc.getBandit(),Operation.BANDIT_CREATION);
        }
 else {
          toggleState(player,npc.getBandit());
        }
      }
 else {
        sender.sendMessage(MessageUtils.noPermissionsMessage);
      }
      returnval=true;
    }
 else     if (args.length == 2 && args[0].equalsIgnoreCase(""String_Node_Str"")) {
      if (args[1].equals(""String_Node_Str"")) {
        toggleAll(npc,player,true);
      }
 else       if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        toggleAll(npc,player,false);
      }
      returnval=true;
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      returnval=true;
    }
  }
  PropertyManager.save(npc);
  return returnval;
}",0.993663724824621
1969,"/** 
 * Changes an operation enum to a string value for use in settings retrieval.
 * @param op
 * @param addendum
 * @return
 */
public static String getString(Operation op,String addendum){
  return op.toString().toLowerCase().replace(""String_Node_Str"",""String_Node_Str"") + addendum;
}","/** 
 * Changes an operation enum to a string value for use in settings retrieval.
 * @param op
 * @param addendum
 * @return
 */
public static String getString(Operation op,String addendum){
  return prefix + op.toString().toLowerCase().replace(""String_Node_Str"",""String_Node_Str"") + addendum;
}",0.9845626072041166
1970,"@Override public void onEntityTarget(EntityTargetEvent event){
  if (NPCManager.isNPC(event.getTarget())) {
    event.setCancelled(true);
  }
  if (!(event instanceof NPCEntityTargetEvent)) {
    return;
  }
  NPCEntityTargetEvent e=(NPCEntityTargetEvent)event;
  HumanNPC npc=NPCManager.get(e.getEntity());
  if (npc != null && event.getTarget() instanceof Player) {
    if (e.getNpcReason() == NpcTargetReason.NPC_RIGHTCLICKED) {
      Player p=(Player)event.getTarget();
      if (plugin.validateTool(""String_Node_Str"",p.getItemInHand().getTypeId(),p.isSneaking()) == true) {
        if (!NPCManager.validateSelected(p,npc.getUID())) {
          NPCManager.selectedNPCs.put(p.getName(),npc.getUID());
          p.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str"");
          return;
        }
      }
      if (plugin.validateTool(""String_Node_Str"",p.getItemInHand().getTypeId(),p.isSneaking()) == true) {
        CitizensBasicNPCEvent ev=new CitizensBasicNPCEvent(npc.getName(),MessageUtils.getText(npc,(Player)e.getTarget(),plugin),npc,Reason.RIGHT_CLICK,(Player)e.getTarget());
        plugin.getServer().getPluginManager().callEvent(ev);
      }
      if (npc.isTrader()) {
        TraderInterface.handleRightClick(npc,p);
      }
      if (npc.isWizard()) {
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)p)) {
          if (p.getItemInHand().getTypeId() == Constants.wizardInteractItem) {
            if (npc.getWizard().getNumberOfLocations() > 0) {
              npc.getWizard().buyTeleport(p,npc.getWizard(),Operation.WIZARD_TELEPORT);
            }
          }
        }
 else {
          p.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
      if (npc.isBlacksmith()) {
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)p)) {
          if (npc.getBlacksmith().getToolType(p.getItemInHand()).equals(""String_Node_Str"")) {
            npc.getBlacksmith().buyItemRepair(p,npc,p.getItemInHand(),Operation.BLACKSMITH_TOOL_REPAIR);
          }
 else           if (npc.getBlacksmith().getToolType(p.getItemInHand()).equals(""String_Node_Str"")) {
            npc.getBlacksmith().buyItemRepair(p,npc,p.getItemInHand(),Operation.BLACKSMITH_ARMOR_REPAIR);
          }
        }
 else {
          p.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
      if (npc.isBandit()) {
        BanditInterface.handleRightClick(npc,p);
      }
      if (npc.isEvil()) {
        if (p.getItemInHand().getTypeId() == Constants.evilNPCTameItem) {
        }
      }
    }
  }
}","@Override public void onEntityTarget(EntityTargetEvent event){
  if (NPCManager.isNPC(event.getTarget())) {
    event.setCancelled(true);
  }
  if (!(event instanceof NPCEntityTargetEvent)) {
    return;
  }
  NPCEntityTargetEvent e=(NPCEntityTargetEvent)event;
  HumanNPC npc=NPCManager.get(e.getEntity());
  if (npc != null && event.getTarget() instanceof Player) {
    if (e.getNpcReason() == NpcTargetReason.NPC_RIGHTCLICKED) {
      Player p=(Player)event.getTarget();
      if (plugin.validateTool(""String_Node_Str"",p.getItemInHand().getTypeId(),p.isSneaking()) == true) {
        if (!NPCManager.validateSelected(p,npc.getUID())) {
          NPCManager.selectedNPCs.put(p.getName(),npc.getUID());
          p.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.wrap(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.wrap(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str"");
          return;
        }
      }
      if (plugin.validateTool(""String_Node_Str"",p.getItemInHand().getTypeId(),p.isSneaking()) == true) {
        CitizensBasicNPCEvent ev=new CitizensBasicNPCEvent(npc.getName(),MessageUtils.getText(npc,(Player)e.getTarget(),plugin),npc,Reason.RIGHT_CLICK,(Player)e.getTarget());
        plugin.getServer().getPluginManager().callEvent(ev);
      }
      if (npc.isTrader()) {
        TraderInterface.handleRightClick(npc,p);
      }
      if (npc.isWizard()) {
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)p)) {
          if (p.getItemInHand().getTypeId() == Constants.wizardInteractItem) {
            if (npc.getWizard().getNumberOfLocations() > 0) {
              npc.getWizard().buyTeleport(p,npc.getWizard(),Operation.WIZARD_TELEPORT);
            }
          }
        }
 else {
          p.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
      if (npc.isBlacksmith()) {
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)p)) {
          if (npc.getBlacksmith().getToolType(p.getItemInHand()).equals(""String_Node_Str"")) {
            npc.getBlacksmith().buyItemRepair(p,npc,p.getItemInHand(),Operation.BLACKSMITH_TOOLREPAIR);
          }
 else           if (npc.getBlacksmith().getToolType(p.getItemInHand()).equals(""String_Node_Str"")) {
            npc.getBlacksmith().buyItemRepair(p,npc,p.getItemInHand(),Operation.BLACKSMITH_ARMORREPAIR);
          }
        }
 else {
          p.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
      if (npc.isBandit()) {
        BanditInterface.handleRightClick(npc,p);
      }
      if (npc.isEvil()) {
        if (p.getItemInHand().getTypeId() == Constants.evilNPCTameItem) {
        }
      }
    }
  }
}",0.9996253278381416
1971,"public static String getDefaultText(){
  String[] split=settings.getString(""String_Node_Str"").split(""String_Node_Str"");
  String text;
  if (split != null) {
    text=split[new Random(System.currentTimeMillis()).nextInt(split.length)];
    if (text == null)     text=""String_Node_Str"";
  }
 else   text=""String_Node_Str"";
  return text.replace('&','');
}","public static String getDefaultText(){
  String[] split=settings.getString(""String_Node_Str"").split(""String_Node_Str"");
  String text;
  if (split != null) {
    text=split[new Random(System.currentTimeMillis()).nextInt(split.length)];
    if (text == null) {
      text=""String_Node_Str"";
    }
  }
 else {
    text=""String_Node_Str"";
  }
  return text.replace('&','');
}",0.9642857142857144
1972,"public boolean setMethod(Plugin method){
  PluginManager loader=method.getServer().getPluginManager();
  if (method.isEnabled()) {
    PluginDescriptionFile info=method.getDescription();
    String name=info.getName();
    if (name.equalsIgnoreCase(""String_Node_Str"")) {
      if (method.getClass().getName().equals(""String_Node_Str""))       Method=new MethodiCo5((iConomy)method);
 else {
        Method=new MethodiCo4((com.nijiko.coelho.iConomy.iConomy)method);
      }
    }
 else     if (name.equalsIgnoreCase(""String_Node_Str"")) {
      Method=new MethodBOSEconomy((BOSEconomy)method);
    }
 else     if (name.equalsIgnoreCase(""String_Node_Str"")) {
      if (!((Essentials)method).isIConomyFallbackEnabled())       Method=new MethodEEco((Essentials)method);
    }
  }
  if (!hasMethod()) {
    if (loader.getPlugin(""String_Node_Str"") != null) {
      method=loader.getPlugin(""String_Node_Str"");
      if (method.getClass().getName().equals(""String_Node_Str""))       Method=new MethodiCo5((iConomy)method);
 else {
        Method=new MethodiCo4((com.nijiko.coelho.iConomy.iConomy)method);
      }
    }
 else     if (loader.getPlugin(""String_Node_Str"") != null) {
      method=loader.getPlugin(""String_Node_Str"");
      Method=new MethodBOSEconomy((BOSEconomy)method);
    }
 else     if (loader.getPlugin(""String_Node_Str"") != null) {
      method=loader.getPlugin(""String_Node_Str"");
      if (!((Essentials)method).isIConomyFallbackEnabled())       Method=new MethodEEco((Essentials)method);
    }
  }
  return hasMethod();
}","public boolean setMethod(Plugin method){
  PluginManager loader=method.getServer().getPluginManager();
  if (method.isEnabled()) {
    PluginDescriptionFile info=method.getDescription();
    String name=info.getName();
    if (name.equalsIgnoreCase(""String_Node_Str"")) {
      if (method.getClass().getName().equals(""String_Node_Str""))       Method=new MethodiCo5((iConomy)method);
 else {
        Method=new MethodiCo4((com.nijiko.coelho.iConomy.iConomy)method);
      }
    }
 else     if (name.equalsIgnoreCase(""String_Node_Str"")) {
      Method=new MethodBOSEconomy((BOSEconomy)method);
    }
 else     if (name.equalsIgnoreCase(""String_Node_Str"")) {
      Method=new MethodEEco((Essentials)method);
    }
  }
  if (!hasMethod()) {
    if (loader.getPlugin(""String_Node_Str"") != null) {
      method=loader.getPlugin(""String_Node_Str"");
      if (method.getClass().getName().equals(""String_Node_Str""))       Method=new MethodiCo5((iConomy)method);
 else {
        Method=new MethodiCo4((com.nijiko.coelho.iConomy.iConomy)method);
      }
    }
 else     if (loader.getPlugin(""String_Node_Str"") != null) {
      method=loader.getPlugin(""String_Node_Str"");
      Method=new MethodBOSEconomy((BOSEconomy)method);
    }
 else     if (loader.getPlugin(""String_Node_Str"") != null) {
      method=loader.getPlugin(""String_Node_Str"");
      Method=new MethodEEco((Essentials)method);
    }
  }
  return hasMethod();
}",0.959266802443992
1973,"/** 
 * Adds an item to be stocked by the selected trader.
 * @param player
 * @param npc
 * @param item
 * @param price
 * @param selling
 */
private void changeTraderStock(Player player,HumanNPC npc,String item,String price,boolean selling){
  if (item.contains(""String_Node_Str"")) {
    Material mat=StringUtils.parseMaterial(price);
    if (mat == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
    String keyword=""String_Node_Str"";
    if (!selling)     keyword=""String_Node_Str"";
    if (npc.getTrader().getStockable(mat.getId(),selling) == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + keyword+ ""String_Node_Str"");
      return;
    }
 else {
      npc.getTrader().removeStockable(mat.getId(),selling);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(mat.name())+ ""String_Node_Str""+ keyword+ ""String_Node_Str"");
    }
    return;
  }
  String[] split=item.split(""String_Node_Str"");
  ItemStack stack=createItemStack(split);
  if (stack == null) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  split=price.split(""String_Node_Str"");
  ItemStack cost=null;
  if (split.length != 1) {
    cost=createItemStack(split);
    if (cost == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
  }
  if (cost == null) {
    if (!EconomyHandler.useIconomy()) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      return;
    }
  }
  boolean iConomy=false;
  if (cost == null)   iConomy=true;
  int data=Citizens.MAGIC_DATA_VALUE;
  if (!iConomy && cost.getData() != null)   data=cost.getData().getData();
  ItemPrice itemPrice;
  if (!iConomy)   itemPrice=new ItemPrice(cost.getAmount(),cost.getTypeId(),data);
 else   itemPrice=new ItemPrice(Double.parseDouble(split[0]));
  itemPrice.setiConomy(iConomy);
  Stockable s=new Stockable(stack,itemPrice,true);
  String keyword=""String_Node_Str"";
  if (!selling) {
    keyword=""String_Node_Str"";
    s.setSelling(false);
  }
  if (npc.getTrader().isStocked(s)) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"" + keyword+ ""String_Node_Str""+ MessageUtils.getStockableMessage(s,ChatColor.RED)+ ""String_Node_Str"");
    return;
  }
  npc.getTrader().addStockable(s);
  player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + keyword+ ""String_Node_Str""+ MessageUtils.getStockableMessage(s,ChatColor.GREEN)+ ""String_Node_Str"");
}","/** 
 * Adds an item to be stocked by the selected trader.
 * @param player
 * @param npc
 * @param item
 * @param price
 * @param selling
 */
private void changeTraderStock(Player player,HumanNPC npc,String item,String price,boolean selling){
  if (item.contains(""String_Node_Str"")) {
    Material mat=StringUtils.parseMaterial(price);
    if (mat == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
    String keyword=""String_Node_Str"";
    if (!selling)     keyword=""String_Node_Str"";
    if (npc.getTrader().getStockable(mat.getId(),selling) == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + keyword+ ""String_Node_Str"");
      return;
    }
 else {
      npc.getTrader().removeStockable(mat.getId(),selling);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(mat.name())+ ""String_Node_Str""+ keyword+ ""String_Node_Str"");
    }
    return;
  }
  String[] split=item.split(""String_Node_Str"");
  ItemStack stack=createItemStack(split);
  if (stack == null) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  split=price.split(""String_Node_Str"");
  ItemStack cost=null;
  if (split.length != 1) {
    cost=createItemStack(split);
    if (cost == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
  }
  if (cost == null && !EconomyHandler.useIconomy()) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    return;
  }
  boolean iConomy=false;
  int data=-1;
  if (cost == null)   iConomy=true;
 else   if (cost.getData() != null) {
    data=cost.getData().getData();
  }
  ItemPrice itemPrice;
  if (!iConomy)   itemPrice=new ItemPrice(cost.getAmount(),cost.getTypeId(),data);
 else   itemPrice=new ItemPrice(Double.parseDouble(split[0]));
  itemPrice.setiConomy(iConomy);
  Stockable s=new Stockable(stack,itemPrice,true);
  String keyword=""String_Node_Str"";
  if (!selling) {
    keyword=""String_Node_Str"";
    s.setSelling(false);
  }
  if (npc.getTrader().isStocked(s)) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"" + keyword+ ""String_Node_Str""+ MessageUtils.getStockableMessage(s,ChatColor.RED)+ ""String_Node_Str"");
    return;
  }
  npc.getTrader().addStockable(s);
  player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + keyword+ ""String_Node_Str""+ MessageUtils.getStockableMessage(s,ChatColor.GREEN)+ ""String_Node_Str"");
}",0.9304295220810648
1974,"/** 
 * Creates an ItemStack from the given string ItemStack format.
 * @param split
 * @return
 */
private ItemStack createItemStack(String[] split){
  try {
    int amount=1;
    int data=0;
    Material mat=StringUtils.parseMaterial(split[0]);
    if (mat == null) {
      return null;
    }
    if (split.length > 1)     amount=Integer.parseInt(split[1]);
    if (split.length > 2)     data=Integer.parseInt(split[2]);
    ItemStack stack=new ItemStack(mat,amount);
    if (data > 0) {
      MaterialData mdata=new MaterialData(data);
      stack.setData(mdata);
    }
    return stack;
  }
 catch (  NumberFormatException ex) {
    return null;
  }
}","/** 
 * Creates an ItemStack from the given string ItemStack format.
 * @param split
 * @return
 */
private ItemStack createItemStack(String[] split){
  try {
    int amount=1;
    byte data=Citizens.MAGIC_DATA_VALUE;
    Material mat=StringUtils.parseMaterial(split[0]);
    if (mat == null) {
      return null;
    }
    if (split.length >= 2)     amount=Integer.parseInt(split[1]);
    if (split.length >= 3)     data=Byte.parseByte(split[2]);
    ItemStack stack=new ItemStack(mat,amount);
    if (data != 0) {
      MaterialData mdata=new MaterialData(mat,data);
      stack.setData(mdata);
    }
    return stack;
  }
 catch (  NumberFormatException ex) {
    return null;
  }
}",0.9402985074626866
1975,"@Override public void run(){
  for (  Entry<Integer,HumanNPC> entry : NPCManager.getNPCList().entrySet()) {
{
      HumanNPC npc=entry.getValue();
      npc.updateMovement();
      int UID=npc.getUID();
      int entityID=entry.getKey();
      for (      Player p : plugin.getServer().getOnlinePlayers()) {
        String name=p.getName();
        if (PropertyPool.getLookWhenClose(UID) || PropertyPool.getTalkWhenClose(UID)) {
          if (checkLocation(npc.getLocation(),p.getLocation())) {
            if (PropertyPool.getLookWhenClose(UID)) {
              NPCManager.rotateNPCToPlayer(npc,p);
            }
            if (PropertyPool.getTalkWhenClose(UID) && (hasSaidText.get(entityID) == null || (hasSaidText.get(entityID).get(name) == null || hasSaidText.get(entityID).get(name) == false))) {
              MessageUtils.sendText(npc,p,plugin);
              HashMap<String,Boolean> players=new HashMap<String,Boolean>();
              if (hasSaidText.get(entityID) != null)               players=hasSaidText.get(entityID);
              players.put(name,true);
              hasSaidText.put(entityID,players);
            }
          }
        }
 else         if (PropertyPool.getTalkWhenClose(UID) && hasSaidText.get(entityID) != null && hasSaidText.get(entityID).get(name) != null && hasSaidText.get(entityID).get(name) == true) {
          hasSaidText.get(entityID).put(name,false);
        }
      }
    }
  }
}","@Override public void run(){
  for (  Entry<Integer,HumanNPC> entry : NPCManager.getNPCList().entrySet()) {
{
      HumanNPC npc=entry.getValue();
      npc.updateMovement();
      int entityID=entry.getKey();
      for (      Player p : plugin.getServer().getOnlinePlayers()) {
        String name=p.getName();
        if (npc.getNPCData().isLookClose() || npc.getNPCData().isTalkClose()) {
          if (checkLocation(npc.getLocation(),p.getLocation())) {
            if (npc.getNPCData().isLookClose()) {
              NPCManager.rotateNPCToPlayer(npc,p);
            }
            if (npc.getNPCData().isTalkClose() && (hasSaidText.get(entityID) == null || (hasSaidText.get(entityID).get(name) == null || hasSaidText.get(entityID).get(name) == false))) {
              MessageUtils.sendText(npc,p,plugin);
              HashMap<String,Boolean> players=new HashMap<String,Boolean>();
              if (hasSaidText.get(entityID) != null)               players=hasSaidText.get(entityID);
              players.put(name,true);
              hasSaidText.put(entityID,players);
            }
          }
        }
 else         if (npc.getNPCData().isTalkClose() && hasSaidText.get(entityID) != null && hasSaidText.get(entityID).get(name) != null && hasSaidText.get(entityID).get(name) == true) {
          hasSaidText.get(entityID).put(name,false);
        }
      }
    }
  }
}",0.7865810135617416
1976,"public ItemStack getItemStack(){
  ItemStack item=new ItemStack(itemID,amount);
  item.setData(new MaterialData(data));
  return item;
}","public ItemStack getItemStack(){
  ItemStack item=new ItemStack(itemID,amount);
  item.setData(new MaterialData(itemID,(byte)data));
  return item;
}",0.9543859649122808
1977,"private boolean checkData(MaterialData first,MaterialData second){
  int data=0;
  int data2=0;
  if (first != null)   data=first.getData();
  if (second != null)   data2=second.getData();
  if (data == data2 || data == Citizens.MAGIC_DATA_VALUE)   return true;
  return false;
}","private boolean checkData(MaterialData first,MaterialData second){
  int data=0;
  int data2=0;
  if (first != null)   data=first.getData();
  if (second != null)   data2=second.getData();
  Citizens.log.info(""String_Node_Str"" + data + ""String_Node_Str""+ data2);
  if (data == data2 || data == Citizens.MAGIC_DATA_VALUE)   return true;
  return false;
}",0.8829113924050633
1978,"public void addStockable(Stockable s){
  stocking.put(new Check(s.getStockingId(),s.isSelling()),s);
  TraderPropertyPool.saveStockables(npc.getUID(),getStocking());
}","public void addStockable(Stockable s){
  stocking.put(new Check(s.getStockingId(),s.isSelling()),s);
  TraderPropertyPool.saveStockables(npc.getUID(),stocking);
}",0.9787234042553192
1979,"public boolean isStocked(Stockable s){
  return isStocked(s.getStockingId(),s.getStocking().getData(),s.isSelling());
}","public boolean isStocked(Stockable s){
  return isStocked(s.getStockingId(),s.getPrice().getMaterialData(),s.isSelling());
}",0.9218106995884774
1980,"public static String addToStockableString(int UID,String s,Stockable st){
  if (s.contains(st.toString() + ""String_Node_Str""))   return ""String_Node_Str"";
  return s+=st.toString() + ""String_Node_Str"";
}","public static String addToStockableString(String s,Stockable st){
  if (s.contains(st.toString() + ""String_Node_Str""))   return ""String_Node_Str"";
  return st.toString() + ""String_Node_Str"";
}",0.9721518987341772
1981,"public static void saveStockables(int UID,ConcurrentHashMap<Check,Stockable> stockables){
  String string=""String_Node_Str"";
  setStockables(UID,string);
  for (  Entry<Check,Stockable> entry : stockables.entrySet()) {
    string+=addToStockableString(UID,string,entry.getValue());
  }
  setStockables(UID,string);
}","public static void saveStockables(int UID,ConcurrentHashMap<Check,Stockable> stockables){
  String string=""String_Node_Str"";
  setStockables(UID,string);
  int count=0;
  for (  Stockable entry : stockables.values()) {
    string+=addToStockableString(string,entry);
    count+=1;
  }
  Citizens.log.info(""String_Node_Str"" + count);
  setStockables(UID,string);
}",0.6804123711340206
1982,"/** 
 * Buy an armor repair
 * @param player
 * @param npc
 * @param armor
 * @param armorName
 * @param plural
 */
private void buyArmorRepair(Player player,HumanNPC npc,ItemStack armor,String armorName,boolean plural){
  String msg=""String_Node_Str"";
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(Operation.BLACKSMITH_ARMOR_REPAIR,player)) {
    if (EconomyHandler.useEconomy()) {
      double paid=EconomyHandler.pay(Operation.BLACKSMITH_ARMOR_REPAIR,player);
      if (paid > 0) {
        if (armor.getDurability() > 0) {
          armor.setDurability((short)0);
          msg=ChatColor.GREEN + (""String_Node_Str"") + StringUtils.yellowify(armorName);
          if (plural) {
            msg+=""String_Node_Str"";
          }
 else {
            msg+=""String_Node_Str"";
          }
          msg+=StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"" + StringUtils.yellowify(EconomyHandler.getPaymentType(Operation.BLACKSMITH_ARMOR_REPAIR,""String_Node_Str"" + paid,ChatColor.YELLOW))+ ""String_Node_Str"";
          player.sendMessage(msg);
        }
 else {
          player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        }
      }
    }
 else {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    }
  }
 else   if (EconomyHandler.useEconomy()) {
    player.sendMessage(MessageUtils.getNoMoneyMessage(Operation.BLACKSMITH_ARMOR_REPAIR,player));
    return;
  }
}","/** 
 * Buy an armor repair
 * @param player
 * @param npc
 * @param armor
 * @param armorName
 * @param plural
 */
private void buyArmorRepair(Player player,HumanNPC npc,ItemStack armor,String armorName,boolean plural){
  String msg=""String_Node_Str"";
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(Operation.BLACKSMITH_ARMOR_REPAIR,player)) {
    if (EconomyHandler.useEconomy()) {
      if (validateArmorToRepair(armor)) {
        if (armor.getDurability() > 0) {
          double paid=EconomyHandler.pay(Operation.BLACKSMITH_ARMOR_REPAIR,player);
          if (paid > 0) {
            armor.setDurability((short)0);
            msg=ChatColor.GREEN + (""String_Node_Str"") + StringUtils.yellowify(armorName);
            if (plural) {
              msg+=""String_Node_Str"";
            }
 else {
              msg+=""String_Node_Str"";
            }
            msg+=StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"" + StringUtils.yellowify(EconomyHandler.getPaymentType(Operation.BLACKSMITH_ARMOR_REPAIR,""String_Node_Str"" + paid,ChatColor.YELLOW))+ ""String_Node_Str"";
            player.sendMessage(msg);
          }
        }
 else {
          player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        }
      }
 else {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      }
    }
 else {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    }
  }
 else   if (EconomyHandler.useEconomy()) {
    player.sendMessage(MessageUtils.getNoMoneyMessage(Operation.BLACKSMITH_ARMOR_REPAIR,player));
    return;
  }
}",0.9082969432314412
1983,"/** 
 * Validate that a tool has a durability and can be repaired
 * @param item
 * @return
 */
private boolean validateToolToRepair(ItemStack item){
  int id=item.getTypeId();
  if (id == 256 || id == 257 || id == 258 || id == 259 || id == 267 || id == 268 || id == 269 || id == 270 || id == 271 || id == 272 || id == 273 || id == 274 || id == 275 || id == 276 || id == 277 || id == 278 || id == 279 || id == 283 || id == 284 || id == 285 || id == 286 || id == 290 || id == 291 || id == 292 || id == 293 || id == 294 || id == 346) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Validate that a tool has a durability and can be repaired
 * @param item
 * @return
 */
private boolean validateToolToRepair(ItemStack tool){
  int id=tool.getTypeId();
  if (id == 256 || id == 257 || id == 258 || id == 259 || id == 267 || id == 268 || id == 269 || id == 270 || id == 271 || id == 272 || id == 273 || id == 274 || id == 275 || id == 276 || id == 277 || id == 278 || id == 279 || id == 283 || id == 284 || id == 285 || id == 286 || id == 290 || id == 291 || id == 292 || id == 293 || id == 294 || id == 346) {
    return true;
  }
 else {
    return false;
  }
}",0.9863481228668942
1984,"/** 
 * Adds an item to be stocked by the selected trader.
 * @param player
 * @param npc
 * @param item
 * @param price
 * @param selling
 */
private void changeTraderStock(Player player,HumanNPC npc,String item,String price,boolean selling){
  if (item.contains(""String_Node_Str"")) {
    Material mat=StringUtils.parseMaterial(price);
    if (mat == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
    String keyword=""String_Node_Str"";
    if (!selling)     keyword=""String_Node_Str"";
    if (npc.getTrader().getStockable(mat.getId(),selling) == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + keyword+ ""String_Node_Str"");
      return;
    }
 else {
      npc.getTrader().removeStockable(mat.getId(),selling);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(mat.name())+ ""String_Node_Str""+ keyword+ ""String_Node_Str"");
    }
    return;
  }
  String[] split=item.split(""String_Node_Str"");
  ItemStack stack=createItemStack(split);
  if (stack == null) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  split=price.split(""String_Node_Str"");
  ItemStack cost=null;
  if (split.length != 1) {
    cost=createItemStack(split);
    if (cost == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
  }
  if (cost == null) {
    if (!EconomyHandler.useIconomy()) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      return;
    }
  }
  int data=Citizens.MAGIC_DATA_VALUE;
  if (cost != null && cost.getData() != null)   data=cost.getData().getData();
  ItemPrice itemPrice;
  if (cost != null)   itemPrice=new ItemPrice(cost.getAmount(),cost.getTypeId(),data);
 else   itemPrice=new ItemPrice(Double.parseDouble(split[0]));
  itemPrice.setiConomy(cost == null);
  Stockable s=new Stockable(stack,itemPrice,true);
  String keyword=""String_Node_Str"";
  if (!selling) {
    keyword=""String_Node_Str"";
    s.setSelling(false);
  }
  if (npc.getTrader().isStocked(s)) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"" + keyword+ ""String_Node_Str""+ MessageUtils.getStockableMessage(s,ChatColor.RED)+ ""String_Node_Str"");
    return;
  }
  npc.getTrader().addStockable(s);
  player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + keyword+ ""String_Node_Str""+ MessageUtils.getStockableMessage(s,ChatColor.GREEN)+ ""String_Node_Str"");
}","/** 
 * Adds an item to be stocked by the selected trader.
 * @param player
 * @param npc
 * @param item
 * @param price
 * @param selling
 */
private void changeTraderStock(Player player,HumanNPC npc,String item,String price,boolean selling){
  if (item.contains(""String_Node_Str"")) {
    Material mat=StringUtils.parseMaterial(price);
    if (mat == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
    String keyword=""String_Node_Str"";
    if (!selling)     keyword=""String_Node_Str"";
    if (npc.getTrader().getStockable(mat.getId(),selling) == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + keyword+ ""String_Node_Str"");
      return;
    }
 else {
      npc.getTrader().removeStockable(mat.getId(),selling);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(mat.name())+ ""String_Node_Str""+ keyword+ ""String_Node_Str"");
    }
    return;
  }
  String[] split=item.split(""String_Node_Str"");
  ItemStack stack=createItemStack(split);
  if (stack == null) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  split=price.split(""String_Node_Str"");
  ItemStack cost=null;
  if (split.length != 1) {
    cost=createItemStack(split);
    if (cost == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
  }
  if (cost == null) {
    if (!EconomyHandler.useIconomy()) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      return;
    }
  }
  boolean iConomy=false;
  if (cost == null)   iConomy=true;
  int data=Citizens.MAGIC_DATA_VALUE;
  if (!iConomy && cost.getData() != null)   data=cost.getData().getData();
  ItemPrice itemPrice;
  if (!iConomy)   itemPrice=new ItemPrice(cost.getAmount(),cost.getTypeId(),data);
 else   itemPrice=new ItemPrice(Double.parseDouble(split[0]));
  itemPrice.setiConomy(iConomy);
  Stockable s=new Stockable(stack,itemPrice,true);
  String keyword=""String_Node_Str"";
  if (!selling) {
    keyword=""String_Node_Str"";
    s.setSelling(false);
  }
  if (npc.getTrader().isStocked(s)) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"" + keyword+ ""String_Node_Str""+ MessageUtils.getStockableMessage(s,ChatColor.RED)+ ""String_Node_Str"");
    return;
  }
  npc.getTrader().addStockable(s);
  player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + keyword+ ""String_Node_Str""+ MessageUtils.getStockableMessage(s,ChatColor.GREEN)+ ""String_Node_Str"");
}",0.9765656565656564
1985,"/** 
 * Alters the selected trader's balance depending on the arguments given. Balance is used for iConomy.
 * @param player
 * @param npc
 * @param args
 * @throws NumberFormatException
 */
private void changeBalance(Player player,HumanNPC npc,String[] args){
  double amount;
  try {
    amount=Double.parseDouble(args[2]);
  }
 catch (  NumberFormatException e) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  if (args[1].contains(""String_Node_Str"")) {
    if (EconomyHandler.canBuy(new Payment(amount,true),player)) {
      EconomyHandler.pay(new Payment(-amount,true),npc,-1);
      EconomyHandler.pay(new Payment(amount,true),player,-1);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(IconomyInterface.getCurrency(amount))+ ""String_Node_Str""+ StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.yellowify(IconomyInterface.getFormattedBalance(player.getName()),ChatColor.GREEN)+ ""String_Node_Str"");
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + ""String_Node_Str""+ StringUtils.yellowify(IconomyInterface.getCurrency(amount - IconomyInterface.getBalance(player.getName())),ChatColor.RED)+ ""String_Node_Str"");
    }
  }
 else   if (args[1].contains(""String_Node_Str"")) {
    if (EconomyHandler.canBuy(new Payment(amount,true),npc)) {
      EconomyHandler.pay(new Payment(amount,true),npc,-1);
      EconomyHandler.pay(new Payment(-amount,true),player,-1);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(IconomyInterface.getCurrency(amount))+ ""String_Node_Str""+ StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.yellowify(IconomyInterface.getFormattedBalance(player.getName()))+ ""String_Node_Str"");
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.yellowify(IconomyInterface.getCurrency(amount - npc.getBalance()),ChatColor.RED)+ ""String_Node_Str"");
    }
  }
 else   player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.yellowify(args[1],ChatColor.RED)+ ""String_Node_Str"");
}","/** 
 * Alters the selected trader's balance depending on the arguments given. Balance is used for iConomy.
 * @param player
 * @param npc
 * @param args
 */
private void changeBalance(Player player,HumanNPC npc,String[] args){
  double amount;
  try {
    amount=Double.parseDouble(args[2]);
  }
 catch (  NumberFormatException e) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  if (args[1].contains(""String_Node_Str"")) {
    if (EconomyHandler.canBuy(new Payment(amount,true),player)) {
      EconomyHandler.pay(new Payment(-amount,true),npc,-1);
      EconomyHandler.pay(new Payment(amount,true),player,-1);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(IconomyInterface.format(amount))+ ""String_Node_Str""+ StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.yellowify(IconomyInterface.getFormattedBalance(player.getName()),ChatColor.GREEN)+ ""String_Node_Str"");
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + ""String_Node_Str""+ StringUtils.yellowify(IconomyInterface.format(amount - IconomyInterface.getBalance(player.getName())),ChatColor.RED)+ ""String_Node_Str"");
    }
  }
 else   if (args[1].contains(""String_Node_Str"")) {
    if (EconomyHandler.canBuy(new Payment(amount,true),npc)) {
      EconomyHandler.pay(new Payment(amount,true),npc,-1);
      EconomyHandler.pay(new Payment(-amount,true),player,-1);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(IconomyInterface.format(amount))+ ""String_Node_Str""+ StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.yellowify(IconomyInterface.getFormattedBalance(player.getName()))+ ""String_Node_Str"");
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.yellowify(IconomyInterface.format(amount - npc.getBalance()),ChatColor.RED)+ ""String_Node_Str"");
    }
  }
 else   player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.yellowify(args[1],ChatColor.RED)+ ""String_Node_Str"");
}",0.9758430997369052
1986,"private void displayMoney(Player player,HumanNPC npc){
  player.sendMessage(StringUtils.yellowify(npc.getName()) + ""String_Node_Str"" + StringUtils.yellowify(IconomyInterface.getCurrency(npc.getBalance()))+ ""String_Node_Str"");
}","private void displayMoney(Player player,HumanNPC npc){
  player.sendMessage(StringUtils.yellowify(npc.getName()) + ""String_Node_Str"" + StringUtils.yellowify(IconomyInterface.format(npc.getBalance()))+ ""String_Node_Str"");
}",0.9621380846325168
1987,"/** 
 * Displays a list of buying/selling items for the selected trader npc.
 * @param player
 * @param npc
 * @param args
 * @param selling
 */
private void displayList(Player player,HumanNPC npc,String[] args,boolean selling){
  ArrayList<Stockable> stock=npc.getTrader().getStockables(selling);
  int page=0;
  int startPoint=0;
  int numPages=stock.size() / 4;
  if (numPages == 0)   numPages=1;
  String keyword=""String_Node_Str"";
  if (selling)   keyword=""String_Node_Str"";
 else   keyword=""String_Node_Str"";
  if (stock.size() == 0) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"" + keyword.toLowerCase()+ ""String_Node_Str"");
    return;
  }
  if (stock.size() > 4 && args.length == 3) {
    page=Integer.parseInt(args[2]);
    startPoint=(4 * page) - 1;
  }
  if (startPoint > stock.size() - 1) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.yellowify(numPages,ChatColor.RED)+ ""String_Node_Str"");
    return;
  }
  player.sendMessage(ChatColor.GOLD + ""String_Node_Str"" + keyword+ ""String_Node_Str""+ StringUtils.yellowify((page == 0 ? 1 : page),ChatColor.GOLD)+ ""String_Node_Str""+ StringUtils.yellowify(numPages,ChatColor.GOLD)+ ""String_Node_Str"");
  player.sendMessage(ChatColor.AQUA + ""String_Node_Str"");
  for (int i=startPoint; i != startPoint + 3; ++i) {
    if ((stock.size() - 1) >= i) {
      Stockable s=stock.get(i);
      player.sendMessage(ChatColor.GREEN + keyword + ""String_Node_Str""+ MessageUtils.getStockableMessage(s,ChatColor.GREEN)+ ""String_Node_Str"");
    }
 else {
      player.sendMessage(ChatColor.AQUA + ""String_Node_Str"");
      break;
    }
  }
}","/** 
 * Displays a list of buying/selling items for the selected trader npc.
 * @param player
 * @param npc
 * @param args
 * @param selling
 */
private void displayList(Player player,HumanNPC npc,String[] args,boolean selling){
  ArrayList<Stockable> stock=npc.getTrader().getStockables(selling);
  int page=0;
  int startPoint=0;
  int numPages=stock.size() / 4;
  if (numPages == 0)   numPages=1;
  String keyword=""String_Node_Str"";
  if (selling)   keyword=""String_Node_Str"";
 else   keyword=""String_Node_Str"";
  if (stock.size() == 0) {
    player.sendMessage(ChatColor.GRAY + ""String_Node_Str"" + keyword.toLowerCase()+ ""String_Node_Str"");
    return;
  }
  if (stock.size() > 4 && args.length == 3) {
    page=Integer.parseInt(args[2]);
    startPoint=(4 * page) - 1;
  }
  if (startPoint > stock.size() - 1) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.yellowify(numPages,ChatColor.RED)+ ""String_Node_Str"");
    return;
  }
  player.sendMessage(ChatColor.GOLD + ""String_Node_Str"" + keyword+ ""String_Node_Str""+ StringUtils.yellowify((page == 0 ? 1 : page),ChatColor.GOLD)+ ""String_Node_Str""+ StringUtils.yellowify(numPages,ChatColor.GOLD)+ ""String_Node_Str"");
  player.sendMessage(ChatColor.AQUA + ""String_Node_Str"");
  for (int i=startPoint; i != startPoint + 3; ++i) {
    if ((stock.size() - 1) >= i) {
      Stockable s=stock.get(i);
      if (selling)       player.sendMessage(ChatColor.GREEN + keyword + ""String_Node_Str""+ MessageUtils.getReverseStockableMessage(s,ChatColor.GREEN)+ ""String_Node_Str"");
 else       player.sendMessage(ChatColor.GREEN + keyword + ""String_Node_Str""+ MessageUtils.getStockableMessage(s,ChatColor.GREEN)+ ""String_Node_Str"");
    }
 else {
      player.sendMessage(ChatColor.AQUA + ""String_Node_Str"");
      break;
    }
  }
}",0.9481090589270008
1988,"/** 
 * Gets the currency of a payment (iConomy currency or item name).
 * @param payment
 * @return
 */
public static String getCurrency(Payment payment,ChatColor colour){
  if (useEconomy) {
    if (payment.isiConomy() && useIconomy())     return IconomyInterface.getCurrency(payment.getPrice());
 else     return ItemInterface.getCurrency(payment,colour);
  }
 else   return ""String_Node_Str"";
}","/** 
 * Gets the currency of a payment (iConomy currency or item name).
 * @param payment
 * @return
 */
public static String getCurrency(Payment payment,ChatColor colour){
  if (useEconomy) {
    if (payment.isiConomy() && useIconomy()) {
      return IconomyInterface.format(payment.getPrice());
    }
 else {
      return ItemInterface.getCurrency(payment,colour);
    }
  }
 else   return ""String_Node_Str"";
}",0.781750924784217
1989,"/** 
 * Gets what item ID or iConomy currency is being used for an operation.
 * @param op
 * @param amount
 * @return
 */
public static String getPaymentType(Operation op,String amount,ChatColor colour){
  if (useEconomy) {
    if (useIconomy())     return IconomyInterface.getCurrency(amount);
 else     return ItemInterface.getCurrency(op,colour);
  }
 else   return ""String_Node_Str"";
}","/** 
 * Gets what item ID or iConomy currency is being used for an operation.
 * @param op
 * @param amount
 * @return
 */
public static String getPaymentType(Operation op,String amount,ChatColor colour){
  if (useEconomy) {
    if (useIconomy())     return IconomyInterface.format(amount);
 else     return ItemInterface.getCurrency(op,colour);
  }
 else   return ""String_Node_Str"";
}",0.9780645161290322
1990,"public static String getFormattedBalance(String name){
  return getCurrency(getBalance(name));
}","public static String getFormattedBalance(String name){
  return format(getBalance(name));
}",0.9197860962566844
1991,"/** 
 * Checks whether an npc has enough in its balance for a payment.
 * @param payment
 * @param npc
 * @return
 */
public static boolean hasEnough(Payment payment,HumanNPC npc){
  return npc.getBalance() > payment.getPrice();
}","/** 
 * Checks whether an npc has enough in its balance for a payment.
 * @param payment
 * @param npc
 * @return
 */
public static boolean hasEnough(Payment payment,HumanNPC npc){
  return npc.getBalance() >= payment.getPrice();
}",0.9978308026030368
1992,"/** 
 * Pays for a payment using the player's money.
 * @param player
 * @param payment
 * @return
 */
public static double pay(Player player,Payment payment){
  iConomy.getAccount(player.getName()).getHoldings().subtract(payment.getPrice());
  return payment.getPrice();
}","/** 
 * Pays for a payment using the player's money.
 * @param player
 * @param payment
 * @return
 */
public static double pay(Player player,Payment payment){
  subtract(player.getName(),payment.getPrice());
  return payment.getPrice();
}",0.90234375
1993,"@Override public void onEntityDamage(EntityDamageEvent event){
  if (event instanceof EntityDamageByEntityEvent) {
    EntityDamageByEntityEvent e=(EntityDamageByEntityEvent)event;
    HumanNPC npc=NPCManager.getNPC(e.getEntity());
    if (e.getEntity() instanceof Player && npc != null) {
      e.setCancelled(true);
    }
    if (e.getDamager() instanceof Player && npc.isHealer()) {
      Entity entity=e.getDamager();
      if (entity instanceof Player) {
        Player player=(Player)entity;
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)player)) {
          int playerHealth=player.getHealth();
          int healerHealth=HealerPropertyPool.getStrength(npc.getUID());
          if (player.getItemInHand().getTypeId() == Citizens.healerTakeHealthItem) {
            if (playerHealth <= 19) {
              if (healerHealth >= 1) {
                player.setHealth(playerHealth + 1);
                HealerPropertyPool.saveStrength(npc.getUID(),healerHealth - 1);
                player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str"");
              }
 else {
                player.sendMessage(StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"");
              }
            }
 else {
              player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
            }
          }
 else           if (player.getItemInHand().getTypeId() == Citizens.healerGiveHealthItem) {
            if (playerHealth >= 1) {
              if (healerHealth < HealerPropertyPool.getMaxStrength(npc.getUID())) {
                player.setHealth(playerHealth - 1);
                HealerPropertyPool.saveStrength(npc.getUID(),healerHealth + 1);
                player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str"");
              }
 else {
                player.sendMessage(StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"");
              }
            }
 else {
              player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName()));
            }
          }
 else           if (player.getItemInHand().getType() == Material.DIAMOND_BLOCK) {
            if (healerHealth != HealerPropertyPool.getMaxStrength(npc.getUID())) {
              HealerPropertyPool.saveStrength(npc.getUID(),HealerPropertyPool.getMaxStrength(npc.getUID()));
              player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str"");
              int x=player.getItemInHand().getAmount();
              ItemStack diamondBlock=new ItemStack(Material.DIAMOND_BLOCK,x - 1);
              player.setItemInHand(diamondBlock);
            }
 else {
              player.sendMessage(StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"");
            }
          }
        }
 else {
          player.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
    }
    if (e.getDamager() instanceof Player && npc.isWizard()) {
      Entity entity=e.getDamager();
      if (entity instanceof Player) {
        Player player=(Player)entity;
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)player)) {
          if (player.getItemInHand().getTypeId() == Citizens.wizardInteractItem) {
            if (!npc.isWizard()) {
              return;
            }
            if (npc.getWizard().getNrOfLocations() > 0) {
              npc.getWizard().nextLocation();
              player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getWizard().getCurrentLocationName()));
            }
          }
        }
 else {
          player.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
    }
  }
}","@Override public void onEntityDamage(EntityDamageEvent event){
  if (event instanceof EntityDamageByEntityEvent) {
    EntityDamageByEntityEvent e=(EntityDamageByEntityEvent)event;
    HumanNPC npc=NPCManager.getNPC(e.getEntity());
    if (e.getEntity() instanceof Player && npc != null) {
      e.setCancelled(true);
    }
    if (npc != null && e.getDamager() instanceof Player && npc.isHealer()) {
      Entity entity=e.getDamager();
      if (entity instanceof Player) {
        Player player=(Player)entity;
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)player)) {
          int playerHealth=player.getHealth();
          int healerHealth=HealerPropertyPool.getStrength(npc.getUID());
          if (player.getItemInHand().getTypeId() == Citizens.healerTakeHealthItem) {
            if (playerHealth <= 19) {
              if (healerHealth >= 1) {
                player.setHealth(playerHealth + 1);
                HealerPropertyPool.saveStrength(npc.getUID(),healerHealth - 1);
                player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str"");
              }
 else {
                player.sendMessage(StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"");
              }
            }
 else {
              player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
            }
          }
 else           if (player.getItemInHand().getTypeId() == Citizens.healerGiveHealthItem) {
            if (playerHealth >= 1) {
              if (healerHealth < HealerPropertyPool.getMaxStrength(npc.getUID())) {
                player.setHealth(playerHealth - 1);
                HealerPropertyPool.saveStrength(npc.getUID(),healerHealth + 1);
                player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str"");
              }
 else {
                player.sendMessage(StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"");
              }
            }
 else {
              player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName()));
            }
          }
 else           if (player.getItemInHand().getType() == Material.DIAMOND_BLOCK) {
            if (healerHealth != HealerPropertyPool.getMaxStrength(npc.getUID())) {
              HealerPropertyPool.saveStrength(npc.getUID(),HealerPropertyPool.getMaxStrength(npc.getUID()));
              player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str"");
              int x=player.getItemInHand().getAmount();
              ItemStack diamondBlock=new ItemStack(Material.DIAMOND_BLOCK,x - 1);
              player.setItemInHand(diamondBlock);
            }
 else {
              player.sendMessage(StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"");
            }
          }
        }
 else {
          player.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
    }
    if (npc != null && e.getDamager() instanceof Player && npc.isWizard()) {
      Entity entity=e.getDamager();
      if (entity instanceof Player) {
        Player player=(Player)entity;
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)player)) {
          if (player.getItemInHand().getTypeId() == Citizens.wizardInteractItem) {
            if (!npc.isWizard()) {
              return;
            }
            if (npc.getWizard().getNrOfLocations() > 0) {
              npc.getWizard().nextLocation();
              player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getWizard().getCurrentLocationName()));
            }
          }
        }
 else {
          player.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
    }
  }
}",0.9960947669877636
1994,"@Override public void onEntityTarget(EntityTargetEvent event){
  if (!(event instanceof NPCEntityTargetEvent))   return;
  NPCEntityTargetEvent e=(NPCEntityTargetEvent)event;
  HumanNPC npc=NPCManager.getNPC(e.getEntity());
  if (NPCManager.getNPC(e.getTarget()) != null) {
    if (e.getEntity() instanceof Monster && !(e.getEntity() instanceof Player))     e.setCancelled(true);
  }
  if (npc != null && event.getTarget() instanceof Player) {
    if (e.getNpcReason() == NpcTargetReason.NPC_RIGHTCLICKED) {
      Player p=(Player)event.getTarget();
      boolean found=false;
      if (plugin.validateTool(""String_Node_Str"",p.getItemInHand().getTypeId()) == true) {
        CitizensBasicNPCEvent ev=new CitizensBasicNPCEvent(npc.getName(),MessageUtils.getText(npc,(Player)e.getTarget(),plugin),npc,Reason.RIGHT_CLICK,(Player)e.getTarget());
        plugin.getServer().getPluginManager().callEvent(ev);
        found=true;
      }
      if (npc.isTrader()) {
        TraderInterface.handleRightClick(npc,p);
        found=true;
      }
      if (npc.isWizard()) {
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)p)) {
          if (p.getItemInHand().getTypeId() == Citizens.wizardInteractItem) {
            if (npc.getWizard().getNrOfLocations() > 0) {
              this.buyTeleport(p,npc.getWizard(),Operation.WIZARD_TELEPORT);
              found=true;
            }
          }
        }
 else {
          p.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
      if (npc.isBlacksmith()) {
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)p)) {
          buyToolRepair(p,npc,Operation.BLACKSMITH_TOOL_REPAIR);
          found=true;
        }
 else {
          p.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
      if (found && !plugin.canSelectAny())       return;
      if (plugin.validateTool(""String_Node_Str"",p.getItemInHand().getTypeId()) == true) {
        if (!NPCManager.validateSelected(p,npc.getUID())) {
          NPCManager.NPCSelected.put(p.getName(),npc.getUID());
          p.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.yellowify(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str"");
        }
 else         if (!found && plugin.canSelectAny()) {
          p.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
        }
      }
    }
  }
}","@Override public void onEntityTarget(EntityTargetEvent event){
  if (!(event instanceof NPCEntityTargetEvent))   return;
  NPCEntityTargetEvent e=(NPCEntityTargetEvent)event;
  HumanNPC npc=NPCManager.getNPC(e.getEntity());
  if (NPCManager.getNPC(e.getTarget()) != null) {
    if (e.getEntity() instanceof Monster && !(e.getEntity() instanceof Player))     e.setCancelled(true);
  }
  if (npc != null && event.getTarget() instanceof Player) {
    if (e.getNpcReason() == NpcTargetReason.NPC_RIGHTCLICKED) {
      Player p=(Player)event.getTarget();
      if (plugin.validateTool(""String_Node_Str"",p.getItemInHand().getTypeId()) == true) {
        if (!NPCManager.validateSelected(p,npc.getUID())) {
          NPCManager.NPCSelected.put(p.getName(),npc.getUID());
          p.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.yellowify(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str"");
          return;
        }
      }
      if (plugin.validateTool(""String_Node_Str"",p.getItemInHand().getTypeId()) == true) {
        CitizensBasicNPCEvent ev=new CitizensBasicNPCEvent(npc.getName(),MessageUtils.getText(npc,(Player)e.getTarget(),plugin),npc,Reason.RIGHT_CLICK,(Player)e.getTarget());
        plugin.getServer().getPluginManager().callEvent(ev);
      }
      if (npc.isTrader()) {
        TraderInterface.handleRightClick(npc,p);
      }
      if (npc.isWizard()) {
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)p)) {
          if (p.getItemInHand().getTypeId() == Citizens.wizardInteractItem) {
            if (npc.getWizard().getNrOfLocations() > 0) {
              this.buyTeleport(p,npc.getWizard(),Operation.WIZARD_TELEPORT);
            }
          }
        }
 else {
          p.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
      if (npc.isBlacksmith()) {
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)p)) {
          buyToolRepair(p,npc,Operation.BLACKSMITH_TOOL_REPAIR);
        }
 else {
          p.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
    }
  }
}",0.7144422529037914
1995,"/** 
 * Purchase a tool repair
 * @param player
 * @param npc
 * @param op
 */
private void buyToolRepair(Player player,HumanNPC npc,Operation op){
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(op,player)) {
    if (EconomyHandler.useEconomy()) {
      double paid=EconomyHandler.pay(op,player);
      if (paid > 0) {
        ItemStack item=player.getItemInHand();
        if (validateToolToRepair(item)) {
          if (item.getDurability() > 0) {
            item.setDurability((short)0);
            player.sendMessage(StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"" + StringUtils.yellowify(EconomyHandler.getPaymentType(op,""String_Node_Str"" + paid,ChatColor.YELLOW))+ ""String_Node_Str"");
          }
 else {
            player.sendMessage(ChatColor.RED + ""String_Node_Str"");
          }
        }
      }
    }
 else {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    }
  }
 else   if (EconomyHandler.useEconomy()) {
    player.sendMessage(MessageUtils.getNoMoneyMessage(op,player));
    return;
  }
}","/** 
 * Purchase a tool repair
 * @param player
 * @param npc
 * @param op
 */
private void buyToolRepair(Player player,HumanNPC npc){
  if (!EconomyHandler.useEconomy() || EconomyHandler.canBuy(Operation.BLACKSMITH_TOOL_REPAIR,player)) {
    if (EconomyHandler.useEconomy()) {
      ItemStack item=player.getItemInHand();
      if (validateToolToRepair(item)) {
        if (item.getDurability() > 0) {
          double paid=EconomyHandler.pay(Operation.BLACKSMITH_TOOL_REPAIR,player);
          if (paid > 0) {
            item.setDurability((short)0);
            player.sendMessage(StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"" + StringUtils.yellowify(EconomyHandler.getPaymentType(Operation.BLACKSMITH_TOOL_REPAIR,""String_Node_Str"" + paid,ChatColor.YELLOW))+ ""String_Node_Str"");
          }
        }
 else {
          player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        }
      }
    }
 else {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"");
    }
  }
 else   if (EconomyHandler.useEconomy()) {
    player.sendMessage(MessageUtils.getNoMoneyMessage(Operation.BLACKSMITH_TOOL_REPAIR,player));
    return;
  }
}",0.7869742198100407
1996,"@Override public void onEntityDamage(EntityDamageEvent event){
  if (event instanceof EntityDamageByEntityEvent) {
    EntityDamageByEntityEvent e=(EntityDamageByEntityEvent)event;
    HumanNPC npc=NPCManager.getNPC(e.getEntity());
    if (e.getEntity() instanceof Player && npc != null) {
      e.setCancelled(true);
    }
    if (npc != null && e.getDamager() instanceof Player && npc.isHealer()) {
      Entity entity=e.getDamager();
      if (entity instanceof Player) {
        Player player=(Player)entity;
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)player)) {
          int playerHealth=player.getHealth();
          int healerHealth=HealerPropertyPool.getStrength(npc.getUID());
          if (player.getItemInHand().getTypeId() == Citizens.healerTakeHealthItem) {
            if (playerHealth <= 19) {
              if (healerHealth >= 1) {
                player.setHealth(playerHealth + 1);
                HealerPropertyPool.saveStrength(npc.getUID(),healerHealth - 1);
                player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str"");
              }
 else {
                player.sendMessage(StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"");
              }
            }
 else {
              player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
            }
          }
 else           if (player.getItemInHand().getTypeId() == Citizens.healerGiveHealthItem) {
            if (playerHealth >= 1) {
              if (healerHealth < HealerPropertyPool.getMaxStrength(npc.getUID())) {
                player.setHealth(playerHealth - 1);
                HealerPropertyPool.saveStrength(npc.getUID(),healerHealth + 1);
                player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str"");
              }
 else {
                player.sendMessage(StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"");
              }
            }
 else {
              player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName()));
            }
          }
 else           if (player.getItemInHand().getType() == Material.DIAMOND_BLOCK) {
            if (healerHealth != HealerPropertyPool.getMaxStrength(npc.getUID())) {
              HealerPropertyPool.saveStrength(npc.getUID(),HealerPropertyPool.getMaxStrength(npc.getUID()));
              player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str"");
              int amountInHand=player.getItemInHand().getAmount();
              if (amountInHand == 1) {
                ItemStack emptyStack=null;
                player.setItemInHand(emptyStack);
              }
 else {
                player.setItemInHand(new ItemStack(Material.DIAMOND_BLOCK,amountInHand - 1));
              }
            }
 else {
              player.sendMessage(StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"");
            }
          }
        }
 else {
          player.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
    }
    if (npc != null && e.getDamager() instanceof Player && npc.isWizard()) {
      Entity entity=e.getDamager();
      if (entity instanceof Player) {
        Player player=(Player)entity;
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)player)) {
          if (player.getItemInHand().getTypeId() == Citizens.wizardInteractItem) {
            if (!npc.isWizard()) {
              return;
            }
            if (npc.getWizard().getNrOfLocations() > 0) {
              npc.getWizard().nextLocation();
              player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getWizard().getCurrentLocationName()));
            }
          }
        }
 else {
          player.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
    }
  }
}","@Override public void onEntityDamage(EntityDamageEvent event){
  if (event instanceof EntityDamageByEntityEvent) {
    EntityDamageByEntityEvent e=(EntityDamageByEntityEvent)event;
    HumanNPC npc=NPCManager.getNPC(e.getEntity());
    if (e.getEntity() instanceof Player && npc != null) {
      e.setCancelled(true);
    }
    if (npc != null && e.getDamager() instanceof Player && npc.isHealer()) {
      Entity entity=e.getDamager();
      if (entity instanceof Player) {
        Player player=(Player)entity;
        int playerHealth=player.getHealth();
        int healerHealth=HealerPropertyPool.getStrength(npc.getUID());
        if (player.getItemInHand().getTypeId() == Citizens.healerTakeHealthItem) {
          if (playerHealth <= 19) {
            if (healerHealth >= 1) {
              player.setHealth(playerHealth + 1);
              HealerPropertyPool.saveStrength(npc.getUID(),healerHealth - 1);
              player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str"");
            }
 else {
              player.sendMessage(StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"");
            }
          }
 else {
            player.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
          }
        }
 else         if (player.getItemInHand().getTypeId() == Citizens.healerGiveHealthItem) {
          if (playerHealth >= 1) {
            if (healerHealth < HealerPropertyPool.getMaxStrength(npc.getUID())) {
              player.setHealth(playerHealth - 1);
              HealerPropertyPool.saveStrength(npc.getUID(),healerHealth + 1);
              player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str"");
            }
 else {
              player.sendMessage(StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"");
            }
          }
 else {
            player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName()));
          }
        }
 else         if (player.getItemInHand().getType() == Material.DIAMOND_BLOCK) {
          if (healerHealth != HealerPropertyPool.getMaxStrength(npc.getUID())) {
            HealerPropertyPool.saveStrength(npc.getUID(),HealerPropertyPool.getMaxStrength(npc.getUID()));
            player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str"");
            int amountInHand=player.getItemInHand().getAmount();
            if (amountInHand == 1) {
              ItemStack emptyStack=null;
              player.setItemInHand(emptyStack);
            }
 else {
              player.setItemInHand(new ItemStack(Material.DIAMOND_BLOCK,amountInHand - 1));
            }
          }
 else {
            player.sendMessage(StringUtils.yellowify(npc.getStrippedName()) + ""String_Node_Str"");
          }
        }
      }
    }
    if (npc != null && e.getDamager() instanceof Player && npc.isWizard()) {
      Entity entity=e.getDamager();
      if (entity instanceof Player) {
        Player player=(Player)entity;
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)player)) {
          if (player.getItemInHand().getTypeId() == Citizens.wizardInteractItem) {
            if (!npc.isWizard()) {
              return;
            }
            if (npc.getWizard().getNrOfLocations() > 0) {
              npc.getWizard().nextLocation();
              player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getWizard().getCurrentLocationName()));
            }
          }
        }
 else {
          player.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
    }
  }
}",0.9664169465254456
1997,"private boolean validateToolToRepair(ItemStack item){
  int id=item.getTypeId();
  if (id == 256 || id == 257 || id == 258 || id == 259 || id == 267 || id == 268 || id == 269 || id == 270 || id == 271 || id == 272 || id == 273 || id == 274 || id == 275 || id == 276 || id == 277 || id == 278 || id == 279 || id == 283 || id == 284 || id == 285 || id == 286 || id == 290 || id == 291 || id == 292 || id == 293 || id == 294 || id == 346) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Validate that a tool has a durability and can be repaired
 * @param item
 * @return
 */
private boolean validateToolToRepair(ItemStack item){
  int id=item.getTypeId();
  if (id == 256 || id == 257 || id == 258 || id == 259 || id == 267 || id == 268 || id == 269 || id == 270 || id == 271 || id == 272 || id == 273 || id == 274 || id == 275 || id == 276 || id == 277 || id == 278 || id == 279 || id == 283 || id == 284 || id == 285 || id == 286 || id == 290 || id == 291 || id == 292 || id == 293 || id == 294 || id == 346) {
    return true;
  }
 else {
    return false;
  }
}",0.9107806691449816
1998,"@Override public void onEntityTarget(EntityTargetEvent event){
  if (!(event instanceof NPCEntityTargetEvent))   return;
  NPCEntityTargetEvent e=(NPCEntityTargetEvent)event;
  HumanNPC npc=NPCManager.getNPC(e.getEntity());
  if (NPCManager.getNPC(e.getTarget()) != null) {
    if (e.getEntity() instanceof Monster && !(e.getEntity() instanceof Player))     e.setCancelled(true);
  }
  if (npc != null && event.getTarget() instanceof Player) {
    if (e.getNpcReason() == NpcTargetReason.NPC_RIGHTCLICKED) {
      Player p=(Player)event.getTarget();
      if (plugin.validateTool(""String_Node_Str"",p.getItemInHand().getTypeId()) == true) {
        if (!NPCManager.validateSelected(p,npc.getUID())) {
          NPCManager.NPCSelected.put(p.getName(),npc.getUID());
          p.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.yellowify(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str"");
          return;
        }
      }
      if (plugin.validateTool(""String_Node_Str"",p.getItemInHand().getTypeId()) == true) {
        CitizensBasicNPCEvent ev=new CitizensBasicNPCEvent(npc.getName(),MessageUtils.getText(npc,(Player)e.getTarget(),plugin),npc,Reason.RIGHT_CLICK,(Player)e.getTarget());
        plugin.getServer().getPluginManager().callEvent(ev);
      }
      if (npc.isTrader()) {
        TraderInterface.handleRightClick(npc,p);
      }
      if (npc.isWizard()) {
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)p)) {
          if (p.getItemInHand().getTypeId() == Citizens.wizardInteractItem) {
            if (npc.getWizard().getNrOfLocations() > 0) {
              this.buyTeleport(p,npc.getWizard(),Operation.WIZARD_TELEPORT);
            }
          }
        }
 else {
          p.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
      if (npc.isBlacksmith()) {
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)p)) {
          buyToolRepair(p,npc,Operation.BLACKSMITH_TOOL_REPAIR);
        }
 else {
          p.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
    }
  }
}","@Override public void onEntityTarget(EntityTargetEvent event){
  if (!(event instanceof NPCEntityTargetEvent))   return;
  NPCEntityTargetEvent e=(NPCEntityTargetEvent)event;
  HumanNPC npc=NPCManager.getNPC(e.getEntity());
  if (NPCManager.getNPC(e.getTarget()) != null) {
    if (e.getEntity() instanceof Monster && !(e.getEntity() instanceof Player))     e.setCancelled(true);
  }
  if (npc != null && event.getTarget() instanceof Player) {
    if (e.getNpcReason() == NpcTargetReason.NPC_RIGHTCLICKED) {
      Player p=(Player)event.getTarget();
      if (plugin.validateTool(""String_Node_Str"",p.getItemInHand().getTypeId()) == true) {
        if (!NPCManager.validateSelected(p,npc.getUID())) {
          NPCManager.NPCSelected.put(p.getName(),npc.getUID());
          p.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.yellowify(""String_Node_Str"" + npc.getUID())+ ""String_Node_Str"");
          return;
        }
      }
      if (plugin.validateTool(""String_Node_Str"",p.getItemInHand().getTypeId()) == true) {
        CitizensBasicNPCEvent ev=new CitizensBasicNPCEvent(npc.getName(),MessageUtils.getText(npc,(Player)e.getTarget(),plugin),npc,Reason.RIGHT_CLICK,(Player)e.getTarget());
        plugin.getServer().getPluginManager().callEvent(ev);
      }
      if (npc.isTrader()) {
        TraderInterface.handleRightClick(npc,p);
      }
      if (npc.isWizard()) {
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)p)) {
          if (p.getItemInHand().getTypeId() == Citizens.wizardInteractItem) {
            if (npc.getWizard().getNrOfLocations() > 0) {
              this.buyTeleport(p,npc.getWizard(),Operation.WIZARD_TELEPORT);
            }
          }
        }
 else {
          p.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
      if (npc.isBlacksmith()) {
        if (Permission.hasPermission(""String_Node_Str"",(CommandSender)p)) {
          buyToolRepair(p,npc);
        }
 else {
          p.sendMessage(MessageUtils.noPermissionsMessage);
        }
      }
    }
  }
}",0.9560103505057632
1999,"/** 
 * Adds an item to be stocked by the selected trader.
 * @param player
 * @param npc
 * @param item
 * @param price
 * @param selling
 */
private void changeTraderStock(Player player,HumanNPC npc,String item,String price,boolean selling){
  if (item.contains(""String_Node_Str"")) {
    Material mat=StringUtils.parseMaterial(price);
    if (mat == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
    String keyword=""String_Node_Str"";
    if (!selling)     keyword=""String_Node_Str"";
    if (npc.getTrader().getStockable(mat.getId(),selling) == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + keyword+ ""String_Node_Str"");
      return;
    }
 else {
      npc.getTrader().removeStockable(mat.getId(),selling);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(mat.name())+ ""String_Node_Str""+ keyword+ ""String_Node_Str"");
    }
    return;
  }
  String[] split=item.split(""String_Node_Str"");
  ItemStack stack=createItemStack(split);
  if (stack == null) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  split=price.split(""String_Node_Str"");
  ItemStack cost=null;
  if (split.length != 1) {
    cost=createItemStack(split);
    if (cost == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
  }
  if (cost == null) {
    if (!EconomyHandler.useIconomy()) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      return;
    }
  }
  int data=Citizens.MAGIC_DATA_VALUE;
  if (cost != null && cost.getData() != null)   data=cost.getData().getData();
  ItemPrice itemPrice;
  if (cost != null)   itemPrice=new ItemPrice(cost.getAmount(),cost.getTypeId(),data);
 else   itemPrice=new ItemPrice(Double.parseDouble(split[0]));
  itemPrice.setiConomy(cost == null);
  Stockable s=new Stockable(stack,itemPrice,false);
  String keyword=""String_Node_Str"";
  if (!selling) {
    keyword=""String_Node_Str"";
  }
  if (selling) {
    s.setSelling(true);
  }
  if (npc.getTrader().isStocked(s)) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"" + keyword+ ""String_Node_Str""+ MessageUtils.getStockableMessage(s,ChatColor.RED)+ ""String_Node_Str"");
    return;
  }
  npc.getTrader().addStockable(s);
  player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + keyword+ ""String_Node_Str""+ MessageUtils.getStockableMessage(s,ChatColor.GREEN)+ ""String_Node_Str"");
}","/** 
 * Adds an item to be stocked by the selected trader.
 * @param player
 * @param npc
 * @param item
 * @param price
 * @param selling
 */
private void changeTraderStock(Player player,HumanNPC npc,String item,String price,boolean selling){
  if (item.contains(""String_Node_Str"")) {
    Material mat=StringUtils.parseMaterial(price);
    if (mat == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
    String keyword=""String_Node_Str"";
    if (!selling)     keyword=""String_Node_Str"";
    if (npc.getTrader().getStockable(mat.getId(),selling) == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + keyword+ ""String_Node_Str"");
      return;
    }
 else {
      npc.getTrader().removeStockable(mat.getId(),selling);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(mat.name())+ ""String_Node_Str""+ keyword+ ""String_Node_Str"");
    }
    return;
  }
  String[] split=item.split(""String_Node_Str"");
  ItemStack stack=createItemStack(split);
  if (stack == null) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  split=price.split(""String_Node_Str"");
  ItemStack cost=null;
  if (split.length != 1) {
    cost=createItemStack(split);
    if (cost == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return;
    }
  }
  if (cost == null) {
    if (!EconomyHandler.useIconomy()) {
      player.sendMessage(ChatColor.GRAY + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      return;
    }
  }
  int data=Citizens.MAGIC_DATA_VALUE;
  if (cost != null && cost.getData() != null)   data=cost.getData().getData();
  ItemPrice itemPrice;
  if (cost != null)   itemPrice=new ItemPrice(cost.getAmount(),cost.getTypeId(),data);
 else   itemPrice=new ItemPrice(Double.parseDouble(split[0]));
  itemPrice.setiConomy(cost == null);
  Stockable s=new Stockable(stack,itemPrice,true);
  String keyword=""String_Node_Str"";
  if (!selling) {
    keyword=""String_Node_Str"";
    s.setSelling(false);
  }
  if (npc.getTrader().isStocked(s)) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"" + keyword+ ""String_Node_Str""+ MessageUtils.getStockableMessage(s,ChatColor.RED)+ ""String_Node_Str"");
    return;
  }
  npc.getTrader().addStockable(s);
  player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + keyword+ ""String_Node_Str""+ MessageUtils.getStockableMessage(s,ChatColor.GREEN)+ ""String_Node_Str"");
}",0.962827544180378
2000,"/** 
 * Alters the selected trader's balance depending on the arguments given. Balance is used for iConomy.
 * @param player
 * @param npc
 * @param args
 * @throws NumberFormatException
 */
private void changeBalance(Player player,HumanNPC npc,String[] args) throws NumberFormatException {
  try {
    double amount=Double.parseDouble(args[2]);
    if (args[1].equals(""String_Node_Str"")) {
      if (EconomyHandler.canBuy(new Payment(amount,true),player)) {
        EconomyHandler.pay(new Payment(-amount,true),npc,-1);
        EconomyHandler.pay(new Payment(amount,true),player,-1);
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(IconomyInterface.getCurrency(amount))+ ""String_Node_Str""+ StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.yellowify(IconomyInterface.getCurrency(player.getName()),ChatColor.GREEN)+ ""String_Node_Str"");
      }
 else {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"" + ""String_Node_Str""+ StringUtils.yellowify(IconomyInterface.getCurrency(amount - IconomyInterface.getBalance(player.getName())),ChatColor.RED)+ ""String_Node_Str"");
      }
    }
 else     if (args[1].equals(""String_Node_Str"")) {
      if (EconomyHandler.canBuy(new Payment(amount,true),npc)) {
        EconomyHandler.pay(new Payment(amount,true),npc,-1);
        EconomyHandler.pay(new Payment(-amount,true),player,-1);
        player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(IconomyInterface.getCurrency(amount))+ ""String_Node_Str""+ StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.yellowify(IconomyInterface.getBalance(player.getName()))+ ""String_Node_Str"");
      }
 else {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.yellowify(IconomyInterface.getCurrency(amount - npc.getBalance()),ChatColor.RED)+ ""String_Node_Str"");
      }
    }
 else     player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.yellowify(args[1],ChatColor.RED)+ ""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
  }
}","/** 
 * Alters the selected trader's balance depending on the arguments given. Balance is used for iConomy.
 * @param player
 * @param npc
 * @param args
 * @throws NumberFormatException
 */
private void changeBalance(Player player,HumanNPC npc,String[] args){
  double amount;
  try {
    amount=Double.parseDouble(args[2]);
  }
 catch (  NumberFormatException e) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return;
  }
  if (args[1].contains(""String_Node_Str"")) {
    if (EconomyHandler.canBuy(new Payment(amount,true),player)) {
      EconomyHandler.pay(new Payment(-amount,true),npc,-1);
      EconomyHandler.pay(new Payment(amount,true),player,-1);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(IconomyInterface.getCurrency(amount))+ ""String_Node_Str""+ StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.yellowify(IconomyInterface.getFormattedBalance(player.getName()),ChatColor.GREEN)+ ""String_Node_Str"");
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + ""String_Node_Str""+ StringUtils.yellowify(IconomyInterface.getCurrency(amount - IconomyInterface.getBalance(player.getName())),ChatColor.RED)+ ""String_Node_Str"");
    }
  }
 else   if (args[1].contains(""String_Node_Str"")) {
    if (EconomyHandler.canBuy(new Payment(amount,true),npc)) {
      EconomyHandler.pay(new Payment(amount,true),npc,-1);
      EconomyHandler.pay(new Payment(-amount,true),player,-1);
      player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + StringUtils.yellowify(IconomyInterface.getCurrency(amount))+ ""String_Node_Str""+ StringUtils.yellowify(npc.getStrippedName())+ ""String_Node_Str""+ StringUtils.yellowify(IconomyInterface.getFormattedBalance(player.getName()))+ ""String_Node_Str"");
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.yellowify(IconomyInterface.getCurrency(amount - npc.getBalance()),ChatColor.RED)+ ""String_Node_Str"");
    }
  }
 else   player.sendMessage(ChatColor.RED + ""String_Node_Str"" + StringUtils.yellowify(args[1],ChatColor.RED)+ ""String_Node_Str"");
}",0.9110119746419348
