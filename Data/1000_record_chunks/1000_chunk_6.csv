record_number,buggy_code,fixed_code,code_similarity
5001,"public boolean getForceIPAddress(){
  return _forceIPAddress;
}","/** 
 * Returns true iff this should force its IP address. 
 */
public boolean getForceIPAddress(){
  return _forceIPAddress;
}",0.6631578947368421
5002,"public String getForcedIPAddressString(){
  return _forcedIPAddressString;
}","/** 
 * Returns the forced IP address in dotted-quad format. 
 */
public String getForcedIPAddressString(){
  return Message.ip2string(_forcedIPAddress);
}",0.6060606060606061
5003,"/** 
 * Sets the directory for saving files. 
 * @param saveDir  A <code>File</code> instance denoting the abstract pathname of the directory for saving files.  
 * @throws IOException If the directory denoted by the directory pathname String parameter did not exist prior to this method call and could not be created, or if the canonical path could not be retrieved from the file system.
 * @throws NullPointerException If the ""dir"" parameter is null.
 */
public void setSaveDirectory(File saveDir) throws IOException {
  if (saveDir == null)   throw new NullPointerException();
  String parentDir=saveDir.getParent();
  File incDir=new File(parentDir,""String_Node_Str"");
  if (!saveDir.isDirectory()) {
    if (!saveDir.mkdirs())     throw new IOException();
  }
  if (!incDir.isDirectory()) {
    if (!incDir.mkdirs())     throw new IOException();
  }
  _saveDirectory=saveDir;
  _incompleteDirectory=incDir;
  _props.put(SAVE_DIRECTORY,saveDir);
}","/** 
 * Sets the directory for saving files. 
 * @param saveDir  A <code>File</code> instance denoting the abstract pathname of the directory for saving files.  
 * @throws IOException If the directory denoted by the directory pathname String parameter did not exist prior to this method call and could not be created, or if the canonical path could not be retrieved from the file system.
 * @throws NullPointerException If the ""dir"" parameter is null.
 */
public void setSaveDirectory(File saveDir) throws IOException {
  if (saveDir == null)   throw new NullPointerException();
  String parentDir=saveDir.getParent();
  File incDir=new File(parentDir,""String_Node_Str"");
  if (!saveDir.isDirectory()) {
    if (!saveDir.mkdirs())     throw new IOException();
  }
  if (!incDir.isDirectory()) {
    if (!incDir.mkdirs())     throw new IOException();
  }
  _saveDirectory=saveDir;
  _incompleteDirectory=incDir;
  _props.put(SAVE_DIRECTORY,saveDir.getAbsolutePath());
}",0.990625
5004,"/** 
 * Load in the default values.  Any properties written to the real properties file will overwrite these. 
 */
private void loadDefaults(){
  setAllowBrowser(DEFAULT_ALLOW_BROWSER);
  setMaxTTL(DEFAULT_MAX_TTL);
  setSoftMaxTTL(DEFAULT_SOFT_MAX_TTL);
  setTTL(DEFAULT_TTL);
  setMaxLength(DEFAULT_MAX_LENGTH);
  setTimeout(DEFAULT_TIMEOUT);
  setHostList(DEFAULT_HOST_LIST);
  setKeepAlive(DEFAULT_KEEP_ALIVE);
  setPort(DEFAULT_PORT);
  setConnectionSpeed(DEFAULT_SPEED);
  setUploadSpeed(DEFAULT_UPLOAD_SPEED);
  setSearchLimit(DEFAULT_SEARCH_LIMIT);
  setClientID((new GUID(Message.makeGuid())).toHexString());
  setMaxIncomingConnections(DEFAULT_MAX_INCOMING_CONNECTION);
  setBannedIps(DEFAULT_BANNED_IPS);
  setBannedWords(DEFAULT_BANNED_WORDS);
  setFilterAdult(DEFAULT_FILTER_ADULT);
  setFilterDuplicates(DEFAULT_FILTER_DUPLICATES);
  setFilterVbs(DEFAULT_FILTER_VBS);
  setFilterHtml(DEFAULT_FILTER_HTML);
  setFilterGreedyQueries(DEFAULT_FILTER_GREEDY_QUERIES);
  setExtensions(DEFAULT_EXTENSIONS);
  setBannedIps(SettingsInterface.DEFAULT_BANNED_IPS);
  setBannedWords(SettingsInterface.DEFAULT_BANNED_WORDS);
  setFilterAdult(SettingsInterface.DEFAULT_FILTER_ADULT);
  setFilterDuplicates(SettingsInterface.DEFAULT_FILTER_DUPLICATES);
  setFilterVbs(SettingsInterface.DEFAULT_FILTER_VBS);
  setFilterHtml(SettingsInterface.DEFAULT_FILTER_HTML);
  setFilterGreedyQueries(DEFAULT_FILTER_GREEDY_QUERIES);
  setFilterBearShareQueries(SettingsInterface.DEFAULT_FILTER_BEARSHARE_QUERIES);
  setUseQuickConnect(DEFAULT_USE_QUICK_CONNECT);
  setQuickConnectHosts(DEFAULT_QUICK_CONNECT_HOSTS);
  setParallelSearchMax(DEFAULT_PARALLEL_SEARCH);
  setClearCompletedUpload(DEFAULT_CLEAR_UPLOAD);
  setClearCompletedDownload(DEFAULT_CLEAR_DOWNLOAD);
  setMaxSimDownload(DEFAULT_MAX_SIM_DOWNLOAD);
  setPromptExeDownload(DEFAULT_PROMPT_EXE_DOWNLOAD);
  setMaxUploads(DEFAULT_MAX_UPLOADS);
  setSearchAnimationTime(DEFAULT_SEARCH_ANIMATION_TIME);
  setConnectString(DEFAULT_CONNECT_STRING);
  setConnectOkString(DEFAULT_CONNECT_OK_STRING);
  setCheckAgain(DEFAULT_CHECK_AGAIN);
  setBasicInfoForQuery(DEFAULT_BASIC_INFO_FOR_QUERY);
  setAdvancedInfoForQuery(DEFAULT_ADVANCED_INFO_FOR_QUERY);
  setForceIPAddress(DEFAULT_FORCE_IP_ADDRESS);
  setForcedIPAddress(DEFAULT_FORCED_IP_ADDRESS);
  setForcedIPAddressString(DEFAULT_FORCED_IP_ADDRESS_STRING);
  setForcedPort(DEFAULT_FORCED_PORT);
  setFreeloaderFiles(DEFAULT_FREELOADER_FILES);
  setFreeloaderAllowed(DEFAULT_FREELOADER_ALLOWED);
  setUploadsPerPerson(DEFAULT_UPLOADS_PER_PERSON);
  setAverageUptime(DEFAULT_AVERAGE_UPTIME);
  setTotalUptime(DEFAULT_TOTAL_UPTIME);
  setSessions(DEFAULT_SESSIONS);
  setInstalled(DEFAULT_INSTALLED);
  setRunOnce(DEFAULT_RUN_ONCE);
  setShowTrayDialog(DEFAULT_SHOW_TRAY_DIALOG);
  setMinimizeToTray(DEFAULT_MINIMIZE_TO_TRAY);
  setShowCloseDialog(DEFAULT_SHOW_CLOSE_DIALOG);
  setLimeWireJarName(DEFAULT_LIME_WIRE_JAR_NAME);
}","/** 
 * Load in the default values.  Any properties written to the real properties file will overwrite these. 
 */
private void loadDefaults(){
  setAllowBrowser(DEFAULT_ALLOW_BROWSER);
  setMaxTTL(DEFAULT_MAX_TTL);
  setSoftMaxTTL(DEFAULT_SOFT_MAX_TTL);
  setTTL(DEFAULT_TTL);
  setMaxLength(DEFAULT_MAX_LENGTH);
  setTimeout(DEFAULT_TIMEOUT);
  setHostList(DEFAULT_HOST_LIST);
  setKeepAlive(DEFAULT_KEEP_ALIVE);
  setPort(DEFAULT_PORT);
  setConnectionSpeed(DEFAULT_SPEED);
  setUploadSpeed(DEFAULT_UPLOAD_SPEED);
  setSearchLimit(DEFAULT_SEARCH_LIMIT);
  setClientID((new GUID(Message.makeGuid())).toHexString());
  setMaxIncomingConnections(DEFAULT_MAX_INCOMING_CONNECTION);
  setBannedIps(DEFAULT_BANNED_IPS);
  setBannedWords(DEFAULT_BANNED_WORDS);
  setFilterAdult(DEFAULT_FILTER_ADULT);
  setFilterDuplicates(DEFAULT_FILTER_DUPLICATES);
  setFilterVbs(DEFAULT_FILTER_VBS);
  setFilterHtml(DEFAULT_FILTER_HTML);
  setFilterGreedyQueries(DEFAULT_FILTER_GREEDY_QUERIES);
  setExtensions(DEFAULT_EXTENSIONS);
  setBannedIps(SettingsInterface.DEFAULT_BANNED_IPS);
  setBannedWords(SettingsInterface.DEFAULT_BANNED_WORDS);
  setFilterAdult(SettingsInterface.DEFAULT_FILTER_ADULT);
  setFilterDuplicates(SettingsInterface.DEFAULT_FILTER_DUPLICATES);
  setFilterVbs(SettingsInterface.DEFAULT_FILTER_VBS);
  setFilterHtml(SettingsInterface.DEFAULT_FILTER_HTML);
  setFilterGreedyQueries(DEFAULT_FILTER_GREEDY_QUERIES);
  setFilterBearShareQueries(SettingsInterface.DEFAULT_FILTER_BEARSHARE_QUERIES);
  setUseQuickConnect(DEFAULT_USE_QUICK_CONNECT);
  setQuickConnectHosts(DEFAULT_QUICK_CONNECT_HOSTS);
  setParallelSearchMax(DEFAULT_PARALLEL_SEARCH);
  setClearCompletedUpload(DEFAULT_CLEAR_UPLOAD);
  setClearCompletedDownload(DEFAULT_CLEAR_DOWNLOAD);
  setMaxSimDownload(DEFAULT_MAX_SIM_DOWNLOAD);
  setPromptExeDownload(DEFAULT_PROMPT_EXE_DOWNLOAD);
  setMaxUploads(DEFAULT_MAX_UPLOADS);
  setSearchAnimationTime(DEFAULT_SEARCH_ANIMATION_TIME);
  setConnectString(DEFAULT_CONNECT_STRING);
  setConnectOkString(DEFAULT_CONNECT_OK_STRING);
  setCheckAgain(DEFAULT_CHECK_AGAIN);
  setBasicInfoForQuery(DEFAULT_BASIC_INFO_FOR_QUERY);
  setAdvancedInfoForQuery(DEFAULT_ADVANCED_INFO_FOR_QUERY);
  setForceIPAddress(DEFAULT_FORCE_IP_ADDRESS);
  setForcedIPAddress(DEFAULT_FORCED_IP_ADDRESS);
  setForcedIPAddressString(DEFAULT_FORCED_IP_ADDRESS_STRING);
  setForcedPort(DEFAULT_FORCED_PORT);
  setFreeloaderFiles(DEFAULT_FREELOADER_FILES);
  setFreeloaderAllowed(DEFAULT_FREELOADER_ALLOWED);
  setUploadsPerPerson(DEFAULT_UPLOADS_PER_PERSON);
  setAverageUptime(DEFAULT_AVERAGE_UPTIME);
  setTotalUptime(DEFAULT_TOTAL_UPTIME);
  setSessions(DEFAULT_SESSIONS);
  setInstalled(DEFAULT_INSTALLED);
  setRunOnce(DEFAULT_RUN_ONCE);
  setShowTrayDialog(DEFAULT_SHOW_TRAY_DIALOG);
  setMinimizeToTray(DEFAULT_MINIMIZE_TO_TRAY);
  setShowCloseDialog(DEFAULT_SHOW_CLOSE_DIALOG);
  setClassPath(DEFAULT_CLASSPATH);
}",0.9881463666036764
5005,"/** 
 * launches the passed-in file on the current platform. 
 * @requires the path String must either be a valid path namefor the operating system, or it must be a URL of the form http://www.whatevername.com
 */
public static int launch(String path) throws IOException {
  path=path.toLowerCase();
  if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")&& !path.endsWith(""String_Node_Str"")&& !path.endsWith(""String_Node_Str"")&& !path.endsWith(""String_Node_Str"")) {
    if (CommonUtils.isWindows()) {
      return launchFileWindows(path);
    }
 else     if (CommonUtils.isMacClassic()) {
      launchFileMacClassic(path);
    }
 else     if (CommonUtils.isUnix()) {
      launchFileUnix(path);
    }
  }
 else {
    String msg=""String_Node_Str"" + ""String_Node_Str"";
    MessageService.showError(msg);
  }
  return -1;
}","/** 
 * launches the passed-in file on the current platform. 
 * @requires the path String must either be a valid path namefor the operating system, or it must be a URL of the form http://www.whatevername.com
 */
public static int launch(String path) throws IOException {
  String extCheckString=path.toLowerCase();
  if (!extCheckString.endsWith(""String_Node_Str"") && !extCheckString.endsWith(""String_Node_Str"") && !extCheckString.endsWith(""String_Node_Str"")&& !extCheckString.endsWith(""String_Node_Str"")&& !extCheckString.endsWith(""String_Node_Str"")&& !extCheckString.endsWith(""String_Node_Str"")) {
    if (CommonUtils.isWindows()) {
      return launchFileWindows(path);
    }
 else     if (CommonUtils.isMacClassic()) {
      launchFileMacClassic(path);
    }
 else     if (CommonUtils.isUnix()) {
      launchFileUnix(path);
    }
  }
 else {
    String msg=""String_Node_Str"" + ""String_Node_Str"";
    MessageService.showError(msg);
  }
  return -1;
}",0.927441352973268
5006,"/** 
 * launches the passed-in file on the current platform. 
 * @requires the path String must either be a valid path namefor the operating system, or it must be a URL of the form http://www.whatevername.com
 */
public static int launch(String path) throws IOException {
  String s=path.toLowerCase();
  if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")&& !path.endsWith(""String_Node_Str"")&& !path.endsWith(""String_Node_Str"")&& !path.endsWith(""String_Node_Str"")) {
    if (CommonUtils.isWindows()) {
      return launchFileWindows(path);
    }
 else     if (CommonUtils.isMacClassic()) {
      launchFileMacClassic(path);
    }
 else     if (CommonUtils.isUnix()) {
      launchFileUnix(path);
    }
  }
 else {
    String msg=""String_Node_Str"" + ""String_Node_Str"";
    MessageService.showError(msg);
  }
  return -1;
}","/** 
 * launches the passed-in file on the current platform. 
 * @requires the path String must either be a valid path namefor the operating system, or it must be a URL of the form http://www.whatevername.com
 */
public static int launch(String path) throws IOException {
  path=path.toLowerCase();
  if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")&& !path.endsWith(""String_Node_Str"")&& !path.endsWith(""String_Node_Str"")&& !path.endsWith(""String_Node_Str"")) {
    if (CommonUtils.isWindows()) {
      return launchFileWindows(path);
    }
 else     if (CommonUtils.isMacClassic()) {
      launchFileMacClassic(path);
    }
 else     if (CommonUtils.isUnix()) {
      launchFileUnix(path);
    }
  }
 else {
    String msg=""String_Node_Str"" + ""String_Node_Str"";
    MessageService.showError(msg);
  }
  return -1;
}",0.9931818181818182
5007,"private void clearFailedPushes(){
  Date time=new Date();
  time.setTime(time.getTime() - (PUSH_INVALIDATE_TIME * 1000));
  Iterator iter=_failedPushes.iterator();
  while (iter.hasNext()) {
    PushedFile pf=(PushedFile)iter.next();
    if (pf.before(time))     iter.remove();
  }
}","/** 
 * @requires caller has this' monitor 
 */
private void clearFailedPushes(){
  Date time=new Date();
  time.setTime(time.getTime() - (PUSH_INVALIDATE_TIME * 1000));
  Iterator iter=_failedPushes.iterator();
  while (iter.hasNext()) {
    PushedFile pf=(PushedFile)iter.next();
    if (pf.before(time))     iter.remove();
  }
}",0.9218241042345277
5008,"public void run(){
  try {
    _up.connect();
    try {
synchronized (UploadManager.this) {
        _activeUploads++;
      }
      _up.start();
    }
  finally {
synchronized (UploadManager.this) {
        _activeUploads--;
      }
    }
  }
 catch (  IOException e) {
    insertFailedPush(_host);
    return;
  }
 finally {
synchronized (UploadManager.this) {
      removeFromMap(_host);
      removeAttemptedPush(_host);
    }
  }
}","public void run(){
  try {
    _up.connect();
    try {
synchronized (UploadManager.this) {
        _activeUploads++;
      }
      _up.start();
    }
  finally {
synchronized (UploadManager.this) {
        _activeUploads--;
      }
    }
  }
 catch (  IOException e) {
synchronized (UploadManager.this) {
      insertFailedPush(_host);
    }
    return;
  }
 finally {
synchronized (UploadManager.this) {
      removeFromMap(_host);
      removeAttemptedPush(_host);
    }
  }
}",0.9518599562363238
5009,"private void insertFailedPush(String host){
  _failedPushes.add(new PushedFile(host));
}","/** 
 * @requires caller has this' monitor 
 */
private void insertFailedPush(String host){
  _failedPushes.add(new PushedFile(host));
}",0.7857142857142857
5010,"/** 
 * Returns all the field names in the passed document. The fields returned are in canonicalized form.
 * @param document The XML Schema documnet from where to extract fields
 * @requires The document be a valid XML Schema without any errors
 * @return A list containing all the field names in the passed document. The fields returned are in canonicalized form.
 * @see XMLStringUtils for more information on canonicalized form
 */
public static List getFields(Document document){
  try {
    Element root=document.getDocumentElement();
    traverse(root);
    String rootElementName=getRootElementName();
    List fieldNames=new LinkedList();
    fillWithFieldNames(fieldNames,(FieldTypeSet)_nameFieldTypeSetMap.get(rootElementName),rootElementName);
    System.out.println(""String_Node_Str"" + fieldNames);
    return fieldNames;
  }
 catch (  NullPointerException npe) {
    return new LinkedList();
  }
}","/** 
 * Returns all the field names in the passed document. The fields returned are in canonicalized form.
 * @param document The XML Schema documnet from where to extract fields
 * @requires The document be a valid XML Schema without any errors
 * @return A list containing all the field names in the passed document. The fields returned are in canonicalized form.
 * @see XMLStringUtils for more information on canonicalized form
 */
public synchronized static List getFields(Document document){
  try {
    reInitializeMemberFields();
    Element root=document.getDocumentElement();
    traverse(root);
    String rootElementName=getRootElementName();
    List fieldNames=new LinkedList();
    fillWithFieldNames(fieldNames,(FieldTypeSet)_nameFieldTypeSetMap.get(rootElementName),rootElementName);
    System.out.println(""String_Node_Str"" + fieldNames);
    return fieldNames;
  }
 catch (  NullPointerException npe) {
    return new LinkedList();
  }
}",0.9758971612212104
5011,"public void run(){
  try {
    _up.connect();
    try {
synchronized (UploadManager.this) {
        _activeUploads++;
      }
      _up.start();
    }
  finally {
synchronized (UploadManager.this) {
        _activeUploads--;
      }
    }
  }
 catch (  IOException e) {
synchronized (UploadManager.this) {
      insertFailedPush(_host);
    }
    return;
  }
 finally {
synchronized (UploadManager.this) {
      removeFromMap(_host);
      removeAttemptedPush(_host);
    }
  }
}","public void run(){
  try {
    _up.connect();
    try {
synchronized (UploadManager.this) {
        _activeUploads++;
      }
      _up.start();
    }
  finally {
synchronized (UploadManager.this) {
        _activeUploads--;
      }
    }
  }
 catch (  IOException e) {
synchronized (UploadManager.this) {
      insertFailedPush(_host,_index);
    }
    return;
  }
 finally {
synchronized (UploadManager.this) {
      removeFromMap(_host);
      removeAttemptedPush(_host,_index);
    }
  }
}",0.9567901234567902
5012,"public synchronized void acceptUpload(Socket socket){
  HTTPUploader uploader;
  GETLine line;
  try {
    line=parseGET(socket);
  }
 catch (  IOException e) {
    return;
  }
  uploader=new HTTPUploader(line._file,socket,line._index,this);
  String host=socket.getInetAddress().getHostAddress();
  insertAndTest(uploader,host);
  UploadRunner runner=new UploadRunner(uploader,host);
  Thread upThread=new Thread(runner);
  upThread.setDaemon(true);
  upThread.start();
}","public synchronized void acceptUpload(Socket socket){
  HTTPUploader uploader;
  GETLine line;
  try {
    line=parseGET(socket);
  }
 catch (  IOException e) {
    return;
  }
  uploader=new HTTPUploader(line._file,socket,line._index,this);
  String host=socket.getInetAddress().getHostAddress();
  insertAndTest(uploader,host);
  UploadRunner runner=new UploadRunner(uploader,host,line._index);
  Thread upThread=new Thread(runner);
  upThread.setDaemon(true);
  upThread.start();
}",0.98744769874477
5013,"public PushedFile(String host){
  _host=host;
  _time=new Date();
}","public PushedFile(String host,int index){
  _host=host;
  _index=index;
  _time=new Date();
}",0.8375
5014,"private void insertAttemptedPush(String host){
  _attemptingPushes.add(new PushedFile(host));
}","private void insertAttemptedPush(String host,int index){
  _attemptingPushes.add(new PushedFile(host,index));
}",0.9223300970873788
5015,"private boolean testAttemptedPush(String host){
  PushedFile pf=new PushedFile(host);
  PushedFile pfile;
  Iterator iter=_attemptingPushes.iterator();
  while (iter.hasNext()) {
    pfile=(PushedFile)iter.next();
    if (pf.equals(pfile))     return false;
  }
  return true;
}","private boolean testAttemptedPush(String host,int index){
  PushedFile pf=new PushedFile(host,index);
  PushedFile pfile;
  Iterator iter=_attemptingPushes.iterator();
  while (iter.hasNext()) {
    pfile=(PushedFile)iter.next();
    if (pf.equals(pfile))     return false;
  }
  return true;
}",0.972027972027972
5016,"public synchronized void acceptPushUpload(String file,String host,int port,int index,String guid){
  clearFailedPushes();
  Uploader uploader;
  uploader=new HTTPUploader(file,host,port,index,guid,this);
  if ((!testAttemptedPush(host)) || (!testFailedPush(host)))   return;
  insertAndTest(uploader,host);
  insertAttemptedPush(host);
  UploadRunner runner=new UploadRunner(uploader,host);
  Thread upThread=new Thread(runner);
  upThread.setDaemon(true);
  upThread.start();
}","public synchronized void acceptPushUpload(String file,String host,int port,int index,String guid){
  clearFailedPushes();
  Uploader uploader;
  uploader=new HTTPUploader(file,host,port,index,guid,this);
  if ((!testAttemptedPush(host,index)) || (!testFailedPush(host,index)))   return;
  insertAndTest(uploader,host);
  insertAttemptedPush(host,index);
  UploadRunner runner=new UploadRunner(uploader,host,index);
  Thread upThread=new Thread(runner);
  upThread.setDaemon(true);
  upThread.start();
}",0.9755102040816328
5017,"public UploadRunner(Uploader up,String host){
  _up=up;
  _host=host;
}","public UploadRunner(Uploader up,String host,int index){
  _up=up;
  _host=host;
  _index=index;
}",0.8452380952380952
5018,"private boolean testFailedPush(String host){
  PushedFile pf=new PushedFile(host);
  PushedFile pfile;
  Iterator iter=_failedPushes.iterator();
  while (iter.hasNext()) {
    pfile=(PushedFile)iter.next();
    if (pf.equals(pfile))     return false;
  }
  return true;
}","private boolean testFailedPush(String host,int index){
  PushedFile pf=new PushedFile(host,index);
  PushedFile pfile;
  Iterator iter=_failedPushes.iterator();
  while (iter.hasNext()) {
    pfile=(PushedFile)iter.next();
    if (pf.equals(pfile))     return false;
  }
  return true;
}",0.971326164874552
5019,"public boolean equals(PushedFile pf){
  if (_host != pf._host)   return false;
  return true;
}","/** 
 * Returns true iff o is a PushedFile with same _host and _index. Time doesn't matter. 
 */
public boolean equals(Object o){
  if (!(o instanceof PushedFile))   return false;
  PushedFile pf=(PushedFile)o;
  return _index == pf._index && _host.equals(pf._host);
}",0.2589531680440771
5020,"/** 
 * @requires caller has this' monitor 
 */
private void insertFailedPush(String host){
  _failedPushes.add(new PushedFile(host));
}","/** 
 * @requires caller has this' monitor 
 */
private void insertFailedPush(String host,int index){
  _failedPushes.add(new PushedFile(host,index));
}",0.9444444444444444
5021,"private void removeAttemptedPush(String host){
  PushedFile pf=new PushedFile(host);
  PushedFile pfile;
  Iterator iter=_attemptingPushes.iterator();
  while (iter.hasNext()) {
    pfile=(PushedFile)iter.next();
    if (pf.equals(pfile))     iter.remove();
  }
}","private void removeAttemptedPush(String host,int index){
  PushedFile pf=new PushedFile(host,index);
  PushedFile pfile;
  Iterator iter=_attemptingPushes.iterator();
  while (iter.hasNext()) {
    pfile=(PushedFile)iter.next();
    if (pf.equals(pfile))     iter.remove();
  }
}",0.970479704797048
5022,"/** 
 * Returns this' address to use for ping replies, query replies, and pushes.
 */
public byte[] getAddress(){
  if (SettingsManager.instance().getForceIPAddress())   return SettingsManager.instance().getForcedIPAddress();
  return _address;
}","/** 
 * Returns this' address to use for ping replies, query replies, and pushes.
 */
public byte[] getAddress(){
  if (SettingsManager.instance().getForceIPAddress())   return SettingsManager.instance().getForcedIPAddress();
synchronized (Acceptor.class) {
    return _address;
  }
}",0.9283018867924528
5023,"/** 
 * Responds to the QueryRequest by calling FileManager.query()
 */
protected void respondToQueryRequest(QueryRequest queryRequest,Acceptor acceptor,byte[] clientGUID){
  FileManager fm=FileManager.instance();
  Response[] responses=fm.query(queryRequest);
  if ((responses == null) || ((responses.length < 1)))   return;
  byte[] guid=queryRequest.getGUID();
  byte ttl=(byte)(queryRequest.getHops() + 1);
  int port=acceptor.getPort();
  byte[] ip=acceptor.getAddress();
  long speed=SettingsManager.instance().getConnectionSpeed();
  int numResponses=responses.length;
  int index=0;
  int numHops=queryRequest.getHops();
  QueryReply queryReply;
  while (numResponses > 0) {
    int arraySize;
    if (numResponses < 255) {
      arraySize=numResponses;
    }
 else     arraySize=255;
    Response[] res;
    if ((index == 0) && (arraySize < 255)) {
      res=responses;
    }
 else {
      res=new Response[arraySize];
      for (int i=0; i < arraySize; i++) {
        res[i]=responses[index];
        index++;
      }
    }
    numResponses-=arraySize;
    boolean busy=_uploadManager.isBusy();
    boolean incoming=_acceptor.acceptedIncoming();
    queryReply=new QueryReply(guid,ttl,port,ip,speed,res,clientGUID,incoming,busy);
    try {
      sendQueryReply(queryReply);
    }
 catch (    IOException e) {
    }
    if (numHops > 2) {
      break;
    }
  }
}","/** 
 * Responds to the QueryRequest by calling FileManager.query()
 */
protected void respondToQueryRequest(QueryRequest queryRequest,Acceptor acceptor,byte[] clientGUID){
  FileManager fm=FileManager.instance();
  Response[] responses=fm.query(queryRequest);
  if ((responses == null) || ((responses.length < 1)))   return;
  byte[] guid=queryRequest.getGUID();
  byte ttl=(byte)(queryRequest.getHops() + 1);
  int port=acceptor.getPort();
  byte[] ip=acceptor.getAddress();
  long speed=SettingsManager.instance().getConnectionSpeed();
  int numResponses=responses.length;
  int index=0;
  int numHops=queryRequest.getHops();
  QueryReply queryReply;
  while (numResponses > 0) {
    int arraySize;
    if (numResponses < 255) {
      arraySize=numResponses;
    }
 else     arraySize=255;
    Response[] res;
    if ((index == 0) && (arraySize < 255)) {
      res=responses;
    }
 else {
      res=new Response[arraySize];
      for (int i=0; i < arraySize; i++) {
        res[i]=responses[index];
        index++;
      }
    }
    numResponses-=arraySize;
    boolean busy=_uploadManager.isBusy();
    boolean incoming=_acceptor.acceptedIncoming();
    queryReply=new QueryReply(guid,ttl,port,ip,speed,res,clientGUID,!incoming,busy);
    try {
      sendQueryReply(queryReply);
    }
 catch (    IOException e) {
    }
    if (numHops > 2) {
      break;
    }
  }
}",0.9996357012750456
5024,"/** 
 * Increments the count of uploads in progress for host. If uploader has exceeded its limits, places it in LIMIT_REACHED state. Notifies callback of this.
 * @modifies _uploadsInProgress, uploader, _callback 
 */
private void insertAndTest(Uploader uploader,String host){
  insertIntoMap(host);
  if ((!testPerHostLimit(host)) || (!testTotalUploadLimit()))   uploader.setState(Uploader.LIMIT_REACHED);
  _callback.addUpload(uploader);
}","/** 
 * Increments the count of uploads in progress for host. If uploader has exceeded its limits, places it in LIMIT_REACHED state. Notifies callback of this.
 * @modifies _uploadsInProgress, uploader, _callback 
 */
private void insertAndTest(Uploader uploader,String host){
  insertIntoMap(host);
  if (!testPerHostLimit(host))   uploader.setState(Uploader.LIMIT_REACHED);
  if (!testTotalUploadLimit())   uploader.setState(Uploader.LIMIT_REACHED);
  _callback.addUpload(uploader);
}",0.8845738942826321
5025,"private boolean testTotalUploadLimit(){
  int max=SettingsManager.instance().getMaxUploads();
  int current=_uploadsInProgress.size();
  if (current > max)   return false;
  return true;
}","private boolean testTotalUploadLimit(){
  int max=SettingsManager.instance().getMaxUploads();
  int current=uploadsInProgress();
  if (current >= max)   return false;
  return true;
}",0.981132075471698
5026,"/** 
 * This method changes the appropriate state class based on the integer representing the state.  I'm not sure if this is a good idea, since it results in a case statement, that i was trying to avoid with 
 */
public void setState(int state){
  _stateNum=state;
switch (state) {
case CONNECTING:
    _state=new NormalUploadState();
  break;
case LIMIT_REACHED:
_state=new LimitReachedUploadState();
break;
case PUSH_FAILED:
_state=new PushFailedUploadState();
break;
case FREELOADER:
_state=new FreeloaderUploadState();
break;
case FILE_NOT_FOUND:
_state=new FileNotFoundUploadState();
case COMPLETE:
break;
}
}","/** 
 * This method changes the appropriate state class based on the integer representing the state.  I'm not sure if this is a good idea, since it results in a case statement, that i was trying to avoid with 
 */
public void setState(int state){
  _stateNum=state;
switch (state) {
case CONNECTING:
    _state=new NormalUploadState();
  break;
case LIMIT_REACHED:
_state=new LimitReachedUploadState();
break;
case PUSH_FAILED:
_state=new PushFailedUploadState();
break;
case FREELOADER:
_state=new FreeloaderUploadState();
break;
case FILE_NOT_FOUND:
_state=new FileNotFoundUploadState();
case COMPLETE:
case INTERRUPTED:
break;
}
}",0.9855769230769232
5027,"public void run(){
  try {
    _up.connect();
synchronized (UploadManager.this) {
      _activeUploads++;
    }
    _up.start();
  }
 catch (  IOException e) {
    insertFailedPush(_host);
    return;
  }
 finally {
synchronized (UploadManager.this) {
      _activeUploads--;
      removeFromMap(_host);
      removeAttemptedPush(_host);
    }
  }
}","public void run(){
  try {
    _up.connect();
    try {
synchronized (UploadManager.this) {
        _activeUploads++;
      }
      _up.start();
    }
  finally {
synchronized (UploadManager.this) {
        _activeUploads--;
      }
    }
  }
 catch (  IOException e) {
    insertFailedPush(_host);
    return;
  }
 finally {
synchronized (UploadManager.this) {
      removeFromMap(_host);
      removeAttemptedPush(_host);
    }
  }
}",0.8239795918367347
5028,"/** 
 * Breaks the given string (which confirms to the pattern defined above in the class description) into a list (of strings) such that the  first element in the list is the top most structural element,  and the last one the actual field/attribute name
 * @param canonicalizedField The string thats needed to be split
 * @return List (of strings) . The first element in the list is the topmost structural element, and the last one the actual field/attribute name
 */
public static List split(String canonicalizedField){
  List returnList=new LinkedList();
  int lastIndex=0;
  int index=0;
  while ((index=canonicalizedField.indexOf(DELIMITER)) != -1) {
    returnList.add(canonicalizedField.substring(lastIndex,index));
    lastIndex=index;
  }
  if (!canonicalizedField.endsWith(DELIMITER)) {
    returnList.add(canonicalizedField.substring(lastIndex));
  }
  return returnList;
}","/** 
 * Breaks the given string (which confirms to the pattern defined above in the class description) into a list (of strings) such that the  first element in the list is the top most structural element,  and the last one the actual field/attribute name
 * @param canonicalizedField The string thats needed to be split
 * @return List (of strings) . The first element in the list is the topmost structural element, and the last one the actual field/attribute name
 */
public static List split(String canonicalizedField){
  List returnList=new LinkedList();
  int lastIndex=0;
  int index=0;
  while ((index=canonicalizedField.indexOf(DELIMITER,lastIndex)) != -1) {
    returnList.add(canonicalizedField.substring(lastIndex,index));
    lastIndex=index + DELIMITER.length();
  }
  if (!canonicalizedField.endsWith(DELIMITER)) {
    returnList.add(canonicalizedField.substring(lastIndex));
  }
  return returnList;
}",0.9371873262923848
5029,"/** 
 * calculates the appropriate burst size for the allocating bandwith on the upload.
 * @return burstSize.  if it is the special case, in which we want to upload as quickly as possible.
 */
public int calculateBurstSize(){
  int totalBandwith=getTotalBandwith();
  int burstSize=totalBandwith / uploadsInProgress();
  return burstSize;
}","/** 
 * calculates the appropriate burst size for the allocating bandwith on the upload.
 * @return burstSize.  if it is the special case, in which we want to upload as quickly as possible.
 */
public int calculateBurstSize(){
  float totalBandwith=getTotalBandwith();
  float burstSize=totalBandwith / uploadsInProgress();
  return (int)burstSize;
}",0.975397973950796
5030,"/** 
 * @return the total bandwith available for uploads
 */
private int getTotalBandwith(){
  SettingsManager manager=SettingsManager.instance();
  int connectionSpeed=(int)(((float)manager.getConnectionSpeed()) / 8.f);
  int speed=manager.getUploadSpeed();
  int totalBandwith=(int)((connectionSpeed * ((float)speed / 100)));
  return totalBandwith;
}","/** 
 * @return the total bandwith available for uploads
 */
private float getTotalBandwith(){
  SettingsManager manager=SettingsManager.instance();
  float connectionSpeed=((float)manager.getConnectionSpeed()) / 8.f;
  float speed=manager.getUploadSpeed();
  float totalBandwith=((connectionSpeed * ((float)speed / 100)));
  return totalBandwith;
}",0.9373219373219374
5031,"/** 
 * Create a RouterService accepting connections on the specified port
 */
public RouterService(int port,ActivityCallback activityCallback,MessageRouter router){
  callback=activityCallback;
  this.acceptor=new Acceptor(port,callback);
  this.manager=new ConnectionManager(callback);
  this.router=router;
  this.catcher=new HostCatcher(callback);
  downloader=new DownloadManager();
  this.uploadmanager=new UploadManager();
  this.catcher.initialize(acceptor,manager,SettingsManager.instance().getHostList());
  this.router.initialize(acceptor,manager,catcher,uploadmanager);
  this.manager.initialize(router,catcher);
  this.uploadmanager.initialize(activityCallback,router,acceptor);
  this.acceptor.initialize(manager,router,downloader,uploadmanager);
  this.downloader.initialize(callback,router,acceptor,FileManager.instance());
}","/** 
 * Create a RouterService accepting connections on the specified port
 */
public RouterService(int port,ActivityCallback activityCallback,MessageRouter router){
  callback=activityCallback;
  this.acceptor=new Acceptor(port,callback);
  this.manager=new ConnectionManager(callback);
  this.router=router;
  this.catcher=new HostCatcher(callback);
  downloader=new DownloadManager();
  this.uploadManager=new UploadManager();
  this.catcher.initialize(acceptor,manager,SettingsManager.instance().getHostList());
  this.router.initialize(acceptor,manager,catcher,uploadManager);
  this.manager.initialize(router,catcher);
  this.uploadManager.initialize(activityCallback,router,acceptor);
  this.acceptor.initialize(manager,router,downloader,uploadManager);
  this.downloader.initialize(callback,router,acceptor,FileManager.instance());
  SettingsManager settings=SettingsManager.instance();
  int outgoing=settings.getKeepAlive();
  if (outgoing > 0)   connect();
}",0.7226519337016575
5032,"/** 
 * @modifies this
 * @effects removes all connections.
 */
public void disconnect(){
  SettingsManager settings=SettingsManager.instance();
  int oldKeepAlive=settings.getKeepAlive();
  setKeepAlive(0);
  setMaxIncomingConnections(0);
  for (Iterator iter=manager.getConnections().iterator(); iter.hasNext(); ) {
    ManagedConnection c=(ManagedConnection)iter.next();
    removeConnection(c);
  }
}","/** 
 * @modifies this
 * @effects removes all connections.
 * @effects deactivates extra connection watchdog check
 */
public void disconnect(){
  manager.deactivateUltraFastConnectShutdown();
  SettingsManager settings=SettingsManager.instance();
  int oldKeepAlive=settings.getKeepAlive();
  setKeepAlive(0);
  for (Iterator iter=manager.getConnections().iterator(); iter.hasNext(); ) {
    ManagedConnection c=(ManagedConnection)iter.next();
    removeConnection(c);
  }
}",0.8454545454545455
5033,"/** 
 * Connects to router and sends a GroupPingRequest. Block until connected.
 */
private void groupConnect(String group){
  SettingsManager settings=SettingsManager.instance();
  boolean useQuickConnect=settings.getUseQuickConnect();
  settings.setUseQuickConnect(false);
  if (settings.getKeepAlive() < 1)   settings.setKeepAlive(SettingsInterface.DEFAULT_KEEP_ALIVE);
  int oldKeepAlive=settings.getKeepAlive();
  String host=""String_Node_Str"";
  Endpoint e;
  try {
    e=new Endpoint(host);
  }
 catch (  IllegalArgumentException exc) {
    return;
  }
  disconnect();
  catcher.silentClear();
  try {
    groupConnectToHostBlocking(e.getHostname(),e.getPort(),group);
  }
 catch (  IOException exc) {
    settings.setUseQuickConnect(useQuickConnect);
    return;
  }
  int outgoing=settings.getKeepAlive();
  if (outgoing < 1) {
    outgoing=settings.DEFAULT_KEEP_ALIVE;
    settings.setKeepAlive(outgoing);
  }
  int incoming=settings.getMaxIncomingConnections();
  if (incoming < 1 && outgoing != 0) {
    incoming=outgoing / 2;
    settings.setMaxIncomingConnections(incoming);
  }
  setKeepAlive(oldKeepAlive);
  settings.setUseQuickConnect(useQuickConnect);
}","/** 
 * Connects to router and sends a GroupPingRequest. Block until connected.
 */
private void groupConnect(String group){
  SettingsManager settings=SettingsManager.instance();
  boolean useQuickConnect=settings.getUseQuickConnect();
  settings.setUseQuickConnect(false);
  if (settings.getKeepAlive() < 1)   settings.setKeepAlive(SettingsInterface.DEFAULT_KEEP_ALIVE);
  int oldKeepAlive=settings.getKeepAlive();
  String host=""String_Node_Str"";
  Endpoint e;
  try {
    e=new Endpoint(host);
  }
 catch (  IllegalArgumentException exc) {
    return;
  }
  disconnect();
  catcher.silentClear();
  try {
    groupConnectToHostBlocking(e.getHostname(),e.getPort(),group);
  }
 catch (  IOException exc) {
    settings.setUseQuickConnect(useQuickConnect);
    return;
  }
  int outgoing=settings.getKeepAlive();
  if (outgoing < 1) {
    outgoing=settings.DEFAULT_KEEP_ALIVE;
    settings.setKeepAlive(outgoing);
  }
  if (outgoing < 10) {
    outgoing=10;
    manager.activateUltraFastConnectShutdown();
  }
  setKeepAlive(outgoing);
  settings.setUseQuickConnect(useQuickConnect);
}",0.8844621513944223
5034,"/** 
 * Tries to ""smart download"" any of the given files.<p>   If overwrite==false, then if any of the files already exists in the download directory, FileExistsException is thrown and no files are modified.  If overwrite==true, the files may be overwritten.<p> Otherwise returns a Downloader that allows you to stop and resume this download.  The ActivityCallback will also be notified of this download, so the return value can usually be ignored.  The download begins immediately, unless it is queued.  It stops after any of the files succeeds.
 * @modifies this, disk 
 */
public Downloader download(RemoteFileDesc[] files,boolean overwrite) throws Exception {
  return downloader.getFiles(files,overwrite);
}","/** 
 * Tries to ""smart download"" any of the given files.<p>   If overwrite==false, then if any of the files already exists in the download directory, FileExistsException is thrown and no files are modified.  If overwrite==true, the files may be overwritten.<p> Otherwise returns a Downloader that allows you to stop and resume this download.  The ActivityCallback will also be notified of this download, so the return value can usually be ignored.  The download begins immediately, unless it is queued.  It stops after any of the files succeeds.
 * @modifies this, disk 
 */
public Downloader download(RemoteFileDesc[] files,boolean overwrite) throws FileExistsException, AlreadyDownloadingException {
  return downloader.getFiles(files,overwrite);
}",0.9733424470266576
5035,"/** 
 * @modifies this
 * @effects ensures the keep-alive is non-zero and recontacts thepong server as needed.
 */
public void connect(){
  boolean useHack=(!SettingsManager.instance().getUseQuickConnect()) && catcher.getNumHosts() == 0;
  if (useHack) {
    SettingsManager.instance().setUseQuickConnect(true);
    disconnect();
  }
  catcher.expire();
  SettingsManager settings=SettingsManager.instance();
  int outgoing=settings.getKeepAlive();
  if (outgoing < 1) {
    outgoing=settings.DEFAULT_KEEP_ALIVE;
    settings.setKeepAlive(outgoing);
  }
  setKeepAlive(outgoing);
  int incoming=settings.getMaxIncomingConnections();
  setMaxIncomingConnections(incoming);
  if (useHack) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
    SettingsManager.instance().setUseQuickConnect(false);
  }
}","/** 
 * @modifies this
 * @effects ensures the keep-alive is non-zero and recontacts thepong server as needed.
 */
public void connect(){
  SettingsManager settings=SettingsManager.instance();
  boolean useHack=(!settings.getUseQuickConnect()) && catcher.getNumHosts() == 0;
  if (useHack) {
    settings.setUseQuickConnect(true);
    disconnect();
  }
  catcher.expire();
  int outgoing=settings.getKeepAlive();
  if (outgoing < 1) {
    outgoing=settings.DEFAULT_KEEP_ALIVE;
    settings.setKeepAlive(outgoing);
  }
  if (outgoing < 10) {
    outgoing=10;
    manager.activateUltraFastConnectShutdown();
  }
  setKeepAlive(outgoing);
  if (useHack) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
    SettingsManager.instance().setUseQuickConnect(false);
  }
}",0.778998778998779
5036,"/** 
 * Searches the given host for all its files.  Results are given to the GUI via handleQuery.  Returns null if the host couldn't be reached.  Blocks until the connection is established and the query is sent.
 */
public byte[] browse(String host,int port){
  ManagedConnection c=null;
  for (Iterator iter=manager.getInitializedConnections().iterator(); iter.hasNext(); ) {
    ManagedConnection c2=(ManagedConnection)iter.next();
    String ip=c2.getInetAddress().getHostAddress();
    if (ip.equals(host) && c2.getOrigPort() == port) {
      c=c2;
      break;
    }
  }
  if (c == null) {
    try {
      c=connectToHostBlocking(host,port);
    }
 catch (    IOException e) {
      return null;
    }
  }
  QueryRequest qr=new QueryRequest((byte)1,0,""String_Node_Str"");
  router.sendQueryRequest(qr,c);
  try {
    c.flush();
  }
 catch (  IOException e) {
    return null;
  }
  if (manager.getNumConnections() > manager.getKeepAlive()) {
    ManagedConnection worst=null;
    long files=Long.MAX_VALUE;
    for (Iterator iter=manager.getConnections().iterator(); iter.hasNext(); ) {
      ManagedConnection c2=(ManagedConnection)iter.next();
      if (c2 == c)       continue;
      long n=c2.getNumFiles();
      if (n < files) {
        worst=c2;
        files=n;
      }
    }
    if (worst != null)     manager.remove(worst);
  }
  return qr.getGUID();
}","/** 
 * Searches the given host for all its files.  Results are given to the GUI via handleQuery.  Returns null if the host couldn't be reached.  Blocks until the connection is established and the query is sent.
 */
public byte[] browse(String host,int port){
  ManagedConnection c=null;
  for (Iterator iter=manager.getInitializedConnections().iterator(); iter.hasNext(); ) {
    ManagedConnection c2=(ManagedConnection)iter.next();
    String ip=c2.getInetAddress().getHostAddress();
    if (ip.equals(host) && c2.getOrigPort() == port) {
      c=c2;
      break;
    }
  }
  if (c == null) {
    try {
      c=connectToHostBlocking(host,port);
    }
 catch (    IOException e) {
      return null;
    }
  }
  QueryRequest qr=new QueryRequest((byte)1,0,FileManager.BROWSE_QUERY);
  router.sendQueryRequest(qr,c);
  try {
    c.flush();
  }
 catch (  IOException e) {
    return null;
  }
  if (manager.getNumConnections() > manager.getKeepAlive()) {
    ManagedConnection worst=null;
    long files=Long.MAX_VALUE;
    for (Iterator iter=manager.getConnections().iterator(); iter.hasNext(); ) {
      ManagedConnection c2=(ManagedConnection)iter.next();
      if (c2 == c)       continue;
      long n=c2.getNumFiles();
      if (n < files) {
        worst=c2;
        files=n;
      }
    }
    if (worst != null)     manager.remove(worst);
  }
  return qr.getGUID();
}",0.98649142022636
5037,"/** 
 * Create an incoming connection.  This method starts the message loop, so it will block for a long time.  Make sure the thread that calls this method is suitable doing a connection message loop. If there are already too many connections in the manager, this method will launch a RejectConnection to send pongs for other hosts.
 */
void acceptConnection(Socket socket){
  if (getNumInConnections() < _maxIncomingConnections) {
    ManagedConnection connection=new ManagedConnection(socket,_router,this);
    try {
      initializeExternallyGeneratedConnection(connection);
      _router.sendPingRequest(new PingRequest(SettingsManager.instance().getTTL()),connection);
      connection.loopForMessages();
    }
 catch (    IOException e) {
    }
catch (    Exception e) {
      _callback.error(ActivityCallback.ERROR_20,e);
    }
  }
 else {
    if (_isWindows) {
      new RejectConnection(socket,_catcher);
    }
 else {
      try {
        socket.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
}","/** 
 * Create an incoming connection.  This method starts the message loop, so it will block for a long time.  Make sure the thread that calls this method is suitable doing a connection message loop. If there are already too many connections in the manager, this method will launch a RejectConnection to send pongs for other hosts.
 */
void acceptConnection(Socket socket){
  boolean allowConnection=false;
synchronized (_incomingConnectionsLock) {
    if (_incomingConnections < _keepAlive) {
      _incomingConnections++;
      allowConnection=true;
    }
  }
  if (allowConnection) {
    ManagedConnection connection=new ManagedConnection(socket,_router,this);
    try {
      initializeExternallyGeneratedConnection(connection);
      _router.sendPingRequest(new PingRequest(_settings.getTTL()),connection);
      connection.loopForMessages();
    }
 catch (    IOException e) {
    }
catch (    Exception e) {
      _callback.error(ActivityCallback.ERROR_20,e);
    }
 finally {
synchronized (_incomingConnectionsLock) {
        _incomingConnections--;
      }
    }
  }
 else {
    if (Utilities.isWindows()) {
      new RejectConnection(socket,_catcher);
    }
 else {
      try {
        socket.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
}",0.8123639529821506
5038,"public void run(){
  Endpoint endpoint=null;
  do {
    try {
      endpoint=_catcher.getAnEndpoint();
    }
 catch (    InterruptedException exc2) {
      return;
    }
  }
 while (isConnected(endpoint));
  Assert.that(endpoint != null);
  ManagedConnection connection=new ManagedConnection(endpoint.hostname,endpoint.port,_router,ConnectionManager.this);
  try {
    initializeFetchedConnection(connection,this);
    _router.sendPingRequest(new PingRequest(SettingsManager.instance().getTTL()),connection);
    connection.loopForMessages();
  }
 catch (  IOException e) {
  }
catch (  Exception e) {
    _callback.error(ActivityCallback.ERROR_20,e);
  }
}","public void run(){
  Endpoint endpoint=null;
  do {
    try {
      endpoint=_catcher.getAnEndpoint();
    }
 catch (    InterruptedException exc2) {
      return;
    }
  }
 while (isConnected(endpoint));
  Assert.that(endpoint != null);
  ManagedConnection connection=new ManagedConnection(endpoint.hostname,endpoint.port,_router,ConnectionManager.this);
  try {
    initializeFetchedConnection(connection,this);
    _router.sendPingRequest(new PingRequest(_settings.getTTL()),connection);
    connection.loopForMessages();
  }
 catch (  IOException e) {
  }
catch (  Exception e) {
    _callback.error(ActivityCallback.ERROR_20,e);
  }
}",0.9730146491904396
5039,"/** 
 * Constructs a ConnectionManager.  Must call initialize before using.
 */
public ConnectionManager(ActivityCallback callback){
  _callback=callback;
  String os=System.getProperty(""String_Node_Str"");
  if (os.startsWith(""String_Node_Str""))   _isWindows=true;
}","/** 
 * Constructs a ConnectionManager.  Must call initialize before using.
 */
public ConnectionManager(ActivityCallback callback){
  _callback=callback;
  _settings=SettingsManager.instance();
}",0.7619047619047619
5040,"/** 
 * Marks a connection fully initialized, but only if that connection wasn't removed from the list of open connections during its initialization. Should only be called from a thread that has this' monitor.
 */
private void connectionInitialized(Connection c){
  if (_connections.contains(c)) {
    List newConnections=new ArrayList(_initializedConnections);
    newConnections.add(c);
    _initializedConnections=newConnections;
    Set newEndpoints=new HashSet(_endpoints);
    newEndpoints.add(new Endpoint(c.getInetAddress().getHostAddress(),c.getPort()));
    _endpoints=newEndpoints;
  }
}","/** 
 * Marks a connection fully initialized, but only if that connection wasn't removed from the list of open connections during its initialization. Should only be called from a thread that has this' monitor.
 */
private void connectionInitialized(Connection c){
  if (_connections.contains(c)) {
    List newConnections=new ArrayList(_initializedConnections);
    newConnections.add(c);
    _initializedConnections=newConnections;
    Set newEndpoints=new HashSet(_endpoints);
    newEndpoints.add(new Endpoint(c.getInetAddress().getHostAddress(),c.getPort()));
    _endpoints=newEndpoints;
  }
  if (_ultraFastCheck != null)   _ultraFastCheck.run();
}",0.9552715654952076
5041,"/** 
 * Links the ConnectionManager up with the other back end pieces and launches the ConnectionWatchdog and the initial ConnectionFetchers.
 */
public void initialize(MessageRouter router,HostCatcher catcher){
  _router=router;
  _catcher=catcher;
  Thread watchdog=new Thread(new ConnectionWatchdog(this,_router));
  watchdog.setDaemon(true);
  watchdog.start();
  setKeepAlive(SettingsManager.instance().getKeepAlive());
  setMaxIncomingConnections(SettingsManager.instance().getMaxIncomingConnections());
}","/** 
 * Links the ConnectionManager up with the other back end pieces and launches the ConnectionWatchdog and the initial ConnectionFetchers.
 */
public void initialize(MessageRouter router,HostCatcher catcher){
  _router=router;
  _catcher=catcher;
  _watchdog=new ConnectionWatchdog(this,_router);
  Thread watchdog=new Thread(_watchdog);
  watchdog.setDaemon(true);
  watchdog.start();
  setKeepAlive(_settings.getKeepAlive());
}",0.7720042417815483
5042,"/** 
 * The default handler for QueryRequests received in ManagedConnection.loopForMessages().  This implementation updates stats, does the broadcast, and generates a response. You can customize behavior in three ways: 1. Override. You can assume that duplicate messages (messages with the same GUID that arrived via different paths) have already been filtered.  If you want stats updated, you'll have to call super.handleQueryRequest. 2. Override broadcastQueryRequest.  This allows you to use the default handling framework and just customize request routing. 3. Implement respondToQueryRequest.  This allows you to use the default handling framework and just customize responses.
 */
public void handleQueryRequest(QueryRequest queryRequest,ManagedConnection receivingConnection){
  _numQueryRequests++;
  if ((receivingConnection.getNumMessagesReceived() <= 2) && (queryRequest.getHops() <= 1) && (queryRequest.getQuery().equals(""String_Node_Str""))) {
    receivingConnection.setKillable(false);
  }
  if (queryRequest.getTTL() > 0)   broadcastQueryRequest(queryRequest,receivingConnection,_manager);
  respondToQueryRequest(queryRequest,_acceptor,_clientGUID);
}","/** 
 * The default handler for QueryRequests received in ManagedConnection.loopForMessages().  This implementation updates stats, does the broadcast, and generates a response. You can customize behavior in three ways: 1. Override. You can assume that duplicate messages (messages with the same GUID that arrived via different paths) have already been filtered.  If you want stats updated, you'll have to call super.handleQueryRequest. 2. Override broadcastQueryRequest.  This allows you to use the default handling framework and just customize request routing. 3. Implement respondToQueryRequest.  This allows you to use the default handling framework and just customize responses.
 */
public void handleQueryRequest(QueryRequest queryRequest,ManagedConnection receivingConnection){
  _numQueryRequests++;
  if ((receivingConnection.getNumMessagesReceived() <= 2) && (queryRequest.getHops() <= 1) && (queryRequest.getQuery().equals(FileManager.INDEXING_QUERY))) {
    receivingConnection.setKillable(false);
  }
  if (queryRequest.getTTL() > 0)   broadcastQueryRequest(queryRequest,receivingConnection,_manager);
  respondToQueryRequest(queryRequest,_acceptor,_clientGUID);
}",0.9825010670081092
5043,"/** 
 * Removes and returns the RemoteFileDesc with the smallest estimated remaining download time in filesLeft.  
 * @requires !filesLeft.isEmpty()
 * @modifies filesLeft
 */
public RemoteFileDesc removeBest(List filesLeft){
  RemoteFileDesc ret=null;
  long lowestTime=Integer.MAX_VALUE;
  for (Iterator iter=filesLeft.iterator(); iter.hasNext(); ) {
    RemoteFileDesc rfd=(RemoteFileDesc)iter.next();
    File incompleteFile=incompleteFileManager.getFile(rfd);
    long amountLeft=rfd.getSize() - incompleteFile.length();
    long speed=rfd.getSpeed() / 8;
    long estimatedTime=amountLeft / speed;
    if (estimatedTime < lowestTime) {
      lowestTime=estimatedTime;
      ret=rfd;
    }
  }
  Assert.that(ret != null,""String_Node_Str"");
  filesLeft.remove(ret);
  return ret;
}","/** 
 * Removes and returns the RemoteFileDesc with the smallest estimated remaining download time in filesLeft.  
 * @requires !filesLeft.isEmpty()
 * @modifies filesLeft
 */
public RemoteFileDesc removeBest(List filesLeft){
  RemoteFileDesc ret=null;
  long lowestTime=Integer.MAX_VALUE;
  for (Iterator iter=filesLeft.iterator(); iter.hasNext(); ) {
    RemoteFileDesc rfd=(RemoteFileDesc)iter.next();
    File incompleteFile=incompleteFileManager.getFile(rfd);
    long amountLeft=rfd.getSize() - incompleteFile.length();
    long speed=rfd.getSpeed() / 8;
    long estimatedTime=999999999;
    if (speed != 0)     estimatedTime=amountLeft / speed;
    if (estimatedTime < lowestTime) {
      lowestTime=estimatedTime;
      ret=rfd;
    }
  }
  Assert.that(ret != null,""String_Node_Str"");
  filesLeft.remove(ret);
  return ret;
}",0.9697344039530574
5044,"/** 
 * Create an incoming connection.  This method starts the message loop, so it will block for a long time.  Make sure the thread that calls this method is suitable doing a connection message loop. If there are already too many connections in the manager, this method will launch a RejectConnection to send pongs for other hosts.
 */
void acceptConnection(Socket socket){
  if (getNumInConnections() < getNumConnections()) {
    ManagedConnection connection=new ManagedConnection(socket,_router,this);
    try {
      initializeExternallyGeneratedConnection(connection);
      _router.sendPingRequest(new PingRequest(_settings.getTTL()),connection);
      connection.loopForMessages();
    }
 catch (    IOException e) {
    }
catch (    Exception e) {
      _callback.error(ActivityCallback.ERROR_20,e);
    }
  }
 else {
    if (Utilities.isWindows()) {
      new RejectConnection(socket,_catcher);
    }
 else {
      try {
        socket.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
}","/** 
 * Create an incoming connection.  This method starts the message loop, so it will block for a long time.  Make sure the thread that calls this method is suitable doing a connection message loop. If there are already too many connections in the manager, this method will launch a RejectConnection to send pongs for other hosts.
 */
void acceptConnection(Socket socket){
  boolean allowConnection=false;
synchronized (_incomingConnectionsLock) {
    if (_incomingConnections < _keepAlive) {
      _incomingConnections++;
      allowConnection=true;
    }
  }
  if (allowConnection) {
    ManagedConnection connection=new ManagedConnection(socket,_router,this);
    try {
      initializeExternallyGeneratedConnection(connection);
      _router.sendPingRequest(new PingRequest(_settings.getTTL()),connection);
      connection.loopForMessages();
    }
 catch (    IOException e) {
    }
catch (    Exception e) {
      _callback.error(ActivityCallback.ERROR_20,e);
    }
 finally {
synchronized (_incomingConnectionsLock) {
        _incomingConnections--;
      }
    }
  }
 else {
    if (Utilities.isWindows()) {
      new RejectConnection(socket,_catcher);
    }
 else {
      try {
        socket.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
}",0.8473983384346305
5045,"/** 
 * Loads the extensions and directories settings and rebuilds the file index.
 * @modifies this
 * @effects ensures that this contains exactly the files recursively givendirectories and all their recursive subdirectories.  If dir_names contains duplicate directories, the duplicates will be ignored.  If the directories list contains files, they will be ignored. Note that some files in this before the call will not be in this after the call, or they may have a different index. <b>WARNING: this is a potential security hazard.</b> WARNING: This call could run for a long time. Only threads that are prepared for that possibility should invoke it.  See the FileManager constructor for an example.
 */
public synchronized void loadSettings(){
  _size=0;
  _numFiles=0;
  _files=new ArrayList();
  _sharedDirectories=new HashSet();
  String dir_names=SettingsManager.instance().getDirectories();
  dir_names.trim();
  String[] names=HTTPUtil.stringSplit(dir_names,';');
  _extensions=HTTPUtil.stringSplit(SettingsManager.instance().getExtensions(),';');
  int size=names.length;
  File f;
  String p;
  String name;
  for (int i=0; i < size; i++) {
    name=names[i];
    f=new File(name);
    if (!f.isDirectory())     continue;
    try {
      p=f.getCanonicalPath();
    }
 catch (    Exception e) {
      continue;
    }
    _sharedDirectories.add(p);
  }
  int hashsize=_sharedDirectories.size();
  String[] dirs=new String[hashsize];
  int j=0;
  for (Iterator iter=_sharedDirectories.iterator(); iter.hasNext(); ) {
    dirs[j++]=(String)iter.next();
  }
  for (int i=0; i < hashsize; i++) {
    addDirectory(dirs[i]);
  }
}","/** 
 * Loads the extensions and directories settings and rebuilds the file index.
 * @modifies this
 * @effects ensures that this contains exactly the files recursively givendirectories and all their recursive subdirectories.  If dir_names contains duplicate directories, the duplicates will be ignored.  If the directories list contains files, they will be ignored. Note that some files in this before the call will not be in this after the call, or they may have a different index. <b>WARNING: this is a potential security hazard.</b> WARNING: This call could run for a long time. Only threads that are prepared for that possibility should invoke it.  See the FileManager constructor for an example.
 */
public synchronized void loadSettings(){
  _size=0;
  _numFiles=0;
  _files=new ArrayList();
  _index=new Trie(true);
  _sharedDirectories=new HashSet();
  String dir_names=SettingsManager.instance().getDirectories();
  dir_names.trim();
  String[] names=HTTPUtil.stringSplit(dir_names,';');
  _extensions=HTTPUtil.stringSplit(SettingsManager.instance().getExtensions(),';');
  int size=names.length;
  File f;
  String p;
  String name;
  for (int i=0; i < size; i++) {
    name=names[i];
    f=new File(name);
    if (!f.isDirectory())     continue;
    try {
      p=f.getCanonicalPath();
    }
 catch (    Exception e) {
      continue;
    }
    _sharedDirectories.add(p);
  }
  int hashsize=_sharedDirectories.size();
  String[] dirs=new String[hashsize];
  int j=0;
  for (Iterator iter=_sharedDirectories.iterator(); iter.hasNext(); ) {
    dirs[j++]=(String)iter.next();
  }
  for (int i=0; i < hashsize; i++) {
    addDirectory(dirs[i]);
  }
}",0.992412746585736
5046,"private VersionUpdate(){
  _settings=SettingsManager.instance();
  _latest=_settings.getLastVersionChecked();
  _timedOut=false;
}","private VersionUpdate(){
  _settings=SettingsManager.instance();
  _latest=_settings.getLastVersionChecked();
}",0.921161825726141
5047,"/** 
 * this method attempts to perform an update --  getting the new jar file from the server, replacing it, and making the call to change the launch anywhere ""LAX"" file. 
 */
public void update() throws CantConnectException {
  StringBuffer newFileBuf=new StringBuffer(""String_Node_Str"");
  StringTokenizer fileTok=new StringTokenizer(_newVersion,""String_Node_Str"");
  newFileBuf.append(fileTok.nextToken());
  newFileBuf.append(fileTok.nextToken());
  newFileBuf.append(""String_Node_Str"");
  String newFileName=newFileBuf.toString();
  String fullPath=_currentDirectory + newFileName;
  File jarFile=new File(fullPath);
  if (jarFile.exists()) {
    jarFile.delete();
  }
  try {
    String pathName=""String_Node_Str"" + newFileName;
    URL url=new URL(""String_Node_Str"",""String_Node_Str"",pathName);
    URLConnection conn=url.openConnection();
    conn.connect();
    _updateSize=conn.getContentLength();
    if (_updateSize == -1) {
      cancelUpdate(""String_Node_Str"");
    }
 else {
      _updateHandler.showProgressWindow(_updateSize);
      InputStream is=conn.getInputStream();
      ByteReader byteReader=new ByteReader(is);
      FileOutputStream fos=new FileOutputStream(fullPath,true);
      int percentRead=0;
      _amountRead=0;
      int newBytes=-1;
      byte[] buf=new byte[1024];
      while (true) {
        _updateHandler.update(_amountRead);
        if (_amountRead == _updateSize)         break;
        if (_amountRead > _updateSize) {
          break;
        }
        newBytes=byteReader.read(buf);
        if (newBytes == -1)         break;
        fos.write(buf,0,newBytes);
        _amountRead+=newBytes;
      }
      byteReader.close();
      fos.close();
      if (_amountRead == _updateSize) {
        _updateHandler.hideProgressWindow();
        if (updateLAXFile(newFileName)) {
          String message=""String_Node_Str"" + ""String_Node_Str"";
          Utilities.showMessage(message);
          _settings.setLastVersionChecked(_newVersion);
        }
        _settings.writeProperties();
        System.exit(0);
      }
    }
  }
 catch (  MalformedURLException mue) {
  }
catch (  IOException ioe) {
  }
}","/** 
 * Attempts to perform an update -- getting the new jar file from the server, replacing it, and making the call to change the launch anywhere ""LAX"" file.  If the update is succesful, terminates the JVM.  Throws CantConnectException if the update failed.  Note that this method should never return without an exception.  
 */
private void update() throws CantConnectException {
  StringBuffer newFileBuf=new StringBuffer(""String_Node_Str"");
  StringTokenizer fileTok=new StringTokenizer(_newVersion,""String_Node_Str"");
  newFileBuf.append(fileTok.nextToken());
  newFileBuf.append(fileTok.nextToken());
  newFileBuf.append(""String_Node_Str"");
  String newFileName=newFileBuf.toString();
  String fullPath=_currentDirectory + newFileName;
  File jarFile=new File(fullPath);
  if (jarFile.exists()) {
    jarFile.delete();
  }
  try {
    String pathName=""String_Node_Str"" + newFileName;
    URL url=new URL(""String_Node_Str"",""String_Node_Str"",pathName);
    URLConnection conn=(new URLOpener(url)).connect(CONNECT_TIMEOUT);
    _updateSize=conn.getContentLength();
    if (_updateSize == -1) {
      cancelUpdate(""String_Node_Str"");
    }
 else {
      _updateHandler.showProgressWindow(_updateSize);
      InputStream is=conn.getInputStream();
      ByteReader byteReader=new ByteReader(is);
      FileOutputStream fos=new FileOutputStream(fullPath,true);
      int percentRead=0;
      _amountRead=0;
      int newBytes=-1;
      byte[] buf=new byte[1024];
      while (true) {
        _updateHandler.update(_amountRead);
        if (_amountRead == _updateSize)         break;
        if (_amountRead > _updateSize) {
          break;
        }
        newBytes=byteReader.read(buf);
        if (newBytes == -1)         break;
        fos.write(buf,0,newBytes);
        _amountRead+=newBytes;
      }
      byteReader.close();
      fos.close();
      if (_amountRead == _updateSize) {
        _updateHandler.hideProgressWindow();
        if (updateLAXFile(newFileName)) {
          String message=""String_Node_Str"" + ""String_Node_Str"";
          Utilities.showMessage(message);
          _settings.setLastVersionChecked(_newVersion);
        }
        _settings.writeProperties();
        System.exit(0);
      }
    }
  }
 catch (  IOException ioe) {
    throw new CantConnectException();
  }
}",0.9206206431302
5048,"/** 
 * Tries to ""smart download"" any of the given files.<p>   If overwrite==false, then if any of the files already exists in the download directory, FileExistsException is thrown and no files are modified.  If overwrite==true, the files may be overwritten.<p> Otherwise returns a Downloader that allows you to stop and resume this download.  The ActivityCallback will also be notified of this download, so the return value can usually be ignored.  The download begins immediately, unless it is queued.  It stops after any of the files succeeds.
 * @modifies this, disk 
 */
public synchronized Downloader getFiles(RemoteFileDesc[] files,boolean overwrite) throws FileExistsException {
  if (!overwrite) {
    String downloadDir=SettingsManager.instance().getSaveDirectory();
    for (int i=0; i < files.length; i++) {
      String filename=files[i].getFileName();
      File completeFile=new File(downloadDir,filename);
      if (completeFile.exists())       throw new FileExistsException(filename);
    }
  }
  ManagedDownloader downloader=new ManagedDownloader(this,files);
  waiting.add(downloader);
  callback.addDownload(downloader);
  return downloader;
}","/** 
 * Tries to ""smart download"" any of the given files.<p>   If any of the files already being downloaded (or queued for downloaded) has the same temporary name as any of the files in 'files', throws AlreadyDownloadingException.  Note, however, that this doesn't guarantee that a successfully downloaded file can be moved to the library.<p> If overwrite==false, then if any of the files already exists in the download directory, FileExistsException is thrown and no files are modified.  If overwrite==true, the files may be overwritten.<p> Otherwise returns a Downloader that allows you to stop and resume this download.  The ActivityCallback will also be notified of this download, so the return value can usually be ignored.  The download begins immediately, unless it is queued.  It stops after any of the files succeeds.
 * @modifies this, disk 
 */
public synchronized Downloader getFiles(RemoteFileDesc[] files,boolean overwrite) throws FileExistsException, AlreadyDownloadingException {
  for (int i=0; i < files.length; i++) {
    for (Iterator iter=active.iterator(); iter.hasNext(); ) {
      ManagedDownloader md=(ManagedDownloader)iter.next();
      if (md.conflicts(files[i]))       throw new AlreadyDownloadingException(files[i].getFileName());
    }
    for (Iterator iter=waiting.iterator(); iter.hasNext(); ) {
      ManagedDownloader md=(ManagedDownloader)iter.next();
      if (md.conflicts(files[i]))       throw new AlreadyDownloadingException(files[i].getFileName());
    }
  }
  if (!overwrite) {
    String downloadDir=SettingsManager.instance().getSaveDirectory();
    for (int i=0; i < files.length; i++) {
      String filename=files[i].getFileName();
      File completeFile=new File(downloadDir,filename);
      if (completeFile.exists())       throw new FileExistsException(filename);
    }
  }
  ManagedDownloader downloader=new ManagedDownloader(this,files);
  waiting.add(downloader);
  callback.addDownload(downloader);
  return downloader;
}",0.4654568608723337
5049,"/** 
 * Removes downloader entirely from the list of current downloads. Notifies callback of the change in status.
 * @requires downloader active or queued
 * @modifies this, callback
 */
public synchronized void remove(ManagedDownloader downloader,boolean success){
  boolean activated=active.remove(downloader);
  if (!activated)   waiting.remove(downloader);
 else   notify();
  callback.removeDownload(downloader);
}","/** 
 * Removes downloader entirely from the list of current downloads. Notifies callback of the change in status.
 * @modifies this, callback
 */
public synchronized void remove(ManagedDownloader downloader,boolean success){
  active.remove(downloader);
  waiting.remove(downloader);
  notify();
  callback.removeDownload(downloader);
}",0.8903566710700133
5050,"/** 
 * @param timeout the amount of time, in milliseconds, to waitwhen establishing a connection.   Must be non-negative.  A timeout of 0 means no timeout.
 * @exception CantConnectException couldn't connect to the host.
 */
public HTTPDownloader(String file,String host,int port,int index,byte[] guid,int size,boolean resume,int timeout) throws IOException {
  _filename=file;
  _index=index;
  _guid=guid;
  _amountRead=0;
  _fileSize=size;
  _initialReadingPoint=0;
  if (resume) {
    SettingsManager sm=SettingsManager.instance();
    String incompleteDir;
    incompleteDir=sm.getIncompleteDirectory();
    if (incompleteDir == ""String_Node_Str"")     throw new NullIncompleteDirectoryException();
    File incompleteFile=new File(incompleteDir,_filename);
    if (incompleteFile.exists()) {
      _initialReadingPoint=(int)incompleteFile.length();
      _amountRead=_initialReadingPoint;
    }
  }
  connect(host,port,file,index,timeout);
}","/** 
 * @param timeout the amount of time, in milliseconds, to waitwhen establishing a connection.   Must be non-negative.  A timeout of 0 means no timeout.
 * @exception CantConnectException couldn't connect to the host.
 */
public HTTPDownloader(String file,String host,int port,int index,byte[] guid,int size,boolean resume,int timeout) throws IOException {
  _filename=file;
  _index=index;
  _guid=guid;
  _amountRead=0;
  _fileSize=size;
  _initialReadingPoint=0;
  if (resume) {
    File incompleteFile=new TemporaryFile(_filename,guid);
    if (incompleteFile.exists()) {
      _initialReadingPoint=(int)incompleteFile.length();
      _amountRead=_initialReadingPoint;
    }
  }
  connect(host,port,file,index,timeout);
}",0.8102625298329356
5051,"private void doDownload() throws IOException {
  SettingsManager settings=SettingsManager.instance();
  String download_dir=settings.getSaveDirectory();
  String incomplete_dir=settings.getIncompleteDirectory();
  File incomplete_file=new File(incomplete_dir,_filename);
  String path_to_incomplete=incomplete_file.getAbsolutePath();
  File complete_file=new File(download_dir,_filename);
  String path_to_complete=complete_file.getAbsolutePath();
  File shared=new File(download_dir);
  String shared_path=shared.getCanonicalPath();
  File parent_of_shared=new File(complete_file.getParent());
  String path_to_parent=parent_of_shared.getCanonicalPath();
  if (!path_to_parent.equals(shared_path)) {
    throw new InvalidPathException();
  }
  if (complete_file.exists()) {
    try {
      complete_file.delete();
    }
 catch (    SecurityException e) {
      throw new IOException(""String_Node_Str"");
    }
  }
  boolean append=false;
  if (_initialReadingPoint > 0)   append=true;
  _fos=new FileOutputStream(path_to_incomplete,append);
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    if (_amountRead == _fileSize)     break;
    if (_amountRead > _fileSize)     throw new FileTooLargeException();
    c=_byteReader.read(buf);
    if (c == -1)     break;
    _fos.write(buf,0,c);
    _amountRead+=c;
  }
  _byteReader.close();
  _fos.close();
  if (_amountRead == _fileSize) {
    complete_file.delete();
    boolean ok=incomplete_file.renameTo(complete_file);
    if (!ok)     throw new FileCantBeMovedException();
    FileManager.instance().addFileIfShared(path_to_complete);
  }
 else   throw new FileIncompleteException();
}","private void doDownload() throws IOException {
  SettingsManager settings=SettingsManager.instance();
  String download_dir=settings.getSaveDirectory();
  File complete_file=new File(download_dir,_filename);
  String path_to_complete=complete_file.getAbsolutePath();
  File shared=new File(download_dir);
  String shared_path=shared.getCanonicalPath();
  File parent_of_shared=new File(complete_file.getParent());
  String path_to_parent=parent_of_shared.getCanonicalPath();
  if (!path_to_parent.equals(shared_path)) {
    throw new InvalidPathException();
  }
  File incomplete_file=new TemporaryFile(_filename,_guid);
  String path_to_incomplete=incomplete_file.getAbsolutePath();
  boolean append=false;
  if (_initialReadingPoint > 0)   append=true;
  _fos=new FileOutputStream(path_to_incomplete,append);
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    if (_amountRead == _fileSize)     break;
    if (_amountRead > _fileSize)     throw new FileTooLargeException();
    c=_byteReader.read(buf);
    if (c == -1)     break;
    _fos.write(buf,0,c);
    _amountRead+=c;
  }
  _byteReader.close();
  _fos.close();
  if (_amountRead == _fileSize) {
    complete_file.delete();
    boolean ok=incomplete_file.renameTo(complete_file);
    if (!ok)     throw new FileCantBeMovedException();
    FileManager.instance().addFileIfShared(path_to_complete);
  }
 else   throw new FileIncompleteException();
}",0.6603527106466361
5052,"/** 
 * Tries to ""smart download"" any of the given files.<p>   If overwrite==false, then if any of the files already exists in the download directory, FileExistsException is thrown and no files are modified.  If overwrite==true, the files may be overwritten.<p> Otherwise returns a Downloader that allows you to stop and resume this download.  The ActivityCallback will also be notified of this download, so the return value can usually be ignored.  The download begins immediately, unless it is queued.  It stops after any of the files succeeds.
 * @modifies this, disk 
 */
public Downloader download(RemoteFileDesc[] files,boolean overwrite) throws com.limegroup.gnutella.downloader.FileExistsException {
  return downloader.getFiles(files,overwrite);
}","/** 
 * Tries to ""smart download"" any of the given files.<p>   If overwrite==false, then if any of the files already exists in the download directory, FileExistsException is thrown and no files are modified.  If overwrite==true, the files may be overwritten.<p> Otherwise returns a Downloader that allows you to stop and resume this download.  The ActivityCallback will also be notified of this download, so the return value can usually be ignored.  The download begins immediately, unless it is queued.  It stops after any of the files succeeds.
 * @modifies this, disk 
 */
public Downloader download(RemoteFileDesc[] files,boolean overwrite) throws FileExistsException, AlreadyDownloadingException {
  return downloader.getFiles(files,overwrite);
}",0.9581950895819508
5053,"/** 
 * @param timeout the amount of time, in milliseconds, to waitwhen establishing a connection.   Must be non-negative.  A timeout of 0 means no timeout.
 * @exception CantConnectException couldn't connect to the host.
 */
public HTTPDownloader(String file,String host,int port,int index,byte[] guid,int size,boolean resume,int timeout) throws IOException {
  _filename=file;
  _index=index;
  _guid=guid;
  _amountRead=0;
  _fileSize=size;
  _initialReadingPoint=0;
  if (resume) {
    SettingsManager sm=SettingsManager.instance();
    String incompleteDir;
    incompleteDir=sm.getIncompleteDirectory();
    if (incompleteDir == ""String_Node_Str"")     throw new NullIncompleteDirectoryException();
    File incompleteFile=new File(incompleteDir,_filename);
    if (incompleteFile.exists()) {
      _initialReadingPoint=(int)incompleteFile.length();
      _amountRead=_initialReadingPoint;
    }
  }
  connect(host,port,file,index,timeout);
}","/** 
 * @param timeout the amount of time, in milliseconds, to waitwhen establishing a connection.   Must be non-negative.  A timeout of 0 means no timeout.
 * @exception CantConnectException couldn't connect to the host.
 */
public HTTPDownloader(String file,String host,int port,int index,byte[] guid,int size,boolean resume,int timeout) throws IOException {
  _filename=file;
  _index=index;
  _guid=guid;
  _amountRead=0;
  _fileSize=size;
  _initialReadingPoint=0;
  if (resume) {
    File incompleteFile=new TemporaryFile(_filename,guid);
    if (incompleteFile.exists()) {
      _initialReadingPoint=(int)incompleteFile.length();
      _amountRead=_initialReadingPoint;
    }
  }
  connect(host,port,file,index,timeout);
}",0.8102625298329356
5054,"private void doDownload() throws IOException {
  SettingsManager settings=SettingsManager.instance();
  String download_dir=settings.getSaveDirectory();
  String incomplete_dir=settings.getIncompleteDirectory();
  File incomplete_file=new File(incomplete_dir,_filename);
  String path_to_incomplete=incomplete_file.getAbsolutePath();
  File complete_file=new File(download_dir,_filename);
  String path_to_complete=complete_file.getAbsolutePath();
  File shared=new File(download_dir);
  String shared_path=shared.getCanonicalPath();
  File parent_of_shared=new File(complete_file.getParent());
  String path_to_parent=parent_of_shared.getCanonicalPath();
  if (!path_to_parent.equals(shared_path)) {
    throw new InvalidPathException();
  }
  if (complete_file.exists()) {
    try {
      complete_file.delete();
    }
 catch (    SecurityException e) {
      throw new IOException(""String_Node_Str"");
    }
  }
  boolean append=false;
  if (_initialReadingPoint > 0)   append=true;
  _fos=new FileOutputStream(path_to_incomplete,append);
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    if (_amountRead == _fileSize)     break;
    if (_amountRead > _fileSize)     throw new FileTooLargeException();
    c=_byteReader.read(buf);
    if (c == -1)     break;
    _fos.write(buf,0,c);
    _amountRead+=c;
  }
  _byteReader.close();
  _fos.close();
  if (_amountRead == _fileSize) {
    complete_file.delete();
    boolean ok=incomplete_file.renameTo(complete_file);
    if (!ok)     throw new FileCantBeMovedException();
    FileManager.instance().addFileIfShared(path_to_complete);
  }
 else   throw new FileIncompleteException();
}","private void doDownload() throws IOException {
  SettingsManager settings=SettingsManager.instance();
  String download_dir=settings.getSaveDirectory();
  File complete_file=new File(download_dir,_filename);
  String path_to_complete=complete_file.getAbsolutePath();
  File shared=new File(download_dir);
  String shared_path=shared.getCanonicalPath();
  File parent_of_shared=new File(complete_file.getParent());
  String path_to_parent=parent_of_shared.getCanonicalPath();
  if (!path_to_parent.equals(shared_path)) {
    throw new InvalidPathException();
  }
  File incomplete_file=new TemporaryFile(_filename,_guid);
  String path_to_incomplete=incomplete_file.getAbsolutePath();
  boolean append=false;
  if (_initialReadingPoint > 0)   append=true;
  _fos=new FileOutputStream(path_to_incomplete,append);
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    if (_amountRead == _fileSize)     break;
    if (_amountRead > _fileSize)     throw new FileTooLargeException();
    c=_byteReader.read(buf);
    if (c == -1)     break;
    _fos.write(buf,0,c);
    _amountRead+=c;
  }
  _byteReader.close();
  _fos.close();
  if (_amountRead == _fileSize) {
    complete_file.delete();
    boolean ok=incomplete_file.renameTo(complete_file);
    if (!ok)     throw new FileCantBeMovedException();
    FileManager.instance().addFileIfShared(path_to_complete);
  }
 else   throw new FileIncompleteException();
}",0.6603527106466361
5055,"/** 
 * @param timeout the amount of time, in milliseconds, to waitwhen establishing a connection.   Must be non-negative.  A timeout of 0 means no timeout.
 */
public HTTPDownloader(String file,String host,int port,int index,byte[] guid,int size,boolean resume,int timeout) throws IOException {
  _filename=file;
  _index=index;
  _guid=guid;
  _amountRead=0;
  _fileSize=size;
  _initialReadingPoint=0;
  if (resume) {
    SettingsManager sm=SettingsManager.instance();
    String incompleteDir;
    incompleteDir=sm.getIncompleteDirectory();
    if (incompleteDir == ""String_Node_Str"")     throw new NullIncompleteDirectoryException();
    String incompletePath;
    incompletePath=incompleteDir + _filename;
    File incompleteFile=new File(incompletePath);
    if (incompleteFile.exists()) {
      _initialReadingPoint=(int)incompleteFile.length();
    }
  }
  connect(host,port,file,index,timeout);
}","/** 
 * @param timeout the amount of time, in milliseconds, to waitwhen establishing a connection.   Must be non-negative.  A timeout of 0 means no timeout.
 * @exception CantConnectException couldn't connect to the host.
 */
public HTTPDownloader(String file,String host,int port,int index,byte[] guid,int size,boolean resume,int timeout) throws IOException {
  _filename=file;
  _index=index;
  _guid=guid;
  _amountRead=0;
  _fileSize=size;
  _initialReadingPoint=0;
  if (resume) {
    SettingsManager sm=SettingsManager.instance();
    String incompleteDir;
    incompleteDir=sm.getIncompleteDirectory();
    if (incompleteDir == ""String_Node_Str"")     throw new NullIncompleteDirectoryException();
    File incompleteFile=new File(incompleteDir,_filename);
    if (incompleteFile.exists()) {
      _initialReadingPoint=(int)incompleteFile.length();
      _amountRead=_initialReadingPoint;
    }
  }
  connect(host,port,file,index,timeout);
}",0.7026443604964921
5056,"/** 
 * Start the download.  Throws IOException if the headers couldn't be read, there remote host has no more download slots, or the download was interrupted.  (In the future different exceptions will be thrown for each of these cases.
 * @modifies this
 */
public void start() throws IOException {
  readHeader();
  doDownload();
}","/** 
 * Start the download, returning when done.  Throws IOException if there is a problem.
 * @modifies this
 * @exception TryAgainLaterException the host is busy
 * @exception NotSharingException the host isn't sharing files
 * @exception FileIncompleteException transfer interrupted, eitherlocally or remotely
 */
public void start() throws IOException {
  readHeader();
  doDownload();
}",0.4281767955801105
5057,"private void connect(Socket s,String file,int index) throws IOException {
  _socket=s;
  try {
    InputStream istream=null;
    try {
      istream=_socket.getInputStream();
    }
 catch (    Exception e) {
      throw new IOException();
    }
    _byteReader=new ByteReader(istream);
    OutputStream os=_socket.getOutputStream();
    OutputStreamWriter osw=new OutputStreamWriter(os);
    BufferedWriter out=new BufferedWriter(osw);
    String startRange=java.lang.String.valueOf(_initialReadingPoint);
    out.write(""String_Node_Str"" + index + ""String_Node_Str""+ file+ ""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.write(""String_Node_Str"" + startRange + ""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.flush();
  }
 catch (  ConnectException e) {
    throw new CantConnectException();
  }
catch (  java.net.MalformedURLException e) {
    throw new BadURLException();
  }
}","private void connect(Socket s,String file,int index) throws IOException {
  _socket=s;
  InputStream istream=null;
  try {
    istream=_socket.getInputStream();
  }
 catch (  Exception e) {
    throw new IOException();
  }
  _byteReader=new ByteReader(istream);
  OutputStream os=_socket.getOutputStream();
  OutputStreamWriter osw=new OutputStreamWriter(os);
  BufferedWriter out=new BufferedWriter(osw);
  String startRange=java.lang.String.valueOf(_initialReadingPoint);
  out.write(""String_Node_Str"" + index + ""String_Node_Str""+ file+ ""String_Node_Str"");
  out.write(""String_Node_Str"");
  out.write(""String_Node_Str"" + startRange + ""String_Node_Str"");
  out.write(""String_Node_Str"");
  out.flush();
}",0.8745341614906832
5058,"/** 
 * @param timeout the amount of time, in milliseconds, to waitwhen establishing a connection.   Must be non-negative.  A timeout of 0 means no timeout.
 */
public HTTPDownloader(String file,String host,int port,int index,byte[] guid,int size,boolean resume,int timeout) throws IOException {
  _filename=file;
  _index=index;
  _guid=guid;
  _amountRead=0;
  _fileSize=size;
  _initialReadingPoint=0;
  if (resume) {
    SettingsManager sm=SettingsManager.instance();
    String incompleteDir;
    incompleteDir=sm.getIncompleteDirectory();
    if (incompleteDir == ""String_Node_Str"")     throw new NullIncompleteDirectoryException();
    String incompletePath;
    incompletePath=incompleteDir + _filename;
    File incompleteFile=new File(incompletePath);
    if (incompleteFile.exists()) {
      _initialReadingPoint=(int)incompleteFile.length();
    }
  }
  connect(host,port,file,index,timeout);
}","/** 
 * @param timeout the amount of time, in milliseconds, to waitwhen establishing a connection.   Must be non-negative.  A timeout of 0 means no timeout.
 * @exception CantConnectException couldn't connect to the host.
 */
public HTTPDownloader(String file,String host,int port,int index,byte[] guid,int size,boolean resume,int timeout) throws IOException {
  _filename=file;
  _index=index;
  _guid=guid;
  _amountRead=0;
  _fileSize=size;
  _initialReadingPoint=0;
  if (resume) {
    SettingsManager sm=SettingsManager.instance();
    String incompleteDir;
    incompleteDir=sm.getIncompleteDirectory();
    if (incompleteDir == ""String_Node_Str"")     throw new NullIncompleteDirectoryException();
    File incompleteFile=new File(incompleteDir,_filename);
    if (incompleteFile.exists()) {
      _initialReadingPoint=(int)incompleteFile.length();
      _amountRead=_initialReadingPoint;
    }
  }
  connect(host,port,file,index,timeout);
}",0.7026443604964921
5059,"/** 
 * Start the download.  Throws IOException if the headers couldn't be read, there remote host has no more download slots, or the download was interrupted.  (In the future different exceptions will be thrown for each of these cases.
 * @modifies this
 */
public void start() throws IOException {
  readHeader();
  doDownload();
}","/** 
 * Start the download, returning when done.  Throws IOException if there is a problem.
 * @modifies this
 * @exception TryAgainLaterException the host is busy
 * @exception NotSharingException the host isn't sharing files
 * @exception FileIncompleteException transfer interrupted, eitherlocally or remotely
 */
public void start() throws IOException {
  readHeader();
  doDownload();
}",0.4281767955801105
5060,"private void connect(Socket s,String file,int index) throws IOException {
  _socket=s;
  try {
    InputStream istream=null;
    try {
      istream=_socket.getInputStream();
    }
 catch (    Exception e) {
      throw new IOException();
    }
    _byteReader=new ByteReader(istream);
    OutputStream os=_socket.getOutputStream();
    OutputStreamWriter osw=new OutputStreamWriter(os);
    BufferedWriter out=new BufferedWriter(osw);
    String startRange=java.lang.String.valueOf(_initialReadingPoint);
    out.write(""String_Node_Str"" + index + ""String_Node_Str""+ file+ ""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.write(""String_Node_Str"" + startRange + ""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.flush();
  }
 catch (  ConnectException e) {
    throw new CantConnectException();
  }
catch (  java.net.MalformedURLException e) {
    throw new BadURLException();
  }
}","private void connect(Socket s,String file,int index) throws IOException {
  _socket=s;
  InputStream istream=null;
  try {
    istream=_socket.getInputStream();
  }
 catch (  Exception e) {
    throw new IOException();
  }
  _byteReader=new ByteReader(istream);
  OutputStream os=_socket.getOutputStream();
  OutputStreamWriter osw=new OutputStreamWriter(os);
  BufferedWriter out=new BufferedWriter(osw);
  String startRange=java.lang.String.valueOf(_initialReadingPoint);
  out.write(""String_Node_Str"" + index + ""String_Node_Str""+ file+ ""String_Node_Str"");
  out.write(""String_Node_Str"");
  out.write(""String_Node_Str"" + startRange + ""String_Node_Str"");
  out.write(""String_Node_Str"");
  out.flush();
}",0.8745341614906832
5061,"public void run(){
  try {
    boolean success;
    for (int i=0; i < TRIES && !stopped; i++) {
      success=tryNormalDownloads();
      if (success) {
        manager.remove(ManagedDownloader.this,true);
        return;
      }
      if (i < 2)       sendPushes();
      success=waitForPushDownloads();
      if (success) {
        manager.remove(ManagedDownloader.this,true);
        return;
      }
    }
    setState(GAVE_UP);
    manager.remove(ManagedDownloader.this,false);
  }
 catch (  InterruptedException e) {
    return;
  }
 finally {
synchronized (ManagedDownloader.this) {
      stopped=true;
      for (Iterator iter=pushQueue.iterator(); iter.hasNext(); )       ((HTTPDownloader)iter.next()).stop();
    }
  }
}","public void run(){
  try {
    boolean success;
    for (int i=0; i < TRIES && !stopped; i++) {
      success=tryNormalDownloads();
      if (success) {
        manager.remove(ManagedDownloader.this,true);
        return;
      }
      if (i < 2)       sendPushes();
      success=waitForPushDownloads();
      if (success) {
        manager.remove(ManagedDownloader.this,true);
        return;
      }
    }
    setState(GAVE_UP);
    manager.remove(ManagedDownloader.this,false);
  }
 catch (  InterruptedException e) {
    return;
  }
 finally {
synchronized (ManagedDownloader.this) {
      stopped=true;
      for (Iterator iter=pushQueue.iterator(); iter.hasNext(); )       ((HTTPDownloader)iter.next()).stop();
      if (dloader != null)       dloader.stop();
    }
  }
}",0.9674850696748508
5062,"/** 
 * Waits at least WAIT_TIME seconds.  If any push downloads come in, handle them, acquiring a download slot first.  Return true if one of these downloads is successful.  Throws InterruptedException if a call to stop() is detected. 
 */
private boolean waitForPushDownloads() throws InterruptedException {
  Date start=new Date();
  while (true) {
synchronized (ManagedDownloader.this) {
      setState(WAITING_FOR_RETRY);
      while (pushQueue.isEmpty()) {
        Date now=new Date();
        long elapsed=now.getTime() - start.getTime();
        long waitTime=WAIT_TIME - elapsed;
        if (waitTime <= 0)         return false;
        ManagedDownloader.this.wait(waitTime);
      }
      dloader=(HTTPDownloader)pushQueue.remove(0);
    }
    try {
      setState(QUEUED);
      manager.waitForSlot(ManagedDownloader.this);
      setState(DOWNLOADING,dloader.getInetAddress().getHostAddress());
      dloader.start();
synchronized (ManagedDownloader.this) {
        if (stopped)         throw new InterruptedException();
        setState(COMPLETE);
      }
      return true;
    }
 catch (    IOException e) {
    }
 finally {
      manager.yieldSlot(ManagedDownloader.this);
    }
  }
}","/** 
 * Waits at least WAIT_TIME seconds.  If any push downloads come in, handle them, acquiring a download slot first.  Return true if one of these downloads is successful.  Throws InterruptedException if a call to stop() is detected. 
 */
private boolean waitForPushDownloads() throws InterruptedException {
  Date start=new Date();
  while (true) {
synchronized (ManagedDownloader.this) {
      setState(WAITING_FOR_RETRY);
      while (pushQueue.isEmpty()) {
        Date now=new Date();
        long elapsed=now.getTime() - start.getTime();
        long waitTime=WAIT_TIME - elapsed;
        if (waitTime <= 0)         return false;
        ManagedDownloader.this.wait(waitTime);
      }
      dloader=(HTTPDownloader)pushQueue.remove(0);
    }
    try {
      setState(QUEUED);
      manager.waitForSlot(ManagedDownloader.this);
      setState(DOWNLOADING,dloader.getInetAddress().getHostAddress());
      dloader.start();
      setState(COMPLETE);
      return true;
    }
 catch (    IOException e) {
synchronized (ManagedDownloader.this) {
        if (stopped)         throw new InterruptedException();
      }
    }
 finally {
      manager.yieldSlot(ManagedDownloader.this);
    }
  }
}",0.9065108514190318
5063,"/** 
 * Called only from initialize()
 * @requires _socket is properly set up
 */
private void sendString(String s) throws IOException {
  byte[] bytes=s.getBytes();
  OutputStream out=_socket.getOutputStream();
  out.write(bytes);
  out.flush();
}","/** 
 * Called only from initialize()
 * @requires _socket, _out are properly set up
 */
private void sendString(String s) throws IOException {
  byte[] bytes=s.getBytes();
  _out.write(bytes);
  _out.flush();
}",0.8671023965141612
5064,"public void remove(){
  if (lastYielded == null)   return;
  real.remove();
  FixedsizeForgetfulHashMap.this.remove(lastYielded);
}","/** 
 * Same as Iterator.remove().  That means that calling remove() multiple times may have undefined results! 
 */
public void remove(){
  if (lastYielded == null)   return;
  ValueElement ve=(ValueElement)map.get(lastYielded);
  if (ve != null) {
    currentSize--;
    removeList.remove(ve.getListElement());
  }
  real.remove();
}",0.2918454935622318
5065,"/** 
 * @requires If isPush, ""GIV "" was just read from s.Otherwise, ""GET "" was just read from s.
 * @effects  Transfers the file over s <i>in the foreground</i>.Throws IOException if the handshake failed.
 */
public HTTPManager(Socket s,MessageRouter router,Acceptor acceptor,ActivityCallback callback,boolean isPush) throws IOException {
  _socket=s;
  String command=null;
  FileManager fm=FileManager.instance();
  try {
    _socket.setSoTimeout(SettingsManager.instance().getTimeout());
    try {
      _istream=_socket.getInputStream();
    }
 catch (    Exception e) {
      throw new IOException();
    }
    _br=new ByteReader(_istream);
    command=_br.readLine();
    if (command == null)     throw new IOException();
  }
 catch (  IOException e) {
    throw e;
  }
  try {
    if (!isPush) {
      String parse[]=HTTPUtil.stringSplit(command,'/');
      if (parse.length != 4)       throw new IOException();
      if (!parse[0].equals(""String_Node_Str""))       throw new IOException();
      _filename=parse[2].substring(0,parse[2].lastIndexOf(""String_Node_Str"") - 1);
      _index=java.lang.Integer.parseInt(parse[1]);
      readRange();
      while (HTTPUploader.getUploadCount() >= SettingsManager.instance().getMaxUploads()) {
        if (!HTTPUploader.checkForLowPriorityUpload(userAgent)) {
          HTTPUploader.doLimitReached(s);
          return;
        }
      }
      HTTPUploader uploader;
      uploader=new HTTPUploader(s,_filename,_index,callback,_uploadBegin,_uploadEnd);
      uploader.setUserAgent(userAgent);
      Thread.currentThread().setName(""String_Node_Str"");
      uploader.run();
    }
 else {
      String next=_br.readLine();
      if (next == null || (!next.equals(""String_Node_Str""))) {
        throw new IOException();
      }
      int i=command.indexOf(""String_Node_Str"");
      _index=Integer.parseInt(command.substring(0,i));
      int j=command.indexOf(""String_Node_Str"",i);
      byte[] guid=GUID.fromHexString(command.substring(i + 1,j));
      _filename=command.substring(j + 1);
      HTTPDownloader downloader;
      downloader=new HTTPDownloader(s,_filename,_index,guid,router,acceptor,callback);
      Thread.currentThread().setName(""String_Node_Str"");
      downloader.run();
    }
  }
 catch (  IndexOutOfBoundsException e) {
    throw new IOException();
  }
catch (  NumberFormatException e) {
    throw new IOException();
  }
catch (  IllegalArgumentException e) {
    throw new IOException();
  }
catch (  IllegalAccessException e) {
    throw new IOException();
  }
}","/** 
 * @requires If isPush, ""GIV "" was just read from s.Otherwise, ""GET "" was just read from s.
 * @effects  Transfers the file over s <i>in the foreground</i>.Throws IOException if the handshake failed.
 */
public HTTPManager(Socket s,MessageRouter router,Acceptor acceptor,ActivityCallback callback,boolean isPush) throws IOException {
  _socket=s;
  String command=null;
  FileManager fm=FileManager.instance();
  try {
    _socket.setSoTimeout(SettingsManager.instance().getTimeout());
    try {
      _istream=_socket.getInputStream();
    }
 catch (    Exception e) {
      throw new IOException();
    }
    _br=new ByteReader(_istream);
    command=_br.readLine();
    if (command == null)     throw new IOException();
  }
 catch (  IOException e) {
    throw e;
  }
  try {
    if (!isPush) {
      String parse[]=HTTPUtil.stringSplit(command,'/');
      if (parse.length != 4)       throw new IOException();
      if (!parse[0].equals(""String_Node_Str""))       throw new IOException();
      _filename=parse[2].substring(0,parse[2].lastIndexOf(""String_Node_Str"") - 1);
      _index=java.lang.Integer.parseInt(parse[1]);
      readRange();
      while (HTTPUploader.getUploadCount() >= SettingsManager.instance().getMaxUploads()) {
        if (!HTTPUploader.checkForLowPriorityUpload(userAgent)) {
          HTTPUploader.doLimitReached(s);
          return;
        }
      }
      HTTPUploader uploader;
      uploader=new HTTPUploader(s,_filename,_index,callback,_uploadBegin,_uploadEnd);
      uploader.setUserAgent(userAgent);
      Thread.currentThread().setName(""String_Node_Str"");
      uploader.run();
    }
 else {
      String next=_br.readLine();
      if (next == null || (!next.equals(""String_Node_Str""))) {
        throw new IOException();
      }
      int i=command.indexOf(""String_Node_Str"");
      _index=Integer.parseInt(command.substring(0,i));
      int j=command.indexOf(""String_Node_Str"",i);
      byte[] guid=GUID.fromHexString(command.substring(i + 1,j));
      _filename=command.substring(j + 1);
      s.setSoTimeout(0);
      HTTPDownloader downloader;
      downloader=new HTTPDownloader(s,_filename,_index,guid,router,acceptor,callback);
      Thread.currentThread().setName(""String_Node_Str"");
      downloader.run();
    }
  }
 catch (  IndexOutOfBoundsException e) {
    throw new IOException();
  }
catch (  NumberFormatException e) {
    throw new IOException();
  }
catch (  IllegalArgumentException e) {
    throw new IOException();
  }
catch (  IllegalAccessException e) {
    throw new IOException();
  }
}",0.9950835791543756
5066,"/** 
 * Receives a message with timeout.  This method is NOT thread-safe. Behavior is undefined if two threads are in a receive call at the same time for a given connection.
 * @requires this is fully initialized
 * @effects exactly like Message.read(), but throws InterruptedIOExceptionif timeout!=0 and no message is read after ""timeout"" milliseconds.  In this case, you should terminate the connection, as half a message may have been read.
 */
public Message receive(int timeout) throws IOException, BadPacketException, InterruptedIOException {
  int oldTimeout=_socket.getSoTimeout();
  _socket.setSoTimeout(timeout);
  try {
    Message m=Message.read(_in);
    if (m == null)     throw new InterruptedIOException();
    return m;
  }
  finally {
    _socket.setSoTimeout(oldTimeout);
  }
}","/** 
 * Receives a message with timeout.  This method is NOT thread-safe. Behavior is undefined if two threads are in a receive call at the same time for a given connection.
 * @requires this is fully initialized
 * @effects exactly like Message.read(), but throws InterruptedIOExceptionif timeout!=0 and no message is read after ""timeout"" milliseconds.  In this case, you should terminate the connection, as half a message may have been read.
 */
public Message receive(int timeout) throws IOException, BadPacketException, InterruptedIOException {
  if (_closed)   throw new IOException();
  int oldTimeout=_socket.getSoTimeout();
  _socket.setSoTimeout(timeout);
  try {
    Message m=Message.read(_in);
    if (m == null)     throw new InterruptedIOException();
    return m;
  }
  finally {
    _socket.setSoTimeout(oldTimeout);
  }
}",0.7882496940024479
5067,"/** 
 * @modifies this.responses
 * @effects extracts response from payload and stores in responses. 
 */
private void parseResults() throws BadPacketException {
  int i=11;
  int left=getResultCount();
  responses=new Response[left];
  try {
    for (; left > 0; left--) {
      long index=ByteOrder.ubytes2long(ByteOrder.leb2int(payload,i));
      long size=ByteOrder.ubytes2long(ByteOrder.leb2int(payload,i + 4));
      i+=8;
      int j=i;
      for (; ; j++) {
        if (payload[j] == (byte)0)         break;
      }
      String name=new String(payload,i,j - i);
      responses[responses.length - left]=new Response(index,size,name);
      for (j=j + 1; ; j++) {
        if (payload[j] == (byte)0)         break;
      }
      i=j + 1;
    }
    if (i < payload.length - 16)     throw new BadPacketException(""String_Node_Str"" + ""String_Node_Str"");
 else     if (i > payload.length - 16)     throw new BadPacketException(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new BadPacketException();
  }
}","/** 
 * @modifies this.responses
 * @effects extracts response from payload and stores in responses. 
 */
private void parseResults() throws BadPacketException {
  int i=11;
  int left=getResultCount();
  responses=new Response[left];
  try {
    for (; left > 0; left--) {
      long index=ByteOrder.ubytes2long(ByteOrder.leb2int(payload,i));
      long size=ByteOrder.ubytes2long(ByteOrder.leb2int(payload,i + 4));
      i+=8;
      int j=i;
      for (; ; j++) {
        if (payload[j] == (byte)0)         break;
      }
      String name=new String(payload,i,j - i);
      responses[responses.length - left]=new Response(index,size,name);
      for (j=j + 1; ; j++) {
        if (payload[j] == (byte)0)         break;
      }
      i=j + 1;
    }
    if (i > payload.length - 16)     throw new BadPacketException(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new BadPacketException();
  }
}",0.9442231075697212
5068,"public void setForcedIPAddress(String address){
  if (address == null)   throw new IllegalArgumentException();
  forcedIPAdress_=address;
  props_.put(SettingsInterface.FORCED_IP_ADDRESS,address);
  writeProperties();
}","public void setForcedIPAddress(String address){
  if (address == null)   throw new IllegalArgumentException();
  forcedIPAdress_=address;
  props_.put(SettingsInterface.FORCED_IP_ADDRESS,address);
}",0.9496402877697842
5069,"public void setForcedPort(){
}","public void setForcedPort(int port){
  forcedPort_=port;
  String s=Integer.toString(forcedPort_);
  props_.put(SettingsInterface.FORCED_PORT,s);
}",0.3389830508474576
5070,"public void setLastVersionChecked(String last){
  lastVersionChecked_=last;
  props_.put(SettingsInterface.LAST_VERSION_CHECKED,last);
  writeProperties();
}","/** 
 * private methods to handle versioning  control information
 */
public void setLastVersionChecked(String last){
  lastVersionChecked_=last;
  props_.put(SettingsInterface.LAST_VERSION_CHECKED,last);
  writeProperties();
}",0.8177083333333334
5071,"public void setForceIPAddress(boolean force){
  String c;
  if (force == true)   c=""String_Node_Str"";
 else   c=""String_Node_Str"";
  forceIPAdress_=force;
  props_.put(SettingsInterface.FORCE_IP_ADDRESS,c);
  writeProperties();
}","public void setForceIPAddress(boolean force){
  String c;
  if (force == true)   c=""String_Node_Str"";
 else   c=""String_Node_Str"";
  forceIPAdress_=force;
  props_.put(SettingsInterface.FORCE_IP_ADDRESS,c);
}",0.9519450800915332
5072,"/** 
 * @modifies this
 * @effects atomically removes and returns the highest priority host inthis.  If no host is available, blocks until one is.  If the calling thread is interrupted during this process, throws InterruptedException.
 */
public Endpoint getAnEndpoint() throws InterruptedException {
  if (settings.getUseQuickConnect() && stale) {
    try {
synchronized (staleWaitersLock) {
        staleWaiters++;
        staleWaitersLock.notify();
      }
synchronized (staleLock) {
        if (stale) {
          staleLock.wait(CONNECT_TIME);
        }
      }
    }
  finally {
synchronized (staleWaitersLock) {
        staleWaiters--;
      }
    }
  }
synchronized (this) {
    while (true) {
      try {
        return getAnEndpointInternal();
      }
 catch (      NoSuchElementException e) {
        wait();
      }
    }
  }
}","/** 
 * @modifies this
 * @effects atomically removes and returns the highest priority host inthis.  If no host is available, blocks until one is.  If the calling thread is interrupted during this process, throws InterruptedException.
 */
public Endpoint getAnEndpoint() throws InterruptedException {
  if (settings.getUseQuickConnect() && stale) {
    try {
synchronized (staleWaitersLock) {
        staleWaiters++;
        staleWaitersLock.notify();
      }
synchronized (staleLock) {
        if (stale) {
          staleLock.wait(CONNECT_TIME);
        }
      }
    }
  finally {
synchronized (staleWaitersLock) {
        staleWaiters--;
      }
    }
  }
  Endpoint endpoint=null;
synchronized (this) {
    while (true) {
      try {
        endpoint=getAnEndpointInternal();
        break;
      }
 catch (      NoSuchElementException e) {
        wait();
      }
    }
  }
  return endpoint;
}",0.95512082853855
5073,"public static void launch(String path) throws IOException {
  if (!loadedWithoutErrors) {
    throw new IOException(""String_Node_Str"" + errorMessage);
  }
  Object browser=locateBrowser();
  if (browser == null) {
    throw new IOException(""String_Node_Str"" + errorMessage);
  }
  String command;
switch (jvm) {
case MRJ_2_1:
    Runtime.getRuntime().exec(new String[]{(String)browser,path});
  break;
case WINDOWS_NT:
File f=new File(path);
if (f.isFile()) {
FileInputStream fis=new FileInputStream(f);
String hex=Integer.toHexString(fis.read());
hex+=Integer.toHexString(fis.read());
if (hex.equals(""String_Node_Str"")) {
  Utilities.showError(""String_Node_Str"" + ""String_Node_Str"");
  return;
}
command=""String_Node_Str"" + ""String_Node_Str"" + checkChars(path) + ""String_Node_Str"";
Runtime.getRuntime().exec(command);
}
break;
case WINDOWS_9x:
File f=new File(path);
if (f.isFile()) {
FileInputStream fis=new FileInputStream(f);
String hex=Integer.toHexString(fis.read());
hex+=Integer.toHexString(fis.read());
if (hex.equals(""String_Node_Str"")) {
Utilities.showError(""String_Node_Str"" + ""String_Node_Str"");
return;
}
command=""String_Node_Str"" + ""String_Node_Str"" + path + ""String_Node_Str"";
Runtime.getRuntime().exec(command);
}
break;
case OTHER:
String[] strs={(String)browser,NETSCAPE_REMOTE_PARAMETER,NETSCAPE_OPEN_PARAMETER_START,path,NETSCAPE_OPEN_PARAMETER_END};
Process process=Runtime.getRuntime().exec(strs);
try {
int exitCode=process.waitFor();
if (exitCode != 0) Runtime.getRuntime().exec(new String[]{(String)browser,path});
}
 catch (InterruptedException ie) {
throw new IOException(""String_Node_Str"" + ie.getMessage());
}
break;
default :
Runtime.getRuntime().exec(new String[]{(String)browser,path});
break;
}
}","public static void launch(String path) throws IOException {
  if (!loadedWithoutErrors) {
    throw new IOException(""String_Node_Str"" + errorMessage);
  }
  Object browser=locateBrowser();
  if (browser == null) {
    throw new IOException(""String_Node_Str"" + errorMessage);
  }
  String command;
switch (jvm) {
case MRJ_2_1:
    Runtime.getRuntime().exec(new String[]{(String)browser,path});
  break;
case WINDOWS_NT:
File f=new File(path);
if (f.isFile()) {
FileInputStream fis=new FileInputStream(f);
String hex=Integer.toHexString(fis.read());
hex+=Integer.toHexString(fis.read());
if (hex.equals(""String_Node_Str"")) {
  Utilities.showError(""String_Node_Str"" + ""String_Node_Str"");
  return;
}
command=""String_Node_Str"" + ""String_Node_Str"" + checkChars(path) + ""String_Node_Str"";
Runtime.getRuntime().exec(command);
}
break;
case WINDOWS_9x:
File fi=new File(path);
if (fi.isFile()) {
FileInputStream fis=new FileInputStream(fi);
String hex=Integer.toHexString(fis.read());
hex+=Integer.toHexString(fis.read());
if (hex.equals(""String_Node_Str"")) {
Utilities.showError(""String_Node_Str"" + ""String_Node_Str"");
return;
}
command=""String_Node_Str"" + ""String_Node_Str"" + path + ""String_Node_Str"";
Runtime.getRuntime().exec(command);
}
break;
case OTHER:
String[] strs={(String)browser,NETSCAPE_REMOTE_PARAMETER,NETSCAPE_OPEN_PARAMETER_START,path,NETSCAPE_OPEN_PARAMETER_END};
Process process=Runtime.getRuntime().exec(strs);
try {
int exitCode=process.waitFor();
if (exitCode != 0) Runtime.getRuntime().exec(new String[]{(String)browser,path});
}
 catch (InterruptedException ie) {
throw new IOException(""String_Node_Str"" + ie.getMessage());
}
break;
default :
Runtime.getRuntime().exec(new String[]{(String)browser,path});
break;
}
}",0.9991336991048224
5074,"private synchronized void addMessage(Message m){
  messages.add(new TimeAndMessage(System.currentTimeMillis(),m));
  if ((mCount++ % 1000) == 0) {
    dumpMessages();
  }
}","private synchronized void addMessage(Message m){
  if (messages == null)   return;
 else   if (messages.size() < SIZE) {
    if ((messages.size() % 200) == 0) {
      System.out.print(""String_Node_Str"" + messages.size() + ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + (SIZE - messages.size()) + ""String_Node_Str"");
    }
    messages.addElement(new TimeAndMessage(System.currentTimeMillis(),m));
  }
 else {
    System.out.println(""String_Node_Str"");
    System.out.print(""String_Node_Str"");
    dumpMessages();
    messages=null;
    System.out.println(""String_Node_Str"");
  }
}",0.2311688311688311
5075,"private void loopForPingRequest() throws IOException {
  while (true) {
    Message m=null;
    try {
      m=receive(SettingsManager.instance().getTimeout());
      if (m == null)       return;
    }
 catch (    BadPacketException e) {
      return;
    }
    if ((m instanceof PingRequest) && (m.getHops() == 0)) {
      Iterator iter=_hostCatcher.getBestHosts(10);
      while (iter.hasNext()) {
        Endpoint bestEndPoint=(Endpoint)iter.next();
        PingReply pr=new PingReply(m.getGUID(),(byte)1,bestEndPoint.getPort(),bestEndPoint.getHostBytes(),0,0);
        send(pr);
      }
    }
  }
}","private void loopForPingRequest() throws IOException {
  for (int i=0; i < 10; i++) {
    Message m=null;
    try {
      m=receive(SettingsManager.instance().getTimeout());
      if (m == null)       return;
    }
 catch (    BadPacketException e) {
      return;
    }
    if ((m instanceof PingRequest) && (m.getHops() == 0)) {
      Iterator iter=_hostCatcher.getBestHosts(10);
      while (iter.hasNext()) {
        Endpoint bestEndPoint=(Endpoint)iter.next();
        PingReply pr=new PingReply(m.getGUID(),(byte)1,bestEndPoint.getPort(),bestEndPoint.getHostBytes(),0,0);
        send(pr);
      }
      flush();
      return;
    }
  }
}",0.9477911646586346
5076,"/** 
 * This sets up the file name for nt to escape special characters. 
 */
private static String checkChars(String str){
  String escapeChars=""String_Node_Str"";
  char[] chars=str.toCharArray();
  int length=chars.length;
  char[] new_chars=new char[length * 3];
  int index=0;
  for (int i=0; i < length; i++) {
    if (escapeChars.indexOf(chars[i]) != -1) {
      new_chars[index++]='""';
      new_chars[index++]=chars[i];
      new_chars[index++]='""';
    }
 else     new_chars[index++]=chars[i];
  }
  String s=new String(new_chars);
  return s.trim();
}","/** 
 * This sets up the file name for nt to escape special characters. 
 */
private static String checkChars(String str){
  System.out.println(""String_Node_Str"" + str);
  String escapeChars=""String_Node_Str"";
  char[] chars=str.toCharArray();
  int length=chars.length;
  char[] new_chars=new char[length * 3];
  int index=0;
  for (int i=0; i < length; i++) {
    if (escapeChars.indexOf(chars[i]) != -1) {
      new_chars[index++]='""';
      new_chars[index++]=chars[i];
      new_chars[index++]='""';
    }
 else     new_chars[index++]=chars[i];
  }
  String s=new String(new_chars);
  return s.trim();
}",0.9597257926306768
5077,"public void doDownload(){
  if (_wasShutdown)   return;
  readHeader();
  if (_state == ERROR)   return;
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String incompleteDir=set.getIncompleteDirectory();
  File myFile=new File(incompleteDir,_filename);
  String pathname=myFile.getAbsolutePath();
  File myTest=new File(_downloadDir,_filename);
  String path=myTest.getAbsolutePath();
  File f;
  String p;
  try {
    File shared=new File(_downloadDir);
    String shared_path=shared.getCanonicalPath();
    f=new File(myTest.getParent());
    p=f.getCanonicalPath();
    if (!p.equals(shared_path)) {
      _state=ERROR;
      return;
    }
  }
 catch (  Exception e) {
    _state=ERROR;
    return;
  }
  if ((myTest.exists()) && (!_resume)) {
    if (!_callback.overwriteFile(_filename)) {
      _stateString=""String_Node_Str"";
      _state=ERROR;
      return;
    }
  }
  try {
    _fos=new FileOutputStream(pathname,_resume);
  }
 catch (  FileNotFoundException e) {
    _state=ERROR;
    return;
  }
catch (  Exception e) {
    _state=ERROR;
    return;
  }
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    if (_amountRead == _sizeOfFile) {
      _state=COMPLETE;
      break;
    }
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      e.printStackTrace();
      _state=ERROR;
      return;
    }
    if (c == -1) {
      break;
    }
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      _state=ERROR;
      break;
    }
    _amountRead+=c;
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
    _state=ERROR;
    return;
  }
  if (_amountRead == _sizeOfFile) {
    String pname=_downloadDir + _filename;
    boolean ok=myFile.renameTo(new File(pname));
    if (!ok) {
      _state=ERROR;
      _stateString=""String_Node_Str"";
      return;
    }
    _state=COMPLETE;
    FileManager.getFileManager().addFileIfShared(pname);
  }
 else {
    _state=ERROR;
  }
}","public void doDownload(){
  if (_wasShutdown)   return;
  readHeader();
  if (_state == ERROR)   return;
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String incompleteDir=set.getIncompleteDirectory();
  File myFile=new File(incompleteDir,_filename);
  String pathname=myFile.getAbsolutePath();
  File myTest=new File(_downloadDir,_filename);
  String path=myTest.getAbsolutePath();
  File f;
  String p;
  try {
    File shared=new File(_downloadDir);
    String shared_path=shared.getCanonicalPath();
    f=new File(myTest.getParent());
    p=f.getCanonicalPath();
    if (!p.equals(shared_path)) {
      _state=ERROR;
      return;
    }
  }
 catch (  Exception e) {
    _state=ERROR;
    return;
  }
  if ((myTest.exists()) && (!_resume)) {
    if (!_callback.overwriteFile(_filename)) {
      _stateString=""String_Node_Str"";
      _state=ERROR;
      return;
    }
  }
  try {
    _fos=new FileOutputStream(pathname,_resume);
  }
 catch (  FileNotFoundException e) {
    _state=ERROR;
    return;
  }
catch (  Exception e) {
    _state=ERROR;
    return;
  }
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    if (_amountRead == _sizeOfFile) {
      _state=COMPLETE;
      break;
    }
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      _state=ERROR;
      return;
    }
    if (c == -1) {
      break;
    }
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      _state=ERROR;
      break;
    }
    _amountRead+=c;
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
    _state=ERROR;
    return;
  }
  if (_amountRead == _sizeOfFile) {
    String pname=_downloadDir + _filename;
    boolean ok=myFile.renameTo(new File(pname));
    if (!ok) {
      _state=ERROR;
      _stateString=""String_Node_Str"";
      return;
    }
    _state=COMPLETE;
    FileManager.getFileManager().addFileIfShared(pname);
  }
 else {
    _state=ERROR;
    _stateString=""String_Node_Str"";
  }
}",0.9842302878598248
5078,"public void initThree(){
  _stateString=null;
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String pathname=_downloadDir + _filename;
  File myFile=new File(pathname);
  if (!myFile.exists()) {
    _stateString=""String_Node_Str"";
    _state=ERROR;
    return;
  }
  URLConnection conn;
  String furl=""String_Node_Str"" + String.valueOf(_index) + ""String_Node_Str""+ _filename;
  long start=myFile.length();
  String startRange=java.lang.String.valueOf(start);
  try {
    URL url=new URL(_protocol,_host,_port,furl);
    conn=url.openConnection();
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + startRange + ""String_Node_Str"");
    conn.connect();
    _istream=conn.getInputStream();
    _br=new ByteReader(_istream);
  }
 catch (  Exception e) {
    _stateString=""String_Node_Str"";
    _state=ERROR;
    return;
  }
  _resume=true;
  _state=CONNECTED;
}","public void initThree(){
  _stateString=null;
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getIncompleteDirectory();
  String pathname=_downloadDir + _filename;
  File myFile=new File(pathname);
  if (!myFile.exists()) {
    _stateString=""String_Node_Str"";
    _state=ERROR;
    return;
  }
  URLConnection conn;
  String furl=""String_Node_Str"" + String.valueOf(_index) + ""String_Node_Str""+ _filename;
  long start=myFile.length();
  String startRange=java.lang.String.valueOf(start);
  try {
    URL url=new URL(_protocol,_host,_port,furl);
    conn=url.openConnection();
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + startRange + ""String_Node_Str"");
    conn.connect();
    _istream=conn.getInputStream();
    _br=new ByteReader(_istream);
  }
 catch (  Exception e) {
    _stateString=""String_Node_Str"";
    _state=ERROR;
    return;
  }
  _resume=true;
  _state=CONNECTED;
}",0.9934711643090316
5079,"public void doDownload(){
  if (_wasShutdown)   return;
  readHeader();
  if (_state == ERROR)   return;
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String incompleteDir=set.getIncompleteDirectory();
  File myFile=new File(incompleteDir,_filename);
  String pathname=myFile.getAbsolutePath();
  File myTest=new File(_downloadDir,_filename);
  String path=myTest.getAbsolutePath();
  File f;
  String p;
  try {
    File shared=new File(_downloadDir);
    String shared_path=shared.getCanonicalPath();
    f=new File(myTest.getParent());
    p=f.getCanonicalPath();
    if (!p.equals(shared_path)) {
      _state=ERROR;
      return;
    }
  }
 catch (  Exception e) {
    _state=ERROR;
    return;
  }
  if ((myTest.exists()) && (!_resume)) {
    if (!_callback.overwriteFile(_filename)) {
      _stateString=""String_Node_Str"";
      _state=ERROR;
      return;
    }
  }
  try {
    _fos=new FileOutputStream(pathname,_resume);
  }
 catch (  FileNotFoundException e) {
    _state=ERROR;
    return;
  }
catch (  Exception e) {
    _state=ERROR;
    return;
  }
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    if (_amountRead == _sizeOfFile) {
      _state=COMPLETE;
      break;
    }
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      e.printStackTrace();
      _state=ERROR;
      return;
    }
    if (c == -1) {
      break;
    }
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      _state=ERROR;
      break;
    }
    _amountRead+=c;
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
    _state=ERROR;
    return;
  }
  if (_amountRead == _sizeOfFile) {
    String pname=_downloadDir + _filename;
    boolean ok=myFile.renameTo(new File(pname));
    if (!ok) {
      _state=ERROR;
      _stateString=""String_Node_Str"";
      return;
    }
    _state=COMPLETE;
    FileManager.getFileManager().addFileIfShared(pname);
  }
 else {
    _state=ERROR;
  }
}","public void doDownload(){
  if (_wasShutdown)   return;
  readHeader();
  if (_state == ERROR)   return;
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String incompleteDir=set.getIncompleteDirectory();
  File myFile=new File(incompleteDir,_filename);
  String pathname=myFile.getAbsolutePath();
  File myTest=new File(_downloadDir,_filename);
  String path=myTest.getAbsolutePath();
  File f;
  String p;
  try {
    File shared=new File(_downloadDir);
    String shared_path=shared.getCanonicalPath();
    f=new File(myTest.getParent());
    p=f.getCanonicalPath();
    if (!p.equals(shared_path)) {
      _state=ERROR;
      return;
    }
  }
 catch (  Exception e) {
    _state=ERROR;
    return;
  }
  if ((myTest.exists()) && (!_resume)) {
    if (!_callback.overwriteFile(_filename)) {
      _stateString=""String_Node_Str"";
      _state=ERROR;
      return;
    }
  }
  try {
    _fos=new FileOutputStream(pathname,_resume);
  }
 catch (  FileNotFoundException e) {
    _state=ERROR;
    return;
  }
catch (  Exception e) {
    _state=ERROR;
    return;
  }
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    if (_amountRead == _sizeOfFile) {
      _state=COMPLETE;
      break;
    }
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      _state=ERROR;
      return;
    }
    if (c == -1) {
      break;
    }
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      _state=ERROR;
      break;
    }
    _amountRead+=c;
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
    _state=ERROR;
    return;
  }
  if (_amountRead == _sizeOfFile) {
    String pname=_downloadDir + _filename;
    boolean ok=myFile.renameTo(new File(pname));
    if (!ok) {
      _state=ERROR;
      _stateString=""String_Node_Str"";
      return;
    }
    _state=COMPLETE;
    FileManager.getFileManager().addFileIfShared(pname);
  }
 else {
    _state=ERROR;
    _stateString=""String_Node_Str"";
  }
}",0.9842302878598248
5080,"public void initThree(){
  _stateString=null;
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String pathname=_downloadDir + _filename;
  File myFile=new File(pathname);
  if (!myFile.exists()) {
    _stateString=""String_Node_Str"";
    _state=ERROR;
    return;
  }
  URLConnection conn;
  String furl=""String_Node_Str"" + String.valueOf(_index) + ""String_Node_Str""+ _filename;
  long start=myFile.length();
  String startRange=java.lang.String.valueOf(start);
  try {
    URL url=new URL(_protocol,_host,_port,furl);
    conn=url.openConnection();
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + startRange + ""String_Node_Str"");
    conn.connect();
    _istream=conn.getInputStream();
    _br=new ByteReader(_istream);
  }
 catch (  Exception e) {
    _stateString=""String_Node_Str"";
    _state=ERROR;
    return;
  }
  _resume=true;
  _state=CONNECTED;
}","public void initThree(){
  _stateString=null;
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getIncompleteDirectory();
  String pathname=_downloadDir + _filename;
  File myFile=new File(pathname);
  if (!myFile.exists()) {
    _stateString=""String_Node_Str"";
    _state=ERROR;
    return;
  }
  URLConnection conn;
  String furl=""String_Node_Str"" + String.valueOf(_index) + ""String_Node_Str""+ _filename;
  long start=myFile.length();
  String startRange=java.lang.String.valueOf(start);
  try {
    URL url=new URL(_protocol,_host,_port,furl);
    conn=url.openConnection();
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + startRange + ""String_Node_Str"");
    conn.connect();
    _istream=conn.getInputStream();
    _br=new ByteReader(_istream);
  }
 catch (  Exception e) {
    _stateString=""String_Node_Str"";
    _state=ERROR;
    return;
  }
  _resume=true;
  _state=CONNECTED;
}",0.9934711643090316
5081,"public void doDownload(){
  if (_wasShutdown)   return;
  readHeader();
  if (_state == ERROR)   return;
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String incompleteDir=set.getIncompleteDirectory();
  File myFile=new File(incompleteDir,_filename);
  String pathname=myFile.getAbsolutePath();
  File myTest=new File(_downloadDir,_filename);
  String path=myTest.getAbsolutePath();
  File f;
  String p;
  try {
    File shared=new File(_downloadDir);
    String shared_path=shared.getCanonicalPath();
    f=new File(myTest.getParent());
    p=f.getCanonicalPath();
    if (!p.equals(shared_path)) {
      _state=ERROR;
      return;
    }
  }
 catch (  Exception e) {
    _state=ERROR;
    return;
  }
  if ((myTest.exists()) && (!_resume)) {
    if (!_callback.overwriteFile(_filename)) {
      _stateString=""String_Node_Str"";
      _state=ERROR;
      return;
    }
  }
  try {
    _fos=new FileOutputStream(pathname,_resume);
  }
 catch (  FileNotFoundException e) {
    _state=ERROR;
    return;
  }
catch (  Exception e) {
    _state=ERROR;
    return;
  }
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    if (_amountRead == _sizeOfFile) {
      _state=COMPLETE;
      break;
    }
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      _state=ERROR;
      return;
    }
    if (c == -1) {
      break;
    }
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      _state=ERROR;
      break;
    }
    _amountRead+=c;
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
    _state=ERROR;
    return;
  }
  if (_amountRead == _sizeOfFile) {
    String pname=_downloadDir + _filename;
    boolean ok=myFile.renameTo(new File(pname));
    if (!ok) {
      _state=ERROR;
      _stateString=""String_Node_Str"";
      return;
    }
    _state=COMPLETE;
    FileManager.getFileManager().addFileIfShared(pname);
  }
 else {
    _state=ERROR;
    _stateString=""String_Node_Str"";
  }
}","public void doDownload(){
  if (_wasShutdown)   return;
  readHeader();
  if (_state == ERROR)   return;
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String incompleteDir=set.getIncompleteDirectory();
  File myFile=new File(incompleteDir,_filename);
  String pathname=myFile.getAbsolutePath();
  File myTest=new File(_downloadDir,_filename);
  String path=myTest.getAbsolutePath();
  File f;
  String p;
  try {
    File shared=new File(_downloadDir);
    String shared_path=shared.getCanonicalPath();
    f=new File(myTest.getParent());
    p=f.getCanonicalPath();
    if (!p.equals(shared_path)) {
      _state=ERROR;
      return;
    }
  }
 catch (  Exception e) {
    _state=ERROR;
    return;
  }
  if (myTest.exists()) {
    if (!_callback.overwriteFile(_filename)) {
      _stateString=""String_Node_Str"";
      _state=ERROR;
      return;
    }
  }
  try {
    _fos=new FileOutputStream(pathname,_resume);
  }
 catch (  FileNotFoundException e) {
    _state=ERROR;
    return;
  }
catch (  Exception e) {
    _state=ERROR;
    return;
  }
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    if (_amountRead == _sizeOfFile) {
      _state=COMPLETE;
      break;
    }
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      _state=ERROR;
      return;
    }
    if (c == -1) {
      break;
    }
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      _state=ERROR;
      break;
    }
    _amountRead+=c;
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
    _state=ERROR;
    return;
  }
  if (_amountRead == _sizeOfFile) {
    String pname=_downloadDir + _filename;
    File target=new File(pname);
    target.delete();
    boolean ok=myFile.renameTo(target);
    if (!ok) {
      _state=ERROR;
      _stateString=""String_Node_Str"";
      return;
    }
    _state=COMPLETE;
    FileManager.getFileManager().addFileIfShared(pname);
  }
 else {
    _state=ERROR;
    _stateString=""String_Node_Str"";
  }
}",0.9774361517480784
5082,"public void doDownload(){
  if (_wasShutdown)   return;
  readHeader();
  if (_state == ERROR)   return;
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String incompleteDir=set.getIncompleteDirectory();
  File myFile=new File(incompleteDir,_filename);
  String pathname=myFile.getAbsolutePath();
  File myTest=new File(_downloadDir,_filename);
  String path=myTest.getAbsolutePath();
  File f;
  String p;
  try {
    File shared=new File(_downloadDir);
    String shared_path=shared.getCanonicalPath();
    f=new File(myTest.getParent());
    p=f.getCanonicalPath();
    if (!p.equals(shared_path)) {
      _state=ERROR;
      return;
    }
  }
 catch (  Exception e) {
    _state=ERROR;
    return;
  }
  if ((myTest.exists()) && (!_resume)) {
    if (!_callback.overwriteFile(_filename)) {
      _stateString=""String_Node_Str"";
      _state=ERROR;
      return;
    }
  }
  try {
    _fos=new FileOutputStream(pathname,_resume);
  }
 catch (  FileNotFoundException e) {
    _state=ERROR;
    return;
  }
catch (  Exception e) {
    _state=ERROR;
    return;
  }
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    if (_amountRead == _sizeOfFile) {
      _state=COMPLETE;
      break;
    }
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      _state=ERROR;
      return;
    }
    if (c == -1) {
      break;
    }
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      _state=ERROR;
      break;
    }
    _amountRead+=c;
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
    _state=ERROR;
    return;
  }
  if (_amountRead == _sizeOfFile) {
    String pname=_downloadDir + _filename;
    boolean ok=myFile.renameTo(new File(pname));
    if (!ok) {
      _state=ERROR;
      _stateString=""String_Node_Str"";
      return;
    }
    _state=COMPLETE;
    FileManager.getFileManager().addFileIfShared(pname);
  }
 else {
    _state=ERROR;
    _stateString=""String_Node_Str"";
  }
}","public void doDownload(){
  if (_wasShutdown)   return;
  readHeader();
  if (_state == ERROR)   return;
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String incompleteDir=set.getIncompleteDirectory();
  File myFile=new File(incompleteDir,_filename);
  String pathname=myFile.getAbsolutePath();
  File myTest=new File(_downloadDir,_filename);
  String path=myTest.getAbsolutePath();
  File f;
  String p;
  try {
    File shared=new File(_downloadDir);
    String shared_path=shared.getCanonicalPath();
    f=new File(myTest.getParent());
    p=f.getCanonicalPath();
    if (!p.equals(shared_path)) {
      _state=ERROR;
      return;
    }
  }
 catch (  Exception e) {
    _state=ERROR;
    return;
  }
  if (myTest.exists()) {
    if (!_callback.overwriteFile(_filename)) {
      _stateString=""String_Node_Str"";
      _state=ERROR;
      return;
    }
  }
  try {
    _fos=new FileOutputStream(pathname,_resume);
  }
 catch (  FileNotFoundException e) {
    _state=ERROR;
    return;
  }
catch (  Exception e) {
    _state=ERROR;
    return;
  }
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    if (_amountRead == _sizeOfFile) {
      _state=COMPLETE;
      break;
    }
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      _state=ERROR;
      return;
    }
    if (c == -1) {
      break;
    }
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      _state=ERROR;
      break;
    }
    _amountRead+=c;
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
    _state=ERROR;
    return;
  }
  if (_amountRead == _sizeOfFile) {
    String pname=_downloadDir + _filename;
    File target=new File(pname);
    target.delete();
    boolean ok=myFile.renameTo(target);
    if (!ok) {
      _state=ERROR;
      _stateString=""String_Node_Str"";
      return;
    }
    _state=COMPLETE;
    FileManager.getFileManager().addFileIfShared(pname);
  }
 else {
    _state=ERROR;
    _stateString=""String_Node_Str"";
  }
}",0.9774361517480784
5083,"/** 
 * Initialize the connection by doing the handshake.  Subclasses of connection should override this method and call super.initialize() in the first line of the override.
 */
public void initialize() throws IOException {
  SettingsManager settingsManager=SettingsManager.instance();
  String expectString;
  if (isOutgoing()) {
    _socket=new Socket(_host,_port);
    expectString=settingsManager.getConnectString();
  }
 else {
    expectString=settingsManager.getConnectStringRemainder();
  }
  if (_shutdownCalled) {
    _socket.close();
    throw new IOException();
  }
  try {
    _in=new BufferedInputStream(_socket.getInputStream());
    _out=new BufferedOutputStream(_socket.getOutputStream());
    sendString(expectString + ""String_Node_Str"");
    expectString(settingsManager.getConnectOkString() + ""String_Node_Str"");
  }
 catch (  IOException e) {
    _socket.close();
    throw e;
  }
}","/** 
 * Initialize the connection by doing the handshake.  Subclasses of connection should override this method and call super.initialize() in the first line of the override.
 */
public void initialize() throws IOException {
  SettingsManager settingsManager=SettingsManager.instance();
  String expectString;
  if (isOutgoing()) {
    _socket=new Socket(_host,_port);
    expectString=settingsManager.getConnectString();
  }
 else {
    expectString=settingsManager.getConnectStringRemainder();
  }
  if (_closed) {
    _socket.close();
    throw new IOException();
  }
  try {
    _in=new BufferedInputStream(_socket.getInputStream());
    _out=new BufferedOutputStream(_socket.getOutputStream());
    sendString(expectString + ""String_Node_Str"");
    expectString(settingsManager.getConnectOkString() + ""String_Node_Str"");
  }
 catch (  IOException e) {
    _socket.close();
    throw e;
  }
}",0.9911111111111112
5084,"/** 
 * Sends a message.
 * @requires this is fully constructed
 * @modifies the network underlying this
 * @effects send m on the network.  Throws IOException if problemsarise.  This is thread-safe.
 */
public void send(Message m) throws IOException {
synchronized (_out) {
    m.write(_out);
    _out.flush();
    _sent++;
  }
}","/** 
 * Sends a message.
 * @requires this is fully constructed
 * @modifies the network underlying this
 * @effects send m on the network.  Throws IOException if problemsarise.  This is thread-safe and guaranteed not to block.
 */
public void send(Message m) throws IOException {
  if (_closed)   throw new IOException();
synchronized (_outputQueueLock) {
    _sent++;
    if (_outputQueue.isFull()) {
      _sentDropped++;
      if (disposeable(m))       return;
      int i;
      for (i=_outputQueue.getSize() - 1; i >= 0; i--) {
        Message mi=(Message)_outputQueue.get(i);
        if (disposeable(mi))         break;
      }
      if (i >= 0)       _outputQueue.set(i,m);
 else       _outputQueue.addFirst(m);
    }
 else {
      _outputQueue.addFirst(m);
      if (_outputQueue.getSize() >= BATCH_SIZE)       _outputQueueLock.notify();
    }
  }
}",0.4932659932659932
5085,"/** 
 * Searches the given host for all its files.  Results are given to the GUI via handleQuery.  Returns null if the host couldn't be reached.  Blocks until the connection is established and the query is sent.
 */
public byte[] browse(String host,int port){
  Connection c=null;
  for (Iterator iter=manager.connections(); iter.hasNext(); ) {
    Connection c2=(Connection)iter.next();
    String ip=c2.getInetAddress().getHostAddress();
    if (ip.equals(host) && c2.getOrigPort() == port) {
      c=c2;
      break;
    }
  }
  if (c == null) {
    try {
      c=connectToHost(host,port);
    }
 catch (    IOException e) {
      return null;
    }
  }
  QueryRequest qr=new QueryRequest((byte)1,0,""String_Node_Str"");
  manager.fromMe(qr);
  try {
    c.send(qr);
  }
 catch (  IOException e) {
    return null;
  }
  if (manager.getNumConnections() > manager.getKeepAlive()) {
    ManagedConnection worst=null;
    long files=Long.MAX_VALUE;
    for (Iterator iter=manager.connections(); iter.hasNext(); ) {
      ManagedConnection c2=(ManagedConnection)iter.next();
      if (c2 == c)       continue;
      long n=c2.getNumFiles();
      if (n < files) {
        worst=c2;
        files=n;
      }
    }
    if (worst != null)     manager.remove(worst);
  }
  return qr.getGUID();
}","/** 
 * Searches the given host for all its files.  Results are given to the GUI via handleQuery.  Returns null if the host couldn't be reached.  Blocks until the connection is established and the query is sent.
 */
public byte[] browse(String host,int port){
  Connection c=null;
  for (Iterator iter=manager.initializedConnections(); iter.hasNext(); ) {
    Connection c2=(Connection)iter.next();
    String ip=c2.getInetAddress().getHostAddress();
    if (ip.equals(host) && c2.getOrigPort() == port) {
      c=c2;
      break;
    }
  }
  if (c == null) {
    try {
      c=connectToHost(host,port);
    }
 catch (    IOException e) {
      return null;
    }
  }
  QueryRequest qr=new QueryRequest((byte)1,0,""String_Node_Str"");
  manager.fromMe(qr);
  try {
    c.send(qr);
  }
 catch (  IOException e) {
    return null;
  }
  if (manager.getNumConnections() > manager.getKeepAlive()) {
    ManagedConnection worst=null;
    long files=Long.MAX_VALUE;
    for (Iterator iter=manager.connections(); iter.hasNext(); ) {
      ManagedConnection c2=(ManagedConnection)iter.next();
      if (c2 == c)       continue;
      long n=c2.getNumFiles();
      if (n < files) {
        worst=c2;
        files=n;
      }
    }
    if (worst != null)     manager.remove(worst);
  }
  return qr.getGUID();
}",0.9949748743718592
5086,"/** 
 * This method is called when a reply is received for a QueryRequest originating on this Connection.  So, just adjust the hops and send it back.  If the sending fails, the calls fails silently. Note that we delegate the sending to the MessageRouter so that it can properly set up a routing for PushRequest sent in reply to the QueryReply.  PushRequests are odd this way; they are QueryReplyReplies
 */
public void handleQueryReply(QueryReply queryReply,ManagedConnection receivingConnection,MessageRouter router,ActivityCallback callback){
  queryReply.hop();
  try {
    router.sendQueryReply(queryReply,this,receivingConnection);
  }
 catch (  IOException e) {
  }
}","/** 
 * This method is called when a reply is received for a QueryRequest originating on this Connection.  So, just adjust the hops and send it back.  If the sending fails, the calls fails silently.
 */
public void handleQueryReply(QueryReply queryReply,ManagedConnection receivingConnection,MessageRouter router,ActivityCallback callback){
  queryReply.hop();
  send(queryReply);
}",0.7165876777251184
5087,"/** 
 * Uses the query route table to route a query reply.  If an appropriate route doesn't exist, records the error statistics.  On sucessful routing, the QueryReply count is incremented.
 */
public void routeQueryReply(QueryReply queryReply,ManagedConnection receivingConnection){
  QueryReplyHandler replyHandler=(QueryReplyHandler)_queryRouteTable.getReplyHandler(queryReply.getGUID());
  if (replyHandler != null) {
    _numQueryReplies++;
    replyHandler.handleQueryReply(queryReply,receivingConnection,this,_callback);
  }
 else {
    _numRouteErrors++;
    receivingConnection.countDroppedMessage();
  }
}","/** 
 * Uses the query route table to route a query reply.  If an appropriate route doesn't exist, records the error statistics.  On sucessful routing, the QueryReply count is incremented, and a routing is created for subsequent PushRequests
 */
public void routeQueryReply(QueryReply queryReply,ManagedConnection receivingConnection){
  QueryReplyHandler replyHandler=(QueryReplyHandler)_queryRouteTable.getReplyHandler(queryReply.getGUID());
  if (replyHandler != null) {
    _numQueryReplies++;
    _pushRouteTable.routeReply(queryReply.getClientGUID(),receivingConnection);
    replyHandler.handleQueryReply(queryReply,receivingConnection,this,_callback);
  }
 else {
    _numRouteErrors++;
    receivingConnection.countDroppedMessage();
  }
}",0.9008082292432036
5088,"/** 
 * Sends the query reply to the designated connection, setting up the routing to the designated PushRequestHandler.
 */
public void sendQueryReply(QueryReply queryReply,ManagedConnection connection,PushRequestHandler replyHandler) throws IOException {
  _pushRouteTable.routeReply(queryReply.getClientGUID(),replyHandler);
  connection.send(queryReply);
}","/** 
 * Sends the query reply to the designated connection, setting up the routing to the MessageRouter's PushRequestHandler.
 */
public void sendQueryReply(QueryReply queryReply,ManagedConnection connection) throws IOException {
  _pushRouteTable.routeReply(queryReply.getClientGUID(),_pushRequestHandler);
  connection.send(queryReply);
}",0.8942857142857142
5089,"/** 
 * Creates a host catcher whose maybe set contains the hosts in the given file.  (The likelys set is empty.)  If filename does not exist, then no error message is printed and this is initially empty.  The file is expected to contain a sequence of lines in the format ""<host>:port\n"".  Lines not in this format are silently ignored.  manager is as described above.  
 */
public HostCatcher(ConnectionManager manager,String filename){
  this.manager=manager;
  BufferedReader in=null;
  try {
    in=new BufferedReader(new FileReader(filename));
  }
 catch (  FileNotFoundException e) {
    error(ActivityCallback.ERROR_10);
    return;
  }
  while (true) {
    String line=null;
    try {
      line=in.readLine();
    }
 catch (    IOException e) {
      return;
    }
    if (line == null)     break;
    int index=line.indexOf(':');
    if (index == -1) {
      continue;
    }
    String host=line.substring(0,index);
    int port=0;
    try {
      port=Integer.parseInt(line.substring(index + 1));
    }
 catch (    NumberFormatException e) {
      continue;
    }
catch (    ArrayIndexOutOfBoundsException e) {
      continue;
    }
    Endpoint e=new Endpoint(host,port);
    if (!set.contains(e)) {
      queue.add(0,e);
      set.add(e);
    }
  }
}","/** 
 * Creates a host catcher whose maybe set contains the hosts in the given file.  (The likelys set is empty.)  If filename does not exist, then no error message is printed and this is initially empty.  The file is expected to contain a sequence of lines in the format ""<host>:port\n"".  Lines not in this format are silently ignored.  manager is as described above.  
 */
public HostCatcher(ConnectionManager manager,String filename){
  this.manager=manager;
  BufferedReader in=null;
  try {
    in=new BufferedReader(new FileReader(filename));
  }
 catch (  FileNotFoundException e) {
    error(ActivityCallback.ERROR_10);
    return;
  }
  while (true) {
    String line=null;
    try {
      line=in.readLine();
    }
 catch (    IOException e) {
      return;
    }
    if (line == null)     break;
    int index=line.indexOf(':');
    if (index == -1) {
      continue;
    }
    String host=line.substring(0,index);
    int port=0;
    try {
      port=Integer.parseInt(line.substring(index + 1));
    }
 catch (    NumberFormatException e) {
      continue;
    }
catch (    ArrayIndexOutOfBoundsException e) {
      continue;
    }
    Endpoint e=new Endpoint(host,port);
    if ((!set.contains(e)) && (!isMe(host,port))) {
      queue.add(0,e);
      set.add(e);
    }
  }
}",0.9905882352941175
5090,"/** 
 * @modifies this
 * @effects returns a new outgoing, connected connection to somehost in this and removes it from this (atomically).  If manager is non-null,  it is (almost) guaranteed that we do not return any hosts we are connected to.   If no such host is found, blocks until a host is added.  If manager is non-null and this connection is no longer needed, returns null.  (Hack!) This method <i>is</i>  thread-safe, but it is cleverly synchronized so that multiple invocations can run  at the same time.  Note that an initial ping is no sent on the returned connection, nor is the connection added to manager.<p> Note: because this method interacts so tightly with ConnectionManager, it should probably be moved into ConnectionFetcher.run.  It is sufficient for HostCatcher to only provide the atomic chooseEndpoint method.
 */
public Connection choose(){
  while (true) {
    Endpoint e=null;
synchronized (this) {
      while (e == null) {
        if (manager != null && !manager.needsMoreConnections())         return null;
        try {
          e=getAnEndpoint();
        }
 catch (        NoSuchElementException exc) {
          try {
            this.wait(2000);
          }
 catch (          InterruptedException exc2) {
          }
        }
      }
    }
    if (manager != null && manager.isConnected(e))     continue;
    Connection ret=null;
    try {
      ret=new Connection(e.hostname,e.port);
      if (manager != null)       manager.tryingToConnect(ret,false);
      ret.connect();
      return ret;
    }
 catch (    IOException exc) {
      if (manager != null)       manager.failedToConnect(ret);
      continue;
    }
  }
}","/** 
 * @modifies this
 * @effects returns a new outgoing, connected connection to somehost in this and removes it from this (atomically).  If manager is non-null,  it is (almost) guaranteed that we do not return any hosts we are connected to.   If no such host is found, blocks until a host is added.  If manager is non-null and this connection is no longer needed, returns null.  (Hack!) This method <i>is</i>  thread-safe, but it is cleverly synchronized so that multiple invocations can run  at the same time.  Note that an initial ping is no sent on the returned connection, nor is the connection added to manager.<p> Note: because this method interacts so tightly with ConnectionManager, it should probably be moved into ConnectionFetcher.run.  It is sufficient for HostCatcher to only provide the atomic chooseEndpoint method.
 */
public Connection choose(){
  while (true) {
    Endpoint e=null;
synchronized (this) {
      while (e == null) {
        if (manager != null && !manager.needsMoreConnections())         return null;
        try {
          e=getAnEndpoint();
        }
 catch (        NoSuchElementException exc) {
          try {
            this.wait(2000);
          }
 catch (          InterruptedException exc2) {
          }
        }
      }
    }
    if (manager != null && manager.isConnected(e))     continue;
    Connection ret=null;
    try {
      ret=new Connection(e.hostname,e.port);
      if (manager != null) {
        manager.tryingToConnect(ret,false);
      }
      ret.connect();
      return ret;
    }
 catch (    IOException exc) {
      if (manager != null)       manager.failedToConnect(ret);
      continue;
    }
  }
}",0.9963898916967509
5091,"/** 
 * @modifies this
 * @effects may choose to add hosts listed in m to this
 */
public void spy(Message m){
  if (!(m instanceof PingReply))   return;
  PingReply pr=(PingReply)m;
  Endpoint e=new Endpoint(pr.getIP(),pr.getPort(),pr.getFiles(),pr.getKbytes());
  if (manager != null && manager.isConnected(e))   return;
synchronized (this) {
    if (!(set.contains(e))) {
      set.add(e);
      queue.add(e);
      this.notify();
    }
  }
  addKnownHost(e);
}","/** 
 * @modifies this
 * @effects may choose to add hosts listed in m to this
 */
public void spy(Message m){
  if (!(m instanceof PingReply))   return;
  PingReply pr=(PingReply)m;
  Endpoint e=new Endpoint(pr.getIP(),pr.getPort(),pr.getFiles(),pr.getKbytes());
  if (manager != null && manager.isConnected(e))   return;
  if (isMe(e.getHostname(),e.getPort()))   return;
synchronized (this) {
    if (!(set.contains(e))) {
      set.add(e);
      queue.add(e);
      this.notify();
    }
  }
  addKnownHost(e);
}",0.947906026557712
5092,"/** 
 * Connect to remote host (establish outgoing connection). Blocks until connection established.
 */
public void connectToHost(Connection c) throws IOException {
  try {
    manager.tryingToConnect(c,false);
    c.connect();
    c.setManager(manager);
    manager.add(c);
    PingRequest pr=new PingRequest(SettingsManager.instance().getTTL());
    manager.fromMe(pr);
    c.send(pr);
    Thread tc=new Thread(c);
    tc.setDaemon(true);
    tc.start();
  }
 catch (  IOException e) {
    manager.failedToConnect(c);
    throw e;
  }
}","/** 
 * Connect to remote host (establish outgoing connection). Blocks until connection established. If establishing c would connect us to the listening socket, the connection is not established.
 */
public void connectToHost(Connection c) throws IOException {
  try {
    byte[] cIP=InetAddress.getByName(c.getOrigHost()).getAddress();
    if (Arrays.equals(cIP,LOCALHOST)) {
      if (c.getOrigPort() == manager.getListeningPort())       throw new IOException();
    }
 else {
      byte[] managerIP=manager.getAddress();
      if (Arrays.equals(cIP,managerIP) && c.getOrigPort() == manager.getListeningPort())       throw new IOException();
    }
    manager.tryingToConnect(c,false);
    c.connect();
    c.setManager(manager);
    manager.add(c);
    PingRequest pr=new PingRequest(SettingsManager.instance().getTTL());
    manager.fromMe(pr);
    c.send(pr);
    Thread tc=new Thread(c);
    tc.setDaemon(true);
    tc.start();
  }
 catch (  IOException e) {
    manager.failedToConnect(c);
    throw e;
  }
}",0.2947232947232947
5093,"public void run(){
  if (_mode == 1) {
    if (_state != QUEUED)     _callback.addDownload(this);
    initOne();
  }
 else   if (_mode == 2) {
    if (_state != QUEUED)     _callback.addDownload(this);
    initTwo();
  }
 else   if (_mode == 3) {
    initThree();
  }
 else   return;
  if (_state == CONNECTED) {
    doDownload();
    _callback.removeDownload(this);
  }
}","public void run(){
  if (_mode == 1) {
    if (_state != QUEUED)     _callback.addDownload(this);
    initOne();
  }
 else   if (_mode == 2) {
    if (_state != QUEUED)     _callback.addDownload(this);
    initTwo();
  }
 else   if (_mode == 3) {
    initThree();
  }
 else   Assert.that(false,""String_Node_Str"");
  if (_state == CONNECTED) {
    doDownload();
    _callback.removeDownload(this);
  }
 else   if (_state == ERROR) {
    _callback.removeDownload(this);
  }
}",0.863905325443787
5094,"public void run(){
  if (_mode == 1) {
    if (_state != QUEUED)     _callback.addDownload(this);
    initOne();
  }
 else   if (_mode == 2) {
    if (_state != QUEUED)     _callback.addDownload(this);
    initTwo();
  }
 else   if (_mode == 3) {
    initThree();
  }
 else   return;
  if (_state == CONNECTED) {
    doDownload();
    _callback.removeDownload(this);
  }
}","public void run(){
  if (_mode == 1) {
    if (_state != QUEUED)     _callback.addDownload(this);
    initOne();
  }
 else   if (_mode == 2) {
    if (_state != QUEUED)     _callback.addDownload(this);
    initTwo();
  }
 else   if (_mode == 3) {
    initThree();
  }
 else   Assert.that(false,""String_Node_Str"");
  if (_state == CONNECTED) {
    doDownload();
    _callback.removeDownload(this);
  }
 else   if (_state == ERROR) {
    _callback.removeDownload(this);
  }
}",0.863905325443787
5095,"public synchronized void addDirectory(String dir_name){
  File myFile=new File(dir_name);
  if (!myFile.exists())   return;
  File[] file_list=myFile.listFiles();
  int n=file_list.length;
  for (int i=0; i < n; i++) {
    if (file_list[i].isDirectory())     addDirectory(file_list[i].getAbsolutePath());
 else     addFile(file_list[i].getAbsolutePath());
  }
}","public synchronized void addDirectory(String dir_name){
  File myFile=new File(dir_name);
  if (!myFile.exists())   return;
  File[] file_list=listFiles(myFile);
  int n=file_list.length;
  for (int i=0; i < n; i++) {
    if (file_list[i].isDirectory())     addDirectory(file_list[i].getAbsolutePath());
 else     addFile(file_list[i].getAbsolutePath());
  }
}",0.954230235783634
5096,"/** 
 * Handles core Gnutella request/reply protocol.
 * @requires this is in the CONNECTED state andthe manager to this has been set via setManager
 * @modifies the network underlying this, manager
 * @effects receives request and sends appropriate replies.Returns if either the connection is closed or an error happens. If this happens, removes itself from the manager's connection list.
 */
public void run(){
  Assert.that(sock != null && in != null && out != null,""String_Node_Str"");
  Assert.that(manager != null && routeTable != null && pushRouteTable != null,""String_Node_Str"");
  try {
    sock.setSoTimeout(SettingsManager.instance().getTimeout());
  }
 catch (  SocketException e) {
  }
  try {
    while (true) {
      Message m=null;
      try {
        m=receive();
        if (m == null)         continue;
      }
 catch (      BadPacketException e) {
        continue;
      }
      if (m instanceof PingRequest) {
        Connection inConnection=routeTable.get(m.getGUID());
        if (inConnection == null && !isRouteSpam(m)) {
          if (manager.stats == true)           manager.PReqCount++;
          if (m.hop() != 0) {
            routeTable.put(m.getGUID(),this);
            manager.sendToAllExcept(m,this);
            byte[] ip=sock.getLocalAddress().getAddress();
            FileManager fm=FileManager.getFileManager();
            int kilobytes=fm.getSize();
            int num_files=fm.getNumFiles();
            Message pingReply=new PingReply(m.getGUID(),(byte)(m.getHops() + 1),manager.getListeningPort(),ip,num_files,kilobytes);
            send(pingReply);
            if (manager.stats == true)             manager.PRepCount++;
          }
 else {
          }
        }
 else {
        }
      }
 else       if (m instanceof PingReply) {
        Connection outConnection=routeTable.get(m.getGUID());
        manager.catcher.spy(m);
        if (outConnection != null && routeFilter.allow(m)) {
          if (manager.stats == true)           manager.PRepCount++;
          if (outConnection.equals(manager.ME_CONNECTION)) {
            totalFileSize+=((PingReply)m).getKbytes();
            numFiles+=((PingReply)m).getFiles();
            numHosts++;
          }
 else {
            m.hop();
            outConnection.send(m);
          }
        }
 else {
          dropped++;
        }
      }
 else       if (m instanceof QueryRequest) {
        Connection inConnection=routeTable.get(m.getGUID());
        if (inConnection == null && !isRouteSpam(m)) {
          ActivityCallback ui=manager.getCallback();
          if (ui != null && personalFilter.allow(m))           ui.handleQueryString(((QueryRequest)m).getQuery());
          manager.QReqCount++;
          if (m.hop() != 0) {
            routeTable.put(m.getGUID(),this);
            manager.sendToAllExcept(m,this);
            FileManager fm=FileManager.getFileManager();
            Response[] responses=fm.query((QueryRequest)m);
            if (responses.length > 0) {
              byte[] guid=m.getGUID();
              byte ttl=(byte)(m.getHops() + 1);
              int port=manager.getListeningPort();
              byte[] ip=sock.getLocalAddress().getAddress();
              long speed=SettingsManager.instance().getConnectionSpeed();
              byte[] clientGUID=manager.ClientId.bytes();
              if (responses.length > 255) {
                Response[] res=new Response[255];
                for (int i=0; i < 255; i++)                 res[i]=responses[i];
                responses=res;
              }
              QueryReply qreply=new QueryReply(guid,ttl,port,ip,speed,responses,clientGUID);
              send(qreply);
              if (manager.stats == true)               manager.QRepCount++;
            }
          }
 else {
          }
        }
 else {
        }
      }
 else       if (m instanceof QueryReply) {
        Connection outConnection=routeTable.get(m.getGUID());
        if (outConnection != null && routeFilter.allow(m)) {
          if (manager.stats == true)           manager.QRepCount++;
          QueryReply qrep=(QueryReply)m;
          pushRouteTable.put(qrep.getClientGUID(),this);
          if (outConnection.equals(manager.ME_CONNECTION)) {
            ActivityCallback ui=manager.getCallback();
            if (ui != null && personalFilter.allow(m))             ui.handleQueryReply((QueryReply)m);
          }
 else {
            m.hop();
            outConnection.send(m);
          }
        }
 else {
          dropped++;
        }
      }
 else       if (m instanceof PushRequest) {
        if (manager.stats == true)         manager.pushCount++;
        PushRequest req=(PushRequest)m;
        byte[] req_guid=req.getClientGUID();
        String req_guid_hexstring=(new GUID(req_guid)).toString();
        Connection nextHost=pushRouteTable.get(req_guid);
        if (nextHost != null && routeFilter.allow(m)) {
          m.hop();
          nextHost.send(m);
        }
 else         if (manager.isClient(req_guid)) {
          String host=new String(req.getIP());
          byte[] ip=req.getIP();
          StringBuffer buf=new StringBuffer();
          buf.append(ByteOrder.ubyte2int(ip[0]) + ""String_Node_Str"");
          buf.append(ByteOrder.ubyte2int(ip[1]) + ""String_Node_Str"");
          buf.append(ByteOrder.ubyte2int(ip[2]) + ""String_Node_Str"");
          buf.append(ByteOrder.ubyte2int(ip[3]) + ""String_Node_Str"");
          String h=buf.toString();
          int port=req.getPort();
          FileManager fmanager=FileManager.getFileManager();
          int index=(int)req.getIndex();
          FileDesc desc;
          try {
            desc=(FileDesc)fmanager._files.get(index);
          }
 catch (          ArrayIndexOutOfBoundsException e) {
            return;
          }
          String file=desc._name;
          HTTPUploader up=new HTTPUploader(h,port,index,req_guid_hexstring,manager);
          Thread t=new Thread(up);
          t.setDaemon(true);
          t.run();
        }
 else {
          dropped++;
        }
      }
    }
  }
 catch (  IOException e) {
    manager.remove(this);
  }
}","/** 
 * Handles core Gnutella request/reply protocol.
 * @requires this is in the CONNECTED state andthe manager to this has been set via setManager
 * @modifies the network underlying this, manager
 * @effects receives request and sends appropriate replies.Returns if either the connection is closed or an error happens. If this happens, removes itself from the manager's connection list.
 */
public void run(){
  Assert.that(sock != null && in != null && out != null,""String_Node_Str"");
  Assert.that(manager != null && routeTable != null && pushRouteTable != null,""String_Node_Str"");
  try {
    sock.setSoTimeout(SettingsManager.instance().getTimeout());
  }
 catch (  SocketException e) {
  }
  try {
    while (true) {
      Message m=null;
      try {
        m=receive();
        if (m == null)         continue;
      }
 catch (      BadPacketException e) {
        continue;
      }
      if (m instanceof PingRequest) {
        Connection inConnection=routeTable.get(m.getGUID());
        if (inConnection == null && !isRouteSpam(m)) {
          if (manager.stats == true)           manager.PReqCount++;
          if (m.hop() != 0) {
            routeTable.put(m.getGUID(),this);
            manager.sendToAllExcept(m,this);
            byte[] ip=sock.getLocalAddress().getAddress();
            FileManager fm=FileManager.getFileManager();
            int kilobytes=fm.getSize();
            int num_files=fm.getNumFiles();
            Message pingReply=new PingReply(m.getGUID(),(byte)(m.getHops() + 1),manager.getListeningPort(),ip,num_files,kilobytes);
            send(pingReply);
            if (manager.stats == true)             manager.PRepCount++;
          }
 else {
          }
        }
 else {
        }
      }
 else       if (m instanceof PingReply) {
        Connection outConnection=routeTable.get(m.getGUID());
        manager.catcher.spy(m);
        if (outConnection != null && routeFilter.allow(m)) {
          if (manager.stats == true)           manager.PRepCount++;
          if (outConnection.equals(manager.ME_CONNECTION)) {
            totalFileSize+=((PingReply)m).getKbytes();
            numFiles+=((PingReply)m).getFiles();
            numHosts++;
          }
 else {
            m.hop();
            outConnection.send(m);
          }
        }
 else {
          dropped++;
        }
      }
 else       if (m instanceof QueryRequest) {
        Connection inConnection=routeTable.get(m.getGUID());
        if (inConnection == null && !isRouteSpam(m)) {
          ActivityCallback ui=manager.getCallback();
          if (ui != null && personalFilter.allow(m))           ui.handleQueryString(((QueryRequest)m).getQuery());
          manager.QReqCount++;
          if (m.hop() != 0) {
            routeTable.put(m.getGUID(),this);
            manager.sendToAllExcept(m,this);
            FileManager fm=FileManager.getFileManager();
            Response[] responses=fm.query((QueryRequest)m);
            if (responses.length > 0) {
              byte[] guid=m.getGUID();
              byte ttl=(byte)(m.getHops() + 1);
              int port=manager.getListeningPort();
              byte[] ip=sock.getLocalAddress().getAddress();
              long speed=SettingsManager.instance().getConnectionSpeed();
              byte[] clientGUID=manager.ClientId.bytes();
              if (responses.length > 255) {
                Response[] res=new Response[255];
                for (int i=0; i < 255; i++)                 res[i]=responses[i];
                responses=res;
              }
              QueryReply qreply=new QueryReply(guid,ttl,port,ip,speed,responses,clientGUID);
              send(qreply);
              if (manager.stats == true)               manager.QRepCount++;
            }
          }
 else {
          }
        }
 else {
        }
      }
 else       if (m instanceof QueryReply) {
        Connection outConnection=routeTable.get(m.getGUID());
        if (outConnection != null && routeFilter.allow(m)) {
          if (manager.stats == true)           manager.QRepCount++;
          QueryReply qrep=(QueryReply)m;
          pushRouteTable.put(qrep.getClientGUID(),this);
          if (outConnection.equals(manager.ME_CONNECTION)) {
            ActivityCallback ui=manager.getCallback();
            if (ui != null && personalFilter.allow(m))             ui.handleQueryReply((QueryReply)m);
          }
 else {
            m.hop();
            outConnection.send(m);
          }
        }
 else {
          dropped++;
        }
      }
 else       if (m instanceof PushRequest) {
        if (manager.stats == true)         manager.pushCount++;
        PushRequest req=(PushRequest)m;
        byte[] req_guid=req.getClientGUID();
        String req_guid_hexstring=(new GUID(req_guid)).toString();
        Connection nextHost=pushRouteTable.get(req_guid);
        if (nextHost != null && routeFilter.allow(m)) {
          m.hop();
          nextHost.send(m);
        }
 else         if (manager.isClient(req_guid)) {
          String host=new String(req.getIP());
          byte[] ip=req.getIP();
          StringBuffer buf=new StringBuffer();
          buf.append(ByteOrder.ubyte2int(ip[0]) + ""String_Node_Str"");
          buf.append(ByteOrder.ubyte2int(ip[1]) + ""String_Node_Str"");
          buf.append(ByteOrder.ubyte2int(ip[2]) + ""String_Node_Str"");
          buf.append(ByteOrder.ubyte2int(ip[3]) + ""String_Node_Str"");
          String h=buf.toString();
          int port=req.getPort();
          FileManager fmanager=FileManager.getFileManager();
          int index=(int)req.getIndex();
          FileDesc desc;
          try {
            desc=(FileDesc)fmanager._files.get(index);
          }
 catch (          Exception e) {
            continue;
          }
          String file=desc._name;
          HTTPUploader up=new HTTPUploader(h,port,index,req_guid_hexstring,manager);
          Thread t=new Thread(up);
          t.setDaemon(true);
          t.run();
        }
 else {
          dropped++;
        }
      }
    }
  }
 catch (  IOException e) {
    manager.remove(this);
  }
}",0.9971172061609422
5097,"public void initThree(){
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String pathname=_downloadDir + _filename;
  File myFile=new File(pathname);
  if (!myFile.exists()) {
    _state=ERROR;
    return;
  }
  URLConnection conn;
  String furl=""String_Node_Str"" + String.valueOf(_index) + ""String_Node_Str""+ _filename;
  long start=myFile.length() + 1;
  String startRange=java.lang.String.valueOf(start);
  try {
    URL url=new URL(_protocol,_host,_port,furl);
    conn=url.openConnection();
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + startRange + ""String_Node_Str"");
    conn.connect();
    _istream=conn.getInputStream();
    _br=new ByteReader(_istream);
  }
 catch (  Exception e) {
    _state=ERROR;
    return;
  }
  _resume=true;
  _state=CONNECTED;
}","public void initThree(){
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String pathname=_downloadDir + _filename;
  File myFile=new File(pathname);
  if (!myFile.exists()) {
    _state=ERROR;
    return;
  }
  URLConnection conn;
  String furl=""String_Node_Str"" + String.valueOf(_index) + ""String_Node_Str""+ _filename;
  long start=myFile.length();
  String startRange=java.lang.String.valueOf(start);
  try {
    URL url=new URL(_protocol,_host,_port,furl);
    conn=url.openConnection();
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + startRange + ""String_Node_Str"");
    conn.connect();
    _istream=conn.getInputStream();
    _br=new ByteReader(_istream);
  }
 catch (  Exception e) {
    _state=ERROR;
    return;
  }
  _resume=true;
  _state=CONNECTED;
}",0.9975757575757576
5098,"public void doUpload() throws IOException {
  writeHeader();
  int c=-1;
  int available=0;
  byte[] buf=new byte[1024];
  int skip=0;
  if (_uploadBegin != 0)   skip=_uploadBegin - 1;
  _fis.skip(skip);
  while (true) {
    try {
      if ((_uploadEnd != 0) && (_uploadEnd == _amountRead))       break;
      c=_fis.read(buf);
    }
 catch (    IOException e) {
      throw e;
    }
    if (c == -1)     break;
    try {
      _ostream.write(buf,0,c);
    }
 catch (    IOException e) {
      throw e;
    }
    _amountRead+=c;
  }
  try {
    _ostream.close();
  }
 catch (  IOException e) {
    throw e;
  }
  _state=COMPLETE;
}","public void doUpload() throws IOException {
  writeHeader();
  int c=-1;
  int available=0;
  byte[] buf=new byte[1024];
  _fis.skip(_uploadBegin);
  while (true) {
    try {
      if ((_uploadEnd != 0) && (_uploadEnd == _amountRead))       break;
      c=_fis.read(buf);
    }
 catch (    IOException e) {
      throw e;
    }
    if (c == -1)     break;
    try {
      _ostream.write(buf,0,c);
    }
 catch (    IOException e) {
      throw e;
    }
    _amountRead+=c;
  }
  try {
    _ostream.close();
  }
 catch (  IOException e) {
    throw e;
  }
  _state=COMPLETE;
}",0.945273631840796
5099,"public void initThree(){
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String pathname=_downloadDir + _filename;
  File myFile=new File(pathname);
  if (!myFile.exists()) {
    _state=ERROR;
    return;
  }
  URLConnection conn;
  String furl=""String_Node_Str"" + String.valueOf(_index) + ""String_Node_Str""+ _filename;
  long start=myFile.length() + 1;
  String startRange=java.lang.String.valueOf(start);
  try {
    URL url=new URL(_protocol,_host,_port,furl);
    conn=url.openConnection();
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + startRange + ""String_Node_Str"");
    conn.connect();
    _istream=conn.getInputStream();
    _br=new ByteReader(_istream);
  }
 catch (  Exception e) {
    _state=ERROR;
    return;
  }
  _resume=true;
  _state=CONNECTED;
}","public void initThree(){
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String pathname=_downloadDir + _filename;
  File myFile=new File(pathname);
  if (!myFile.exists()) {
    _state=ERROR;
    return;
  }
  URLConnection conn;
  String furl=""String_Node_Str"" + String.valueOf(_index) + ""String_Node_Str""+ _filename;
  long start=myFile.length();
  String startRange=java.lang.String.valueOf(start);
  try {
    URL url=new URL(_protocol,_host,_port,furl);
    conn=url.openConnection();
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + startRange + ""String_Node_Str"");
    conn.connect();
    _istream=conn.getInputStream();
    _br=new ByteReader(_istream);
  }
 catch (  Exception e) {
    _state=ERROR;
    return;
  }
  _resume=true;
  _state=CONNECTED;
}",0.9975757575757576
5100,"public void doUpload() throws IOException {
  writeHeader();
  int c=-1;
  int available=0;
  byte[] buf=new byte[1024];
  int skip=0;
  if (_uploadBegin != 0)   skip=_uploadBegin - 1;
  _fis.skip(skip);
  while (true) {
    try {
      if ((_uploadEnd != 0) && (_uploadEnd == _amountRead))       break;
      c=_fis.read(buf);
    }
 catch (    IOException e) {
      throw e;
    }
    if (c == -1)     break;
    try {
      _ostream.write(buf,0,c);
    }
 catch (    IOException e) {
      throw e;
    }
    _amountRead+=c;
  }
  try {
    _ostream.close();
  }
 catch (  IOException e) {
    throw e;
  }
  _state=COMPLETE;
}","public void doUpload() throws IOException {
  writeHeader();
  int c=-1;
  int available=0;
  byte[] buf=new byte[1024];
  _fis.skip(_uploadBegin);
  while (true) {
    try {
      if ((_uploadEnd != 0) && (_uploadEnd == _amountRead))       break;
      c=_fis.read(buf);
    }
 catch (    IOException e) {
      throw e;
    }
    if (c == -1)     break;
    try {
      _ostream.write(buf,0,c);
    }
 catch (    IOException e) {
      throw e;
    }
    _amountRead+=c;
  }
  try {
    _ostream.close();
  }
 catch (  IOException e) {
    throw e;
  }
  _state=COMPLETE;
}",0.945273631840796
5101,"public void readHeader(){
  String str=""String_Node_Str"";
  boolean foundLength=false;
  boolean foundRangeInitial=false;
  boolean foundRangeFinal=false;
  while (!str.equals(""String_Node_Str"")) {
    str=_br.readLine();
    if (str.indexOf(""String_Node_Str"") != -1) {
      String sub;
      try {
        sub=str.substring(15);
      }
 catch (      IndexOutOfBoundsException e) {
        _state=ERROR;
        return;
      }
      sub=sub.trim();
      try {
        _sizeOfFile=java.lang.Integer.parseInt(sub);
      }
 catch (      NumberFormatException e) {
        _state=ERROR;
        return;
      }
      foundLength=true;
      ;
    }
    if (str.indexOf(""String_Node_Str"") != -1) {
      _resume=true;
    }
  }
  if (!foundLength) {
    _state=ERROR;
  }
}","public void readHeader(){
  String str=""String_Node_Str"";
  boolean foundLength=false;
  boolean foundRangeInitial=false;
  boolean foundRangeFinal=false;
  while (true) {
    try {
      str=_br.readLine();
    }
 catch (    IOException e) {
      _state=ERROR;
      return;
    }
    if (str == null || str.equals(""String_Node_Str""))     break;
    if (str.indexOf(""String_Node_Str"") != -1) {
      String sub;
      try {
        sub=str.substring(15);
      }
 catch (      IndexOutOfBoundsException e) {
        _state=ERROR;
        return;
      }
      sub=sub.trim();
      try {
        _sizeOfFile=java.lang.Integer.parseInt(sub);
      }
 catch (      NumberFormatException e) {
        _state=ERROR;
        return;
      }
      foundLength=true;
      ;
    }
    if (str.indexOf(""String_Node_Str"") != -1) {
      _resume=true;
    }
  }
  if (!foundLength) {
    _state=ERROR;
  }
}",0.8923444976076556
5102,"public boolean equals(Object o){
  if (!(o instanceof PushRequestedFile))   return false;
  PushRequestedFile prf=(PushRequestedFile)o;
  return Arrays.equals(clientGUID,prf.clientGUID) && filename.equals(prf.filename) && Arrays.equals(ip,prf.ip)&& index == prf.index;
}","public boolean equals(Object o){
  if (!(o instanceof PushRequestedFile))   return false;
  PushRequestedFile prf=(PushRequestedFile)o;
  return Arrays.equals(clientGUID,prf.clientGUID) && filename.equals(prf.filename) && index == prf.index;
}",0.9473684210526316
5103,"public void readHeader(){
  String str=""String_Node_Str"";
  boolean foundLength=false;
  boolean foundRangeInitial=false;
  boolean foundRangeFinal=false;
  while (!str.equals(""String_Node_Str"")) {
    str=_br.readLine();
    if (str.indexOf(""String_Node_Str"") != -1) {
      String sub;
      try {
        sub=str.substring(15);
      }
 catch (      IndexOutOfBoundsException e) {
        _state=ERROR;
        return;
      }
      sub=sub.trim();
      try {
        _sizeOfFile=java.lang.Integer.parseInt(sub);
      }
 catch (      NumberFormatException e) {
        _state=ERROR;
        return;
      }
      foundLength=true;
      ;
    }
    if (str.indexOf(""String_Node_Str"") != -1) {
      _resume=true;
    }
  }
  if (!foundLength) {
    _state=ERROR;
  }
}","public void readHeader(){
  String str=""String_Node_Str"";
  boolean foundLength=false;
  boolean foundRangeInitial=false;
  boolean foundRangeFinal=false;
  while (true) {
    try {
      str=_br.readLine();
    }
 catch (    IOException e) {
      _state=ERROR;
      return;
    }
    if (str == null || str.equals(""String_Node_Str""))     break;
    if (str.indexOf(""String_Node_Str"") != -1) {
      String sub;
      try {
        sub=str.substring(15);
      }
 catch (      IndexOutOfBoundsException e) {
        _state=ERROR;
        return;
      }
      sub=sub.trim();
      try {
        _sizeOfFile=java.lang.Integer.parseInt(sub);
      }
 catch (      NumberFormatException e) {
        _state=ERROR;
        return;
      }
      foundLength=true;
      ;
    }
    if (str.indexOf(""String_Node_Str"") != -1) {
      _resume=true;
    }
  }
  if (!foundLength) {
    _state=ERROR;
  }
}",0.8923444976076556
5104,"public boolean equals(Object o){
  if (!(o instanceof PushRequestedFile))   return false;
  PushRequestedFile prf=(PushRequestedFile)o;
  return Arrays.equals(clientGUID,prf.clientGUID) && filename.equals(prf.filename) && Arrays.equals(ip,prf.ip)&& index == prf.index;
}","public boolean equals(Object o){
  if (!(o instanceof PushRequestedFile))   return false;
  PushRequestedFile prf=(PushRequestedFile)o;
  return Arrays.equals(clientGUID,prf.clientGUID) && filename.equals(prf.filename) && index == prf.index;
}",0.9473684210526316
5105,"public void readHeader(){
  String str=null;
  int flag=0;
  while (true) {
    str=_br.readLine();
    if (str.indexOf(""String_Node_Str"") != -1) {
      String sub;
      try {
        sub=str.substring(15);
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        _state=ERROR;
        return;
      }
      sub.trim();
      try {
        _sizeOfFile=java.lang.Integer.parseInt(sub);
      }
 catch (      NumberFormatException e) {
        _state=ERROR;
        return;
      }
      flag=1;
      str=_br.readLine();
      break;
    }
  }
  if (flag == 0) {
    _state=ERROR;
  }
}","public void readHeader(){
  String str=null;
  int flag=0;
  while (true) {
    str=_br.readLine();
    if (str.indexOf(""String_Node_Str"") != -1) {
      String sub;
      try {
        sub=str.substring(15);
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        _state=ERROR;
        return;
      }
      sub=sub.trim();
      try {
        _sizeOfFile=java.lang.Integer.parseInt(sub);
      }
 catch (      NumberFormatException e) {
        _state=ERROR;
        return;
      }
      flag=1;
      str=_br.readLine();
      break;
    }
  }
  if (flag == 0) {
    _state=ERROR;
  }
}",0.9966555183946488
5106,"public void readHeader(){
  String str=null;
  int flag=0;
  while (true) {
    str=_br.readLine();
    if (str.indexOf(""String_Node_Str"") != -1) {
      String sub;
      try {
        sub=str.substring(15);
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        _state=ERROR;
        return;
      }
      sub.trim();
      try {
        _sizeOfFile=java.lang.Integer.parseInt(sub);
      }
 catch (      NumberFormatException e) {
        _state=ERROR;
        return;
      }
      flag=1;
      str=_br.readLine();
      break;
    }
  }
  if (flag == 0) {
    _state=ERROR;
  }
}","public void readHeader(){
  String str=null;
  int flag=0;
  while (true) {
    str=_br.readLine();
    if (str.indexOf(""String_Node_Str"") != -1) {
      String sub;
      try {
        sub=str.substring(15);
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        _state=ERROR;
        return;
      }
      sub=sub.trim();
      try {
        _sizeOfFile=java.lang.Integer.parseInt(sub);
      }
 catch (      NumberFormatException e) {
        _state=ERROR;
        return;
      }
      flag=1;
      str=_br.readLine();
      break;
    }
  }
  if (flag == 0) {
    _state=ERROR;
  }
}",0.9966555183946488
5107,"/** 
 * Create a hex version of a GUID for compact display and storage Note that the client guid should be read in with the  Integer.parseByte(String s, int radix)  call like this in reverse
 */
public String toHexString(){
  StringBuffer buf=new StringBuffer();
  String str;
  int val;
  for (int i=0; i < SZ; i+=4) {
    val=bytes[i];
    val=(val * 256) + bytes[i + 1];
    val=(val * 256) + bytes[i + 2];
    val=(val * 256) + bytes[i + 3];
    str=Integer.toHexString(val);
    while (str.length() < 8)     str=""String_Node_Str"" + str;
    buf.append(str);
  }
  return buf.toString();
}","/** 
 * Create a hex version of a GUID for compact display and storage Note that the client guid should be read in with the  Integer.parseByte(String s, int radix)  call like this in reverse
 */
public String toHexString(){
  StringBuffer buf=new StringBuffer();
  String str;
  int val;
  for (int i=0; i < SZ; i++) {
    val=ByteOrder.ubyte2int(bytes[i]);
    str=Integer.toHexString(val);
    while (str.length() < 2)     str=""String_Node_Str"" + str;
    buf.append(str);
  }
  return buf.toString();
}",0.8561020036429873
5108,"/** 
 * Create a GUID bytes from a hex string version.
 */
public static byte[] fromHexString(String sguid){
  byte bytes[]=new byte[SZ];
  for (int i=0; i < SZ; i++) {
    bytes[i]=Byte.parseByte(sguid.substring(i * 2,i * 2 + 1),16);
  }
  return bytes;
}","/** 
 * Create a GUID bytes from a hex string version. Throws IllegalArgumentException if sguid is not of the proper format.
 */
public static byte[] fromHexString(String sguid) throws IllegalArgumentException {
  byte bytes[]=new byte[SZ];
  try {
    for (int i=0; i < SZ; i++) {
      bytes[i]=(byte)Integer.parseInt(sguid.substring(i * 2,(i * 2) + 2),16);
    }
    return bytes;
  }
 catch (  NumberFormatException e) {
    throw new IllegalArgumentException();
  }
catch (  IndexOutOfBoundsException e) {
    throw new IllegalArgumentException();
  }
}",0.5724815724815725
5109,"public String readLine(){
  if (_istream == null)   return ""String_Node_Str"";
  String finalString=""String_Node_Str"";
  byte[] buf=new byte[BUFSIZE];
  int c=-1;
  int b=-1;
  int i=0;
  int numBytes=0;
  boolean endOfLine=false;
  String cr=""String_Node_Str"";
  byte[] creturn=cr.getBytes();
  String nl=""String_Node_Str"";
  byte[] nline=nl.getBytes();
  while (!endOfLine) {
    try {
      c=_istream.read();
    }
 catch (    IOException e) {
    }
    if (c == -1)     break;
    if (c == creturn[0]) {
      try {
        b=_istream.read();
      }
 catch (      IOException e) {
      }
      if (b == -1)       break;
      if (b == nline[0])       endOfLine=true;
 else {
        buf[i++]=(byte)c;
        buf[i++]=(byte)b;
        numBytes+=2;
      }
    }
 else {
      buf[i++]=(byte)c;
      numBytes++;
    }
    if (numBytes == BUFSIZE) {
      finalString+=new String(buf,0,numBytes);
      i=0;
      numBytes=0;
    }
  }
  finalString+=new String(buf,0,numBytes);
  return finalString;
}","public String readLine(){
  if (_istream == null)   return ""String_Node_Str"";
  String finalString=""String_Node_Str"";
  byte[] buf=new byte[BUFSIZE];
  int c=-1;
  int b=-1;
  int i=0;
  int numBytes=0;
  String cr=""String_Node_Str"";
  byte[] creturn=cr.getBytes();
  String nl=""String_Node_Str"";
  byte[] nline=nl.getBytes();
  while (true) {
    try {
      c=_istream.read();
    }
 catch (    IOException e) {
    }
    if (c == -1)     break;
    if (c == creturn[0]) {
      try {
        b=_istream.read();
      }
 catch (      IOException e) {
      }
      if (b == -1)       break;
      if (b == nline[0])       break;
 else {
        buf[i++]=(byte)c;
        buf[i++]=(byte)b;
        numBytes+=2;
      }
    }
 else {
      buf[i++]=(byte)c;
      numBytes++;
    }
    if (numBytes == BUFSIZE) {
      finalString+=new String(buf,0,numBytes);
      i=0;
      numBytes=0;
    }
  }
  finalString+=new String(buf,0,numBytes);
  return finalString;
}",0.9705882352941176
5110,"public void doDownload(){
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String pathname=_downloadDir + _filename;
  System.out.println(pathname);
  try {
    _fos=new FileOutputStream(pathname);
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
  readHeader();
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      System.out.print(""String_Node_Str"");
    }
    if (c == -1)     break;
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      System.out.print(""String_Node_Str"");
    }
    _amountRead+=c;
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
  }
}","public void doDownload(){
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String fs=System.getProperty(""String_Node_Str"");
  String pathname=_downloadDir + fs + _filename;
  System.out.println(pathname);
  try {
    _fos=new FileOutputStream(pathname);
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
  readHeader();
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      System.out.print(""String_Node_Str"");
    }
    if (c == -1)     break;
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      System.out.print(""String_Node_Str"");
    }
    _amountRead+=c;
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
  }
}",0.968574635241302
5111,"public void doDownload(){
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String pathname=_downloadDir + _filename;
  System.out.println(pathname);
  try {
    _fos=new FileOutputStream(pathname);
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
  readHeader();
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      System.out.print(""String_Node_Str"");
    }
    if (c == -1)     break;
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      System.out.print(""String_Node_Str"");
    }
    _amountRead+=c;
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
  }
}","public void doDownload(){
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String fs=System.getProperty(""String_Node_Str"");
  String pathname=_downloadDir + fs + _filename;
  System.out.println(pathname);
  try {
    _fos=new FileOutputStream(pathname);
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
  readHeader();
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      System.out.print(""String_Node_Str"");
    }
    if (c == -1)     break;
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      System.out.print(""String_Node_Str"");
    }
    _amountRead+=c;
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
  }
}",0.968574635241302
5112,"public int read(byte[] buf){
  int c=-1;
  if (_istream == null)   return c;
  try {
    c=_istream.read(buf);
    System.out.print(c + ""String_Node_Str"");
  }
 catch (  IOException e) {
  }
  return c;
}","public int read(byte[] buf){
  int c=-1;
  if (_istream == null)   return c;
  try {
    c=_istream.read(buf);
  }
 catch (  IOException e) {
  }
  return c;
}",0.8760330578512396
5113,"public String readLine(){
  if (_istream == null)   return ""String_Node_Str"";
  String finalString=""String_Node_Str"";
  byte[] buf=new byte[BUFSIZE];
  int c=-1;
  int b=-1;
  int i=0;
  int numBytes=0;
  String cr=""String_Node_Str"";
  byte[] creturn=cr.getBytes();
  String nl=""String_Node_Str"";
  byte[] nline=nl.getBytes();
  while (true) {
    try {
      c=_istream.read();
    }
 catch (    IOException e) {
    }
    if (c == -1)     break;
    if (c == creturn[0]) {
      try {
        b=_istream.read();
      }
 catch (      IOException e) {
      }
      if (b == -1)       break;
      if (b == nline[0])       break;
 else {
        buf[i++]=(byte)c;
        buf[i++]=(byte)b;
        numBytes+=2;
      }
    }
 else {
      buf[i++]=(byte)c;
      numBytes++;
    }
    if (numBytes == BUFSIZE) {
      finalString+=new String(buf,0,numBytes);
      i=0;
      numBytes=0;
    }
  }
  finalString+=new String(buf,0,numBytes);
  return finalString;
}","public String readLine(){
  if (_istream == null)   return ""String_Node_Str"";
  String finalString=""String_Node_Str"";
  byte[] buf=new byte[BUFSIZE];
  int c=-1;
  int b=-1;
  int i=0;
  int numBytes=0;
  String cr=""String_Node_Str"";
  byte[] creturn=cr.getBytes();
  String nl=""String_Node_Str"";
  byte[] nline=nl.getBytes();
  while (true) {
    try {
      c=_istream.read();
    }
 catch (    IOException e) {
    }
    if (c == -1)     break;
    if (c == creturn[0]) {
      try {
        b=_istream.read();
      }
 catch (      IOException e) {
      }
      if (b == -1)       break;
      if (b == nline[0])       break;
 else {
      }
    }
 else {
      buf[i++]=(byte)c;
      numBytes++;
    }
    if (numBytes == BUFSIZE) {
      finalString+=new String(buf,0,numBytes);
      i=0;
      numBytes=0;
    }
  }
  finalString+=new String(buf,0,numBytes);
  return finalString;
}",0.9391491653204092
5114,"public HTTPDownloader(String protocal,String host,int port,int index,String file,ConnectionManager m,byte[] guid){
  _filename=file;
  _amountRead=0;
  _sizeOfFile=-1;
  _socket=null;
  _manager=m;
  _callback=_manager.getCallback();
  _downloadDir=""String_Node_Str"";
  URLConnection conn;
  String furl=""String_Node_Str"" + String.valueOf(index) + ""String_Node_Str""+ file;
  try {
    URL url=new URL(protocal,host,port,furl);
    conn=url.openConnection();
  }
 catch (  java.net.MalformedURLException e) {
    sendPushRequest(host,index,port,guid);
    _callback.error(ActivityCallback.ERROR_5);
    return;
  }
catch (  IOException e) {
    sendPushRequest(host,index,port,guid);
    _callback.error(ActivityCallback.ERROR_6);
    return;
  }
  try {
    _istream=conn.getInputStream();
    _br=new ByteReader(_istream);
  }
 catch (  NoRouteToHostException e) {
    System.out.println(""String_Node_Str"");
    _callback.error(ActivityCallback.ERROR_13);
    return;
  }
catch (  IOException e) {
    e.printStackTrace();
    sendPushRequest(host,index,port,guid);
    return;
  }
}","public HTTPDownloader(String protocal,String host,int port,int index,String file,ConnectionManager m,byte[] guid){
  _okay=false;
  _filename=file;
  _amountRead=0;
  _sizeOfFile=-1;
  _socket=null;
  _manager=m;
  _callback=_manager.getCallback();
  _downloadDir=""String_Node_Str"";
  URLConnection conn;
  String furl=""String_Node_Str"" + String.valueOf(index) + ""String_Node_Str""+ file;
  try {
    URL url=new URL(protocal,host,port,furl);
    conn=url.openConnection();
  }
 catch (  java.net.MalformedURLException e) {
    sendPushRequest(host,index,port,guid);
    _callback.error(ActivityCallback.ERROR_5);
    return;
  }
catch (  IOException e) {
    sendPushRequest(host,index,port,guid);
    _callback.error(ActivityCallback.ERROR_6);
    return;
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  try {
    _istream=conn.getInputStream();
    _br=new ByteReader(_istream);
  }
 catch (  NoRouteToHostException e) {
    System.out.println(""String_Node_Str"");
    _callback.error(ActivityCallback.ERROR_13);
    return;
  }
catch (  IOException e) {
    e.printStackTrace();
    sendPushRequest(host,index,port,guid);
    return;
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  _okay=true;
}",0.8984666390385412
5115,"public void doDownload(){
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String pathname=_downloadDir + _filename;
  System.out.println(pathname);
  try {
    _fos=new FileOutputStream(pathname);
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
  readHeader();
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      System.out.print(""String_Node_Str"");
    }
    if (c == -1)     break;
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      System.out.print(""String_Node_Str"");
    }
    _amountRead+=c;
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
  }
}","public void doDownload(){
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String pathname=_downloadDir + _filename;
  System.out.println(pathname);
  try {
    _fos=new FileOutputStream(pathname);
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
  readHeader();
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"");
      return;
    }
    if (c == -1)     break;
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      e.printStackTrace();
      return;
    }
    _amountRead+=c;
    System.out.println(""String_Node_Str"" + _amountRead);
    System.out.println(""String_Node_Str"" + _sizeOfFile);
    double percent=_amountRead / _sizeOfFile;
    System.out.println(""String_Node_Str"" + percent);
    System.out.println(""String_Node_Str"");
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
  }
}",0.8099483810417645
5116,"public void run(){
  _callback.addDownload(this);
  doDownload();
  _callback.removeDownload(this);
}","public void run(){
  if (_okay) {
    _callback.addDownload(this);
    doDownload();
    _callback.removeDownload(this);
  }
}",0.8898678414096917
5117,"public void readHeader(){
  String str=null;
  while (true) {
    str=_br.readLine();
    System.out.println(str);
    if (str.indexOf(""String_Node_Str"") != -1) {
      String sub=str.substring(15);
      sub.trim();
      _sizeOfFile=java.lang.Integer.parseInt(sub);
      str=_br.readLine();
      System.out.println(str);
      break;
    }
  }
}","public void readHeader(){
  String str=null;
  int flag=0;
  while (true) {
    str=_br.readLine();
    System.out.println(str);
    if (str.indexOf(""String_Node_Str"") != -1) {
      String sub=str.substring(15);
      sub.trim();
      System.out.println(""String_Node_Str"" + str + ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + sub + ""String_Node_Str"");
      try {
        _sizeOfFile=java.lang.Integer.parseInt(sub);
      }
 catch (      NumberFormatException e) {
        System.out.println(""String_Node_Str"");
        return;
      }
      flag=1;
      str=_br.readLine();
      System.out.println(str);
      break;
    }
  }
  if (flag == 0) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
}",0.6048526863084922
5118,"public HTTPDownloader(String protocal,String host,int port,int index,String file,ConnectionManager m,byte[] guid){
  _filename=file;
  _amountRead=0;
  _sizeOfFile=-1;
  _socket=null;
  _manager=m;
  _callback=_manager.getCallback();
  _downloadDir=""String_Node_Str"";
  URLConnection conn;
  String furl=""String_Node_Str"" + String.valueOf(index) + ""String_Node_Str""+ file;
  try {
    URL url=new URL(protocal,host,port,furl);
    conn=url.openConnection();
  }
 catch (  java.net.MalformedURLException e) {
    sendPushRequest(host,index,port,guid);
    _callback.error(ActivityCallback.ERROR_5);
    return;
  }
catch (  IOException e) {
    sendPushRequest(host,index,port,guid);
    _callback.error(ActivityCallback.ERROR_6);
    return;
  }
  try {
    _istream=conn.getInputStream();
    _br=new ByteReader(_istream);
  }
 catch (  NoRouteToHostException e) {
    System.out.println(""String_Node_Str"");
    _callback.error(ActivityCallback.ERROR_13);
    return;
  }
catch (  IOException e) {
    e.printStackTrace();
    sendPushRequest(host,index,port,guid);
    return;
  }
}","public HTTPDownloader(String protocal,String host,int port,int index,String file,ConnectionManager m,byte[] guid){
  _okay=false;
  _filename=file;
  _amountRead=0;
  _sizeOfFile=-1;
  _socket=null;
  _manager=m;
  _callback=_manager.getCallback();
  _downloadDir=""String_Node_Str"";
  URLConnection conn;
  String furl=""String_Node_Str"" + String.valueOf(index) + ""String_Node_Str""+ file;
  try {
    URL url=new URL(protocal,host,port,furl);
    conn=url.openConnection();
  }
 catch (  java.net.MalformedURLException e) {
    sendPushRequest(host,index,port,guid);
    _callback.error(ActivityCallback.ERROR_5);
    return;
  }
catch (  IOException e) {
    sendPushRequest(host,index,port,guid);
    _callback.error(ActivityCallback.ERROR_6);
    return;
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  try {
    _istream=conn.getInputStream();
    _br=new ByteReader(_istream);
  }
 catch (  NoRouteToHostException e) {
    System.out.println(""String_Node_Str"");
    _callback.error(ActivityCallback.ERROR_13);
    return;
  }
catch (  IOException e) {
    e.printStackTrace();
    sendPushRequest(host,index,port,guid);
    return;
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    return;
  }
  _okay=true;
}",0.8984666390385412
5119,"public void doDownload(){
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String pathname=_downloadDir + _filename;
  System.out.println(pathname);
  try {
    _fos=new FileOutputStream(pathname);
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
  readHeader();
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      System.out.print(""String_Node_Str"");
    }
    if (c == -1)     break;
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      System.out.print(""String_Node_Str"");
    }
    _amountRead+=c;
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
  }
}","public void doDownload(){
  SettingsManager set=SettingsManager.instance();
  _downloadDir=set.getSaveDirectory();
  String pathname=_downloadDir + _filename;
  System.out.println(pathname);
  try {
    _fos=new FileOutputStream(pathname);
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
  readHeader();
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    try {
      c=_br.read(buf);
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"");
      return;
    }
    if (c == -1)     break;
    try {
      _fos.write(buf,0,c);
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      e.printStackTrace();
      return;
    }
    _amountRead+=c;
    System.out.println(""String_Node_Str"" + _amountRead);
    System.out.println(""String_Node_Str"" + _sizeOfFile);
    double percent=_amountRead / _sizeOfFile;
    System.out.println(""String_Node_Str"" + percent);
    System.out.println(""String_Node_Str"");
  }
  try {
    _br.close();
    _fos.close();
  }
 catch (  IOException e) {
  }
}",0.8099483810417645
5120,"public void run(){
  _callback.addDownload(this);
  doDownload();
  _callback.removeDownload(this);
}","public void run(){
  if (_okay) {
    _callback.addDownload(this);
    doDownload();
    _callback.removeDownload(this);
  }
}",0.8898678414096917
5121,"public void readHeader(){
  String str=null;
  while (true) {
    str=_br.readLine();
    System.out.println(str);
    if (str.indexOf(""String_Node_Str"") != -1) {
      String sub=str.substring(15);
      sub.trim();
      _sizeOfFile=java.lang.Integer.parseInt(sub);
      str=_br.readLine();
      System.out.println(str);
      break;
    }
  }
}","public void readHeader(){
  String str=null;
  int flag=0;
  while (true) {
    str=_br.readLine();
    System.out.println(str);
    if (str.indexOf(""String_Node_Str"") != -1) {
      String sub=str.substring(15);
      sub.trim();
      System.out.println(""String_Node_Str"" + str + ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + sub + ""String_Node_Str"");
      try {
        _sizeOfFile=java.lang.Integer.parseInt(sub);
      }
 catch (      NumberFormatException e) {
        System.out.println(""String_Node_Str"");
        return;
      }
      flag=1;
      str=_br.readLine();
      System.out.println(str);
      break;
    }
  }
  if (flag == 0) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
}",0.6048526863084922
5122,"/** 
 * subclasses must override this method 
 */
protected ArrayList search(String query){
  ArrayList response_list=new ArrayList();
  try {
    pattern=compiler.compile(query);
  }
 catch (  MalformedPatternException e) {
    for (int i=0; i < _numFiles; i++) {
      FileDesc desc=(FileDesc)_files.get(i);
      String file_name=desc._name;
      if (file_name.indexOf(query) != -1)       response_list.add(_files.get(i));
    }
  }
  for (int i=0; i < _numFiles; i++) {
    FileDesc desc=(FileDesc)_files.get(i);
    String file_name=desc._name;
    input=new PatternMatcherInput(file_name);
    if (matcher.contains(input,pattern))     response_list.add(_files.get(i));
  }
  return response_list;
}","/** 
 * subclasses must override this method 
 */
protected ArrayList search(String query){
  ArrayList response_list=new ArrayList();
  try {
    try {
      pattern=compiler.compile(query);
    }
 catch (    MalformedPatternException e) {
      for (int i=0; i < _numFiles; i++) {
        FileDesc desc=(FileDesc)_files.get(i);
        String file_name=desc._name;
        if (file_name.indexOf(query) != -1)         response_list.add(_files.get(i));
      }
    }
    for (int i=0; i < _numFiles; i++) {
      FileDesc desc=(FileDesc)_files.get(i);
      String file_name=desc._name;
      input=new PatternMatcherInput(file_name);
      if (matcher.contains(input,pattern))       response_list.add(_files.get(i));
    }
  }
 catch (  Exception e2) {
    System.out.println(""String_Node_Str"" + e2);
  }
  return response_list;
}",0.8893229166666666
5123,"/** 
 * Create a hex version of a GUID for compact display and storage Note that the client guid should be read in with the  Integer.parseByte(String s, int radix)  call like this in reverse
 */
public String toHexString(){
  StringBuffer buf=new StringBuffer();
  int val;
  for (int i=0; i < SZ; i+=4) {
    val=bytes[i];
    val=(val * 256) + bytes[i + 1];
    val=(val * 256) + bytes[i + 2];
    val=(val * 256) + bytes[i + 3];
    buf.append(Integer.toHexString(val));
  }
  return buf.toString();
}","/** 
 * Create a hex version of a GUID for compact display and storage Note that the client guid should be read in with the  Integer.parseByte(String s, int radix)  call like this in reverse
 */
public String toHexString(){
  StringBuffer buf=new StringBuffer();
  String str;
  int val;
  for (int i=0; i < SZ; i+=4) {
    val=bytes[i];
    val=(val * 256) + bytes[i + 1];
    val=(val * 256) + bytes[i + 2];
    val=(val * 256) + bytes[i + 3];
    str=Integer.toHexString(val);
    while (str.length() < 8)     str=""String_Node_Str"" + str;
    buf.append(str);
  }
  return buf.toString();
}",0.8222424794895169
5124,"public void doDownload(){
  readHeader();
  try {
    if (_sizeOfFile != -1) {
      SettingsManager set=SettingsManager.instance();
      _downloadDir=set.getSaveDirectory();
      String pathname=_downloadDir + _filename;
      System.out.println(""String_Node_Str"" + pathname);
      int c=-1;
      _bis=new BufferedInputStream(_istream);
      FileOutputStream fos=new FileOutputStream(pathname);
      byte[] buf=new byte[1024];
      while (true) {
        c=_istream.read(buf);
        if (c == -1)         break;
        fos.write(buf,0,c);
        _amountRead+=c;
      }
      fos.close();
      System.out.println(""String_Node_Str"" + _sizeOfFile);
    }
  }
 catch (  Exception e) {
    _callback.error(ActivityCallback.ERROR_8);
    System.out.println(""String_Node_Str"" + e + ""String_Node_Str"");
  }
}","public void doDownload(){
  readHeader();
  try {
    if (_sizeOfFile != -1) {
      SettingsManager set=SettingsManager.instance();
      _downloadDir=set.getSaveDirectory();
      String pathname=_downloadDir + ""String_Node_Str"" + _filename;
      System.out.println(""String_Node_Str"" + pathname);
      int c=-1;
      _bis=new BufferedInputStream(_istream);
      FileOutputStream fos=new FileOutputStream(pathname);
      byte[] buf=new byte[1024];
      while (true) {
        c=_istream.read(buf);
        if (c == -1)         break;
        fos.write(buf,0,c);
        _amountRead+=c;
      }
      fos.close();
      System.out.println(""String_Node_Str"" + _sizeOfFile);
    }
  }
 catch (  Exception e) {
    _callback.error(ActivityCallback.ERROR_8);
    System.out.println(""String_Node_Str"" + e + ""String_Node_Str"");
  }
}",0.9878493317132442
5125,"public void doSchmownload(){
  System.out.println(""String_Node_Str"");
  readHeader();
  try {
    if (_sizeOfFile != -1) {
      SettingsManager set=SettingsManager.instance();
      _downloadDir=set.getSaveDirectory();
      String pathname=_downloadDir + _filename;
      System.out.println(""String_Node_Str"" + pathname);
      File myFile=new File(pathname);
      FileOutputStream fos=new FileOutputStream(myFile);
      BufferedOutputStream bos=new BufferedOutputStream(fos);
      int count=0;
      int c=-1;
      byte[] buf=new byte[MAX_BUFF];
      while (true) {
        int available=_bis.available();
        System.out.println(""String_Node_Str"" + available);
        int amount=Math.min(MAX_BUFF,available);
        System.out.println(""String_Node_Str"" + amount);
        if (amount != 0)         c=_bis.read(buf,0,amount);
 else {
          c=_bis.read();
          System.out.println(""String_Node_Str"" + c);
          if (c != -1) {
            buf[0]=(byte)c;
            c=1;
          }
        }
        System.out.println(""String_Node_Str"" + c);
        if (c == -1)         break;
        bos.write(buf,0,c);
        _amountRead+=c;
        System.out.println(""String_Node_Str"" + _amountRead);
        count++;
      }
      System.out.println(""String_Node_Str"" + _amountRead);
      System.out.println(""String_Node_Str"" + _sizeOfFile);
    }
  }
 catch (  Exception e) {
    _callback.error(ActivityCallback.ERROR_8);
    System.out.println(""String_Node_Str"" + e + ""String_Node_Str"");
  }
}","public void doSchmownload(){
  System.out.println(""String_Node_Str"");
  readHeader();
  try {
    if (_sizeOfFile != -1) {
      SettingsManager set=SettingsManager.instance();
      _downloadDir=set.getSaveDirectory();
      String pathname=_downloadDir + _filename;
      System.out.println(""String_Node_Str"" + pathname);
      File myFile=new File(pathname);
      FileOutputStream fos=new FileOutputStream(myFile);
      BufferedOutputStream bos=new BufferedOutputStream(fos);
      int count=0;
      int c=-1;
      byte[] buf=new byte[MAX_BUFF];
      while (true) {
        int available=_bis.available();
        System.out.println(""String_Node_Str"" + available);
        int amount=Math.min(MAX_BUFF,available);
        System.out.println(""String_Node_Str"" + amount);
        if (amount != 0)         c=_bis.read(buf,0,amount);
 else {
          c=_bis.read();
          System.out.println(""String_Node_Str"" + c);
          if (c != -1) {
            buf[0]=(byte)c;
            c=1;
          }
        }
        System.out.println(""String_Node_Str"" + c);
        if (c == -1)         break;
        bos.write(buf,0,c);
        _amountRead++;
        System.out.println(""String_Node_Str"" + _amountRead);
        count++;
      }
      System.out.println(""String_Node_Str"" + _amountRead);
      System.out.println(""String_Node_Str"" + _sizeOfFile);
    }
  }
 catch (  Exception e) {
    _callback.error(ActivityCallback.ERROR_8);
    System.out.println(""String_Node_Str"" + e + ""String_Node_Str"");
  }
}",0.99900826446281
5126,"public void doUpload(){
  writeHeader();
  int c=-1;
  int available=0;
  while (true) {
    try {
      c=_fis.read();
    }
 catch (    IOException e) {
      uploadError(""String_Node_Str"");
      e.printStackTrace();
    }
    if (c == -1)     break;
    try {
      if (_ostream == null)       System.out.println(""String_Node_Str"");
      _ostream.write(c);
    }
 catch (    IOException e) {
      uploadError(""String_Node_Str"");
      e.printStackTrace();
    }
    _amountRead+=c;
  }
  try {
    _out.close();
  }
 catch (  IOException e) {
    uploadError(""String_Node_Str"");
  }
}","public void doUpload(){
  writeHeader();
  int c=-1;
  int available=0;
  while (true) {
    try {
      c=_fis.read();
    }
 catch (    IOException e) {
      uploadError(""String_Node_Str"");
      e.printStackTrace();
    }
    if (c == -1)     break;
    try {
      if (_ostream == null)       System.out.println(""String_Node_Str"");
      _ostream.write(c);
    }
 catch (    IOException e) {
      uploadError(""String_Node_Str"");
      e.printStackTrace();
    }
    _amountRead++;
  }
  try {
    _out.close();
  }
 catch (  IOException e) {
    uploadError(""String_Node_Str"");
  }
}",0.9974554707379136
5127,"public void doDownload(){
  readHeader();
  try {
    if (_sizeOfFile != -1) {
      SettingsManager set=SettingsManager.instance();
      _downloadDir=set.getSaveDirectory();
      String pathname=_downloadDir + _filename;
      System.out.println(""String_Node_Str"" + pathname);
      int c=-1;
      _bis=new BufferedInputStream(_istream);
      FileOutputStream fos=new FileOutputStream(pathname);
      byte[] buf=new byte[1024];
      while (true) {
        c=_istream.read(buf);
        if (c == -1)         break;
        fos.write(buf,0,c);
        _amountRead+=c;
      }
      fos.close();
      System.out.println(""String_Node_Str"" + _sizeOfFile);
    }
  }
 catch (  Exception e) {
    _callback.error(ActivityCallback.ERROR_8);
    System.out.println(""String_Node_Str"" + e + ""String_Node_Str"");
  }
}","public void doDownload(){
  readHeader();
  try {
    if (_sizeOfFile != -1) {
      SettingsManager set=SettingsManager.instance();
      _downloadDir=set.getSaveDirectory();
      String pathname=_downloadDir + ""String_Node_Str"" + _filename;
      System.out.println(""String_Node_Str"" + pathname);
      int c=-1;
      _bis=new BufferedInputStream(_istream);
      FileOutputStream fos=new FileOutputStream(pathname);
      byte[] buf=new byte[1024];
      while (true) {
        c=_istream.read(buf);
        if (c == -1)         break;
        fos.write(buf,0,c);
        _amountRead+=c;
      }
      fos.close();
      System.out.println(""String_Node_Str"" + _sizeOfFile);
    }
  }
 catch (  Exception e) {
    _callback.error(ActivityCallback.ERROR_8);
    System.out.println(""String_Node_Str"" + e + ""String_Node_Str"");
  }
}",0.9878493317132442
5128,"public void doSchmownload(){
  System.out.println(""String_Node_Str"");
  readHeader();
  try {
    if (_sizeOfFile != -1) {
      SettingsManager set=SettingsManager.instance();
      _downloadDir=set.getSaveDirectory();
      String pathname=_downloadDir + _filename;
      System.out.println(""String_Node_Str"" + pathname);
      File myFile=new File(pathname);
      FileOutputStream fos=new FileOutputStream(myFile);
      BufferedOutputStream bos=new BufferedOutputStream(fos);
      int count=0;
      int c=-1;
      byte[] buf=new byte[MAX_BUFF];
      while (true) {
        int available=_bis.available();
        System.out.println(""String_Node_Str"" + available);
        int amount=Math.min(MAX_BUFF,available);
        System.out.println(""String_Node_Str"" + amount);
        if (amount != 0)         c=_bis.read(buf,0,amount);
 else {
          c=_bis.read();
          System.out.println(""String_Node_Str"" + c);
          if (c != -1) {
            buf[0]=(byte)c;
            c=1;
          }
        }
        System.out.println(""String_Node_Str"" + c);
        if (c == -1)         break;
        bos.write(buf,0,c);
        _amountRead+=c;
        System.out.println(""String_Node_Str"" + _amountRead);
        count++;
      }
      System.out.println(""String_Node_Str"" + _amountRead);
      System.out.println(""String_Node_Str"" + _sizeOfFile);
    }
  }
 catch (  Exception e) {
    _callback.error(ActivityCallback.ERROR_8);
    System.out.println(""String_Node_Str"" + e + ""String_Node_Str"");
  }
}","public void doSchmownload(){
  System.out.println(""String_Node_Str"");
  readHeader();
  try {
    if (_sizeOfFile != -1) {
      SettingsManager set=SettingsManager.instance();
      _downloadDir=set.getSaveDirectory();
      String pathname=_downloadDir + _filename;
      System.out.println(""String_Node_Str"" + pathname);
      File myFile=new File(pathname);
      FileOutputStream fos=new FileOutputStream(myFile);
      BufferedOutputStream bos=new BufferedOutputStream(fos);
      int count=0;
      int c=-1;
      byte[] buf=new byte[MAX_BUFF];
      while (true) {
        int available=_bis.available();
        System.out.println(""String_Node_Str"" + available);
        int amount=Math.min(MAX_BUFF,available);
        System.out.println(""String_Node_Str"" + amount);
        if (amount != 0)         c=_bis.read(buf,0,amount);
 else {
          c=_bis.read();
          System.out.println(""String_Node_Str"" + c);
          if (c != -1) {
            buf[0]=(byte)c;
            c=1;
          }
        }
        System.out.println(""String_Node_Str"" + c);
        if (c == -1)         break;
        bos.write(buf,0,c);
        _amountRead++;
        System.out.println(""String_Node_Str"" + _amountRead);
        count++;
      }
      System.out.println(""String_Node_Str"" + _amountRead);
      System.out.println(""String_Node_Str"" + _sizeOfFile);
    }
  }
 catch (  Exception e) {
    _callback.error(ActivityCallback.ERROR_8);
    System.out.println(""String_Node_Str"" + e + ""String_Node_Str"");
  }
}",0.99900826446281
5129,"public void doUpload(){
  writeHeader();
  int c=-1;
  int available=0;
  while (true) {
    try {
      c=_fis.read();
    }
 catch (    IOException e) {
      uploadError(""String_Node_Str"");
      e.printStackTrace();
    }
    if (c == -1)     break;
    try {
      if (_ostream == null)       System.out.println(""String_Node_Str"");
      _ostream.write(c);
    }
 catch (    IOException e) {
      uploadError(""String_Node_Str"");
      e.printStackTrace();
    }
    _amountRead+=c;
  }
  try {
    _out.close();
  }
 catch (  IOException e) {
    uploadError(""String_Node_Str"");
  }
}","public void doUpload(){
  writeHeader();
  int c=-1;
  int available=0;
  while (true) {
    try {
      c=_fis.read();
    }
 catch (    IOException e) {
      uploadError(""String_Node_Str"");
      e.printStackTrace();
    }
    if (c == -1)     break;
    try {
      if (_ostream == null)       System.out.println(""String_Node_Str"");
      _ostream.write(c);
    }
 catch (    IOException e) {
      uploadError(""String_Node_Str"");
      e.printStackTrace();
    }
    _amountRead++;
  }
  try {
    _out.close();
  }
 catch (  IOException e) {
    uploadError(""String_Node_Str"");
  }
}",0.9974554707379136
5130,"public static String[] stringSplit(String s,char delimeter){
  s=s.trim();
  int n=s.length();
  if (n == 0)   return new String[0];
  Vector buf=new Vector();
  for (int i=0; i < n; ) {
    if (s.charAt(i) == delimeter)     i++;
    int j=s.indexOf(delimeter,i + 1);
    if (j == -1)     j=n;
    buf.add(s.substring(i,j));
    for (i=j + 1; j < n; ) {
      if (s.charAt(i) != ' ')       break;
      i++;
    }
  }
  String[] ret=new String[buf.size()];
  for (int i=0; i < ret.length; i++)   ret[i]=(String)buf.get(i);
  return ret;
}","public static String[] stringSplit(String s,char delimeter){
  s=s.trim();
  int n=s.length();
  if (n == 0)   return new String[0];
  Vector buf=new Vector();
  for (int i=0; i < n; ) {
    if (s.charAt(i) == delimeter)     i++;
    int j=s.indexOf(delimeter,i + 1);
    if (j == -1)     j=n;
    buf.add(s.substring(i,j));
    for (i=j + 1; j < n - 1; ) {
      if (s.charAt(i) != ' ')       break;
      i++;
    }
  }
  String[] ret=new String[buf.size()];
  for (int i=0; i < ret.length; i++)   ret[i]=(String)buf.get(i);
  return ret;
}",0.9962962962962963
5131,"/** 
 * Note: the minimum speed can be represented as a 4-byte unsigned  number, but Java ints are signed.  Hence we must use a long.  The value returned is always smaller than 2^32.
 */
public long getMinSpeed(){
  int speed=ByteOrder.leb2int(payload,0);
  long ret=ByteOrder.ubytes2long(speed);
  Assert.that(ret >= 0,""String_Node_Str"");
  return ret;
}","/** 
 * Note: the minimum speed can be represented as a 4-byte unsigned  number, but Java ints are signed.  Hence we must use a long.  The value returned is always smaller than 2^32.
 */
public int getMinSpeed(){
  short speed=ByteOrder.leb2short(payload,0);
  int ret=ByteOrder.ubytes2int(speed);
  Assert.that(ret >= 0,""String_Node_Str"");
  return ret;
}",0.9535864978902954
5132,"/** 
 * See specification of Message.read. Note that this is non-blocking, but there is no hard guarantee on the maximum block time.  
 */
public Message receive() throws IOException, BadPacketException {
  Message m=Message.read(sock.getInputStream());
  received++;
  return m;
}","/** 
 * See specification of Message.read. Note that this is non-blocking, but there is no hard guarantee on the maximum block time.  This is thread-safe.
 */
public Message receive() throws IOException, BadPacketException {
  InputStream in=sock.getInputStream();
synchronized (in) {
    Message m=Message.read(in);
    received++;
    if (m != null)     System.out.println(""String_Node_Str"" + m.toString() + ""String_Node_Str""+ sock.toString());
    return m;
  }
}",0.6746987951807228
5133,"/** 
 * @modifies network, modifies
 * @effects Throws IOException if handshake failed.  Otherwiseadds this manager
 * @param manager the manager managing me and my ""sibling"" connections
 * @param sock the socket used for communication
 * @param incoming true if this is an incoming connection.False otherwise.
 * @exception IOException if the handshake failed
 */
public Connection(ConnectionManager manager,Socket sock,boolean incoming) throws IOException {
  this.manager=manager;
  this.sock=sock;
  this.incoming=incoming;
  this.routeTable=manager.routeTable;
  final String CONNECT=""String_Node_Str"";
  final String OK=""String_Node_Str"";
  if (incoming) {
    expectString(CONNECT);
    sendString(OK);
  }
 else {
    sendString(CONNECT);
    expectString(OK);
    Message m=new PingRequest(Const.TTL);
    send(m);
    routeTable.put(m.getGUID(),this);
  }
  manager.add(this);
  System.out.println(""String_Node_Str"" + (incoming ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ sock.toString());
}","/** 
 * Creates an outgoing or incoming connection around an existing socket.
 * @modifies network, manager
 * @effects wraps a connection around sock and does the Gnutella handshake.Throws IOException if the connection couldn't be established. If manager is non-null, also registers this with manager and sends an initial PingRequest if this is outgoing..
 * @param manager the manager managing me and my ""sibling"" connections, or nullif the run() method will not be called.
 * @param sock the socket used for communication
 * @param incoming true if this is an incoming connection.False otherwise.
 * @exception IOException if the handshake failed
 */
public Connection(ConnectionManager manager,Socket sock,boolean incoming) throws IOException {
  this.manager=manager;
  this.sock=sock;
  this.incoming=incoming;
  if (manager != null)   this.routeTable=manager.routeTable;
  final String CONNECT=""String_Node_Str"";
  final String OK=""String_Node_Str"";
  if (incoming) {
    expectString(CONNECT);
    sendString(OK);
  }
 else {
    sendString(CONNECT);
    expectString(OK);
    if (manager != null) {
      Message m=new PingRequest(Const.TTL);
      send(m);
      routeTable.put(m.getGUID(),this);
    }
  }
  if (manager != null)   manager.add(this);
  System.out.println(""String_Node_Str"" + (incoming ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ sock.toString());
}",0.7960199004975125
5134,"/** 
 * @modifies : the network underlying this, manager
 * @effects : receives request and sends appropriate replies. Returns if either the connection is closed or an error happens. If this happens, removes itself from the manager's connection list.
 */
public void run(){
  try {
    while (true) {
      Message m=null;
      try {
        m=receive();
        if (m == null)         continue;
      }
 catch (      BadPacketException e) {
        continue;
      }
      byte[] guid=m.getGUID();
      Connection originator=routeTable.get(guid);
      manager.catcher.spy(m);
      if (m instanceof PingRequest && originator == null) {
        byte[] ip=sock.getLocalAddress().getAddress();
        send(new PingReply(guid,m.getHops(),(short)sock.getLocalPort(),ip,(int)0,(int)0));
      }
 else       if (m instanceof QueryRequest) {
      }
      if (m.hop() != 0) {
        if (m.isRequest()) {
          if (originator == null) {
            routeTable.put(guid,this);
            manager.sendToAllExcept(m,this);
          }
        }
 else {
          if (originator == this)           ;
 else           if (originator != null)           originator.send(m);
 else           ConnectionManager.error(""String_Node_Str"" + m.toString() + ""String_Node_Str"");
        }
      }
    }
  }
 catch (  IOException e) {
    manager.remove(this);
    ConnectionManager.error(""String_Node_Str"" + sock.toString());
  }
catch (  Exception e) {
    ConnectionManager.error(""String_Node_Str"");
    manager.remove(this);
    e.printStackTrace();
  }
}","/** 
 * @requires the manager to this is non-null
 * @modifies the network underlying this, manager
 * @effects receives request and sends appropriate replies.Returns if either the connection is closed or an error happens. If this happens, removes itself from the manager's connection list.
 */
public void run(){
  Assert.that(manager != null && routeTable != null);
  try {
    while (true) {
      Message m=null;
      try {
        m=receive();
        if (m == null)         continue;
      }
 catch (      BadPacketException e) {
        continue;
      }
      byte[] guid=m.getGUID();
      Connection originator=routeTable.get(guid);
      manager.catcher.spy(m);
      if (m instanceof PingRequest && originator == null) {
        byte[] ip=sock.getLocalAddress().getAddress();
        send(new PingReply(guid,m.getHops(),(short)sock.getLocalPort(),ip,(int)0,(int)0));
      }
 else       if (m instanceof QueryRequest) {
      }
      if (m.hop() != 0) {
        if (m.isRequest()) {
          if (originator == null) {
            routeTable.put(guid,this);
            manager.sendToAllExcept(m,this);
          }
        }
 else {
          if (originator == this)           ;
 else           if (originator != null)           originator.send(m);
 else           ConnectionManager.error(""String_Node_Str"" + m.toString() + ""String_Node_Str"");
        }
      }
    }
  }
 catch (  IOException e) {
    manager.remove(this);
    ConnectionManager.error(""String_Node_Str"" + sock.toString());
  }
catch (  Exception e) {
    ConnectionManager.error(""String_Node_Str"");
    manager.remove(this);
    e.printStackTrace();
  }
}",0.9672750157331657
5135,"/** 
 * @modifies : the network underlying this
 * @effects : send m on the network.  Throws IOException if problems arise.
 */
public synchronized void send(Message m) throws IOException {
  OutputStream out=sock.getOutputStream();
  m.write(out);
  out.flush();
  sent++;
}","/** 
 * @modifies the network underlying this
 * @effects send m on the network.  Throws IOException if problemsarise.  This is thread-safe.
 */
public void send(Message m) throws IOException {
  OutputStream out=sock.getOutputStream();
synchronized (out) {
    m.write(out);
    out.flush();
    sent++;
  }
  System.out.println(""String_Node_Str"" + m.toString() + ""String_Node_Str""+ sock.toString());
}",0.7463126843657817
5136,"/** 
 * @modifies this
 * @effects adds any hosts listed in m to this
 */
public void spy(Message m){
  String ip=null;
  int port=6346;
  if (m instanceof PingReply) {
    ip=((PingReply)m).getIP();
    port=port;
  }
 else {
    return;
  }
synchronized (candidates) {
    candidates.add(new Endpoint(ip,port));
  }
}","/** 
 * @modifies this
 * @effects ensures any hosts listed in m are in this
 */
public void spy(Message m){
  String ip=null;
  int port=6346;
  if (m instanceof PingReply) {
    PingReply pr=(PingReply)m;
    ip=pr.getIP();
    port=pr.getPort();
  }
 else {
    return;
  }
synchronized (candidates) {
    Endpoint e=new Endpoint(ip,port);
    if (!elected.contains(e)) {
      candidates.add(e);
    }
  }
}",0.7315068493150685
5137,"/** 
 * Little-endian bytes to int
 * @requires x.length-offset>=4
 * @effects returns the value of x[offset..offset+4] as an int, assuming x is interpreted as a signed little endian number (i.e.,  x[offset] is LSB) If you want to interpret it as an unsigned number, call ubytes2int on the result.
 */
public static int leb2int(byte[] x,int offset){
  int x0=x[offset];
  int x1=x[offset + 1] << 8;
  int x2=x[offset + 2] << 16;
  int x3=x[offset + 3] << 24;
  return x3 | x2 | x1| x0;
}","/** 
 * Little-endian bytes to int
 * @requires x.length-offset>=4
 * @effects returns the value of x[offset..offset+4] as an int, assuming x is interpreted as a signed little endian number (i.e.,  x[offset] is LSB) If you want to interpret it as an unsigned number, call ubytes2int on the result.
 */
public static int leb2int(byte[] x,int offset){
  int x0=x[offset] & 0x000000FF;
  int x1=(x[offset + 1] << 8) & 0x0000FF00;
  int x2=(x[offset + 2] << 16) & 0x00FF0000;
  int x3=(x[offset + 3] << 24);
  return x3 | x2 | x1| x0;
}",0.955839057899902
5138,"/** 
 * Little-endian bytes to short
 * @requires x.length-offset>=2
 * @effects returns the value of x[offset..offset+2] as a short, assuming x is interpreted as a signed little endian number (i.e.,  x[offset] is LSB).  If you want to interpret it as an unsigned number, call ubytes2int on the result.
 */
public static short leb2short(byte[] x,int offset){
  short x0=(short)x[offset];
  short x1=(short)(x[offset + 1] << 8);
  return (short)(x1 | x0);
}","/** 
 * Little-endian bytes to short
 * @requires x.length-offset>=2
 * @effects returns the value of x[offset..offset+2] as a short, assuming x is interpreted as a signed little endian number (i.e.,  x[offset] is LSB).  If you want to interpret it as an unsigned number, call ubytes2int on the result.
 */
public static short leb2short(byte[] x,int offset){
  int x0=(x[offset]) & 0x000000FF;
  int x1=(x[offset + 1] << 8);
  return (short)(x1 | x0);
}",0.9570957095709572
5139,"/** 
 * Little-endian bytes to int
 * @requires x.length-offset>=4
 * @effects returns the value of x[offset..offset+4] as an int, assuming x is interpreted in a little endian number (i.e.,  x[offset] is LSB) 
 */
public static int leb2int(byte[] x,int offset){
  int x0=x[offset];
  int x1=x[offset + 1] << 8;
  int x2=x[offset + 2] << 16;
  int x3=x[offset + 3] << 24;
  return x0 + x1 + x2+ x3;
}","/** 
 * Little-endian bytes to int
 * @requires x.length-offset>=4
 * @effects returns the value of x[offset..offset+4] as an int, assuming x is interpreted as a signed little endian number (i.e.,  x[offset] is LSB) If you want to interpret it as an unsigned number, call ubytes2int on the result.
 */
public static int leb2int(byte[] x,int offset){
  int x0=x[offset];
  int x1=x[offset + 1] << 8;
  int x2=x[offset + 2] << 16;
  int x3=x[offset + 3] << 24;
  return x3 | x2 | x1| x0;
}",0.8600451467268623
5140,"/** 
 * Little-endian bytes to short
 * @requires x.length-offset>=2
 * @effects returns the value of x[offset..offset+2] as a short, assuming x is interpreted in a little endian number (i.e.,  x[offset] is LSB) 
 */
public static short leb2short(byte[] x,int offset){
  short x0=(short)x[offset];
  short x1=(short)(x[offset + 1] << 8);
  return (short)(x0 + x1);
}","/** 
 * Little-endian bytes to short
 * @requires x.length-offset>=2
 * @effects returns the value of x[offset..offset+2] as a short, assuming x is interpreted as a signed little endian number (i.e.,  x[offset] is LSB).  If you want to interpret it as an unsigned number, call ubytes2int on the result.
 */
public static short leb2short(byte[] x,int offset){
  short x0=(short)x[offset];
  short x1=(short)(x[offset + 1] << 8);
  return (short)(x1 | x0);
}",0.8661800486618005
5141,"/** 
 * Interprets the value of b as an unsigned byte, and returns  it as integer.  For example, ubyte2int(0xFF)==255, not -1.
 */
public static int ubyte2int(byte b){
  return ((int)b) & 0x000000FF;
}","/** 
 * Interprets the value of x as an unsigned byte, and returns  it as integer.  For example, ubyte2int(0xFF)==255, not -1.
 */
public static int ubyte2int(byte x){
  return ((int)x) & 0x000000FF;
}",0.9850746268656716
5142,"/** 
 * Returns the ip (in LITTLE-endian) format as standard dotted-decimal, e.g., 192.168.0.1 
 */
protected static String ip2string(byte[] ip){
  StringBuffer buf=new StringBuffer();
  buf.append(ByteOrder.ubyte2int(ip[3]) + ""String_Node_Str"");
  buf.append(ByteOrder.ubyte2int(ip[2]) + ""String_Node_Str"");
  buf.append(ByteOrder.ubyte2int(ip[1]) + ""String_Node_Str"");
  buf.append(ByteOrder.ubyte2int(ip[3]) + ""String_Node_Str"");
  return buf.toString();
}","/** 
 * Returns the ip (given in LITTLE-endian) format as standard dotted-decimal, e.g., 192.168.0.1 
 */
protected static String ip2string(byte[] ip){
  StringBuffer buf=new StringBuffer();
  buf.append(ByteOrder.ubyte2int(ip[3]) + ""String_Node_Str"");
  buf.append(ByteOrder.ubyte2int(ip[2]) + ""String_Node_Str"");
  buf.append(ByteOrder.ubyte2int(ip[1]) + ""String_Node_Str"");
  buf.append(ByteOrder.ubyte2int(ip[0]) + ""String_Node_Str"");
  return buf.toString();
}",0.9913419913419912
5143,"public Object invokeMethod(String controllerName,Method method,Object[] parameter){
  try {
    if (controllerName != null) {
      LOGGER.debug(""String_Node_Str"",method.getName(),controllerName);
      IMeasurementEnvironmentController mec=MECApplication.get().getMEController(controllerName);
      return method.invoke(mec,parameter);
    }
 else {
      LOGGER.debug(""String_Node_Str"",method.getName());
      return method.invoke(this,parameter);
    }
  }
 catch (  IllegalArgumentException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
  }
  return null;
}","public Object invokeMethod(String controllerName,Method method,Object[] parameter){
  try {
    if (controllerName != null) {
      LOGGER.debug(""String_Node_Str"",method.getName(),controllerName);
      IMeasurementEnvironmentController mec=MECApplication.get().getMEController(controllerName);
      return method.invoke(mec,parameter);
    }
 else {
      LOGGER.debug(""String_Node_Str"",method.getName());
      return method.invoke(this,parameter);
    }
  }
 catch (  IllegalArgumentException e) {
    e.printStackTrace();
    return e;
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
    return e;
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
    return e;
  }
}",0.95902228612509
5144,"@SuppressWarnings(""String_Node_Str"") @Override public Collection<ParameterValueList<?>> runExperiment(String acquirerID,ParameterCollection<ParameterValue<?>> inputPVs) throws RemoteException, ExperimentFailedException {
  Object result=call(acquirerID,inputPVs);
  while (true) {
    if (result instanceof StatusMessage) {
      StatusBroker.getManagerViaSessionID(acquirerID).newStatus((StatusMessage)result);
    }
 else {
      break;
    }
    try {
      result=getOiStream().readObject();
    }
 catch (    IOException e) {
      e.printStackTrace();
      throw new RuntimeException(e);
    }
catch (    ClassNotFoundException e) {
      e.printStackTrace();
      throw new RuntimeException(e);
    }
  }
  return (Collection<ParameterValueList<?>>)result;
}","@SuppressWarnings(""String_Node_Str"") @Override public Collection<ParameterValueList<?>> runExperiment(String acquirerID,ParameterCollection<ParameterValue<?>> inputPVs) throws RemoteException, ExperimentFailedException {
  Object result=call(acquirerID,inputPVs);
  while (true) {
    if (result instanceof StatusMessage) {
      StatusBroker.getManagerViaSessionID(acquirerID).newStatus((StatusMessage)result);
    }
 else {
      break;
    }
    try {
      result=getOiStream().readObject();
    }
 catch (    IOException e) {
      e.printStackTrace();
      throw new RuntimeException(e);
    }
catch (    ClassNotFoundException e) {
      e.printStackTrace();
      throw new RuntimeException(e);
    }
  }
  if (result instanceof InvocationTargetException) {
    InvocationTargetException exc=(InvocationTargetException)result;
    throw new RuntimeException(exc.getCause());
  }
 else   if (result instanceof Exception) {
    throw new RuntimeException((Exception)result);
  }
  return (Collection<ParameterValueList<?>>)result;
}",0.8493909191583611
5145,"/** 
 * Reads the file specified by the given   {@link pathToFile} parameter andreturns a complete  {@link ScenarioDefinition} instance.
 * @param pathToFile absolute path to the XML file
 * @return Returns a {@link ScenarioDefinition} instance.
 */
public ScenarioDefinition read(String pathToFile){
  LOGGER.debug(""String_Node_Str"",pathToFile);
  XScenarioDefinition sd=null;
  try {
    JAXBContext jc=JAXBContext.newInstance(Configuration.getSessionUnrelatedSingleton().getPropertyAsStr(IConfiguration.CONF_SCENARIO_DEFINITION_PACKAGE));
    Unmarshaller u=jc.createUnmarshaller();
    sd=((JAXBElement<XScenarioDefinition>)u.unmarshal(new FileInputStream(pathToFile))).getValue();
  }
 catch (  FileNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  JAXBException e) {
    throw new RuntimeException(e);
  }
  return convert(sd);
}","/** 
 * Reads the file specified by the given   {@link pathToFile} parameter andreturns a complete  {@link ScenarioDefinition} instance.
 * @param pathToFile absolute path to the XML file
 * @return Returns a {@link ScenarioDefinition} instance.
 */
public ScenarioDefinition read(String pathToFile){
  LOGGER.debug(""String_Node_Str"",pathToFile);
  XScenarioDefinition sd=null;
  try {
    JAXBContext jc=JAXBContext.newInstance(Configuration.getSessionUnrelatedSingleton().getPropertyAsStr(IConfiguration.CONF_SCENARIO_DEFINITION_PACKAGE));
    Unmarshaller u=jc.createUnmarshaller();
    sd=((JAXBElement<XScenarioDefinition>)u.unmarshal(new FileInputStream(pathToFile))).getValue();
  }
 catch (  FileNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  JAXBException e) {
    throw new RuntimeException(e);
  }
  ScenarioDefinition scenarioDefinition=convertScenarioDefinition(sd);
  scenarioDefinition.setMeasurementEnvironmentDefinition(meDefinition);
  return scenarioDefinition;
}",0.9135932560590094
5146,"private ExperimentTerminationCondition convertTerminationCondition(XExtensibleElement xTerminationCondition){
  Map<String,String> config=new HashMap<String,String>();
  for (  XConfigurationNode xConfigNode : xTerminationCondition.getConfig()) {
    config.put(xConfigNode.getKey(),xConfigNode.getValue());
  }
  return EntityFactory.createTerminationCondition(xTerminationCondition.getName(),config);
}","/** 
 * Converts the xml representation of a termination condition to a  {@link ExperimentTerminationCondition} object.
 * @param xTerminationCondition xml representation of a termination condition
 * @return {@link ExperimentTerminationCondition} object
 */
private ExperimentTerminationCondition convertTerminationCondition(XExtensibleElement xTerminationCondition){
  Map<String,String> config=new HashMap<String,String>();
  for (  XConfigurationNode xConfigNode : xTerminationCondition.getConfig()) {
    config.put(xConfigNode.getKey(),xConfigNode.getValue());
  }
  return EntityFactory.createTerminationCondition(xTerminationCondition.getName(),config);
}",0.7572633552014996
5147,"private ExplorationStrategy convertExplorationStrategy(XExplorationStrategy xExplorationStrategy){
  Map<String,String> config=new HashMap<String,String>();
  for (  XConfigurationNode xConfigNode : xExplorationStrategy.getConfig()) {
    config.put(xConfigNode.getKey(),xConfigNode.getValue());
  }
  ExplorationStrategy explStrategy=EntityFactory.createExplorationStrategy(xExplorationStrategy.getName(),config);
  for (  XAnalysisConfiguration xAnalysisConfig : xExplorationStrategy.getAnalysisConfig()) {
    explStrategy.getAnalysisConfigurations().add(convert(xAnalysisConfig));
  }
  return explStrategy;
}","/** 
 * Converts the xml representation of an exploration strategy to a  {@link ExplorationStrategy} object.
 * @param xExplorationStrategy xml representation of an exploration strategy
 * @return {@link ExplorationStrategy} object
 */
private ExplorationStrategy convertExplorationStrategy(XExplorationStrategy xExplorationStrategy){
  Map<String,String> config=new HashMap<String,String>();
  for (  XConfigurationNode xConfigNode : xExplorationStrategy.getConfig()) {
    config.put(xConfigNode.getKey(),xConfigNode.getValue());
  }
  ExplorationStrategy explStrategy=EntityFactory.createExplorationStrategy(xExplorationStrategy.getName(),config);
  for (  XAnalysisConfiguration xAnalysisConfig : xExplorationStrategy.getAnalysisConfig()) {
    explStrategy.getAnalysisConfigurations().add(convertAnalysisConfiguration(xAnalysisConfig));
  }
  return explStrategy;
}",0.8240053944706676
5148,"@Override public void runExperimentSeries(ExperimentSeriesRun expSeriesRun,List<IParameterVariation> parameterVariations){
  if (parameterVariations == null || parameterVariations.isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  strategyConfig=expSeriesRun.getExperimentSeries().getExperimentSeriesDefinition().getExplorationStrategy();
  if (strategyConfig.getName().equalsIgnoreCase(ScreeningConfiguration.FULL_FACTORIAL)) {
    adapter=new FullFactorialAdapter();
  }
 else   if (strategyConfig.getName().equalsIgnoreCase(ScreeningConfiguration.FRACTIONAL_FACTORIAL)) {
    adapter=new FullFactorialAdapter();
  }
 else   if (strategyConfig.getName().equalsIgnoreCase(ScreeningConfiguration.PLACKETT_BURMAN)) {
    adapter=new FullFactorialAdapter();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + strategyConfig.getName());
  }
  adapter.setParameterVariations(parameterVariations);
  adapter.setExplorationConf(strategyConfig);
  adapter.generateDesign();
  numberOfMeasurements=0;
  executeExperimentSeries(expSeriesRun);
}","@Override public void runExperimentSeries(ExperimentSeriesRun expSeriesRun,List<IParameterVariation> parameterVariations){
  if (parameterVariations == null || parameterVariations.isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  strategyConfig=expSeriesRun.getExperimentSeries().getExperimentSeriesDefinition().getExplorationStrategy();
  if (strategyConfig.getName().equalsIgnoreCase(ScreeningConfiguration.FULL_FACTORIAL)) {
    adapter=new FullFactorialAdapter();
  }
 else   if (strategyConfig.getName().equalsIgnoreCase(ScreeningConfiguration.FRACTIONAL_FACTORIAL)) {
    adapter=new FractionalFactorialAdapter();
  }
 else   if (strategyConfig.getName().equalsIgnoreCase(ScreeningConfiguration.PLACKETT_BURMAN)) {
    adapter=new PlackettBurmanAdapter();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + strategyConfig.getName());
  }
  adapter.setParameterVariations(parameterVariations);
  adapter.setExplorationConf(strategyConfig);
  adapter.generateDesign();
  numberOfMeasurements=0;
  executeExperimentSeries(expSeriesRun);
}",0.9847996315062184
5149,"@Override public IExplorationStrategy createExtensionArtifact(){
  return new BreakdownExplorationController(this);
}","@Override public IExplorationStrategy createExtensionArtifact(){
  return new ScreeningDesignExploration(this);
}",0.8782608695652174
5150,"public String getType(){
  return type;
}","public String getType(){
  return type.toUpperCase();
}",0.8541666666666666
5151,"@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((getFullName() == null) ? 0 : getFullName().hashCode());
  result=prime * result + ((role == null) ? 0 : role.hashCode());
  result=prime * result + ((type == null) ? 0 : type.hashCode());
  return result;
}","@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((getFullName() == null) ? 0 : getFullName().hashCode());
  result=prime * result + ((getRole() == null) ? 0 : getRole().hashCode());
  result=prime * result + ((getType() == null) ? 0 : getType().hashCode());
  return result;
}",0.9365079365079364
5152,"public static ExplorationStrategy createExplorationStrategy(String name,Map<String,String> config){
  ExplorationStrategy es=new ExplorationStrategy();
  es.setName(name);
  es.getConfiguration().putAll(config);
  return es;
}","public static ExplorationStrategy createExplorationStrategy(String name,Map<String,String> config){
  ExplorationStrategy es=new ExplorationStrategy();
  es.setName(name);
  if (config != null) {
    es.getConfiguration().putAll(config);
  }
  return es;
}",0.8921161825726142
5153,"/** 
 * Configures the logging system with the provided logger configuration file.
 */
private void configureLogger(){
  LoggerContext lc=(LoggerContext)LoggerFactory.getILoggerFactory();
  String fileName=getPropertyAsStr(CONF_LOGGER_CONFIG_FILE_NAME);
  if (fileName != null) {
    try {
      logger.debug(""String_Node_Str"",fileName);
      JoranConfigurator configurator=new JoranConfigurator();
      configurator.setContext(lc);
      lc.reset();
      configurator.doConfigure(findConfigFileAsInputStream(ClassLoader.getSystemClassLoader(),null,fileName));
    }
 catch (    JoranException je) {
      logger.warn(""String_Node_Str"",je.getMessage());
    }
catch (    FileNotFoundException e) {
      logger.warn(""String_Node_Str"",fileName);
    }
    logger.debug(""String_Node_Str"");
  }
}","/** 
 * Configures the logging system with the provided logger configuration file.
 */
private void configureLogger(){
  String fileName=getPropertyAsStr(CONF_LOGGER_CONFIG_FILE_NAME);
  if (fileName != null) {
    LoggerContext lc=(LoggerContext)LoggerFactory.getILoggerFactory();
    try {
      logger.debug(""String_Node_Str"",fileName);
      JoranConfigurator configurator=new JoranConfigurator();
      configurator.setContext(lc);
      lc.reset();
      configurator.doConfigure(findConfigFileAsInputStream(ClassLoader.getSystemClassLoader(),null,fileName));
    }
 catch (    JoranException je) {
      logger.warn(""String_Node_Str"",je.getMessage());
    }
catch (    FileNotFoundException e) {
      logger.warn(""String_Node_Str"",fileName);
    }
    logger.debug(""String_Node_Str"");
  }
}",0.9121706398996235
5154,"/** 
 * Loads the extensions with basic class loading.
 * @param registry the Eclipse platform extension registry
 * @param eid extension point id
 */
@SuppressWarnings(""String_Node_Str"") private void loadExtensions(){
  final IConfiguration config=Configuration.getSingleton();
  final String pluginsDirName=Tools.concatFileName(config.getAppRootDirectory(),config.getPropertyAsStr(IConfiguration.CONF_PLUGINS_FOLDER));
  final File pluginsDir=new File(pluginsDirName);
  final String defExtensionsFileName=pluginsDirName + File.separatorChar + EXTENSIONS_FILE_NAME;
  final File defExtensionsFile=new File(defExtensionsFileName);
  final String EXTENSION_FILE_PATH=config.DEFAULT_PLUGINS_FOLDER_IN_CLASSPATH + '/' + EXTENSIONS_FILE_NAME;
  Set<URL> extensioInfoURLs=new HashSet<URL>();
  Enumeration<URL> eURLs;
  try {
    eURLs=ClassLoader.getSystemResources(EXTENSION_FILE_PATH);
    while (eURLs.hasMoreElements()) {
      extensioInfoURLs.add(eURLs.nextElement());
    }
    URL enginePathURL=this.getClass().getClassLoader().getResource(EXTENSION_FILE_PATH);
    if (enginePathURL != null) {
      extensioInfoURLs.add(enginePathURL);
    }
  }
 catch (  IOException e1) {
  }
  if (defExtensionsFile.exists()) {
    try {
      extensioInfoURLs.add(new URL(""String_Node_Str"" + defExtensionsFileName));
    }
 catch (    MalformedURLException e1) {
      logger.warn(""String_Node_Str"",defExtensionsFile,e1.getMessage());
    }
  }
  for (  URL url : extensioInfoURLs)   logger.debug(""String_Node_Str"",url);
  if (extensioInfoURLs.size() == 0)   logger.warn(""String_Node_Str"");
  Set<String> extensionClasses=new HashSet<String>();
  for (  URL url : extensioInfoURLs) {
    try {
      extensionClasses.addAll(Tools.readLines(url));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  ClassLoader cl=this.getClass().getClassLoader();
  if (pluginsDir.exists()) {
    String[] names=Tools.getFileNames(pluginsDirName,""String_Node_Str"");
    ArrayList<URL> urls=new ArrayList<URL>();
    if (names.length > 0) {
      for (      String str : names) {
        final String jarName=Tools.concatFileName(pluginsDirName,str);
        try {
          urls.add(new URL(""String_Node_Str"" + jarName));
        }
 catch (        MalformedURLException e) {
          logger.warn(""String_Node_Str"",jarName);
        }
      }
    }
    for (    URL url : urls)     logger.debug(""String_Node_Str"",url);
    cl=new URLClassLoader(urls.toArray(new URL[]{}),this.getClass().getClassLoader());
  }
 else {
    logger.debug(""String_Node_Str"",pluginsDirName);
  }
  for (  String extClassName : extensionClasses) {
    Class<?> c;
    try {
      c=cl.loadClass(extClassName);
      Object o=c.newInstance();
      if (o instanceof ISoPeCoExtension) {
        ISoPeCoExtension ext=(ISoPeCoExtension)o;
        this.addExtension(ext);
        logger.debug(""String_Node_Str"",ext.getName());
      }
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"",new Object[]{extClassName,e.getClass().getSimpleName(),e.getMessage()});
    }
  }
}","/** 
 * Loads the extensions with basic class loading.
 * @param registry the Eclipse platform extension registry
 * @param eid extension point id
 */
@SuppressWarnings(""String_Node_Str"") private void loadExtensions(){
  final IConfiguration config=Configuration.getSingleton();
  final String pluginsDirName=Tools.concatFileName(config.getAppRootDirectory(),config.getPropertyAsStr(IConfiguration.CONF_PLUGINS_FOLDER));
  final File pluginsDir=new File(pluginsDirName);
  final String defExtensionsFileName=pluginsDirName + File.separatorChar + EXTENSIONS_FILE_NAME;
  final File defExtensionsFile=new File(defExtensionsFileName);
  final String EXTENSION_FILE_PATH=config.DEFAULT_PLUGINS_FOLDER_IN_CLASSPATH + '/' + EXTENSIONS_FILE_NAME;
  Set<URL> extensioInfoURLs=new HashSet<URL>();
  Enumeration<URL> eURLs;
  try {
    eURLs=ClassLoader.getSystemResources(EXTENSION_FILE_PATH);
    while (eURLs.hasMoreElements()) {
      extensioInfoURLs.add(eURLs.nextElement());
    }
    URL enginePathURL=this.getClass().getClassLoader().getResource(EXTENSION_FILE_PATH);
    if (enginePathURL != null) {
      extensioInfoURLs.add(enginePathURL);
    }
  }
 catch (  IOException e1) {
  }
  if (defExtensionsFile.exists()) {
    try {
      extensioInfoURLs.add(new URL(""String_Node_Str"" + defExtensionsFileName));
    }
 catch (    MalformedURLException e1) {
      logger.warn(""String_Node_Str"",defExtensionsFile,e1.getMessage());
    }
  }
  for (  URL url : extensioInfoURLs)   logger.debug(""String_Node_Str"",url);
  if (extensioInfoURLs.size() == 0)   logger.warn(""String_Node_Str"");
  Set<String> extensionClasses=new HashSet<String>();
  for (  URL url : extensioInfoURLs) {
    try {
      extensionClasses.addAll(Tools.readLines(url));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  ClassLoader cl=this.getClass().getClassLoader();
  if (pluginsDir.exists()) {
    String[] names=Tools.getFileNames(pluginsDirName,""String_Node_Str"");
    ArrayList<URL> urls=new ArrayList<URL>();
    if (names.length > 0) {
      for (      String str : names) {
        final String jarName=Tools.concatFileName(pluginsDirName,str);
        try {
          urls.add(new URL(""String_Node_Str"",""String_Node_Str"",jarName));
        }
 catch (        MalformedURLException e) {
          logger.warn(""String_Node_Str"",jarName);
        }
      }
    }
    for (    URL url : urls)     logger.debug(""String_Node_Str"",url);
    cl=new URLClassLoader(urls.toArray(new URL[]{}),this.getClass().getClassLoader());
  }
 else {
    logger.debug(""String_Node_Str"",pluginsDirName);
  }
  for (  String extClassName : extensionClasses) {
    Class<?> c;
    try {
      c=cl.loadClass(extClassName);
      Object o=c.newInstance();
      if (o instanceof ISoPeCoExtension) {
        ISoPeCoExtension ext=(ISoPeCoExtension)o;
        this.addExtension(ext);
        logger.debug(""String_Node_Str"",ext.getName());
      }
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"",new Object[]{extClassName,e.getClass().getSimpleName(),e.getMessage()});
    }
  }
}",0.9964146023468058
5155,"/** 
 * Returns the size of observation values if they are consistent (i.e., they are either 1 or the same size). Otherwise, returns -1.
 * @param collection
 * @return -1, if data sizes are inconsistent, otherwise the size of observation parameter value lists.
 */
private int sameSizeOfAllVPLs(Collection<ParameterValueList<?>> collection){
  if (collection.size() <= 1) {
    return 0;
  }
  boolean first=true;
  int relSize=0;
  for (  ParameterValueList pvl : collection) {
    if (first) {
      first=false;
      relSize=pvl.getValues().size();
    }
 else {
      if (pvl.getValues().size() != 1 && pvl.getValues().size() != relSize) {
        return -1;
      }
    }
  }
  return relSize;
}","/** 
 * Returns the size of observation values if they are consistent (i.e., they are either 1 or the same size). Otherwise, returns -1.
 * @param collection
 * @return -1, if data sizes are inconsistent, otherwise the size of observation parameter value lists.
 */
private int sameSizeOfAllVPLs(List<ParameterValueList<?>> collection){
  if (collection.size() == 1) {
    return collection.get(0).getValues().size();
  }
  boolean first=true;
  int relSize=0;
  for (  ParameterValueList pvl : collection) {
    if (first) {
      first=false;
      relSize=pvl.getValues().size();
    }
 else {
      if (pvl.getValues().size() != 1 && pvl.getValues().size() != relSize) {
        return -1;
      }
    }
  }
  return relSize;
}",0.964410327983252
5156,"private Configuration(Class<?> mainClass){
  try {
    setDefaultValues(mainClass);
  }
 catch (  ConfigurationException e) {
    throw new RuntimeException(e);
  }
}","private Configuration(Class<?> mainClass){
  try {
    logger.info(""String_Node_Str"",(mainClass == null ? ""String_Node_Str"" : ""String_Node_Str"" + mainClass.getName() + ""String_Node_Str""));
    setDefaultValues(mainClass);
  }
 catch (  ConfigurationException e) {
    throw new RuntimeException(e);
  }
}",0.7063829787234043
5157,"/** 
 * @return the analysis result as a function string that conforms to theJavaScript syntax
 */
private String getFunctionAsString(){
  String fs=RAdapter.getWrapper().executeRCommandString(""String_Node_Str"" + getId() + ""String_Node_Str"");
  fs=fs.replace(""String_Node_Str"",""String_Node_Str"");
  fs=fs.replace(""String_Node_Str"",""String_Node_Str"");
  fs=fs.replace(""String_Node_Str"",""String_Node_Str"");
  fs=fs.replace(""String_Node_Str"",""String_Node_Str"");
  fs=fs.replaceAll(""String_Node_Str"",""String_Node_Str"");
  return fs;
}","/** 
 * @return the analysis result as a function string that conforms to theJavaScript syntax
 */
private String getFunctionAsString(){
  String fs=RAdapter.getWrapper().executeRCommandString(""String_Node_Str"" + getId() + ""String_Node_Str"");
  fs=fs.replace(""String_Node_Str"",""String_Node_Str"");
  fs=fs.replace(""String_Node_Str"",""String_Node_Str"");
  fs=fs.replace(""String_Node_Str"",""String_Node_Str"");
  fs=fs.replace(""String_Node_Str"",""String_Node_Str"");
  fs=fs.replaceAll(""String_Node_Str"",""String_Node_Str"");
  for (  ParameterDefinition pd : independentParameterDefinitions) {
    fs=fs.replaceAll(pd.getFullName(""String_Node_Str"") + ""String_Node_Str"",pd.getFullName(""String_Node_Str""));
  }
  return fs;
}",0.8392282958199357
5158,"/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Integer getNumberOfExperimentsPerIteration(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(NUMBER_OF_EXPERIMENTS_PER_ITERATION);
  if (value != null) {
    return Integer.valueOf(value);
  }
 else {
    return NUMBER_OF_EXPERIMENTS_PER_ITERATION_DEFAULT_VALUE;
  }
}","/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Integer getNumberOfExperimentsPerIteration(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(NUMBER_OF_EXPERIMENTS_PER_ITERATION);
  if (value != null && !value.isEmpty()) {
    return Integer.valueOf(value);
  }
 else {
    return NUMBER_OF_EXPERIMENTS_PER_ITERATION_DEFAULT_VALUE;
  }
}",0.9799196787148594
5159,"/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static DynamicSectorAccuracyScope getDynamicSectorAccuracyScope(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(DYNAMIC_SECTOR_ACCURACY_SCOPE);
  if (value != null) {
    if (value.equalsIgnoreCase(DynamicSectorAccuracyScope.Local.name())) {
      return DynamicSectorAccuracyScope.Local;
    }
 else     if (value.equalsIgnoreCase(DynamicSectorAccuracyScope.Global.name())) {
      return DynamicSectorAccuracyScope.Global;
    }
  }
 else {
    return DYNAMIC_SECTOR_ACCURACY_SCOPE_DEFAULT_VALUE;
  }
  throw new IllegalArgumentException(""String_Node_Str"" + value);
}","/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static DynamicSectorAccuracyScope getDynamicSectorAccuracyScope(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(DYNAMIC_SECTOR_ACCURACY_SCOPE);
  if (value != null && !value.isEmpty()) {
    if (value.equalsIgnoreCase(DynamicSectorAccuracyScope.Local.name())) {
      return DynamicSectorAccuracyScope.Local;
    }
 else     if (value.equalsIgnoreCase(DynamicSectorAccuracyScope.Global.name())) {
      return DynamicSectorAccuracyScope.Global;
    }
  }
 else {
    return DYNAMIC_SECTOR_ACCURACY_SCOPE_DEFAULT_VALUE;
  }
  throw new IllegalArgumentException(""String_Node_Str"" + value);
}",0.9874055415617128
5160,"/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Integer getBorderMeasurementDepth(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(BORDER_MEASUREMENT_DEPTH);
  if (value != null) {
    return Integer.valueOf(value);
  }
 else {
    return BORDER_MEASUREMENT_DEPTH_DEFAULT_VALUE;
  }
}","/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Integer getBorderMeasurementDepth(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(BORDER_MEASUREMENT_DEPTH);
  if (value != null && !value.isEmpty()) {
    return Integer.valueOf(value);
  }
 else {
    return BORDER_MEASUREMENT_DEPTH_DEFAULT_VALUE;
  }
}",0.9785867237687366
5161,"/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Integer getNumberOfExperimentsPerSectionSplit(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(NUMBER_OF_EXPERIMENTS_PER_SECTION_SPLIT);
  if (value != null) {
    return Integer.valueOf(value);
  }
 else {
    return NUMBER_OF_EXPERIMENTS_PER_SECTION_SPLIT_DEFAULT_VALUE;
  }
}","/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Integer getNumberOfExperimentsPerSectionSplit(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(NUMBER_OF_EXPERIMENTS_PER_SECTION_SPLIT);
  if (value != null && !value.isEmpty()) {
    return Integer.valueOf(value);
  }
 else {
    return NUMBER_OF_EXPERIMENTS_PER_SECTION_SPLIT_DEFAULT_VALUE;
  }
}",0.9803536345776032
5162,"/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Integer getSizeOfValidationSet(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(SIZE_OF_VALIDATION_SET);
  if (value != null) {
    return Integer.valueOf(value);
  }
 else {
    return SIZE_OF_VALIDATION_SET_DEFAULT_VALUE;
  }
}","/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Integer getSizeOfValidationSet(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(SIZE_OF_VALIDATION_SET);
  if (value != null && !value.isEmpty()) {
    return Integer.valueOf(value);
  }
 else {
    return SIZE_OF_VALIDATION_SET_DEFAULT_VALUE;
  }
}",0.9782608695652174
5163,"/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Integer getNumberOfInitialExperiments(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(NUMBER_OF_INITIAL_EXPERIMENTS);
  if (value != null) {
    return Integer.valueOf(value);
  }
 else {
    return NUMBER_OF_INITIAL_EXPERIMENTS_DEFAULT_VALUE;
  }
}","/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Integer getNumberOfInitialExperiments(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(NUMBER_OF_INITIAL_EXPERIMENTS);
  if (value != null && !value.isEmpty()) {
    return Integer.valueOf(value);
  }
 else {
    return NUMBER_OF_INITIAL_EXPERIMENTS_DEFAULT_VALUE;
  }
}",0.9792099792099792
5164,"/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter, <code>null</code> ifthe parameter is not set
 */
public static Long getMaxExplorationTimeInMin(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(MAX_EXPLORATION_TIME_IN_MIN);
  if (value != null) {
    return Long.valueOf(value);
  }
 else {
    return MAX_EXPLORATION_TIME_IN_MIN_DEFAULT_VALUE;
  }
}","/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter, <code>null</code> ifthe parameter is not set
 */
public static Long getMaxExplorationTimeInMin(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(MAX_EXPLORATION_TIME_IN_MIN);
  if (value != null && !value.isEmpty()) {
    return Long.valueOf(value);
  }
 else {
    return MAX_EXPLORATION_TIME_IN_MIN_DEFAULT_VALUE;
  }
}",0.980544747081712
5165,"/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Double getIrrelevantParameterThreshold(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(IRRELEVANT_PARAMETER_THRESHOLD);
  if (value != null) {
    return Double.valueOf(value);
  }
 else {
    return IRRELEVANT_PARAMETER_THRESHOLD_DEFAULT_VALUE;
  }
}","/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Double getIrrelevantParameterThreshold(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(IRRELEVANT_PARAMETER_THRESHOLD);
  if (value != null && !value.isEmpty()) {
    return Double.valueOf(value);
  }
 else {
    return IRRELEVANT_PARAMETER_THRESHOLD_DEFAULT_VALUE;
  }
}",0.979296066252588
5166,"/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Double getDesiredModelAccuracy(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(DESIRED_MODEL_ACCURACY);
  if (value != null) {
    return Double.valueOf(value);
  }
 else {
    return DESIRED_MODEL_ACCURACY_DEFAULT_VALUE;
  }
}","/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Double getDesiredModelAccuracy(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(DESIRED_MODEL_ACCURACY);
  if (value != null && !value.isEmpty()) {
    return Double.valueOf(value);
  }
 else {
    return DESIRED_MODEL_ACCURACY_DEFAULT_VALUE;
  }
}",0.9782135076252724
5167,"/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static AccuracyDetermination getAccuracyDeterminationMethod(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(ACCURACY_DETERMINATION_METHOD);
  if (value != null) {
    if (value.equalsIgnoreCase(AccuracyDetermination.RandomValidationSet.name())) {
      return AccuracyDetermination.RandomValidationSet;
    }
 else     if (value.equalsIgnoreCase(AccuracyDetermination.DynamicSector.name())) {
      return AccuracyDetermination.DynamicSector;
    }
  }
 else {
    return ACCURACY_DETERMINATION_METHOD_DEFAULT_VALUE;
  }
  throw new IllegalArgumentException(""String_Node_Str"" + value);
}","/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static AccuracyDetermination getAccuracyDeterminationMethod(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(ACCURACY_DETERMINATION_METHOD);
  if (value != null && !value.isEmpty()) {
    if (value.equalsIgnoreCase(AccuracyDetermination.RandomValidationSet.name())) {
      return AccuracyDetermination.RandomValidationSet;
    }
 else     if (value.equalsIgnoreCase(AccuracyDetermination.DynamicSector.name())) {
      return AccuracyDetermination.DynamicSector;
    }
  }
 else {
    return ACCURACY_DETERMINATION_METHOD_DEFAULT_VALUE;
  }
  throw new IllegalArgumentException(""String_Node_Str"" + value);
}",0.9876847290640394
5168,"/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Double getDiminutionOfValidation(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(DIMINUTION_OF_VALIDATIONS);
  if (value != null) {
    return Double.valueOf(value);
  }
 else {
    return DIMINUTION_OF_VALIDATIONS_DEFAULT_VALUE;
  }
}","/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter
 */
public static Double getDiminutionOfValidation(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(DIMINUTION_OF_VALIDATIONS);
  if (value != null && !value.isEmpty()) {
    return Double.valueOf(value);
  }
 else {
    return DIMINUTION_OF_VALIDATIONS_DEFAULT_VALUE;
  }
}",0.9785867237687366
5169,"/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter, <code>null</code> ifthe parameter is not set
 */
public static Integer getMaxNumberOfExperiments(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(MAX_NUMBER_OF_EXPERIMENTS);
  if (value != null) {
    return Integer.valueOf(value);
  }
 else {
    return MAX_NUMBER_OF_EXPERIMENTS_DEFAULT_VALUE;
  }
}","/** 
 * @param strategyConfig - the configuration of the exploration strategy provided by the users of SoPeCo
 * @return the value of the configuration parameter, <code>null</code> ifthe parameter is not set
 */
public static Integer getMaxNumberOfExperiments(ExplorationStrategy strategyConfig){
  String value=strategyConfig.getConfiguration().get(MAX_NUMBER_OF_EXPERIMENTS);
  if (value != null && !value.isEmpty()) {
    return Integer.valueOf(value);
  }
 else {
    return MAX_NUMBER_OF_EXPERIMENTS_DEFAULT_VALUE;
  }
}",0.9805825242718448
5170,"@Override public void prepareExperimentSeries(ExperimentSeriesRun experimentSeriesRun,ParameterCollection<ParameterValue<?>> preparationPVs){
  if (experimentSeriesRun == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    this.currentExperimentSeriesRun=experimentSeriesRun;
    this.preparationPVs=preparationPVs;
    meController.prepareExperimentSeries(preparationPVs);
    ParameterCollection<ParameterDefinition> observationParams=ParameterCollectionFactory.createParameterDefinitionCollection(meDefinition.getRoot().getObservationParameters());
    meController.setObservationParameters(observationParams);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","@Override public void prepareExperimentSeries(ExperimentSeriesRun experimentSeriesRun,ParameterCollection<ParameterValue<?>> preparationPVs){
  if (experimentSeriesRun == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (experimentSeriesRun.getExperimentSeries().getName().equals(""String_Node_Str"")) {
    boolean x=true;
  }
  try {
    this.currentExperimentSeriesRun=experimentSeriesRun;
    this.preparationPVs=preparationPVs;
    meController.prepareExperimentSeries(preparationPVs);
    ParameterCollection<ParameterDefinition> observationParams=ParameterCollectionFactory.createParameterDefinitionCollection(meDefinition.getRoot().getObservationParameters());
    meController.setObservationParameters(observationParams);
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.3692501575299307
5171,"public static Object convertValue(Object value,ParameterType type){
switch (type) {
case BOOLEAN:
    if (value instanceof Boolean)     return value;
 else     if (value instanceof Double)     return doubleToBoolean((Double)value);
 else     if (value instanceof Integer)     return integerToBoolean((Integer)value);
 else     if (value instanceof String)     return stringToBoolean((String)value);
  break;
case DOUBLE:
if (value instanceof Double) return value;
 else if (value instanceof Boolean) return booleanToDouble((Boolean)value);
 else if (value instanceof Integer) return ((Integer)value).doubleValue();
 else if (value instanceof String) return Double.parseDouble((String)value);
break;
case INTEGER:
if (value instanceof Integer) return value;
 else if (value instanceof Boolean) return booleanToInteger((Boolean)value);
 else if (value instanceof Double) return ((Double)value).intValue();
 else if (value instanceof String) return Integer.parseInt((String)value);
break;
case STRING:
return value.toString();
default :
break;
}
throw new IllegalArgumentException(""String_Node_Str"" + value + ""String_Node_Str"");
}","public static Object convertValue(Object value,ParameterType type){
switch (type) {
case BOOLEAN:
    if (value instanceof Boolean)     return value;
 else     if (value instanceof Double)     return doubleToBoolean((Double)value);
 else     if (value instanceof Integer)     return integerToBoolean((Integer)value);
 else     if (value instanceof String)     return stringToBoolean((String)value);
  break;
case DOUBLE:
if (value instanceof Double) return value;
 else if (value instanceof Boolean) return booleanToDouble((Boolean)value);
 else if (value instanceof Integer) return ((Integer)value).doubleValue();
 else if (value instanceof String) return Double.parseDouble((String)value);
break;
case INTEGER:
if (value instanceof Integer) return value;
 else if (value instanceof Boolean) return booleanToInteger((Boolean)value);
 else if (value instanceof Double) return ((Double)value).intValue();
 else if (value instanceof String) return Integer.parseInt((String)value);
break;
case STRING:
return (String)value;
default :
break;
}
throw new IllegalArgumentException(""String_Node_Str"" + value + ""String_Node_Str"");
}",0.9924478009773434
5172,"public void extendScenarioInstance(ScenarioDefinition otherSD){
  List<ExperimentSeriesDefinition> esdList=this.getScenarioDefinition().extendBy(otherSD);
  for (  ExperimentSeriesDefinition esd : esdList) {
    ExperimentSeries expSeries=EntityFactory.createExperimentSeries(esd);
    expSeries.setScenarioInstance(this);
    this.getExperimentSeriesList().add(expSeries);
  }
}","public void extendScenarioInstance(ScenarioDefinition otherSD){
  List<ExperimentSeriesDefinition> esdList=this.getScenarioDefinition().extendBy(otherSD);
}",0.5831775700934579
5173,"@Override public ParameterValue<?> get(int pos){
  if (pos < values.size()) {
    return ParameterValueFactory.createParameterValue(dynamicValueAssignment.getParameter(),values.get(pos));
  }
 else {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + pos + ""String_Node_Str""+ values.size()+ ""String_Node_Str"");
  }
}","@Override public ParameterValue<?> get(int pos){
  if (pos < values.size()) {
    return ParameterValueFactory.createParameterValue(dynamicValueAssignment.getParameter(),values.get(pos).getValue());
  }
 else {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + pos + ""String_Node_Str""+ values.size()+ ""String_Node_Str"");
  }
}",0.983358547655068
5174,"protected AbstractBreakdownExplorationExtension(String name){
  NAME=name;
  prepareConfigurationParameterMap();
}","protected AbstractBreakdownExplorationExtension(){
  prepareConfigurationParameterMap();
}",0.8823529411764706
5175,"public AdaptiveEquidistantBreakdownExtension(){
  super(BreakdownConfiguration.ADAPTIVE_EQUIDISTANT_BREAKDOWN);
}","public AdaptiveEquidistantBreakdownExtension(){
  super();
}",0.6936416184971098
5176,"public AdaptiveRandomBreakdownExtension(){
  super(BreakdownConfiguration.ADAPTIVE_RANDOM_BREAKDOWN);
}","public AdaptiveRandomBreakdownExtension(){
  super();
}",0.6962025316455697
5177,"public EquidistantBreakdownExtension(){
  super(BreakdownConfiguration.EQUIDISTANT_BREAKDOWN);
}","public EquidistantBreakdownExtension(){
  super();
}",0.7027027027027027
5178,"public RandomBreakdownExtension(){
  super(BreakdownConfiguration.RANDOM_BREAKDOWN);
}","public RandomBreakdownExtension(){
  super();
}",0.706766917293233
5179,"protected AbstractBreakdownExplorationExtension(){
  prepareConfigurationParameterMap();
}","protected AbstractBreakdownExplorationExtension(String name){
  NAME=name;
  prepareConfigurationParameterMap();
}",0.8823529411764706
5180,"public AdaptiveEquidistantBreakdownExtension(){
  this.NAME=BreakdownConfiguration.EQUIDISTANT_BREAKDOWN;
}","public AdaptiveEquidistantBreakdownExtension(){
  super(BreakdownConfiguration.ADAPTIVE_EQUIDISTANT_BREAKDOWN);
}",0.8909090909090909
5181,"public AdaptiveRandomBreakdownExtension(){
  this.NAME=BreakdownConfiguration.ADAPTIVE_RANDOM_BREAKDOWN;
}","public AdaptiveRandomBreakdownExtension(){
  super(BreakdownConfiguration.ADAPTIVE_RANDOM_BREAKDOWN);
}",0.9282296650717704
5182,"public EquidistantBreakdownExtension(){
  this.NAME=BreakdownConfiguration.EQUIDISTANT_BREAKDOWN;
}","public EquidistantBreakdownExtension(){
  super(BreakdownConfiguration.EQUIDISTANT_BREAKDOWN);
}",0.9230769230769232
5183,"public RandomBreakdownExtension(){
  this.NAME=BreakdownConfiguration.RANDOM_BREAKDOWN;
}","public RandomBreakdownExtension(){
  super(BreakdownConfiguration.RANDOM_BREAKDOWN);
}",0.9142857142857144
5184,"/** 
 * checks if it is time for a validation. The decision is based on the number of elements in the model. We do the following assumptions: <br> 1. Only a few data points in the model means that one new data point influences the prediction of the wide area. Therefore a new data point at the beginning of the measurement series can cause a high prediction error. <br> 2. A lot data points in the model means that one new data point influences the predictio only at it nearest region. Therefore a new data point at the end of the measurement series has a low risk to cause a high prediction error. <br> The conclusion is to decrease the intervals for validation with the number of elements in the model. The number of validations is calculated as a logarithm of the number of Elements in the model with a base given by the attribute   {@link #baseForValidationExecutionCheck}.
 * @return true if a validation should be executed.
 */
protected boolean isTimeForValidation(){
  if (this.baseForValidationExecutionCheck == null) {
    return true;
  }
  Double timestamp=Math.log10(this.cachedEnvironmentAccess.getNumberOfPointsInModel()) / Math.log10(this.baseForValidationExecutionCheck);
  if (timestamp.longValue() > this.lastValidationExecutionTimestamp) {
    this.lastValidationExecutionTimestamp=timestamp.longValue();
    return true;
  }
  return false;
}","/** 
 * checks if it is time for a validation. The decision is based on the number of elements in the model. We do the following assumptions: <br> 1. Only a few data points in the model means that one new data point influences the prediction of the wide area. Therefore a new data point at the beginning of the measurement series can cause a high prediction error. <br> 2. A lot data points in the model means that one new data point influences the predictio only at it nearest region. Therefore a new data point at the end of the measurement series has a low risk to cause a high prediction error. <br> The conclusion is to decrease the intervals for validation with the number of elements in the model. The number of validations is calculated as a logarithm of the number of Elements in the model with a base given by the attribute   {@link #baseForValidationExecutionCheck}.
 * @return true if a validation should be executed.
 */
protected boolean isTimeForValidation(){
  if (this.baseForValidationExecutionCheck == null || this.baseForValidationExecutionCheck == 0) {
    return true;
  }
  Double timestamp=Math.log10(this.cachedEnvironmentAccess.getNumberOfPointsInModel()) / Math.log10(this.baseForValidationExecutionCheck);
  if (timestamp.longValue() > this.lastValidationExecutionTimestamp) {
    this.lastValidationExecutionTimestamp=timestamp.longValue();
    return true;
  }
  return false;
}",0.9837603753157704
5185,"public void validate(){
  if ((hasNewModelPoints && isTimeForValidation()) || !hasMoreIterations()) {
    if (BreakdownConfiguration.getAccuracyDeterminationMethod(strategyConfig).equals(AccuracyDetermination.RandomValidationSet)) {
      if (validationSetManager == null) {
        validationSetManager=new ValidationSetManager(cachedEnvironmentAccess,allParameters);
        validationSetManager.createRandomValidationSet(BreakdownConfiguration.getSizeOfValidationSet(strategyConfig));
      }
 else {
        double avgRelativePredictionError=validationSetManager.getAvgRelativePredictionError();
        if (avgRelativePredictionError < BreakdownConfiguration.getDesiredModelAccuracy(strategyConfig)) {
          accurateEnoughModel=true;
        }
      }
    }
  }
}","public void validate(){
  if ((hasNewModelPoints && isTimeForValidation()) || !hasMoreIterations()) {
    if (BreakdownConfiguration.getAccuracyDeterminationMethod(strategyConfig).equals(AccuracyDetermination.RandomValidationSet)) {
      if (validationSetManager == null) {
        validationSetManager=new ValidationSetManager(cachedEnvironmentAccess,allParameters);
        validationSetManager.createRandomValidationSet(BreakdownConfiguration.getSizeOfValidationSet(strategyConfig));
      }
      double avgRelativePredictionError=validationSetManager.getAvgRelativePredictionError();
      if (avgRelativePredictionError < BreakdownConfiguration.getDesiredModelAccuracy(strategyConfig)) {
        accurateEnoughModel=true;
      }
    }
  }
}",0.9842105263157894
5186,"@Override public void setExtensionRegistry(IExtensionRegistry registry){
  this.extensionRegistry=extensionRegistry;
}","@Override public void setExtensionRegistry(IExtensionRegistry registry){
  this.extensionRegistry=registry;
}",0.9515418502202644
5187,"@Override public void runExperimentSeries(ExperimentSeriesRun expSeriesRun,List<IParameterVariation> parameterVariations){
  createBreakdownImplementation(parameterVariations,expSeriesRun);
  breakdownImpl.initialise();
  if (breakdownImpl.reachedStopCondition()) {
    breakdownImpl.finishWork();
    return;
  }
  breakdownImpl.measureBordersOfParameterSpace();
  while (!breakdownImpl.reachedStopCondition()) {
    breakdownImpl.doIteration();
    breakdownImpl.validate();
  }
  breakdownImpl.finishWork();
}","@Override public void runExperimentSeries(ExperimentSeriesRun expSeriesRun,List<IParameterVariation> parameterVariations){
  if (canRun(expSeriesRun.getExperimentSeries().getExperimentSeriesDefinition())) {
    strategyConfig=expSeriesRun.getExperimentSeries().getExperimentSeriesDefinition().getExplorationStrategy();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + expSeriesRun.getExperimentSeries().getExperimentSeriesDefinition().getExplorationStrategy().getName() + ""String_Node_Str"");
  }
  createBreakdownImplementation(parameterVariations,expSeriesRun);
  breakdownImpl.initialise();
  if (breakdownImpl.reachedStopCondition()) {
    breakdownImpl.finishWork();
    return;
  }
  breakdownImpl.measureBordersOfParameterSpace();
  while (!breakdownImpl.reachedStopCondition()) {
    breakdownImpl.doIteration();
    breakdownImpl.validate();
  }
  breakdownImpl.finishWork();
}",0.7216349541930938
5188,"@Override public void initialise(){
  for (int j=0; j < NUM_INITIAL_MODEL_POINTS; j++) {
    RelativePosition point=createRandomPoint();
    MeasurementCacheResult measuredValue=cachedEnvironmentAccess.measure(point);
    cachedEnvironmentAccess.addToModel(point,measuredValue.value);
  }
}","@Override public void initialise(){
  for (int j=0; j < BreakdownConfiguration.getNumberOfInitialExperiments(); j++) {
    RelativePosition point=createRandomPoint();
    MeasurementCacheResult measuredValue=cachedEnvironmentAccess.measure(point);
    cachedEnvironmentAccess.addToModel(point,measuredValue.value);
  }
}",0.8819672131147541
5189,"/** 
 * calculates the real world position based on a relative one.
 * @param position the relative Position
 * @return a list with {@link ParameterValue}s containing the real world position.
 */
public List<ParameterValue<?>> getRealPosition(RelativePosition position){
  List<ParameterValue<?>> returnList=new ArrayList<ParameterValue<?>>(position.size());
  for (  Entry<String,Double> e : position.entrySet()) {
    IParameterVariation paramVariation=this.parameterVariationIdMap.get(e.getKey());
    int indexInVariation=(int)Math.round(paramVariation.size() * e.getValue());
    returnList.add(paramVariation.get(indexInVariation));
  }
  return returnList;
}","/** 
 * calculates the real world position based on a relative one.
 * @param position the relative Position
 * @return a list with {@link ParameterValue}s containing the real world position.
 */
public List<ParameterValue<?>> getRealPosition(RelativePosition position){
  List<ParameterValue<?>> returnList=new ArrayList<ParameterValue<?>>(position.size());
  for (  Entry<String,Double> e : position.entrySet()) {
    IParameterVariation paramVariation=this.parameterVariationIdMap.get(e.getKey());
    int indexInVariation=(int)Math.ceil(paramVariation.size() * e.getValue()) - 1;
    if (indexInVariation == -1) {
      indexInVariation=0;
    }
    returnList.add(paramVariation.get(indexInVariation));
  }
  return returnList;
}",0.8849177984274482
5190,"/** 
 * Add a value to the analysis model base. And invalidates the analysisResult from the analyser, because the model was modified.
 * @param the relative position the position which is not used at that time
 * @param value the Environment value which has the position info as part of the runInfo.
 * @throws FrameworkException if the data could not be added to the model for any reason.
 */
public void addToModel(RelativePosition position,AbstractEnvironmentValue value){
  List<ParameterValue<?>> realDataPoint=this.getRealPosition(position);
  realDataPoint.add(value.getValue());
  for (  ParameterValue<?> parameterValue : realDataPoint) {
    AbstractDataSetColumn<?> column=null;
    column=modifier.getColumn(parameterValue.getParameter());
    if (column == null) {
      column=modifier.addColumn(parameterValue.getParameter());
    }
    column.getParameterValues().add(parameterValue);
  }
  this.resultIsInvalid=true;
}","/** 
 * Add a value to the analysis model base. And invalidates the analysisResult from the analyser, because the model was modified.
 * @param the relative position the position which is not used at that time
 * @param value the Environment value which has the position info as part of the runInfo.
 * @throws FrameworkException if the data could not be added to the model for any reason.
 */
public void addToModel(RelativePosition position,AbstractEnvironmentValue value){
  List<ParameterValue<?>> realDataPoint=this.getRealPosition(position);
  realDataPoint.add(value.getValue());
  dataSetBuilder.startRow();
  for (  ParameterValue<?> parameterValue : realDataPoint) {
    if (parameterValue.getParameter().getRole().equals(ParameterRole.INPUT)) {
      dataSetBuilder.addInputParameterValue(parameterValue.getParameter(),parameterValue.getValue());
    }
 else {
      dataSetBuilder.addObservationParameterValue(parameterValue.getParameter(),parameterValue.getValue());
    }
  }
  dataSetBuilder.finishRow();
  this.resultIsInvalid=true;
}",0.6690176322418137
5191,"/** 
 * TODO: REMOVE WHEN DATA EXPORT IS AVAILABLE IN THE PERFORMANCE COCKPIT. just for writing the data.
 * @return
 */
public DataSetAggregated getModelDataSet(){
  return this.modifier.getDataSet();
}","/** 
 * TODO: REMOVE WHEN DATA EXPORT IS AVAILABLE IN THE PERFORMANCE COCKPIT. just for writing the data.
 * @return
 */
public DataSetAggregated getModelDataSet(){
  return this.dataSetBuilder.createDataSet();
}",0.9204819277108434
5192,"/** 
 * predicts a value with help of the analysis component.
 * @param position position to be predicted.
 * @return the predicted value.
 * @throws FrameworkException
 */
public AbstractEnvironmentValue predictValue(RelativePosition position){
  if (this.resultIsInvalid) {
    this.analyser.analyse(modifier.getDataSet(),this.analysisConfig);
    this.analysisResult=analyser.getPredictionFunctionResult();
    this.resultIsInvalid=false;
  }
  ParameterValue<?> predictedValue;
  predictedValue=this.analysisResult.predictOutputParameter(this.getRealPosition(position));
  return EnvironmentValueFactory.createAbstractEnvironmentValue(predictedValue);
}","/** 
 * predicts a value with help of the analysis component.
 * @param position position to be predicted.
 * @return the predicted value.
 * @throws FrameworkException
 */
public AbstractEnvironmentValue predictValue(RelativePosition position){
  if (this.resultIsInvalid) {
    this.analyser.analyse(dataSetBuilder.createDataSet(),this.analysisConfig);
    this.analysisResult=analyser.getPredictionFunctionResult();
    this.resultIsInvalid=false;
  }
  ParameterValue<?> predictedValue;
  predictedValue=this.analysisResult.predictOutputParameter(this.getRealPosition(position));
  return EnvironmentValueFactory.createAbstractEnvironmentValue(predictedValue);
}",0.9750566893424036
5193,"private String createFullNamespaceString(String fullNamespace,ParameterNamespace namespace,String namespaceDelimitter){
  if (namespace != null && namespace.getName() != null && !namespace.getName().isEmpty()) {
    ParameterNamespace parent=(ParameterNamespace)namespace.eContainer();
    fullNamespace=namespace.getName() + namespaceDelimitter + fullNamespace;
    return createFullNamespaceString(fullNamespace,parent,namespaceDelimitter);
  }
  return fullNamespace;
}","private String createFullNamespaceString(String fullNamespace,ParameterNamespace namespace,String namespaceDelimitter){
  if (namespace != null && namespace.getName() != null && !namespace.getName().isEmpty()) {
    fullNamespace=namespace.getName() + namespaceDelimitter + fullNamespace;
    if (namespace.eContainer() instanceof ParameterNamespace) {
      ParameterNamespace parent=(ParameterNamespace)namespace.eContainer();
      return createFullNamespaceString(fullNamespace,parent,namespaceDelimitter);
    }
  }
  return fullNamespace;
}",0.5363457760314342
5194,"public void createNamespace(String name){
  ParameterNamespace root=scenarioDefinition.getMeasurementEnvironmentDefinition().getRoot();
  ParameterNamespace namespace=EnvironmentFactory.eINSTANCE.createParameterNamespace();
  namespace.setName(name);
  root.getChildren().add(namespace);
  currentNamespace=namespace;
}","public void createNamespace(String name){
  ParameterNamespace root=scenarioDefinition.getMeasurementEnvironmentDefinition().getRoot();
  ParameterNamespace namespace=EnvironmentFactory.eINSTANCE.createParameterNamespace();
  namespace.setName(name);
  if (currentNamespace == null)   root.getChildren().add(namespace);
 else   currentNamespace.getChildren().add(namespace);
  currentNamespace=namespace;
}",0.88
5195,"@Override public boolean addAll(Collection<? extends V> collection){
  boolean changed=false;
  boolean singleAdd=false;
  for (  V e : collection) {
    singleAdd=add(e);
    changed=changed || singleAdd;
  }
  return changed;
}","@Override public boolean addAll(Collection<? extends V> collection){
  boolean changed=false;
  boolean singleAdd=false;
  if (collection != null) {
    for (    V e : collection) {
      singleAdd=add(e);
      changed=changed || singleAdd;
    }
  }
  return changed;
}",0.824
5196,"/** 
 * Creates a parameter value collection based on the given values.
 * @param parameterValueCollection a collection of parameter values
 * @return a parameter value collection that holds the given parameter values
 */
public static ParameterCollection<ParameterValue<?>> createParameterValueCollection(Collection<ParameterValue<?>> parameterValueCollection){
  final ParameterCollection<ParameterValue<?>> result=new ParameterCollection<ParameterValue<?>>();
  result.addAll(parameterValueCollection);
  return result;
}","/** 
 * Creates a parameter value collection based on the given values.
 * @param parameterValueCollection a collection of parameter values
 * @return a parameter value collection that holds the given parameter values
 */
public static ParameterCollection<ParameterValue<?>> createParameterValueCollection(Collection<ParameterValue<?>> parameterValueCollection){
  if (parameterValueCollection == null) {
    return null;
  }
  final ParameterCollection<ParameterValue<?>> result=new ParameterCollection<ParameterValue<?>>();
  result.addAll(parameterValueCollection);
  return result;
}",0.9432943294329432
5197,"@Override public void runExperimentSeries(ExperimentSeries expSeries,List<IParameterVariation> parameterVariations){
  initialiseExplorationStrategy(parameterVariations);
  executeExperimentSeries(expSeries.getExperimentSeriesDefinition().getExperimentTerminationCondition());
}","@Override public void runExperimentSeries(ExperimentSeriesRun expSeriesRun,List<IParameterVariation> parameterVariations){
  initialiseExplorationStrategy(parameterVariations);
  executeExperimentSeries(expSeriesRun.getExperimentSeries().getExperimentSeriesDefinition().getExperimentTerminationCondition());
}",0.9131175468483816
5198,"@Test public void testRunExperimentSeries(){
  IExtensionRegistry er=engine.getExtensionRegistry();
  IParameterVariation ipv=er.getExtensionArtifact(IParameterVariationExtension.class,VARIATION_NAME);
  assertNotNull(ipv);
  List<IParameterVariation> ipvList=new ArrayList<IParameterVariation>();
  ipvList.add(ipv);
  ExperimentSeries es=new ExperimentSeries();
  es.setName(expSeriesDef.getName());
  fes.runExperimentSeries(es,ipvList);
}","@Test public void testRunExperimentSeries(){
  IExtensionRegistry er=engine.getExtensionRegistry();
  IParameterVariation ipv=er.getExtensionArtifact(IParameterVariationExtension.class,VARIATION_NAME);
  assertNotNull(ipv);
  List<IParameterVariation> ipvList=new ArrayList<IParameterVariation>();
  ipvList.add(ipv);
  ExperimentSeries es=new ExperimentSeries();
  es.setName(expSeriesDef.getName());
  ExperimentSeriesRun esr=new ExperimentSeriesRun();
  esr.setTimestamp(System.nanoTime());
  esr.setExperimentSeries(es);
  es.getExperimentSeriesRuns().add(esr);
  fes.runExperimentSeries(esr,ipvList);
}",0.8427073403241182
5199,"@Test public void testFullExplorationStrategy(){
  Map<String,String> config=new HashMap<String,String>();
  config.put(""String_Node_Str"",String.valueOf(4));
  config.put(""String_Node_Str"",String.valueOf(28));
  config.put(""String_Node_Str"",String.valueOf(12));
  dva=builder.createDynamicValueAssignment(VARIATION_NAME,pdef,config);
  IParameterVariation ipv=registry.getExtensionArtifact(IParameterVariationExtension.class,VARIATION_NAME);
  assertNotNull(ipv);
  ipv.initialize(dva);
  List<IParameterVariation> ipvList=new ArrayList<IParameterVariation>();
  ipvList.add(ipv);
  IExplorationStrategy fes=registry.getExtensionArtifact(IExplorationStrategyExtension.class,FULL_EXPLORATION_STRATEGY_NAME);
  assertNotNull(fes);
  fes.setExperimentController(expController);
  ExperimentSeries es=new ExperimentSeries();
  es.setExperimentSeriesDefinition(expSeriesDef);
  es.setName(expSeriesDef.getName());
  fes.runExperimentSeries(es,ipvList);
}","@Test public void testFullExplorationStrategy(){
  Map<String,String> config=new HashMap<String,String>();
  config.put(""String_Node_Str"",String.valueOf(4));
  config.put(""String_Node_Str"",String.valueOf(28));
  config.put(""String_Node_Str"",String.valueOf(12));
  dva=builder.createDynamicValueAssignment(VARIATION_NAME,pdef,config);
  IParameterVariation ipv=registry.getExtensionArtifact(IParameterVariationExtension.class,VARIATION_NAME);
  assertNotNull(ipv);
  ipv.initialize(dva);
  List<IParameterVariation> ipvList=new ArrayList<IParameterVariation>();
  ipvList.add(ipv);
  IExplorationStrategy fes=registry.getExtensionArtifact(IExplorationStrategyExtension.class,FULL_EXPLORATION_STRATEGY_NAME);
  assertNotNull(fes);
  fes.setExperimentController(expController);
  ExperimentSeries es=new ExperimentSeries();
  es.setName(expSeriesDef.getName());
  fes.runExperimentSeries(es,ipvList);
}",0.9642857142857144
5200,"@Override public ScenarioInstance run(ScenarioDefinition scenario){
  ScenarioInstance scenarioInstance=new ScenarioInstance();
  scenarioInstance.setMeasurementEnvironmentUrl(getConfiguration().getProperty(IConfiguration.CONF_MEASUREMENT_CONTROLLER_URI).toString());
  scenarioInstance.setName(scenario.getName());
  persistenceProvider.store(scenarioInstance);
  experimentController.initialize(EngineTools.getConstantParameterValues(scenario.getMeasurementSpecification().getInitializationAssignemts()),scenario.getMeasurementEnvironmentDefinition());
  for (  ExperimentSeriesDefinition esd : scenario.getMeasurementSpecification().getExperimentSeriesDefinitions()) {
    ExperimentSeries series=new ExperimentSeries();
    series.setExperimentSeriesDefinition(esd);
    series.setName(esd.getName());
    series.setScenarioInstance(scenarioInstance);
    persistenceProvider.store(series);
    scenarioInstance.getExperimentSeries().add(series);
    experimentSeriesManager.runExperimentSeries(series);
  }
  try {
    ScenarioInstance loadedScenario=persistenceProvider.loadScenarioInstance(scenarioInstance.getPrimaryKey());
    return loadedScenario;
  }
 catch (  DataNotFoundException e) {
    logger.error(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"");
  }
}","@Override public ScenarioInstance run(ScenarioDefinition scenario){
  ScenarioInstance scenarioInstance=PersistenceProviderFactory.createScenarioInstance(scenario,getConfiguration().getProperty(IConfiguration.CONF_MEASUREMENT_CONTROLLER_URI).toString());
  persistenceProvider.store(scenarioInstance);
  experimentController.initialize(EngineTools.getConstantParameterValues(scenario.getMeasurementSpecification().getInitializationAssignemts()),scenario.getMeasurementEnvironmentDefinition());
  for (  ExperimentSeriesDefinition esd : scenario.getMeasurementSpecification().getExperimentSeriesDefinitions()) {
    ExperimentSeries series=PersistenceProviderFactory.createExperimentSeries(scenarioInstance,esd);
    persistenceProvider.store(series);
    experimentSeriesManager.runExperimentSeries(series);
  }
  try {
    ScenarioInstance loadedScenario=persistenceProvider.loadScenarioInstance(scenarioInstance.getPrimaryKey());
    return loadedScenario;
  }
 catch (  DataNotFoundException e) {
    logger.error(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.8239731768650461
5201,"@Override public void prepareExperimentSeries(ExperimentSeriesRun experimentSeriesRun,Collection<ParameterValue<?>> preparationPVList){
  if (experimentSeriesRun == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.currentExperimentSeriesRun=experimentSeriesRun;
  meController.prepareExperimentSeries(preparationPVList);
  List<ParameterDefinition> observationParameterList=new ArrayList<ParameterDefinition>();
  collectObservationParameters(meDefinition.getRoot(),observationParameterList);
  meController.setObservationParameters(observationParameterList);
}","@Override public void prepareExperimentSeries(ExperimentSeriesRun experimentSeriesRun,Collection<ParameterValue<?>> preparationPVList){
  if (experimentSeriesRun == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.currentExperimentSeriesRun=experimentSeriesRun;
  meController.prepareExperimentSeries(preparationPVList);
  List<ParameterDefinition> observationParameterList=new ArrayList<ParameterDefinition>();
  ScenarioDefinitionUtil.collectObservationParameters(meDefinition.getRoot(),observationParameterList);
  meController.setObservationParameters(observationParameterList);
}",0.9808811305070656
5202,"/** 
 * Loads a SoPeCo configuration   {@link EObject} from an XMI representation.
 * @param str the XMI representation 
 * @return an {@link EObject} instance
 * @throws IOException
 */
public static EObject loadFromSting(String str) throws IOException {
  InputStream is=new ByteArrayInputStream(str.getBytes());
  EObject eObject=ModelUtils.load(is,""String_Node_Str"",createSoPeCoModelResourceSet());
  return eObject;
}","/** 
 * Loads a SoPeCo configuration   {@link EObject} from an XMI representation.
 * @param str the XMI representation 
 * @return an {@link EObject} instance
 * @throws IOException
 */
public static EObject loadFromSting(String str) throws IOException {
  SoPeCoModelFactoryHandler.initFactories();
  InputStream is=new ByteArrayInputStream(str.getBytes());
  EObject eObject=ModelUtils.load(is,""String_Node_Str"",createSoPeCoModelResourceSet());
  return eObject;
}",0.9493813273340832
5203,"/** 
 * Loads a SoPeCo scenario definition from the given URI.
 * @param uri URI of the scenario configuration
 * @return an instance of Scenario Definition 
 * @throws IOException 
 */
public static EObject loadFromURI(URI uri) throws IOException {
  return ModelUtils.load(uri,createSoPeCoModelResourceSet());
}","/** 
 * Loads a SoPeCo scenario definition from the given URI.
 * @param uri URI of the scenario configuration
 * @return an instance of Scenario Definition 
 * @throws IOException 
 */
public static EObject loadFromURI(URI uri) throws IOException {
  SoPeCoModelFactoryHandler.initFactories();
  return ModelUtils.load(uri,createSoPeCoModelResourceSet());
}",0.932935916542474
5204,"/** 
 * Creates a new instance of the   {@link ScenarioInstance} entity. Sets the name and measurementEnvironmentUrl according to the given parameters.
 * @param scenarioDefinition
 * @param measurementEnvironmentUrl
 * @return a new instance of {@link ScenarioInstance} based on the given parameters
 */
public static ScenarioInstance createScenarioInstance(ScenarioDefinition scenarioDefinition,String measurementEnvironmentUrl){
  ScenarioInstance si=new ScenarioInstance();
  si.setName(scenarioDefinition.getName());
  si.setMeasurementEnvironmentUrl(measurementEnvironmentUrl);
  return si;
}","/** 
 * Creates a new instance of the   {@link ScenarioInstance} entity. Sets the name and measurementEnvironmentUrl according to the given parameters.
 * @param scenarioDefinition
 * @param measurementEnvironmentUrl
 * @return a new instance of {@link ScenarioInstance} based on the given parameters
 */
public static ScenarioInstance createScenarioInstance(ScenarioDefinition scenarioDefinition,String measurementEnvironmentUrl){
  ScenarioInstance si=new ScenarioInstance();
  si.setScenarioDefinition(scenarioDefinition);
  si.setName(scenarioDefinition.getName());
  si.setMeasurementEnvironmentUrl(measurementEnvironmentUrl);
  return si;
}",0.9614147909967846
5205,"/** 
 * Creates a new instance of the   {@link ExperimentSeries} entity. Sets the name, experimentDefintion and scenarioInstance according to the given parameters. Adds the newly created instance to the given scenarioInstance (resolving the relationship).
 * @param scenarioInstance
 * @param expSeriesDefinition
 * @return a new instance of {@link ExperimentSeries} based on the given parameters
 */
public static ExperimentSeries createExperimentSeries(ScenarioInstance scenarioInstance,ExperimentSeriesDefinition expSeriesDefinition){
  ExperimentSeries expSeries=new ExperimentSeries();
  expSeries.setName(expSeriesDefinition.getName());
  expSeries.setExperimentSeriesDefinition(expSeriesDefinition);
  expSeries.setScenarioInstance(scenarioInstance);
  scenarioInstance.getExperimentSeries().add(expSeries);
  return expSeries;
}","/** 
 * Creates a new instance of the   {@link ExperimentSeries} entity. Sets the name, experimentDefintion and scenarioInstance according to the given parameters. Adds the newly created instance to the given scenarioInstance (resolving the relationship).
 * @param scenarioInstance
 * @param expSeriesDefinition
 * @return a new instance of {@link ExperimentSeries} based on the given parameters
 */
public static ExperimentSeries createExperimentSeries(ScenarioInstance scenarioInstance,ExperimentSeriesDefinition expSeriesDefinition){
  ExperimentSeries expSeries=new ExperimentSeries();
  expSeries.setName(expSeriesDefinition.getName());
  expSeries.setScenarioInstance(scenarioInstance);
  scenarioInstance.getExperimentSeries().add(expSeries);
  return expSeries;
}",0.9601990049751244
5206,"public ExperimentSeriesDefinition getExperimentSeriesDefinition(){
  ExperimentSeriesDefinition returnValue;
  try {
    returnValue=(ExperimentSeriesDefinition)EMFUtil.loadFromSting(this.experimentSeriesDefinition);
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return returnValue;
}","public ExperimentSeriesDefinition getExperimentSeriesDefinition(){
  ExperimentSeriesDefinition returnValue;
  ScenarioDefinition sd=this.scenarioInstance.getScenarioDefinition();
  returnValue=ScenarioDefinitionUtil.getExperimentSeriesDefinition(this.getName(),sd);
  return returnValue;
}",0.4271844660194174
5207,"/** 
 * Adds a set of new values to the column under construction (created by startColumn).
 * @param valueList Values to be added.
 */
public void addObservationValueLists(List<ParameterValueList> valueLists){
  if (nextColumn == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!(nextColumn instanceof DataSetInputColumn)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  ((DataSetObservationColumn)nextColumn).getValueLists().addAll(valueLists);
}","/** 
 * Adds a set of new values to the column under construction (created by startColumn).
 * @param valueList Values to be added.
 */
public void addObservationValueLists(List<ParameterValueList> valueLists){
  if (nextColumn == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!(nextColumn instanceof DataSetObservationColumn)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  ((DataSetObservationColumn)nextColumn).getValueLists().addAll(valueLists);
}",0.9837728194726166
5208,"public static DataSetAggregated createDummyResultDataSet(){
  DataSetColumnBuilder builder=new DataSetColumnBuilder();
  builder.startInputColumn(createDummyInputParameterDefinition(""String_Node_Str""));
  builder.addInputValue(1);
  builder.addInputValue(2);
  builder.finishColumn();
  builder.startObservationColumn(createDummyObservationParameterDefinition(""String_Node_Str""));
  ArrayList<Object> obsValues1=new ArrayList<Object>();
  obsValues1.add(10);
  obsValues1.add(10);
  builder.addObservationValues(obsValues1);
  ArrayList<Object> obsValues2=new ArrayList<Object>();
  obsValues2.add(20);
  obsValues2.add(20);
  builder.addObservationValues(obsValues2);
  builder.finishColumn();
  return builder.createDataSet();
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static DataSetAggregated createDummyResultDataSet(){
  DataSetColumnBuilder builder=new DataSetColumnBuilder();
  builder.startInputColumn(createDummyInputParameterDefinition(""String_Node_Str""));
  builder.addInputValue(1);
  builder.addInputValue(2);
  builder.finishColumn();
  ParameterDefinition paramDef=createDummyObservationParameterDefinition(""String_Node_Str"");
  ArrayList<ParameterValueList> obsValueLists=new ArrayList<ParameterValueList>();
  builder.startObservationColumn(paramDef);
  ArrayList<Object> obsValues1=new ArrayList<Object>();
  obsValues1.add(10);
  obsValues1.add(10);
  obsValueLists.add(new ParameterValueList<Object>(paramDef,obsValues1));
  ArrayList<Object> obsValues2=new ArrayList<Object>();
  obsValues2.add(20);
  obsValues2.add(20);
  obsValueLists.add(new ParameterValueList(paramDef,obsValues2));
  builder.addObservationValueLists(obsValueLists);
  builder.finishColumn();
  return builder.createDataSet();
}",0.731651376146789
5209,"@Override public String getFullName(){
  ParameterNamespace namespace=this.getNamespace();
  String result=createFullNamespaceString(""String_Node_Str"",namespace) + getName();
  System.out.println(result);
  return result;
}","@Override public String getFullName(){
  ParameterNamespace namespace=this.getNamespace();
  String result=createFullNamespaceString(""String_Node_Str"",namespace) + getName();
  return result;
}",0.9278846153846154
5210,"public static ScenarioInstance createDummyScenarioInstance(){
  ScenarioInstance scenarioInstance=new ScenarioInstance();
  scenarioInstance.setName(""String_Node_Str"");
  scenarioInstance.setMeasurementEnvironmentUrl(""String_Node_Str"");
  scenarioInstance.getExperimentSeries().addAll(createDummyExperimentSeries(2,scenarioInstance));
  return scenarioInstance;
}","public static ScenarioInstance createDummyScenarioInstance(){
  SoPeCoModelFactoryHandler.initFactories();
  ScenarioInstance scenarioInstance=new ScenarioInstance();
  scenarioInstance.setName(""String_Node_Str"");
  scenarioInstance.setMeasurementEnvironmentUrl(""String_Node_Str"");
  scenarioInstance.getExperimentSeries().addAll(createDummyExperimentSeries(2,scenarioInstance));
  return scenarioInstance;
}",0.9416342412451362
5211,"public List<ExperimentSeriesRun> getExperimentSeries(){
  return experimentSeries;
}","public List<ExperimentSeries> getExperimentSeries(){
  return experimentSeries;
}",0.9818181818181818
5212,"/** 
 * Creates a new InnerClass with the specified properties.
 * @param accessSpecifier
 * @param isAbstract
 * @param isFinal
 * @param isImmutable
 * @param sinceSpecifier
 * @param name
 * @param isStatic
 * @param outerClass
 */
public InnerClass(AccessSpecifier accessSpecifier,boolean isAbstract,boolean isFinal,boolean isImmutable,SinceSpecifier sinceSpecifier,String name,boolean isStatic,ConceptualClass outerClass){
  super(accessSpecifier,isAbstract,isFinal,isImmutable,sinceSpecifier,name);
  this.isStatic=isStatic;
  this.outerClass=outerClass;
}","/** 
 * Creates a new InnerClass with the specified properties.
 * @param accessSpecifier
 * @param isAbstract
 * @param isFinal
 * @param isImmutable
 * @param sinceSpecifier
 * @param name
 * @param isStatic
 */
public InnerClass(AccessSpecifier accessSpecifier,boolean isAbstract,boolean isFinal,boolean isImmutable,SinceSpecifier sinceSpecifier,String name,boolean isStatic){
  super(accessSpecifier,isAbstract,isFinal,isImmutable,sinceSpecifier,name);
  this.isStatic=isStatic;
}",0.9254302103250478
5213,"/** 
 * Creates a new InnerClass with the specified properties.
 * @param accessSpecifier
 * @param isAbstract
 * @param isFinal
 * @param isImmutable
 * @param sinceSpecifier
 * @param name
 * @param typeArguments
 * @param baseClass
 * @param interfaces
 * @param isStatic
 * @param outerClass
 */
public InnerClass(AccessSpecifier accessSpecifier,boolean isAbstract,boolean isFinal,boolean isImmutable,SinceSpecifier sinceSpecifier,String name,TypeArgument[] typeArguments,PointerType baseClass,PointerType[] interfaces,boolean isStatic,ConceptualClass outerClass){
  super(accessSpecifier,isAbstract,isFinal,isImmutable,sinceSpecifier,name,typeArguments,baseClass,interfaces);
  this.isStatic=isStatic;
  this.outerClass=outerClass;
}","/** 
 * Creates a new InnerClass with the specified properties.
 * @param accessSpecifier
 * @param isAbstract
 * @param isFinal
 * @param isImmutable
 * @param sinceSpecifier
 * @param name
 * @param isStatic
 * @param outerClass
 */
public InnerClass(AccessSpecifier accessSpecifier,boolean isAbstract,boolean isFinal,boolean isImmutable,SinceSpecifier sinceSpecifier,String name,boolean isStatic,ConceptualClass outerClass){
  super(accessSpecifier,isAbstract,isFinal,isImmutable,sinceSpecifier,name);
  this.isStatic=isStatic;
  this.outerClass=outerClass;
}",0.8646153846153846
5214,"private void resolveImports() throws ConceptualException {
  for (  CompilationUnitAST compilationUnit : compilationUnits) {
    Scope fileScope=fileScopes.get(compilationUnit);
    ImportDeclarationAST[] imports=compilationUnit.getImports();
    for (    ImportDeclarationAST importDeclaration : imports) {
      Scope importScope=fileScope.lookup(importDeclaration.getName().getNameStrings());
      if (importScope == null) {
        throw new ConceptualException(""String_Node_Str"" + importDeclaration.getName(),importDeclaration.getName().getParseInfo());
      }
      if (importDeclaration.isAll()) {
        fileScope.copyChildren(importScope);
      }
 else {
        NameAST[] names=importDeclaration.getName().getNames();
        String name=names[names.length - 1].getName();
        try {
          fileScope.addChild(name,importScope);
        }
 catch (        ScopeException e) {
          throw new ConceptualException(""String_Node_Str"" + name,importDeclaration.getParseInfo());
        }
      }
    }
  }
}","private void resolveImports() throws ConceptualException {
  Map<CompilationUnitAST,Scope> fileScopes=nameScanner.getFileScopes();
  for (  CompilationUnitAST compilationUnit : compilationUnits) {
    Scope fileScope=fileScopes.get(compilationUnit);
    ImportDeclarationAST[] imports=compilationUnit.getImports();
    for (    ImportDeclarationAST importDeclaration : imports) {
      Scope importScope=fileScope.lookup(importDeclaration.getName().getNameStrings());
      if (importScope == null) {
        throw new ConceptualException(""String_Node_Str"" + importDeclaration.getName(),importDeclaration.getName().getParseInfo());
      }
      if (importDeclaration.isAll()) {
        fileScope.copyChildren(importScope);
      }
 else {
        NameAST[] names=importDeclaration.getName().getNames();
        String name=names[names.length - 1].getName();
        try {
          fileScope.addChild(name,importScope);
        }
 catch (        ScopeException e) {
          throw new ConceptualException(""String_Node_Str"" + name,importDeclaration.getParseInfo());
        }
      }
    }
  }
}",0.9660377358490566
5215,"/** 
 * Translates the ASTs provided to this object's constructor into a conceptual object heirarchy.
 */
public void translate(){
  try {
    for (    CompilationUnitAST compilationUnit : compilationUnits) {
      nameScanner.scanCompilationUnit(compilationUnit);
    }
  }
 catch (  ScopeException e) {
    e.printStackTrace();
  }
}","/** 
 * Translates the ASTs provided to this object's constructor into a conceptual object heirarchy.
 */
public void translate(){
  try {
    for (    CompilationUnitAST compilationUnit : compilationUnits) {
      nameScanner.scanCompilationUnit(compilationUnit);
    }
  }
 catch (  ScopeException e) {
    e.printStackTrace();
  }
catch (  ConceptualException e) {
    e.printStackTrace();
  }
}",0.9113233287858116
5216,"/** 
 * Sets the members of this enum constant.
 * @param staticInitializer
 * @param constructors
 * @param properties
 * @param variables
 * @param variableInitializers
 * @param methods
 */
public void setMembers(StaticInitializer staticInitializer,Constructor[] constructors,Property[] properties,MemberVariable[] variables,VariableInitializers variableInitializers,Method[] methods){
  this.staticInitializer=staticInitializer;
  this.constructors=constructors;
  this.properties=properties;
  this.variables=variables;
  this.variableInitializers=variableInitializers;
  this.methods=methods;
}","/** 
 * Sets the members of this enum constant.
 * @param staticInitializer
 * @param variableInitializers
 * @param variables
 * @param properties
 * @param constructors
 * @param methods
 * @param innerClasses
 * @param innerInterfaces
 * @param innerEnums
 */
public void setMembers(StaticInitializer staticInitializer,VariableInitializers variableInitializers,MemberVariable[] variables,Property[] properties,Constructor[] constructors,Method[] methods,InnerClass[] innerClasses,ConceptualInterface[] innerInterfaces,ConceptualEnum[] innerEnums){
  this.staticInitializer=staticInitializer;
  this.variableInitializers=variableInitializers;
  this.variables=variables;
  this.properties=properties;
  this.constructors=constructors;
  this.methods=methods;
  this.innerClasses=innerClasses;
  this.innerInterfaces=innerInterfaces;
  this.innerEnums=innerEnums;
}",0.5266030013642565
5217,"/** 
 * Converts the specified EnumDefinitionAST into a ConceptualEnum
 * @param enumDefinitionAST - the EnumDefinitionAST to convert
 * @param enclosingScope - the scope to make the parent of the new conceptual object's scope
 * @return the Scope of the ConceptualEnum created, which has the ConceptualEnum as its value
 * @throws ConceptualException - if there is a problem with the conversion
 */
private Scope convertInnerEnum(EnumDefinitionAST enumDefinitionAST,Scope enclosingScope) throws ConceptualException {
  return convert(enumDefinitionAST,enclosingScope);
}","/** 
 * Converts the specified EnumDefinitionAST into a ConceptualEnum
 * @param enumDefinitionAST - the EnumDefinitionAST to convert
 * @param enclosingScope - the scope to make the parent of the new conceptual object's scope
 * @return the Scope of the ConceptualEnum created, which has the ConceptualEnum as its value
 * @throws ConceptualException - if there is a problem with the conversion
 * @throws ScopeException - if there is a scope collision
 */
private Scope convertInnerEnum(EnumDefinitionAST enumDefinitionAST,Scope enclosingScope) throws ConceptualException, ScopeException {
  return convert(enumDefinitionAST,enclosingScope);
}",0.9391447368421052
5218,"/** 
 * Converts the specified InterfaceDefinitionAST into a ConceptualInterface
 * @param interfaceDefinitionAST - the InterfaceDefinitionAST to convert
 * @param enclosingScope - the scope to make the parent of the new conceptual object's scope
 * @return the Scope of the ConceptualInterface created, which has the ConceptualInterface as its value
 * @throws ConceptualException - if there is a problem with the conversion
 */
private Scope convertInnerInterface(InterfaceDefinitionAST interfaceDefinitionAST,Scope enclosingScope) throws ConceptualException {
  return convert(interfaceDefinitionAST,enclosingScope);
}","/** 
 * Converts the specified InterfaceDefinitionAST into a ConceptualInterface
 * @param interfaceDefinitionAST - the InterfaceDefinitionAST to convert
 * @param enclosingScope - the scope to make the parent of the new conceptual object's scope
 * @return the Scope of the ConceptualInterface created, which has the ConceptualInterface as its value
 * @throws ConceptualException - if there is a problem with the conversion
 * @throws ScopeException - if there is a scope collision
 */
private Scope convertInnerInterface(InterfaceDefinitionAST interfaceDefinitionAST,Scope enclosingScope) throws ConceptualException, ScopeException {
  return convert(interfaceDefinitionAST,enclosingScope);
}",0.9437689969604864
5219,"/** 
 * Converts the specified ClassDefinitionAST into an InnerClass
 * @param classDefinitionAST - the ClassDefinitionAST to convert
 * @param enclosingScope - the scope to make the parent of the new conceptual object's scope
 * @return the Scope of the InnerClass created, which has the InnerClass as its value
 * @throws ConceptualException - if there is a problem with the conversion
 */
private Scope convertInnerClass(ClassDefinitionAST classDefinitionAST,Scope enclosingScope) throws ConceptualException {
  AccessSpecifier access=convert(classDefinitionAST.getAccess(),AccessSpecifier.PUBLIC);
  ModifierAST[] modifiers=classDefinitionAST.getModifiers();
  boolean isAbstract=false;
  boolean isSealed=false;
  boolean isImmutable=false;
  boolean isStatic=false;
  SinceSpecifier sinceSpecifier=null;
  for (  ModifierAST modifier : modifiers) {
switch (modifier.getType()) {
case ABSTRACT:
      isAbstract=true;
    break;
case SEALED:
  isSealed=true;
break;
case STATIC:
isStatic=true;
break;
case IMMUTABLE:
isImmutable=true;
break;
case SINCE_SPECIFIER:
sinceSpecifier=convert((SinceSpecifierAST)modifier);
break;
default :
throw new ConceptualException(""String_Node_Str"",modifier.getParseInfo());
}
}
InnerClass conceptualClass=new InnerClass(access,isAbstract,isSealed,isImmutable,sinceSpecifier,classDefinitionAST.getName().getName(),isStatic);
Scope scope=ScopeFactory.createClassDefinitionScope(conceptualClass,enclosingScope);
scopes.put(conceptualClass,scope);
addClassData(scope,classDefinitionAST);
return scope;
}","/** 
 * Converts the specified ClassDefinitionAST into an InnerClass
 * @param classDefinitionAST - the ClassDefinitionAST to convert
 * @param enclosingScope - the scope to make the parent of the new conceptual object's scope
 * @return the Scope of the InnerClass created, which has the InnerClass as its value
 * @throws ConceptualException - if there is a problem with the conversion
 * @throws ScopeException - if there is a scope collision
 */
private Scope convertInnerClass(ClassDefinitionAST classDefinitionAST,Scope enclosingScope) throws ConceptualException, ScopeException {
  AccessSpecifier access=convert(classDefinitionAST.getAccess(),AccessSpecifier.PUBLIC);
  ModifierAST[] modifiers=classDefinitionAST.getModifiers();
  boolean isAbstract=false;
  boolean isSealed=false;
  boolean isImmutable=false;
  boolean isStatic=false;
  SinceSpecifier sinceSpecifier=null;
  for (  ModifierAST modifier : modifiers) {
switch (modifier.getType()) {
case ABSTRACT:
      isAbstract=true;
    break;
case SEALED:
  isSealed=true;
break;
case STATIC:
isStatic=true;
break;
case IMMUTABLE:
isImmutable=true;
break;
case SINCE_SPECIFIER:
sinceSpecifier=convert((SinceSpecifierAST)modifier);
break;
default :
throw new ConceptualException(""String_Node_Str"",modifier.getParseInfo());
}
}
InnerClass conceptualClass=new InnerClass(access,isAbstract,isSealed,isImmutable,sinceSpecifier,classDefinitionAST.getName().getName(),isStatic);
Scope scope=ScopeFactory.createClassDefinitionScope(conceptualClass,enclosingScope);
scopes.put(conceptualClass,scope);
addClassData(scope,classDefinitionAST);
return scope;
}",0.9765079365079364
5220,"/** 
 * Generates the parse table for the set of rules passed into this parser generator. The parse table can be obtained from the getStartState() function.
 */
public void generate(){
  Rule startRule=rules.getStartRule();
  LALRItemSet initialSet=new LALRItemSet();
  int productionCount=startRule.getProductions().length;
  for (int i=0; i < productionCount; i++) {
    LALRItem startItem=new LALRItem(startRule,i,0);
    startItem.addLookahead(null);
    initialSet.addKernelItem(startItem);
  }
  initialSet.calculateClosureItems(rules);
  Map<LALRItemSet,LALRItemSet> itemSets=new HashMap<LALRItemSet,LALRItemSet>();
  itemSets.put(initialSet,initialSet);
  Deque<LALRItemSet> stack=new LinkedList<LALRItemSet>();
  stack.add(initialSet);
  Map<LALRItemSet,Map<Object,LALRItemSet>> transitions=new HashMap<LALRItemSet,Map<Object,LALRItemSet>>();
  while (!stack.isEmpty()) {
    LALRItemSet set=stack.pop();
    Map<Object,LALRItemSet> setTransitions=findTransitions(set);
    for (    Entry<Object,LALRItemSet> transition : setTransitions.entrySet()) {
      LALRItemSet transitionSet=transition.getValue();
      transitionSet.calculateClosureItems(rules);
      LALRItemSet existingSet=itemSets.get(transitionSet);
      if (existingSet == null) {
        itemSets.put(transitionSet,transitionSet);
        stack.add(transitionSet);
        continue;
      }
      if (existingSet.containsLookaheads(transitionSet)) {
        continue;
      }
      existingSet.combineLookaheads(transitionSet);
      existingSet.calculateClosureItems(rules);
      transition.setValue(existingSet);
      stack.add(existingSet);
    }
    transitions.put(set,setTransitions);
  }
  startState=generateStates(initialSet,transitions,itemSets.keySet());
}","/** 
 * Generates the parse table for the set of rules passed into this parser generator. The parse table can be obtained from the getStartState() function.
 */
public void generate(){
  final Rule startRule=rules.getStartRule();
  Object generatedStartRuleType=new Object(){
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
;
  Rule newStartRule=new Rule(generatedStartRuleType,new Object[]{startRule.getType()}){
    @Override public Object match(    Object[] types,    Object[] args){
      if (types.length == 1 && types[0] == startRule.getType()) {
        return args[0];
      }
      throw badTypeList();
    }
  }
;
  rules.addStartRule(newStartRule);
  LALRItemSet initialSet=new LALRItemSet();
  LALRItem startItem=new LALRItem(newStartRule,0,0);
  startItem.addLookahead(null);
  initialSet.addKernelItem(startItem);
  initialSet.calculateClosureItems(rules);
  Map<LALRItemSet,LALRItemSet> itemSets=new HashMap<LALRItemSet,LALRItemSet>();
  itemSets.put(initialSet,initialSet);
  Deque<LALRItemSet> stack=new LinkedList<LALRItemSet>();
  stack.add(initialSet);
  Map<LALRItemSet,Map<Object,LALRItemSet>> transitions=new HashMap<LALRItemSet,Map<Object,LALRItemSet>>();
  while (!stack.isEmpty()) {
    LALRItemSet set=stack.pop();
    Map<Object,LALRItemSet> setTransitions=findTransitions(set);
    for (    Entry<Object,LALRItemSet> transition : setTransitions.entrySet()) {
      LALRItemSet transitionSet=transition.getValue();
      transitionSet.calculateClosureItems(rules);
      LALRItemSet existingSet=itemSets.get(transitionSet);
      if (existingSet == null) {
        itemSets.put(transitionSet,transitionSet);
        stack.add(transitionSet);
        continue;
      }
      if (existingSet.containsLookaheads(transitionSet)) {
        continue;
      }
      existingSet.combineLookaheads(transitionSet);
      existingSet.calculateClosureItems(rules);
      transition.setValue(existingSet);
      stack.add(existingSet);
    }
    transitions.put(set,setTransitions);
  }
  startState=generateStates(initialSet,transitions,itemSets.keySet());
}",0.8313440581214323
5221,"/** 
 * Finds the set of LALR Items that are in the epsilon-closure of the specified set of start items.
 * @param startItems - the set of kernel items to calculate the closure of
 * @return the set of closure items that must be added to the kernel set to produce the closure
 */
public Map<TypeUseEntry,LALRItem> calculateClosureItems(Collection<LALRItem> startItems){
  Deque<LALRItem> queue=new LinkedList<LALRItem>();
  queue.addAll(startItems);
  Map<TypeUseEntry,LALRItem> result=new HashMap<TypeUseEntry,LALRItem>();
  Map<TypeUseEntry,LALRItem> visited=new HashMap<TypeUseEntry,LALRItem>();
  while (!queue.isEmpty()) {
    LALRItem item=queue.pollFirst();
    LALRItem visitedItem=visited.get(item.getNextTypeUse());
    if (visitedItem != null && visitedItem.containsLookaheads(item)) {
      continue;
    }
    LALRItem itemCopy=new LALRItem(item);
    visited.put(itemCopy.getNextTypeUse(),itemCopy);
    int offset=item.getOffset();
    LALRItem resultItem=new LALRItem(item.getRule(),item.getProductionIndex(),offset);
    LALRItem existing=result.get(resultItem.getNextTypeUse());
    if (existing != null) {
      existing.addLookaheads(item.getLookaheads());
      queue.addLast(existing);
    }
 else {
      resultItem.addLookaheads(item.getLookaheads());
      result.put(resultItem.getNextTypeUse(),resultItem);
    }
    Object[] production=item.getProduction();
    if (offset == production.length) {
      continue;
    }
    Rule rule=rules.get(production[offset]);
    if (rule != null) {
      Set<Object> lookaheads=new HashSet<Object>();
      boolean nullable=true;
      for (int lookahead=offset + 1; lookahead < production.length; lookahead++) {
        lookaheads.addAll(getFirstSet(production[lookahead]));
        if (!isNullable(production[lookahead])) {
          nullable=false;
          break;
        }
      }
      if (nullable) {
        lookaheads.addAll(item.getLookaheads());
      }
      Object[][] subProductions=rule.getProductions();
      for (int j=0; j < subProductions.length; j++) {
        LALRItem stackItem=new LALRItem(rule,j,0);
        stackItem.addLookaheads(lookaheads);
        queue.addLast(stackItem);
      }
    }
  }
  Iterator<Entry<TypeUseEntry,LALRItem>> it=result.entrySet().iterator();
  while (it.hasNext()) {
    Entry<TypeUseEntry,LALRItem> entry=it.next();
    if (startItems.contains(entry.getValue())) {
      it.remove();
    }
  }
  return result;
}","/** 
 * Finds the set of LALR Items that are in the epsilon-closure of the specified set of start items.
 * @param startItems - the set of kernel items to calculate the closure of
 * @return the set of closure items that must be added to the kernel set to produce the closure. These will be updated with any additional lookaheads they require
 */
public Map<TypeUseEntry,LALRItem> calculateClosureItems(Collection<LALRItem> startItems){
  Deque<LALRItem> queue=new LinkedList<LALRItem>();
  queue.addAll(startItems);
  Map<TypeUseEntry,LALRItem> result=new HashMap<TypeUseEntry,LALRItem>();
  for (  LALRItem startItem : startItems) {
    result.put(startItem.getNextTypeUse(),startItem);
  }
  Map<TypeUseEntry,LALRItem> visited=new HashMap<TypeUseEntry,LALRItem>();
  while (!queue.isEmpty()) {
    LALRItem item=queue.pollFirst();
    LALRItem visitedItem=visited.get(item.getNextTypeUse());
    if (visitedItem != null && visitedItem.containsLookaheads(item)) {
      continue;
    }
    LALRItem itemCopy=new LALRItem(item);
    visited.put(itemCopy.getNextTypeUse(),itemCopy);
    int offset=item.getOffset();
    LALRItem resultItem=new LALRItem(item.getRule(),item.getProductionIndex(),offset);
    LALRItem existing=result.get(resultItem.getNextTypeUse());
    if (existing != null) {
      existing.addLookaheads(item.getLookaheads());
      queue.addLast(existing);
    }
 else {
      resultItem.addLookaheads(item.getLookaheads());
      result.put(resultItem.getNextTypeUse(),resultItem);
    }
    Object[] production=item.getProduction();
    if (offset == production.length) {
      continue;
    }
    Rule rule=rules.get(production[offset]);
    if (rule != null) {
      Set<Object> lookaheads=new HashSet<Object>();
      boolean nullable=true;
      for (int lookahead=offset + 1; lookahead < production.length; lookahead++) {
        lookaheads.addAll(getFirstSet(production[lookahead]));
        if (!isNullable(production[lookahead])) {
          nullable=false;
          break;
        }
      }
      if (nullable) {
        lookaheads.addAll(item.getLookaheads());
      }
      Object[][] subProductions=rule.getProductions();
      for (int j=0; j < subProductions.length; j++) {
        LALRItem stackItem=new LALRItem(rule,j,0);
        stackItem.addLookaheads(lookaheads);
        queue.addLast(stackItem);
      }
    }
  }
  Iterator<Entry<TypeUseEntry,LALRItem>> it=result.entrySet().iterator();
  while (it.hasNext()) {
    Entry<TypeUseEntry,LALRItem> entry=it.next();
    if (startItems.contains(entry.getValue())) {
      it.remove();
    }
  }
  return result;
}",0.966461599523715
5222,"public TimeAmountFileAppender(TimeAmountFileCallback callback,TimeAmount amount,TimeAmount staleFileCheck,String dir,long maxBytes,boolean gzip){
  this.amount=amount;
  this.callback=callback;
  this.directory=dir;
  this.maxBytes=maxBytes;
  this.gzip=gzip;
  this.cache=CacheBuilder.newBuilder().maximumSize(1000).expireAfterAccess(staleFileCheck.getAmount(),staleFileCheck.getTimeframe().getTimeUnit()).removalListener(new RemovalListener<Long,TimeAmountFile>(){
    @Override public void onRemoval(    RemovalNotification<Long,TimeAmountFile> rn){
      staleFile(rn.getValue());
    }
  }
).build(new CacheLoader<Long,TimeAmountFile>(){
    public TimeAmountFile load(    Long epoch) throws Exception {
      System.out.println(""String_Node_Str"" + epoch);
      return newFile(epoch);
    }
  }
);
  File f[]=new File(dir).listFiles();
  if (f != null) {
    for (    File file : f) {
      try {
        TimeAmountFile taf=new TimeAmountFile(file,maxBytes);
        if (file.getName().endsWith(""String_Node_Str"")) {
          if (new File(StringHelper.trim(file.getAbsolutePath(),""String_Node_Str"")).exists()) {
            log.warn(""String_Node_Str"" + file.getAbsolutePath());
            file.delete();
            continue;
          }
        }
        this.cache.put(taf.getEpoch(),taf);
      }
 catch (      Exception x) {
        log.error(""String_Node_Str"",x);
      }
    }
  }
}","public TimeAmountFileAppender(TimeAmountFileCallback callback,TimeAmount amount,TimeAmount staleFileCheck,String dir,long maxBytes,boolean gzip){
  this.amount=amount;
  this.callback=callback;
  this.directory=dir;
  this.maxBytes=maxBytes;
  this.gzip=gzip;
  this.cache=CacheBuilder.newBuilder().maximumSize(1000).expireAfterAccess(staleFileCheck.getAmount(),staleFileCheck.getTimeframe().getTimeUnit()).removalListener(new RemovalListener<Long,TimeAmountFile>(){
    @Override public void onRemoval(    RemovalNotification<Long,TimeAmountFile> rn){
      staleFile(rn.getValue());
    }
  }
).build(new CacheLoader<Long,TimeAmountFile>(){
    public TimeAmountFile load(    Long epoch) throws Exception {
      System.out.println(""String_Node_Str"" + epoch);
      return newFile(epoch);
    }
  }
);
  File f[]=new File(dir).listFiles();
  if (f != null) {
    for (    File file : f) {
      try {
        TimeAmountFile taf=new TimeAmountFile(file,maxBytes);
        log.warn(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
        if (file.getName().endsWith(""String_Node_Str"")) {
          if (new File(StringHelper.trim(file.getAbsolutePath(),""String_Node_Str"")).exists()) {
            log.warn(""String_Node_Str"" + file.getAbsolutePath());
            file.delete();
            continue;
          }
 else {
            staleFile(taf);
            continue;
          }
        }
        this.cache.put(taf.getEpoch(),taf);
      }
 catch (      Exception x) {
        log.error(""String_Node_Str"",x);
      }
    }
  }
}",0.9300271739130436
5223,"@Override public void onRemoval(RemovalNotification<Long,TimeAmountFile> rn){
  staleFile(rn.getValue());
}","@Override public void onRemoval(RemovalNotification<Long,TimeAmountFile> rn){
  log.warn(""String_Node_Str"" + rn.getKey() + ""String_Node_Str""+ rn.getValue());
  staleFile(rn.getValue());
}",0.7278911564625851
5224,"public TimeAmountFileAppender(TimeAmountFileCallback callback,TimeAmount amount,TimeAmount staleFileCheck,String dir,long maxBytes,boolean gzip){
  this.amount=amount;
  this.callback=callback;
  this.directory=dir;
  this.maxBytes=maxBytes;
  this.gzip=gzip;
  this.cache=CacheBuilder.newBuilder().maximumSize(1000).expireAfterAccess(staleFileCheck.getAmount(),staleFileCheck.getTimeframe().getTimeUnit()).removalListener(new RemovalListener<Long,TimeAmountFile>(){
    @Override public void onRemoval(    RemovalNotification<Long,TimeAmountFile> rn){
      staleFile(rn.getValue());
    }
  }
).build(new CacheLoader<Long,TimeAmountFile>(){
    public TimeAmountFile load(    Long epoch) throws Exception {
      System.out.println(""String_Node_Str"" + epoch);
      return newFile(epoch);
    }
  }
);
  File f[]=new File(dir).listFiles();
  if (f != null) {
    for (    File file : f) {
      try {
        TimeAmountFile taf=new TimeAmountFile(file,maxBytes);
        log.warn(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
        if (file.getName().endsWith(""String_Node_Str"")) {
          if (new File(StringHelper.trim(file.getAbsolutePath(),""String_Node_Str"")).exists()) {
            log.warn(""String_Node_Str"" + file.getAbsolutePath());
            file.delete();
            continue;
          }
 else {
            staleFile(taf);
            continue;
          }
        }
        this.cache.put(taf.getEpoch(),taf);
      }
 catch (      Exception x) {
        log.error(""String_Node_Str"",x);
      }
    }
  }
}","public TimeAmountFileAppender(TimeAmountFileCallback callback,TimeAmount amount,TimeAmount staleFileCheck,String dir,long maxBytes,boolean gzip){
  this.amount=amount;
  this.callback=callback;
  this.directory=dir;
  this.maxBytes=maxBytes;
  this.gzip=gzip;
  this.staleFileCheck=staleFileCheck;
}",0.2902003248511099
5225,"public synchronized void append(Date date,String str) throws Exception {
  long epoch=this.amount.toTrendrrEpoch(date).longValue();
  for (int i=0; i < 5; i++) {
    TimeAmountFile file=null;
    try {
      file=this.cache.get(epoch);
      file.append(str);
      return;
    }
 catch (    FileClosedException x) {
      this.staleFile(file);
      this.cache.invalidate(epoch);
    }
  }
  throw new TrendrrIOException(""String_Node_Str"" + epoch);
}","public synchronized void append(Date date,String str) throws Exception {
  if (this.cache == null) {
    this.init();
  }
  long epoch=this.amount.toTrendrrEpoch(date).longValue();
  for (int i=0; i < 5; i++) {
    TimeAmountFile file=null;
    try {
      file=this.cache.get(epoch);
      file.append(str);
      return;
    }
 catch (    FileClosedException x) {
      this.staleFile(file);
      this.cache.invalidate(epoch);
    }
  }
  throw new TrendrrIOException(""String_Node_Str"" + epoch);
}",0.9484752891692956
5226,"public void appendLine(Date date,String str) throws Exception {
  this.append(new Date(),str + ""String_Node_Str"");
}","public void appendLine(Date date,String str) throws Exception {
  this.append(date,str + ""String_Node_Str"");
}",0.9646017699115044
5227,"public static void main(String... strings) throws TrendrrException {
  String json=""String_Node_Str"";
  JSONStreamReader reader=new JSONStreamReader(new StringReader(json));
  DynMap mp;
  while ((mp=reader.readNext()) != null) {
    System.out.println(mp.toJSONString());
  }
}","public static void main(String... strings) throws TrendrrException {
  String json=""String_Node_Str"";
  try {
    json=FileHelper.loadString(""String_Node_Str"");
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
  }
  JSONStreamReader reader=new JSONStreamReader(new StringReader(json));
  DynMap mp;
  while ((mp=reader.readNext()) != null) {
    System.out.println(mp.toJSONString());
  }
}",0.8128654970760234
5228,"/** 
 * returns null on eof. throws exception or returns parsed object.
 * @return
 * @throws IOException
 */
public DynMap readNext() throws TrendrrException {
  StringBuilder json=new StringBuilder(""String_Node_Str"");
  try {
    long numRead=0;
    int openBrackets=1;
    boolean isQuote=false;
    char previous='{';
    int current=this.reader.read();
    while (current != '{' && current != -1) {
      numRead++;
      if (numRead > this.maxBufferedChars) {
        throw new TrendrrParseException(""String_Node_Str"" + this.maxBufferedChars + ""String_Node_Str"");
      }
      current=this.reader.read();
    }
    do {
      current=this.reader.read();
      if (current == -1) {
        return null;
      }
      char c=(char)current;
      json.append(c);
      if (!isQuote) {
        if (c == '{') {
          openBrackets++;
        }
 else         if (c == '}') {
          openBrackets--;
        }
      }
      if (c == '""' && previous != '\\') {
        isQuote=!isQuote;
      }
      previous=c;
      numRead++;
      if (numRead > this.maxBufferedChars) {
        throw new TrendrrParseException(""String_Node_Str"" + this.maxBufferedChars + ""String_Node_Str"");
      }
    }
 while (openBrackets != 0);
    DynMap dm=DynMapFactory.instanceFromJSON(json.toString());
    if (dm == null) {
      throw new TrendrrParseException(""String_Node_Str"");
    }
    return dm;
  }
 catch (  IOException x) {
    throw new TrendrrIOException(x);
  }
}","/** 
 * returns null on eof. throws exception or returns parsed object.
 * @return
 * @throws IOException
 */
public DynMap readNext() throws TrendrrException {
  StringBuilder json=new StringBuilder(""String_Node_Str"");
  try {
    long numRead=0;
    int openBrackets=1;
    boolean isQuote=false;
    boolean isEscape=false;
    int current=this.reader.read();
    while (current != '{' && current != -1) {
      numRead++;
      if (numRead > this.maxBufferedChars) {
        throw new TrendrrParseException(""String_Node_Str"" + this.maxBufferedChars + ""String_Node_Str""+ json.substring(0,256));
      }
      current=this.reader.read();
    }
    do {
      current=this.reader.read();
      if (current == -1) {
        return null;
      }
      char c=(char)current;
      json.append(c);
      if (!isQuote) {
        if (c == '{') {
          openBrackets++;
        }
 else         if (c == '}') {
          openBrackets--;
        }
      }
      if (c == '""' && !isEscape) {
        isQuote=!isQuote;
      }
      if (isQuote && !isEscape && c == '\\') {
        isEscape=true;
      }
 else {
        isEscape=false;
      }
      numRead++;
      if (numRead > this.maxBufferedChars) {
        throw new TrendrrParseException(""String_Node_Str"" + this.maxBufferedChars + ""String_Node_Str""+ json.substring(0,256));
      }
    }
 while (openBrackets != 0);
    DynMap dm=DynMapFactory.instanceFromJSON(json.toString());
    if (dm == null) {
      throw new TrendrrParseException(""String_Node_Str"");
    }
    return dm;
  }
 catch (  IOException x) {
    throw new TrendrrIOException(x);
  }
}",0.6082138200782269
5229,"public TimeAmountCounter(TimeAmount timeamount,TimeAmountCounterCallback callback){
  this.timeframe=timeamount;
}","public TimeAmountCounter(TimeAmount timeamount,TimeAmountCounterCallback callback){
  this.timeframe=timeamount;
  this.callback=callback;
}",0.8976377952755905
5230,"/** 
 * Append to this file.  note that 
 * @param str
 * @throws FileClosedException
 * @throws IOException
 */
public synchronized void append(String str) throws FileClosedException, IOException {
  if (stale) {
    throw new FileClosedException();
  }
  if (curBytes >= maxBytes) {
    this.setStale();
    throw new FileClosedException();
  }
  this.lastWrite=new Date();
  this.writer.append(str);
}","/** 
 * Append to this file.  note that 
 * @param str
 * @throws FileClosedException
 * @throws IOException
 */
public synchronized void append(String str) throws FileClosedException, IOException {
  if (stale) {
    throw new FileClosedException();
  }
  if (maxBytes > 0 && curBytes >= maxBytes) {
    this.setStale();
    throw new FileClosedException();
  }
  this.lastWrite=new Date();
  this.writer.append(str);
  this.writer.flush();
}",0.935064935064935
5231,"public TimeAmountFile load(Long epoch) throws Exception {
  return newFile(epoch);
}","public TimeAmountFile load(Long epoch) throws Exception {
  System.out.println(""String_Node_Str"" + epoch);
  return newFile(epoch);
}",0.7741935483870968
5232,"public TimeAmountFileAppender(TimeAmountFileCallback callback,TimeAmount amount,TimeAmount staleFileCheck,String dir,long maxBytes){
  this.amount=amount;
  this.callback=callback;
  this.directory=dir;
  this.cache=CacheBuilder.newBuilder().maximumSize(1000).expireAfterWrite(staleFileCheck.getAmount(),staleFileCheck.getTimeframe().getTimeUnit()).removalListener(new RemovalListener<Long,TimeAmountFile>(){
    @Override public void onRemoval(    RemovalNotification<Long,TimeAmountFile> rn){
      staleFile(rn.getValue());
    }
  }
).build(new CacheLoader<Long,TimeAmountFile>(){
    public TimeAmountFile load(    Long epoch) throws Exception {
      return newFile(epoch);
    }
  }
);
  File f[]=new File(dir).listFiles();
  if (f != null) {
    for (    File file : f) {
      try {
        TimeAmountFile taf=new TimeAmountFile(file,maxBytes);
        this.cache.put(taf.getEpoch(),taf);
      }
 catch (      Exception x) {
        log.error(""String_Node_Str"",x);
      }
    }
  }
}","public TimeAmountFileAppender(TimeAmountFileCallback callback,TimeAmount amount,TimeAmount staleFileCheck,String dir,long maxBytes){
  this.amount=amount;
  this.callback=callback;
  this.directory=dir;
  this.maxBytes=maxBytes;
  this.cache=CacheBuilder.newBuilder().maximumSize(1000).expireAfterWrite(staleFileCheck.getAmount(),staleFileCheck.getTimeframe().getTimeUnit()).removalListener(new RemovalListener<Long,TimeAmountFile>(){
    @Override public void onRemoval(    RemovalNotification<Long,TimeAmountFile> rn){
      staleFile(rn.getValue());
    }
  }
).build(new CacheLoader<Long,TimeAmountFile>(){
    public TimeAmountFile load(    Long epoch) throws Exception {
      System.out.println(""String_Node_Str"" + epoch);
      return newFile(epoch);
    }
  }
);
  File f[]=new File(dir).listFiles();
  if (f != null) {
    for (    File file : f) {
      try {
        TimeAmountFile taf=new TimeAmountFile(file,maxBytes);
        this.cache.put(taf.getEpoch(),taf);
      }
 catch (      Exception x) {
        log.error(""String_Node_Str"",x);
      }
    }
  }
}",0.9617803580067732
5233,"public synchronized void append(Date date,String str) throws Exception {
  long epoch=this.amount.toTrendrrEpoch(date).longValue();
  TimeAmountFile file=null;
  try {
    file=this.cache.get(epoch);
    file.append(str);
  }
 catch (  FileClosedException x) {
    this.staleFile(file);
    this.cache.invalidate(epoch);
    this.append(date,str);
    return;
  }
}","public synchronized void append(Date date,String str) throws Exception {
  long epoch=this.amount.toTrendrrEpoch(date).longValue();
  for (int i=0; i < 5; i++) {
    TimeAmountFile file=null;
    try {
      file=this.cache.get(epoch);
      file.append(str);
      return;
    }
 catch (    FileClosedException x) {
      this.staleFile(file);
      this.cache.invalidate(epoch);
    }
  }
  throw new TrendrrIOException(""String_Node_Str"" + epoch);
}",0.803921568627451
5234,"protected Date getExpire(TimeAmount frame,Date date){
  Date expireMin=Timeframe.HOURS.add(date,24);
  Date expire=frame.add(date,100);
  if (expire.before(expireMin)) {
    expire=expireMin;
  }
  return expire;
}","protected Date getExpire(TimeAmount frame,Date date){
  Date expireMin=Timeframe.HOURS.add(date,24);
  Date expire=frame.add(date,100);
  if (expire.after(expireMin)) {
    expire=expireMin;
  }
  return expire;
}",0.97423887587822
5235,"/** 
 * does a (FAST) removal of the specified element.
 * @param obj
 */
public synchronized boolean remove(T obj){
  Integer index=this.indexes.get(obj);
  if (index == null) {
    return false;
  }
  T item=heap.remove(heap.size() - 1);
  this.indexes.put(item,index);
  this.heap.set(index,item);
  this.pushDown(item);
  return true;
}","/** 
 * does a (FAST) removal of the specified element.
 * @param obj
 */
public synchronized boolean remove(T obj){
  Integer index=this.indexes.remove(obj);
  if (index == null) {
    return false;
  }
  if (index == heap.size() - 1) {
    heap.remove((int)index);
    return true;
  }
  T item=heap.remove(heap.size() - 1);
  this.indexes.put(item,index);
  this.heap.set(index,item);
  this.pushDown(item);
  return true;
}",0.878748370273794
5236,"public Set<String> getFullKey(DynMap map){
  String fullkey=""String_Node_Str"";
  Set<String> keyset=new HashSet<String>();
  for (  Object key : map.keySet()) {
    if (map.getMap((String)key) != null) {
      fullkey=(String)key + ""String_Node_Str"" + ((getFullKey(map.getMap((String)key)).toArray())[0]);
    }
 else {
      fullkey=(String)key;
    }
    keyset.add(fullkey);
  }
  return keyset;
}","private Set<String> getFullKey(DynMap map){
  Set<String> keyset=new HashSet<String>();
  for (  Object key : map.keySet()) {
    if (map.getMap((String)key) != null) {
      Iterator it=(getFullKey(map.getMap((String)key))).iterator();
      while (it.hasNext())       keyset.add((String)key + ""String_Node_Str"" + it.next());
    }
 else {
      keyset.add((String)key);
    }
  }
  return keyset;
}",0.23
5237,"public StrestResponse awaitResponse(long timeoutMillis) throws Throwable {
  try {
    if (timeoutMillis > 0) {
      lock.acquire(1);
    }
 else {
      if (!lock.tryAcquire(timeoutMillis,TimeUnit.MILLISECONDS)) {
        throw new TrendrrTimeoutException(""String_Node_Str"" + timeoutMillis + ""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    log.error(""String_Node_Str"",e);
    throw e;
  }
  if (this.error != null) {
    throw this.error;
  }
  return this.response;
}","public StrestResponse awaitResponse(long timeoutMillis) throws Throwable {
  try {
    if (timeoutMillis <= 0) {
      lock.acquire(1);
    }
 else {
      if (!lock.tryAcquire(timeoutMillis,TimeUnit.MILLISECONDS)) {
        throw new TrendrrTimeoutException(""String_Node_Str"" + timeoutMillis + ""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    log.error(""String_Node_Str"",e);
    throw e;
  }
  if (this.error != null) {
    throw this.error;
  }
  return this.response;
}",0.997002997002997
5238,"/** 
 * parses any of the query params into a DynMap.  returns an empty map if there are no params to parse.
 * @param url
 * @return
 */
public static DynMap instanceFromURL(String url){
  if (!url.contains(""String_Node_Str"")) {
    return new DynMap();
  }
  String q=url.split(""String_Node_Str"")[1];
  return instanceFromURLEncoded(q);
}","/** 
 * parses any of the query params into a DynMap.  returns an empty map if there are no params to parse.
 * @param url
 * @return
 */
public static DynMap instanceFromURL(String url){
  String[] tmp=url.split(""String_Node_Str"");
  if (tmp.length < 2) {
    return new DynMap();
  }
  return instanceFromURLEncoded(tmp[1]);
}",0.844311377245509
5239,"/** 
 * initializes the appender.  This will be called automatically on the first invocation of append.  Subsequent calls to init are simply ignored.
 */
public void init(){
  if (this.init.start()) {
    try {
      String directory=System.getProperty(""String_Node_Str"");
      if (filename.contains(File.separator)) {
        directory=filename.substring(0,filename.lastIndexOf(File.separator));
        if (!directory.startsWith(File.separator)) {
          directory=System.getProperty(""String_Node_Str"") + File.separator + directory;
        }
      }
      this.currentTE=this.toTE(getDate());
      for (      File f : FileHelper.listDirectory(new File(directory),false)) {
        String fn=f.getAbsolutePath();
        if (!fn.endsWith(this.fileExtension) || !fn.startsWith(this.filename)) {
          continue;
        }
        String tmp=fn;
        tmp=StringHelper.trim(tmp,this.fileExtension);
        if (!tmp.contains(""String_Node_Str"")) {
          continue;
        }
        tmp=tmp.replace(this.filename + ""String_Node_Str"",""String_Node_Str"");
        long te=TypeCast.cast(Long.class,tmp);
        if (te < this.minTE()) {
          System.out.println(""String_Node_Str"" + this.currentTE + ""String_Node_Str""+ this.minTE());
          System.out.println(""String_Node_Str"" + fn);
          this.delete(f);
        }
      }
      this.newFile();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
 finally {
      init.end();
    }
  }
}","/** 
 * initializes the appender.  This will be called automatically on the first invocation of append.  Subsequent calls to init are simply ignored.
 */
public void init(){
  if (this.init.start()) {
    try {
      String directory=System.getProperty(""String_Node_Str"");
      if (filename.contains(File.separator)) {
        directory=filename.substring(0,filename.lastIndexOf(File.separator));
        if (!directory.startsWith(File.separator)) {
          directory=System.getProperty(""String_Node_Str"") + File.separator + directory;
        }
      }
      this.currentTE=this.toTE(getDate());
      for (      File f : FileHelper.listDirectory(new File(directory),false)) {
        String fn=f.getAbsolutePath();
        if (!fn.endsWith(this.fileExtension) || !fn.startsWith(this.filename)) {
          continue;
        }
        String tmp=fn;
        tmp=StringHelper.trim(tmp,this.fileExtension);
        if (!tmp.contains(""String_Node_Str"")) {
          continue;
        }
        tmp=tmp.replace(this.filename + ""String_Node_Str"",""String_Node_Str"");
        long te=TypeCast.cast(Long.class,tmp);
        if (te < this.minTE()) {
          this.delete(f);
        }
      }
      this.newFile();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
 finally {
      init.end();
    }
  }
}",0.9447632711621234
5240,"private void newFile() throws Exception {
  String oldFilename=this.currentFilename;
  this.currentTE=this.toTE(getDate());
  this.currentFilename=this.toFilename(this.currentTE);
  this.current=FileHelper.createNewFile(this.currentFilename);
  if (this.writer != null) {
    this.writer.close();
  }
  this.writer=new FileWriter(this.current);
  this.delete(new File(this.toFilename(this.minTE())));
  if (LINUX) {
    try {
      new File(this.filename + this.fileExtension).delete();
    }
 catch (    Exception x) {
      log.error(""String_Node_Str"",x);
    }
    try {
      Runtime rt=Runtime.getRuntime();
      Process result=null;
      String exe=new String(""String_Node_Str"" + ""String_Node_Str"" + this.currentFilename + ""String_Node_Str""+ this.filename+ this.fileExtension);
      result=rt.exec(exe);
    }
 catch (    Exception x) {
      log.error(""String_Node_Str"",x);
    }
  }
  RollingFileCallback cb=this.getCallback();
  if (cb != null) {
    cb.onRollover(oldFilename,this.currentFilename);
  }
}","private void newFile() throws Exception {
  String oldFilename=this.currentFilename;
  this.currentTE=this.toTE(getDate());
  this.currentFilename=this.toFilename(this.currentTE);
  this.current=FileHelper.createNewFile(this.currentFilename);
  if (this.writer != null) {
    this.writer.close();
  }
  this.writer=new FileWriter(this.current,true);
  this.delete(new File(this.toFilename(this.minTE())));
  if (LINUX) {
    try {
      new File(this.filename + this.fileExtension).delete();
    }
 catch (    Exception x) {
      log.error(""String_Node_Str"",x);
    }
    try {
      Runtime rt=Runtime.getRuntime();
      Process result=null;
      String exe=new String(""String_Node_Str"" + ""String_Node_Str"" + this.currentFilename + ""String_Node_Str""+ this.filename+ this.fileExtension);
      result=rt.exec(exe);
    }
 catch (    Exception x) {
      log.error(""String_Node_Str"",x);
    }
  }
  RollingFileCallback cb=this.getCallback();
  if (cb != null) {
    cb.onRollover(oldFilename,this.currentFilename);
  }
}",0.9975478175576264
5241,"public static void main(String... str) throws Exception {
  RollingFileAppender appender=new RollingFileAppender(Timeframe.SECONDS,10,10,""String_Node_Str"",null,true);
  appender.init();
  Date start=new Date();
  for (int i=0; i < 1000000; i++) {
    appender.append(i + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + (new Date().getTime() - start.getTime()));
}","public static void main(String... str) throws Exception {
  RollingFileAppender appender=new RollingFileAppender(Timeframe.MINUTES,10,10,""String_Node_Str"",null,true);
  appender.init();
  Date start=new Date();
  for (int i=0; i < 1000000; i++) {
    appender.append(i + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + (new Date().getTime() - start.getTime()));
}",0.986842105263158
5242,"protected long minTE(){
  System.out.println(this.currentTE);
  return ((long)((this.currentTE - (this.maxFiles * this.timeframeAmount)) / this.timeframeAmount)) * this.timeframeAmount;
}","protected long minTE(){
  return ((long)((this.currentTE - (this.maxFiles * this.timeframeAmount)) / this.timeframeAmount)) * this.timeframeAmount;
}",0.8869047619047619
5243,"@Override protected DynMap doCast(Class clss,Object object){
  if (object instanceof Map) {
    return toDynMap((Map)object);
  }
  if (object instanceof String) {
    try {
      Object obj=JSONValue.parseWithException((String)object);
      if (obj instanceof Map) {
        return toDynMap((Map)obj);
      }
    }
 catch (    Exception x) {
      log.info(""String_Node_Str"" + object + ""String_Node_Str""+ x.getMessage()+ ""String_Node_Str"");
    }
    return null;
  }
  Class cls=object.getClass();
  try {
    Method toMap=cls.getMethod(""String_Node_Str"");
    log.info(""String_Node_Str"");
    Map mp=(Map)toMap.invoke(object);
    return toDynMap((Map)mp);
  }
 catch (  NoSuchMethodError x) {
  }
catch (  Exception x) {
    log.info(""String_Node_Str"" + object + ""String_Node_Str""+ x.getMessage()+ ""String_Node_Str"");
  }
  return null;
}","@Override protected DynMap doCast(Class clss,Object object){
  if (object instanceof Map) {
    return toDynMap((Map)object);
  }
  if (object instanceof String) {
    try {
      Object obj=JSONValue.parseWithException((String)object);
      if (obj instanceof Map) {
        return toDynMap((Map)obj);
      }
    }
 catch (    Exception x) {
      log.info(""String_Node_Str"" + object + ""String_Node_Str""+ x.getMessage()+ ""String_Node_Str"");
    }
    return null;
  }
  Class cls=object.getClass();
  try {
    Method toMap=cls.getMethod(""String_Node_Str"");
    Map mp=(Map)toMap.invoke(object);
    return toDynMap((Map)mp);
  }
 catch (  NoSuchMethodError x) {
  }
catch (  Exception x) {
    log.info(""String_Node_Str"" + object + ""String_Node_Str""+ x.getMessage()+ ""String_Node_Str"");
  }
  return null;
}",0.980060422960725
5244,"/** 
 * initializes the appender.  This will be called automatically on the first invocation of append.  Subsequent calls to init are simply ignored.
 */
public void init(){
  if (this.init.start()) {
    try {
      String directory=filename.substring(0,filename.lastIndexOf(File.separator));
      System.out.println(directory);
      for (      File f : FileHelper.listDirectory(new File(directory),false)) {
        String fn=f.getAbsolutePath();
        if (!fn.endsWith(this.fileExtension) || !fn.startsWith(this.filename)) {
          continue;
        }
        String tmp=fn;
        tmp=StringHelper.trim(tmp,this.fileExtension);
        tmp=tmp.replace(this.filename + ""String_Node_Str"",""String_Node_Str"");
        long te=TypeCast.cast(Long.class,tmp);
        if (te < this.minTE()) {
          System.out.println(""String_Node_Str"" + this.currentTE + ""String_Node_Str""+ this.minTE());
          System.out.println(""String_Node_Str"" + fn);
          this.delete(f);
        }
      }
      this.newFile();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
 finally {
      init.end();
    }
  }
}","/** 
 * initializes the appender.  This will be called automatically on the first invocation of append.  Subsequent calls to init are simply ignored.
 */
public void init(){
  if (this.init.start()) {
    try {
      String directory=filename.substring(0,filename.lastIndexOf(File.separator));
      this.currentTE=this.toTE(new Date());
      for (      File f : FileHelper.listDirectory(new File(directory),false)) {
        String fn=f.getAbsolutePath();
        if (!fn.endsWith(this.fileExtension) || !fn.startsWith(this.filename)) {
          continue;
        }
        String tmp=fn;
        tmp=StringHelper.trim(tmp,this.fileExtension);
        if (!tmp.contains(""String_Node_Str"")) {
          continue;
        }
        tmp=tmp.replace(this.filename + ""String_Node_Str"",""String_Node_Str"");
        long te=TypeCast.cast(Long.class,tmp);
        if (te < this.minTE()) {
          System.out.println(""String_Node_Str"" + this.currentTE + ""String_Node_Str""+ this.minTE());
          System.out.println(""String_Node_Str"" + fn);
          this.delete(f);
        }
      }
      this.newFile();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
 finally {
      init.end();
    }
  }
}",0.9404200600085728
5245,"public static void main(String... str) throws Exception {
  RollingFileAppender appender=new RollingFileAppender(Timeframe.SECONDS,10,10,""String_Node_Str"");
  appender.init();
  Date start=new Date();
  for (int i=0; i < 1000000; i++) {
    appender.append(i + ""String_Node_Str"");
    Sleep.seconds(1);
  }
  System.out.println(""String_Node_Str"" + (new Date().getTime() - start.getTime()));
}","public static void main(String... str) throws Exception {
  RollingFileAppender appender=new RollingFileAppender(Timeframe.SECONDS,10,10,""String_Node_Str"",null,true);
  appender.init();
  Date start=new Date();
  for (int i=0; i < 1000000; i++) {
    appender.append(i + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + (new Date().getTime() - start.getTime()));
}",0.9585492227979274
5246,"protected long minTE(){
  return ((long)((this.currentTE - (this.maxFiles * this.timeframeAmount)) / this.timeframeAmount)) * this.timeframeAmount;
}","protected long minTE(){
  System.out.println(this.currentTE);
  return ((long)((this.currentTE - (this.maxFiles * this.timeframeAmount)) / this.timeframeAmount)) * this.timeframeAmount;
}",0.8869047619047619
5247,"@Override public void run(){
  while (true) {
    SelectionKey key=null;
    try {
      while (!this.changeQueue.isEmpty()) {
        SocketChannelWrapper wrapper=changeQueue.poll();
        if (wrapper.hasWrites()) {
          key=wrapper.getChannel().keyFor(this.selector);
          key.interestOps(SelectionKey.OP_WRITE);
        }
 else         if (wrapper.hasReads()) {
          key=wrapper.getChannel().keyFor(this.selector);
          key.interestOps(SelectionKey.OP_READ);
        }
 else {
          key=wrapper.getChannel().keyFor(this.selector);
          key.interestOps(0);
        }
        if (wrapper.isClosed()) {
          continue;
        }
      }
      this.selector.select();
      Iterator<SelectionKey> selectedKeys=this.selector.selectedKeys().iterator();
      while (selectedKeys.hasNext()) {
        key=selectedKeys.next();
        selectedKeys.remove();
        if (!key.isValid()) {
          continue;
        }
        if (key.isReadable()) {
          this.read(key);
        }
 else         if (key.isWritable()) {
          this.write(key);
        }
      }
    }
 catch (    TrendrrDisconnectedException x) {
      this.channels.get((SocketChannel)key.channel()).close();
    }
catch (    Exception e) {
      log.error(""String_Node_Str"",e);
    }
  }
}","@Override public void run(){
  while (true) {
    SelectionKey key=null;
    try {
      while (!this.registerQueue.isEmpty()) {
        SocketChannelWrapper wrapper=registerQueue.poll();
        key=wrapper.getChannel().register(this.selector,SelectionKey.OP_READ);
      }
      while (!this.changeQueue.isEmpty()) {
        SocketChannelWrapper wrapper=changeQueue.poll();
        if (wrapper.hasWrites()) {
          key=wrapper.getChannel().keyFor(this.selector);
          key.interestOps(SelectionKey.OP_WRITE);
        }
 else         if (wrapper.hasReads()) {
          key=wrapper.getChannel().keyFor(this.selector);
          key.interestOps(SelectionKey.OP_READ);
        }
 else {
          key=wrapper.getChannel().keyFor(this.selector);
          key.interestOps(0);
        }
        if (wrapper.isClosed()) {
          continue;
        }
      }
      this.selector.select();
      Iterator<SelectionKey> selectedKeys=this.selector.selectedKeys().iterator();
      while (selectedKeys.hasNext()) {
        key=selectedKeys.next();
        selectedKeys.remove();
        if (!key.isValid()) {
          continue;
        }
        if (key.isReadable()) {
          this.read(key);
        }
 else         if (key.isWritable()) {
          this.write(key);
        }
      }
    }
 catch (    TrendrrDisconnectedException x) {
      this.channels.get((SocketChannel)key.channel()).close();
    }
catch (    Exception e) {
      log.error(""String_Node_Str"",e);
    }
  }
}",0.9309849029475198
5248,"public void register(SocketChannelWrapper wrapper) throws IOException {
  this.channels.put(wrapper.getChannel(),wrapper);
  wrapper.getChannel().configureBlocking(false);
  wrapper.getChannel().register(this.selector,SelectionKey.OP_READ);
}","public void register(SocketChannelWrapper wrapper) throws IOException {
  this.channels.put(wrapper.getChannel(),wrapper);
  wrapper.getChannel().configureBlocking(false);
  registerQueue.add(wrapper);
  this.selector.wakeup();
}",0.7558386411889597
5249,"private boolean process(ChannelCallback callback){
  if (this.databuffers.isEmpty()) {
    log.info(""String_Node_Str"");
    return false;
  }
  try {
    if (callback instanceof StringReadRequest) {
      try {
        return this.readString((StringReadRequest)callback);
      }
 catch (      CharacterCodingException e) {
        throw new TrendrrException(""String_Node_Str"",e);
      }
    }
 else     if (callback instanceof ByteReadRequest) {
      return this.readBytes((ByteReadRequest)callback);
    }
 else {
      throw new TrendrrException(""String_Node_Str"" + callback);
    }
  }
 catch (  TrendrrException x) {
    callback.onError(x);
  }
  return true;
}","private boolean process(ChannelCallback callback){
  if (this.databuffers.isEmpty()) {
    return false;
  }
  try {
    if (callback instanceof StringReadRequest) {
      try {
        return this.readString((StringReadRequest)callback);
      }
 catch (      CharacterCodingException e) {
        throw new TrendrrException(""String_Node_Str"",e);
      }
    }
 else     if (callback instanceof ByteReadRequest) {
      return this.readBytes((ByteReadRequest)callback);
    }
 else {
      throw new TrendrrException(""String_Node_Str"" + callback);
    }
  }
 catch (  TrendrrException x) {
    callback.onError(x);
  }
  this.callbacks.poll();
  return true;
}",0.3473684210526316
5250,"/** 
 * reads one buffer (or less) worth of bytes from the channel. channel settings. after calling read it is up to the caller to call process, in order to process the bytes.
 * @param channel
 * @return
 * @throws TrendrrException 
 * @throws TrendrrDisconnectedException 
 */
public synchronized int read(ReadableByteChannel channel) throws TrendrrDisconnectedException, TrendrrException {
  int numRead=this.getBytesPerRead();
  int totalRead=0;
  try {
    ByteBuffer buf=this.getBuffer();
    numRead=channel.read(buf);
    totalRead+=numRead;
    System.out.println(numRead);
    if (numRead < 0) {
      this.returnBuffer(buf);
      throw new TrendrrDisconnectedException(""String_Node_Str"");
    }
 else     if (numRead == 0) {
      this.returnBuffer(buf);
    }
 else {
      buf.flip();
      this.databuffers.add(buf);
    }
  }
 catch (  Exception x) {
    this.throwException(x);
  }
  return totalRead;
}","/** 
 * reads one buffer (or less) worth of bytes from the channel. channel settings. after calling read it is up to the caller to call process, in order to process the bytes.
 * @param channel
 * @return
 * @throws TrendrrException 
 * @throws TrendrrDisconnectedException 
 */
public synchronized int read(ReadableByteChannel channel) throws TrendrrDisconnectedException, TrendrrException {
  int numRead=this.getBytesPerRead();
  int totalRead=0;
  try {
    ByteBuffer buf=this.getBuffer();
    numRead=channel.read(buf);
    totalRead+=numRead;
    if (numRead < 0) {
      this.returnBuffer(buf);
      throw new TrendrrDisconnectedException(""String_Node_Str"");
    }
 else     if (numRead == 0) {
      this.returnBuffer(buf);
    }
 else {
      buf.flip();
      this.databuffers.add(buf);
    }
  }
 catch (  Exception x) {
    this.throwException(x);
  }
  return totalRead;
}",0.981737686773658
5251,"/** 
 * reads characters until the requested string is found, or buffers are exhausted.
 * @throws CharacterCodingException
 */
private boolean readString(StringReadRequest request) throws CharacterCodingException {
  String delimiter=request.getDelimiter();
  StringBuilder builder=request.getBuf();
  int fromIndex=Math.max(0,builder.length() - delimiter.length());
  List<ByteBuffer> databufs=new ArrayList<ByteBuffer>();
  String retVal=null;
  CharsetDecoder decoder=request.getCharset().newDecoder();
  CharBuffer charBuf=CharBuffer.allocate(this.getBytesPerRead());
  for (  ByteBuffer buf : this.databuffers) {
    if (retVal != null) {
      databufs.add(buf);
    }
 else {
      decoder.decode(buf,charBuf,false);
      charBuf.flip();
      log.info(charBuf.toString());
      request.getBuf().append(charBuf);
      charBuf.clear();
      if (request.getBuf().length() > request.getDelimiter().length() + fromIndex) {
        int found=builder.indexOf(delimiter,fromIndex);
        if (found != -1) {
          String val=builder.toString();
          log.info(val);
          retVal=val.substring(0,found);
          String remaining=val.substring(found + delimiter.length());
          log.info(remaining);
          ByteBuffer remainingAsBuf=this.getBuffer().put(remaining.getBytes(request.getCharset()));
          remainingAsBuf.flip();
          databufs.add(remainingAsBuf);
        }
 else {
          fromIndex+=delimiter.length();
        }
      }
      if (buf.hasRemaining()) {
        databufs.add(buf);
        if (retVal == null) {
          throw new CharacterCodingException();
        }
      }
 else {
        this.returnBuffer(buf);
      }
    }
  }
  this.databuffers=databufs;
  if (retVal != null) {
    log.info(""String_Node_Str"");
    log.info(retVal);
    request.getCallback().stringResult(retVal);
    return true;
  }
  return false;
}","/** 
 * reads characters until the requested string is found, or buffers are exhausted.
 * @throws CharacterCodingException
 */
private boolean readString(StringReadRequest request) throws CharacterCodingException {
  String delimiter=request.getDelimiter();
  StringBuilder builder=request.getBuf();
  int fromIndex=Math.max(0,builder.length() - delimiter.length());
  List<ByteBuffer> databufs=new ArrayList<ByteBuffer>();
  String retVal=null;
  CharsetDecoder decoder=request.getCharset().newDecoder();
  CharBuffer charBuf=CharBuffer.allocate(this.getBytesPerRead());
  for (  ByteBuffer buf : this.databuffers) {
    if (retVal != null) {
      databufs.add(buf);
    }
 else {
      decoder.decode(buf,charBuf,false);
      charBuf.flip();
      request.getBuf().append(charBuf);
      charBuf.clear();
      if (request.getBuf().length() > request.getDelimiter().length() + fromIndex) {
        int found=builder.indexOf(delimiter,fromIndex);
        if (found != -1) {
          String val=builder.toString();
          retVal=val.substring(0,found);
          String remaining=val.substring(found + delimiter.length());
          ByteBuffer remainingAsBuf=this.getBuffer().put(remaining.getBytes(request.getCharset()));
          remainingAsBuf.flip();
          databufs.add(remainingAsBuf);
        }
 else {
          fromIndex+=delimiter.length();
        }
      }
      if (buf.hasRemaining()) {
        databufs.add(buf);
        if (retVal == null) {
          throw new CharacterCodingException();
        }
      }
 else {
        this.returnBuffer(buf);
      }
    }
  }
  this.databuffers=databufs;
  if (retVal != null) {
    this.callbacks.poll();
    request.getCallback().stringResult(retVal);
    return true;
  }
  return false;
}",0.9334799340296868
5252,"/** 
 * attempts to read the requested bytes from the current buffer. callback is called if read was successfull, this request can then be  discarded.
 * @return
 */
private boolean readBytes(ByteReadRequest request){
  List<ByteBuffer> databufs=new ArrayList<ByteBuffer>();
  log.info(""String_Node_Str"");
  for (  ByteBuffer buf : this.databuffers) {
    if (request.getBuf().hasRemaining()) {
      try {
        request.getBuf().put(buf);
        this.returnBuffer(buf);
      }
 catch (      BufferOverflowException x) {
        while (request.getBuf().hasRemaining()) {
          request.getBuf().put(buf.get());
        }
        databufs.add(buf);
      }
    }
 else {
      databufs.add(buf);
    }
  }
  this.databuffers=databufs;
  if (!request.getBuf().hasRemaining()) {
    log.info(""String_Node_Str"");
    request.getCallback().byteResult(request.getBuf().array());
    return true;
  }
  return false;
}","/** 
 * attempts to read the requested bytes from the current buffer. callback is called if read was successfull, this request can then be  discarded.
 * @return
 */
private boolean readBytes(ByteReadRequest request){
  List<ByteBuffer> databufs=new ArrayList<ByteBuffer>();
  for (  ByteBuffer buf : this.databuffers) {
    if (request.getBuf().hasRemaining()) {
      try {
        request.getBuf().put(buf);
        this.returnBuffer(buf);
      }
 catch (      BufferOverflowException x) {
        while (request.getBuf().hasRemaining()) {
          request.getBuf().put(buf.get());
        }
        databufs.add(buf);
      }
    }
 else {
      databufs.add(buf);
    }
  }
  this.databuffers=databufs;
  if (!request.getBuf().hasRemaining()) {
    this.callbacks.poll();
    request.getCallback().byteResult(request.getBuf().array());
    return true;
  }
  return false;
}",0.9583101723179543
5253,"@Override public void run(){
  while (true) {
    SelectionKey key=null;
    try {
      while (!this.changeQueue.isEmpty()) {
        SocketChannelWrapper wrapper=changeQueue.poll();
        if (wrapper.hasWrites()) {
          key=wrapper.getChannel().keyFor(this.selector);
          key.interestOps(SelectionKey.OP_WRITE);
        }
 else         if (wrapper.hasReads()) {
          key=wrapper.getChannel().keyFor(this.selector);
          key.interestOps(SelectionKey.OP_READ);
        }
        if (wrapper.isClosed()) {
          continue;
        }
      }
      log.info(""String_Node_Str"");
      this.selector.select();
      Iterator<SelectionKey> selectedKeys=this.selector.selectedKeys().iterator();
      while (selectedKeys.hasNext()) {
        key=selectedKeys.next();
        selectedKeys.remove();
        if (!key.isValid()) {
          continue;
        }
        if (key.isReadable()) {
          log.info(""String_Node_Str"");
          this.read(key);
        }
 else         if (key.isWritable()) {
          log.info(""String_Node_Str"");
          this.write(key);
        }
      }
    }
 catch (    TrendrrDisconnectedException x) {
      x.printStackTrace();
      this.channels.get((SocketChannel)key.channel()).close();
    }
catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","@Override public void run(){
  while (true) {
    SelectionKey key=null;
    try {
      while (!this.changeQueue.isEmpty()) {
        SocketChannelWrapper wrapper=changeQueue.poll();
        if (wrapper.hasWrites()) {
          key=wrapper.getChannel().keyFor(this.selector);
          key.interestOps(SelectionKey.OP_WRITE);
        }
 else         if (wrapper.hasReads()) {
          key=wrapper.getChannel().keyFor(this.selector);
          key.interestOps(SelectionKey.OP_READ);
        }
 else {
          key=wrapper.getChannel().keyFor(this.selector);
          key.interestOps(0);
        }
        if (wrapper.isClosed()) {
          continue;
        }
      }
      this.selector.select();
      Iterator<SelectionKey> selectedKeys=this.selector.selectedKeys().iterator();
      while (selectedKeys.hasNext()) {
        key=selectedKeys.next();
        selectedKeys.remove();
        if (!key.isValid()) {
          continue;
        }
        if (key.isReadable()) {
          this.read(key);
        }
 else         if (key.isWritable()) {
          this.write(key);
        }
      }
    }
 catch (    TrendrrDisconnectedException x) {
      x.printStackTrace();
      this.channels.get((SocketChannel)key.channel()).close();
    }
catch (    Exception e) {
      e.printStackTrace();
    }
  }
}",0.8855077976416889
5254,"public void register(SocketChannelWrapper wrapper) throws IOException {
  this.channels.put(wrapper.getChannel(),wrapper);
  wrapper.getChannel().configureBlocking(false);
  log.info(""String_Node_Str"");
  wrapper.getChannel().register(this.selector,SelectionKey.OP_READ);
}","public void register(SocketChannelWrapper wrapper) throws IOException {
  this.channels.put(wrapper.getChannel(),wrapper);
  wrapper.getChannel().configureBlocking(false);
  wrapper.getChannel().register(this.selector,SelectionKey.OP_READ);
}",0.9398058252427184
5255,"/** 
 * Attempts to read from the network, and process any callbacks.   does nothing if no callbacks have been registered.
 * @throws TrendrrNoCallbackException
 * @throws TrendrrDisconnectedException
 * @throws TrendrrException
 */
public void doRead() throws TrendrrNoCallbackException, TrendrrDisconnectedException, TrendrrException {
  int numRead=1;
  while (numRead > 0 && this.buffer.hasCallbacksWaiting()) {
    this.buffer.read(this.channel);
    this.buffer.process();
  }
}","/** 
 * Attempts to read from the network, and process any callbacks.   does nothing if no callbacks have been registered.
 * @throws TrendrrNoCallbackException
 * @throws TrendrrDisconnectedException
 * @throws TrendrrException
 */
public void doRead() throws TrendrrNoCallbackException, TrendrrDisconnectedException, TrendrrException {
  int numRead=1;
  while (numRead > 0 && this.buffer.hasCallbacksWaiting()) {
    numRead=this.buffer.read(this.channel);
    this.buffer.process();
  }
}",0.9918032786885246
5256,"/** 
 * @param args
 */
public static void main(String[] args){
  SocketChannel channel;
  try {
    channel=SocketChannel.open();
    channel.connect(new InetSocketAddress(""String_Node_Str"",8000));
    SocketChannelWrapper wrapper=new SocketChannelWrapper(channel);
    wrapper.write(""String_Node_Str"".getBytes());
    wrapper.readUntil(""String_Node_Str"",Charset.forName(""String_Node_Str""),new StringReadCallback(){
      @Override public void onError(      TrendrrException ex){
        ex.printStackTrace();
      }
      @Override public void stringResult(      String result){
        System.out.println(""String_Node_Str"" + result);
      }
    }
);
    byte[] bytes=wrapper.readBytes(197);
    System.out.println(""String_Node_Str"" + bytes.length);
    System.out.println(new String(bytes));
    wrapper.write(""String_Node_Str"".getBytes());
    System.out.println(wrapper.readUntil(""String_Node_Str"",Charset.forName(""String_Node_Str"")));
    System.out.println(wrapper.readUntil(""String_Node_Str"",Charset.forName(""String_Node_Str"")));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * @param args
 */
public static void main(String[] args){
  SocketChannel channel;
  try {
    channel=SocketChannel.open();
    channel.connect(new InetSocketAddress(""String_Node_Str"",8000));
    Sleep.seconds(30);
    SocketChannelWrapper wrapper=new SocketChannelWrapper(channel);
    wrapper.write(""String_Node_Str"".getBytes());
    wrapper.readUntil(""String_Node_Str"",Charset.forName(""String_Node_Str""),new StringReadCallback(){
      @Override public void onError(      TrendrrException ex){
        ex.printStackTrace();
      }
      @Override public void stringResult(      String result){
        System.out.println(""String_Node_Str"" + result);
      }
    }
);
    byte[] bytes=wrapper.readBytes(197);
    System.out.println(""String_Node_Str"" + bytes.length);
    System.out.println(new String(bytes));
    wrapper.write(""String_Node_Str"".getBytes());
    System.out.println(wrapper.readUntil(""String_Node_Str"",Charset.forName(""String_Node_Str"")));
    System.out.println(wrapper.readUntil(""String_Node_Str"",Charset.forName(""String_Node_Str"")));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.989644304367402
5257,"void incoming(StrestResponse response){
  String txnId=response.getHeader(StrestHeaders.Names.STREST_TXN_ID);
  String txnStatus=response.getHeader(StrestHeaders.Names.STREST_TXN_STATUS);
  StrestRequestCallback cb=this.callbacks.get(txnId);
  try {
    cb.messageRecieved(response);
  }
 catch (  Exception x) {
    log.error(""String_Node_Str"",x);
  }
  if (!StrestHeaders.Values.CONTINUE.equalsIgnoreCase(txnStatus)) {
    this.callbacks.remove(txnId);
    cb.txnComplete();
  }
}","void incoming(StrestResponse response){
  String txnId=response.getHeader(StrestHeaders.Names.STREST_TXN_ID);
  String txnStatus=response.getHeader(StrestHeaders.Names.STREST_TXN_STATUS);
  StrestRequestCallback cb=this.callbacks.get(txnId);
  if (cb == null) {
    log.error(""String_Node_Str"" + txnId + ""String_Node_Str"");
    return;
  }
  try {
    cb.messageRecieved(response);
  }
 catch (  Exception x) {
    log.error(""String_Node_Str"",x);
  }
  if (!StrestHeaders.Values.CONTINUE.equalsIgnoreCase(txnStatus)) {
    this.callbacks.remove(txnId);
    cb.txnComplete();
  }
}",0.9077212806026366
5258,"public synchronized void connect(){
  SocketChannel channel;
  try {
    channel=SocketChannel.open();
    channel.configureBlocking(true);
    channel.connect(new InetSocketAddress(this.host,this.port));
    socket=new SocketChannelWrapper(channel);
    reader=new StrestMessageReader();
    reader.start(this,socket);
    connected.set(true);
  }
 catch (  Exception x) {
    x.printStackTrace();
  }
}","public synchronized void connect(){
  SocketChannel channel;
  try {
    channel=SocketChannel.open();
    boolean connected=channel.connect(new InetSocketAddress(this.host,this.port));
    log.info(""String_Node_Str"" + connected);
    socket=new SocketChannelWrapper(channel);
    reader=new StrestMessageReader();
    reader.start(this,socket);
    this.connected.set(true);
  }
 catch (  Exception x) {
    x.printStackTrace();
  }
}",0.4576877234803337
5259,"@Override public void stringResult(String result){
  current=new StrestResponse();
  current.parseHeaders(result);
  String contentLength=current.getHeader(StrestHeaders.Names.CONTENT_LENGTH);
  if (contentLength == null) {
    log.warn(""String_Node_Str"");
    return;
  }
  int length=Integer.parseInt(contentLength);
  SocketChannelWrapper sock=this.socket.get();
  if (sock == null) {
    log.info(""String_Node_Str"");
  }
  sock.readBytes(length,this);
}","@Override public void stringResult(String result){
  current=new StrestResponse();
  current.parseHeaders(result);
  String contentLength=current.getHeader(StrestHeaders.Names.CONTENT_LENGTH);
  if (contentLength == null) {
    log.warn(""String_Node_Str"");
    this.readNextMessage();
    return;
  }
  int length=Integer.parseInt(contentLength);
  SocketChannelWrapper sock=this.socket.get();
  if (sock == null) {
    log.info(""String_Node_Str"");
  }
  sock.readBytes(length,this);
}",0.970276008492569
5260,"public void start(StrestClient client,SocketChannelWrapper socket){
  this.client.set(client);
  this.socket.set(socket);
}","public void start(StrestClient client,SocketChannelWrapper socket){
  this.client.set(client);
  this.socket.set(socket);
  this.readNextMessage();
}",0.9044117647058824
5261,"/** 
 * gets the bytes prepared and ready for sending to the server.
 * @return
 * @throws UnsupportedEncodingException 
 */
public ByteBuffer getBytesAsBuffer() throws UnsupportedEncodingException {
  this.finish();
  byte[] header=this.encodeHeaders();
  ByteBuffer buf=ByteBuffer.allocate(header.length + this.content.length);
  buf.put(header);
  buf.put(content);
  return buf;
}","/** 
 * gets the bytes prepared and ready for sending to the server. buffer is flipped
 * @return
 * @throws UnsupportedEncodingException 
 */
public ByteBuffer getBytesAsBuffer() throws UnsupportedEncodingException {
  this.finish();
  byte[] header=this.encodeHeaders();
  ByteBuffer buf=ByteBuffer.allocate(header.length + this.content.length);
  buf.put(header);
  buf.put(content);
  buf.flip();
  return buf;
}",0.96
5262,"public void parseHeaders(String header){
  String[] lines=header.split(StrestUtil.CRLF);
  String firstLine=lines[0];
  int index=firstLine.indexOf(' ');
  String protocol=firstLine.substring(0,index).trim();
  firstLine=firstLine.substring(index);
  index=firstLine.indexOf(' ');
  String code=firstLine.substring(0,index).trim();
  String message=firstLine.substring(index).trim();
  this.responseCode=Integer.parseInt(code);
  this.responseMessage=message;
  for (int i=1; i < lines.length; i++) {
    this.headers.parseHeader(lines[i]);
  }
}","public void parseHeaders(String header){
  String[] lines=header.split(StrestUtil.CRLF);
  String firstLine=lines[0];
  int index=firstLine.indexOf(' ');
  String protocol=firstLine.substring(0,index).trim();
  firstLine=firstLine.substring(index).trim();
  index=firstLine.indexOf(' ');
  String code=firstLine.substring(0,index).trim();
  String message=firstLine.substring(index).trim();
  this.responseCode=Integer.parseInt(code);
  this.responseMessage=message;
  for (int i=1; i < lines.length; i++) {
    this.headers.parseHeader(lines[i]);
  }
}",0.9936305732484076
5263,"/** 
 * Convert an object to JSON text. <p> If this object is a Map or a List, and it's also a JSONAware, JSONAware will be considered firstly. <p> DO NOT call this method from toJSONString() of a class that implements both JSONAware and Map or List with  ""this"" as the parameter, use JSONObject.toJSONString(Map) or JSONArray.toJSONString(List) instead. 
 * @see org.json.simple.JSONObject#toJSONString(Map)
 * @see org.json.simple.JSONArray#toJSONString(List)
 * @param value
 * @return JSON text, or ""null"" if value is null or it's an NaN or an INF number.
 */
public static String toJSONString(Object value){
  if (value == null)   return ""String_Node_Str"";
  JSONFormatter formatter=formatters.get(value.getClass());
  if (formatter != null) {
    return formatter.toJSONString(value);
  }
  if (value instanceof String)   return ""String_Node_Str"" + escape((String)value) + ""String_Node_Str"";
  if (value instanceof Double) {
    if (((Double)value).isInfinite() || ((Double)value).isNaN())     return ""String_Node_Str"";
 else     return value.toString();
  }
  if (value instanceof Float) {
    if (((Float)value).isInfinite() || ((Float)value).isNaN())     return ""String_Node_Str"";
 else     return value.toString();
  }
  if (value instanceof Number)   return value.toString();
  if (value instanceof Boolean)   return value.toString();
  if ((value instanceof JSONAware))   return ((JSONAware)value).toJSONString();
  if (value instanceof Map)   return JSONObject.toJSONString((Map)value);
  if (value instanceof List)   return JSONArray.toJSONString((List)value);
  return value.toString();
}","/** 
 * Convert an object to JSON text. <p> If this object is a Map or a List, and it's also a JSONAware, JSONAware will be considered firstly. <p> DO NOT call this method from toJSONString() of a class that implements both JSONAware and Map or List with  ""this"" as the parameter, use JSONObject.toJSONString(Map) or JSONArray.toJSONString(List) instead. 
 * @see org.json.simple.JSONObject#toJSONString(Map)
 * @see org.json.simple.JSONArray#toJSONString(List)
 * @param value
 * @return JSON text, or ""null"" if value is null or it's an NaN or an INF number.
 */
public static String toJSONString(Object value){
  if (value == null)   return ""String_Node_Str"";
  JSONFormatter formatter=formatters.get(value.getClass());
  if (formatter != null) {
    return formatter.toJSONString(value);
  }
  if (value instanceof String)   return ""String_Node_Str"" + escape((String)value) + ""String_Node_Str"";
  if (value instanceof Double) {
    if (((Double)value).isInfinite() || ((Double)value).isNaN())     return ""String_Node_Str"";
 else     return value.toString();
  }
  if (value instanceof Float) {
    if (((Float)value).isInfinite() || ((Float)value).isNaN())     return ""String_Node_Str"";
 else     return value.toString();
  }
  if (value instanceof Number)   return value.toString();
  if (value instanceof Boolean)   return value.toString();
  if ((value instanceof JSONAware))   return ((JSONAware)value).toJSONString();
  if (value instanceof Map)   return JSONObject.toJSONString((Map)value);
  if (value instanceof List)   return JSONArray.toJSONString((List)value);
  return toJSONString(value.toString());
}",0.986335403726708
5264,"/** 
 * Encode an object into JSON text and write it to out. <p> If this object is a Map or a List, and it's also a JSONStreamAware or a JSONAware, JSONStreamAware or JSONAware will be considered firstly. <p> DO NOT call this method from writeJSONString(Writer) of a class that implements both JSONStreamAware and (Map or List) with  ""this"" as the first parameter, use JSONObject.writeJSONString(Map, Writer) or JSONArray.writeJSONString(List, Writer) instead. 
 * @see org.json.simple.JSONObject#writeJSONString(Map,Writer)
 * @see org.json.simple.JSONArray#writeJSONString(List,Writer)
 * @param value
 * @param writer
 */
public static void writeJSONString(Object value,Writer out) throws IOException {
  if (value == null) {
    out.write(""String_Node_Str"");
    return;
  }
  JSONFormatter formatter=formatters.get(value.getClass());
  if (formatter != null) {
    out.write(formatter.toJSONString(value));
    return;
  }
  if (value instanceof String) {
    out.write('\""');
    out.write(escape((String)value));
    out.write('\""');
    return;
  }
  if (value instanceof Double) {
    if (((Double)value).isInfinite() || ((Double)value).isNaN())     out.write(""String_Node_Str"");
 else     out.write(value.toString());
    return;
  }
  if (value instanceof Float) {
    if (((Float)value).isInfinite() || ((Float)value).isNaN())     out.write(""String_Node_Str"");
 else     out.write(value.toString());
    return;
  }
  if (value instanceof Number) {
    out.write(value.toString());
    return;
  }
  if (value instanceof Boolean) {
    out.write(value.toString());
    return;
  }
  if ((value instanceof JSONStreamAware)) {
    ((JSONStreamAware)value).writeJSONString(out);
    return;
  }
  if ((value instanceof JSONAware)) {
    out.write(((JSONAware)value).toJSONString());
    return;
  }
  if (value instanceof Map) {
    JSONObject.writeJSONString((Map)value,out);
    return;
  }
  if (value instanceof List) {
    JSONArray.writeJSONString((List)value,out);
    return;
  }
  out.write(value.toString());
}","/** 
 * Encode an object into JSON text and write it to out. <p> If this object is a Map or a List, and it's also a JSONStreamAware or a JSONAware, JSONStreamAware or JSONAware will be considered firstly. <p> DO NOT call this method from writeJSONString(Writer) of a class that implements both JSONStreamAware and (Map or List) with  ""this"" as the first parameter, use JSONObject.writeJSONString(Map, Writer) or JSONArray.writeJSONString(List, Writer) instead. 
 * @see org.json.simple.JSONObject#writeJSONString(Map,Writer)
 * @see org.json.simple.JSONArray#writeJSONString(List,Writer)
 * @param value
 * @param writer
 */
public static void writeJSONString(Object value,Writer out) throws IOException {
  if (value == null) {
    out.write(""String_Node_Str"");
    return;
  }
  JSONFormatter formatter=formatters.get(value.getClass());
  if (formatter != null) {
    out.write(formatter.toJSONString(value));
    return;
  }
  if (value instanceof String) {
    out.write('\""');
    out.write(escape((String)value));
    out.write('\""');
    return;
  }
  if (value instanceof Double) {
    if (((Double)value).isInfinite() || ((Double)value).isNaN())     out.write(""String_Node_Str"");
 else     out.write(value.toString());
    return;
  }
  if (value instanceof Float) {
    if (((Float)value).isInfinite() || ((Float)value).isNaN())     out.write(""String_Node_Str"");
 else     out.write(value.toString());
    return;
  }
  if (value instanceof Number) {
    out.write(value.toString());
    return;
  }
  if (value instanceof Boolean) {
    out.write(value.toString());
    return;
  }
  if ((value instanceof JSONStreamAware)) {
    ((JSONStreamAware)value).writeJSONString(out);
    return;
  }
  if ((value instanceof JSONAware)) {
    out.write(((JSONAware)value).toJSONString());
    return;
  }
  if (value instanceof Map) {
    JSONObject.writeJSONString((Map)value,out);
    return;
  }
  if (value instanceof List) {
    JSONArray.writeJSONString((List)value,out);
    return;
  }
  writeJSONString(value.toString(),out);
}",0.9847590953785644
5265,"/** 
 * creates a DynMap instance. Will convert a regular map, or any object that has a toMap method a string is assumed to be json.
 * @param obj
 * @return
 */
public static DynMap instance(Object obj){
  return TypeCast.cast(DynMap.class,obj);
}","/** 
 * creates a DynMap instance. Will convert a regular map, or any object that has a toMap method a string is assumed to be json. if obj is an instance of DynMap then that DynMap instance is returned.
 * @param obj
 * @return
 */
public static DynMap instance(Object obj){
  return TypeCast.cast(DynMap.class,obj);
}",0.8747795414462081
5266,"/** 
 * checks if the lists are equivelent, i.e. all items in both lists are the same
 * @param l1
 * @param l2
 * @return
 */
public static boolean equivalent(Object l1,Object l2){
  try {
    List list1=TypeCast.toList(l1);
    List list2=TypeCast.toList(l2);
    if (list1 == list2)     return true;
    if (l1 == null || l2 == null)     return false;
    return list1.containsAll(list2);
  }
 catch (  Exception x) {
  }
  return false;
}","/** 
 * checks if the lists are equivelent, i.e. all items in both lists are the same
 * @param l1
 * @param l2
 * @return
 */
public static boolean equivalent(Object l1,Object l2){
  try {
    if (l1 == l2)     return true;
    if (l1 == null || l2 == null)     return false;
    List list1=TypeCast.toList(l1);
    List list2=TypeCast.toList(l2);
    System.out.println(""String_Node_Str"" + list1);
    System.out.println(""String_Node_Str"" + list2);
    System.out.println(""String_Node_Str"");
    return list1.containsAll(list2);
  }
 catch (  Exception x) {
  }
  return false;
}",0.6940371456500489
5267,"/** 
 * converts to a list.   will convert: Collection Enumeration Object[] String (will split based on delimiters). in all other cases: Will return null on null value. otherwise will return a list of length 1, with the value
 * @param obj
 * @param delimiters
 * @return
 */
public static List toList(Object obj,String... delimiters){
  Object val=obj;
  if (val == null)   return null;
  List list=new ArrayList();
  if (val instanceof List) {
    list=(List)val;
  }
 else   if (val instanceof String[]) {
    String str=TypeCast.cast(String.class,val);
    if (str != null && StringHelper.contains(str,delimiters)) {
      return toList(str,delimiters);
    }
    for (int i=0; i < ((Object[])val).length; i++) {
      Object tmp=(((Object[])val)[i]);
      if (tmp != null)       list.add(tmp);
    }
  }
 else   if (val instanceof Object[]) {
    for (int i=0; i < ((Object[])val).length; i++) {
      Object tmp=(((Object[])val)[i]);
      if (tmp != null)       list.add(tmp);
    }
  }
 else   if (val instanceof Collection) {
    for (    Object tmp : (Collection)val) {
      if (tmp != null)       list.add(tmp);
    }
  }
 else   if (obj instanceof String) {
    String str=TypeCast.cast(String.class,val);
    if (str == null || str.isEmpty())     return null;
    if (str.startsWith(""String_Node_Str"") && str.endsWith(""String_Node_Str"")) {
      try {
        Object jsonobj=JSONValue.parseWithException(str);
        return toList(jsonobj,delimiters);
      }
 catch (      Exception x) {
        return null;
      }
    }
    if (delimiters != null && delimiters.length > 0)     list.addAll(StringHelper.split(str,delimiters));
  }
 else   if (obj instanceof Enumeration) {
    Enumeration e=(Enumeration)obj;
    while (e.hasMoreElements()) {
      list.add(e.nextElement());
    }
  }
  if (list != null && list.isEmpty()) {
    list.add(obj);
  }
  if (list != null && !list.isEmpty())   return list;
  return null;
}","/** 
 * converts to a list.   will convert: Collection Enumeration Object[] String (will split based on the passed in delimiters). in all other cases: Will return null on null value or empty lists otherwise will return a list of length 1, with the value
 * @param obj
 * @param delimiters
 * @return
 */
public static List toList(Object obj,String... delimiters){
  Object val=obj;
  if (val == null)   return null;
  List list=new ArrayList();
  if (val instanceof List) {
    list=(List)val;
  }
 else   if (val instanceof String[]) {
    String str=TypeCast.cast(String.class,val);
    if (str != null && StringHelper.contains(str,delimiters)) {
      return toList(str,delimiters);
    }
    for (int i=0; i < ((Object[])val).length; i++) {
      Object tmp=(((Object[])val)[i]);
      if (tmp != null)       list.add(tmp);
    }
  }
 else   if (val instanceof Object[]) {
    for (int i=0; i < ((Object[])val).length; i++) {
      Object tmp=(((Object[])val)[i]);
      if (tmp != null)       list.add(tmp);
    }
  }
 else   if (val instanceof Collection) {
    for (    Object tmp : (Collection)val) {
      if (tmp != null)       list.add(tmp);
    }
  }
 else   if (obj instanceof String) {
    String str=TypeCast.cast(String.class,val);
    if (str == null || str.isEmpty())     return null;
    if (str.startsWith(""String_Node_Str"") && str.endsWith(""String_Node_Str"")) {
      try {
        Object jsonobj=JSONValue.parseWithException(str);
        return toList(jsonobj,delimiters);
      }
 catch (      Exception x) {
        return null;
      }
    }
    if (delimiters != null && delimiters.length > 0)     list.addAll(StringHelper.split(str,delimiters));
    if (list.isEmpty())     list.add(str);
  }
 else   if (obj instanceof Enumeration) {
    Enumeration e=(Enumeration)obj;
    while (e.hasMoreElements()) {
      list.add(e.nextElement());
    }
  }
 else {
    list.add(obj);
  }
  if (list != null && !list.isEmpty())   return list;
  return null;
}",0.930779054916986
5268,"@Test public void listTests(){
  Assert.assertNull(TypeCast.toList(null,""String_Node_Str""));
  Assert.assertNull(TypeCast.toList(""String_Node_Str""));
  Assert.assertTrue(listTest(TypeCast.toList(""String_Node_Str"",""String_Node_Str""),2));
  Assert.assertTrue(listTest(TypeCast.toList(""String_Node_Str""),2));
  Assert.assertTrue(listTest(TypeCast.toList(""String_Node_Str""),1));
}","@Test public void listTests(){
  Assert.assertNull(TypeCast.toList(null,""String_Node_Str""));
  Assert.assertNull(TypeCast.toList(""String_Node_Str""));
  Assert.assertTrue(listTest(TypeCast.toList(""String_Node_Str"",""String_Node_Str""),2));
  Assert.assertTrue(listTest(TypeCast.toList(""String_Node_Str""),2));
  Assert.assertTrue(listTest(TypeCast.toList(""String_Node_Str""),1));
  Assert.assertNull(TypeCast.toList(new ArrayList()));
}",0.9318463444857495
5269,"public void step(){
  double x0=x, y0=y, t0=t;
  x+=v * Math.cos(t) * dt;
  y+=-v * Math.sin(t) * dt;
  t+=vt * dt;
  while (t < -Math.PI)   t+=2 * Math.PI;
  while (t >= Math.PI)   t-=2 * Math.PI;
  if (playfield.collision(this)) {
    x=x0;
    y=y0;
    t=t0;
    return;
  }
  v+=a * dt;
  v-=v * r * r* CDRAG;
}","public void step(){
  double x0=x, y0=y, t0=t;
  x+=v * Math.cos(t) * dt;
  y+=-v * Math.sin(t) * dt;
  t+=vt * dt;
  while (t < -Math.PI)   t+=2 * Math.PI;
  while (t >= Math.PI)   t-=2 * Math.PI;
  if (playfield.collision(this)) {
    x=x0;
    y=y0;
    t=t0;
    return;
  }
  v+=a * dt;
  v-=v * r * r* CDRAG* dt;
}",0.9937106918238994
5270,"public void control(Agent me,Agent[] agents,Thing[] things){
  MeView meV=new MeView();
  meV.t=me.t;
  meV.vt=me.vt;
  meV.x=me.x;
  meV.y=me.y;
  meV.r=me.r;
  meV.a=me.a;
  meV.AMIN=me.AMIN;
  meV.AMAX=me.AMAX;
  meV.VTMIN=me.VTMIN;
  meV.VTMAX=me.VTMAX;
  meV.CDRAG=me.CDRAG;
  AgentView[] aVs=new AgentView[agents.length];
  for (int i=0; i < aVs.length; i++) {
    aVs[i]=new AgentView();
    aVs[i].c=agents[i].getClass();
    aVs[i].r=agents[i].r;
    aVs[i].t=agents[i].t;
    aVs[i].v=agents[i].v;
    aVs[i].x=agents[i].x;
    aVs[i].y=agents[i].y;
  }
  if (things != null)   throw new Error(""String_Node_Str"");
  ai.control(meV,aVs,null);
  me.a=clamp(meV.a,me.AMIN,me.AMAX);
  me.vt=clamp(meV.vt,me.VTMIN,me.VTMAX);
}","public void control(Agent[] agents,Thing[] things){
  MeView meV=new MeView();
  meV.t=t;
  meV.vt=vt;
  meV.x=x;
  meV.y=y;
  meV.r=r;
  meV.a=a;
  meV.AMIN=AMIN;
  meV.AMAX=AMAX;
  meV.VTMIN=VTMIN;
  meV.VTMAX=VTMAX;
  meV.CDRAG=CDRAG;
  AgentView[] aVs=new AgentView[agents.length];
  for (int i=0; i < aVs.length; i++) {
    aVs[i]=new AgentView();
    aVs[i].c=agents[i].getClass();
    aVs[i].r=agents[i].r;
    aVs[i].t=agents[i].t;
    aVs[i].v=agents[i].v;
    aVs[i].x=agents[i].x;
    aVs[i].y=agents[i].y;
  }
  if (things != null)   throw new Error(""String_Node_Str"");
  ai.control(meV,aVs,null);
  a=clamp(meV.a,AMIN,AMAX);
  vt=clamp(meV.vt,VTMIN,VTMAX);
}",0.94151212553495
5271,"/** 
 * Move the agent's state forward by a timestep. One would not normally override this. 
 */
public void step(){
  double x0=x, y0=y, t0=t;
  x+=v * Math.cos(t) * dt;
  y+=-v * Math.sin(t) * dt;
  t+=vt * dt;
  while (t < -Math.PI)   t+=2 * Math.PI;
  while (t >= Math.PI)   t-=2 * Math.PI;
  if (playfield.collision(this)) {
    x=x0;
    y=y0;
    t=t0;
    return;
  }
  v+=a * dt;
  double drag=r * r * CDRAG;
  if (drag >= 0.95) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  v-=v * drag;
}","/** 
 * Move the agent's state forward by a timestep. One would not normally override this. 
 */
public void step(){
  double x0=x, y0=y, t0=t;
  x+=v * Math.cos(t) * dt;
  y+=-v * Math.sin(t) * dt;
  t+=vt * dt;
  while (t < -Math.PI)   t+=2 * Math.PI;
  while (t >= Math.PI)   t-=2 * Math.PI;
  if (playfield.collision(this,true)) {
    x=x0;
    y=y0;
    t=t0;
    return;
  }
  v+=a * dt;
  double drag=r * r * CDRAG;
  if (drag >= 0.95) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  v-=v * drag;
}",0.9952426260704093
5272,"/** 
 * When the bug collides, its velocity and acceleration go to zero. 
 */
public synchronized void thump(){
  v=0;
  a=0;
  if (!thumped)   System.out.println(this.name + ""String_Node_Str"");
  this.thumped=true;
}","/** 
 * When the bug collides, its velocity and acceleration go to zero. 
 */
public void thump(){
  v=0;
  a=0;
}",0.6888217522658611
5273,"/** 
 * Make a playfield.
 * @param nagents   Number of agents to put on the field.
 * @param dt   Simulation timestep.
 * @param ddt  Display timestep multiplier.
 */
public Playfield(int nagents,double dt,int ddt){
  DT=dt;
  DDT=ddt;
  agents=new Agent[nagents];
  for (int i=0; i < nagents; i++)   do   agents[i]=new Bug(this,""String_Node_Str"" + i);
 while (collision(agents[i]));
}","/** 
 * Make a playfield.
 * @param nagents   Number of agents to put on the field.
 * @param dt   Simulation timestep.
 * @param ddt  Display timestep multiplier.
 */
public Playfield(int nagents,double dt,int ddt){
  DT=dt;
  DDT=ddt;
  agents=new Agent[nagents];
  for (int i=0; i < nagents; i++)   do   agents[i]=new Bug(this,""String_Node_Str"" + i);
 while (collision(agents[i],false));
}",0.9922879177377892
5274,"/** 
 * Returns True iff the given agent has collided with something: another agent, a thing, a wall.
 */
public boolean collision(Agent b){
  boolean result=false;
  if (b.wallCollision()) {
    result=true;
    b.thump();
  }
  for (int i=0; i < agents.length; i++) {
    if (agents[i] != null && agents[i].id != b.id && agents[i].thingCollision(b)) {
      result=true;
      b.thump();
      agents[i].thump();
    }
  }
  return result;
}","/** 
 * Returns True iff the given agent has collided with something: another agent, a thing, a wall.
 */
public boolean collision(Agent b,boolean thump){
  boolean result=false;
  if (b.wallCollision()) {
    result=true;
    if (thump)     b.thump();
  }
  for (int i=0; i < agents.length; i++) {
    if (agents[i] != null && agents[i].id != b.id && agents[i].thingCollision(b)) {
      result=true;
      if (thump) {
        b.thump();
        agents[i].thump();
      }
    }
  }
  return result;
}",0.8816067653276956
5275,"/** 
 * Atribui um valor de segundo ao indicador temporal.
 * @param second integer que determina o valor da parte de segundo. Deve ser um inteiro no intervalo [0,59], caso hava um valor de minuto, ou um inteiro positivo, caso contrrio.
 * @throws java.lang.IllegalArgumentException se o valor no estiver no formato definido pela norma.
 */
public void setSecond(Integer second) throws IllegalArgumentException {
  if (second != null && !(second >= 0 && (absoluteSecond() || second <= 59)))   throw new IllegalArgumentException(""String_Node_Str"");
  this.second=second.doubleValue();
}","/** 
 * Atribui um valor de segundo ao indicador temporal.
 * @param second integer que determina o valor da parte de segundo. Deve ser um inteiro no intervalo [0,59], caso hava um valor de minuto, ou um inteiro positivo, caso contrrio.
 * @throws java.lang.IllegalArgumentException se o valor no estiver no formato definido pela norma.
 */
public void setSecond(Integer second) throws IllegalArgumentException {
  if (second == null && !(second >= 0 && (absoluteSecond() || second <= 59)))   throw new IllegalArgumentException(""String_Node_Str"");
  this.second=second.doubleValue();
}",0.9982964224872232
5276,"/** 
 * Returns the value of the parameter defined by a connector or <i>null</i> if the attribute is not defined.
 * @return string representing the value to be set to the connector parameter or <i>null</i> if the attribute is not defined.
 */
public String getValue(){
  if (value != null)   return value.toString();
 else   return null;
}","/** 
 * Returns the value of the parameter defined by a connector or <i>null</i> if the attribute is not defined.
 * @return value to be set to the connector parameter or <i>null</i> if the attribute is not defined.
 */
public Object getValue(){
  return value;
}",0.4975124378109453
5277,"protected String parseValue(){
  String aux=getValue();
  if (aux != null)   return ""String_Node_Str"" + aux + ""String_Node_Str"";
 else   return ""String_Node_Str"";
}","protected String parseValue(){
  Object aux=getValue();
  if (aux != null)   return ""String_Node_Str"" + aux.toString() + ""String_Node_Str"";
 else   return ""String_Node_Str"";
}",0.9380530973451328
5278,"@Override public Ei findInterface(String id) throws XMLException {
  Ei result;
  Object aux;
  if ((aux=getRefer()) != null) {
    if (aux instanceof NCLMedia)     return (Ei)((En)aux).findInterface(id);
 else     return (Ei)((En)((ExternalReferenceType)aux).getTarget()).findInterface(id);
  }
  for (  Ep p : properties) {
    if (p.getName().toString().equals(id))     return (Ei)p;
  }
  result=(Ei)areas.get(id);
  if (result != null)   return result;
  return null;
}","@Override public Ei findInterface(String id) throws XMLException {
  Ei result;
  Object aux;
  if ((aux=getRefer()) != null) {
    if (aux instanceof NCLMedia)     return (Ei)((En)aux).findInterface(id);
 else     return (Ei)((En)((ExternalReferenceType)aux).getTarget()).findInterface(id);
  }
  result=(Ei)properties.get(id);
  if (result != null)   return result;
  result=(Ei)areas.get(id);
  if (result != null)   return result;
  return null;
}",0.6789189189189189
5279,"/** 
 * Returns the element with an specific identification. The element identification can be its id, name or alias.
 * @param ident identification of the element to be retrieved.
 * @return element of the list with the identification. Return <i>null</i> if the element was not found or the element type does not have an identification.
 * @throws XMLException if the string is null or empty.
 */
public T get(String ident) throws XMLException {
  if (ident == null)   throw new XMLException(""String_Node_Str"");
  if (""String_Node_Str"".equals(ident.trim()))   throw new XMLException(""String_Node_Str"");
  if (elements.isEmpty())   return null;
  T aux=elements.get(0);
  if (aux instanceof NCLIdentifiableElementPrototype) {
    for (    T el : elements) {
      if (((NCLIdentifiableElementPrototype)el).getId().equals(ident))       return el;
    }
  }
 else   if (aux instanceof NCLNamedElementPrototype) {
    for (    T el : elements) {
      if (((NCLNamedElementPrototype)el).getName().equals(ident))       return el;
    }
  }
  return null;
}","/** 
 * Returns the element with an specific identification. The element identification can be its id, name or alias.
 * @param ident identification of the element to be retrieved.
 * @return element of the list with the identification. Return <i>null</i> if the element was not found or the element type does not have an identification.
 * @throws XMLException if the string is null or empty.
 */
public T get(String ident) throws XMLException {
  if (ident == null)   throw new XMLException(""String_Node_Str"");
  if (""String_Node_Str"".equals(ident.trim()))   throw new XMLException(""String_Node_Str"");
  if (elements.isEmpty())   return null;
  T aux=elements.get(0);
  if (aux instanceof NCLIdentifiableElementPrototype) {
    for (    T el : elements) {
      if (((NCLIdentifiableElementPrototype)el).getId().equals(ident))       return el;
    }
  }
 else   if (aux instanceof NCLNamedElementPrototype) {
    for (    T el : elements) {
      if (((NCLNamedElementPrototype)el).getName().toString().equals(ident))       return el;
    }
  }
  return null;
}",0.9947990543735225
5280,"@Override protected String parseIdent(){
switch ((NCLElementAttributes)getTargetAtt()) {
case ID:
    return getTarget().getId();
case FOCUSINDEX:
  return ((NCLDescriptorPrototype)getTarget()).getFocusIndex().toString();
}
return null;
}","@Override protected String parseIdent(){
switch ((NCLElementAttributes)getTargetAtt()) {
case ID:
    return getTarget().getId();
case FOCUSINDEX:
  return ((NCLDescriptorPrototype)getTarget()).getFocusIndex().parse();
}
return null;
}",0.9725158562367864
5281,"@Override public void setName(NCLAttributes name) throws XMLException {
  if (name == null)   throw new XMLException(""String_Node_Str"");
  if (!name.equals(NCLAttributes.STYLE) && !name.equals(NCLAttributes.FONT_FAMILY))   throw new XMLException(""String_Node_Str"");
  super.setName(name);
}","@Override public void setName(NCLAttributes name) throws XMLException {
  if (name == null)   throw new XMLException(""String_Node_Str"");
  super.setName(name);
}",0.7139689578713969
5282,"/** 
 * Return the name of the property element or <i>null</i> if the attribute is not defined. <br/> A property element may represent an attribute or group of attributes of a node element. <br/> If the property element is a child of a media element with type <i>settings</i>, than it indicates the use of a global variable in the list defined by the document.
 * @return string representing the name of property element or <i>null</i> if the attribute is not defined.
 */
public String getName(){
  if (varName != null)   return varName.parse();
  if (attName != null)   return attName.toString();
 else   return null;
}","/** 
 * Return the name of the property element or <i>null</i> if the attribute is not defined. <br/> A property element may represent an attribute or group of attributes of a node element. <br/> If the property element is a child of a media element with type <i>settings</i>, than it indicates the use of a global variable in the list defined by the document.
 * @return string representing the name of property element or <i>null</i> if the attribute is not defined.
 */
public String getName(){
  if (varName != null)   return varName.parse();
  if (attName != null)   return attName.getName();
 else   return null;
}",0.9879129734085416
5283,"private Ep createParamByType(Element element) throws XMLException {
  String att_name, att_var;
  NCLAttributes att=NCLAttributes.DEFAULT;
  att_name=NCLElementAttributes.NAME.toString();
  if ((att_var=element.getAttribute(att_name)).isEmpty())   throw new NCLParsingException(""String_Node_Str"" + att_name + ""String_Node_Str"");
  for (  NCLAttributes a : NCLAttributes.values()) {
    if (a.toString().equals(att_var))     att=a;
  }
switch (att) {
case TOP:
    return createDoubleDescriptorParam();
case LEFT:
  return createDoubleDescriptorParam();
case BOTTOM:
return createDoubleDescriptorParam();
case RIGHT:
return createDoubleDescriptorParam();
case WIDTH:
return createDoubleDescriptorParam();
case HEIGHT:
return createDoubleDescriptorParam();
case LOCATION:
return createStringDescriptorParam();
case SIZE:
return createStringDescriptorParam();
case BOUNDS:
return createStringDescriptorParam();
case BACKGROUND:
return createColorDescriptorParam();
case VISIBLE:
return createBooleanDescriptorParam();
case TRANSPARENCY:
return createPercentDescriptorParam();
case FIT:
return createFitDescriptorParam();
case SCROLL:
return createScrollDescriptorParam();
case STYLE:
return createStringDescriptorParam();
case SOUND_LEVEL:
return createPercentDescriptorParam();
case BALANCE_LEVEL:
return createPercentDescriptorParam();
case TREBLE_LEVEL:
return createPercentDescriptorParam();
case BASS_LEVEL:
return createPercentDescriptorParam();
case ZINDEX:
return createDoubleDescriptorParam();
case FONT_FAMILY:
return createStringDescriptorParam();
case FONT_SIZE:
return createDoubleDescriptorParam();
case FONT_VARIANT:
return createFontVariantDescriptorParam();
case FONT_WEIGHT:
return createFontWeightDescriptorParam();
case FONT_COLOR:
return createColorDescriptorParam();
case REUSE_PLAYER:
return createBooleanDescriptorParam();
case PLAYER_LIFE:
return createPlayerLifeDescriptorParam();
default :
return createStringDescriptorParam();
}
}","private Ep createParamByType(Element element) throws XMLException {
  String att_name, att_var;
  NCLAttributes att=NCLAttributes.DEFAULT;
  att_name=NCLElementAttributes.NAME.toString();
  if ((att_var=element.getAttribute(att_name)).isEmpty())   throw new NCLParsingException(""String_Node_Str"" + att_name + ""String_Node_Str"");
  for (  NCLAttributes a : NCLAttributes.values()) {
    if (a.toString().equals(att_var))     att=a;
  }
switch (att) {
case TOP:
    return createRelativeDescriptorParam();
case LEFT:
  return createRelativeDescriptorParam();
case BOTTOM:
return createRelativeDescriptorParam();
case RIGHT:
return createRelativeDescriptorParam();
case WIDTH:
return createRelativeDescriptorParam();
case HEIGHT:
return createRelativeDescriptorParam();
case LOCATION:
return createStringDescriptorParam();
case SIZE:
return createStringDescriptorParam();
case BOUNDS:
return createStringDescriptorParam();
case BACKGROUND:
return createTranspColorDescriptorParam();
case VISIBLE:
return createBooleanDescriptorParam();
case TRANSPARENCY:
return createPercentDescriptorParam();
case FIT:
return createFitDescriptorParam();
case SCROLL:
return createScrollDescriptorParam();
case STYLE:
return createStringDescriptorParam();
case SOUND_LEVEL:
return createPercentDescriptorParam();
case BALANCE_LEVEL:
return createPercentDescriptorParam();
case TREBLE_LEVEL:
return createPercentDescriptorParam();
case BASS_LEVEL:
return createPercentDescriptorParam();
case ZINDEX:
return createIntegerDescriptorParam();
case FONT_FAMILY:
return createStringDescriptorParam();
case FONT_SIZE:
return createDoubleDescriptorParam();
case FONT_VARIANT:
return createFontVariantDescriptorParam();
case FONT_WEIGHT:
return createFontWeightDescriptorParam();
case FONT_COLOR:
return createColorDescriptorParam();
case REUSE_PLAYER:
return createBooleanDescriptorParam();
case PLAYER_LIFE:
return createPlayerLifeDescriptorParam();
default :
return createStringDescriptorParam();
}
}",0.976838890302876
5284,"public NCLPercentDescriptorParamPrototype() throws XMLException {
  super();
}","public NCLPercentDescriptorParamPrototype() throws XMLException {
  super();
  relative=false;
}",0.896551724137931
5285,"public void load(Element element) throws NCLParsingException {
  String att_name, att_var;
  try {
    att_name=NCLElementAttributes.ALIAS.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setAlias(att_var);
 else     throw new NCLParsingException(""String_Node_Str"" + att_name + ""String_Node_Str"");
    att_name=NCLElementAttributes.DOCUMENTURI.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setDocumentURI(new SrcType(att_var));
 else     throw new NCLParsingException(""String_Node_Str"" + att_name + ""String_Node_Str"");
    att_name=NCLElementAttributes.REGION.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      setRegion((Er)NCLReferenceManager.getInstance().findRegionReference(impl.getDoc(),att_var));
    }
    Ed aux=createDoc();
    String path=impl.getDoc().getLocation() + File.separator + getDocumentURI().parse();
    aux.loadXML(new File(path));
    setImportedDoc(aux);
  }
 catch (  XMLException ex) {
    String aux=getAlias();
    if (aux != null)     aux=""String_Node_Str"" + aux + ""String_Node_Str"";
 else     aux=""String_Node_Str"";
    throw new NCLParsingException(type.toString() + aux + ""String_Node_Str""+ ex.getMessage());
  }
}","public void load(Element element) throws NCLParsingException {
  String att_name, att_var;
  try {
    att_name=NCLElementAttributes.ALIAS.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setAlias(att_var);
 else     throw new NCLParsingException(""String_Node_Str"" + att_name + ""String_Node_Str"");
    att_name=NCLElementAttributes.DOCUMENTURI.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setDocumentURI(new SrcType(att_var));
 else     throw new NCLParsingException(""String_Node_Str"" + att_name + ""String_Node_Str"");
    att_name=NCLElementAttributes.REGION.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      setRegion((Er)NCLReferenceManager.getInstance().findRegionReference(impl.getDoc(),att_var));
    }
    try {
      Ed aux=createDoc();
      URI base=new URI(impl.getDoc().getLocation() + File.separator);
      URI path=base.resolve(getDocumentURI().parse());
      aux.loadXML(new File(path.getPath()));
      setImportedDoc(aux);
    }
 catch (    Exception e) {
      throw new NCLParsingException(""String_Node_Str"" + getDocumentURI().parse());
    }
  }
 catch (  XMLException ex) {
    String aux=getAlias();
    if (aux != null)     aux=""String_Node_Str"" + aux + ""String_Node_Str"";
 else     aux=""String_Node_Str"";
    throw new NCLParsingException(type.toString() + aux + ""String_Node_Str""+ ex.getMessage());
  }
}",0.8660647103085026
5286,"protected String parseDelay(){
  DoubleParamType aux=getDelay();
  if (aux == null)   return ""String_Node_Str"";
  String content=""String_Node_Str"" + aux.parse() + ""String_Node_Str"";
  if (aux.getValue() != null)   content+=""String_Node_Str"";
 else   content+=""String_Node_Str"";
  return content;
}","protected String parseDelay(){
  DoubleParamType aux=getDelay();
  if (aux == null)   return ""String_Node_Str"";
  String content=""String_Node_Str"" + aux.parse();
  if (aux.getValue() != null)   content+=""String_Node_Str"";
 else   content+=""String_Node_Str"";
  return content;
}",0.735191637630662
5287,"protected String parseDelay(){
  DoubleParamType aux=getDelay();
  if (aux == null)   return ""String_Node_Str"";
  String content=""String_Node_Str"" + aux.parse() + ""String_Node_Str"";
  if (aux.getValue() != null)   content+=""String_Node_Str"";
 else   content+=""String_Node_Str"";
  return content;
}","protected String parseDelay(){
  DoubleParamType aux=getDelay();
  if (aux == null)   return ""String_Node_Str"";
  String content=""String_Node_Str"" + aux.parse();
  if (aux.getValue() != null)   content+=""String_Node_Str"";
 else   content+=""String_Node_Str"";
  return content;
}",0.735191637630662
5288,"protected String parseDelay(){
  DoubleParamType aux=getDelay();
  if (aux == null)   return ""String_Node_Str"";
  String content=""String_Node_Str"" + aux.parse() + ""String_Node_Str"";
  if (aux.getValue() != null)   content+=""String_Node_Str"";
 else   content+=""String_Node_Str"";
  return content;
}","protected String parseDelay(){
  DoubleParamType aux=getDelay();
  if (aux == null)   return ""String_Node_Str"";
  String content=""String_Node_Str"" + aux.parse();
  if (aux.getValue() != null)   content+=""String_Node_Str"";
 else   content+=""String_Node_Str"";
  return content;
}",0.735191637630662
5289,"protected String parseDuration(){
  DoubleParamType aux=getDuration();
  if (aux == null)   return ""String_Node_Str"";
  String content=""String_Node_Str"" + aux.parse() + ""String_Node_Str"";
  if (aux.getValue() != null)   content+=""String_Node_Str"";
 else   content+=""String_Node_Str"";
  return content;
}","protected String parseDuration(){
  DoubleParamType aux=getDuration();
  if (aux == null)   return ""String_Node_Str"";
  String content=""String_Node_Str"" + aux.parse();
  if (aux.getValue() != null)   content+=""String_Node_Str"";
 else   content+=""String_Node_Str"";
  return content;
}",0.7406143344709898
5290,"protected String parseRepeatDelay(){
  DoubleParamType aux=getRepeatDelay();
  if (aux == null)   return ""String_Node_Str"";
  String content=""String_Node_Str"" + aux.parse() + ""String_Node_Str"";
  if (aux.getValue() != null)   content+=""String_Node_Str"";
 else   content+=""String_Node_Str"";
  return content;
}","protected String parseRepeatDelay(){
  DoubleParamType aux=getRepeatDelay();
  if (aux == null)   return ""String_Node_Str"";
  String content=""String_Node_Str"" + aux.parse();
  if (aux.getValue() != null)   content+=""String_Node_Str"";
 else   content+=""String_Node_Str"";
  return content;
}",0.745819397993311
5291,"protected String parseDelay(){
  DoubleParamType aux=getDelay();
  if (aux == null)   return ""String_Node_Str"";
  String content=""String_Node_Str"" + aux.parse() + ""String_Node_Str"";
  if (aux.getValue() != null)   content+=""String_Node_Str"";
 else   content+=""String_Node_Str"";
  return content;
}","protected String parseDelay(){
  DoubleParamType aux=getDelay();
  if (aux == null)   return ""String_Node_Str"";
  String content=""String_Node_Str"" + aux.parse();
  if (aux.getValue() != null)   content+=""String_Node_Str"";
 else   content+=""String_Node_Str"";
  return content;
}",0.735191637630662
5292,"protected String parseDefaultDescriptor(int ident){
  El aux=getDefaultDescriptor();
  if (aux != null)   return ""String_Node_Str"";
  String space=""String_Node_Str"";
  if (ident < 0)   ident=0;
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  return space + ""String_Node_Str"" + aux.getId()+ ""String_Node_Str"";
}","protected String parseDefaultDescriptor(int ident){
  El aux=getDefaultDescriptor();
  if (aux == null)   return ""String_Node_Str"";
  String space=""String_Node_Str"";
  if (ident < 0)   ident=0;
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  return space + ""String_Node_Str"" + aux.getId()+ ""String_Node_Str"";
}",0.9969135802469136
5293,"public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  content+=parseAttributes();
  if ((getValue() != null) || (this instanceof NCLColorDescriptorParamPrototype && ((NCLColorDescriptorParamPrototype)this).getIsTransparent() != null))   content+=""String_Node_Str"" + getParamValue() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  return content;
}","public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  content+=parseAttributes();
  content+=""String_Node_Str"";
  return content;
}",0.6398996235884568
5294,"protected String parseDefaultComponent(int ident){
  En aux=getDefaultComponent();
  if (aux != null)   return ""String_Node_Str"";
  String space=""String_Node_Str"";
  if (ident < 0)   ident=0;
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  return space + ""String_Node_Str"" + aux.getId()+ ""String_Node_Str"";
}","protected String parseDefaultComponent(int ident){
  En aux=getDefaultComponent();
  if (aux == null)   return ""String_Node_Str"";
  String space=""String_Node_Str"";
  if (ident < 0)   ident=0;
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  return space + ""String_Node_Str"" + aux.getId()+ ""String_Node_Str"";
}",0.9968944099378882
5295,"public void load(Element element) throws NCLParsingException {
  try {
    setRDFTree(element.getTextContent());
  }
 catch (  XMLException ex) {
    throw new NCLParsingException(""String_Node_Str"" + ex.getMessage());
  }
}","public void load(Element element) throws NCLParsingException {
  try {
    String aux=element.getTextContent();
    aux=aux.substring(1,aux.length() - 2);
    setRDFTree(aux);
  }
 catch (  XMLException ex) {
    throw new NCLParsingException(""String_Node_Str"" + ex.getMessage());
  }
}",0.7819253438113949
5296,"public boolean compare(T other){
  boolean comp=true;
  comp&=getComponent().compare(other.getComponent());
  comp&=getInterface().compare(other.getInterface());
  return comp;
}","public boolean compare(T other){
  boolean comp=true;
  En thisComp=getComponent();
  En otherComp=(En)other.getComponent();
  if (thisComp != null && otherComp != null)   comp&=thisComp.compare(otherComp);
 else   comp&=!(thisComp != null || otherComp != null);
  Ei thisInt=getInterface();
  Ei otherInt=(Ei)other.getInterface();
  if (thisInt != null && otherInt != null)   comp&=thisInt.compare(otherInt);
 else   comp&=!(thisInt != null || otherInt != null);
  return comp;
}",0.4407294832826747
5297,"/** 
 * Function to create the child element <i>port</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>port</i>.
 */
protected Ept createPort(Element element) throws XMLException {
  return (Ept)new NCLPort(element);
}","/** 
 * Function to create the child element <i>port</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>port</i>.
 */
protected Ept createPort() throws XMLException {
  return (Ept)new NCLPort();
}",0.96
5298,"/** 
 * Function to create the child element <i>context</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>context</i>.
 */
protected En createContext(Element element) throws XMLException {
  return (En)new NCLContext(element);
}","/** 
 * Function to create the child element <i>context</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>context</i>.
 */
protected En createContext() throws XMLException {
  return (En)new NCLContext();
}",0.9614035087719298
5299,"/** 
 * Function to create the child element <i>link</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>link</i>.
 */
protected El createLink(Element element) throws XMLException {
  return (El)new NCLLink(element);
}","/** 
 * Function to create the child element <i>link</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>link</i>.
 */
protected El createLink() throws XMLException {
  return (El)new NCLLink();
}",0.8351648351648352
5300,"public void load(Element element) throws XMLException {
  String att_name, att_var;
  NodeList nl;
  att_name=NCLElementAttributes.ID.toString();
  if (!(att_var=element.getAttribute(att_name)).isEmpty())   setId(att_var);
  nl=element.getChildNodes();
  for (int i=0; i < nl.getLength(); i++) {
    Node nd=nl.item(i);
    if (nd instanceof Element) {
      Element el=(Element)nl.item(i);
      if (el.getTagName().equals(NCLElementAttributes.PROPERTY.toString()))       addProperty(createProperty(el));
      if (el.getTagName().equals(NCLElementAttributes.META.toString()))       addMeta(createMeta(el));
      if (el.getTagName().equals(NCLElementAttributes.METADATA.toString()))       addMetadata(createMetadata(el));
      if (el.getTagName().equals(NCLElementAttributes.MEDIA.toString()))       addNode(createMedia(el));
      if (el.getTagName().equals(NCLElementAttributes.CONTEXT.toString()))       addNode(createContext(el));
      if (el.getTagName().equals(NCLElementAttributes.SWITCH.toString()))       addNode(createSwitch(el));
    }
  }
  nl=element.getChildNodes();
  for (int i=0; i < nl.getLength(); i++) {
    Node nd=nl.item(i);
    if (nd instanceof Element) {
      Element el=(Element)nl.item(i);
      if (el.getTagName().equals(NCLElementAttributes.PORT.toString()))       addPort(createPort(el));
      if (el.getTagName().equals(NCLElementAttributes.LINK.toString()))       addLink(createLink(el));
    }
  }
}","public void load(Element element) throws XMLException {
  String att_name, att_var;
  NodeList nl;
  att_name=NCLElementAttributes.ID.toString();
  if (!(att_var=element.getAttribute(att_name)).isEmpty())   setId(att_var);
  nl=element.getChildNodes();
  for (int i=0; i < nl.getLength(); i++) {
    Node nd=nl.item(i);
    if (nd instanceof Element) {
      Element el=(Element)nl.item(i);
      if (el.getTagName().equals(NCLElementAttributes.PROPERTY.toString())) {
        Epp inst=createProperty();
        addProperty(inst);
        inst.load(el);
      }
      if (el.getTagName().equals(NCLElementAttributes.META.toString())) {
        Em inst=createMeta();
        addMeta(inst);
        inst.load(el);
      }
      if (el.getTagName().equals(NCLElementAttributes.METADATA.toString())) {
        Emt inst=createMetadata();
        addMetadata(inst);
        inst.load(el);
      }
      if (el.getTagName().equals(NCLElementAttributes.MEDIA.toString())) {
        En inst=createMedia();
        addNode(inst);
        inst.load(el);
      }
      if (el.getTagName().equals(NCLElementAttributes.CONTEXT.toString())) {
        En inst=createContext();
        addNode(inst);
        inst.load(el);
      }
      if (el.getTagName().equals(NCLElementAttributes.SWITCH.toString())) {
        En inst=createSwitch();
        addNode(inst);
        inst.load(el);
      }
    }
  }
  nl=element.getChildNodes();
  for (int i=0; i < nl.getLength(); i++) {
    Node nd=nl.item(i);
    if (nd instanceof Element) {
      Element el=(Element)nl.item(i);
      if (el.getTagName().equals(NCLElementAttributes.PORT.toString())) {
        Ept inst=createPort();
        addPort(inst);
        inst.load(el);
      }
      if (el.getTagName().equals(NCLElementAttributes.LINK.toString())) {
        El inst=createLink();
        addLink(inst);
        inst.load(el);
      }
    }
  }
}",0.7715919349984953
5301,"/** 
 * Function to create the child element <i>media</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>media</i>.
 */
protected En createMedia(Element element) throws XMLException {
  return (En)new NCLMedia(element);
}","/** 
 * Function to create the child element <i>media</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>media</i>.
 */
protected En createMedia() throws XMLException {
  return (En)new NCLMedia();
}",0.96028880866426
5302,"/** 
 * Function to create the child element <i>switch</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>switch</i>.
 */
protected En createSwitch(Element element) throws XMLException {
  return (En)new NCLSwitch(element);
}","/** 
 * Function to create the child element <i>switch</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>switch</i>.
 */
protected En createSwitch() throws XMLException {
  return (En)new NCLSwitch();
}",0.9608540925266904
5303,"/** 
 * Function to create the child element <i>metadata</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>metadata</i>.
 */
protected Emt createMetadata(Element element) throws XMLException {
  return (Emt)new NCLMetadata(element);
}","/** 
 * Function to create the child element <i>metadata</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>metadata</i>.
 */
protected Emt createMetadata() throws XMLException {
  return (Emt)new NCLMetadata();
}",0.9621993127147768
5304,"public NCLBody(Element element) throws XMLException {
  super();
  load(element);
}","public NCLBody() throws XMLException {
  super();
}",0.7611940298507462
5305,"/** 
 * Function to create the child element <i>meta</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>meta</i>.
 */
protected Em createMeta(Element element) throws XMLException {
  return (Em)new NCLMeta(element);
}","/** 
 * Function to create the child element <i>meta</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>meta</i>.
 */
protected Em createMeta() throws XMLException {
  return (Em)new NCLMeta();
}",0.9597069597069596
5306,"/** 
 * Function to create the child element <i>property</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>property</i>.
 */
protected Epp createProperty(Element element) throws XMLException {
  return (Epp)new NCLProperty(element);
}","/** 
 * Function to create the child element <i>property</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>property</i>.
 */
protected Epp createProperty() throws XMLException {
  return (Epp)new NCLProperty();
}",0.9621993127147768
5307,"/** 
 * Loads the objects structure representing an NCL document from an XML file.
 * @param xmlFile file with the NCL document content.
 * @throws NCLParsingException if an error occur while parsing the document.
 */
public void loadXML(File xmlFile) throws NCLParsingException {
  try {
    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    DocumentBuilder parser=factory.newDocumentBuilder();
    Document doc=parser.parse(xmlFile);
    load(doc.getDocumentElement());
  }
 catch (  Exception e) {
    throw new NCLParsingException(e.fillInStackTrace());
  }
}","/** 
 * Loads the objects structure representing an NCL document from an XML file.
 * @param xmlFile file with the NCL document content.
 * @throws NCLParsingException if an error occur while parsing the document.
 */
public void loadXML(File xmlFile) throws XMLException {
  try {
    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    DocumentBuilder parser=factory.newDocumentBuilder();
    Document doc=parser.parse(xmlFile);
    load(doc.getDocumentElement());
  }
 catch (  SAXException e) {
    throw new NCLParsingException(e.fillInStackTrace());
  }
catch (  ParserConfigurationException e) {
    throw new NCLParsingException(e.fillInStackTrace());
  }
catch (  IOException e) {
    throw new NCLParsingException(e.fillInStackTrace());
  }
}",0.847682119205298
5308,"public void load(Element element) throws XMLException {
  String att_name, att_var, ch_name;
  Element el;
  att_name=NCLElementAttributes.ID.toString();
  if (!(att_var=element.getAttribute(att_name)).isEmpty())   setId(att_var);
  att_name=NCLElementAttributes.TITLE.toString();
  if (!(att_var=element.getAttribute(att_name)).isEmpty())   setTitle(att_var);
  att_name=NCLElementAttributes.XMLNS.toString();
  if (!(att_var=element.getAttribute(att_name)).isEmpty())   setXmlns(NCLNamespace.getEnumType(att_var));
  ch_name=NCLElementAttributes.HEAD.toString();
  el=(Element)element.getElementsByTagName(ch_name).item(0);
  setHead(createHead(el));
  ch_name=NCLElementAttributes.BODY.toString();
  el=(Element)element.getElementsByTagName(ch_name).item(0);
  setBody(createBody(el));
  NCLReferenceManager.getInstance().fixReferences();
}","public void load(Element element) throws XMLException {
  String att_name, att_var, ch_name;
  Element el;
  att_name=NCLElementAttributes.ID.toString();
  if (!(att_var=element.getAttribute(att_name)).isEmpty())   setId(att_var);
  att_name=NCLElementAttributes.TITLE.toString();
  if (!(att_var=element.getAttribute(att_name)).isEmpty())   setTitle(att_var);
  att_name=NCLElementAttributes.XMLNS.toString();
  if (!(att_var=element.getAttribute(att_name)).isEmpty())   setXmlns(NCLNamespace.getEnumType(att_var));
  ch_name=NCLElementAttributes.HEAD.toString();
  el=(Element)element.getElementsByTagName(ch_name).item(0);
  if (el != null) {
    Eh inst=createHead();
    setHead(inst);
    inst.load(el);
  }
  ch_name=NCLElementAttributes.BODY.toString();
  el=(Element)element.getElementsByTagName(ch_name).item(0);
  if (el != null) {
    Eb inst=createBody();
    setBody(inst);
    inst.load(el);
  }
  NCLReferenceManager.getInstance().fixReferences();
}",0.9015486725663716
5309,"/** 
 * Function to create the child element <i>body</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>body</i>.
 */
protected Eb createBody(Element element) throws XMLException {
  return (Eb)new NCLBody(element);
}","/** 
 * Function to create the child element <i>body</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>body</i>.
 */
protected Eb createBody() throws XMLException {
  return (Eb)new NCLBody();
}",0.9597069597069596
5310,"/** 
 * Function to create the child element <i>head</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>head</i>.
 */
protected Eh createHead(Element element) throws XMLException {
  return (Eh)new NCLHead(element);
}","/** 
 * Function to create the child element <i>head</i>. This function must be overwritten in classes that extends this one.
 * @return element representing the child <i>head</i>.
 */
protected Eh createHead() throws XMLException {
  return (Eh)new NCLHead();
}",0.9597069597069596
5311,"public void waitReference(PostReferenceElement element){
  for (  PostReferenceElement ref : references) {
    if (ref.getId().equals(element.getId())) {
      references.remove(ref);
      break;
    }
  }
  references.add(element);
}","public void waitReference(PostReferenceElement element){
  references.add(element);
}",0.53125
5312,"public void load(Element element) throws NCLParsingException {
  String att_name, att_var, ch_name;
  NodeList nl;
  try {
    att_name=NCLElementAttributes.ID.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setId(att_var);
 else     throw new NCLParsingException(""String_Node_Str"" + att_name + ""String_Node_Str"");
    att_name=NCLElementAttributes.PLAYER.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setPlayer(att_var);
    att_name=NCLElementAttributes.EXPLICITDUR.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setExplicitDur(new TimeType(att_var));
    att_name=NCLElementAttributes.FREEZE.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setFreeze(Boolean.parseBoolean(att_var));
    att_name=NCLElementAttributes.MOVEUP.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      Integer aux;
      try {
        aux=new Integer(att_var);
      }
 catch (      Exception e) {
        throw new NCLParsingException(""String_Node_Str"" + att_var + ""String_Node_Str"");
      }
      T desc=(T)new NCLDescriptor(att_var);
      desc.setFocusIndex(aux);
      setMoveUp(desc);
      NCLReferenceManager.getInstance().waitReference(this);
    }
    att_name=NCLElementAttributes.MOVERIGHT.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      Integer aux;
      try {
        aux=new Integer(att_var);
      }
 catch (      Exception e) {
        throw new NCLParsingException(""String_Node_Str"" + att_var + ""String_Node_Str"");
      }
      T desc=(T)new NCLDescriptor(att_var);
      desc.setFocusIndex(aux);
      setMoveRight(desc);
      NCLReferenceManager.getInstance().waitReference(this);
    }
    att_name=NCLElementAttributes.MOVELEFT.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      Integer aux;
      try {
        aux=new Integer(att_var);
      }
 catch (      Exception e) {
        throw new NCLParsingException(""String_Node_Str"" + att_var + ""String_Node_Str"");
      }
      T desc=(T)new NCLDescriptor(att_var);
      desc.setFocusIndex(aux);
      setMoveLeft(desc);
      NCLReferenceManager.getInstance().waitReference(this);
    }
    att_name=NCLElementAttributes.MOVEDOWN.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      Integer aux;
      try {
        aux=new Integer(att_var);
      }
 catch (      Exception e) {
        throw new NCLParsingException(""String_Node_Str"" + att_var + ""String_Node_Str"");
      }
      T desc=(T)new NCLDescriptor(att_var);
      desc.setFocusIndex(aux);
      setMoveDown(desc);
      NCLReferenceManager.getInstance().waitReference(this);
    }
    att_name=NCLElementAttributes.FOCUSINDEX.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      try {
        setFocusIndex(new Integer(att_var));
      }
 catch (      Exception e) {
        throw new NCLParsingException(""String_Node_Str"" + att_name + ""String_Node_Str""+ att_var+ ""String_Node_Str"");
      }
    }
    att_name=NCLElementAttributes.FOCUSBORDERCOLOR.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setFocusBorderColor(NCLColor.getEnumType(att_var));
    att_name=NCLElementAttributes.FOCUSBORDERWIDTH.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      try {
        setFocusBorderWidth(new Integer(att_var));
      }
 catch (      Exception e) {
        throw new NCLParsingException(""String_Node_Str"" + att_name + ""String_Node_Str""+ att_var+ ""String_Node_Str"");
      }
    }
    att_name=NCLElementAttributes.FOCUSBORDERTRANSPARENCY.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setFocusBorderTransparency(new PercentageType(att_var));
    att_name=NCLElementAttributes.FOCUSSRC.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setFocusSrc(new SrcType(att_var));
    att_name=NCLElementAttributes.FOCUSSELSRC.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setFocusSelSrc(new SrcType(att_var));
    att_name=NCLElementAttributes.SELBORDERCOLOR.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setSelBorderColor(NCLColor.getEnumType(att_var));
    att_name=NCLElementAttributes.TRANSIN.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      Et tran=(Et)NCLReferenceManager.getInstance().findTransitionReference(impl.getDoc(),att_var);
      setTransIn(tran);
    }
    att_name=NCLElementAttributes.TRANSOUT.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      Et tran=(Et)NCLReferenceManager.getInstance().findTransitionReference(impl.getDoc(),att_var);
      setTransOut(tran);
    }
    att_name=NCLElementAttributes.REGION.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      Er reg=(Er)NCLReferenceManager.getInstance().findRegionReference(impl.getDoc(),att_var);
      setRegion(reg);
    }
  }
 catch (  XMLException ex) {
    String aux=getId();
    if (aux != null)     aux=""String_Node_Str"" + aux + ""String_Node_Str"";
 else     aux=""String_Node_Str"";
    throw new NCLParsingException(""String_Node_Str"" + aux + ""String_Node_Str""+ ex.getMessage());
  }
  try {
    ch_name=NCLElementAttributes.DESCRIPTORPARAM.toString();
    nl=element.getElementsByTagName(ch_name);
    for (int i=0; i < nl.getLength(); i++) {
      Element el=(Element)nl.item(i);
      Ep inst=createParamByType(el);
      addDescriptorParam(inst);
      inst.load(el);
    }
  }
 catch (  XMLException ex) {
    String aux=getId();
    if (aux != null)     aux=""String_Node_Str"" + aux + ""String_Node_Str"";
 else     aux=""String_Node_Str"";
    throw new NCLParsingException(""String_Node_Str"" + aux + ""String_Node_Str""+ ex.getMessage());
  }
}","public void load(Element element) throws NCLParsingException {
  String att_name, att_var, ch_name;
  NodeList nl;
  try {
    att_name=NCLElementAttributes.ID.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setId(att_var);
 else     throw new NCLParsingException(""String_Node_Str"" + att_name + ""String_Node_Str"");
    att_name=NCLElementAttributes.PLAYER.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setPlayer(att_var);
    att_name=NCLElementAttributes.EXPLICITDUR.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setExplicitDur(new TimeType(att_var));
    att_name=NCLElementAttributes.FREEZE.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setFreeze(Boolean.parseBoolean(att_var));
    att_name=NCLElementAttributes.MOVEUP.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      Integer aux;
      try {
        aux=new Integer(att_var);
      }
 catch (      Exception e) {
        throw new NCLParsingException(""String_Node_Str"" + att_var + ""String_Node_Str"");
      }
      T desc=(T)new NCLDescriptor(""String_Node_Str"" + att_var);
      desc.setFocusIndex(aux);
      setMoveUp(desc);
      NCLReferenceManager.getInstance().waitReference(this);
    }
    att_name=NCLElementAttributes.MOVERIGHT.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      Integer aux;
      try {
        aux=new Integer(att_var);
      }
 catch (      Exception e) {
        throw new NCLParsingException(""String_Node_Str"" + att_var + ""String_Node_Str"");
      }
      T desc=(T)new NCLDescriptor(""String_Node_Str"" + att_var);
      desc.setFocusIndex(aux);
      setMoveRight(desc);
      NCLReferenceManager.getInstance().waitReference(this);
    }
    att_name=NCLElementAttributes.MOVELEFT.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      Integer aux;
      try {
        aux=new Integer(att_var);
      }
 catch (      Exception e) {
        throw new NCLParsingException(""String_Node_Str"" + att_var + ""String_Node_Str"");
      }
      T desc=(T)new NCLDescriptor(""String_Node_Str"" + att_var);
      desc.setFocusIndex(aux);
      setMoveLeft(desc);
      NCLReferenceManager.getInstance().waitReference(this);
    }
    att_name=NCLElementAttributes.MOVEDOWN.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      Integer aux;
      try {
        aux=new Integer(att_var);
      }
 catch (      Exception e) {
        throw new NCLParsingException(""String_Node_Str"" + att_var + ""String_Node_Str"");
      }
      T desc=(T)new NCLDescriptor(""String_Node_Str"" + att_var);
      desc.setFocusIndex(aux);
      setMoveDown(desc);
      NCLReferenceManager.getInstance().waitReference(this);
    }
    att_name=NCLElementAttributes.FOCUSINDEX.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      try {
        setFocusIndex(new Integer(att_var));
      }
 catch (      Exception e) {
        throw new NCLParsingException(""String_Node_Str"" + att_name + ""String_Node_Str""+ att_var+ ""String_Node_Str"");
      }
    }
    att_name=NCLElementAttributes.FOCUSBORDERCOLOR.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setFocusBorderColor(NCLColor.getEnumType(att_var));
    att_name=NCLElementAttributes.FOCUSBORDERWIDTH.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      try {
        setFocusBorderWidth(new Integer(att_var));
      }
 catch (      Exception e) {
        throw new NCLParsingException(""String_Node_Str"" + att_name + ""String_Node_Str""+ att_var+ ""String_Node_Str"");
      }
    }
    att_name=NCLElementAttributes.FOCUSBORDERTRANSPARENCY.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setFocusBorderTransparency(new PercentageType(att_var));
    att_name=NCLElementAttributes.FOCUSSRC.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setFocusSrc(new SrcType(att_var));
    att_name=NCLElementAttributes.FOCUSSELSRC.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setFocusSelSrc(new SrcType(att_var));
    att_name=NCLElementAttributes.SELBORDERCOLOR.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty())     setSelBorderColor(NCLColor.getEnumType(att_var));
    att_name=NCLElementAttributes.TRANSIN.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      Et tran=(Et)NCLReferenceManager.getInstance().findTransitionReference(impl.getDoc(),att_var);
      setTransIn(tran);
    }
    att_name=NCLElementAttributes.TRANSOUT.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      Et tran=(Et)NCLReferenceManager.getInstance().findTransitionReference(impl.getDoc(),att_var);
      setTransOut(tran);
    }
    att_name=NCLElementAttributes.REGION.toString();
    if (!(att_var=element.getAttribute(att_name)).isEmpty()) {
      Er reg=(Er)NCLReferenceManager.getInstance().findRegionReference(impl.getDoc(),att_var);
      setRegion(reg);
    }
  }
 catch (  XMLException ex) {
    String aux=getId();
    if (aux != null)     aux=""String_Node_Str"" + aux + ""String_Node_Str"";
 else     aux=""String_Node_Str"";
    throw new NCLParsingException(""String_Node_Str"" + aux + ""String_Node_Str""+ ex.getMessage());
  }
  try {
    ch_name=NCLElementAttributes.DESCRIPTORPARAM.toString();
    nl=element.getElementsByTagName(ch_name);
    for (int i=0; i < nl.getLength(); i++) {
      Element el=(Element)nl.item(i);
      Ep inst=createParamByType(el);
      addDescriptorParam(inst);
      inst.load(el);
    }
  }
 catch (  XMLException ex) {
    String aux=getId();
    if (aux != null)     aux=""String_Node_Str"" + aux + ""String_Node_Str"";
 else     aux=""String_Node_Str"";
    throw new NCLParsingException(""String_Node_Str"" + aux + ""String_Node_Str""+ ex.getMessage());
  }
}",0.9932203389830508
5313,"public El findDescriptor(Integer focusIndex) throws XMLException {
  if (this.focusIndex == focusIndex)   return (El)this;
 else   return null;
}","public El findDescriptor(Integer focusIndex) throws XMLException {
  if (this.focusIndex != null && this.focusIndex.intValue() == focusIndex.intValue())   return (El)this;
 else   return null;
}",0.855457227138643
5314,"public boolean compare(T other){
  boolean comp=true;
  if (getXconnector() != null && other.getXconnector() != null)   comp&=getXconnector().compare(other.getXconnector());
  comp&=linkParams.size() == other.getLinkParams().size();
  comp&=binds.size() == other.getBinds().size();
  Iterator it=other.getLinkParams().iterator();
  for (  Ep param : linkParams) {
    Ep other_param=(Ep)it.next();
    comp&=param.compare(other_param);
    if (comp)     break;
  }
  it=other.getBinds().iterator();
  for (  Eb bind : binds) {
    if (!it.hasNext())     continue;
    Eb other_bind=(Eb)it.next();
    comp=bind.compare(other_bind);
    if (comp)     break;
  }
  return comp;
}","public boolean compare(T other){
  boolean comp=true;
  if (getXconnector() != null && other.getXconnector() != null)   comp&=getXconnector().compare(other.getXconnector());
  comp&=linkParams.size() == other.getLinkParams().size();
  comp&=binds.size() == other.getBinds().size();
  Iterator it=other.getLinkParams().iterator();
  for (  Ep param : linkParams) {
    Ep other_param=(Ep)it.next();
    comp&=param.compare(other_param);
    if (comp)     break;
  }
  it=other.getBinds().iterator();
  for (  Eb bind : binds) {
    if (!it.hasNext())     continue;
    Eb other_bind=(Eb)it.next();
    comp&=bind.compare(other_bind);
    if (comp)     break;
  }
  return comp;
}",0.9992619926199262
5315,"/** 
 * Retorna o tipo da mdia de acordo com seu tipo especificado ou sua URL.
 * @return elemento representando o tipo da mdia.
 */
public NCLMediaType getMediaType(){
  if (getType() != null) {
    boolean status=false;
    status|=(getType() == NCLMimeType.APPLICATION_X_GINGA_NCLET);
    status|=(getType() == NCLMimeType.APPLICATION_X_GINGA_NCLUA);
    if (status)     return NCLMediaType.PROCEDURAL;
    status|=(getType() == NCLMimeType.AUDIO_BASIC);
    status|=(getType() == NCLMimeType.AUDIO_MP2);
    status|=(getType() == NCLMimeType.AUDIO_MP3);
    status|=(getType() == NCLMimeType.AUDIO_MPEG);
    status|=(getType() == NCLMimeType.AUDIO_MPEG4);
    if (status)     return NCLMediaType.AUDIO;
    status|=(getType() == NCLMimeType.IMAGE_BMP);
    status|=(getType() == NCLMimeType.IMAGE_GIF);
    status|=(getType() == NCLMimeType.IMAGE_JPEG);
    status|=(getType() == NCLMimeType.IMAGE_PNG);
    if (status)     return NCLMediaType.IMAGE;
    status|=(getType() == NCLMimeType.VIDEO_MPEG);
    if (status)     return NCLMediaType.VIDEO;
    status|=(getType() == NCLMimeType.TEXT_CSS);
    status|=(getType() == NCLMimeType.TEXT_HTML);
    status|=(getType() == NCLMimeType.TEXT_PLAIN);
    status|=(getType() == NCLMimeType.TEXT_XML);
    if (status)     return NCLMediaType.TEXT;
  }
  if (getSrc() != null) {
    boolean status=false;
    String ext=getSrc().getExtension();
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    if (status)     return NCLMediaType.TEXT;
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    if (status)     return NCLMediaType.IMAGE;
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    if (status)     return NCLMediaType.AUDIO;
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    if (status)     return NCLMediaType.VIDEO;
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    status|=ext.contentEquals(""String_Node_Str"");
    if (status)     return NCLMediaType.PROCEDURAL;
  }
  return NCLMediaType.OTHER;
}","/** 
 * Retorna o tipo da mdia de acordo com seu tipo especificado ou sua URL.
 * @return elemento representando o tipo da mdia.
 */
public NCLMediaType getMediaType(){
  if (getType() != null) {
    try {
      return NCLMediaType.getEnumType(getType());
    }
 catch (    NCLParsingException e) {
    }
  }
  if (getSrc() != null) {
    try {
      return NCLMediaType.getEnumType(getSrc().getExtension());
    }
 catch (    NCLParsingException e) {
    }
  }
  return NCLMediaType.OTHER;
}",0.1561135371179039
5316,"public Er findRole(String name){
  Er result;
  for (  Ec condition : conditions) {
    result=(Er)condition.findRole(name);
    if (result != null)     return result;
  }
  return null;
}","public Er findRole(String name){
  Er result;
  for (  Ec condition : conditions) {
    result=(Er)condition.findRole(name);
    if (result != null)     return result;
  }
  for (  Es statement : statements) {
    result=(Er)statement.findRole(name);
    if (result != null)     return result;
  }
  return null;
}",0.6972111553784861
5317,"public void load(Element element) throws NCLParsingException, XMLException {
  String att_name, att_var;
  att_name=NCLElementAttributes.VALUEASSESSMENT.toString();
  if (!(att_var=element.getAttribute(att_name)).isEmpty())   setValue(new AssValueParamType(att_var,this));
 else   throw new NCLParsingException(""String_Node_Str"" + att_name + ""String_Node_Str"");
}","public void load(Element element) throws NCLParsingException, XMLException {
  String att_name, att_var;
  att_name=NCLElementAttributes.VALUE.toString();
  if (!(att_var=element.getAttribute(att_name)).isEmpty())   setValue(new AssValueParamType(att_var,this));
 else   throw new NCLParsingException(""String_Node_Str"" + att_name + ""String_Node_Str"");
}",0.9860335195530726
5318,"@Override public void setValue(AssValueParamType<Ep,T> value){
  AssValueParamType aux=this.value;
  super.setValue(value);
  impl.notifyAltered(NCLElementAttributes.VALUEASSESSMENT,aux,value);
}","@Override public void setValue(AssValueParamType<Ep,T> value){
  AssValueParamType aux=this.value;
  super.setValue(value);
  impl.notifyAltered(NCLElementAttributes.VALUE,aux,value);
}",0.9736842105263158
5319,"@Override protected Double createValue(String value) throws XMLException {
  return new Double(value);
}","@Override protected Double createValue(String value) throws XMLException {
  int index=value.indexOf(""String_Node_Str"");
  if (index > 0)   value=value.substring(0,index);
  return new Double(value);
}",0.6819672131147541
5320,"public boolean compare(T other){
  boolean comp=true;
  String this_stat, other_stat;
  NCLAssessmentStatementPrototype other_asses;
  if (!(other instanceof NCLAssessmentStatementPrototype))   return false;
  other_asses=(NCLAssessmentStatementPrototype)other;
  if (getComparator() == null)   this_stat=""String_Node_Str"";
 else   this_stat=getComparator().toString();
  if (other_asses.getComparator() == null)   other_stat=""String_Node_Str"";
 else   other_stat=other_asses.getComparator().toString();
  comp&=this_stat.equals(other_stat);
  comp&=attributeAssessments.size() == other_asses.getAttributeAssessments().size();
  Iterator it=other_asses.getAttributeAssessments().iterator();
  for (  NCLAttributeAssessmentPrototype att : attributeAssessments) {
    NCLAttributeAssessmentPrototype other_att=(NCLAttributeAssessmentPrototype)it.next();
    comp&=att.compare(other_att);
    if (comp)     break;
  }
  if (getValueAssessment() != null && other_asses.getValueAssessment() != null)   comp&=getValueAssessment().compare(other_asses.getValueAssessment());
  return comp;
}","public boolean compare(Es other){
  boolean comp=true;
  String this_stat, other_stat;
  NCLAssessmentStatementPrototype other_asses;
  if (!(other instanceof NCLAssessmentStatementPrototype))   return false;
  other_asses=(NCLAssessmentStatementPrototype)other;
  if (getComparator() == null)   this_stat=""String_Node_Str"";
 else   this_stat=getComparator().toString();
  if (other_asses.getComparator() == null)   other_stat=""String_Node_Str"";
 else   other_stat=other_asses.getComparator().toString();
  comp&=this_stat.equals(other_stat);
  comp&=attributeAssessments.size() == other_asses.getAttributeAssessments().size();
  Iterator it=other_asses.getAttributeAssessments().iterator();
  for (  NCLAttributeAssessmentPrototype att : attributeAssessments) {
    if (!it.hasNext())     continue;
    NCLAttributeAssessmentPrototype other_att=(NCLAttributeAssessmentPrototype)it.next();
    comp&=att.compare(other_att);
    if (comp)     break;
  }
  if (getValueAssessment() != null && other_asses.getValueAssessment() != null)   comp&=getValueAssessment().compare(other_asses.getValueAssessment());
  return comp;
}",0.9818511796733213
5321,"public boolean compare(Ea other){
  boolean comp=true;
  String this_act, other_act;
  NCLCompoundActionPrototype other_comp;
  if (!(other instanceof NCLCompoundActionPrototype))   return false;
  other_comp=(NCLCompoundActionPrototype)other;
  if (getOperator() == null)   this_act=""String_Node_Str"";
 else   this_act=getOperator().toString();
  if (other_comp.getOperator() == null)   other_act=""String_Node_Str"";
 else   other_act=other_comp.getOperator().toString();
  comp=this_act.equals(other_act);
  if (getDelay() == null)   this_act=""String_Node_Str"";
 else   this_act=getDelay().parse();
  if (other_comp.getDelay() == null)   other_act=""String_Node_Str"";
 else   other_act=other_comp.getDelay().parse();
  comp&=this_act.equals(other_act);
  comp&=actions.size() == other_comp.getActions().size();
  Iterator it=other_comp.getActions().iterator();
  for (  NCLAction a : actions) {
    NCLAction other_a=(NCLAction)it.next();
    comp&=a.compare(other_a);
    if (comp)     break;
  }
  return comp;
}","public boolean compare(Ea other){
  boolean comp=true;
  String this_act, other_act;
  NCLCompoundActionPrototype other_comp;
  if (!(other instanceof NCLCompoundActionPrototype))   return false;
  other_comp=(NCLCompoundActionPrototype)other;
  if (getOperator() == null)   this_act=""String_Node_Str"";
 else   this_act=getOperator().toString();
  if (other_comp.getOperator() == null)   other_act=""String_Node_Str"";
 else   other_act=other_comp.getOperator().toString();
  comp=this_act.equals(other_act);
  if (getDelay() == null)   this_act=""String_Node_Str"";
 else   this_act=getDelay().parse();
  if (other_comp.getDelay() == null)   other_act=""String_Node_Str"";
 else   other_act=other_comp.getDelay().parse();
  comp&=this_act.equals(other_act);
  comp&=actions.size() == other_comp.getActions().size();
  Iterator it=other_comp.getActions().iterator();
  for (  NCLAction a : actions) {
    if (!it.hasNext())     continue;
    NCLAction other_a=(NCLAction)it.next();
    comp&=a.compare(other_a);
    if (comp)     break;
  }
  return comp;
}",0.9820823244552058
5322,"public boolean compare(Ec other){
  boolean comp=true;
  String this_cond, other_cond;
  NCLCompoundConditionPrototype other_comp;
  if (!(other instanceof NCLCompoundConditionPrototype))   return false;
  other_comp=(NCLCompoundConditionPrototype)other;
  if (getOperator() == null)   this_cond=""String_Node_Str"";
 else   this_cond=getOperator().toString();
  if (other_comp.getOperator() == null)   other_cond=""String_Node_Str"";
 else   other_cond=other_comp.getOperator().toString();
  comp&=this_cond.equals(other_cond);
  if (getDelay() == null)   this_cond=""String_Node_Str"";
 else   this_cond=getDelay().parse();
  if (other_comp.getDelay() == null)   other_cond=""String_Node_Str"";
 else   other_cond=other_comp.getDelay().parse();
  comp&=this_cond.equals(other_cond);
  comp&=conditions.size() == other_comp.getConditions().size();
  Iterator it=other_comp.getConditions().iterator();
  for (  NCLCondition c : conditions) {
    NCLCondition other_c=(NCLCondition)it.next();
    comp&=c.compare(other_c);
    if (comp)     break;
  }
  comp&=statements.size() == other_comp.getStatements().size();
  it=other_comp.getStatements().iterator();
  for (  NCLStatement st : statements) {
    NCLStatement other_st=(NCLStatement)it.next();
    comp&=st.compare(other_st);
    if (comp)     break;
  }
  return comp;
}","public boolean compare(Ec other){
  boolean comp=true;
  String this_cond, other_cond;
  NCLCompoundConditionPrototype other_comp;
  if (!(other instanceof NCLCompoundConditionPrototype))   return false;
  other_comp=(NCLCompoundConditionPrototype)other;
  if (getOperator() == null)   this_cond=""String_Node_Str"";
 else   this_cond=getOperator().toString();
  if (other_comp.getOperator() == null)   other_cond=""String_Node_Str"";
 else   other_cond=other_comp.getOperator().toString();
  comp&=this_cond.equals(other_cond);
  if (getDelay() == null)   this_cond=""String_Node_Str"";
 else   this_cond=getDelay().parse();
  if (other_comp.getDelay() == null)   other_cond=""String_Node_Str"";
 else   other_cond=other_comp.getDelay().parse();
  comp&=this_cond.equals(other_cond);
  comp&=conditions.size() == other_comp.getConditions().size();
  Iterator it=other_comp.getConditions().iterator();
  for (  NCLCondition c : conditions) {
    if (!it.hasNext())     continue;
    NCLCondition other_c=(NCLCondition)it.next();
    comp&=c.compare(other_c);
    if (comp)     break;
  }
  comp&=statements.size() == other_comp.getStatements().size();
  it=other_comp.getStatements().iterator();
  for (  NCLStatement st : statements) {
    if (!it.hasNext())     continue;
    NCLStatement other_st=(NCLStatement)it.next();
    comp&=st.compare(other_st);
    if (comp)     break;
  }
  return comp;
}",0.9727339719970524
5323,"public boolean compare(Es other){
  boolean comp=true;
  String this_stat, other_stat;
  NCLCompoundStatementPrototype other_comp;
  if (!(other instanceof NCLCompoundStatementPrototype))   return false;
  other_comp=(NCLCompoundStatementPrototype)other;
  if (getOperator() == null)   this_stat=""String_Node_Str"";
 else   this_stat=getOperator().toString();
  if (other_comp.getOperator() == null)   other_stat=""String_Node_Str"";
 else   other_stat=other_comp.getOperator().toString();
  comp&=this_stat.equals(other_stat);
  if (getIsNegated() == null)   this_stat=""String_Node_Str"";
 else   this_stat=getIsNegated().toString();
  if (other_comp.getIsNegated() == null)   other_stat=""String_Node_Str"";
 else   other_stat=other_comp.getIsNegated().toString();
  comp&=this_stat.equals(other_stat);
  comp&=statements.size() == other_comp.getStatements().size();
  Iterator it=other_comp.getStatements().iterator();
  for (  NCLStatement st : statements) {
    NCLStatement other_st=(NCLStatement)it.next();
    comp&=st.compare(other_st);
    if (comp)     break;
  }
  return comp;
}","public boolean compare(Es other){
  boolean comp=true;
  String this_stat, other_stat;
  NCLCompoundStatementPrototype other_comp;
  if (!(other instanceof NCLCompoundStatementPrototype))   return false;
  other_comp=(NCLCompoundStatementPrototype)other;
  if (getOperator() == null)   this_stat=""String_Node_Str"";
 else   this_stat=getOperator().toString();
  if (other_comp.getOperator() == null)   other_stat=""String_Node_Str"";
 else   other_stat=other_comp.getOperator().toString();
  comp&=this_stat.equals(other_stat);
  if (getIsNegated() == null)   this_stat=""String_Node_Str"";
 else   this_stat=getIsNegated().toString();
  if (other_comp.getIsNegated() == null)   other_stat=""String_Node_Str"";
 else   other_stat=other_comp.getIsNegated().toString();
  comp&=this_stat.equals(other_stat);
  comp&=statements.size() == other_comp.getStatements().size();
  Iterator it=other_comp.getStatements().iterator();
  for (  NCLStatement st : statements) {
    if (!it.hasNext())     continue;
    NCLStatement other_st=(NCLStatement)it.next();
    comp&=st.compare(other_st);
    if (comp)     break;
  }
  return comp;
}",0.983235160851835
5324,"public NCLBody() throws XMLException {
  super();
  impl=(I)new NCLElementImpl(this);
}","public NCLBody() throws XMLException {
  super();
}",0.7391304347826086
5325,"public NCLDoc() throws XMLException {
  super();
  impl=(I)new NCLElementImpl(this);
}","public NCLDoc() throws XMLException {
  super();
}",0.7352941176470589
5326,"public NCLHead() throws XMLException {
  super();
  impl=(I)new NCLElementImpl(this);
}","public NCLHead() throws XMLException {
  super();
}",0.7391304347826086
5327,"public NCLAssessmentStatement() throws XMLException {
  super();
  impl=(I)new NCLElementImpl(this);
}","public NCLAssessmentStatement() throws XMLException {
  super();
}",0.7857142857142857
5328,"public NCLAttributeAssessment() throws XMLException {
  super();
  impl=(I)new NCLElementImpl(this);
}","public NCLAttributeAssessment() throws XMLException {
  super();
}",0.7857142857142857
5329,"public NCLCausalConnector(String id) throws XMLException {
  super(id);
  impl=(I)new NCLElementImpl(this);
}","public NCLCausalConnector(String id) throws XMLException {
  super(id);
}",0.8021978021978022
5330,"public NCLCompoundAction() throws XMLException {
  super();
  impl=(I)new NCLElementImpl(this);
}","public NCLCompoundAction() throws XMLException {
  super();
}",0.7721518987341772
5331,"public NCLCompoundCondition() throws XMLException {
  super();
  impl=(I)new NCLElementImpl(this);
}","public NCLCompoundCondition() throws XMLException {
  super();
}",0.7804878048780488
5332,"public NCLCompoundStatement() throws XMLException {
  super();
  impl=(I)new NCLElementImpl(this);
}","public NCLCompoundStatement() throws XMLException {
  super();
}",0.7804878048780488
5333,"public NCLConnectorBase() throws XMLException {
  super();
  impl=(I)new NCLElementImpl(this);
}","public NCLConnectorBase() throws XMLException {
  super();
}",0.7692307692307693
5334,"public NCLConnectorParam(String name) throws XMLException {
  super(name);
  impl=(I)new NCLElementImpl(this);
}","public NCLConnectorParam(String name) throws XMLException {
  super(name);
}",0.8085106382978723
5335,"public NCLSimpleAction() throws XMLException {
  super();
  impl=(I)new NCLElementImpl(this);
}","public NCLSimpleAction() throws XMLException {
  super();
}",0.7662337662337663
5336,"public NCLSimpleCondition() throws XMLException {
  super();
  impl=(I)new NCLElementImpl(this);
}","public NCLSimpleCondition() throws XMLException {
  super();
}",0.775
5337,"public NCLDocPrototype(){
  super();
}","public NCLDocPrototype() throws XMLException {
  super();
}",0.7835051546391752
5338,"/** 
 * Construtor do elemento <i>head</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLHeadPrototype(){
  super();
  regionBases=new IdentifiableElementList<Erb,T>();
  metas=new ElementList<Em,T>();
  metadatas=new ElementList<Emt,T>();
}","/** 
 * Construtor do elemento <i>head</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLHeadPrototype() throws XMLException {
  super();
  regionBases=new IdentifiableElementList<Erb,T>();
  metas=new ElementList<Em,T>();
  metadatas=new ElementList<Emt,T>();
}",0.9596928982725528
5339,"public NCLIdentifiableElementPrototype(){
  impl=(I)new NCLElementImpl<T,P>();
}","public NCLIdentifiableElementPrototype() throws XMLException {
  super();
}",0.6580645161290323
5340,"/** 
 * Construtor do elemento <i>assessmentStatement</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLAssessmentStatementPrototype(){
  super();
  attributeAssessments=new ElementList<Ea,T>();
}","/** 
 * Construtor do elemento <i>assessmentStatement</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLAssessmentStatementPrototype() throws XMLException {
  super();
  attributeAssessments=new ElementList<Ea,T>();
}",0.951276102088167
5341,"/** 
 * Construtor do elemento <i>attributeStatement</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLAttributeAssessmentPrototype(){
  super();
}","/** 
 * Construtor do elemento <i>attributeStatement</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLAttributeAssessmentPrototype() throws XMLException {
  super();
}",0.9369369369369368
5342,"/** 
 * Construtor do elemento <i>compoundAction</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLCompoundActionPrototype(){
  super();
  actions=new ElementList<Ea,T>();
}","/** 
 * Construtor do elemento <i>compoundAction</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLCompoundActionPrototype() throws XMLException {
  super();
  actions=new ElementList<Ea,T>();
}",0.9454545454545454
5343,"/** 
 * Construtor do elemento <i>compoundCondition</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLCompoundConditionPrototype(){
  super();
  conditions=new ElementList<Ec,T>();
  statements=new ElementList<Es,T>();
}","/** 
 * Construtor do elemento <i>compoundCondition</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLCompoundConditionPrototype() throws XMLException {
  super();
  conditions=new ElementList<Ec,T>();
  statements=new ElementList<Es,T>();
}",0.9561586638830898
5344,"/** 
 * Construtor do elemento <i>compoundStatement</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLCompoundStatementPrototype(){
  super();
  statements=new ElementList<Es,T>();
}","/** 
 * Construtor do elemento <i>compoundStatement</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLCompoundStatementPrototype() throws XMLException {
  super();
  statements=new ElementList<Es,T>();
}",0.9478908188585607
5345,"/** 
 * Construtor do elemento <i>connectorBase</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLConnectorBasePrototype(){
  super();
  connectors=new IdentifiableElementList<Ec,T>();
  imports=new ElementList<Ei,T>();
}","/** 
 * Construtor do elemento <i>connectorBase</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLConnectorBasePrototype() throws XMLException {
  super();
  connectors=new IdentifiableElementList<Ec,T>();
  imports=new ElementList<Ei,T>();
}",0.9563409563409564
5346,"/** 
 * Construtor do elemento <i>simpleAction</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLSimpleActionPrototype(){
  super();
}","/** 
 * Construtor do elemento <i>simpleAction</i> da <i>Nested Context Language</i> (NCL).
 */
public NCLSimpleActionPrototype() throws XMLException {
  super();
}",0.9315960912052116
5347,"@Override protected String getParamValue(){
  if (getRelative())   return ""String_Node_Str"" + getValue().intValue() + ""String_Node_Str"";
 else   return ""String_Node_Str"" + getValue().intValue();
}","@Override protected String getParamValue(){
  if (getRelative() != null && !getRelative())   return ""String_Node_Str"" + getValue().intValue() + ""String_Node_Str"";
 else   return ""String_Node_Str"" + getValue().intValue();
}",0.937799043062201
5348,"public int compareTo(L other){
  int comp=0;
  if (getXconnector() != null)   comp=getXconnector().compareTo(other.getXconnector());
 else   comp=1;
  if (comp == 0)   comp=linkParams.size() - ((Set)other.getLinkParams()).size();
  if (comp == 0)   comp=binds.size() - ((Set)other.getBinds()).size();
  if (comp == 0) {
    Iterator it=other.getLinkParams().iterator();
    for (    P param : linkParams) {
      P other_param=(P)it.next();
      comp=param.compareTo(other_param);
      if (comp != 0)       break;
    }
  }
  if (comp == 0) {
    Iterator it=other.getBinds().iterator();
    for (    B bind : binds) {
      B other_bind=(B)it.next();
      comp=bind.compareTo(other_bind);
      if (comp != 0)       break;
    }
  }
  return comp;
}","public int compareTo(L other){
  int comp=0;
  if (getXconnector() != null)   comp=getXconnector().compareTo(other.getXconnector());
 else   comp=1;
  if (comp == 0)   comp=linkParams.size() - ((Set)other.getLinkParams()).size();
  if (comp == 0)   comp=binds.size() - ((List)other.getBinds()).size();
  if (comp == 0) {
    Iterator it=other.getLinkParams().iterator();
    for (    P param : linkParams) {
      P other_param=(P)it.next();
      comp=param.compareTo(other_param);
      if (comp != 0)       break;
    }
  }
  if (comp == 0) {
    Iterator it=other.getBinds().iterator();
    for (    B bind : binds) {
      B other_bind=(B)it.next();
      comp=bind.compareTo(other_bind);
      if (comp != 0)       break;
    }
  }
  return comp;
}",0.9966821499668216
5349,"/** 
 * Adiciona um atributo de comparao a assertiva.
 * @param attribute elemento representando o atributo a ser adicionado.
 * @return verdadeiro se o atributo foi adicionado.
 * @throws java.lang.Exception se o nmero mximo de atributos for ultrapassado.
 * @see TreeSet#add
 */
public boolean addAttributeAssessment(A attribute) throws Exception {
  if (attributeAssessments.size() == 2)   throw new Exception(""String_Node_Str"");
  if (attributeAssessments.add(attribute)) {
    if (attribute != null)     attribute.setParent(this);
    return true;
  }
  return false;
}","/** 
 * Adiciona um atributo de comparao a assertiva.
 * @param attribute elemento representando o atributo a ser adicionado.
 * @return verdadeiro se o atributo foi adicionado.
 * @throws java.lang.Exception se o nmero mximo de atributos for ultrapassado.
 * @see ArrayList#add
 */
public boolean addAttributeAssessment(A attribute) throws Exception {
  if (attributeAssessments.size() == 2)   throw new Exception(""String_Node_Str"");
  if (attribute != null && attributeAssessments.add(attribute)) {
    attribute.setParent(this);
    return true;
  }
  return false;
}",0.9079861111111112
5350,"public int compareTo(S other){
  int comp=0;
  String this_stat, other_stat;
  NCLAssessmentStatement other_asses;
  if (!(other instanceof NCLAssessmentStatement))   return -1;
  other_asses=(NCLAssessmentStatement)other;
  if (comp == 0) {
    if (getComparator() == null)     this_stat=""String_Node_Str"";
 else     this_stat=getComparator().toString();
    if (other_asses.getComparator() == null)     other_stat=""String_Node_Str"";
 else     other_stat=other_asses.getComparator().toString();
    comp=this_stat.compareTo(other_stat);
  }
  if (comp == 0)   comp=attributeAssessments.size() - ((Set)other_asses.getAttributeAssessments()).size();
  if (comp == 0) {
    Iterator it=other_asses.getAttributeAssessments().iterator();
    for (    NCLAttributeAssessment att : attributeAssessments) {
      NCLAttributeAssessment other_att=(NCLAttributeAssessment)it.next();
      comp=att.compareTo(other_att);
      if (comp != 0)       break;
    }
  }
  if (comp == 0) {
    if (getValueAssessment() == null && other_asses.getValueAssessment() == null)     comp=0;
 else     if (getValueAssessment() != null && other_asses.getValueAssessment() != null)     comp=getValueAssessment().compareTo(other_asses.getValueAssessment());
 else     comp=1;
  }
  if (comp != 0)   return 1;
 else   return 0;
}","public int compareTo(S other){
  int comp=0;
  String this_stat, other_stat;
  NCLAssessmentStatement other_asses;
  if (!(other instanceof NCLAssessmentStatement))   return -1;
  other_asses=(NCLAssessmentStatement)other;
  if (comp == 0) {
    if (getComparator() == null)     this_stat=""String_Node_Str"";
 else     this_stat=getComparator().toString();
    if (other_asses.getComparator() == null)     other_stat=""String_Node_Str"";
 else     other_stat=other_asses.getComparator().toString();
    comp=this_stat.compareTo(other_stat);
  }
  if (comp == 0)   comp=attributeAssessments.size() - ((List)other_asses.getAttributeAssessments()).size();
  if (comp == 0) {
    Iterator it=other_asses.getAttributeAssessments().iterator();
    for (    NCLAttributeAssessment att : attributeAssessments) {
      NCLAttributeAssessment other_att=(NCLAttributeAssessment)it.next();
      comp=att.compareTo(other_att);
      if (comp != 0)       break;
    }
  }
  if (comp == 0) {
    if (getValueAssessment() == null && other_asses.getValueAssessment() == null)     comp=0;
 else     if (getValueAssessment() != null && other_asses.getValueAssessment() != null)     comp=getValueAssessment().compareTo(other_asses.getValueAssessment());
 else     if (getValueAssessment() == null)     comp=-1;
 else     comp=1;
  }
  return comp;
}",0.952054794520548
5351,"/** 
 * Remove um atributo de comparao da assertiva.
 * @param attribute elemento representando o atributo a ser removido.
 * @return verdadeiro se o atributo for removido.
 * @see TreeSet#remove
 */
public boolean removeAttributeAssessment(A attribute){
  if (attributeAssessments.remove(attribute)) {
    if (attribute != null)     attribute.setParent(null);
    return true;
  }
  return false;
}","/** 
 * Remove um atributo de comparao da assertiva.
 * @param attribute elemento representando o atributo a ser removido.
 * @return verdadeiro se o atributo for removido.
 * @see ArrayList#remove
 */
public boolean removeAttributeAssessment(A attribute){
  if (attributeAssessments.remove(attribute)) {
    if (attribute != null)     attribute.setParent(null);
    return true;
  }
  return false;
}",0.9825870646766168
5352,"public int compareTo(A other){
  int comp=0;
  String this_att, other_att;
  if (getRole() == null)   this_att=""String_Node_Str"";
 else   this_att=getRole().getName();
  if (other.getRole() == null)   other_att=""String_Node_Str"";
 else   other_att=other.getRole().getName();
  comp=this_att.compareTo(other_att);
  if (comp == 0) {
    if (getEventType() == null)     this_att=""String_Node_Str"";
 else     this_att=getEventType().toString();
    if (other.getEventType() == null)     other_att=""String_Node_Str"";
 else     other_att=other.getEventType().toString();
    comp=this_att.compareTo(other_att);
  }
  if (comp == 0) {
    if (getAttributeType() == null)     this_att=""String_Node_Str"";
 else     this_att=getAttributeType().toString();
    if (other.getAttributeType() == null)     other_att=""String_Node_Str"";
 else     other_att=other.getAttributeType().toString();
    comp=this_att.compareTo(other_att);
  }
  if (comp == 0) {
    int this_off, other_off;
    if (getOffset() == null)     this_off=0;
 else     this_off=getOffset();
    if (other.getOffset() == null)     other_off=0;
 else     other_off=other.getOffset();
    comp=this_off - other_off;
  }
  if (comp == 0) {
    if (getParamOffset() == null && other.getParamOffset() == null)     comp=0;
 else     if (getParamOffset() != null && other.getParamOffset() != null)     comp=getParamOffset().compareTo(other.getParamOffset());
 else     comp=1;
  }
  if (comp == 0) {
    if (getKey() == null)     this_att=""String_Node_Str"";
 else     this_att=getKey().toString();
    if (other.getKey() == null)     other_att=""String_Node_Str"";
 else     other_att=other.getKey().toString();
    comp=this_att.compareTo(other_att);
  }
  if (comp == 0) {
    if (getParamKey() == null && other.getParamKey() == null)     comp=0;
 else     if (getParamKey() != null && other.getParamKey() != null)     comp=getParamKey().compareTo(other.getParamKey());
 else     comp=1;
  }
  if (comp != 0)   return 1;
 else   return 0;
}","public int compareTo(A other){
  int comp=0;
  String this_att, other_att;
  if (getRole() == null)   this_att=""String_Node_Str"";
 else   this_att=getRole().getName();
  if (other.getRole() == null)   other_att=""String_Node_Str"";
 else   other_att=other.getRole().getName();
  comp=this_att.compareTo(other_att);
  if (comp == 0) {
    if (getEventType() == null)     this_att=""String_Node_Str"";
 else     this_att=getEventType().toString();
    if (other.getEventType() == null)     other_att=""String_Node_Str"";
 else     other_att=other.getEventType().toString();
    comp=this_att.compareTo(other_att);
  }
  if (comp == 0) {
    if (getAttributeType() == null)     this_att=""String_Node_Str"";
 else     this_att=getAttributeType().toString();
    if (other.getAttributeType() == null)     other_att=""String_Node_Str"";
 else     other_att=other.getAttributeType().toString();
    comp=this_att.compareTo(other_att);
  }
  if (comp == 0) {
    int this_off, other_off;
    if (getOffset() == null)     this_off=0;
 else     this_off=getOffset();
    if (other.getOffset() == null)     other_off=0;
 else     other_off=other.getOffset();
    comp=this_off - other_off;
  }
  if (comp == 0) {
    if (getParamOffset() == null && other.getParamOffset() == null)     comp=0;
 else     if (getParamOffset() != null && other.getParamOffset() != null)     comp=getParamOffset().compareTo(other.getParamOffset());
 else     if (getParamOffset() == null)     comp=-1;
 else     comp=1;
  }
  if (comp == 0) {
    if (getKey() == null)     this_att=""String_Node_Str"";
 else     this_att=getKey().toString();
    if (other.getKey() == null)     other_att=""String_Node_Str"";
 else     other_att=other.getKey().toString();
    comp=this_att.compareTo(other_att);
  }
  if (comp == 0) {
    if (getParamKey() == null && other.getParamKey() == null)     comp=0;
 else     if (getParamKey() != null && other.getParamKey() != null)     comp=getParamKey().compareTo(other.getParamKey());
 else     if (getParamKey() == null)     comp=-1;
 else     comp=1;
  }
  return comp;
}",0.9587552482094344
5353,"/** 
 * Remove uma ao a ao composta.
 * @param action elemento representando a ao a ser removida
 * @return verdadeiro se a ao foi removida.
 * @see TreeSet#remove(java.lang.Object)
 */
public boolean removeAction(A action){
  if (actions.remove(action)) {
    if (action != null)     action.setParent(null);
    return true;
  }
  return false;
}","/** 
 * Remove uma ao a ao composta.
 * @param action elemento representando a ao a ser removida
 * @return verdadeiro se a ao foi removida.
 * @see ArrayList#remove(java.lang.Object)
 */
public boolean removeAction(A action){
  if (actions.remove(action)) {
    if (action != null)     action.setParent(null);
    return true;
  }
  return false;
}",0.9803370786516854
5354,"public int compareTo(A other){
  int comp=0;
  String this_act, other_act;
  NCLCompoundAction other_comp;
  if (!(other instanceof NCLCompoundAction))   return 1;
  other_comp=(NCLCompoundAction)other;
  if (comp == 0) {
    if (getOperator() == null)     this_act=""String_Node_Str"";
 else     this_act=getOperator().toString();
    if (other_comp.getOperator() == null)     other_act=""String_Node_Str"";
 else     other_act=other_comp.getOperator().toString();
    comp=this_act.compareTo(other_act);
  }
  if (comp == 0) {
    int this_del, other_del;
    if (getDelay() == null)     this_del=0;
 else     this_del=getDelay();
    if (other_comp.getDelay() == null)     other_del=0;
 else     other_del=other_comp.getDelay();
    comp=this_del - other_del;
  }
  if (comp == 0) {
    if (getParamDelay() == null && other_comp.getParamDelay() == null)     comp=0;
 else     if (getParamDelay() != null && other_comp.getParamDelay() != null)     comp=getParamDelay().compareTo(other_comp.getParamDelay());
 else     comp=1;
  }
  if (comp == 0)   comp=actions.size() - ((Set)other_comp.getActions()).size();
  if (comp == 0) {
    Iterator it=other_comp.getActions().iterator();
    for (    NCLAction a : actions) {
      NCLAction other_a=(NCLAction)it.next();
      comp=a.compareTo(other_a);
      if (comp != 0)       break;
    }
  }
  if (comp != 0)   return 1;
 else   return 0;
}","public int compareTo(A other){
  int comp=0;
  String this_act, other_act;
  NCLCompoundAction other_comp;
  if (!(other instanceof NCLCompoundAction))   return 1;
  other_comp=(NCLCompoundAction)other;
  if (comp == 0) {
    if (getOperator() == null)     this_act=""String_Node_Str"";
 else     this_act=getOperator().toString();
    if (other_comp.getOperator() == null)     other_act=""String_Node_Str"";
 else     other_act=other_comp.getOperator().toString();
    comp=this_act.compareTo(other_act);
  }
  if (comp == 0) {
    int this_del, other_del;
    if (getDelay() == null)     this_del=0;
 else     this_del=getDelay();
    if (other_comp.getDelay() == null)     other_del=0;
 else     other_del=other_comp.getDelay();
    comp=this_del - other_del;
  }
  if (comp == 0) {
    if (getParamDelay() == null && other_comp.getParamDelay() == null)     comp=0;
 else     if (getParamDelay() != null && other_comp.getParamDelay() != null)     comp=getParamDelay().compareTo(other_comp.getParamDelay());
 else     if (getParamDelay() == null)     comp=-1;
 else     comp=1;
  }
  if (comp == 0)   comp=actions.size() - ((List)other_comp.getActions()).size();
  if (comp == 0) {
    Iterator it=other_comp.getActions().iterator();
    for (    NCLAction a : actions) {
      NCLAction other_a=(NCLAction)it.next();
      comp=a.compareTo(other_a);
      if (comp != 0)       break;
    }
  }
  return comp;
}",0.9617447264926708
5355,"/** 
 * Adiciona uma ao a ao composta.
 * @param action elemento representando a ao a ser adicionada
 * @return verdadeiro se a ao foi adicionada.
 * @see TreeSet#add(java.lang.Object) 
 */
public boolean addAction(A action){
  if (actions.add(action)) {
    if (action != null)     action.setParent(this);
    return true;
  }
  return false;
}","/** 
 * Adiciona uma ao a ao composta.
 * @param action elemento representando a ao a ser adicionada
 * @return verdadeiro se a ao foi adicionada.
 * @see ArrayList#add(java.lang.Object)
 */
public boolean addAction(A action){
  if (action != null && actions.add(action)) {
    action.setParent(this);
    return true;
  }
  return false;
}",0.8930099857346647
5356,"/** 
 * Adiciona uma condio a condio composta.
 * @param condition elemento representando a condio a ser adicionada
 * @return verdadeiro se a condio foi adicionada.
 * @see TreeSet#add
 */
public boolean addCondition(C condition){
  if (conditions.add(condition)) {
    if (condition != null)     condition.setParent(this);
    return true;
  }
  return false;
}","/** 
 * Adiciona uma condio a condio composta.
 * @param condition elemento representando a condio a ser adicionada
 * @return verdadeiro se a condio foi adicionada.
 * @see ArrayList#add
 */
public boolean addCondition(C condition){
  if (condition != null && conditions.add(condition)) {
    condition.setParent(this);
    return true;
  }
  return false;
}",0.9159891598915988
5357,"public int compareTo(C other){
  int comp=0;
  String this_cond, other_cond;
  NCLCompoundCondition other_comp;
  if (!(other instanceof NCLCompoundCondition))   return 1;
  other_comp=(NCLCompoundCondition)other;
  if (comp == 0) {
    if (getOperator() == null)     this_cond=""String_Node_Str"";
 else     this_cond=getOperator().toString();
    if (other_comp.getOperator() == null)     other_cond=""String_Node_Str"";
 else     other_cond=other_comp.getOperator().toString();
    comp=this_cond.compareTo(other_cond);
  }
  if (comp == 0) {
    int this_del, other_del;
    if (getDelay() == null)     this_del=0;
 else     this_del=getDelay();
    if (other_comp.getDelay() == null)     other_del=0;
 else     other_del=other_comp.getDelay();
    comp=this_del - other_del;
  }
  if (comp == 0) {
    if (getParamDelay() == null && other_comp.getParamDelay() == null)     comp=0;
 else     if (getParamDelay() != null && other_comp.getParamDelay() != null)     comp=getParamDelay().compareTo(other_comp.getParamDelay());
 else     comp=1;
  }
  if (comp == 0)   comp=conditions.size() - ((Set)other_comp.getConditions()).size();
  if (comp == 0) {
    Iterator it=other_comp.getConditions().iterator();
    for (    NCLCondition c : conditions) {
      NCLCondition other_c=(NCLCondition)it.next();
      comp=c.compareTo(other_c);
      if (comp != 0)       break;
    }
  }
  if (comp == 0)   comp=statements.size() - ((Set)other_comp.getStatements()).size();
  if (comp == 0) {
    Iterator it=other_comp.getStatements().iterator();
    for (    NCLStatement st : statements) {
      NCLStatement other_st=(NCLStatement)it.next();
      comp=st.compareTo(other_st);
      if (comp != 0)       break;
    }
  }
  if (comp != 0)   return 1;
 else   return 0;
}","public int compareTo(C other){
  int comp=0;
  String this_cond, other_cond;
  NCLCompoundCondition other_comp;
  if (!(other instanceof NCLCompoundCondition))   return 1;
  other_comp=(NCLCompoundCondition)other;
  if (comp == 0) {
    if (getOperator() == null)     this_cond=""String_Node_Str"";
 else     this_cond=getOperator().toString();
    if (other_comp.getOperator() == null)     other_cond=""String_Node_Str"";
 else     other_cond=other_comp.getOperator().toString();
    comp=this_cond.compareTo(other_cond);
  }
  if (comp == 0) {
    int this_del, other_del;
    if (getDelay() == null)     this_del=0;
 else     this_del=getDelay();
    if (other_comp.getDelay() == null)     other_del=0;
 else     other_del=other_comp.getDelay();
    comp=this_del - other_del;
  }
  if (comp == 0) {
    if (getParamDelay() == null && other_comp.getParamDelay() == null)     comp=0;
 else     if (getParamDelay() != null && other_comp.getParamDelay() != null)     comp=getParamDelay().compareTo(other_comp.getParamDelay());
 else     if (getParamDelay() == null)     comp=-1;
 else     comp=1;
  }
  if (comp == 0)   comp=conditions.size() - ((List)other_comp.getConditions()).size();
  if (comp == 0) {
    Iterator it=other_comp.getConditions().iterator();
    for (    NCLCondition c : conditions) {
      NCLCondition other_c=(NCLCondition)it.next();
      comp=c.compareTo(other_c);
      if (comp != 0)       break;
    }
  }
  if (comp == 0)   comp=statements.size() - ((List)other_comp.getStatements()).size();
  if (comp == 0) {
    Iterator it=other_comp.getStatements().iterator();
    for (    NCLStatement st : statements) {
      NCLStatement other_st=(NCLStatement)it.next();
      comp=st.compareTo(other_st);
      if (comp != 0)       break;
    }
  }
  return comp;
}",0.9684329199549042
5358,"/** 
 * Adiciona uma assertiva a condio composta.
 * @param statement elemento representando a assertiva a ser adicionada.
 * @return verdadeiro se a assertiva foi adicionada.
 * @see TreeSet#add
 */
public boolean addStatement(S statement){
  if (statements.add(statement)) {
    if (statement != null)     statement.setParent(this);
    return true;
  }
  return false;
}","/** 
 * Adiciona uma assertiva a condio composta.
 * @param statement elemento representando a assertiva a ser adicionada.
 * @return verdadeiro se a assertiva foi adicionada.
 * @see ArrayList#add
 */
public boolean addStatement(S statement){
  if (statement != null && statements.add(statement)) {
    statement.setParent(this);
    return true;
  }
  return false;
}",0.9168900804289544
5359,"/** 
 * Remove uma condio a condio composta.
 * @param condition elemento representando a condio a ser removida
 * @return verdadeiro se a condio foi removida.
 * @see TreeSet#remove
 */
public boolean removeCondition(C condition){
  if (conditions.remove(condition)) {
    if (condition != null)     condition.setParent(null);
    return true;
  }
  return false;
}","/** 
 * Remove uma condio a condio composta.
 * @param condition elemento representando a condio a ser removida
 * @return verdadeiro se a condio foi removida.
 * @see ArrayList#remove
 */
public boolean removeCondition(C condition){
  if (conditions.remove(condition)) {
    if (condition != null)     condition.setParent(null);
    return true;
  }
  return false;
}",0.9813333333333332
5360,"/** 
 * Remove uma assertiva da condio composta.
 * @param statement elemento representando a assertiva a ser removida.
 * @return verdadeiro se a assertiva foi removida.
 * @see TreeSet#remove
 */
public boolean removeStatement(S statement){
  if (statements.remove(statement)) {
    if (statement != null)     statement.setParent(null);
    return true;
  }
  return false;
}","/** 
 * Remove uma assertiva da condio composta.
 * @param statement elemento representando a assertiva a ser removida.
 * @return verdadeiro se a assertiva foi removida.
 * @see ArrayList#remove
 */
public boolean removeStatement(S statement){
  if (statements.remove(statement)) {
    if (statement != null)     statement.setParent(null);
    return true;
  }
  return false;
}",0.9815789473684212
5361,"/** 
 * Retorna se a posio inferior da regio  uma porcentagem.
 * @return booleano indicando se a posio inferior da regio  uma porcentagem.
 */
private boolean isRelativeBottom(){
  return relativeBottom;
}","/** 
 * Retorna se a posio inferior da regio  uma porcentagem.
 * @return booleano indicando se a posio inferior da regio  uma porcentagem.
 */
public boolean isRelativeBottom(){
  return relativeBottom;
}",0.97423887587822
5362,"/** 
 * Determina se a posio de topo da regio  uma porcentagem.
 * @param relativeTop booleano indicando se a posio de topo da regio  uma porcentagem.
 */
private void setRelativeTop(boolean relativeTop){
  this.relativeTop=relativeTop;
}","/** 
 * Determina se a posio de topo da regio  uma porcentagem.
 * @param relativeTop booleano indicando se a posio de topo da regio  uma porcentagem.
 */
public void setRelativeTop(boolean relativeTop){
  this.relativeTop=relativeTop;
}",0.9775967413441956
5363,"/** 
 * Retorna se a altura da regio  uma porcentagem.
 * @return booleano indicando se a altura da regio  uma porcentagem.
 */
private boolean isRelativeHeight(){
  return relativeHeight;
}","/** 
 * Retorna se a altura da regio  uma porcentagem.
 * @return booleano indicando se a altura da regio  uma porcentagem.
 */
public boolean isRelativeHeight(){
  return relativeHeight;
}",0.9767441860465116
5364,"/** 
 * Determina se a posio a direita da regio  uma porcentagem.
 * @param relativeRight booleano indicando se a posio a direita da regio  uma porcentagem.
 */
private void setRelativeRight(boolean relativeRight){
  this.relativeRight=relativeRight;
}","/** 
 * Determina se a posio a direita da regio  uma porcentagem.
 * @param relativeRight booleano indicando se a posio a direita da regio  uma porcentagem.
 */
public void setRelativeRight(boolean relativeRight){
  this.relativeRight=relativeRight;
}",0.978805394990366
5365,"/** 
 * Determina se a posio inferior da regio  uma porcentagem.
 * @param relativeBottom booleano indicando se a posio inferior da regio  uma porcentagem.
 */
private void setRelativeBottom(boolean relativeBottom){
  this.relativeBottom=relativeBottom;
}","/** 
 * Determina se a posio inferior da regio  uma porcentagem.
 * @param relativeBottom booleano indicando se a posio inferior da regio  uma porcentagem.
 */
public void setRelativeBottom(boolean relativeBottom){
  this.relativeBottom=relativeBottom;
}",0.979047619047619
5366,"/** 
 * Retorna se a posio a esquerda da regio  uma porcentagem.
 * @return booleano indicando se a posio a esquerda da regio  uma porcentagem.
 */
private boolean isRelativeLeft(){
  return relativeLeft;
}","/** 
 * Retorna se a posio a esquerda da regio  uma porcentagem.
 * @return booleano indicando se a posio a esquerda da regio  uma porcentagem.
 */
public boolean isRelativeLeft(){
  return relativeLeft;
}",0.97423887587822
5367,"/** 
 * Determina se a largura da regio  uma porcentagem.
 * @param relativeWidth booleano indicando se a largura da regio  uma porcentagem.
 */
private void setRelativeWidth(boolean relativeWidth){
  this.relativeWidth=relativeWidth;
}","/** 
 * Determina se a largura da regio  uma porcentagem.
 * @param relativeWidth booleano indicando se a largura da regio  uma porcentagem.
 */
public void setRelativeWidth(boolean relativeWidth){
  this.relativeWidth=relativeWidth;
}",0.977035490605428
5368,"/** 
 * Retorna se a largura da regio  uma porcentagem.
 * @return booleano indicando se a largura da regio  uma porcentagem.
 */
private boolean isRelativeWidth(){
  return relativeWidth;
}","/** 
 * Retorna se a largura da regio  uma porcentagem.
 * @return booleano indicando se a largura da regio  uma porcentagem.
 */
public boolean isRelativeWidth(){
  return relativeWidth;
}",0.9767441860465116
5369,"/** 
 * Determina se a altura da regio  uma porcentagem.
 * @param relativeHeight booleano indicando se a altura da regio  uma porcentagem.
 */
private void setRelativeHeight(boolean relativeHeight){
  this.relativeHeight=relativeHeight;
}","/** 
 * Determina se a altura da regio  uma porcentagem.
 * @param relativeHeight booleano indicando se a altura da regio  uma porcentagem.
 */
public void setRelativeHeight(boolean relativeHeight){
  this.relativeHeight=relativeHeight;
}",0.977319587628866
5370,"/** 
 * Retorna se a posio a direita da regio  uma porcentagem.
 * @return booleano indicando se a posio a direita da regio  uma porcentagem.
 */
private boolean isRelativeRight(){
  return relativeRight;
}","/** 
 * Retorna se a posio a direita da regio  uma porcentagem.
 * @return booleano indicando se a posio a direita da regio  uma porcentagem.
 */
public boolean isRelativeRight(){
  return relativeRight;
}",0.97423887587822
5371,"/** 
 * Determina se a posio a esquerda da regio  uma porcentagem.
 * @param relativeLeft booleano indicando se a posio a esquerda da regio  uma porcentagem.
 */
private void setRelativeLeft(boolean relativeLeft){
  this.relativeLeft=relativeLeft;
}","/** 
 * Determina se a posio a esquerda da regio  uma porcentagem.
 * @param relativeLeft booleano indicando se a posio a esquerda da regio  uma porcentagem.
 */
public void setRelativeLeft(boolean relativeLeft){
  this.relativeLeft=relativeLeft;
}",0.9785575048732944
5372,"/** 
 * Retorna se a posio de topo da regio  uma porcentagem.
 * @return booleano indicando se a posio de topo da regio  uma porcentagem.
 */
private boolean isRelativeTop(){
  return relativeTop;
}","/** 
 * Retorna se a posio de topo da regio  uma porcentagem.
 * @return booleano indicando se a posio de topo da regio  uma porcentagem.
 */
public boolean isRelativeTop(){
  return relativeTop;
}",0.97323600973236
5373,"public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getOperator() != null)   content+=""String_Node_Str"" + getOperator().toString() + ""String_Node_Str"";
  if (getDelay() != null)   content+=""String_Node_Str"" + getDelay() + ""String_Node_Str"";
  if (getParamDelay() != null)   content+=""String_Node_Str"" + getParamDelay() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  if (hasCondition()) {
    for (    C condition : conditions)     content+=condition.parse(ident + 1);
  }
  if (hasStatement()) {
    for (    S statement : statements)     content+=statement.parse(ident + 1);
  }
  content+=space + ""String_Node_Str"";
  return content;
}","public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getOperator() != null)   content+=""String_Node_Str"" + getOperator().toString() + ""String_Node_Str"";
  if (getDelay() != null)   content+=""String_Node_Str"" + getDelay() + ""String_Node_Str"";
  if (getParamDelay() != null)   content+=""String_Node_Str"" + getParamDelay().getId() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  if (hasCondition()) {
    for (    C condition : conditions)     content+=condition.parse(ident + 1);
  }
  if (hasStatement()) {
    for (    S statement : statements)     content+=statement.parse(ident + 1);
  }
  content+=space + ""String_Node_Str"";
  return content;
}",0.9950617283950616
5374,"public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getRole() != null)   content+=""String_Node_Str"" + getRole().getName() + ""String_Node_Str"";
  if (getKey() != null)   content+=""String_Node_Str"" + getKey().toString() + ""String_Node_Str"";
  if (getParamKey() != null)   content+=""String_Node_Str"" + getParamKey().getId() + ""String_Node_Str"";
  if (getDelay() != null)   content+=""String_Node_Str"" + getDelay() + ""String_Node_Str"";
  if (getParamDelay() != null)   content+=""String_Node_Str"" + getParamDelay() + ""String_Node_Str"";
  if (getMin() != null)   content+=""String_Node_Str"" + getMin() + ""String_Node_Str"";
  if (getMax() != null) {
    if (getMax() < 0)     content+=""String_Node_Str"";
 else     content+=""String_Node_Str"" + getMax() + ""String_Node_Str"";
  }
  if (getQualifier() != null)   content+=""String_Node_Str"" + getQualifier().toString() + ""String_Node_Str"";
  if (getEventType() != null)   content+=""String_Node_Str"" + getEventType().toString() + ""String_Node_Str"";
  if (getTransition() != null)   content+=""String_Node_Str"" + getTransition().toString() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  return content;
}","public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getRole() != null)   content+=""String_Node_Str"" + getRole().getName() + ""String_Node_Str"";
  if (getKey() != null)   content+=""String_Node_Str"" + getKey().toString() + ""String_Node_Str"";
  if (getParamKey() != null)   content+=""String_Node_Str"" + getParamKey().getId() + ""String_Node_Str"";
  if (getDelay() != null)   content+=""String_Node_Str"" + getDelay() + ""String_Node_Str"";
  if (getParamDelay() != null)   content+=""String_Node_Str"" + getParamDelay().getId() + ""String_Node_Str"";
  if (getMin() != null)   content+=""String_Node_Str"" + getMin() + ""String_Node_Str"";
  if (getMax() != null) {
    if (getMax() < 0)     content+=""String_Node_Str"";
 else     content+=""String_Node_Str"" + getMax() + ""String_Node_Str"";
  }
  if (getQualifier() != null)   content+=""String_Node_Str"" + getQualifier().toString() + ""String_Node_Str"";
  if (getEventType() != null)   content+=""String_Node_Str"" + getEventType().toString() + ""String_Node_Str"";
  if (getTransition() != null)   content+=""String_Node_Str"" + getTransition().toString() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  return content;
}",0.9969465648854962
5375,"/** 
 * Cria o cdigo XML do elemento da <i>Nested Context Language</i> (NCL).<br>
 * @param ident Inteiro indicando o nvel de indentao do elemento, ou seja, o nmero de tabulaes usadas na indentao do elemento.
 * @return String contendo o cdigo XML do elemento.
 */
public String parse(int ident);","/** 
 * Cria o cdigo XML do elemento da <i>Nested Context Language</i> (NCL).<br>
 * @param ident Inteiro indicando o nvel de indentao do elemento, ou seja, o nmero de tabulaes usadas na indentao do elemento.
 * @return String contendo o cdigo XML do elemento.
 */
public abstract String parse(int ident);",0.9855072463768116
5376,"public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  content+=space + ""String_Node_Str"";
  content+=space + ""String_Node_Str"";
  if (getId() != null)   content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  if (getTitle() != null)   content+=""String_Node_Str"" + getTitle() + ""String_Node_Str"";
  content+=""String_Node_Str"" + getXmlns() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  if (getHead() != null)   content+=getHead().parse(ident + 1);
  if (getBody() != null)   content+=getBody().parse(ident + 1);
  content+=space + ""String_Node_Str"";
  return content;
}","public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  content+=space + ""String_Node_Str"";
  content+=space + ""String_Node_Str"";
  if (getId() != null)   content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  if (getTitle() != null)   content+=""String_Node_Str"" + getTitle() + ""String_Node_Str"";
  if (getXmlns() != null)   content+=""String_Node_Str"" + getXmlns() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  if (getHead() != null)   content+=getHead().parse(ident + 1);
  if (getBody() != null)   content+=getBody().parse(ident + 1);
  content+=space + ""String_Node_Str"";
  return content;
}",0.9438502673796793
5377,"public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  content+=""String_Node_Str"" + getComparator().toString() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  for (  A attribute : attributeAssessments)   content+=attribute.parse(ident + 1);
  if (valueAssessment != null)   content+=valueAssessment.parse(ident + 1);
  content+=space + ""String_Node_Str"";
  return content;
}","public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getComparator() != null)   content+=""String_Node_Str"" + getComparator().toString() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  if (hasAttributeAssessment()) {
    for (    A attribute : attributeAssessments)     content+=attribute.parse(ident + 1);
  }
  if (getValueAssessment() != null)   content+=getValueAssessment().parse(ident + 1);
  content+=space + ""String_Node_Str"";
  return content;
}",0.5835497835497836
5378,"public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  content+=""String_Node_Str"" + getRole().getName() + ""String_Node_Str"";
  if (getEventType() != null)   content+=""String_Node_Str"" + getEventType().toString() + ""String_Node_Str"";
  if (getKey() != null)   content+=""String_Node_Str"" + getKey().toString() + ""String_Node_Str"";
  if (getParamKey() != null)   content+=""String_Node_Str"" + getParamKey().getId() + ""String_Node_Str"";
  if (getAttributeType() != null)   content+=""String_Node_Str"" + getAttributeType().toString() + ""String_Node_Str"";
  if (getOffset() != null)   content+=""String_Node_Str"" + getOffset() + ""String_Node_Str"";
  if (getParamOffset() != null)   content+=""String_Node_Str"" + getParamOffset().getId() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  return content;
}","public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getRole() != null)   content+=""String_Node_Str"" + getRole().getName() + ""String_Node_Str"";
  if (getEventType() != null)   content+=""String_Node_Str"" + getEventType().toString() + ""String_Node_Str"";
  if (getKey() != null)   content+=""String_Node_Str"" + getKey().toString() + ""String_Node_Str"";
  if (getParamKey() != null)   content+=""String_Node_Str"" + getParamKey().getId() + ""String_Node_Str"";
  if (getAttributeType() != null)   content+=""String_Node_Str"" + getAttributeType().toString() + ""String_Node_Str"";
  if (getOffset() != null)   content+=""String_Node_Str"" + getOffset() + ""String_Node_Str"";
  if (getParamOffset() != null)   content+=""String_Node_Str"" + getParamOffset().getId() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  return content;
}",0.9870533402382186
5379,"/** 
 * Adiciona mensagens de erro relacionado ao elemento NCL em questo. Uma mensagem ser adicionada durante a recuperao do arquivo XML ou da validao feita pela api.
 * @param errors Lista contendo mensagens de erro.
 */
public void addError(Iterable<String> errors){
  this.errors.addAll((Collection<? extends String>)errors);
}","/** 
 * Adiciona mensagens de erro relacionado ao elemento NCL em questo. Uma mensagem ser adicionada durante a recuperao do arquivo XML ou da validao feita pela api.
 * @param errors Lista contendo mensagens de erro.
 */
public void addError(Iterable<String> errors){
  for (  String error : errors)   addError(error);
}",0.8536953242835595
5380,"/** 
 * Adiciona mensagens de aviso relacionado ao elemento NCL em questo. Uma mensagem ser adicionada durante a recuperao do arquivo XML ou da validao feita pela api.
 * @param warnings Lista contendo mensagens de aviso.
 */
public void addWarning(Iterable<String> warnings){
  this.warnings.addAll((Collection<? extends String>)warnings);
}","/** 
 * Adiciona mensagens de aviso relacionado ao elemento NCL em questo. Uma mensagem ser adicionada durante a recuperao do arquivo XML ou da validao feita pela api.
 * @param warnings Lista contendo mensagens de aviso.
 */
public void addWarning(Iterable<String> warnings){
  for (  String warning : warnings)   addWarning(warning);
}",0.8422575976845152
5381,"public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getComparator() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (!(attributeAssessments.size() == 2 || (attributeAssessments.size() == 1 && getValueAssessment() != null))) {
    addError(""String_Node_Str"");
    valid=false;
  }
  return valid;
}","public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getComparator() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (!(attributeAssessments.size() == 2 || (attributeAssessments.size() == 1 && getValueAssessment() != null))) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getValueAssessment() != null) {
    valid&=getValueAssessment().validate();
    addWarning(getValueAssessment().getWarnings());
    addError(getValueAssessment().getErrors());
  }
  if (hasAttributeAssessment()) {
    for (    NCLAttributeAssessment attribute : attributeAssessments) {
      valid&=attribute.validate();
      addWarning(attribute.getWarnings());
      addError(attribute.getErrors());
    }
  }
  return valid;
}",0.6061674008810573
5382,"public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getRole() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getRole() != null && getRole().getActionName() != null) {
    if (getRole().getActionName().equals(NCLDefaultActionRole.SET)) {
      if (getValue() == null && getParamValue() == null) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else {
      if (getValue() != null || getParamValue() != null) {
        addWarning(""String_Node_Str"");
        valid=false;
      }
    }
  }
 else {
    if (getEventType() == null || getActionType() == null) {
      addError(""String_Node_Str"");
      valid=false;
    }
 else     if (getEventType().equals(NCLEventType.ATTRIBUTION)) {
      if (getValue() == null && getParamValue() == null) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else {
      if (getValue() != null || getParamValue() != null) {
        addWarning(""String_Node_Str"");
        valid=false;
      }
      if (getDuration() != null || getParamDuration() != null || getBy() != null || getParamBy() != null) {
        addWarning(""String_Node_Str"");
        valid=false;
      }
    }
  }
  if ((getRepeatDelay() != null || getParamRepeatDelay() != null) && (getRepeat() == null && getParamRepeat() == null)) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
  if ((getDuration() == null && getParamDuration() == null) || (getBy() == null && getParamBy() == null)) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
  if (getMax() == 1 && getQualifier() != null) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
 else   if (getMax() != 1 && getQualifier() == null) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
  return valid;
}","public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getRole() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getRole() != null && getRole().getActionName() != null) {
    if (getRole().getActionName().equals(NCLDefaultActionRole.SET)) {
      if (getValue() == null && getParamValue() == null) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else {
      if (getValue() != null || getParamValue() != null) {
        addWarning(""String_Node_Str"");
        valid=false;
      }
    }
  }
 else {
    if (getEventType() == null || getActionType() == null) {
      addError(""String_Node_Str"");
      valid=false;
    }
 else     if (getEventType().equals(NCLEventType.ATTRIBUTION)) {
      if (getValue() == null && getParamValue() == null) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else {
      if (getValue() != null || getParamValue() != null) {
        addWarning(""String_Node_Str"");
        valid=false;
      }
      if (getDuration() != null || getParamDuration() != null || getBy() != null || getParamBy() != null) {
        addWarning(""String_Node_Str"");
        valid=false;
      }
    }
  }
  if ((getRepeatDelay() != null || getParamRepeatDelay() != null) && (getRepeat() == null && getParamRepeat() == null)) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
  if ((getDuration() != null || getParamDuration() != null) && (getBy() == null && getParamBy() == null)) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
  if (getMax() != null && getMax() == 1 && getQualifier() != null) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
 else   if (getMax() != null && getMax() != 1 && getQualifier() == null) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
  return valid;
}",0.977435332966428
5383,"public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getRole() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getRole() != null && getRole().getConditionName() != null) {
    if (getRole().getConditionName().equals(NCLDefaultConditionRole.ONSELECTION)) {
      if (getKey() == null && getParamKey() == null) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else {
      if (getKey() != null || getParamKey() != null) {
        addWarning(""String_Node_Str"");
        valid=false;
      }
    }
  }
 else {
    if (getEventType() == null || getTransition() == null) {
      addError(""String_Node_Str"");
      valid=false;
    }
 else     if (getEventType().equals(NCLEventType.SELECTION)) {
      if (getKey() == null && getParamKey() == null) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else {
      if (getKey() != null || getParamKey() != null) {
        addWarning(""String_Node_Str"");
        valid=false;
      }
    }
  }
  if (getMax() == 1 && getQualifier() != null) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
 else   if (getMax() != 1 && getQualifier() == null) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
  return valid;
}","public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getRole() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getRole() != null && getRole().getConditionName() != null) {
    if (getRole().getConditionName().equals(NCLDefaultConditionRole.ONSELECTION)) {
      if (getKey() == null && getParamKey() == null) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else {
      if (getKey() != null || getParamKey() != null) {
        addWarning(""String_Node_Str"");
        valid=false;
      }
    }
  }
 else {
    if (getEventType() == null || getTransition() == null) {
      addError(""String_Node_Str"");
      valid=false;
    }
 else     if (getEventType().equals(NCLEventType.SELECTION)) {
      if (getKey() == null && getParamKey() == null) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else {
      if (getKey() != null || getParamKey() != null) {
        addWarning(""String_Node_Str"");
        valid=false;
      }
    }
  }
  if (getMax() != null && getMax() == 1 && getQualifier() != null) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
 else   if (getMax() != null && getMax() != 1 && getQualifier() == null) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
  return valid;
}",0.8998459167950693
5384,"public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getId() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (!hasDescriptor() && !hasBind()) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (hasBind()) {
    for (    B bind : binds) {
      valid&=bind.validate();
      addWarning(bind.getWarnings());
      addError(bind.getErrors());
    }
  }
  if (hasDescriptor()) {
    for (    D desc : descriptors) {
      valid&=desc.validate();
      addWarning(desc.getWarnings());
      addError(desc.getErrors());
    }
  }
  if (getDefaultDescriptor() != null) {
    if (!(getDefaultDescriptor().getParent() instanceof NCLDescriptorSwitch)) {
      addError(""String_Node_Str"");
      valid=false;
    }
 else     if (((NCLDescriptorSwitch)getDefaultDescriptor().getParent()).compareTo(this) != 0) {
      addError(""String_Node_Str"");
      valid=false;
    }
  }
  return valid;
}","public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getId() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (!hasDescriptor() || !hasBind()) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (hasBind()) {
    for (    B bind : binds) {
      valid&=bind.validate();
      addWarning(bind.getWarnings());
      addError(bind.getErrors());
    }
  }
  if (hasDescriptor()) {
    for (    D desc : descriptors) {
      valid&=desc.validate();
      addWarning(desc.getWarnings());
      addError(desc.getErrors());
    }
  }
  if (getDefaultDescriptor() != null) {
    if (!(getDefaultDescriptor().getParent() instanceof NCLDescriptorSwitch)) {
      addError(""String_Node_Str"");
      valid=false;
    }
 else     if (((NCLDescriptorSwitch)getDefaultDescriptor().getParent()).compareTo(this) != 0) {
      addError(""String_Node_Str"");
      valid=false;
    }
  }
  return valid;
}",0.9978969505783386
5385,"public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getId() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getPosition() != null && getText() == null) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
  int i=0;
  if (getCoords() != null) {
    i++;
    if (!((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.IMAGE) && !((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.VIDEO)) {
      addWarning(""String_Node_Str"");
      valid=false;
    }
  }
  if (getBegin() != null || getEnd() != null) {
    i++;
    if (!((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.AUDIO) && !((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.VIDEO)) {
      addWarning(""String_Node_Str"");
      valid=false;
    }
  }
  if (getText() != null || getPosition() != null) {
    i++;
    if (!((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.TEXT)) {
      addWarning(""String_Node_Str"");
      valid=false;
    }
  }
  if (getFirst() != null || getLast() != null) {
    i++;
    if (!((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.AUDIO) && !((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.VIDEO)) {
      addWarning(""String_Node_Str"");
      valid=false;
    }
  }
  if (getLabel() != null) {
    i++;
    if (!((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.PROCEDURAL)) {
      addWarning(""String_Node_Str"");
      valid=false;
    }
  }
  if (i > 1) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
  return valid;
}","public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getId() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getPosition() != null && getText() == null) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
  int i=0;
  if (getCoords() != null) {
    i++;
    if (getParent() != null && !((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.IMAGE) && !((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.VIDEO)) {
      addWarning(""String_Node_Str"");
      valid=false;
    }
  }
  if (getBegin() != null || getEnd() != null) {
    i++;
    if (getParent() != null && !((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.AUDIO) && !((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.VIDEO)) {
      addWarning(""String_Node_Str"");
      valid=false;
    }
  }
  if (getText() != null || getPosition() != null) {
    i++;
    if (getParent() != null && !((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.TEXT)) {
      addWarning(""String_Node_Str"");
      valid=false;
    }
  }
  if (getFirst() != null || getLast() != null) {
    i++;
    if (getParent() != null && !((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.AUDIO) && !((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.VIDEO)) {
      addWarning(""String_Node_Str"");
      valid=false;
    }
  }
  if (getLabel() != null) {
    i++;
    if (getParent() != null && !((NCLMedia)getParent()).getMediaType().equals(NCLMediaType.PROCEDURAL)) {
      addWarning(""String_Node_Str"");
      valid=false;
    }
  }
  if (i > 1) {
    addWarning(""String_Node_Str"");
    valid=false;
  }
  return valid;
}",0.96436318562132
5386,"public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getComponent() == null) {
    addError(""String_Node_Str"");
  }
  if (getComponent() != null && getParent().getParent() != null) {
    if (getComponent().compareTo(getParent().getParent()) == 0) {
      addError(""String_Node_Str"");
      valid=false;
    }
    if (!((NCLSwitch)getParent().getParent()).hasNode(getComponent())) {
      addError(""String_Node_Str"");
      valid=false;
    }
  }
  if (getInterface() != null && getComponent() != null && getParent().getParent() != null) {
    if (getComponent() instanceof NCLMedia) {
      if (getInterface() instanceof NCLArea && !((NCLMedia)getComponent()).hasArea((NCLArea)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (getInterface() instanceof NCLProperty && !((NCLMedia)getComponent()).hasProperty((NCLProperty)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty) && !(getInterface() instanceof NCLArea)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     if (getComponent() instanceof NCLContext) {
      if (getInterface() instanceof NCLPort && !((NCLContext)getComponent()).hasPort((NCLPort)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (getInterface() instanceof NCLProperty && !((NCLContext)getComponent()).hasProperty((NCLProperty)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty) && !(getInterface() instanceof NCLPort)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     if (getComponent() instanceof NCLSwitch) {
      if (getInterface() instanceof NCLSwitchPort && !((NCLSwitch)getComponent()).hasPort((NCLSwitchPort)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     valid=false;
  }
  return valid;
}","public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getComponent() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getComponent() != null && getParent() != null && getParent().getParent() != null) {
    if (getComponent().compareTo(getParent().getParent()) == 0) {
      addError(""String_Node_Str"");
      valid=false;
    }
    if (!((NCLSwitch)getParent().getParent()).hasNode(getComponent())) {
      addError(""String_Node_Str"");
      valid=false;
    }
  }
  if (getInterface() != null && getComponent() != null && getParent() != null && getParent().getParent() != null) {
    if (getComponent() instanceof NCLMedia) {
      if (getInterface() instanceof NCLArea && !((NCLMedia)getComponent()).hasArea((NCLArea)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (getInterface() instanceof NCLProperty && !((NCLMedia)getComponent()).hasProperty((NCLProperty)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty) && !(getInterface() instanceof NCLArea)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     if (getComponent() instanceof NCLContext) {
      if (getInterface() instanceof NCLPort && !((NCLContext)getComponent()).hasPort((NCLPort)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (getInterface() instanceof NCLProperty && !((NCLContext)getComponent()).hasProperty((NCLProperty)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty) && !(getInterface() instanceof NCLPort)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     if (getComponent() instanceof NCLSwitch) {
      if (getInterface() instanceof NCLSwitchPort && !((NCLSwitch)getComponent()).hasPort((NCLSwitchPort)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     valid=false;
  }
  return valid;
}",0.9858076143275512
5387,"public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getId() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getComponent() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getComponent() != null) {
    if (getComponent().compareTo(getParent()) == 0) {
      addError(""String_Node_Str"");
      valid=false;
    }
    if (getParent() instanceof NCLContext && !((NCLContext)getParent()).hasNode(getComponent())) {
      addError(""String_Node_Str"");
      valid=false;
    }
 else     if (getParent() instanceof NCLBody && !((NCLBody)getParent()).hasNode(getComponent())) {
      addError(""String_Node_Str"");
      valid=false;
    }
 else     if (!(getParent() instanceof NCLContext) || !(getParent() instanceof NCLBody)) {
      addError(""String_Node_Str"");
      valid=false;
    }
  }
  if (getInterface() != null && getComponent() != null) {
    if (getComponent() instanceof NCLMedia) {
      if (getInterface() instanceof NCLArea && !((NCLMedia)getComponent()).hasArea((NCLArea)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (getInterface() instanceof NCLProperty && !((NCLMedia)getComponent()).hasProperty((NCLProperty)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty) && !(getInterface() instanceof NCLArea)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     if (getComponent() instanceof NCLContext) {
      if (getInterface() instanceof NCLPort && !((NCLContext)getComponent()).hasPort((NCLPort)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (getInterface() instanceof NCLProperty && !((NCLContext)getComponent()).hasProperty((NCLProperty)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty) && !(getInterface() instanceof NCLPort)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     if (getComponent() instanceof NCLSwitch) {
      if (getInterface() instanceof NCLSwitchPort && !((NCLSwitch)getComponent()).hasPort((NCLSwitchPort)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     valid=false;
  }
  return valid;
}","public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getId() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getComponent() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getComponent() != null && getParent() != null) {
    if (getParent() instanceof NCLNode && getComponent() instanceof NCLNode && getComponent().compareTo(getParent()) == 0) {
      addError(""String_Node_Str"");
      valid=false;
    }
    if (getParent() instanceof NCLContext && !((NCLContext)getParent()).hasNode(getComponent())) {
      addError(""String_Node_Str"");
      valid=false;
    }
 else     if (getParent() instanceof NCLBody && !((NCLBody)getParent()).hasNode(getComponent())) {
      addError(""String_Node_Str"");
      valid=false;
    }
  }
  if (getInterface() != null && getComponent() != null) {
    if (getComponent() instanceof NCLMedia) {
      if (getInterface() instanceof NCLArea && !((NCLMedia)getComponent()).hasArea((NCLArea)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (getInterface() instanceof NCLProperty && !((NCLMedia)getComponent()).hasProperty((NCLProperty)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty) && !(getInterface() instanceof NCLArea)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     if (getComponent() instanceof NCLContext) {
      if (getInterface() instanceof NCLPort && !((NCLContext)getComponent()).hasPort((NCLPort)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (getInterface() instanceof NCLProperty && !((NCLContext)getComponent()).hasProperty((NCLProperty)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty) && !(getInterface() instanceof NCLPort)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     if (getComponent() instanceof NCLSwitch) {
      if (getInterface() instanceof NCLSwitchPort && !((NCLSwitch)getComponent()).hasPort((NCLSwitchPort)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     valid=false;
  }
  return valid;
}",0.9511854951185496
5388,"public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getName() != null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  return valid;
}","public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getName() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  return valid;
}",0.994535519125683
5389,"public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getRole() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getComponent() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (!roleReference()) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getComponent() != null && getParent().getParent() != null) {
    if (getComponent().compareTo(getParent().getParent()) == 0) {
      addError(""String_Node_Str"");
      valid=false;
    }
    if (getParent().getParent() instanceof NCLContext && !((NCLContext)getParent().getParent()).hasNode(getComponent())) {
      addError(""String_Node_Str"");
      valid=false;
    }
 else     if (getParent().getParent() instanceof NCLBody && !((NCLBody)getParent().getParent()).hasNode(getComponent())) {
      addError(""String_Node_Str"");
      valid=false;
    }
 else     if (!(getParent().getParent() instanceof NCLContext) || !(getParent().getParent() instanceof NCLBody)) {
      addError(""String_Node_Str"");
      valid=false;
    }
  }
  if (getInterface() != null && getComponent() != null) {
    if (getComponent() instanceof NCLMedia) {
      if (getInterface() instanceof NCLArea && !((NCLMedia)getComponent()).hasArea((NCLArea)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (getInterface() instanceof NCLProperty && !((NCLMedia)getComponent()).hasProperty((NCLProperty)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty) && !(getInterface() instanceof NCLArea)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     if (getComponent() instanceof NCLContext) {
      if (getInterface() instanceof NCLPort && !((NCLContext)getComponent()).hasPort((NCLPort)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (getInterface() instanceof NCLProperty && !((NCLContext)getComponent()).hasProperty((NCLProperty)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty) && !(getInterface() instanceof NCLPort)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     if (getComponent() instanceof NCLSwitch) {
      if (getInterface() instanceof NCLSwitchPort && !((NCLSwitch)getComponent()).hasPort((NCLSwitchPort)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     valid=false;
  }
  if (hasBindParam()) {
    for (    P param : bindParams) {
      if (!param.getType().equals(NCLParamInstance.BINDPARAM)) {
        addError(""String_Node_Str"");
        valid=false;
      }
      valid&=param.validate();
      addWarning(param.getWarnings());
      addError(param.getErrors());
    }
  }
  return valid;
}","public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getRole() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getComponent() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getComponent() != null && getParent() != null && getParent().getParent() != null) {
    if (getParent().getParent() instanceof NCLNode && getComponent() instanceof NCLNode && getComponent().compareTo(getParent().getParent()) == 0) {
      addError(""String_Node_Str"");
      valid=false;
    }
    if (getParent().getParent() instanceof NCLContext && !((NCLContext)getParent().getParent()).hasNode(getComponent())) {
      addError(""String_Node_Str"");
      valid=false;
    }
 else     if (getParent().getParent() instanceof NCLBody && !((NCLBody)getParent().getParent()).hasNode(getComponent())) {
      addError(""String_Node_Str"");
      valid=false;
    }
  }
  if (getInterface() != null && getComponent() != null) {
    if (getComponent() instanceof NCLMedia) {
      if (getInterface() instanceof NCLArea && !((NCLMedia)getComponent()).hasArea((NCLArea)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (getInterface() instanceof NCLProperty && !((NCLMedia)getComponent()).hasProperty((NCLProperty)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty) && !(getInterface() instanceof NCLArea)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     if (getComponent() instanceof NCLContext) {
      if (getInterface() instanceof NCLPort && !((NCLContext)getComponent()).hasPort((NCLPort)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (getInterface() instanceof NCLProperty && !((NCLContext)getComponent()).hasProperty((NCLProperty)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty) && !(getInterface() instanceof NCLPort)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     if (getComponent() instanceof NCLSwitch) {
      if (getInterface() instanceof NCLSwitchPort && !((NCLSwitch)getComponent()).hasPort((NCLSwitchPort)getInterface())) {
        addError(""String_Node_Str"");
        valid=false;
      }
 else       if (!(getInterface() instanceof NCLProperty)) {
        addError(""String_Node_Str"");
        valid=false;
      }
    }
 else     valid=false;
  }
  if (hasBindParam()) {
    for (    P param : bindParams) {
      if (!param.getType().equals(NCLParamInstance.BINDPARAM)) {
        addError(""String_Node_Str"");
        valid=false;
      }
      valid&=param.validate();
      addWarning(param.getWarnings());
      addError(param.getErrors());
    }
  }
  return valid;
}",0.9352179034157831
5390,"public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getId() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getRefer() != null && getRefer().compareTo(this) == 0) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (hasMeta()) {
    for (    M meta : metas) {
      valid&=meta.validate();
      addWarning(meta.getWarnings());
      addError(meta.getErrors());
    }
  }
  if (hasMetadata()) {
    for (    MT metadata : metadatas) {
      valid&=metadata.validate();
      addWarning(metadata.getWarnings());
      addError(metadata.getErrors());
    }
  }
  if (hasPort()) {
    for (    Pt port : ports) {
      valid&=port.validate();
      addWarning(port.getWarnings());
      addError(port.getErrors());
    }
  }
  if (hasProperty()) {
    for (    Pp property : properties) {
      valid&=property.validate();
      addWarning(property.getWarnings());
      addError(property.getErrors());
    }
  }
  if (hasNode()) {
    for (    N node : nodes) {
      valid&=node.validate();
      addWarning(node.getWarnings());
      addError(node.getErrors());
    }
  }
  if (hasLink()) {
    for (    L link : links) {
      valid&=link.validate();
      addWarning(link.getWarnings());
      addError(link.getErrors());
    }
  }
  return valid;
}","public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getId() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getRefer() != null && (getRefer().compareTo(this) == 0 || findContext(nodes) != null)) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (hasMeta()) {
    for (    M meta : metas) {
      valid&=meta.validate();
      addWarning(meta.getWarnings());
      addError(meta.getErrors());
    }
  }
  if (hasMetadata()) {
    for (    MT metadata : metadatas) {
      valid&=metadata.validate();
      addWarning(metadata.getWarnings());
      addError(metadata.getErrors());
    }
  }
  if (hasPort()) {
    for (    Pt port : ports) {
      valid&=port.validate();
      addWarning(port.getWarnings());
      addError(port.getErrors());
    }
  }
  if (hasProperty()) {
    for (    Pp property : properties) {
      valid&=property.validate();
      addWarning(property.getWarnings());
      addError(property.getErrors());
    }
  }
  if (hasNode()) {
    for (    N node : nodes) {
      valid&=node.validate();
      addWarning(node.getWarnings());
      addError(node.getErrors());
    }
  }
  if (hasLink()) {
    for (    L link : links) {
      valid&=link.validate();
      addWarning(link.getWarnings());
      addError(link.getErrors());
    }
  }
  return valid;
}",0.9880418535127056
5391,"public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getId() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getRefer() != null && getRefer().compareTo(this) == 0) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (!hasNode() && !hasBind()) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (hasPort()) {
    for (    P port : ports) {
      valid&=port.validate();
      addWarning(port.getWarnings());
      addError(port.getErrors());
    }
  }
  if (hasBind()) {
    for (    B bind : binds) {
      valid&=bind.validate();
      addWarning(bind.getWarnings());
      addError(bind.getErrors());
    }
  }
  if (hasNode()) {
    for (    N node : nodes) {
      valid&=node.validate();
      addWarning(node.getWarnings());
      addError(node.getErrors());
    }
  }
  if (getDefaultComponent() != null) {
    if (!(getDefaultComponent().getParent() instanceof NCLSwitch)) {
      addError(""String_Node_Str"");
      valid=false;
    }
 else     if (((NCLSwitch)getDefaultComponent().getParent()).compareTo(this) != 0) {
      addError(""String_Node_Str"");
      valid=false;
    }
  }
  return valid;
}","public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getId() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getRefer() != null && (getRefer().compareTo(this) == 0 || findSwitch(nodes) != null)) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (!hasNode() || !hasBind()) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (hasPort()) {
    for (    P port : ports) {
      valid&=port.validate();
      addWarning(port.getWarnings());
      addError(port.getErrors());
    }
  }
  if (hasBind()) {
    for (    B bind : binds) {
      valid&=bind.validate();
      addWarning(bind.getWarnings());
      addError(bind.getErrors());
    }
  }
  if (hasNode()) {
    for (    N node : nodes) {
      valid&=node.validate();
      addWarning(node.getWarnings());
      addError(node.getErrors());
    }
  }
  if (getDefaultComponent() != null) {
    if (!(getDefaultComponent().getParent() instanceof NCLSwitch)) {
      addError(""String_Node_Str"");
      valid=false;
    }
 else     if (((NCLSwitch)getDefaultComponent().getParent()).compareTo(this) != 0) {
      addError(""String_Node_Str"");
      valid=false;
    }
  }
  return valid;
}",0.9854711498547116
5392,"@Override public void endDocument(){
  if (getParent() != null) {
    if (getDefaultComponent() != null)     defaultComponentReference();
    if (getRefer() != null)     switchReference();
  }
  if (hasBind()) {
    for (    B bind : binds) {
      bind.endDocument();
      addWarning(bind.getWarnings());
      addError(bind.getErrors());
    }
  }
  if (hasPort()) {
    for (    P port : ports) {
      port.endDocument();
      addWarning(port.getWarnings());
      addError(port.getErrors());
    }
  }
  if (hasNode()) {
    for (    N node : nodes) {
      node.endDocument();
      addWarning(node.getWarnings());
      addError(node.getErrors());
    }
  }
}","@Override public void endDocument(){
  if (getDefaultComponent() != null)   defaultComponentReference();
  if (getParent() != null && getRefer() != null)   switchReference();
  if (hasBind()) {
    for (    B bind : binds) {
      bind.endDocument();
      addWarning(bind.getWarnings());
      addError(bind.getErrors());
    }
  }
  if (hasPort()) {
    for (    P port : ports) {
      port.endDocument();
      addWarning(port.getWarnings());
      addError(port.getErrors());
    }
  }
  if (hasNode()) {
    for (    N node : nodes) {
      node.endDocument();
      addWarning(node.getWarnings());
      addError(node.getErrors());
    }
  }
}",0.6009104704097117
5393,"public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getAlias() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getDocumentURI() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  return valid;
}","public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getAlias() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getDocumentURI() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getParent() != null) {
switch (type) {
case BASE:
      if (getParent() instanceof NCLImportedDocumentBase) {
        addError(""String_Node_Str"");
        valid=false;
      }
    break;
case NCL:
  if (!(getParent() instanceof NCLImportedDocumentBase)) {
    addError(""String_Node_Str"");
    valid=false;
  }
break;
}
}
return valid;
}",0.5914844649021864
5394,"public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getId() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getVar() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getComparator() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getValue() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getVar().getParent() != null && getVar().getParent() instanceof NCLMedia) {
    if (((NCLMedia)getVar().getParent()).getType() != NCLMimeType.APPLICATION_X_GINGA_SETTINGS) {
      addWarning(""String_Node_Str"");
      valid=false;
    }
  }
 else {
    addWarning(""String_Node_Str"");
    valid=false;
  }
  return valid;
}","public boolean validate(){
  cleanWarnings();
  cleanErrors();
  boolean valid=true;
  if (getId() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getVar() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getComparator() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getValue() == null) {
    addError(""String_Node_Str"");
    valid=false;
  }
  if (getVar() != null) {
    if (getVar().getParent() != null && getVar().getParent() instanceof NCLMedia) {
      if (((NCLMedia)getVar().getParent()).getType() != NCLMimeType.APPLICATION_X_GINGA_SETTINGS) {
        addWarning(""String_Node_Str"");
        valid=false;
      }
    }
 else {
      addWarning(""String_Node_Str"");
      valid=false;
    }
  }
  return valid;
}",0.8835078534031413
5395,"public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getId() != null)   content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  if (hasImportBase()) {
    for (    I imp : imports)     content+=imp.parse(ident + 1);
  }
  if (hasDescriptor()) {
    for (    D descriptor : descriptors)     content+=descriptor.parse(ident + 1);
  }
  content+=space + ""String_Node_Str"";
  return content;
}","public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getId() != null)   content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  if (hasDescriptor() || hasImportBase()) {
    content+=""String_Node_Str"";
    if (hasImportBase()) {
      for (      I imp : imports)       content+=imp.parse(ident + 1);
    }
    if (hasDescriptor()) {
      for (      D descriptor : descriptors)       content+=descriptor.parse(ident + 1);
    }
    content+=space + ""String_Node_Str"";
  }
 else   content+=""String_Node_Str"";
  return content;
}",0.810641627543036
5396,"public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  if (hasBind()) {
    for (    B bind : binds)     content+=bind.parse(ident + 1);
  }
  if (getDefaultDescriptor() != null)   content+=""String_Node_Str"" + getDefaultDescriptor().getId() + ""String_Node_Str"";
  if (hasDescriptor()) {
    for (    D descriptor : descriptors)     content+=descriptor.parse(ident + 1);
  }
  content+=space + ""String_Node_Str"";
  return content;
}","public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  if (hasBind()) {
    for (    B bind : binds)     content+=bind.parse(ident + 1);
  }
  if (getDefaultDescriptor() != null)   content+=space + ""String_Node_Str"" + ""String_Node_Str""+ getDefaultDescriptor().getId()+ ""String_Node_Str"";
  if (hasDescriptor()) {
    for (    D descriptor : descriptors)     content+=descriptor.parse(ident + 1);
  }
  content+=space + ""String_Node_Str"";
  return content;
}",0.9536231884057972
5397,"/** 
 * Adiciona uma regio filha  regio. A regio filha  considerada uma regio interna tendo seus parmetros relativos a esta regio.
 * @param child elemento representando a regio a ser adicionada.
 * @return verdadeiro se a regio foi adicionada.
 * @see TreeSet#add
 */
public boolean addRegion(R child) throws Exception {
  return regions.add(child);
}","/** 
 * Adiciona uma regio filha  regio. A regio filha  considerada uma regio interna tendo seus parmetros relativos a esta regio.
 * @param child elemento representando a regio a ser adicionada.
 * @return verdadeiro se a regio foi adicionada.
 * @see TreeSet#add
 */
public boolean addRegion(R child){
  return regions.add(child);
}",0.9745042492917848
5398,"public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getId() != null)   content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  if (getDevice() != null)   content+=""String_Node_Str"" + getDevice() + ""String_Node_Str"";
  if (getParentRegion() != null)   content+=""String_Node_Str"" + getParentRegion().getId() + ""String_Node_Str"";
  if (hasRegion()) {
    content+=""String_Node_Str"";
    if (hasImportBase()) {
      for (      I imp : imports)       content+=imp.parse(ident + 1);
    }
    for (    R region : regions)     content+=region.parse(ident + 1);
    content+=space + ""String_Node_Str"";
  }
 else   content+=""String_Node_Str"";
  return content;
}","public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getId() != null)   content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  if (getDevice() != null)   content+=""String_Node_Str"" + getDevice() + ""String_Node_Str"";
  if (getParentRegion() != null)   content+=""String_Node_Str"" + getParentRegion().getId() + ""String_Node_Str"";
  if (hasRegion() || hasImportBase()) {
    content+=""String_Node_Str"";
    if (hasImportBase()) {
      for (      I imp : imports)       content+=imp.parse(ident + 1);
    }
    for (    R region : regions)     content+=region.parse(ident + 1);
    content+=space + ""String_Node_Str"";
  }
 else   content+=""String_Node_Str"";
  return content;
}",0.9187236604455148
5399,"public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getId() != null)   content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  if (hasImportNCL()) {
    for (    I imp : imports)     content+=imp.parse(ident + 1);
  }
  content+=space + ""String_Node_Str"";
  return content;
}","public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getId() != null)   content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  if (hasImportNCL()) {
    content+=""String_Node_Str"";
    for (    I imp : imports)     content+=imp.parse(ident + 1);
    content+=space + ""String_Node_Str"";
  }
 else   content+=""String_Node_Str"";
  return content;
}",0.8617886178861789
5400,"public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  content+=""String_Node_Str"" + getVar() + ""String_Node_Str"";
  content+=""String_Node_Str"" + getComparator() + ""String_Node_Str"";
  content+=""String_Node_Str"" + getValue() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  return content;
}","public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  content+=""String_Node_Str"" + getVar().getName() + ""String_Node_Str"";
  content+=""String_Node_Str"" + getComparator().toString() + ""String_Node_Str"";
  content+=""String_Node_Str"" + getValue() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  return content;
}",0.9798270893371758
5401,"public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getId() != null)   content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  if (hasImportBase()) {
    for (    I imp : imports)     content+=imp.parse(ident + 1);
  }
  if (hasRule()) {
    for (    T rule : rules)     content+=rule.parse(ident + 1);
  }
  content+=space + ""String_Node_Str"";
  return content;
}","public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getId() != null)   content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  if (hasImportBase() || hasRule()) {
    content+=""String_Node_Str"";
    if (hasImportBase()) {
      for (      I imp : imports)       content+=imp.parse(ident + 1);
    }
    if (hasRule()) {
      for (      T rule : rules)       content+=rule.parse(ident + 1);
    }
    content+=space + ""String_Node_Str"";
  }
 else   content+=""String_Node_Str"";
  return content;
}",0.7532679738562091
5402,"/** 
 * Atribui um delay de progresso final a transio.
 * @param startProgress inteiro representando o delay final.
 */
public void setEndProgress(Integer endProgress){
  this.endProgress=endProgress;
}","/** 
 * Atribui um delay de progresso final a transio.
 * @param startProgress fracionrio representando o delay final.
 */
public void setEndProgress(Double endProgress){
  this.endProgress=endProgress;
}",0.929440389294404
5403,"public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  content+=""String_Node_Str"" + getType() + ""String_Node_Str"";
  if (getSubtype() != null)   content+=""String_Node_Str"" + getSubtype() + ""String_Node_Str"";
  if (getDur() != null)   content+=""String_Node_Str"" + getDur() + ""String_Node_Str"";
  if (getStartProgress() != null)   content+=""String_Node_Str"" + getStartProgress() + ""String_Node_Str"";
  if (getEndProgress() != null)   content+=""String_Node_Str"" + getEndProgress() + ""String_Node_Str"";
  if (getDirection() != null)   content+=""String_Node_Str"" + getDirection() + ""String_Node_Str"";
  if (getFadeColor() != null)   content+=""String_Node_Str"" + getFadeColor() + ""String_Node_Str"";
  if (getHorRepeat() != null)   content+=""String_Node_Str"" + getHorRepeat() + ""String_Node_Str"";
  if (getVertRepeat() != null)   content+=""String_Node_Str"" + getVertRepeat() + ""String_Node_Str"";
  if (getBorderWidth() != null)   content+=""String_Node_Str"" + getBorderWidth() + ""String_Node_Str"";
  if (getBorderColor() != null)   content+=""String_Node_Str"" + getBorderColor() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  return content;
}","public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  content+=""String_Node_Str"" + getType() + ""String_Node_Str"";
  if (getSubtype() != null)   content+=""String_Node_Str"" + getSubtype() + ""String_Node_Str"";
  if (getDur() != null)   content+=""String_Node_Str"" + getDur() + ""String_Node_Str"";
  if (getStartProgress() != null)   content+=""String_Node_Str"" + getStartProgress() + ""String_Node_Str"";
  if (getEndProgress() != null)   content+=""String_Node_Str"" + getEndProgress() + ""String_Node_Str"";
  if (getDirection() != null)   content+=""String_Node_Str"" + getDirection().toString() + ""String_Node_Str"";
  if (getFadeColor() != null)   content+=""String_Node_Str"" + getFadeColor().toString() + ""String_Node_Str"";
  if (getHorRepeat() != null)   content+=""String_Node_Str"" + getHorRepeat() + ""String_Node_Str"";
  if (getVertRepeat() != null)   content+=""String_Node_Str"" + getVertRepeat() + ""String_Node_Str"";
  if (getBorderWidth() != null)   content+=""String_Node_Str"" + getBorderWidth() + ""String_Node_Str"";
  if (getBorderColor() != null)   content+=""String_Node_Str"" + getBorderColor().toString() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  return content;
}",0.9879781420765028
5404,"/** 
 * Retorna o delay de progresso inicial da transio.
 * @return inteiro representando o delay inicial.
 */
public Integer getStartProgress(){
  return startProgress;
}","/** 
 * Retorna o delay de progresso inicial da transio.
 * @return fracionrio representando o delay inicial.
 */
public Double getStartProgress(){
  return startProgress;
}",0.9398280802292264
5405,"/** 
 * Atribui um delay de progresso inicial a transio.
 * @param startProgress inteiro representando o delay inicial.
 */
public void setStartProgress(Integer startProgress){
  this.startProgress=startProgress;
}","/** 
 * Atribui um delay de progresso inicial a transio.
 * @param startProgress fracionrio representando o delay inicial.
 */
public void setStartProgress(Double startProgress){
  this.startProgress=startProgress;
}",0.9333333333333332
5406,"/** 
 * Retorna o delay de progresso final da transio.
 * @return inteiro representando o delay final.
 */
public Integer getEndProgress(){
  return endProgress;
}","/** 
 * Retorna o delay de progresso final da transio.
 * @return fracionrio representando o delay final.
 */
public Double getEndProgress(){
  return endProgress;
}",0.9369369369369368
5407,"public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getId() != null)   content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  content+=""String_Node_Str"";
  if (hasImportBase()) {
    for (    I imp : imports)     content+=imp.parse(ident + 1);
  }
  if (hasTransition()) {
    for (    T transition : transitions)     content+=transition.parse(ident + 1);
  }
  content+=space + ""String_Node_Str"";
  return content;
}","public String parse(int ident){
  String space, content;
  if (ident < 0)   ident=0;
  space=""String_Node_Str"";
  for (int i=0; i < ident; i++)   space+=""String_Node_Str"";
  content=space + ""String_Node_Str"";
  if (getId() != null)   content+=""String_Node_Str"" + getId() + ""String_Node_Str"";
  if (hasImportBase() || hasTransition()) {
    content+=""String_Node_Str"";
    if (hasImportBase()) {
      for (      I imp : imports)       content+=imp.parse(ident + 1);
    }
    if (hasTransition()) {
      for (      T transition : transitions)       content+=transition.parse(ident + 1);
    }
    content+=space + ""String_Node_Str"";
  }
 else   content+=""String_Node_Str"";
  return content;
}",0.8169014084507042
5408,"@Override public void startElement(String uri,String localName,String qName,Attributes attributes){
  try {
    if (localName.equals(""String_Node_Str"")) {
      for (int i=0; i < attributes.getLength(); i++) {
        if (attributes.getLocalName(i).equals(""String_Node_Str""))         setId(attributes.getValue(i));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setTitle(attributes.getValue(i));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str"")) {
          for (          NCLNamespace ns : NCLNamespace.values()) {
            if (ns.toString().equals(attributes.getValue(i)))             setXmlns(ns);
          }
        }
      }
    }
 else     if (localName.equals(""String_Node_Str"")) {
      setHead((H)new NCLHead(getReader(),this));
      getHead().startElement(uri,localName,qName,attributes);
    }
 else     if (localName.equals(""String_Node_Str"")) {
      setBody((B)new NCLBody(getReader(),this));
      getBody().startElement(uri,localName,qName,attributes);
    }
  }
 catch (  NCLInvalidIdentifierException ex) {
  }
}","@Override public void startElement(String uri,String localName,String qName,Attributes attributes){
  try {
    if (localName.equals(""String_Node_Str"")) {
      for (int i=0; i < attributes.getLength(); i++) {
        if (attributes.getLocalName(i).equals(""String_Node_Str""))         setId(attributes.getValue(i));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setTitle(attributes.getValue(i));
      }
      if (!uri.equals(""String_Node_Str"")) {
        for (        NCLNamespace ns : NCLNamespace.values()) {
          if (ns.toString().equals(uri))           setXmlns(ns);
        }
      }
    }
 else     if (localName.equals(""String_Node_Str"")) {
      setHead((H)new NCLHead(getReader(),this));
      getHead().startElement(uri,localName,qName,attributes);
    }
 else     if (localName.equals(""String_Node_Str"")) {
      setBody((B)new NCLBody(getReader(),this));
      getBody().startElement(uri,localName,qName,attributes);
    }
  }
 catch (  NCLInvalidIdentifierException ex) {
  }
}",0.9561113732892874
5409,"@Override public void startElement(String uri,String localName,String qName,Attributes attributes){
  try {
    if (localName.equals(""String_Node_Str"")) {
      for (int i=0; i < attributes.getLength(); i++) {
        if (attributes.getLocalName(i).equals(""String_Node_Str""))         setId(attributes.getValue(i));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setRegion((R)new NCLRegion(attributes.getValue(i)));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str"")) {
          String value=attributes.getValue(i);
          if (value.contains(""String_Node_Str""))           value=value.substring(0,value.length() - 1);
          setExplicitDur(new Integer(value));
        }
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setFreeze(new Boolean(attributes.getValue(i)));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setPlayer(attributes.getValue(i));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setMoveLeft((D)new NCLDescriptor(attributes.getValue(i)));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setMoveRight((D)new NCLDescriptor(attributes.getValue(i)));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setMoveDown((D)new NCLDescriptor(attributes.getValue(i)));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setMoveUp((D)new NCLDescriptor(attributes.getValue(i)));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setFocusIndex(new Integer(attributes.getValue(i)));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str"")) {
          for (          NCLColor c : NCLColor.values()) {
            if (c.toString().equals(attributes.getValue(i)))             setFocusBorderColor(c);
          }
        }
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setFocusBorderWidth(new Integer(attributes.getValue(i)));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setFocusBorderTransparency(new Integer(attributes.getValue(i)));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setFocusSrc(attributes.getValue(i));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setFocusSelSrc(attributes.getValue(i));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str"")) {
          for (          NCLColor c : NCLColor.values()) {
            if (c.toString().equals(attributes.getValue(i)))             setSelBorderColor(c);
          }
        }
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setTransIn((T)new NCLTransition(attributes.getValue(i)));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setTransOut((T)new NCLTransition(attributes.getValue(i)));
      }
    }
 else     if (localName.equals(""String_Node_Str"")) {
      NCLDescriptorParam p=new NCLDescriptorParam(getReader(),this);
      p.startElement(uri,localName,qName,attributes);
      addDescriptorParam((P)p);
    }
  }
 catch (  NCLInvalidIdentifierException ex) {
  }
catch (  URISyntaxException ex) {
  }
}","@Override public void startElement(String uri,String localName,String qName,Attributes attributes){
  try {
    if (localName.equals(""String_Node_Str"")) {
      for (int i=0; i < attributes.getLength(); i++) {
        if (attributes.getLocalName(i).equals(""String_Node_Str""))         setId(attributes.getValue(i));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setRegion((R)new NCLRegion(attributes.getValue(i)));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str"")) {
          String value=attributes.getValue(i);
          if (value.contains(""String_Node_Str""))           value=value.substring(0,value.length() - 1);
          setExplicitDur(new Integer(value));
        }
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setFreeze(new Boolean(attributes.getValue(i)));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setPlayer(attributes.getValue(i));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str"")) {
          NCLDescriptor d=new NCLDescriptor(""String_Node_Str"" + attributes.getValue(i));
          d.setFocusIndex(new Integer(attributes.getValue(i)));
          setMoveLeft((D)d);
        }
 else         if (attributes.getLocalName(i).equals(""String_Node_Str"")) {
          NCLDescriptor d=new NCLDescriptor(""String_Node_Str"" + attributes.getValue(i));
          d.setFocusIndex(new Integer(attributes.getValue(i)));
          setMoveRight((D)d);
        }
 else         if (attributes.getLocalName(i).equals(""String_Node_Str"")) {
          NCLDescriptor d=new NCLDescriptor(""String_Node_Str"" + attributes.getValue(i));
          d.setFocusIndex(new Integer(attributes.getValue(i)));
          setMoveDown((D)d);
        }
 else         if (attributes.getLocalName(i).equals(""String_Node_Str"")) {
          NCLDescriptor d=new NCLDescriptor(""String_Node_Str"" + attributes.getValue(i));
          d.setFocusIndex(new Integer(attributes.getValue(i)));
          setMoveUp((D)d);
        }
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setFocusIndex(new Integer(attributes.getValue(i)));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str"")) {
          for (          NCLColor c : NCLColor.values()) {
            if (c.toString().equals(attributes.getValue(i)))             setFocusBorderColor(c);
          }
        }
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setFocusBorderWidth(new Integer(attributes.getValue(i)));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str"")) {
          String value=attributes.getValue(i);
          if (value.contains(""String_Node_Str""))           value=value.substring(0,value.length() - 1);
          setFocusBorderTransparency(new Integer(value));
        }
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setFocusSrc(attributes.getValue(i));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setFocusSelSrc(attributes.getValue(i));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str"")) {
          for (          NCLColor c : NCLColor.values()) {
            if (c.toString().equals(attributes.getValue(i)))             setSelBorderColor(c);
          }
        }
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setTransIn((T)new NCLTransition(attributes.getValue(i)));
 else         if (attributes.getLocalName(i).equals(""String_Node_Str""))         setTransOut((T)new NCLTransition(attributes.getValue(i)));
      }
    }
 else     if (localName.equals(""String_Node_Str"")) {
      NCLDescriptorParam p=new NCLDescriptorParam(getReader(),this);
      p.startElement(uri,localName,qName,attributes);
      addDescriptorParam((P)p);
    }
  }
 catch (  NCLInvalidIdentifierException ex) {
  }
catch (  URISyntaxException ex) {
  }
}",0.8167452176323815
5410,"@Override public void startElement(String uri,String localName,String qName,Attributes attributes){
  try {
    for (int i=0; i < attributes.getLength(); i++) {
      if (attributes.getLocalName(i).equals(""String_Node_Str""))       setId(attributes.getValue(i));
 else       if (attributes.getLocalName(i).equals(""String_Node_Str"")) {
        Vector<Integer> coord=new Vector<Integer>();
        String value=attributes.getValue(i);
        while (value.contains(""String_Node_Str"")) {
          int index=value.indexOf(""String_Node_Str"");
          coord.add(new Integer(value.substring(0,index)));
          value.substring(index + 1);
        }
        coord.add(new Integer(value));
        int[] a=new int[coord.size()];
        for (int k=0; k < coord.size(); k++)         a[k]=(int)coord.elementAt(k);
        setCoords(a);
      }
 else       if (attributes.getLocalName(i).equals(""String_Node_Str""))       setBegin(new NCLTime(attributes.getValue(i)));
 else       if (attributes.getLocalName(i).equals(""String_Node_Str""))       setEnd(new NCLTime(attributes.getValue(i)));
 else       if (attributes.getLocalName(i).equals(""String_Node_Str""))       setText(attributes.getValue(i));
 else       if (attributes.getLocalName(i).equals(""String_Node_Str""))       setPosition(new Integer(attributes.getValue(i)));
 else       if (attributes.getLocalName(i).equals(""String_Node_Str""))       setFirst(new NCLSample(attributes.getValue(i)));
 else       if (attributes.getLocalName(i).equals(""String_Node_Str""))       setLast(new NCLSample(attributes.getValue(i)));
 else       if (attributes.getLocalName(i).equals(""String_Node_Str""))       setLabel(attributes.getValue(i));
    }
  }
 catch (  NCLInvalidIdentifierException ex) {
  }
}","@Override public void startElement(String uri,String localName,String qName,Attributes attributes){
  try {
    for (int i=0; i < attributes.getLength(); i++) {
      if (attributes.getLocalName(i).equals(""String_Node_Str""))       setId(attributes.getValue(i));
 else       if (attributes.getLocalName(i).equals(""String_Node_Str"")) {
        Vector<Integer> coord=new Vector<Integer>();
        String value=attributes.getValue(i);
        while (value.contains(""String_Node_Str"")) {
          int index=value.indexOf(""String_Node_Str"");
          coord.add(new Integer(value.substring(0,index)));
          value=value.substring(index + 1);
        }
        coord.add(new Integer(value));
        int[] a=new int[coord.size()];
        for (int k=0; k < coord.size(); k++)         a[k]=(int)coord.elementAt(k);
        setCoords(a);
      }
 else       if (attributes.getLocalName(i).equals(""String_Node_Str""))       setBegin(new NCLTime(attributes.getValue(i)));
 else       if (attributes.getLocalName(i).equals(""String_Node_Str""))       setEnd(new NCLTime(attributes.getValue(i)));
 else       if (attributes.getLocalName(i).equals(""String_Node_Str""))       setText(attributes.getValue(i));
 else       if (attributes.getLocalName(i).equals(""String_Node_Str""))       setPosition(new Integer(attributes.getValue(i)));
 else       if (attributes.getLocalName(i).equals(""String_Node_Str""))       setFirst(new NCLSample(attributes.getValue(i)));
 else       if (attributes.getLocalName(i).equals(""String_Node_Str""))       setLast(new NCLSample(attributes.getValue(i)));
 else       if (attributes.getLocalName(i).equals(""String_Node_Str""))       setLabel(attributes.getValue(i));
    }
  }
 catch (  NCLInvalidIdentifierException ex) {
  }
}",0.9982748706152962
5411,"@Override public String toString(){
  if (getSecond() != null) {
    if (getFraction() != null) {
      if (getHour() != null && getMinute() != null) {
        if (getYear() != null && getMonth() != null && getDay() != null) {
          return year + ""String_Node_Str"" + month+ ""String_Node_Str""+ day+ ""String_Node_Str""+ hour+ ""String_Node_Str""+ minute+ ""String_Node_Str""+ second+ ""String_Node_Str""+ fraction;
        }
 else         return hour + ""String_Node_Str"" + minute+ ""String_Node_Str""+ second+ ""String_Node_Str""+ fraction;
      }
 else       return second + ""String_Node_Str"" + fraction+ ""String_Node_Str"";
    }
 else     return second + ""String_Node_Str"";
  }
  return null;
}","@Override public String toString(){
  if (getSecond() == null)   return null;
  String result=""String_Node_Str"";
  if (getYear() != null && getMonth() != null && getDay() != null)   result+=getYear() + ""String_Node_Str"" + getMonth()+ ""String_Node_Str""+ getDay()+ ""String_Node_Str"";
  if (getHour() != null && getMinute() != null)   result+=getHour() + ""String_Node_Str"" + getMinute()+ ""String_Node_Str"";
  if (getFraction() != null)   result+=getSecond() + ""String_Node_Str"" + getFraction();
 else   result+=getSecond();
  if (absoluteSecond())   result+=""String_Node_Str"";
  return result;
}",0.2109375
5412,"@Override public void onEnable(){
  if (!initialized) {
    onLoad();
  }
  if (!loadError) {
    log.info(""String_Node_Str"");
    groupService=new GroupService(currentServer,config.getIgnoreGroups());
    StatsSerializer.enableSerializerCache=config.getEnableSerializerCache();
    getCommand(""String_Node_Str"").setExecutor(new PlayedCommand(controller));
    StatsPlayerListener spl=new StatsPlayerListener(controller);
    getServer().getPluginManager().registerEvent(Type.PLAYER_JOIN,spl,Priority.Monitor,this);
    getServer().getPluginManager().registerEvent(Type.PLAYER_QUIT,spl,Priority.Monitor,this);
    getServer().getPluginManager().registerEvent(Type.PLAYER_KICK,spl,Priority.Monitor,this);
    getServer().getPluginManager().registerEvent(Type.PLAYER_MOVE,spl,Priority.Monitor,this);
    getServer().getPluginManager().registerEvent(Type.PLAYER_DROP_ITEM,spl,Priority.Monitor,this);
    StatsEntityListener sel=new StatsEntityListener(controller);
    getServer().getPluginManager().registerEvent(Type.ENTITY_DEATH,sel,Priority.Monitor,this);
    getServer().getPluginManager().registerEvent(Type.ENTITY_DAMAGE,sel,Priority.Monitor,this);
    StatsBlockListener sbl=new StatsBlockListener(controller);
    getServer().getPluginManager().registerEvent(Type.BLOCK_PLACE,sbl,Priority.Monitor,this);
    getServer().getPluginManager().registerEvent(Type.BLOCK_BREAK,sbl,Priority.Monitor,this);
    if (config.getPlayersToPurge().length > 0) {
      for (      String playerName : config.getPlayersToPurge()) {
        model.purgePlayer(playerName);
      }
      config.clearPlayersToPurge();
    }
    if (config.getResetPlaytime()) {
      log.info(""String_Node_Str"");
      model.resetAllPlaytimes();
      config.clearResetPlaytime();
    }
    if (config.getWebserverEnabled()) {
      String resource=config.getStatsBaseResource();
      String contextRoot=config.getHttpServerContextRoot();
      log.info(""String_Node_Str"");
      try {
        server=HttpServer.create(new InetSocketAddress(config.getHttpPort()),config.getHttpBacklog());
        server.createContext(contextRoot,new StatsHttpHandler(model,config));
        server.setExecutor(null);
        server.start();
        log.info(String.format(""String_Node_Str"",config.getHttpPort(),contextRoot,resource + ""String_Node_Str"",resource + ""String_Node_Str"",resource + ""String_Node_Str"",resource + ""String_Node_Str""));
      }
 catch (      IOException e) {
        log.log(Level.SEVERE,""String_Node_Str"",e);
        log.severe(""String_Node_Str"");
      }
    }
    Runtime.getRuntime().addShutdownHook(hook);
    controller.logOutAllPlayers();
    controller.logInOnlinePlayers();
    model.startPersisting();
  }
}","@Override public void onEnable(){
  if (!initialized) {
    onLoad();
  }
  if (!loadError) {
    log.info(""String_Node_Str"");
    groupService=new GroupService(currentServer,config.getIgnoreGroups());
    IConomyService.initialize();
    StatsSerializer.enableSerializerCache=config.getEnableSerializerCache();
    getCommand(""String_Node_Str"").setExecutor(new PlayedCommand(controller));
    StatsPlayerListener spl=new StatsPlayerListener(controller);
    getServer().getPluginManager().registerEvent(Type.PLAYER_JOIN,spl,Priority.Monitor,this);
    getServer().getPluginManager().registerEvent(Type.PLAYER_QUIT,spl,Priority.Monitor,this);
    getServer().getPluginManager().registerEvent(Type.PLAYER_KICK,spl,Priority.Monitor,this);
    getServer().getPluginManager().registerEvent(Type.PLAYER_MOVE,spl,Priority.Monitor,this);
    getServer().getPluginManager().registerEvent(Type.PLAYER_DROP_ITEM,spl,Priority.Monitor,this);
    StatsEntityListener sel=new StatsEntityListener(controller);
    getServer().getPluginManager().registerEvent(Type.ENTITY_DEATH,sel,Priority.Monitor,this);
    getServer().getPluginManager().registerEvent(Type.ENTITY_DAMAGE,sel,Priority.Monitor,this);
    StatsBlockListener sbl=new StatsBlockListener(controller);
    getServer().getPluginManager().registerEvent(Type.BLOCK_PLACE,sbl,Priority.Monitor,this);
    getServer().getPluginManager().registerEvent(Type.BLOCK_BREAK,sbl,Priority.Monitor,this);
    if (config.getPlayersToPurge().length > 0) {
      for (      String playerName : config.getPlayersToPurge()) {
        model.purgePlayer(playerName);
      }
      config.clearPlayersToPurge();
    }
    if (config.getResetPlaytime()) {
      log.info(""String_Node_Str"");
      model.resetAllPlaytimes();
      config.clearResetPlaytime();
    }
    if (config.getWebserverEnabled()) {
      String resource=config.getStatsBaseResource();
      String contextRoot=config.getHttpServerContextRoot();
      log.info(""String_Node_Str"");
      try {
        server=HttpServer.create(new InetSocketAddress(config.getHttpPort()),config.getHttpBacklog());
        server.createContext(contextRoot,new StatsHttpHandler(model,config));
        server.setExecutor(null);
        server.start();
        log.info(String.format(""String_Node_Str"",config.getHttpPort(),contextRoot,resource + ""String_Node_Str"",resource + ""String_Node_Str"",resource + ""String_Node_Str"",resource + ""String_Node_Str""));
      }
 catch (      IOException e) {
        log.log(Level.SEVERE,""String_Node_Str"",e);
        log.severe(""String_Node_Str"");
      }
    }
    Runtime.getRuntime().addShutdownHook(hook);
    controller.logOutAllPlayers();
    controller.logInOnlinePlayers();
    model.startPersisting();
  }
}",0.9939080671958648
5413,"public String[] getGroups(Player player){
  ArrayList<String> playerGroups=new ArrayList<String>();
  if (player.isOp()) {
    playerGroups.add(""String_Node_Str"");
  }
  if (permissions != null) {
    ArrayList<String> keepGroups=new ArrayList<String>();
    for (    String group : permissions.getGroups(player.getWorld().getName(),player.getName())) {
      if (permissions.inSingleGroup(player.getWorld().getName(),player.getName(),group)) {
        keepGroups.add(toTitleCase(group));
      }
    }
    for (    String ignore : ignoreGroups) {
      String tcIgnore=toTitleCase(ignore);
      if (keepGroups.contains(tcIgnore)) {
        keepGroups.remove(tcIgnore);
      }
    }
    playerGroups.addAll(keepGroups);
  }
  return playerGroups.toArray(new String[]{});
}","public String[] getGroups(Player player){
  ArrayList<String> playerGroups=new ArrayList<String>();
  if (player.isOp()) {
    playerGroups.add(""String_Node_Str"");
  }
  if (permissions != null) {
    ArrayList<String> keepGroups=new ArrayList<String>();
    try {
      for (      String group : permissions.getGroups(player.getWorld().getName(),player.getName())) {
        if (permissions.inSingleGroup(player.getWorld().getName(),player.getName(),group)) {
          keepGroups.add(toTitleCase(group));
        }
      }
    }
 catch (    NoSuchMethodError e) {
    }
    for (    String ignore : ignoreGroups) {
      String tcIgnore=toTitleCase(ignore);
      if (keepGroups.contains(tcIgnore)) {
        keepGroups.remove(tcIgnore);
      }
    }
    playerGroups.addAll(keepGroups);
  }
  return playerGroups.toArray(new String[]{});
}",0.956091527520099
5414,"@Override public void onPlayerMove(PlayerMoveEvent event){
  Block b;
  Player player=event.getPlayer();
  if (Nethrar.permissions != null && !Nethrar.permissions.has(player,""String_Node_Str"")) {
    return;
  }
  if (!event.getPlayer().isInsideVehicle()) {
    b=event.getTo().getBlock();
  }
 else {
    b=event.getTo().getBlock().getFace(BlockFace.UP);
  }
  if (!b.getType().equals(Material.PORTAL)) {
    return;
  }
  Portal portal=PortalUtil.getPortalAt(b);
  if (portal != null) {
    Location endpoint=portal.teleport(player);
    if (endpoint != null) {
      event.setTo(endpoint);
    }
  }
}","@Override public void onPlayerMove(PlayerMoveEvent event){
  Block b;
  Player player=event.getPlayer();
  if (Nethrar.permissions != null && !Nethrar.permissions.has(player,""String_Node_Str"")) {
    return;
  }
  if (!event.getPlayer().isInsideVehicle()) {
    b=event.getTo().getBlock();
  }
 else {
    b=event.getTo().getBlock().getFace(BlockFace.UP);
  }
  if (!b.getType().equals(Material.PORTAL)) {
    return;
  }
  Portal portal=PortalUtil.getPortalAt(b);
  if (portal != null) {
    Location endpoint=portal.teleport(player,event.getTo());
    if (endpoint != null) {
      event.setTo(endpoint);
    }
  }
}",0.9885433715220948
5415,"@Override public void onVehicleMove(VehicleMoveEvent event){
  Block b;
  Vehicle vehicle=event.getVehicle();
  if (vehicle.getPassenger() != null) {
    return;
  }
  b=vehicle.getLocation().getBlock();
  if (!b.getType().equals(Material.PORTAL)) {
    return;
  }
  Portal portal=PortalUtil.getPortalAt(b);
  portal.teleport(vehicle);
}","@Override public void onVehicleMove(VehicleMoveEvent event){
  Block b;
  Vehicle vehicle=event.getVehicle();
  if (vehicle.getPassenger() != null) {
    return;
  }
  b=vehicle.getLocation().getBlock();
  if (!b.getType().equals(Material.PORTAL)) {
    return;
  }
  Portal portal=PortalUtil.getPortalAt(b);
  portal.teleport(vehicle,event.getTo());
}",0.9797101449275364
5416,"/** 
 * Teleports the passed in Entity through the portal. Given an Entity object, attempts to teleport them through the portal. This involves many steps. 1) Verify the portal on the other end still exists. If it doesn't, mark this as such. 2) If there is no counterpart, figure out where it would be, and get it. This may involve generating and placing a portal into the world. 3) Assuming we now have a counterpart, figure out where to teleport the entity to. 3a) Figure out the entity's position relative to the entry portal. 3b) Translate this to a position relative to the exit portal. 3c) Preserve the entity's camera's orientation relative to the portal. 4) Teleport the entity. 4a) If the entity is a Player in a vehicle, we do a dance. - Raise the destination by 1 (vehicles have to 'fall' into the portal to avoid losing momentum, so they should be one higher). - Make the player leave the vehicle. - Spawn a new minecart at the destination. - Teleport the player to the destination. - Make the player a passenger of the minecart. - Give the new minecart the (properly translated) velocity of the old vehicle. - Remove the old vehicle.
 * @param e The entity to teleport.
 * @return The location the entity was teleported to, or null if theentity was not teleported.
 */
public Location teleport(Entity e){
  if (this.counterpart != null) {
    if (!this.counterpart.isValid()) {
      PortalUtil.removePortal(this.counterpart);
      this.counterpart=null;
      PortalUtil.getCounterpartPortalFor(this);
    }
  }
 else {
    PortalUtil.getCounterpartPortalFor(this);
  }
  if (this.counterpart == null) {
    return null;
  }
  double destX, destY, destZ;
  float destPitch, destYaw;
  int rotateVehicleVelocity=0;
  Vector offset=e.getLocation().toVector().subtract(this.keyBlock.getLocation().toVector());
  Vector finalOffset;
  if (this.facingNorth) {
    if (offset.getX() < .5) {
      offset.setX(offset.getX() + 1);
    }
 else {
      offset.setX(offset.getX() - 1);
    }
    if (this.counterpart.isFacingNorth()) {
      destYaw=e.getLocation().getYaw();
      finalOffset=offset;
    }
 else {
      destYaw=e.getLocation().getYaw() - 90;
      finalOffset=new Vector(offset.getZ(),offset.getY(),-offset.getX() + 1);
      rotateVehicleVelocity=1;
    }
  }
 else {
    if (offset.getZ() < .5) {
      offset.setZ(offset.getZ() + 1);
    }
 else {
      offset.setZ(offset.getZ() - 1);
    }
    if (this.counterpart.isFacingNorth()) {
      destYaw=e.getLocation().getYaw() + 90;
      finalOffset=new Vector(-offset.getZ() + 1,offset.getY(),offset.getX());
      rotateVehicleVelocity=2;
    }
 else {
      destYaw=e.getLocation().getYaw();
      finalOffset=offset;
    }
  }
  World destWorld=this.counterpart.getKeyBlock().getWorld();
  destX=this.counterpart.getKeyBlock().getX() + finalOffset.getX();
  destY=this.counterpart.getKeyBlock().getY() + finalOffset.getY();
  destZ=this.counterpart.getKeyBlock().getZ() + finalOffset.getZ();
  destPitch=e.getLocation().getPitch();
  if (e instanceof Player && ((Player)e).isInsideVehicle() || e instanceof Vehicle) {
    destY+=1.0;
  }
  Location dest;
  dest=new Location(destWorld,destX,destY,destZ,destYaw,destPitch);
  Chunk destChunk=dest.getBlock().getChunk();
  for (int dx=-1; dx <= 1; dx++) {
    for (int dz=-1; dz <= 1; dz++) {
      destWorld.loadChunk(destChunk.getX() + dx,destChunk.getZ() + dz);
    }
  }
  Vehicle oldV=null, newV=null;
  if (e instanceof Player) {
    if (((Player)e).isInsideVehicle()) {
      oldV=((Player)e).getVehicle();
      ((Player)e).leaveVehicle();
    }
  }
 else   if (e instanceof StorageMinecart || e instanceof Minecart || e instanceof Boat) {
    oldV=((Vehicle)e);
  }
  if (oldV != null) {
    if (oldV instanceof StorageMinecart) {
      newV=destWorld.spawn(dest,StorageMinecart.class);
      ((StorageMinecart)newV).getInventory().setContents(((StorageMinecart)oldV).getInventory().getContents());
    }
 else     if (oldV instanceof Minecart) {
      newV=destWorld.spawn(dest,Minecart.class);
    }
 else     if (oldV instanceof Boat) {
      newV=destWorld.spawn(dest,Boat.class);
    }
 else {
      log.warning(""String_Node_Str"");
    }
    Vector oldVelocity=oldV.getVelocity();
    Vector newVelocity;
switch (rotateVehicleVelocity) {
case 1:
      newVelocity=new Vector(oldVelocity.getZ(),oldVelocity.getY(),oldVelocity.getX() * -1);
    break;
case 2:
  newVelocity=new Vector(oldVelocity.getZ() * -1,oldVelocity.getY(),oldVelocity.getX());
break;
default :
newVelocity=oldVelocity;
break;
}
final Location threadDest=dest;
final Entity threadE=e;
final Vehicle threadOldV=oldV;
final Vehicle threadNewV=newV;
final Vector threadNewVelocity=newVelocity;
Bukkit.getServer().getScheduler().scheduleSyncDelayedTask(PortalUtil.getPlugin(),new Runnable(){
public void run(){
if (threadE instanceof Player) {
if (((Player)threadE).teleport(threadDest)) {
World destWorld=threadE.getLocation().getWorld();
Chunk destChunk=threadE.getLocation().getBlock().getChunk();
int x=destChunk.getX(), z=destChunk.getZ();
for (int dx=-1; dx <= 1; dx++) {
  for (int dz=-1; dz <= 1; dz++) {
    destWorld.refreshChunk(x + dx,z + dz);
  }
}
}
 else {
return;
}
}
if (threadNewV != null) {
if (threadE instanceof Player) {
threadNewV.setPassenger(threadE);
}
threadNewV.setVelocity(threadNewVelocity);
}
Bukkit.getServer().getPluginManager().callEvent(new NethrarVehicleTeleportEvent(threadOldV,threadNewV));
threadOldV.remove();
}
}
);
}
 else {
final Location threadDest=dest;
final Entity threadE=e;
return dest;
}
return null;
}","/** 
 * Teleports the passed in Entity through the portal. Given an Entity object, attempts to teleport them through the portal. This involves many steps. 1) Verify the portal on the other end still exists. If it doesn't, mark this as such. 2) If there is no counterpart, figure out where it would be, and get it. This may involve generating and placing a portal into the world. 3) Assuming we now have a counterpart, figure out where to teleport the entity to. 3a) Figure out the entity's position relative to the entry portal. 3b) Translate this to a position relative to the exit portal. 3c) Preserve the entity's camera's orientation relative to the portal. 4) Teleport the entity. 4a) If the entity is a Player in a vehicle, we do a dance. - Raise the destination by 1 (vehicles have to 'fall' into the portal to avoid losing momentum, so they should be one higher). - Make the player leave the vehicle. - Spawn a new minecart at the destination. - Teleport the player to the destination. - Make the player a passenger of the minecart. - Give the new minecart the (properly translated) velocity of the old vehicle. - Remove the old vehicle.
 * @param e The entity to teleport.
 * @return The location the entity was teleported to, or null if theentity was not teleported.
 */
public Location teleport(Entity e,Location interaction){
  if (this.counterpart != null) {
    if (!this.counterpart.isValid()) {
      PortalUtil.removePortal(this.counterpart);
      this.counterpart=null;
      PortalUtil.getCounterpartPortalFor(this);
    }
  }
 else {
    PortalUtil.getCounterpartPortalFor(this);
  }
  if (this.counterpart == null) {
    return null;
  }
  double destX, destY, destZ;
  float destPitch, destYaw;
  int rotateVehicleVelocity=0;
  Vector offset=interaction.toVector().subtract(this.keyBlock.getLocation().toVector());
  Vector finalOffset;
  if (this.facingNorth) {
    if (offset.getX() < .5) {
      offset.setX(offset.getX() + OFFSET);
    }
 else {
      offset.setX(offset.getX() - OFFSET);
    }
    if (this.counterpart.isFacingNorth()) {
      destYaw=e.getLocation().getYaw();
      finalOffset=offset;
    }
 else {
      destYaw=e.getLocation().getYaw() - 90;
      finalOffset=new Vector(offset.getZ(),offset.getY(),-offset.getX() + 1);
      rotateVehicleVelocity=1;
    }
  }
 else {
    if (offset.getZ() < .5) {
      offset.setZ(offset.getZ() + OFFSET);
    }
 else {
      offset.setZ(offset.getZ() - OFFSET);
    }
    if (this.counterpart.isFacingNorth()) {
      destYaw=e.getLocation().getYaw() + 90;
      finalOffset=new Vector(-offset.getZ() + 1,offset.getY(),offset.getX());
      rotateVehicleVelocity=2;
    }
 else {
      destYaw=e.getLocation().getYaw();
      finalOffset=offset;
    }
  }
  World destWorld=this.counterpart.getKeyBlock().getWorld();
  destX=this.counterpart.getKeyBlock().getX() + finalOffset.getX();
  destY=this.counterpart.getKeyBlock().getY() + finalOffset.getY();
  destZ=this.counterpart.getKeyBlock().getZ() + finalOffset.getZ();
  destPitch=e.getLocation().getPitch();
  if (e instanceof Player && ((Player)e).isInsideVehicle() || e instanceof Vehicle) {
    destY+=1.0;
  }
  Location dest;
  dest=new Location(destWorld,destX,destY,destZ,destYaw,destPitch);
  Chunk destChunk=dest.getBlock().getChunk();
  for (int dx=-1; dx <= 1; dx++) {
    for (int dz=-1; dz <= 1; dz++) {
      destWorld.loadChunk(destChunk.getX() + dx,destChunk.getZ() + dz);
    }
  }
  Vehicle oldV=null, newV=null;
  if (e instanceof Player) {
    if (((Player)e).isInsideVehicle()) {
      oldV=((Player)e).getVehicle();
      ((Player)e).leaveVehicle();
    }
  }
 else   if (e instanceof StorageMinecart || e instanceof Minecart || e instanceof Boat) {
    oldV=((Vehicle)e);
  }
  if (oldV != null) {
    if (oldV instanceof StorageMinecart) {
      newV=destWorld.spawn(dest,StorageMinecart.class);
      ((StorageMinecart)newV).getInventory().setContents(((StorageMinecart)oldV).getInventory().getContents());
    }
 else     if (oldV instanceof Minecart) {
      newV=destWorld.spawn(dest,Minecart.class);
    }
 else     if (oldV instanceof Boat) {
      newV=destWorld.spawn(dest,Boat.class);
    }
 else {
      log.warning(""String_Node_Str"");
    }
    Vector oldVelocity=oldV.getVelocity();
    Vector newVelocity;
switch (rotateVehicleVelocity) {
case 1:
      newVelocity=new Vector(oldVelocity.getZ(),oldVelocity.getY(),oldVelocity.getX() * -1);
    break;
case 2:
  newVelocity=new Vector(oldVelocity.getZ() * -1,oldVelocity.getY(),oldVelocity.getX());
break;
default :
newVelocity=oldVelocity;
break;
}
final Location threadDest=dest;
final Entity threadE=e;
final Vehicle threadOldV=oldV;
final Vehicle threadNewV=newV;
final Vector threadNewVelocity=newVelocity;
Bukkit.getServer().getScheduler().scheduleSyncDelayedTask(PortalUtil.getPlugin(),new Runnable(){
public void run(){
if (threadE instanceof Player) {
if (((Player)threadE).teleport(threadDest)) {
World destWorld=threadE.getLocation().getWorld();
Chunk destChunk=threadE.getLocation().getBlock().getChunk();
int x=destChunk.getX(), z=destChunk.getZ();
for (int dx=-1; dx <= 1; dx++) {
  for (int dz=-1; dz <= 1; dz++) {
    destWorld.refreshChunk(x + dx,z + dz);
  }
}
}
 else {
return;
}
}
if (threadNewV != null) {
if (threadE instanceof Player) {
threadNewV.setPassenger(threadE);
}
threadNewV.setVelocity(threadNewVelocity);
}
Bukkit.getServer().getPluginManager().callEvent(new NethrarVehicleTeleportEvent(threadOldV,threadNewV));
threadOldV.remove();
}
}
);
}
 else {
final Location threadDest=dest;
final Entity threadE=e;
return dest;
}
return null;
}",0.9871760380234956
5417,"public Value<?> readValueRec() throws IOException {
  final int first=stream.read();
  if (first == END_VALUE) {
    return BVOID;
  }
 else   if (first == INTEGER_VALUE) {
    int i=0;
    boolean end=false;
    while (!end) {
      final int readInt=stream.read();
      if (readInt < 0) {
        throw new EOFException();
      }
 else       if (readInt == END_VALUE) {
        end=true;
      }
 else       if ((readInt >= '0' && readInt <= '9') || (i == 0 && readInt == '-')) {
        charBuffer[i]=(char)readInt;
        i++;
      }
 else {
        throw new IOException(""String_Node_Str"");
      }
    }
    return new IntegerValue(Long.valueOf(new String(charBuffer,0,i)));
  }
 else   if (first == LIST_VALUE) {
    final List<Value<?>> list=new ArrayList<Value<?>>();
    boolean end=false;
    while (!end) {
      final Value<?> val=readValueRec();
      if (val == BVOID) {
        end=true;
      }
 else {
        list.add(val);
      }
    }
    return new ListValue(list);
  }
 else   if (first == DICTIONARY_VALUE) {
    final SortedMap<String,Value<?>> map=new TreeMap<String,Value<?>>();
    String lastKeyStr=null;
    boolean end=false;
    while (!end) {
      final Value<?> key=readValueRec();
      if (key != null && !(key instanceof StringValue)) {
        throw new IOException(""String_Node_Str"");
      }
      if (key == BVOID) {
        end=true;
      }
 else {
        final String currKeyStr=((StringValue)key).getStringValue();
        if (lastKeyStr != null) {
          final int cmp=lastKeyStr.compareTo(currKeyStr);
          if (cmp > 0) {
            throw new IOException(""String_Node_Str"");
          }
 else           if (cmp == 0) {
            throw new IOException(""String_Node_Str"");
          }
        }
        lastKeyStr=currKeyStr;
        final Value<?> val=readValueRec();
        if (val == null) {
          throw new IOException(""String_Node_Str"");
        }
        map.put(new String((byte[])key.getValue(),Bencode.UTF8),val);
      }
    }
    return new DictionaryValue(map);
  }
 else   if (first >= STRING_VALUE_FROM && first <= STRING_VALUE_TO) {
    charBuffer[0]=(char)first;
    int i=1;
    boolean end=false;
    while (!end) {
      final int readInt=stream.read();
      if (readInt < 0) {
        throw new EOFException();
      }
 else       if (readInt == ':') {
        end=true;
      }
 else       if (readInt >= '0' && readInt <= '9') {
        charBuffer[i]=(char)readInt;
        i++;
      }
 else {
        throw new IOException(""String_Node_Str"");
      }
    }
    final long lsize=Long.parseLong(new String(charBuffer,0,i));
    if (lsize > Integer.MAX_VALUE) {
      throw new IOException(""String_Node_Str"");
    }
    final int size=(int)lsize;
    if (byteBuffer.length < lsize) {
      byteBuffer=new byte[Math.max(size + 1,byteBuffer.length * 2 + 1)];
    }
    final int howMany=stream.read(byteBuffer,0,size);
    if (howMany != size) {
      throw new EOFException();
    }
    return new StringValue(Arrays.copyOf(byteBuffer,size));
  }
 else {
    if (first == -1) {
      return null;
    }
 else {
      throw new IOException(""String_Node_Str"" + Integer.toHexString(first));
    }
  }
}","public Value<?> readValueRec() throws IOException {
  final int first=stream.read();
  if (first == END_VALUE) {
    return BVOID;
  }
 else   if (first == INTEGER_VALUE) {
    int i=0;
    boolean end=false;
    while (!end) {
      final int readInt=stream.read();
      if (readInt < 0) {
        throw new EOFException();
      }
 else       if (readInt == END_VALUE) {
        end=true;
      }
 else       if ((readInt >= '0' && readInt <= '9') || (i == 0 && readInt == '-')) {
        charBuffer[i]=(char)readInt;
        i++;
      }
 else {
        throw new IOException(""String_Node_Str"");
      }
    }
    return new IntegerValue(Long.valueOf(new String(charBuffer,0,i)));
  }
 else   if (first == LIST_VALUE) {
    final List<Value<?>> list=new ArrayList<Value<?>>();
    boolean end=false;
    while (!end) {
      final Value<?> val=readValueRec();
      if (val == BVOID) {
        end=true;
      }
 else {
        list.add(val);
      }
    }
    return new ListValue(list);
  }
 else   if (first == DICTIONARY_VALUE) {
    final SortedMap<String,Value<?>> map=new TreeMap<String,Value<?>>();
    String lastKeyStr=null;
    boolean end=false;
    while (!end) {
      final Value<?> key=readValueRec();
      if (key != BVOID && !(key instanceof StringValue)) {
        throw new IOException(""String_Node_Str"");
      }
      if (key == BVOID) {
        end=true;
      }
 else {
        final String currKeyStr=((StringValue)key).getStringValue();
        if (lastKeyStr != null) {
          final int cmp=lastKeyStr.compareTo(currKeyStr);
          if (cmp > 0) {
            throw new IOException(""String_Node_Str"");
          }
 else           if (cmp == 0) {
            throw new IOException(""String_Node_Str"");
          }
        }
        lastKeyStr=currKeyStr;
        final Value<?> val=readValueRec();
        if (val == null) {
          throw new IOException(""String_Node_Str"");
        }
        map.put(new String((byte[])key.getValue(),Bencode.UTF8),val);
      }
    }
    return new DictionaryValue(map);
  }
 else   if (first >= STRING_VALUE_FROM && first <= STRING_VALUE_TO) {
    charBuffer[0]=(char)first;
    int i=1;
    boolean end=false;
    while (!end) {
      final int readInt=stream.read();
      if (readInt < 0) {
        throw new EOFException();
      }
 else       if (readInt == ':') {
        end=true;
      }
 else       if (readInt >= '0' && readInt <= '9') {
        charBuffer[i]=(char)readInt;
        i++;
      }
 else {
        throw new IOException(""String_Node_Str"");
      }
    }
    final long lsize=Long.parseLong(new String(charBuffer,0,i));
    if (lsize > Integer.MAX_VALUE) {
      throw new IOException(""String_Node_Str"");
    }
    final int size=(int)lsize;
    if (byteBuffer.length < lsize) {
      byteBuffer=new byte[Math.max(size + 1,byteBuffer.length * 2 + 1)];
    }
    final int howMany=stream.read(byteBuffer,0,size);
    if (howMany != size) {
      throw new EOFException();
    }
    return new StringValue(Arrays.copyOf(byteBuffer,size));
  }
 else {
    if (first == -1) {
      return null;
    }
 else {
      throw new IOException(""String_Node_Str"" + Integer.toHexString(first));
    }
  }
}",0.9985886780617844
5418,"@Override public void flush() throws IOException {
  stream.flush();
}","@Override public void flush(){
  stream.flush();
}",0.8333333333333334
5419,"@Override public void close() throws IOException {
  stream.close();
}","@Override public void close(){
  stream.close();
}",0.8333333333333334
5420,"/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private void encodeBitField(ByteBuffer buffer,BitFieldMessage msg){
  BitSet bitfield=msg.getBitField();
  int nbytes=(bitfield.size() + 7) / 8;
  byte[] bytes=new byte[nbytes];
  for (int i=0; i < nbytes * 8; i++) {
    if (bitfield.get(i)) {
      int bInd=i % 8;
      int bMask=1 << (7 - (i / 8));
      bytes[bInd]|=bMask;
    }
  }
  buffer.putInt(nbytes + 1);
  buffer.put((byte)msg.getMessageType().getId());
  buffer.put(bytes);
}","/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private static void encodeBitField(ByteBuffer buffer,BitFieldMessage msg){
  BitSet bitfield=msg.getBitField();
  int nbytes=(bitfield.size() + 7) / 8;
  byte[] bytes=new byte[nbytes];
  for (int i=0; i < nbytes * 8; i++) {
    if (bitfield.get(i)) {
      int bInd=i % 8;
      int bMask=1 << (7 - (i / 8));
      bytes[bInd]|=bMask;
    }
  }
  buffer.putInt(nbytes + 1);
  buffer.put((byte)msg.getMessageType().getId());
  buffer.put(bytes);
}",0.9947722180731888
5421,"/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private void encodeRequest(ByteBuffer buffer,RequestMessage msg){
  buffer.putInt(13);
  buffer.put((byte)msg.getMessageType().getId());
  buffer.putInt(msg.getIndex());
  buffer.putInt(msg.getOffset());
  buffer.putInt(msg.getLength());
}","/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private static void encodeRequest(ByteBuffer buffer,RequestMessage msg){
  buffer.putInt(13);
  buffer.put((byte)msg.getMessageType().getId());
  buffer.putInt(msg.getIndex());
  buffer.putInt(msg.getOffset());
  buffer.putInt(msg.getLength());
}",0.992545260915868
5422,"/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private void encodeHave(ByteBuffer buffer,HaveMessage msg){
  buffer.putInt(5);
  buffer.put((byte)msg.getMessageType().getId());
  buffer.putInt(msg.getPieceIndex());
}","/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private static void encodeHave(ByteBuffer buffer,HaveMessage msg){
  buffer.putInt(5);
  buffer.put((byte)msg.getMessageType().getId());
  buffer.putInt(msg.getPieceIndex());
}",0.9912390488110138
5423,"/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private void encodePort(ByteBuffer buffer,PortMessage msg){
  buffer.putInt(3);
  buffer.put((byte)msg.getMessageType().getId());
  buffer.putShort((short)msg.getPort());
}","/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private static void encodePort(ByteBuffer buffer,PortMessage msg){
  buffer.putInt(3);
  buffer.put((byte)msg.getMessageType().getId());
  buffer.putShort((short)msg.getPort());
}",0.991304347826087
5424,"/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private void encodeCancel(ByteBuffer buffer,CancelMessage msg){
  buffer.putInt(13);
  buffer.put((byte)msg.getMessageType().getId());
  buffer.putInt(msg.getIndex());
  buffer.putInt(msg.getOffset());
  buffer.putInt(msg.getLength());
}","/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private static void encodeCancel(ByteBuffer buffer,CancelMessage msg){
  buffer.putInt(13);
  buffer.put((byte)msg.getMessageType().getId());
  buffer.putInt(msg.getIndex());
  buffer.putInt(msg.getOffset());
  buffer.putInt(msg.getLength());
}",0.9925133689839571
5425,"/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private void encodeHandShakeStart(ByteBuffer buffer,HandShakeStart msg){
  buffer.put((byte)msg.getProtocolName().length());
  buffer.put(msg.getProtocolName().getBytes(ISO_8859_1));
  byte[] bits=new byte[8];
  BitSet flags=msg.getFlags();
  for (int i=0; i < 64; i++) {
    if (flags.get(i)) {
      int bInd=7 - (i / 8);
      int bMask=1 << (i % 8);
      bits[bInd]|=bMask;
    }
  }
  buffer.put(msg.getHash().getBytes());
}","/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private static void encodeHandShakeStart(ByteBuffer buffer,HandShakeStart msg){
  buffer.put((byte)msg.getProtocolName().length());
  buffer.put(msg.getProtocolName().getBytes(ISO_8859_1));
  byte[] bits=new byte[8];
  BitSet flags=msg.getFlags();
  for (int i=0; i < 64; i++) {
    if (flags.get(i)) {
      int bInd=7 - (i / 8);
      int bMask=1 << (i % 8);
      bits[bInd]|=bMask;
    }
  }
  buffer.put(bits);
  buffer.put(msg.getHash().getBytes());
}",0.9798657718120806
5426,"/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private void encodePiece(ByteBuffer buffer,PieceMessage msg){
  ByteBuffer contents=msg.getPieceContents();
  contents.rewind().limit(contents.capacity());
  buffer.putInt(9 + contents.capacity());
  buffer.put((byte)msg.getMessageType().getId());
  buffer.putInt(msg.getIndex());
  buffer.putInt(msg.getOffset());
  buffer.put(contents);
}","/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private static void encodePiece(ByteBuffer buffer,PieceMessage msg){
  ByteBuffer contents=msg.getPieceContents();
  contents.rewind().limit(contents.capacity());
  buffer.putInt(9 + contents.capacity());
  buffer.put((byte)msg.getMessageType().getId());
  buffer.putInt(msg.getIndex());
  buffer.putInt(msg.getOffset());
  buffer.put(contents);
}",0.9938650306748468
5427,"/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private void encodeHandShakeEnd(ByteBuffer buffer,HandShakeEnd msg){
  buffer.put(msg.getPeerId());
}","/** 
 * Encodes the given message into the given <tt>buffer</tt>
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 */
private static void encodeHandShakeEnd(ByteBuffer buffer,HandShakeEnd msg){
  buffer.put(msg.getPeerId());
}",0.9894419306184012
5428,"/** 
 * Encodes the given message into the given <tt>buffer</tt> in the format specified in the BitTorrent protocol specification. <p> If this method throws a   {@link BufferOverflowException}, the actual amount of bytes written into the buffer is not determined.
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws NullPointerException if any of the arguments is <tt>null</tt>
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 * @throws IllegalArgumentException if <tt>msg</tt> is not a valid message
 */
public void encodeMessageToBuffer(ByteBuffer buffer,BitTorrentMessage msg){
switch (msg.getMessageType()) {
case KEEP_ALIVE:
    buffer.putInt(0);
  break;
case CHOKE:
case UNCHOKE:
case INTERESTED:
case UNINTERESTED:
buffer.putInt(1);
buffer.put((byte)msg.getMessageType().getId());
break;
case HANDSHAKE_START:
encodeHandShakeStart(buffer,(HandShakeStart)msg);
break;
case HANDSHAKE_END:
encodeHandShakeEnd(buffer,(HandShakeEnd)msg);
break;
case HAVE:
encodeHave(buffer,(HaveMessage)msg);
break;
case BITFIELD:
encodeBitField(buffer,(BitFieldMessage)msg);
break;
case REQUEST:
encodeRequest(buffer,(RequestMessage)msg);
break;
case PIECE:
encodePiece(buffer,(PieceMessage)msg);
break;
case CANCEL:
encodeCancel(buffer,(CancelMessage)msg);
break;
case PORT:
encodePort(buffer,(PortMessage)msg);
break;
default :
throw new IllegalArgumentException();
}
}","/** 
 * Encodes the given message into the given <tt>buffer</tt> in the format specified in the BitTorrent protocol specification. <p> If this method throws a   {@link BufferOverflowException}, the actual amount of bytes written into the buffer is not determined.
 * @param buffer Destination buffer
 * @param msg Message to encode
 * @throws NullPointerException if any of the arguments is <tt>null</tt>
 * @throws BufferOverflowException if there is not enough space to encodethe full message
 * @throws IllegalArgumentException if <tt>msg</tt> is not a valid message
 */
public static void encodeMessageToBuffer(ByteBuffer buffer,BitTorrentMessage msg){
switch (msg.getMessageType()) {
case KEEP_ALIVE:
    buffer.putInt(0);
  break;
case CHOKE:
case UNCHOKE:
case INTERESTED:
case UNINTERESTED:
buffer.putInt(1);
buffer.put((byte)msg.getMessageType().getId());
break;
case HANDSHAKE_START:
encodeHandShakeStart(buffer,(HandShakeStart)msg);
break;
case HANDSHAKE_END:
encodeHandShakeEnd(buffer,(HandShakeEnd)msg);
break;
case HAVE:
encodeHave(buffer,(HaveMessage)msg);
break;
case BITFIELD:
encodeBitField(buffer,(BitFieldMessage)msg);
break;
case REQUEST:
encodeRequest(buffer,(RequestMessage)msg);
break;
case PIECE:
encodePiece(buffer,(PieceMessage)msg);
break;
case CANCEL:
encodeCancel(buffer,(CancelMessage)msg);
break;
case PORT:
encodePort(buffer,(PortMessage)msg);
break;
default :
throw new IllegalArgumentException();
}
}",0.9975550122249388
5429,"/** 
 * Constructs this message with the given peer ID.
 * @param peerId Peer ID of this handshake
 * @throws NullPointerException if <tt>peerId</tt> is <tt>null</tt>
 * @throws IllegalArgumentException if <tt>peerId</tt> has a lengthdifferent than 20
 */
public HandShakeEnd(byte[] peerId){
  if (peerId.length != 20) {
    throw new IllegalArgumentException();
  }
  this.peerId=Arrays.copyOf(peerId,peerId.length);
}","/** 
 * Constructs this message with the given peer ID.
 * @param peerId Peer ID of this handshake
 * @throws NullPointerException if <tt>peerId</tt> is <tt>null</tt>
 * @throws IllegalArgumentException if <tt>peerId</tt> has a lengthdifferent than 20
 */
public HandShakeEnd(byte[] peerId){
  if (peerId.length != 20) {
    throw new IllegalArgumentException();
  }
  this.peerId=Arrays.copyOf(peerId,peerId.length);
  strPeerId=new String(peerId,Charset.forName(""String_Node_Str""));
}",0.9259668508287292
5430,"/** 
 * Creates a new <tt>TorrentInfoSection</tt> object based on the information contained on the passed <tt>value</tt> argument
 * @param value A bencode value containing the info section
 * @return A new <tt>TorrentInfoSection</tt> that represents the<tt>value</tt> parameter
 * @throws NullPointerException if <tt>value</tt> is <tt>null</tt>
 * @throws IllegalArgumentException if <tt>value</tt> is not a bencodedictionary that holds the information in a torrent info section
 */
public static TorrentInfoSection fromValue(Value<?> value){
  if (value == null) {
    throw new NullPointerException();
  }
  try {
    long pieceLength=((IntegerValue)Bencode.getChildValue(value,""String_Node_Str"")).getValue().longValue();
    IntegerValue privv=(IntegerValue)Bencode.getChildValue(value,""String_Node_Str"");
    boolean priv=privv == null ? false : (privv.getValue().longValue() == 1L);
    StringValue piecesv=(StringValue)Bencode.getChildValue(value,""String_Node_Str"");
    byte[] piecesa=piecesv.getValue();
    if (piecesa.length % 20 != 0) {
      throw new IllegalArgumentException();
    }
    List<Sha1Hash> pieceHashes=new ArrayList<Sha1Hash>();
    for (int i=0; i < piecesa.length; i+=20) {
      byte[] hashbytes=new byte[20];
      for (int j=0; j < 20; j++) {
        hashbytes[j]=piecesa[i + j];
      }
      pieceHashes.add(new Sha1Hash(hashbytes));
    }
    String baseDir;
    List<TorrentFileInfo> files=new ArrayList<TorrentFileInfo>();
    ListValue filesv=(ListValue)Bencode.getChildValue(value,""String_Node_Str"");
    if (filesv == null) {
      baseDir=""String_Node_Str"";
      long length=((IntegerValue)Bencode.getChildValue(value,""String_Node_Str"")).getValue().longValue();
      String fname=((StringValue)Bencode.getChildValue(value,""String_Node_Str"")).getStringValue();
      TorrentFileInfo file=new TorrentFileInfo(length,Arrays.asList(fname));
      files.add(file);
    }
 else {
      baseDir=((StringValue)Bencode.getChildValue(value,""String_Node_Str"")).getStringValue();
      List<Value<?>> filesvl=filesv.getValue();
      for (      Value<?> val : filesvl) {
        DictionaryValue dval=(DictionaryValue)val;
        long length=((IntegerValue)Bencode.getChildValue(dval,""String_Node_Str"")).getValue().longValue();
        ListValue pathv=(ListValue)Bencode.getChildValue(dval,""String_Node_Str"");
        List<String> path=new ArrayList<String>();
        for (        Value<?> pathpiece : pathv.getValue()) {
          StringValue pps=(StringValue)pathpiece;
          path.add(pps.getStringValue());
        }
        files.add(new TorrentFileInfo(length,path));
      }
    }
    Sha1Hash hash=Sha1Hash.forValue(value);
    return new TorrentInfoSection(pieceLength,pieceHashes,priv,baseDir,files,hash);
  }
 catch (  Exception e) {
    if (e instanceof IllegalArgumentException) {
      throw ((IllegalArgumentException)e);
    }
 else {
      throw new IllegalArgumentException(e);
    }
  }
}","/** 
 * Creates a new <tt>TorrentInfoSection</tt> object based on the information contained on the passed <tt>value</tt> argument
 * @param value A bencode value containing the info section
 * @return A new <tt>TorrentInfoSection</tt> that represents the<tt>value</tt> parameter
 * @throws NullPointerException if <tt>value</tt> is <tt>null</tt>
 * @throws IllegalArgumentException if <tt>value</tt> is not a bencodedictionary that holds the information in a torrent info section
 */
public static TorrentInfoSection fromValue(Value<?> value){
  if (value == null) {
    throw new NullPointerException();
  }
  try {
    long pieceLength=((IntegerValue)Bencode.getChildValue(value,""String_Node_Str"")).getValue().longValue();
    IntegerValue privv=(IntegerValue)Bencode.getChildValue(value,""String_Node_Str"");
    boolean priv=privv == null ? false : (privv.getValue().longValue() == 1L);
    StringValue piecesv=(StringValue)Bencode.getChildValue(value,""String_Node_Str"");
    byte[] piecesa=piecesv.getValue();
    if (piecesa.length % 20 != 0) {
      throw new IllegalArgumentException();
    }
    List<Sha1Hash> pieceHashes=new ArrayList<Sha1Hash>();
    for (int i=0; i < piecesa.length; i+=20) {
      byte[] hashbytes=new byte[20];
      for (int j=0; j < 20; j++) {
        hashbytes[j]=piecesa[i + j];
      }
      pieceHashes.add(new Sha1Hash(hashbytes));
    }
    String name=((StringValue)Bencode.getChildValue(value,""String_Node_Str"")).getStringValue();
    String baseDir;
    List<TorrentFileInfo> files=new ArrayList<TorrentFileInfo>();
    ListValue filesv=(ListValue)Bencode.getChildValue(value,""String_Node_Str"");
    if (filesv == null) {
      baseDir=""String_Node_Str"";
      long length=((IntegerValue)Bencode.getChildValue(value,""String_Node_Str"")).getValue().longValue();
      String fname=((StringValue)Bencode.getChildValue(value,""String_Node_Str"")).getStringValue();
      TorrentFileInfo file=new TorrentFileInfo(length,Arrays.asList(fname));
      files.add(file);
    }
 else {
      baseDir=((StringValue)Bencode.getChildValue(value,""String_Node_Str"")).getStringValue();
      List<Value<?>> filesvl=filesv.getValue();
      for (      Value<?> val : filesvl) {
        DictionaryValue dval=(DictionaryValue)val;
        long length=((IntegerValue)Bencode.getChildValue(dval,""String_Node_Str"")).getValue().longValue();
        ListValue pathv=(ListValue)Bencode.getChildValue(dval,""String_Node_Str"");
        List<String> path=new ArrayList<String>();
        for (        Value<?> pathpiece : pathv.getValue()) {
          StringValue pps=(StringValue)pathpiece;
          path.add(pps.getStringValue());
        }
        files.add(new TorrentFileInfo(length,path));
      }
    }
    Sha1Hash hash=Sha1Hash.forValue(value);
    return new TorrentInfoSection(pieceLength,pieceHashes,priv,baseDir,files,hash,name);
  }
 catch (  Exception e) {
    if (e instanceof IllegalArgumentException) {
      throw ((IllegalArgumentException)e);
    }
 else {
      throw new IllegalArgumentException(e);
    }
  }
}",0.9831301152497076
5431,"/** 
 * Constructs this object using every piece of information needed.
 * @param pieceLength Nominal length of every piece
 * @param pieceHashes List of SHA-1 hashes of all pieces
 * @param priv Whether this is a private torrent
 * @param baseDir The advised base directory name
 * @param files List of file information
 * @param hash SHA-1 hash of the info section
 * @throws NullPointerException if some argument is <tt>null</tt> orcontains a <tt>null</tt>
 * @throws IllegalArgumentException if <tt>pieceLength</tt> is negative
 */
protected TorrentInfoSection(long pieceLength,List<Sha1Hash> pieceHashes,boolean priv,String baseDir,List<TorrentFileInfo> files,Sha1Hash hash){
  if (baseDir == null | hash == null | pieceHashes.contains(null) | files.contains(null)) {
    throw new NullPointerException();
  }
  if (pieceLength < 0) {
    throw new IllegalArgumentException();
  }
  this.pieceLength=pieceLength;
  this.priv=priv;
  this.baseDir=baseDir;
  this.hash=hash;
  this.pieceHashes=Collections.unmodifiableList(new ArrayList<Sha1Hash>(pieceHashes));
  this.files=Collections.unmodifiableList(new ArrayList<TorrentFileInfo>(files));
}","/** 
 * Constructs this object using every piece of information needed.
 * @param pieceLength Nominal length of every piece
 * @param pieceHashes List of SHA-1 hashes of all pieces
 * @param priv Whether this is a private torrent
 * @param baseDir The advised base directory name
 * @param files List of file information
 * @param hash SHA-1 hash of the info section
 * @throws NullPointerException if some argument is <tt>null</tt> orcontains a <tt>null</tt>
 * @throws IllegalArgumentException if <tt>pieceLength</tt> is negative
 */
private TorrentInfoSection(long pieceLength,List<Sha1Hash> pieceHashes,boolean priv,String baseDir,List<TorrentFileInfo> files,Sha1Hash hash,String name){
  if (baseDir == null | hash == null | name == null | pieceHashes.contains(null) | files.contains(null)) {
    throw new NullPointerException();
  }
  if (pieceLength < 0) {
    throw new IllegalArgumentException();
  }
  this.pieceLength=pieceLength;
  this.priv=priv;
  this.baseDir=baseDir;
  this.hash=hash;
  this.pieceHashes=Collections.unmodifiableList(new ArrayList<Sha1Hash>(pieceHashes));
  this.files=Collections.unmodifiableList(new ArrayList<TorrentFileInfo>(files));
  this.name=name;
}",0.9756306113723814
5432,"/** 
 * Checks if this object is equal to the given <tt>obj</tt>. <p> This object is only equal to a <tt>TorrentInfoSection</tt> object that holds the same information and was created using a bencode value equivalent to the bencode value that created this object.
 */
@Override public boolean equals(Object obj){
  if (!(obj instanceof TorrentInfoSection)) {
    return false;
  }
  TorrentInfoSection tis=(TorrentInfoSection)obj;
  return hash.equals(tis.hash) && pieceLength == tis.pieceLength && priv == tis.priv && pieceHashes.equals(tis.pieceHashes) && baseDir.equals(tis.baseDir) && files.equals(tis.files);
}","/** 
 * Checks if this object is equal to the given <tt>obj</tt>. <p> This object is only equal to a <tt>TorrentInfoSection</tt> object that holds the same information and was created using a bencode value equivalent to the bencode value that created this object.
 */
@Override public boolean equals(Object obj){
  if (!(obj instanceof TorrentInfoSection)) {
    return false;
  }
  TorrentInfoSection tis=(TorrentInfoSection)obj;
  return hash.equals(tis.hash) && name.equals(tis.name) && pieceLength == tis.pieceLength && priv == tis.priv && pieceHashes.equals(tis.pieceHashes) && baseDir.equals(tis.baseDir) && files.equals(tis.files);
}",0.9800796812749004
5433,"/** 
 * Returns a tracker that sends its request to the specified URLs in the torrent. <p> Whether the returned object uses the <tt>announce</tt> or the <tt>announce-list</tt> values depends on the object passed and the implementation availability. In general, the best possible method is chosen for each torrent.
 * @param torrent Torrent meta-info used to build the tracker
 * @return A tracker that announces to the corresponding URL
 * @throws MalformedURLException if the URL or URLs used are not valid
 */
public static Tracker forTorrent(TorrentMetaInfo torrent) throws MalformedURLException {
  return getSingleTracker(torrent.getAnnounce());
}","/** 
 * Returns a tracker that sends its request to the specified URLs in the torrent. <p> Whether the returned object uses the <tt>announce</tt> or the <tt>announce-list</tt> values depends on the object passed and the implementation availability. In general, the best possible method is chosen for each torrent.
 * @param torrent Torrent meta-info used to build the tracker
 * @return A tracker that announces to the corresponding URL
 * @throws MalformedURLException if the URL or URLs used are not valid
 */
public static Tracker forTorrent(TorrentMetaInfo torrent) throws MalformedURLException {
  if (torrent.getAnnounceList().isEmpty()) {
    return getSingleTracker(torrent.getAnnounce());
  }
 else {
    return getMultiTracker(torrent.getAnnounceList());
  }
}",0.9170182841068916
5434,"/** 
 * Constructs the query string of the announce request.
 * @param req Request to build the string from
 * @return The query string to send to the tracker
 */
protected static String getUrlParams(TrackerRequest req){
  try {
    StringBuilder sb=new StringBuilder(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(req.getInfoHash().toUrlEncodedString());
    sb.append(""String_Node_Str"");
    String peerstr=new String(req.getPeerId(),Charset.forName(""String_Node_Str""));
    sb.append(URLEncoder.encode(peerstr,""String_Node_Str""));
    sb.append(""String_Node_Str"");
    sb.append(req.getPort());
    sb.append(""String_Node_Str"");
    sb.append(req.getBytesUploaded());
    sb.append(""String_Node_Str"");
    sb.append(req.getBytesDownloaded());
    sb.append(""String_Node_Str"");
    sb.append(req.getBytesLeft());
    if (req.isCompact() != null) {
      sb.append(""String_Node_Str"");
      sb.append(req.isCompact() ? ""String_Node_Str"" : ""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
    sb.append(req.getWantPeerId() ? ""String_Node_Str"" : ""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(req.getEvent().getEventString());
    if (req.getIp() != null) {
      sb.append(""String_Node_Str"");
      sb.append(req.getIp().getHostAddress());
    }
    sb.append(""String_Node_Str"");
    sb.append(req.getNumWant());
    if (req.getKey() != null) {
      sb.append(""String_Node_Str"");
      sb.append(req.getKey());
    }
    if (req.getKey() != null) {
      sb.append(""String_Node_Str"");
      String trstr=new String(req.getTrackerId(),Charset.forName(""String_Node_Str""));
      sb.append(URLEncoder.encode(trstr,""String_Node_Str""));
    }
    return sb.toString();
  }
 catch (  UnsupportedEncodingException e) {
    return null;
  }
}","/** 
 * Constructs the query string of the announce request.
 * @param req Request to build the string from
 * @return The query string to send to the tracker
 */
protected static String getUrlParams(TrackerRequest req){
  try {
    StringBuilder sb=new StringBuilder(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(req.getInfoHash().toUrlEncodedString());
    sb.append(""String_Node_Str"");
    String peerstr=new String(req.getPeerId(),Charset.forName(""String_Node_Str""));
    sb.append(URLEncoder.encode(peerstr,""String_Node_Str""));
    sb.append(""String_Node_Str"");
    sb.append(req.getPort());
    sb.append(""String_Node_Str"");
    sb.append(req.getBytesUploaded());
    sb.append(""String_Node_Str"");
    sb.append(req.getBytesDownloaded());
    sb.append(""String_Node_Str"");
    sb.append(req.getBytesLeft());
    if (req.isCompact() != null) {
      sb.append(""String_Node_Str"");
      sb.append(req.isCompact() ? ""String_Node_Str"" : ""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
    sb.append(req.getWantPeerId() ? ""String_Node_Str"" : ""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(req.getEvent().getEventString());
    if (req.getIp() != null) {
      sb.append(""String_Node_Str"");
      sb.append(req.getIp().getHostAddress());
    }
    sb.append(""String_Node_Str"");
    sb.append(req.getNumWant());
    if (req.getKey() != null) {
      sb.append(""String_Node_Str"");
      sb.append(req.getKey());
    }
    if (req.getTrackerId() != null) {
      sb.append(""String_Node_Str"");
      String trstr=new String(req.getTrackerId(),Charset.forName(""String_Node_Str""));
      sb.append(URLEncoder.encode(trstr,""String_Node_Str""));
    }
    return sb.toString();
  }
 catch (  UnsupportedEncodingException e) {
    return null;
  }
}",0.9966499162479062
5435,"/** 
 * Returns a <tt>Tracker</tt> object that send its request to the given announce URLs, in order, until one of them is successfull. <p> The passed object is treated as the <tt>announce-list</tt> key of a  torrent, and behaves like it. <p> <i><b>Note:</b> This mehtod is currently unimplemented and returns <tt>null</tt>. A <tt>Tacker</tt> implementation that matches the requirements of this method is needed.</i>
 * @param announces List of announce URLs
 * @return A tracker which announces to the given URL list
 */
@SuppressWarnings(""String_Node_Str"") private static Tracker getMultiTracker(List<Set<String>> announces){
  return null;
}","/** 
 * Returns a <tt>Tracker</tt> object that send its request to the given announce URLs, in order, until one of them is successfull. <p> The passed object is treated as the <tt>announce-list</tt> key of a  torrent, and behaves like it.
 * @param announces List of announce URLs
 * @return A tracker which announces to the given URL list
 */
private static Tracker getMultiTracker(List<Set<String>> announces){
  return new MultiTracker(announces);
}",0.7766636280765725
5436,"/** 
 * @return the tracker ID set for this request
 */
public byte[] getTrackerId(){
  return Arrays.copyOf(trackerId,trackerId.length);
}","/** 
 * @return the tracker ID set for this request
 */
public byte[] getTrackerId(){
  return (trackerId == null) ? null : Arrays.copyOf(trackerId,trackerId.length);
}",0.9055374592833876
5437,"/** 
 * Creates a new response with the given arguments.
 * @param failed Whether the request failed
 * @param failureReason Failure reason
 * @param warning Warning message
 * @param interval Normal announce interval
 * @param minInterval Minimum announce interval
 * @param trackerId Tracker ID
 * @param complete Number of seeders
 * @param incomplete Number of leechers
 * @param peers List of peers
 */
private TrackerResponse(boolean failed,String failureReason,String warning,long interval,long minInterval,byte[] trackerId,long complete,long incomplete,List<PeerInfo> peers){
  this.failed=failed;
  if (failed) {
    if (failureReason == null) {
      throw new NullPointerException();
    }
    this.failureReason=failureReason;
    this.warning=(warning == null) ? ""String_Node_Str"" : warning;
    this.interval=0;
    this.minInterval=0;
    this.trackerId=null;
    this.complete=0;
    this.incomplete=0;
    this.peers=Collections.emptyList();
  }
 else {
    if (peers == null) {
      throw new NullPointerException();
    }
    this.failureReason=""String_Node_Str"";
    this.warning=(warning == null) ? ""String_Node_Str"" : warning;
    this.interval=interval;
    this.minInterval=minInterval;
    this.trackerId=Arrays.copyOf(trackerId,trackerId.length);
    this.complete=complete;
    this.incomplete=incomplete;
    this.peers=Collections.unmodifiableList(new ArrayList<PeerInfo>(peers));
  }
}","/** 
 * Creates a new response with the given arguments.
 * @param failed Whether the request failed
 * @param failureReason Failure reason
 * @param warning Warning message
 * @param interval Normal announce interval
 * @param minInterval Minimum announce interval
 * @param trackerId Tracker ID
 * @param complete Number of seeders
 * @param incomplete Number of leechers
 * @param peers List of peers
 */
private TrackerResponse(boolean failed,String failureReason,String warning,long interval,long minInterval,byte[] trackerId,long complete,long incomplete,List<PeerInfo> peers){
  this.failed=failed;
  if (failed) {
    if (failureReason == null) {
      throw new NullPointerException();
    }
    this.failureReason=failureReason;
    this.warning=(warning == null) ? ""String_Node_Str"" : warning;
    this.interval=0;
    this.minInterval=0;
    this.trackerId=null;
    this.complete=0;
    this.incomplete=0;
    this.peers=Collections.emptyList();
  }
 else {
    if (peers == null) {
      throw new NullPointerException();
    }
    this.failureReason=""String_Node_Str"";
    this.warning=(warning == null) ? ""String_Node_Str"" : warning;
    this.interval=interval;
    this.minInterval=minInterval;
    this.trackerId=trackerId == null ? null : Arrays.copyOf(trackerId,trackerId.length);
    this.complete=complete;
    this.incomplete=incomplete;
    this.peers=Collections.unmodifiableList(new ArrayList<PeerInfo>(peers));
  }
}",0.9905561385099684
5438,"@Override public void onEnable(){
  String dataStoreMethod;
  pluginDataPath=this.getDataFolder().getAbsolutePath() + File.separator;
  File dataPath=new File(pluginDataPath);
  if (!dataPath.exists()) {
    dataPath.mkdirs();
  }
  if (!HomePermissions.initialize(this))   return;
  disableEssentials();
  Settings.initialize(this);
  Settings.loadSettings();
  MultiHomeEconManager.initialize(this);
  dataStoreMethod=Settings.getDataStoreMethod();
  if (dataStoreMethod.compareToIgnoreCase(""String_Node_Str"") == 0) {
    this.homes=new HomeManagerFile(this);
    this.invites=new InviteManagerFile(this);
    this.warmups=new WarmUpManagerFile(this);
    this.cooldowns=new CoolDownManagerFile(this);
  }
 else   if (dataStoreMethod.compareToIgnoreCase(""String_Node_Str"") == 0) {
    this.homes=new HomeManagerMySQL(this);
    this.invites=new InviteManagerMySQL(this);
    this.warmups=new WarmUpManagerMySQL(this);
    this.cooldowns=new CoolDownManagerMySQL(this);
  }
 else {
    this.homes=new HomeManagerFile(this);
    this.invites=new InviteManagerFile(this);
    this.warmups=new WarmUpManagerFile(this);
    this.cooldowns=new CoolDownManagerFile(this);
  }
  setupCommands();
  registerEvents();
  Messaging.logInfo(""String_Node_Str"" + this.getDescription().getVersion() + ""String_Node_Str"",this);
}","@Override public void onEnable(){
  String dataStoreMethod;
  pluginDataPath=this.getDataFolder().getAbsolutePath() + File.separator;
  File dataPath=new File(pluginDataPath);
  if (!dataPath.exists()) {
    dataPath.mkdirs();
  }
  if (!HomePermissions.initialize(this))   return;
  disableEssentials();
  Settings.initialize(this);
  Settings.loadSettings();
  MultiHomeEconManager.initialize(this);
  dataStoreMethod=Settings.getDataStoreMethod();
  if (dataStoreMethod.compareToIgnoreCase(""String_Node_Str"") == 0) {
    this.homes=new HomeManagerFile(this);
    this.invites=new InviteManagerFile(this);
    this.warmups=new WarmUpManagerFile(this);
    this.cooldowns=new CoolDownManagerFile(this);
    Messaging.logInfo(""String_Node_Str"",this);
  }
 else   if (dataStoreMethod.compareToIgnoreCase(""String_Node_Str"") == 0) {
    this.homes=new HomeManagerMySQL(this);
    this.invites=new InviteManagerMySQL(this);
    this.warmups=new WarmUpManagerMySQL(this);
    this.cooldowns=new CoolDownManagerMySQL(this);
    Messaging.logInfo(""String_Node_Str"",this);
  }
 else {
    this.homes=new HomeManagerFile(this);
    this.invites=new InviteManagerFile(this);
    this.warmups=new WarmUpManagerFile(this);
    this.cooldowns=new CoolDownManagerFile(this);
    Messaging.logInfo(""String_Node_Str"",this);
  }
  setupCommands();
  registerEvents();
  Messaging.logInfo(""String_Node_Str"" + this.getDescription().getVersion() + ""String_Node_Str"",this);
}",0.9143476689555476
5439,"@Override public void addHome(String player,String name,Location location){
  ArrayList<HomeEntry> homes;
  if (this.HomeEntrys.containsKey(player.toLowerCase())) {
    homes=this.HomeEntrys.get(player.toLowerCase());
  }
 else {
    homes=new ArrayList<HomeEntry>();
  }
  boolean homeSet=false;
  for (int index=0; index < homes.size(); index++) {
    HomeEntry thisHome=homes.get(index);
    if (thisHome.getHomeName().compareToIgnoreCase(name) == 0) {
      thisHome.setHomeLocation(location);
      homes.set(index,thisHome);
    }
  }
  if (!homeSet) {
    HomeEntry home=new HomeEntry(player,name.toLowerCase(),location);
    homes.add(home);
  }
  this.HomeEntrys.remove(player.toLowerCase());
  this.HomeEntrys.put(player.toLowerCase(),homes);
  this.saveHomes();
}","@Override public void addHome(String player,String name,Location location){
  ArrayList<HomeEntry> homes;
  if (this.HomeEntrys.containsKey(player.toLowerCase())) {
    homes=this.HomeEntrys.get(player.toLowerCase());
  }
 else {
    homes=new ArrayList<HomeEntry>();
  }
  boolean homeSet=false;
  for (int index=0; index < homes.size(); index++) {
    HomeEntry thisHome=homes.get(index);
    if (thisHome.getHomeName().compareToIgnoreCase(name) == 0) {
      thisHome.setHomeLocation(location);
      homes.set(index,thisHome);
      homeSet=true;
    }
  }
  if (!homeSet) {
    HomeEntry home=new HomeEntry(player,name.toLowerCase(),location);
    homes.add(home);
  }
  this.HomeEntrys.remove(player.toLowerCase());
  this.HomeEntrys.put(player.toLowerCase(),homes);
  this.saveHomes();
}",0.9872448979591836
5440,"@Override public void addHome(String player,String name,Location location){
  Connection connection=null;
  PreparedStatement statement=null;
  try {
    connection=DriverManager.getConnection(url,user,password);
    if (!connection.isValid(100)) {
      throw new SQLException();
    }
    statement=connection.prepareStatement(""String_Node_Str"");
    statement.setString(1,player.toLowerCase());
    statement.setString(2,name.toLowerCase());
    statement.setString(3,location.getWorld().getName());
    statement.setDouble(4,location.getX());
    statement.setDouble(5,location.getY());
    statement.setDouble(6,location.getZ());
    statement.setFloat(7,location.getPitch());
    statement.setFloat(8,location.getYaw());
    statement.execute();
  }
 catch (  SQLException e) {
    Messaging.logSevere(""String_Node_Str"",this.plugin);
    e.printStackTrace();
  }
 finally {
    if (statement != null) {
      try {
        statement.close();
      }
 catch (      SQLException ex) {
      }
    }
    if (connection != null) {
      try {
        connection.close();
      }
 catch (      SQLException ex) {
      }
    }
  }
}","@Override public void addHome(String player,String name,Location location){
  Connection connection=null;
  PreparedStatement statement=null;
  ResultSet resultSet=null;
  boolean exists=false;
  try {
    connection=DriverManager.getConnection(url,user,password);
    if (!connection.isValid(100)) {
      throw new SQLException();
    }
    statement=connection.prepareStatement(""String_Node_Str"");
    statement.setString(1,player.toLowerCase());
    statement.setString(2,name.toLowerCase());
    resultSet=statement.executeQuery();
    if (resultSet.first()) {
      exists=resultSet.getInt(1) > 0;
    }
    if (exists) {
      statement=connection.prepareStatement(""String_Node_Str"");
      statement.setString(1,location.getWorld().getName());
      statement.setDouble(2,location.getX());
      statement.setDouble(3,location.getY());
      statement.setDouble(4,location.getZ());
      statement.setFloat(5,location.getPitch());
      statement.setFloat(6,location.getYaw());
      statement.setString(7,player.toLowerCase());
      statement.setString(8,name.toLowerCase());
      statement.execute();
    }
 else {
      statement=connection.prepareStatement(""String_Node_Str"");
      statement.setString(1,player.toLowerCase());
      statement.setString(2,name.toLowerCase());
      statement.setString(3,location.getWorld().getName());
      statement.setDouble(4,location.getX());
      statement.setDouble(5,location.getY());
      statement.setDouble(6,location.getZ());
      statement.setFloat(7,location.getPitch());
      statement.setFloat(8,location.getYaw());
      statement.execute();
    }
  }
 catch (  SQLException e) {
    Messaging.logSevere(""String_Node_Str"",this.plugin);
    e.printStackTrace();
  }
 finally {
    if (statement != null) {
      try {
        statement.close();
      }
 catch (      SQLException ex) {
      }
    }
    if (connection != null) {
      try {
        connection.close();
      }
 catch (      SQLException ex) {
      }
    }
  }
}",0.7113665389527458
5441,"public void setHomeLocation(Location homeLocation){
  this.homeLocation=homeLocation;
}","public void setHomeLocation(Location location){
  this.setWorld(location.getWorld().getName());
  this.setX(location.getX());
  this.setY(location.getY());
  this.setZ(location.getZ());
  this.setPitch(location.getPitch());
  this.setYaw(location.getYaw());
}",0.2427745664739884
5442,"public HomeLocation(String homeName,Location homeLocation){
  this.homeLocation=homeLocation;
  this.homeName=homeName;
}","public HomeLocation(String homeName,Location location){
  this.setHomeName(homeName);
  this.setWorld(location.getWorld().getName());
  this.setX(location.getX());
  this.setY(location.getY());
  this.setZ(location.getZ());
  this.setPitch(location.getPitch());
  this.setYaw(location.getYaw());
}",0.3110047846889952
5443,"public Location getHomeLocation(){
  return homeLocation;
}","public Location getHomeLocation(Server server){
  return new Location(server.getWorld(this.world),this.X,this.Y,this.Z,this.yaw,this.pitch);
}",0.5572139303482587
5444,"public Location getPlayerHomeLocation(Player player,String name){
  if (!homeLocations.containsKey(player.getName())) {
    return null;
  }
  ArrayList<HomeLocation> thisLocationList=homeLocations.get(player.getName());
  for (  HomeLocation thisLocation : thisLocationList) {
    if (thisLocation.getHomeName().compareToIgnoreCase(name) == 0) {
      return thisLocation.getHomeLocation();
    }
  }
  return null;
}","public Location getPlayerHomeLocation(Player player,String name){
  if (!homeLocations.containsKey(player.getName())) {
    return null;
  }
  ArrayList<HomeLocation> thisLocationList=homeLocations.get(player.getName());
  for (  HomeLocation thisLocation : thisLocationList) {
    if (thisLocation.getHomeName().compareToIgnoreCase(name) == 0) {
      return thisLocation.getHomeLocation(getServer());
    }
  }
  return null;
}",0.987012987012987
5445,"public void loadHomes(){
  File file=new File(homesPath);
  if (!(file.exists())) {
    file.mkdir();
  }
  file=new File(homesPath + homesFile);
  if (!file.exists()) {
    try {
      FileWriter fstream=new FileWriter(homesPath + homesFile);
      BufferedWriter out=new BufferedWriter(fstream);
      out.write(""String_Node_Str"");
      out.write(""String_Node_Str"");
      out.close();
    }
 catch (    Exception e) {
      log.warning(pdfFile.getName() + ""String_Node_Str"");
      this.getServer().getPluginManager().disablePlugin(this);
    }
  }
  try {
    FileReader fstream=new FileReader(homesPath + homesFile);
    BufferedReader reader=new BufferedReader(fstream);
    String line=reader.readLine().trim();
    while (line != null) {
      if (!line.startsWith(""String_Node_Str"")) {
        String[] values=line.split(""String_Node_Str"");
        double X=0, Y=0, Z=0;
        float pitch=0, yaw=0;
        World world=null;
        String name=""String_Node_Str"";
        try {
          if (values.length == 7) {
            X=Double.parseDouble(values[1]);
            Y=Double.parseDouble(values[2]);
            Z=Double.parseDouble(values[3]);
            pitch=Float.parseFloat(values[4]);
            yaw=Float.parseFloat(values[5]);
            world=getServer().getWorld(values[6]);
          }
 else           if (values.length == 8) {
            X=Double.parseDouble(values[1]);
            Y=Double.parseDouble(values[2]);
            Z=Double.parseDouble(values[3]);
            pitch=Float.parseFloat(values[4]);
            yaw=Float.parseFloat(values[5]);
            world=getServer().getWorld(values[6]);
            name=values[7];
          }
          if (world != null) {
            ArrayList<HomeLocation> homeList;
            if (!homeLocations.containsKey(values[0])) {
              homeList=new ArrayList<HomeLocation>();
            }
 else {
              homeList=homeLocations.get(values[0]);
            }
            homeList.add(new HomeLocation(name,new Location(world,X,Y,Z,yaw,pitch)));
            homeLocations.put(values[0],homeList);
          }
        }
 catch (        Exception e) {
        }
      }
      line=reader.readLine();
    }
    reader.close();
  }
 catch (  Exception e) {
    log.severe(pdfFile.getName() + ""String_Node_Str"");
    this.getServer().getPluginManager().disablePlugin(this);
  }
}","public void loadHomes(){
  File file=new File(homesPath);
  if (!(file.exists())) {
    file.mkdir();
  }
  file=new File(homesPath + homesFile);
  if (!file.exists()) {
    try {
      FileWriter fstream=new FileWriter(homesPath + homesFile);
      BufferedWriter out=new BufferedWriter(fstream);
      out.write(""String_Node_Str"");
      out.write(""String_Node_Str"");
      out.close();
    }
 catch (    Exception e) {
      log.warning(pdfFile.getName() + ""String_Node_Str"");
      this.getServer().getPluginManager().disablePlugin(this);
    }
  }
  try {
    FileReader fstream=new FileReader(homesPath + homesFile);
    BufferedReader reader=new BufferedReader(fstream);
    String line=reader.readLine().trim();
    while (line != null) {
      if (!line.startsWith(""String_Node_Str"")) {
        String[] values=line.split(""String_Node_Str"");
        double X=0, Y=0, Z=0;
        float pitch=0, yaw=0;
        String world=""String_Node_Str"";
        String name=""String_Node_Str"";
        try {
          if (values.length == 7) {
            X=Double.parseDouble(values[1]);
            Y=Double.parseDouble(values[2]);
            Z=Double.parseDouble(values[3]);
            pitch=Float.parseFloat(values[4]);
            yaw=Float.parseFloat(values[5]);
            world=values[6];
          }
 else           if (values.length == 8) {
            X=Double.parseDouble(values[1]);
            Y=Double.parseDouble(values[2]);
            Z=Double.parseDouble(values[3]);
            pitch=Float.parseFloat(values[4]);
            yaw=Float.parseFloat(values[5]);
            world=values[6];
            name=values[7];
          }
          if (world != null) {
            ArrayList<HomeLocation> homeList;
            if (!homeLocations.containsKey(values[0])) {
              homeList=new ArrayList<HomeLocation>();
            }
 else {
              homeList=homeLocations.get(values[0]);
            }
            homeList.add(new HomeLocation(name,world,X,Y,Z,pitch,yaw));
            homeLocations.put(values[0],homeList);
          }
        }
 catch (        Exception e) {
          if (line != null) {
            log.warning(""String_Node_Str"" + line);
          }
        }
      }
      line=reader.readLine();
    }
    reader.close();
  }
 catch (  Exception e) {
    log.severe(pdfFile.getName() + ""String_Node_Str"");
    this.getServer().getPluginManager().disablePlugin(this);
  }
}",0.9592306084047668
5446,"public void saveHomes(){
  File file=new File(homesPath);
  if (!(file.exists())) {
    file.mkdir();
  }
  try {
    FileWriter fstream=new FileWriter(homesPath + homesFile);
    BufferedWriter writer=new BufferedWriter(fstream);
    writer.write(""String_Node_Str"");
    writer.newLine();
    writer.write(""String_Node_Str"");
    writer.newLine();
    writer.newLine();
    for (    Entry<String,ArrayList<HomeLocation>> entry : homeLocations.entrySet()) {
      for (      HomeLocation thisLocation : entry.getValue()) {
        Location loc=thisLocation.getHomeLocation();
        writer.write(entry.getKey() + ""String_Node_Str"" + loc.getX()+ ""String_Node_Str""+ loc.getBlockY()+ ""String_Node_Str""+ loc.getBlockZ()+ ""String_Node_Str""+ loc.getPitch()+ ""String_Node_Str""+ loc.getYaw()+ ""String_Node_Str""+ loc.getWorld().getName()+ ""String_Node_Str""+ thisLocation.getHomeName());
        writer.newLine();
      }
    }
    writer.close();
  }
 catch (  Exception e) {
    log.severe(pdfFile.getName() + ""String_Node_Str"");
    this.getServer().getPluginManager().disablePlugin(this);
  }
}","public void saveHomes(){
  File file=new File(homesPath);
  if (!(file.exists())) {
    file.mkdir();
  }
  try {
    FileWriter fstream=new FileWriter(homesPath + homesFile);
    BufferedWriter writer=new BufferedWriter(fstream);
    writer.write(""String_Node_Str"");
    writer.newLine();
    writer.write(""String_Node_Str"");
    writer.newLine();
    writer.newLine();
    for (    Entry<String,ArrayList<HomeLocation>> entry : homeLocations.entrySet()) {
      for (      HomeLocation thisLocation : entry.getValue()) {
        writer.write(entry.getKey() + ""String_Node_Str"" + thisLocation.getX()+ ""String_Node_Str""+ thisLocation.getY()+ ""String_Node_Str""+ thisLocation.getZ()+ ""String_Node_Str""+ thisLocation.getPitch()+ ""String_Node_Str""+ thisLocation.getYaw()+ ""String_Node_Str""+ thisLocation.getWorld()+ ""String_Node_Str""+ thisLocation.getHomeName());
        writer.newLine();
      }
    }
    writer.close();
  }
 catch (  Exception e) {
    log.severe(pdfFile.getName() + ""String_Node_Str"");
    e.printStackTrace();
  }
}",0.8817710786622703
5447,"@Override public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    return false;
  }
  Player player=(Player)sender;
  if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    Location loc=null;
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      loc=getPlayerHomeLocation(player,args[0]);
    }
 else {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      loc=getPlayerHomeLocation(player,""String_Node_Str"");
    }
    if (loc == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else {
      if (loc.getWorld().getName().equals(player.getWorld().getName())) {
        player.teleportTo(loc);
      }
 else {
        Location playerLoc=player.getLocation();
        player.teleportTo(new Location(loc.getWorld(),playerLoc.getX(),playerLoc.getY(),playerLoc.getZ(),playerLoc.getPitch(),playerLoc.getYaw()));
        player.teleportTo(loc);
      }
    }
    return true;
  }
 else   if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      setPlayerHomeLocation(player,args[0],player.getLocation());
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
      log.info(player.getName() + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
    }
 else {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      setPlayerHomeLocation(player,""String_Node_Str"",player.getLocation());
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      log.info(player.getName() + ""String_Node_Str"");
    }
    saveHomes();
    return true;
  }
 else   if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      if (deletePlayerHomeLocation(player,args[0])) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
        log.info(player.getName() + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
      }
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
    saveHomes();
    return true;
  }
 else   if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    ArrayList<HomeLocation> listHomeLocations;
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      listHomeLocations=listPlayerHomeLocations(args[0]);
      log.info(player.getName() + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
    }
 else {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      listHomeLocations=listPlayerHomeLocations(player.getName());
    }
    String userResponse=""String_Node_Str"";
    for (    HomeLocation thisLocation : listHomeLocations) {
      if (thisLocation.getHomeName().length() == 0) {
        userResponse=userResponse + ""String_Node_Str"";
      }
 else {
        userResponse=userResponse + ""String_Node_Str"" + thisLocation.getHomeName();
      }
    }
    if (!userResponse.isEmpty() && userResponse.length() > 2) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + userResponse.substring(2));
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
    return true;
  }
  return false;
}","@Override public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    return false;
  }
  Player player=(Player)sender;
  if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    Location loc=null;
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      loc=getPlayerHomeLocation(player,args[0]);
    }
 else {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      loc=getPlayerHomeLocation(player,""String_Node_Str"");
    }
    if (loc == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else {
      if (loc.getWorld().getName().equals(player.getWorld().getName())) {
        player.teleportTo(loc);
      }
 else {
        Location playerLoc=player.getLocation();
        player.teleportTo(new Location(loc.getWorld(),playerLoc.getX(),playerLoc.getY(),playerLoc.getZ(),playerLoc.getPitch(),playerLoc.getYaw()));
        player.teleportTo(loc);
      }
    }
    return true;
  }
 else   if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      setPlayerHomeLocation(player,args[0],player.getLocation());
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
      log.info(player.getName() + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
    }
 else {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      setPlayerHomeLocation(player,""String_Node_Str"",player.getLocation());
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      log.info(player.getName() + ""String_Node_Str"");
    }
    saveHomes();
    return true;
  }
 else   if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      if (deletePlayerHomeLocation(player,args[0])) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
        log.info(player.getName() + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
      }
 else {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      }
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
    saveHomes();
    return true;
  }
 else   if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    ArrayList<HomeLocation> listHomeLocations;
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      listHomeLocations=listPlayerHomeLocations(args[0]);
      log.info(player.getName() + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
    }
 else {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      listHomeLocations=listPlayerHomeLocations(player.getName());
    }
    String userResponse=""String_Node_Str"";
    for (    HomeLocation thisLocation : listHomeLocations) {
      if (thisLocation.getHomeName().length() == 0) {
        userResponse=userResponse + ""String_Node_Str"";
      }
 else {
        userResponse=userResponse + ""String_Node_Str"" + thisLocation.getHomeName();
      }
    }
    if (!userResponse.isEmpty() && userResponse.length() > 2) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + userResponse.substring(2));
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
    return true;
  }
  return false;
}",0.9888117830335648
5448,"@Override public void onEnable(){
  this.pdfFile=this.getDescription();
  this.homesPath=""String_Node_Str"" + File.separator + pdfFile.getName()+ File.separator;
  loadHomes();
  setupPermissions();
  log.info(pdfFile.getName() + ""String_Node_Str"" + pdfFile.getVersion()+ ""String_Node_Str"");
}","@Override public void onEnable(){
  this.pdfFile=this.getDescription();
  this.homesPath=this.getDataFolder().getAbsolutePath() + File.separator;
  setupHelp();
  loadHomes();
  setupPermissions();
  log.info(pdfFile.getName() + ""String_Node_Str"" + pdfFile.getVersion()+ ""String_Node_Str"");
}",0.3561643835616438
5449,"@Override public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    return false;
  }
  Player player=(Player)sender;
  if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    Location loc=null;
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      loc=getPlayerHomeLocation(player,args[0]);
    }
 else {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      loc=getPlayerHomeLocation(player,""String_Node_Str"");
    }
    if (loc == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else {
      if (loc.getWorld().getName().equals(player.getWorld().getName())) {
        player.teleportTo(loc);
      }
 else {
        Location playerLoc=player.getLocation();
        player.teleportTo(new Location(loc.getWorld(),playerLoc.getX(),playerLoc.getY(),playerLoc.getZ(),playerLoc.getPitch(),playerLoc.getYaw()));
        player.teleportTo(loc);
      }
    }
    return true;
  }
 else   if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      setPlayerHomeLocation(player,args[0],player.getLocation());
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
      log.info(player.getName() + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
    }
 else {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      setPlayerHomeLocation(player,""String_Node_Str"",player.getLocation());
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      log.info(player.getName() + ""String_Node_Str"");
    }
    saveHomes();
    return true;
  }
 else   if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      if (deletePlayerHomeLocation(player,args[0])) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
        log.info(player.getName() + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
      }
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
    saveHomes();
    return true;
  }
 else   if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    ArrayList<HomeLocation> listHomeLocations;
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      listHomeLocations=listPlayerHomeLocations(args[0]);
      log.info(player.getName() + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
    }
 else {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      listHomeLocations=listPlayerHomeLocations(player.getName());
    }
    String userResponse=""String_Node_Str"";
    for (    HomeLocation thisLocation : listHomeLocations) {
      if (thisLocation.getHomeName().length() == 0) {
        userResponse=userResponse + ""String_Node_Str"";
      }
 else {
        userResponse=userResponse + ""String_Node_Str"" + thisLocation.getHomeName();
      }
    }
    player.sendMessage(ChatColor.RED + ""String_Node_Str"" + userResponse.substring(2));
    return true;
  }
  return false;
}","@Override public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  if (!(sender instanceof Player)) {
    return false;
  }
  Player player=(Player)sender;
  if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    Location loc=null;
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      loc=getPlayerHomeLocation(player,args[0]);
    }
 else {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      loc=getPlayerHomeLocation(player,""String_Node_Str"");
    }
    if (loc == null) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
 else {
      if (loc.getWorld().getName().equals(player.getWorld().getName())) {
        player.teleportTo(loc);
      }
 else {
        Location playerLoc=player.getLocation();
        player.teleportTo(new Location(loc.getWorld(),playerLoc.getX(),playerLoc.getY(),playerLoc.getZ(),playerLoc.getPitch(),playerLoc.getYaw()));
        player.teleportTo(loc);
      }
    }
    return true;
  }
 else   if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      setPlayerHomeLocation(player,args[0],player.getLocation());
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
      log.info(player.getName() + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
    }
 else {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      setPlayerHomeLocation(player,""String_Node_Str"",player.getLocation());
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
      log.info(player.getName() + ""String_Node_Str"");
    }
    saveHomes();
    return true;
  }
 else   if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      if (deletePlayerHomeLocation(player,args[0])) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
        log.info(player.getName() + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
      }
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
    saveHomes();
    return true;
  }
 else   if (cmd.getName().compareToIgnoreCase(""String_Node_Str"") == 0) {
    ArrayList<HomeLocation> listHomeLocations;
    if (args.length > 0) {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      listHomeLocations=listPlayerHomeLocations(args[0]);
      log.info(player.getName() + ""String_Node_Str"" + args[0]+ ""String_Node_Str"");
    }
 else {
      if (!this.Permissions.has(player,""String_Node_Str""))       return true;
      listHomeLocations=listPlayerHomeLocations(player.getName());
    }
    String userResponse=""String_Node_Str"";
    for (    HomeLocation thisLocation : listHomeLocations) {
      if (thisLocation.getHomeName().length() == 0) {
        userResponse=userResponse + ""String_Node_Str"";
      }
 else {
        userResponse=userResponse + ""String_Node_Str"" + thisLocation.getHomeName();
      }
    }
    if (!userResponse.isEmpty() && userResponse.length() > 2) {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"" + userResponse.substring(2));
    }
 else {
      player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
    return true;
  }
  return false;
}",0.9741038771031456
5450,"/** 
 * @see android.os.AsyncTask#doInBackground(Params[])
 */
@Override protected Boolean doInBackground(Void... params){
  try {
    Log.d(""String_Node_Str"");
    if (!mWidgetConfiguration.isDisplayable()) {
      Log.i(""String_Node_Str"");
      cancel(true);
    }
    mFlickrConnect=new FlickrConnect(mContext);
    if (!mFlickrConnect.isLoggedIn()) {
      Log.e(""String_Node_Str"");
      return false;
    }
    mRootViews.removeAllViews(R.id.root);
    mRootViews.removeAllViews(R.id.root);
    mRootViews.addView(R.id.root,new RemoteViews(mContext.getPackageName(),R.layout.loading));
    pushUpdate();
    String userId=mFlickrConnect.getFlickrParameters().getNsid();
    if (userId != null) {
      Log.e(""String_Node_Str"");
      return false;
    }
    FlickrApiResult flickrApiResult=null;
switch (mWidgetConfiguration.getContent()) {
case userComments:
      Log.d(""String_Node_Str"");
    flickrApiResult=mFlickrConnect.getActivityUserComments(userId,String.valueOf(mWidgetConfiguration.getMaxItems()),""String_Node_Str"");
  break;
case userPhotos:
Log.d(""String_Node_Str"");
flickrApiResult=mFlickrConnect.getActivityUserPhotos(userId,Constants.TIME_FRAME,String.valueOf(mWidgetConfiguration.getMaxItems()),""String_Node_Str"");
break;
}
if (flickrApiResult == null) {
Log.e(""String_Node_Str"");
return false;
}
Log.i(""String_Node_Str"" + flickrApiResult.getItems().getItems().size() + ""String_Node_Str"");
if (flickrApiResult.getItems().getItems().isEmpty()) {
mRootViews.addView(R.id.root,new RemoteViews(mContext.getPackageName(),R.layout.nothing));
pushUpdate();
return true;
}
for (Item item : flickrApiResult.getItems().getItems()) {
RemoteViews itemRemoteViews=null;
Log.d(""String_Node_Str"" + item.getType());
switch (item.getType()) {
case photo:
itemRemoteViews=new RemoteViews(mContext.getPackageName(),R.layout.item_photo);
Photo photo=mFlickrConnect.getPhotoInfo(item.getId()).getPhoto();
if (photo == null) {
Log.e(""String_Node_Str"" + item.getId());
continue;
}
try {
Bitmap bitmap=photo.getBitmap(Photo.Size.SMALLSQUARE);
if (bitmap == null) {
Log.e(""String_Node_Str"" + item.getId());
continue;
}
itemRemoteViews.setImageViewBitmap(R.id.photoBitmap,bitmap);
if (item.getTitle().getContent() == null) {
Log.e(""String_Node_Str"");
}
 else {
itemRemoteViews.setTextViewText(R.id.photoText,item.getTitle().getContent());
}
}
 catch (Exception e) {
Log.e(e.getMessage(),e);
itemRemoteViews.setTextViewText(R.id.photoText,e.getMessage() == null ? ""String_Node_Str"" : e.getMessage());
}
for (Event event : item.getActivity().getEvents()) {
RemoteViews eventRemoteViews=new RemoteViews(mContext.getPackageName(),R.layout.event_photo);
Log.d(""String_Node_Str"" + event.getType());
switch (event.getType()) {
case added_to_gallery:
eventRemoteViews.setImageViewResource(R.id.event_photo_icon,R.drawable.expo);
Spanned txt=Html.fromHtml(getString(R.string.added_to_gallery,event.getUsername()),getHtmlImageGetter(),null);
if (txt == null) {
Log.e(""String_Node_Str"" + item.getId());
continue;
}
eventRemoteViews.setTextViewText(R.id.event_photo_text,txt);
break;
case comment:
eventRemoteViews.setImageViewResource(R.id.event_photo_icon,R.drawable.comment);
txt=Html.fromHtml(getString(R.string.comment,event.getUsername(),event.getContent()),getHtmlImageGetter(),null);
if (txt == null) {
Log.e(""String_Node_Str"" + item.getId());
continue;
}
eventRemoteViews.setTextViewText(R.id.event_photo_text,txt);
break;
case fave:
eventRemoteViews.setImageViewResource(R.id.event_photo_icon,R.drawable.fave);
txt=Html.fromHtml(getString(R.string.fave,event.getUsername()),getHtmlImageGetter(),null);
if (txt == null) {
Log.e(""String_Node_Str"" + item.getId());
continue;
}
eventRemoteViews.setTextViewText(R.id.event_photo_text,txt);
break;
default :
Log.e(""String_Node_Str"" + event.getType());
eventRemoteViews.setTextViewText(R.id.event_photo_text,""String_Node_Str"" + event.getType());
}
itemRemoteViews.addView(R.id.events,eventRemoteViews);
}
break;
default :
Log.e(""String_Node_Str"" + item.getType());
}
if (itemRemoteViews != null) {
mRootViews.addView(R.id.root,itemRemoteViews);
}
}
Intent widgetIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(Constants.FLICKR_ACTIVITY_URL));
PendingIntent pendingIntent=PendingIntent.getActivity(mContext,0,widgetIntent,0);
mRootViews.setOnClickPendingIntent(R.id.root,pendingIntent);
pushUpdate();
Log.d(""String_Node_Str"");
return true;
}
 catch (Exception e) {
Log.e(""String_Node_Str"");
Log.e(e.getMessage(),e);
return false;
}
}","/** 
 * @see android.os.AsyncTask#doInBackground(Params[])
 */
@Override protected Boolean doInBackground(Void... params){
  try {
    Log.d(""String_Node_Str"");
    if (!mWidgetConfiguration.isDisplayable()) {
      Log.i(""String_Node_Str"");
      cancel(true);
    }
    mFlickrConnect=new FlickrConnect(mContext);
    if (!mFlickrConnect.isLoggedIn()) {
      Log.e(""String_Node_Str"");
      return false;
    }
    mRootViews.removeAllViews(R.id.root);
    mRootViews.addView(R.id.root,new RemoteViews(mContext.getPackageName(),R.layout.loading));
    pushUpdate();
    mRootViews.removeAllViews(R.id.root);
    String userId=mFlickrConnect.getFlickrParameters().getNsid();
    if (userId == null) {
      Log.e(""String_Node_Str"");
      return false;
    }
    FlickrApiResult flickrApiResult=null;
switch (mWidgetConfiguration.getContent()) {
case userComments:
      Log.d(""String_Node_Str"");
    flickrApiResult=mFlickrConnect.getActivityUserComments(userId,String.valueOf(mWidgetConfiguration.getMaxItems()),""String_Node_Str"");
  break;
case userPhotos:
Log.d(""String_Node_Str"");
flickrApiResult=mFlickrConnect.getActivityUserPhotos(userId,Constants.TIME_FRAME,String.valueOf(mWidgetConfiguration.getMaxItems()),""String_Node_Str"");
break;
}
if (flickrApiResult == null) {
Log.e(""String_Node_Str"");
return false;
}
Log.i(""String_Node_Str"" + flickrApiResult.getItems().getItems().size() + ""String_Node_Str"");
if (flickrApiResult.getItems().getItems().isEmpty()) {
mRootViews.addView(R.id.root,new RemoteViews(mContext.getPackageName(),R.layout.nothing));
pushUpdate();
return true;
}
for (Item item : flickrApiResult.getItems().getItems()) {
RemoteViews itemRemoteViews=null;
Log.d(""String_Node_Str"" + item.getType());
switch (item.getType()) {
case photo:
itemRemoteViews=new RemoteViews(mContext.getPackageName(),R.layout.item_photo);
Photo photo=mFlickrConnect.getPhotoInfo(item.getId()).getPhoto();
if (photo == null) {
Log.e(""String_Node_Str"" + item.getId());
continue;
}
try {
Bitmap bitmap=photo.getBitmap(Photo.Size.SMALLSQUARE);
if (bitmap == null) {
Log.e(""String_Node_Str"" + item.getId());
continue;
}
itemRemoteViews.setImageViewBitmap(R.id.photoBitmap,bitmap);
if (item.getTitle().getContent() == null) {
Log.e(""String_Node_Str"");
}
 else {
itemRemoteViews.setTextViewText(R.id.photoText,item.getTitle().getContent());
}
}
 catch (Exception e) {
Log.e(e.getMessage(),e);
itemRemoteViews.setTextViewText(R.id.photoText,e.getMessage() == null ? ""String_Node_Str"" : e.getMessage());
}
for (Event event : item.getActivity().getEvents()) {
RemoteViews eventRemoteViews=new RemoteViews(mContext.getPackageName(),R.layout.event_photo);
Log.d(""String_Node_Str"" + event.getType());
switch (event.getType()) {
case added_to_gallery:
eventRemoteViews.setImageViewResource(R.id.event_photo_icon,R.drawable.expo);
Spanned txt=Html.fromHtml(getString(R.string.added_to_gallery,event.getUsername()),getHtmlImageGetter(),null);
if (txt == null) {
Log.e(""String_Node_Str"" + item.getId());
continue;
}
eventRemoteViews.setTextViewText(R.id.event_photo_text,txt);
break;
case comment:
eventRemoteViews.setImageViewResource(R.id.event_photo_icon,R.drawable.comment);
txt=Html.fromHtml(getString(R.string.comment,event.getUsername(),event.getContent()),getHtmlImageGetter(),null);
if (txt == null) {
Log.e(""String_Node_Str"" + item.getId());
continue;
}
eventRemoteViews.setTextViewText(R.id.event_photo_text,txt);
break;
case fave:
eventRemoteViews.setImageViewResource(R.id.event_photo_icon,R.drawable.fave);
txt=Html.fromHtml(getString(R.string.fave,event.getUsername()),getHtmlImageGetter(),null);
if (txt == null) {
Log.e(""String_Node_Str"" + item.getId());
continue;
}
eventRemoteViews.setTextViewText(R.id.event_photo_text,txt);
break;
default :
Log.e(""String_Node_Str"" + event.getType());
eventRemoteViews.setTextViewText(R.id.event_photo_text,""String_Node_Str"" + event.getType());
}
itemRemoteViews.addView(R.id.events,eventRemoteViews);
}
break;
default :
Log.e(""String_Node_Str"" + item.getType());
}
if (itemRemoteViews != null) {
mRootViews.addView(R.id.root,itemRemoteViews);
}
}
Intent widgetIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(Constants.FLICKR_ACTIVITY_URL));
PendingIntent pendingIntent=PendingIntent.getActivity(mContext,0,widgetIntent,0);
mRootViews.setOnClickPendingIntent(R.id.root,pendingIntent);
pushUpdate();
Log.d(""String_Node_Str"");
return true;
}
 catch (Exception e) {
Log.e(""String_Node_Str"");
Log.e(e.getMessage(),e);
return false;
}
}",0.9903824647729814
5451,"/** 
 * @see android.app.Activity#onCreate(android.os.Bundle)
 */
@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Log.d(""String_Node_Str"");
  setResult(RESULT_CANCELED);
  mAppWidgetId=getIntent().getExtras().getInt(AppWidgetManager.EXTRA_APPWIDGET_ID,AppWidgetManager.INVALID_APPWIDGET_ID);
  Log.d(""String_Node_Str"" + mAppWidgetId);
  AuthenticateActivity.registerAppParameters(this,getString(R.string.api_key),getString(R.string.api_secret),getString(R.string.auth_url));
  RestClient.setAuth(this);
  mFlickrLibraryPrefs=getSharedPreferences(GlobalResources.PREFERENCES_ID,0);
  if (APICalls.authCheckToken()) {
    displayConfigureLayout();
  }
 else {
    setContentView(R.layout.connect);
  }
  Log.d(""String_Node_Str"");
}","/** 
 * @see android.app.Activity#onCreate(android.os.Bundle)
 */
@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Log.d(""String_Node_Str"");
  setResult(RESULT_CANCELED);
  mAppWidgetId=getIntent().getExtras().getInt(AppWidgetManager.EXTRA_APPWIDGET_ID,AppWidgetManager.INVALID_APPWIDGET_ID);
  if (mAppWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
    Log.e(""String_Node_Str"");
    finish();
    return;
  }
  Log.d(""String_Node_Str"" + mAppWidgetId);
  AuthenticateActivity.registerAppParameters(this,getString(R.string.api_key),getString(R.string.api_secret),getString(R.string.auth_url));
  RestClient.setAuth(this);
  mFlickrLibraryPrefs=getSharedPreferences(GlobalResources.PREFERENCES_ID,0);
  if (APICalls.authCheckToken()) {
    displayConfigureLayout();
  }
 else {
    setContentView(R.layout.connect);
  }
  Log.d(""String_Node_Str"");
}",0.9271758436944938
5452,"/** 
 * @param context
 * @param appWidgetId
 * @return
 */
public static WidgetConfiguration loadConfiguration(Context context,int appWidgetId){
  SharedPreferences widgetPrefs=context.getSharedPreferences(Constants.WIDGET_PREFS,0);
  WidgetConfiguration widgetConfiguration=new WidgetConfiguration();
  widgetConfiguration.setShowUserComments(widgetPrefs.getBoolean(Constants.WIDGET_SHOW_USERCOMMENTS,false));
  widgetConfiguration.setShowUserPhotos(widgetPrefs.getBoolean(Constants.WIDGET_SHOW_USERPHOTOS,false));
  return widgetConfiguration;
}","/** 
 * @param context
 * @param appWidgetId
 * @return
 */
public static WidgetConfiguration loadConfiguration(Context context,int appWidgetId){
  SharedPreferences widgetPrefs=context.getSharedPreferences(Constants.WIDGET_PREFS,0);
  WidgetConfiguration widgetConfiguration=new WidgetConfiguration();
  widgetConfiguration.setShowUserComments(widgetPrefs.getBoolean(Constants.WIDGET_SHOW_USERCOMMENTS + appWidgetId,false));
  widgetConfiguration.setShowUserPhotos(widgetPrefs.getBoolean(Constants.WIDGET_SHOW_USERPHOTOS + appWidgetId,false));
  return widgetConfiguration;
}",0.9750889679715302
5453,"public void onConfigurationDone(View view){
  WidgetConfiguration widgetConfiguration=generateWidgetConfiguration();
  saveConfiguration(this,mAppWidgetId,widgetConfiguration);
  Log.d(""String_Node_Str"");
  WidgetUpdateService.updateWidget(this,widgetConfiguration,mAppWidgetId);
  Intent resultValue=new Intent();
  resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,mAppWidgetId);
  setResult(RESULT_OK,resultValue);
  Log.d(""String_Node_Str"");
  finish();
}","public void onConfigurationDone(View view){
  WidgetConfiguration widgetConfiguration=generateWidgetConfiguration();
  saveConfiguration(this,mAppWidgetId,widgetConfiguration);
  Log.d(""String_Node_Str"" + mAppWidgetId);
  WidgetUpdateService.updateWidget(this,widgetConfiguration,mAppWidgetId);
  Intent resultValue=new Intent();
  resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,mAppWidgetId);
  setResult(RESULT_OK,resultValue);
  Log.d(""String_Node_Str"");
  finish();
}",0.9841605068637804
5454,"public void equip(Item item){
switch (item.glyph) {
case ')':
    unequip(weapon);
  weapon=item;
hp+=item.modHp;
attack+=item.modAttack;
defence+=item.modDefence;
item.equipped=true;
tell(AsciiPanel.white,""String_Node_Str"" + item.name);
break;
case ']':
unequip(armor);
armor=item;
tell(AsciiPanel.white,""String_Node_Str"" + item.name);
break;
default :
return;
}
hp+=item.modHp;
attack+=item.modAttack;
defence+=item.modDefence;
item.equipped=true;
}","public void equip(Item item){
switch (item.glyph) {
case ')':
    unequip(weapon);
  weapon=item;
hear(AsciiPanel.white,""String_Node_Str"" + item.name);
break;
case ']':
unequip(armor);
armor=item;
hear(AsciiPanel.white,""String_Node_Str"" + item.name);
break;
default :
return;
}
hp+=item.modHp;
attack+=item.modAttack;
defence+=item.modDefence;
item.equipped=true;
}",0.8774509803921569
5455,"public void unequip(Item item){
  if (item == null) {
    return;
  }
 else   if (weapon == item) {
    weapon=null;
    tell(AsciiPanel.white,""String_Node_Str"" + item.name);
  }
 else   if (armor == item) {
    armor=null;
    tell(AsciiPanel.white,""String_Node_Str"" + item.name);
  }
 else {
    return;
  }
  hp-=item.modHp;
  attack-=item.modAttack;
  defence-=item.modDefence;
  item.x=x;
  item.y=y;
  item.equipped=false;
}","public void unequip(Item item){
  if (item == null) {
    return;
  }
 else   if (weapon == item) {
    weapon=null;
    hear(AsciiPanel.white,""String_Node_Str"" + item.name);
  }
 else   if (armor == item) {
    armor=null;
    hear(AsciiPanel.white,""String_Node_Str"" + item.name);
  }
 else {
    return;
  }
  hp-=item.modHp;
  attack-=item.modAttack;
  defence-=item.modDefence;
  item.x=x;
  item.y=y;
  item.equipped=false;
}",0.9813953488372092
5456,"public void keyPressed(KeyEvent ke){
switch (stage) {
case start:
case win:
case lose:
    if (ke.getKeyChar() == ' ') {
      stage=play;
      reset();
    }
  break;
case help:
if (ke.getKeyChar() == ' ') {
  stage=play;
}
break;
case play:
boolean endTurn1=true;
boolean endTurn2=true;
switch (ke.getKeyChar()) {
case '?':
stage=help;
endTurn1=false;
break;
case '8':
case 'k':
target.moveBy(0,-1);
break;
case '2':
case 'j':
target.moveBy(0,1);
break;
case '4':
case 'h':
target.moveBy(-1,0);
break;
case '6':
case 'l':
target.moveBy(1,0);
break;
case '7':
case 'y':
target.moveBy(-1,-1);
break;
case '1':
case 'b':
target.moveBy(-1,1);
break;
case '9':
case 'u':
target.moveBy(1,-1);
break;
case '3':
case 'n':
target.moveBy(1,1);
break;
case '5':
case '.':
target.moveBy(0,0);
break;
case 'g':
case ',':
boolean found=false;
for (Item item : world.items) {
if (item.x == target.x && item.y == target.y && !item.equipped) {
target.equip(item);
found=true;
break;
}
}
if (!found) {
target.tell(AsciiPanel.white,""String_Node_Str"");
endTurn1=false;
}
break;
default :
endTurn1=false;
}
switch (ke.getKeyCode()) {
case KeyEvent.VK_UP:
target.moveBy(0,-1);
break;
case KeyEvent.VK_DOWN:
target.moveBy(0,1);
break;
case KeyEvent.VK_LEFT:
target.moveBy(-1,0);
break;
case KeyEvent.VK_RIGHT:
target.moveBy(1,0);
break;
default :
endTurn2=false;
}
if (endTurn1 || endTurn2) world.update();
break;
default :
stage=0;
break;
}
currentScreen();
}","public void keyPressed(KeyEvent ke){
switch (stage) {
case start:
case win:
case lose:
    if (ke.getKeyChar() == ' ') {
      stage=play;
      reset();
    }
  break;
case help:
if (ke.getKeyChar() == ' ') {
  stage=play;
}
break;
case play:
boolean endTurn1=true;
boolean endTurn2=true;
switch (ke.getKeyChar()) {
case '?':
stage=help;
endTurn1=false;
break;
case '8':
case 'k':
target.moveBy(0,-1);
break;
case '2':
case 'j':
target.moveBy(0,1);
break;
case '4':
case 'h':
target.moveBy(-1,0);
break;
case '6':
case 'l':
target.moveBy(1,0);
break;
case '7':
case 'y':
target.moveBy(-1,-1);
break;
case '1':
case 'b':
target.moveBy(-1,1);
break;
case '9':
case 'u':
target.moveBy(1,-1);
break;
case '3':
case 'n':
target.moveBy(1,1);
break;
case '5':
case '.':
target.moveBy(0,0);
break;
case 'g':
case ',':
boolean found=false;
for (Item item : world.items) {
if (item.x == target.x && item.y == target.y && !item.equipped) {
target.equip(item);
found=true;
break;
}
}
if (!found) {
target.hear(AsciiPanel.white,""String_Node_Str"");
endTurn1=false;
}
break;
default :
endTurn1=false;
}
switch (ke.getKeyCode()) {
case KeyEvent.VK_UP:
target.moveBy(0,-1);
break;
case KeyEvent.VK_DOWN:
target.moveBy(0,1);
break;
case KeyEvent.VK_LEFT:
target.moveBy(-1,0);
break;
case KeyEvent.VK_RIGHT:
target.moveBy(1,0);
break;
default :
endTurn2=false;
}
if (endTurn1 || endTurn2) world.update();
break;
default :
stage=0;
break;
}
currentScreen();
}",0.9972222222222222
5457,"private void writeMessages(){
  if (!target.messages.isEmpty()) {
    currentMessages=(ArrayList<String>)target.messages.clone();
    currentMessageColors=(ArrayList<Color>)target.messageColors.clone();
    target.messages.clear();
    target.messageColors.clear();
  }
  int startY=panel.getHeightInCharacters() - currentMessages.size() - 1;
  for (int i=0; i < currentMessages.size(); i++) {
    panel.writeCenter(currentMessages.get(i),startY + i,currentMessageColors.get(i));
  }
}","private void writeMessages(){
  if (!target.messages.isEmpty()) {
    currentMessages=(ArrayList<String>)target.messages.clone();
    currentMessageColors=(ArrayList<Color>)target.messageColors.clone();
    target.messages.clear();
    target.messageColors.clear();
  }
  int startY=panel.getHeightInCharacters() - currentMessages.size();
  for (int i=0; i < currentMessages.size(); i++) {
    panel.writeCenter(currentMessages.get(i),startY + i,currentMessageColors.get(i));
  }
}",0.9958592132505176
5458,"public void playScreen(){
  panel.clear();
  int viewWidth=80;
  int viewHeight=23;
  int vx=Math.max(0,Math.min(target.x - viewWidth / 2,world.width - viewWidth));
  int vy=Math.max(0,Math.min(target.y - viewHeight / 2,world.height - viewHeight));
  for (int x=vx; x < vx + viewWidth; x++) {
    for (int y=vy; y < vy + viewHeight; y++) {
      panel.write(world.getGlyph(x,y),x - vx,y - vy,world.getColor(x,y));
    }
  }
  Item itemHere=null;
  for (  Item item : world.items) {
    int cx=item.x - vx;
    int cy=item.y - vy;
    if (cx < 0 || cx >= viewWidth || cy < 0 || cy >= viewHeight)     continue;
    if (item.equipped)     continue;
    if (item.x == target.x && item.y == target.y)     itemHere=item;
    panel.write(item.glyph,cx,cy,item.color);
  }
  for (  Creature creature : world.creatures) {
    int cx=creature.x - vx;
    int cy=creature.y - vy;
    if (cx < 0 || cx >= viewWidth || cy < 0 || cy >= viewHeight)     continue;
    panel.write(creature.glyph,cx,cy,creature.color);
  }
  if (target.target != null) {
    infoPanel(target,1);
    infoPanel(target.target,-1);
  }
 else   if (itemHere != null) {
    infoPanel(target,1);
    infoPanel(target,itemHere,22);
  }
  writeMessages();
  panel.write(world.getName(target.x,target.y),71,panel.getHeightInCharacters() - 1);
  String status=""String_Node_Str"" + target.name + ""String_Node_Str""+ target.x+ ""String_Node_Str""+ target.y+ ""String_Node_Str"";
  if (target.weapon != null)   status+=""String_Node_Str"" + target.weapon.name;
  if (target.armor != null)   status+=""String_Node_Str"" + target.armor.name;
  panel.write(status,0,panel.getHeightInCharacters() - 1);
}","public void playScreen(){
  panel.clear();
  int viewWidth=80;
  int viewHeight=24;
  int vx=Math.max(0,Math.min(target.x - viewWidth / 2,world.width - viewWidth));
  int vy=Math.max(0,Math.min(target.y - viewHeight / 2,world.height - viewHeight));
  for (int x=vx; x < vx + viewWidth; x++) {
    for (int y=vy; y < vy + viewHeight; y++) {
      panel.write(world.getGlyph(x,y),x - vx,y - vy,world.getColor(x,y));
    }
  }
  Item itemHere=null;
  for (  Item item : world.items) {
    int cx=item.x - vx;
    int cy=item.y - vy;
    if (cx < 0 || cx >= viewWidth || cy < 0 || cy >= viewHeight)     continue;
    if (item.equipped)     continue;
    if (item.x == target.x && item.y == target.y)     itemHere=item;
    panel.write(item.glyph,cx,cy,item.color);
  }
  for (  Creature creature : world.creatures) {
    int cx=creature.x - vx;
    int cy=creature.y - vy;
    if (cx < 0 || cx >= viewWidth || cy < 0 || cy >= viewHeight)     continue;
    panel.write(creature.glyph,cx,cy,creature.color);
  }
  infoPanel(target,1);
  if (target.target != null) {
    infoPanel(target.target,-1);
  }
 else   if (itemHere != null) {
    infoPanel(target,1);
    infoPanel(target,itemHere,22);
  }
  writeMessages();
}",0.8326330532212886
5459,"private void infoPanel(Creature creature,Item item,int left){
  int panelWidth=20;
  if (left < 0)   left=panel.getWidthInCharacters() - panelWidth + left;
  int diffHp=0;
  int diffAtk=0;
  int diffDef=0;
  if (creature != null) {
    if (item.glyph == ')' && creature.weapon != null) {
      diffHp=item.modHp - creature.weapon.modHp;
      diffAtk=item.modAttack - creature.weapon.modAttack;
      diffDef=item.modDefence - creature.weapon.modDefence;
    }
 else     if (item.glyph == ']' && creature.armor != null) {
      diffHp=item.modHp - creature.armor.modHp;
      diffAtk=item.modAttack - creature.armor.modAttack;
      diffDef=item.modDefence - creature.armor.modDefence;
    }
 else {
      diffHp=item.modHp;
      diffAtk=item.modAttack;
      diffDef=item.modDefence;
    }
  }
  char up=(char)24;
  char down=(char)25;
  String diffHpStr=diffHp == 0 ? ""String_Node_Str"" : (diffHp > 0 ? ""String_Node_Str"" + up + diffHp : ""String_Node_Str"" + down + Math.abs(diffHp));
  String diffAtkStr=diffAtk == 0 ? ""String_Node_Str"" : (diffAtk > 0 ? ""String_Node_Str"" + up + diffAtk : ""String_Node_Str"" + down + Math.abs(diffAtk));
  String diffDefStr=diffDef == 0 ? ""String_Node_Str"" : (diffDef > 0 ? ""String_Node_Str"" + up + diffDef : ""String_Node_Str"" + down + Math.abs(diffDef));
  panel.write(pad(""String_Node_Str"" + item.name,panelWidth),left,1);
  panel.write(pad(""String_Node_Str"" + item.modHp + diffHpStr,panelWidth),left,2);
  panel.write(pad(""String_Node_Str"" + item.modAttack + diffAtkStr,panelWidth),left,3);
  panel.write(pad(""String_Node_Str"" + item.modDefence + diffDefStr,panelWidth),left,4);
}","private void infoPanel(Creature creature,Item item,int left){
  int panelWidth=20;
  if (left < 0)   left=panel.getWidthInCharacters() - panelWidth + left;
  int diffHp=0;
  int diffAtk=0;
  int diffDef=0;
  if (creature != null) {
    if (item.glyph == ')' && creature.weapon != null) {
      diffHp=item.modHp - creature.weapon.modHp;
      diffAtk=item.modAttack - creature.weapon.modAttack;
      diffDef=item.modDefence - creature.weapon.modDefence;
    }
 else     if (item.glyph == ']' && creature.armor != null) {
      diffHp=item.modHp - creature.armor.modHp;
      diffAtk=item.modAttack - creature.armor.modAttack;
      diffDef=item.modDefence - creature.armor.modDefence;
    }
 else {
      diffHp=item.modHp;
      diffAtk=item.modAttack;
      diffDef=item.modDefence;
    }
  }
  char up=(char)24;
  char down=(char)25;
  String diffHpStr=diffHp == 0 ? ""String_Node_Str"" : (diffHp > 0 ? ""String_Node_Str"" + up + diffHp : ""String_Node_Str"" + down + Math.abs(diffHp));
  String diffAtkStr=diffAtk == 0 ? ""String_Node_Str"" : (diffAtk > 0 ? ""String_Node_Str"" + up + diffAtk : ""String_Node_Str"" + down + Math.abs(diffAtk));
  String diffDefStr=diffDef == 0 ? ""String_Node_Str"" : (diffDef > 0 ? ""String_Node_Str"" + up + diffDef : ""String_Node_Str"" + down + Math.abs(diffDef));
  panel.write(pad(""String_Node_Str"" + item.name,panelWidth),left,1);
  panel.write(""String_Node_Str"" + item.modHp,left,2);
  panel.write(pad(diffHpStr,(panelWidth + left) - panel.getCursorX()),diffHp > 0 ? AsciiPanel.green : AsciiPanel.red);
  panel.write(""String_Node_Str"" + item.modAttack,left,3);
  panel.write(pad(diffAtkStr,(panelWidth + left) - panel.getCursorX()),diffAtk > 0 ? AsciiPanel.green : AsciiPanel.red);
  panel.write(""String_Node_Str"" + item.modDefence,left,4);
  panel.write(pad(diffDefStr,(panelWidth + left) - panel.getCursorX()),diffDef > 0 ? AsciiPanel.green : AsciiPanel.red);
}",0.8771029369831765
5460,"public void tellAll(Color color,String message){
  for (  Creature creature : creatures) {
    creature.tell(color,message);
  }
}","public void tellAll(Color color,String message){
  for (  Creature creature : creatures) {
    creature.hear(color,message);
  }
}",0.9769230769230768
5461,"/** 
 * Returns the readings count for a node.
 * @param node , a node .
 * @return the count of this node.
 */
public Long getNodeReadingsCount(final Node node){
  final Session session=getSessionFactory().getCurrentSession();
  final Criteria criteria=session.createCriteria(NodeReading.class);
  criteria.add(Restrictions.eq(""String_Node_Str"",node));
  criteria.setProjection(Projections.count(""String_Node_Str""));
  criteria.setMaxResults(1);
  return (Long)criteria.uniqueResult();
}","/** 
 * Returns the readings count for a node.
 * @param node , a node .
 * @return the count of this node.
 */
public Long getNodeReadingsCount(final Node node){
  final Session session=getSessionFactory().getCurrentSession();
  final Criteria criteria=session.createCriteria(NodeReading.class);
  criteria.add(Restrictions.eq(NODE,node));
  criteria.setProjection(Projections.count(NODE));
  criteria.setMaxResults(1);
  return (Long)criteria.uniqueResult();
}",0.96
5462,"/** 
 * Insert a links's reading from it's capabilities and make the appropriate relations such as Link-Reading , Capability-reading
 * @param sourceId , link's source id.
 * @param targetId , target's source id.
 * @param capabilityName , capability's id.
 * @param rssiValue , the RSSI value of the link.
 * @param readingValue , value of a sensor reading.
 * @param timestamp , a timestamp.
 * @throws UnknownNodeIdException , cannot find node by id exception.
 * @throws UnknownCapabilityIdException , cannot find capability by id exception.
 */
public void insertReading(final String sourceId,final String targetId,final String capabilityName,final double readingValue,final double rssiValue,final Date timestamp) throws UnknownNodeIdException, UnknownCapabilityIdException {
  Node source=NodeController.getInstance().getByID(sourceId);
  if (source == null)   throw new UnknownNodeIdException(sourceId);
  Node target=NodeController.getInstance().getByID(targetId);
  if (target == null)   throw new UnknownNodeIdException(targetId);
  Link link=LinkController.getInstance().getByID(sourceId,targetId);
  if (link == null) {
    link=new Link();
    link.setSource(sourceId);
    link.setTarget(targetId);
    link.setEncrypted(false);
    link.setVirtual(false);
    Rssi rssi=new Rssi();
    rssi.setDatatype(""String_Node_Str"");
    rssi.setUnit(""String_Node_Str"");
    rssi.setValue(""String_Node_Str"");
    link.setRssi(rssi);
    source.getSetup().getLink().add(link);
    link.setSetup(source.getSetup());
    LinkController.getInstance().add(link);
  }
  Capability capability=CapabilityController.getInstance().getByID(capabilityName);
  if (capability == null) {
    capability=new Capability();
    capability.setName(capabilityName);
    capability.setDatatype(""String_Node_Str"");
    capability.setDefaultvalue(""String_Node_Str"");
    capability.setUnit(""String_Node_Str"");
    CapabilityController.getInstance().add(capability);
  }
  if (link.getCapabilities() == null) {
    link.setCapabilities(new ArrayList<Capability>());
  }
  if (!link.getCapabilities().contains(capability)) {
    link.getCapabilities().add(capability);
  }
  if (capability.getLinks() == null) {
    capability.setLinks(new HashSet<Link>());
  }
  capability.getLinks().add(link);
  LinkController.getInstance().update(link);
  LinkReading reading=new LinkReading();
  reading.setLink(link);
  reading.setCapability(capability);
  reading.setReading(readingValue);
  reading.setRssiValue(rssiValue);
  reading.setTimestamp(timestamp);
  if (link.getReadings() == null) {
    link.setReadings(new HashSet<LinkReading>());
  }
  link.getReadings().add(reading);
  if (capability.getLinkReadings() == null) {
    capability.setLinkReadings(new HashSet<LinkReading>());
  }
  capability.getLinkReadings().add(reading);
  LinkReadingController.getInstance().add(reading);
}","/** 
 * Insert a links's reading from it's capabilities and make the appropriate relations such as Link-Reading , Capability-reading
 * @param sourceId , link's source id.
 * @param targetId , target's source id.
 * @param capabilityName , capability's id.
 * @param rssiValue , the RSSI value of the link.
 * @param readingValue , value of a sensor reading.
 * @param timestamp , a timestamp.
 * @throws UnknownNodeIdException , cannot find node by id exception.
 * @throws UnknownCapabilityIdException , cannot find capability by id exception.
 */
public void insertReading(final String sourceId,final String targetId,final String capabilityName,final double readingValue,final double rssiValue,final Date timestamp) throws UnknownNodeIdException, UnknownCapabilityIdException {
  Node source=NodeController.getInstance().getByID(sourceId);
  if (source == null)   throw new UnknownNodeIdException(sourceId);
  Node target=NodeController.getInstance().getByID(targetId);
  if (target == null)   throw new UnknownNodeIdException(targetId);
  Link link=LinkController.getInstance().getByID(sourceId,targetId);
  if (link == null) {
    link=new Link();
    link.setSource(sourceId);
    link.setTarget(targetId);
    link.setEncrypted(false);
    link.setVirtual(false);
    Rssi rssi=new Rssi();
    rssi.setDatatype(""String_Node_Str"");
    rssi.setUnit(""String_Node_Str"");
    rssi.setValue(""String_Node_Str"");
    link.setRssi(rssi);
    source.getSetup().getLink().add(link);
    link.setSetup(source.getSetup());
    LinkController.getInstance().add(link);
  }
  Capability capability=CapabilityController.getInstance().getByID(capabilityName);
  if (capability == null) {
    capability=new Capability();
    capability.setName(capabilityName);
    capability.setDatatype(""String_Node_Str"");
    capability.setDefaultvalue(""String_Node_Str"");
    capability.setUnit(""String_Node_Str"");
    CapabilityController.getInstance().add(capability);
  }
  if (link.getCapabilities() == null) {
    link.setCapabilities(new ArrayList<Capability>());
  }
  if (!link.getCapabilities().contains(capability)) {
    link.getCapabilities().add(capability);
  }
  if (capability.getLinks() == null) {
    capability.setLinks(new HashSet<Link>());
  }
  capability.getLinks().add(link);
  LinkController.getInstance().update(link);
  LinkReading reading=new LinkReading();
  reading.setLink(link);
  reading.setCapability(capability);
  reading.setReading(readingValue);
  reading.setRssiValue(rssiValue);
  reading.setTimestamp(timestamp);
  if (link.getReadings() == null) {
    link.setReadings(new HashSet<LinkReading>());
  }
  link.getReadings().add(reading);
  if (capability.getLinkReadings() == null) {
    capability.setLinkReadings(new HashSet<LinkReading>());
  }
  capability.getLinkReadings().add(reading);
  add(reading);
}",0.9936753338018272
5463,"/** 
 * Insert a node's reading from it's capabilities and make the appropriate relations such as Node-Reading , Capability-reading
 * @param nodeId       , a node's id.
 * @param capabilityId , a capability's id.
 * @param readingValue , the readings value.
 * @param timestamp    , a timestamp for the time the reading took place
 * @throws UnknownNodeIdException       , exception when an unknown node id occurs.
 * @throws UnknownCapabilityIdException ,  exception when an unknown capability id occurs.
 */
public void insertReading(final String nodeId,final String capabilityId,final double readingValue,final Date timestamp) throws UnknownNodeIdException, UnknownCapabilityIdException {
  Node node=NodeController.getInstance().getByID(nodeId);
  if (node == null)   throw new UnknownNodeIdException(nodeId);
  Capability capability=CapabilityController.getInstance().getByID(capabilityId);
  if (capability == null)   throw new UnknownCapabilityIdException(capabilityId);
  NodeReading reading=new NodeReading();
  reading.setNode(node);
  reading.setCapability(capability);
  reading.setReading(readingValue);
  reading.setTimestamp(timestamp);
  if (node.getReadings() == null) {
    node.setReadings(new HashSet<NodeReading>());
  }
  node.getReadings().add(reading);
  if (capability.getNodeReadings() == null) {
    capability.setNodeReadings(new HashSet<NodeReading>());
  }
  capability.getNodeReadings().add(reading);
  NodeReadingController.getInstance().add(reading);
}","/** 
 * Insert a node's reading from it's capabilities and make the appropriate relations such as Node-Reading , Capability-reading
 * @param nodeId       , a node's id.
 * @param capabilityId , a capability's id.
 * @param readingValue , the readings value.
 * @param timestamp    , a timestamp for the time the reading took place
 * @throws UnknownNodeIdException       , exception when an unknown node id occurs.
 * @throws UnknownCapabilityIdException ,  exception when an unknown capability id occurs.
 */
public void insertReading(final String nodeId,final String capabilityId,final double readingValue,final Date timestamp) throws UnknownNodeIdException, UnknownCapabilityIdException {
  Node node=NodeController.getInstance().getByID(nodeId);
  if (node == null)   throw new UnknownNodeIdException(nodeId);
  Capability capability=CapabilityController.getInstance().getByID(capabilityId);
  if (capability == null)   throw new UnknownCapabilityIdException(capabilityId);
  NodeReading reading=new NodeReading();
  reading.setNode(node);
  reading.setCapability(capability);
  reading.setReading(readingValue);
  reading.setTimestamp(timestamp);
  if (node.getReadings() == null) {
    node.setReadings(new HashSet<NodeReading>());
  }
  node.getReadings().add(reading);
  if (capability.getNodeReadings() == null) {
    capability.setNodeReadings(new HashSet<NodeReading>());
  }
  capability.getNodeReadings().add(reading);
  add(reading);
}",0.9877384196185286
5464,"/** 
 * Convert the WiseML setup entries collection to a WiseDB setup records.
 * @param collection , collection of setup entries.
 */
public void convertCollection(final Collection<Setup> collection){
  if (collection == null) {
    LOGGER.fatal(""String_Node_Str"");
    System.exit(-1);
  }
  setEntities(collection);
  for (  Setup setup : getEntities()) {
    SetupImporter.setNodeLinkSetup(setup);
    testbed.setSetup(setup);
    setup.setTestbed(testbed);
    TestbedController.getInstance().update(testbed);
    SetupController.getInstance().add(setup);
    LOGGER.debug(""String_Node_Str"");
  }
  LOGGER.debug(""String_Node_Str"" + collection.size() + ""String_Node_Str"");
}","/** 
 * Convert the WiseML setup entries collection to a WiseDB setup records.
 * @param collection , collection of setup entries.
 */
public void convertCollection(final Collection<Setup> collection){
  if (collection == null) {
    LOGGER.fatal(""String_Node_Str"");
    System.exit(-1);
  }
  setEntities(collection);
  for (  Setup setup : getEntities()) {
    SetupImporter.setNodeLinkSetup(setup);
    testbed.setSetup(setup);
    setup.setTestbed(testbed);
    TestbedController.getInstance().update(testbed);
    LOGGER.debug(""String_Node_Str"");
    SetupController.getInstance().add(setup);
    LOGGER.debug(""String_Node_Str"");
  }
}",0.8907435508345979
5465,"/** 
 * Insert a links's reading from it's capabilities and make the appropriate relations such as Link-Reading , Capability-reading
 * @param sourceId , link's source id.
 * @param targetId , target's source id.
 * @param capabilityName , capability's id.
 * @param rssiValue , the RSSI value of the link.
 * @param readingValue , value of a sensor reading.
 * @param timestamp , a timestamp.
 * @throws UnknownNodeIdException , cannot find node by id exception.
 * @throws UnknownCapabilityIdException , cannot find capability by id exception.
 */
public void insertReading(final String sourceId,final String targetId,final String capabilityName,final double readingValue,final double rssiValue,final Date timestamp) throws UnknownNodeIdException, UnknownCapabilityIdException {
  Node source=NodeController.getInstance().getByID(sourceId);
  if (source == null)   throw new UnknownNodeIdException(sourceId);
  Node target=NodeController.getInstance().getByID(targetId);
  if (target == null)   throw new UnknownNodeIdException(targetId);
  Link link=LinkController.getInstance().getByID(sourceId,targetId);
  if (link == null) {
    link=new Link();
    link.setSource(sourceId);
    link.setTarget(sourceId);
    link.setEncrypted(false);
    link.setVirtual(false);
    Rssi rssi=new Rssi();
    rssi.setDatatype(""String_Node_Str"");
    rssi.setUnit(""String_Node_Str"");
    rssi.setValue(""String_Node_Str"");
    link.setRssi(rssi);
    link.setSetup(source.getSetup());
    LinkController.getInstance().add(link);
  }
  Capability capability=CapabilityController.getInstance().getByID(capabilityName);
  if (capability == null) {
    capability=new Capability();
    capability.setName(capabilityName);
    capability.setDatatype(""String_Node_Str"");
    capability.setDefaultvalue(""String_Node_Str"");
    capability.setUnit(""String_Node_Str"");
    CapabilityController.getInstance().add(capability);
  }
  if (link.getCapabilities() == null) {
    link.setCapabilities(new ArrayList<Capability>());
  }
  if (!link.getCapabilities().contains(capability)) {
    link.getCapabilities().add(capability);
  }
  if (capability.getLinks() == null) {
    capability.setLinks(new HashSet<Link>());
  }
  capability.getLinks().add(link);
  LinkController.getInstance().update(link);
  LinkReading reading=new LinkReading();
  reading.setLink(link);
  reading.setCapability(capability);
  reading.setReading(readingValue);
  reading.setRssiValue(rssiValue);
  reading.setTimestamp(timestamp);
  if (link.getReadings() == null) {
    link.setReadings(new HashSet<LinkReading>());
  }
  link.getReadings().add(reading);
  if (capability.getLinkReadings() == null) {
    capability.setLinkReadings(new HashSet<LinkReading>());
  }
  capability.getLinkReadings().add(reading);
  LinkReadingController.getInstance().add(reading);
}","/** 
 * Insert a links's reading from it's capabilities and make the appropriate relations such as Link-Reading , Capability-reading
 * @param sourceId , link's source id.
 * @param targetId , target's source id.
 * @param capabilityName , capability's id.
 * @param rssiValue , the RSSI value of the link.
 * @param readingValue , value of a sensor reading.
 * @param timestamp , a timestamp.
 * @throws UnknownNodeIdException , cannot find node by id exception.
 * @throws UnknownCapabilityIdException , cannot find capability by id exception.
 */
public void insertReading(final String sourceId,final String targetId,final String capabilityName,final double readingValue,final double rssiValue,final Date timestamp) throws UnknownNodeIdException, UnknownCapabilityIdException {
  Node source=NodeController.getInstance().getByID(sourceId);
  if (source == null)   throw new UnknownNodeIdException(sourceId);
  Node target=NodeController.getInstance().getByID(targetId);
  if (target == null)   throw new UnknownNodeIdException(targetId);
  Link link=LinkController.getInstance().getByID(sourceId,targetId);
  if (link == null) {
    link=new Link();
    link.setSource(sourceId);
    link.setTarget(targetId);
    link.setEncrypted(false);
    link.setVirtual(false);
    Rssi rssi=new Rssi();
    rssi.setDatatype(""String_Node_Str"");
    rssi.setUnit(""String_Node_Str"");
    rssi.setValue(""String_Node_Str"");
    link.setRssi(rssi);
    source.getSetup().getLink().add(link);
    link.setSetup(source.getSetup());
    LinkController.getInstance().add(link);
  }
  Capability capability=CapabilityController.getInstance().getByID(capabilityName);
  if (capability == null) {
    capability=new Capability();
    capability.setName(capabilityName);
    capability.setDatatype(""String_Node_Str"");
    capability.setDefaultvalue(""String_Node_Str"");
    capability.setUnit(""String_Node_Str"");
    CapabilityController.getInstance().add(capability);
  }
  if (link.getCapabilities() == null) {
    link.setCapabilities(new ArrayList<Capability>());
  }
  if (!link.getCapabilities().contains(capability)) {
    link.getCapabilities().add(capability);
  }
  if (capability.getLinks() == null) {
    capability.setLinks(new HashSet<Link>());
  }
  capability.getLinks().add(link);
  LinkController.getInstance().update(link);
  LinkReading reading=new LinkReading();
  reading.setLink(link);
  reading.setCapability(capability);
  reading.setReading(readingValue);
  reading.setRssiValue(rssiValue);
  reading.setTimestamp(timestamp);
  if (link.getReadings() == null) {
    link.setReadings(new HashSet<LinkReading>());
  }
  link.getReadings().add(reading);
  if (capability.getLinkReadings() == null) {
    capability.setLinkReadings(new HashSet<LinkReading>());
  }
  capability.getLinkReadings().add(reading);
  LinkReadingController.getInstance().add(reading);
}",0.990325417766051
5466,"public static void main(String args[]){
  HibernateUtil.connectEntityManagers();
  Transaction tx=HibernateUtil.getInstance().getSession().beginTransaction();
  try {
    final String sourceId=""String_Node_Str"";
    final String targetId=""String_Node_Str"";
    final String capabilityName=""String_Node_Str"";
    LOGGER.debug(""String_Node_Str"" + sourceId);
    LOGGER.debug(""String_Node_Str"" + targetId);
    LOGGER.debug(""String_Node_Str"" + capabilityName);
    final int beforeLinks=LinkController.getInstance().list().size();
    final int beforeCaps=CapabilityController.getInstance().list().size();
    final int beforeReadings=LinkReadingController.getInstance().list().size();
    LinkReadingController.getInstance().insertReading(sourceId,targetId,capabilityName,10.0,new Date());
    final int afterLinks=LinkController.getInstance().list().size();
    final int afterCaps=CapabilityController.getInstance().list().size();
    final int afterReadings=LinkReadingController.getInstance().list().size();
    LOGGER.debug(""String_Node_Str"" + beforeLinks);
    LOGGER.debug(""String_Node_Str"" + beforeCaps);
    LOGGER.debug(""String_Node_Str"" + afterLinks);
    LOGGER.debug(""String_Node_Str"" + afterCaps);
    LOGGER.debug(""String_Node_Str"" + beforeReadings);
    LOGGER.debug(""String_Node_Str"" + afterReadings);
    tx.commit();
  }
 catch (  Exception e) {
    tx.rollback();
    LOGGER.fatal(e.getMessage());
    System.exit(-1);
  }
 finally {
    HibernateUtil.getInstance().closeSession();
  }
}","public static void main(String args[]){
  HibernateUtil.connectEntityManagers();
  Transaction tx=HibernateUtil.getInstance().getSession().beginTransaction();
  try {
    Iterator<Node> nodeIt=NodeController.getInstance().list().iterator();
    Node source=nodeIt.next();
    final String sourceId=source.getId();
    Node target=nodeIt.next();
    final String targetId=target.getId();
    final String capabilityName=""String_Node_Str"";
    LOGGER.debug(""String_Node_Str"" + sourceId);
    LOGGER.debug(""String_Node_Str"" + targetId);
    LOGGER.debug(""String_Node_Str"" + capabilityName);
    final int beforeLinks=LinkController.getInstance().list().size();
    final int beforeCaps=CapabilityController.getInstance().list().size();
    final int beforeReadings=LinkReadingController.getInstance().list().size();
    LinkReadingController.getInstance().insertReading(sourceId,targetId,capabilityName,10.0,new Date());
    final int afterLinks=LinkController.getInstance().list().size();
    final int afterCaps=CapabilityController.getInstance().list().size();
    final int afterReadings=LinkReadingController.getInstance().list().size();
    LOGGER.debug(""String_Node_Str"" + beforeLinks);
    LOGGER.debug(""String_Node_Str"" + beforeCaps);
    LOGGER.debug(""String_Node_Str"" + afterLinks);
    LOGGER.debug(""String_Node_Str"" + afterCaps);
    LOGGER.debug(""String_Node_Str"" + beforeReadings);
    LOGGER.debug(""String_Node_Str"" + afterReadings);
    tx.commit();
  }
 catch (  Exception e) {
    tx.rollback();
    LOGGER.fatal(e.getMessage());
    System.exit(-1);
  }
 finally {
    HibernateUtil.getInstance().closeSession();
  }
}",0.913375796178344
5467,"public void setWisemlfilename(String wisemlfilename){
  this.wisemlfilename=wisemlfilename;
}","public void setWisemlfilename(String wisemlFilename){
  this.wisemlFilename=wisemlFilename;
}",0.967741935483871
5468,"public String getWisemlfilename(){
  return wisemlfilename;
}","public String getWisemlfilename(){
  return wisemlFilename;
}",0.9836065573770492
5469,"public void addNodename(Nodename nodename){
  this.names.add(nodename);
}","public void addNodename(Nodename nodename){
  if (this.names == null) {
    this.names=new ArrayList<Nodename>();
  }
  this.names.add(nodename);
}",0.6636363636363637
5470,"public void addApplication(Application app){
  this.applications.add(app);
}","public void addApplication(Application app){
  if (this.applications == null) {
    this.applications=new ArrayList<Application>();
  }
  this.applications.add(app);
}",0.6255144032921811
5471,"public void addServerConnection(ServerConnection con){
  this.serverConnections.add(con);
}","public void addServerConnection(ServerConnection con){
  if (this.serverConnections == null) {
    this.serverConnections=new ArrayList<ServerConnection>();
  }
  this.serverConnections.add(con);
}",0.6319444444444444
5472,"/** 
 * this method add a node in the configuration
 * @param nd of the testbed configuration
 */
public void addNodes(Nodes nd){
  this.nodes.add(nd);
}","/** 
 * this method add a node in the configuration
 * @param nd of the testbed configuration
 */
public void addNodes(Nodes nd){
  if (this.nodes == null) {
    this.nodes=new ArrayList<Nodes>();
  }
  this.nodes.add(nd);
}",0.7214854111405835
5473,"/** 
 * {@inheritDoc}
 */
@Override public int doStartTag() throws JspException {
  if (this.autoForm == null) {
    setAutoForm(this.pageContext.getRequest().getAttribute(""String_Node_Str""));
  }
  AjahUtils.requireParam(this.autoForm,""String_Node_Str"");
  try {
    final JspWriter out=this.pageContext.getOut();
    final Div div=new Div().css(""String_Node_Str"");
    final Enumeration<String> attributes=this.pageContext.getRequest().getAttributeNames();
    while (attributes.hasMoreElements()) {
      final String attribute=attributes.nextElement();
      if (attribute.startsWith(""String_Node_Str"")) {
        final BindingResult result=(BindingResult)this.pageContext.getRequest().getAttribute(attribute);
        log.fine(""String_Node_Str"" + result.getErrorCount() + ""String_Node_Str"");
        final Div alertBox=div.add(new Div().css(""String_Node_Str"").css(""String_Node_Str""));
        final UnorderedList errs=alertBox.add(new UnorderedList().css(""String_Node_Str""));
        for (        final ObjectError error : result.getAllErrors()) {
          errs.add(new ListItem(getMessage(error)));
        }
      }
    }
    final Form form=new Form(FormMethod.POST).css(""String_Node_Str"").css(""String_Node_Str"");
    if (!StringUtils.isBlank(getId())) {
      form.setId(getId());
    }
    for (    final Field field : this.autoForm.getClass().getFields()) {
      log.fine(field.getName() + ""String_Node_Str"" + field.get(this.autoForm));
      final Input<?> input=getInput(field,this.autoForm.getClass().getFields());
      form.getInputs().add(input);
    }
    String submitText=null;
    if (this.autoForm.getClass().isAnnotationPresent(Submit.class)) {
      submitText=this.autoForm.getClass().getAnnotation(Submit.class).value();
    }
    if (StringUtils.isBlank(submitText)) {
      submitText=StringUtils.capitalize(StringUtils.splitCamelCase(this.autoForm.getClass().getSimpleName().replaceAll(""String_Node_Str"",""String_Node_Str"")));
    }
    final Input<InputImpl> input=new InputImpl(""String_Node_Str"",submitText,InputType.SUBMIT).css(""String_Node_Str"").css(""String_Node_Str"");
    form.getInputs().add(input);
    div.add(form);
    final Script script=new Script();
    final StringBuffer code=new StringBuffer();
    code.append(""String_Node_Str"");
    for (    final Input<?> child : form.getInputs()) {
      if (child instanceof TextArea && ((TextArea)child).isHtml()) {
        this.pageContext.getRequest().setAttribute(""String_Node_Str"",Boolean.TRUE);
        code.append(""String_Node_Str"" + ""String_Node_Str"");
        break;
      }
    }
    code.append(""String_Node_Str"" + form.getInputs().get(0).getId() + ""String_Node_Str"");
    code.append(""String_Node_Str"");
    script.setText(code.toString());
    div.add(script);
    div.render(out,isCompact() ? -1 : 0);
  }
 catch (  final IOException e) {
    throw new JspException(e);
  }
catch (  final IllegalArgumentException e) {
    throw new JspException(e);
  }
catch (  final IllegalAccessException e) {
    throw new JspException(e);
  }
  return Tag.EVAL_PAGE;
}","/** 
 * {@inheritDoc}
 */
@Override public int doStartTag() throws JspException {
  if (this.autoForm == null) {
    setAutoForm(this.pageContext.getRequest().getAttribute(""String_Node_Str""));
  }
  AjahUtils.requireParam(this.autoForm,""String_Node_Str"");
  try {
    final JspWriter out=this.pageContext.getOut();
    final Div div=new Div().css(""String_Node_Str"");
    final Enumeration<String> attributes=this.pageContext.getRequest().getAttributeNames();
    while (attributes.hasMoreElements()) {
      final String attribute=attributes.nextElement();
      if (attribute.startsWith(""String_Node_Str"")) {
        final BindingResult result=(BindingResult)this.pageContext.getRequest().getAttribute(attribute);
        log.fine(""String_Node_Str"" + result.getErrorCount() + ""String_Node_Str"");
        if (result.getErrorCount() > 0) {
          final Div alertBox=div.add(new Div().css(""String_Node_Str"").css(""String_Node_Str""));
          final UnorderedList errs=alertBox.add(new UnorderedList().css(""String_Node_Str""));
          for (          final ObjectError error : result.getAllErrors()) {
            errs.add(new ListItem(getMessage(error)));
          }
        }
      }
    }
    final Form form=new Form(FormMethod.POST).css(""String_Node_Str"").css(""String_Node_Str"");
    if (!StringUtils.isBlank(getId())) {
      form.setId(getId());
    }
    for (    final Field field : this.autoForm.getClass().getFields()) {
      log.fine(field.getName() + ""String_Node_Str"" + field.get(this.autoForm));
      final Input<?> input=getInput(field,this.autoForm.getClass().getFields());
      form.getInputs().add(input);
    }
    String submitText=null;
    Icon iconLeft=null;
    Icon iconRight=null;
    if (this.autoForm.getClass().isAnnotationPresent(Submit.class)) {
      Submit submit=this.autoForm.getClass().getAnnotation(Submit.class);
      submitText=submit.value();
      if (submit.iconLeft() != null && submit.iconLeft() != Icon.NONE) {
        iconLeft=submit.iconLeft();
      }
      if (submit.iconRight() != null && submit.iconRight() != Icon.NONE) {
        iconRight=submit.iconRight();
      }
    }
    if (StringUtils.isBlank(submitText)) {
      submitText=StringUtils.capitalize(StringUtils.splitCamelCase(this.autoForm.getClass().getSimpleName().replaceAll(""String_Node_Str"",""String_Node_Str"")));
    }
    final Button submitButton=new Button().text(submitText).type(ButtonType.SUBMIT).css(""String_Node_Str"").css(""String_Node_Str"");
    if (iconLeft != null) {
      submitButton.addBeforeText(new Italic().css(iconLeft.getBootstrapClass()));
    }
    if (iconRight != null) {
      submitButton.add(new Italic().css(iconRight.getBootstrapClass()));
    }
    form.getInputs().add(submitButton);
    div.add(form);
    final Script script=new Script();
    final StringBuffer code=new StringBuffer();
    code.append(""String_Node_Str"");
    for (    final Input<?> child : form.getInputs()) {
      if (child instanceof TextArea && ((TextArea)child).isHtml()) {
        this.pageContext.getRequest().setAttribute(""String_Node_Str"",Boolean.TRUE);
        code.append(""String_Node_Str"" + ""String_Node_Str"");
        break;
      }
    }
    code.append(""String_Node_Str"" + form.getInputs().get(0).getId() + ""String_Node_Str"");
    code.append(""String_Node_Str"");
    script.setText(code.toString());
    div.add(script);
    div.render(out,isCompact() ? -1 : 0);
  }
 catch (  final IOException e) {
    throw new JspException(e);
  }
catch (  final IllegalArgumentException e) {
    throw new JspException(e);
  }
catch (  final IllegalAccessException e) {
    throw new JspException(e);
  }
  return Tag.EVAL_PAGE;
}",0.8072683943997617
5474,"/** 
 * Handle the message via   {@link #innerHandle(AjahMessage)} and then callhandle on child handlers.
 * @see com.ajah.rfcmail.fetch.MessageHandler#handle(AjahMessage)
 */
@Override public final MessageHandlerResponse handle(AjahMessage message) throws MessagingException {
  AjahUtils.requireParam(message,""String_Node_Str"");
  AjahUtils.requireParam(message.getId(),""String_Node_Str"");
  MessageHandlerResponse response=innerHandle(message);
  for (  MessageHandler messageHandler : this.messageHandlers.getList(response.getResult())) {
    messageHandler.handle(message);
  }
  return null;
}","/** 
 * Handle the message via   {@link #innerHandle(AjahMessage)} and then callhandle on child handlers.
 * @see com.ajah.rfcmail.fetch.MessageHandler#handle(AjahMimeMessage)
 */
@Override public final MessageHandlerResponse handle(AjahMimeMessage message) throws MessagingException {
  AjahUtils.requireParam(message,""String_Node_Str"");
  AjahUtils.requireParam(message.getId(),""String_Node_Str"");
  MessageHandlerResponse response=innerHandle(message);
  for (  MessageHandler messageHandler : this.messageHandlers.getList(response.getResult())) {
    messageHandler.handle(message);
  }
  return null;
}",0.9933665008291874
5475,"private void processFolder(final IMAPFolder folder) throws MessagingException, IOException {
  log.fine(""String_Node_Str"" + folder.getFullName());
  final long start=System.currentTimeMillis();
  if ((folder.getType() & Folder.HOLDS_MESSAGES) != 0) {
    folder.open(Folder.READ_ONLY);
    final Message[] messages=folder.getMessages();
    log.fine(messages.length + ""String_Node_Str"");
    final FetchProfile fp=new FetchProfile();
    fp.add(""String_Node_Str"");
    folder.fetch(messages,fp);
    long messageCount=0;
    for (    final Message message : messages) {
      messageCount++;
      try {
        for (        MessageHandler messageHandler : getMessageHandlers()) {
          log.finest(messageHandler.getClass().getSimpleName() + ""String_Node_Str"" + ((MimeMessage)message).getMessageID());
          messageHandler.handle(new AjahMessage(message));
          return;
        }
      }
 catch (      final MessagingException e) {
        log.log(Level.SEVERE,e.getMessage(),e);
      }
    }
    log.finest(messageCount + ""String_Node_Str"");
  }
  final long end=System.currentTimeMillis();
  log.finest(""String_Node_Str"" + folder.getFullName() + ""String_Node_Str""+ (end - start)+ ""String_Node_Str"");
  if ((folder.getType() & Folder.HOLDS_FOLDERS) != 0) {
    final Folder[] children=folder.list();
    if (children != null) {
      for (      final Folder child : children) {
        processFolder((IMAPFolder)child);
      }
    }
  }
}","private void processFolder(final IMAPFolder folder) throws MessagingException, IOException {
  log.fine(""String_Node_Str"" + folder.getFullName());
  final long start=System.currentTimeMillis();
  if ((folder.getType() & Folder.HOLDS_MESSAGES) != 0) {
    folder.open(Folder.READ_ONLY);
    final Message[] messages=folder.getMessages();
    log.fine(messages.length + ""String_Node_Str"");
    final FetchProfile fp=new FetchProfile();
    fp.add(""String_Node_Str"");
    folder.fetch(messages,fp);
    long messageCount=0;
    for (    final Message message : messages) {
      messageCount++;
      try {
        for (        MessageHandler messageHandler : getMessageHandlers()) {
          log.finest(messageHandler.getClass().getSimpleName() + ""String_Node_Str"" + ((MimeMessage)message).getMessageID());
          messageHandler.handle(new AjahMimeMessage(message.getInputStream()));
          return;
        }
      }
 catch (      final MessagingException e) {
        log.log(Level.SEVERE,e.getMessage(),e);
      }
    }
    log.finest(messageCount + ""String_Node_Str"");
  }
  final long end=System.currentTimeMillis();
  log.finest(""String_Node_Str"" + folder.getFullName() + ""String_Node_Str""+ (end - start)+ ""String_Node_Str"");
  if ((folder.getType() & Folder.HOLDS_FOLDERS) != 0) {
    final Folder[] children=folder.list();
    if (children != null) {
      for (      final Folder child : children) {
        processFolder((IMAPFolder)child);
      }
    }
  }
}",0.98327074086719
5476,"/** 
 * Process a message.
 * @param message The message to process.
 * @return The result of the message processing, will not be null.
 * @throws MessagingException
 */
MessageHandlerResponse handle(AjahMessage message) throws MessagingException ;","/** 
 * Process a message.
 * @param message The message to process.
 * @return The result of the message processing, will not be null.
 * @throws MessagingException
 */
MessageHandlerResponse handle(AjahMimeMessage message) throws MessagingException ;",0.992
5477,"/** 
 * Gets the content of a message as text and removes extra whitespace.
 * @see #getContentAsText(AjahMessage)
 * @param message
 * @return The content of a message as text with extra whitespace removed.
 * @throws IOException
 * @throws MessagingException
 */
public static String getContentAsCleanText(AjahMessage message) throws MessagingException, IOException {
  return removeExtraWhitespace(getContentAsText(message));
}","/** 
 * Gets the content of a message as text and removes extra whitespace.
 * @see #getContentAsText(AjahMimeMessage)
 * @param message
 * @return The content of a message as text with extra whitespace removed.
 * @throws IOException
 * @throws MessagingException
 */
public static String getContentAsCleanText(AjahMimeMessage message) throws MessagingException, IOException {
  return removeExtraWhitespace(getContentAsText(message));
}",0.9907834101382488
5478,"/** 
 * Returns a random element from a list.
 * @param < T > Type of element.
 * @param list The list to find a random element in.
 * @return A random element from the list, or null if the list is null orempty.
 */
public static <T>T getRandomElement(final List<T> list){
  if (CollectionUtils.isEmpty(list)) {
    return null;
  }
  return list.get(getRandomNumber(0,list.size()));
}","/** 
 * Returns a random element from a list.
 * @param < T > Type of element.
 * @param list The list to find a random element in.
 * @return A random element from the list, or null if the list is null orempty.
 */
public static <T>T getRandomElement(final List<T> list){
  if (CollectionUtils.isEmpty(list)) {
    return null;
  }
  return list.get(getRandomNumber(0,list.size() - 1));
}",0.9948320413436692
5479,"public MapTable getMap(){
  MapTable map=new MapTable();
  int sAddrHighest=-1;
  ELFSection name=sections[symTable.link];
  int len=symTable.size;
  int count=len / symTable.getEntrySize();
  int addr=symTable.getOffset();
  String currentFile=null;
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + count);
  }
  int currentAddress=0;
  for (int i=0, n=count; i < n; i++) {
    setPos(addr);
    int nI=readElf32();
    String sn=name.getName(nI);
    int sAddr=readElf32();
    int size=readElf32();
    int info=readElf8();
    int bind=info >> 4;
    int type=info & 0xf;
    if (type == ELFSection.SYMTYPE_NONE && sn != null) {
      if (""String_Node_Str"".equals(sn)) {
        if (currentFile != null) {
          files.add(new FileInfo(currentFile,currentAddress,sAddr));
          currentAddress=sAddr;
        }
      }
 else       if (!sn.startsWith(""String_Node_Str"")) {
        map.setEntry(new MapEntry(MapEntry.TYPE.variable,sAddr,0,sn,currentFile,false));
      }
    }
    if (type == ELFSection.SYMTYPE_FILE) {
      currentFile=sn;
    }
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + sn + ""String_Node_Str""+ Integer.toString(sAddr,16)+ ""String_Node_Str""+ bind+ ""String_Node_Str""+ type+ ""String_Node_Str""+ size);
    }
    if (sAddr > 0 && sAddr < 0x100000) {
      String symbolName=sn;
      if (sAddr < 0x5c00 && sAddr > sAddrHighest) {
        sAddrHighest=sAddr;
      }
      if (""String_Node_Str"".equals(symbolName)) {
        map.setHeapStart(sAddr);
      }
 else       if (""String_Node_Str"".equals(symbolName)) {
        map.setStackStart(sAddr);
      }
      if (type == ELFSection.SYMTYPE_FUNCTION) {
        String file=lookupFile(sAddr);
        if (file == null) {
          file=currentFile;
        }
        map.setEntry(new MapEntry(MapEntry.TYPE.function,sAddr,0,symbolName,file,bind == ELFSection.SYMBIND_LOCAL));
      }
 else       if (type == ELFSection.SYMTYPE_OBJECT) {
        String file=lookupFile(sAddr);
        if (file == null) {
          file=currentFile;
        }
        map.setEntry(new MapEntry(MapEntry.TYPE.variable,sAddr,size,symbolName,file,bind == ELFSection.SYMBIND_LOCAL));
      }
 else {
        if (DEBUG) {
          System.out.println(""String_Node_Str"" + symbolName + ""String_Node_Str""+ Integer.toString(sAddr,16)+ ""String_Node_Str""+ currentFile+ ""String_Node_Str"");
        }
      }
    }
    addr+=symTable.getEntrySize();
  }
  if (sAddrHighest > 0) {
    System.out.printf(""String_Node_Str"",sAddrHighest);
    map.setHeapStart(sAddrHighest);
  }
  return map;
}","public MapTable getMap(){
  MapTable map=new MapTable();
  int sAddrHighest=-1;
  ELFSection name=sections[symTable.link];
  int len=symTable.size;
  int count=len / symTable.getEntrySize();
  int addr=symTable.getOffset();
  String currentFile=null;
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + count);
  }
  int currentAddress=0;
  for (int i=0, n=count; i < n; i++) {
    setPos(addr);
    int nI=readElf32();
    String sn=name.getName(nI);
    int sAddr=readElf32();
    int size=readElf32();
    int info=readElf8();
    int bind=info >> 4;
    int type=info & 0xf;
    if (type == ELFSection.SYMTYPE_NONE && sn != null) {
      if (""String_Node_Str"".equals(sn)) {
        if (currentFile != null) {
          files.add(new FileInfo(currentFile,currentAddress,sAddr));
          currentAddress=sAddr;
        }
      }
 else       if (!sn.startsWith(""String_Node_Str"")) {
        map.setEntry(new MapEntry(MapEntry.TYPE.variable,sAddr,0,sn,currentFile,false));
      }
    }
    if (type == ELFSection.SYMTYPE_FILE) {
      currentFile=sn;
    }
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + sn + ""String_Node_Str""+ Integer.toString(sAddr,16)+ ""String_Node_Str""+ bind+ ""String_Node_Str""+ type+ ""String_Node_Str""+ size);
    }
    if (sAddr > 0 && sAddr < 0x100000) {
      String symbolName=sn;
      if (sAddr < 0x5c00 && sAddr > sAddrHighest) {
        sAddrHighest=sAddr;
      }
      if (""String_Node_Str"".equals(symbolName)) {
        map.setHeapStart(sAddr);
      }
 else       if (""String_Node_Str"".equals(symbolName)) {
        map.setStackStart(sAddr);
      }
      if (type == ELFSection.SYMTYPE_FUNCTION) {
        String file=lookupFile(sAddr);
        if (file == null) {
          file=currentFile;
        }
        map.setEntry(new MapEntry(MapEntry.TYPE.function,sAddr,0,symbolName,file,bind == ELFSection.SYMBIND_LOCAL));
      }
 else       if (type == ELFSection.SYMTYPE_OBJECT) {
        String file=lookupFile(sAddr);
        if (file == null) {
          file=currentFile;
        }
        map.setEntry(new MapEntry(MapEntry.TYPE.variable,sAddr,size,symbolName,file,bind == ELFSection.SYMBIND_LOCAL));
      }
 else {
        if (DEBUG) {
          System.out.println(""String_Node_Str"" + symbolName + ""String_Node_Str""+ Integer.toString(sAddr,16)+ ""String_Node_Str""+ currentFile+ ""String_Node_Str"");
        }
      }
    }
    addr+=symTable.getEntrySize();
  }
  if (map.getHeapStart() <= 0 && sAddrHighest > 0) {
    System.err.printf(""String_Node_Str"",sAddrHighest);
    map.setHeapStart(sAddrHighest);
  }
  return map;
}",0.9916488638570596
5480,"private void writePort(PortReg function,int data,long cycles){
switch (function) {
case OUT:
{
      out=data;
      PortListener listener=portListener;
      if (listener != null) {
        listener.portWrite(this,out | (~dir) & 0xff);
      }
      break;
    }
case IN:
  logw(WarningType.ILLEGAL_IO_WRITE,""String_Node_Str"" + getID() + ""String_Node_Str"");
throw new EmulationException(""String_Node_Str"" + getID() + ""String_Node_Str"");
case DIR:
{
dir=data;
PortListener listener=portListener;
if (listener != null) {
  listener.portWrite(this,out | (~dir) & 0xff);
}
break;
}
case REN:
ren=data;
break;
case IFG:
if (DEBUG) {
log(""String_Node_Str"" + data);
}
ifg&=data;
updateIV();
break;
case IE:
ie=data;
if (DEBUG) {
log(""String_Node_Str"" + data);
}
cpu.flagInterrupt(interrupt,this,(ifg & ie) > 0);
break;
case IES:
ies=data;
break;
case SEL:
sel=data;
break;
case SEL2:
sel2=data;
break;
case DS:
ds=data;
break;
case IV_L:
if (iv != 0) {
if (iv > 1 && iv < 17) {
ifg&=~(1 << ((iv - 2) / 2));
}
updateIV();
}
break;
case IV_H:
break;
}
}","private void writePort(PortReg function,int data,long cycles){
switch (function) {
case OUT:
{
      out=data;
      PortListener listener=portListener;
      if (listener != null) {
        listener.portWrite(this,out | (~dir) & 0xff);
      }
      break;
    }
case IN:
  logw(WarningType.ILLEGAL_IO_WRITE,""String_Node_Str"" + getID() + ""String_Node_Str"");
throw new EmulationException(""String_Node_Str"" + getID() + ""String_Node_Str"");
case DIR:
{
dir=data;
PortListener listener=portListener;
if (listener != null) {
  listener.portWrite(this,out | (~dir) & 0xff);
}
break;
}
case REN:
ren=data;
break;
case IFG:
if (DEBUG) {
log(""String_Node_Str"" + data);
}
ifg=data;
updateIV();
break;
case IE:
ie=data;
if (DEBUG) {
log(""String_Node_Str"" + data);
}
cpu.flagInterrupt(interrupt,this,(ifg & ie) > 0);
break;
case IES:
ies=data;
break;
case SEL:
sel=data;
break;
case SEL2:
sel2=data;
break;
case DS:
ds=data;
break;
case IV_L:
if (iv != 0) {
if (iv > 1 && iv < 17) {
ifg&=~(1 << ((iv - 2) / 2));
}
updateIV();
}
break;
case IV_H:
break;
}
}",0.9995213020584012
5481,"@Override public void write(int address,int data,boolean word,long cycles){
  address=address - offset;
  if (DEBUG) {
    log(""String_Node_Str"" + Utils.hex(address,4) + ""String_Node_Str""+ data+ ""String_Node_Str""+ word);
  }
switch (address) {
case MPY:
    if (DEBUG)     log(""String_Node_Str"" + data);
  op1=mpy=data;
signed=false;
accumulating=false;
break;
case MPYS:
op1=mpys=data;
if (DEBUG) log(""String_Node_Str"" + data);
signed=true;
accumulating=false;
break;
case MAC:
op1=mac=data;
if (DEBUG) log(""String_Node_Str"" + data);
signed=false;
accumulating=true;
break;
case MACS:
op1=macs=data;
if (DEBUG) log(""String_Node_Str"" + data);
signed=true;
accumulating=true;
break;
case RESLO:
resLo=data;
break;
case RESHI:
resHi=data;
break;
case OP2:
if (DEBUG) log(""String_Node_Str"" + data);
sumext=0;
op2=data;
if (signed) {
if (!word) {
if (op1 > 0x80) op1=op1 | 0xff00;
if (op2 > 0x80) op2=op2 | 0xff00;
}
op1=op1 > 0x8000 ? op1 - 0x10000 : op1;
op2=op2 > 0x8000 ? op2 - 0x10000 : op2;
}
long res=(long)op1 * (long)op2;
if (DEBUG) log(""String_Node_Str"" + op1 + ""String_Node_Str""+ op2+ ""String_Node_Str""+ res);
if (signed) {
sumext=res < 0 ? 0xffff : 0;
}
if (accumulating) {
res+=((long)resHi << 16) + resLo;
if (!signed) {
sumext=res > 0xffffffffL ? 1 : 0;
}
}
 else if (!signed) {
sumext=0;
}
resHi=(int)((res >> 16) & 0xffff);
resLo=(int)(res & 0xffff);
if (DEBUG) log(""String_Node_Str"" + res);
break;
case MPY32L:
op1=mpy32L=data;
signed=false;
accumulating=false;
break;
case MPY32H:
mpy32H=data;
op1=(op1 & 0xffff) | (data << 16);
break;
case MPYS32L:
if (!word && data >= 0x80) {
data-=0x100;
}
op1=mpy32L=data;
signed=true;
accumulating=false;
break;
case MPYS32H:
if (!word & data > 0x80) {
data-=0x100;
}
mpys32H=data;
op1=(op1 & 0xffff) | (data << 16);
break;
case MAC32L:
op1=mac32L=data;
signed=false;
accumulating=true;
break;
case MAC32H:
mac32H=data;
op1=(op1 & 0xffff) | (data << 16);
break;
case MACS32L:
if (!word & data > 0x80) {
data-=0x100;
}
op1=macs32L=data;
signed=true;
accumulating=true;
break;
case MACS32H:
if (!word & data > 0x80) {
data-=0x100;
}
macs32H=data;
op1=(op1 & 0xffff) | (data << 16);
break;
case OP2L:
if (signed && !word && data >= 0x80) {
data-=0x80;
}
op2L=op2=data;
break;
case OP2H:
{
long p;
if (signed && !word && data >= 0x80) {
data-=0x80;
}
op2=(op2 & 0xffff) | (data << 16);
if (signed) {
p=(long)op1 * (long)op2;
}
 else {
long uop1, uop2;
uop1=op1;
if (uop1 < 0) {
uop1+=0x100000000L;
}
uop2=op2;
if (uop2 < 0) {
uop2+=0x100000000L;
}
p=uop1 * uop2;
}
if (accumulating) {
res64+=p;
}
 else {
res64=p;
}
res0=(int)res64 & 0xffff;
res1=(int)(res64 >> 16) & 0xffff;
res2=(int)(res64 >> 32) & 0xffff;
res3=(int)(res64 >> 48) & 0xffff;
break;
}
default :
logw(WarningType.EMULATION_ERROR,""String_Node_Str"" + Utils.hex(address,4));
break;
}
}","@Override public void write(int address,int data,boolean word,long cycles){
  address=address - offset;
  if (DEBUG) {
    log(""String_Node_Str"" + Utils.hex(address,4) + ""String_Node_Str""+ data+ ""String_Node_Str""+ word);
  }
switch (address) {
case MPY:
    if (DEBUG)     log(""String_Node_Str"" + data);
  op1=mpy=data;
signed=false;
accumulating=false;
break;
case MPYS:
op1=mpys=data;
if (DEBUG) log(""String_Node_Str"" + data);
signed=true;
accumulating=false;
break;
case MAC:
op1=mac=data;
if (DEBUG) log(""String_Node_Str"" + data);
signed=false;
accumulating=true;
break;
case MACS:
op1=macs=data;
if (DEBUG) log(""String_Node_Str"" + data);
signed=true;
accumulating=true;
break;
case RESLO:
resLo=data;
break;
case RESHI:
resHi=data;
break;
case OP2:
if (DEBUG) log(""String_Node_Str"" + data);
sumext=0;
op2=data;
if (signed) {
if (!word) {
if (op1 > 0x80) op1=op1 | 0xff00;
if (op2 > 0x80) op2=op2 | 0xff00;
}
op1=op1 > 0x8000 ? op1 - 0x10000 : op1;
op2=op2 > 0x8000 ? op2 - 0x10000 : op2;
}
long res=(long)op1 * (long)op2;
if (DEBUG) log(""String_Node_Str"" + op1 + ""String_Node_Str""+ op2+ ""String_Node_Str""+ res);
if (signed) {
sumext=res < 0 ? 0xffff : 0;
}
if (accumulating) {
res+=((long)resHi << 16) + resLo;
if (!signed) {
sumext=res > 0xffffffffL ? 1 : 0;
}
}
 else if (!signed) {
sumext=0;
}
resHi=(int)((res >> 16) & 0xffff);
resLo=(int)(res & 0xffff);
if (DEBUG) log(""String_Node_Str"" + res);
break;
case MPY32L:
op1=mpy32L=data;
signed=false;
accumulating=false;
break;
case MPY32H:
mpy32H=data;
op1=(op1 & 0xffff) | (data << 16);
break;
case MPYS32L:
if (!word && data >= 0x80) {
data-=0x100;
}
op1=mpy32L=data;
signed=true;
accumulating=false;
break;
case MPYS32H:
if (!word & data > 0x80) {
data-=0x100;
}
mpys32H=data;
op1=(op1 & 0xffff) | (data << 16);
break;
case MAC32L:
op1=mac32L=data;
signed=false;
accumulating=true;
break;
case MAC32H:
mac32H=data;
op1=(op1 & 0xffff) | (data << 16);
break;
case MACS32L:
if (!word & data > 0x80) {
data-=0x100;
}
op1=macs32L=data;
signed=true;
accumulating=true;
break;
case MACS32H:
if (!word & data > 0x80) {
data-=0x100;
}
macs32H=data;
op1=(op1 & 0xffff) | (data << 16);
break;
case OP2L:
if (signed && !word && data >= 0x80) {
data-=0x80;
}
op2L=op2=data;
break;
case OP2H:
{
long p;
if (signed && !word && data >= 0x80) {
data-=0x80;
}
op2=(op2 & 0xffff) | (data << 16);
if (signed) {
p=(long)op1 * (long)op2;
}
 else {
long uop1, uop2;
uop1=op1;
if (uop1 < 0) {
uop1+=0x100000000L;
}
uop2=op2;
if (uop2 < 0) {
uop2+=0x100000000L;
}
p=uop1 * uop2;
}
if (accumulating) {
res64+=p;
}
 else {
res64=p;
}
resLo=res0=(int)res64 & 0xffff;
resHi=res1=(int)(res64 >> 16) & 0xffff;
res2=(int)(res64 >> 32) & 0xffff;
res3=(int)(res64 >> 48) & 0xffff;
break;
}
default :
logw(WarningType.EMULATION_ERROR,""String_Node_Str"" + Utils.hex(address,4));
break;
}
}",0.9978609625668448
5482,"public void setLogLevel(int l){
  logLevel=l;
}","public void setLogLevel(int l){
  logLevel=l;
  DEBUG=logLevel == Loggable.DEBUG;
}",0.7230769230769231
5483,"public void updateIV(){
  int bitval=0x01;
  iv=0;
  int ie_ifg=ifg & ie;
  for (int i=0; i < 8; i++) {
    if ((bitval & ie_ifg) > 0) {
      iv=2 + i * 2;
      break;
    }
    bitval=bitval << 1;
  }
}","private void updateIV(){
  int bitval=0x01;
  iv=0;
  int ie_ifg=ifg & ie;
  for (int i=0; i < 8; i++) {
    if ((bitval & ie_ifg) > 0) {
      iv=2 + i * 2;
      break;
    }
    bitval=bitval << 1;
  }
  cpu.flagInterrupt(interrupt,this,(ifg & ie) > 0);
}",0.8639308855291576
5484,"public int read(int address,boolean word,long cycles){
  PortReg reg=portMap[address - offset];
  if (word && reg == PortReg.IV_L) {
    return read_port(reg,cycles) | (read_port(PortReg.IV_H,cycles) << 8);
  }
 else   if (word && ioPair != null) {
    return read_port(reg,cycles) | (ioPair.read_port(reg,cycles) << 8);
  }
  return read_port(reg,cycles);
}","public int read(int address,boolean word,long cycles){
  PortReg reg=portMap[address - offset];
  if (word && reg == PortReg.IV_L) {
    return (readPort(PortReg.IV_H,cycles) << 8) | readPort(reg,cycles);
  }
 else   if (word && ioPair != null) {
    return readPort(reg,cycles) | (ioPair.readPort(reg,cycles) << 8);
  }
  return readPort(reg,cycles);
}",0.9029535864978904
5485,"public void write(int address,int data,boolean word,long cycles){
  int iAddress=address - offset;
  if (iAddress < 0 || iAddress >= portMap.length) {
    throw new EmulationException(""String_Node_Str"" + getID() + ""String_Node_Str""+ Utils.hex(address,4));
  }
  PortReg fun=portMap[iAddress];
  if (DEBUG) {
    log(""String_Node_Str"" + getID() + fun+ ""String_Node_Str""+ Utils.hex(address,2)+ ""String_Node_Str""+ Utils.hex(data,2)+ ""String_Node_Str""+ Utils.binary8(data)+ (word ? ""String_Node_Str"" : ""String_Node_Str""));
  }
  if (word && ioPair != null) {
    write_port(fun,data & 0xff,cycles);
    ioPair.write_port(fun,data >> 8,cycles);
  }
 else {
    write_port(fun,data,cycles);
  }
}","public void write(int address,int data,boolean word,long cycles){
  int iAddress=address - offset;
  if (iAddress < 0 || iAddress >= portMap.length) {
    throw new EmulationException(""String_Node_Str"" + getID() + ""String_Node_Str""+ Utils.hex(address,4));
  }
  PortReg fun=portMap[iAddress];
  if (DEBUG) {
    log(""String_Node_Str"" + getID() + fun+ ""String_Node_Str""+ Utils.hex(address,2)+ ""String_Node_Str""+ Utils.hex(data,2)+ ""String_Node_Str""+ Utils.binary8(data)+ (word ? ""String_Node_Str"" : ""String_Node_Str""));
  }
  if (word && ioPair != null) {
    writePort(fun,data & 0xff,cycles);
    ioPair.writePort(fun,data >> 8,cycles);
  }
 else {
    writePort(fun,data,cycles);
  }
}",0.9934640522875816
5486,"public void setPinState(int pin,PinState state){
  if (pinState[pin] != state) {
    pinState[pin]=state;
    int bit=1 << pin;
    if (state == PinState.HI) {
      in|=bit;
    }
 else {
      in&=~bit;
    }
    if (interrupt > 0) {
      if ((ies & bit) == 0) {
        if (state == PinState.HI) {
          ifg|=bit;
          updateIV();
          if (DEBUG) {
            log(""String_Node_Str"" + bit);
          }
        }
      }
 else {
        if (state == PinState.LOW) {
          ifg|=bit;
          updateIV();
          if (DEBUG) {
            log(""String_Node_Str"" + bit);
          }
        }
      }
      cpu.flagInterrupt(interrupt,this,(ifg & ie) > 0);
    }
    if (timerCapture[pin] != null) {
      timerCapture[pin].capture(pin,0,state);
    }
  }
}","public void setPinState(int pin,PinState state){
  if (pinState[pin] != state) {
    pinState[pin]=state;
    int bit=1 << pin;
    if (state == PinState.HI) {
      in|=bit;
    }
 else {
      in&=~bit;
    }
    if (interrupt > 0) {
      if ((ies & bit) == 0) {
        if (state == PinState.HI) {
          ifg|=bit;
          if (DEBUG) {
            log(""String_Node_Str"" + bit);
          }
          updateIV();
        }
      }
 else {
        if (state == PinState.LOW) {
          ifg|=bit;
          if (DEBUG) {
            log(""String_Node_Str"" + bit);
          }
          updateIV();
        }
      }
    }
    if (timerCapture[pin] != null) {
      timerCapture[pin].capture(pin,0,state);
    }
  }
}",0.8945260347129506
5487,"public DbgInstruction disassemble(int pc,int[] memory,int[] reg,DbgInstruction dbg,int interrupt){
  int startPC=pc;
  int size=0;
  int instruction=memory[pc] + (memory[pc + 1] << 8);
  int op=instruction >> 12;
  boolean word=(instruction & 0x40) == 0;
  String output=""String_Node_Str"";
  if (interrupt > 0) {
    output=""String_Node_Str"" + Integer.toString(interrupt) + ' ';
  }
  String regs=""String_Node_Str"";
  if (pc < 0x0010) {
    output+=""String_Node_Str"" + Integer.toString(pc,16);
  }
 else   if (pc < 0x0100) {
    output+=""String_Node_Str"" + Integer.toString(pc,16);
  }
 else   if (pc < 0x1000) {
    output+=""String_Node_Str"" + Integer.toString(pc,16);
  }
 else {
    output+=Integer.toString(pc,16);
  }
  output+=""String_Node_Str"";
  pc+=2;
  size+=2;
switch (op) {
case 0:
{
      String opstr=""String_Node_Str"";
      op=instruction & 0xf0f0;
      int srcdata=(instruction & 0x0f00) >> 8;
      int dst=instruction & 0x000f;
      int nextData=memory[pc] + (memory[pc + 1] << 8);
      boolean rrword=true;
switch (op) {
case MOVA_IND:
        opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ dst;
      break;
case MOVA_IND_AUTOINC:
    opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ dst;
  break;
case MOVA_ABS2REG:
opstr=""String_Node_Str"" + Utils.hex20(((srcdata << 16) | nextData)) + ""String_Node_Str""+ dst;
size+=2;
break;
case MOVA_INDX2REG:
opstr=""String_Node_Str"" + Utils.hex16(nextData) + ""String_Node_Str""+ srcdata+ ""String_Node_Str""+ dst;
size+=2;
break;
case MOVA_REG2ABS:
opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ Utils.hex20(((dst << 16) | nextData));
size+=2;
break;
case MOVA_REG2INDX:
opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ Utils.hex16(nextData)+ ""String_Node_Str""+ dst+ ""String_Node_Str"";
size+=2;
break;
case MOVA_IMM2REG:
opstr=""String_Node_Str"" + Utils.hex20(((srcdata << 16) | nextData)) + ""String_Node_Str""+ dst;
size+=2;
break;
case CMPA_IMM:
opstr=""String_Node_Str"" + Utils.hex20(((srcdata << 16) | nextData)) + ""String_Node_Str""+ dst;
size+=2;
break;
case ADDA_IMM:
opstr=""String_Node_Str"" + Utils.hex20(((srcdata << 16) | nextData)) + ""String_Node_Str""+ dst;
size+=2;
break;
case SUBA_IMM:
opstr=""String_Node_Str"" + Utils.hex20(((srcdata << 16) | nextData)) + ""String_Node_Str""+ dst;
size+=2;
break;
case MOVA_REG:
opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ dst;
break;
case CMPA_REG:
opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ dst;
break;
case ADDA_REG:
opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ dst;
break;
case SUBA_REG:
opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ dst;
break;
case RRXX_ADDR:
rrword=false;
case RRXX_WORD:
String rrwordStr=rrword ? ""String_Node_Str"" : ""String_Node_Str"";
int count=((instruction >> 10) & 0x03) + 1;
switch (instruction & RRMASK) {
case RRCM:
opstr=""String_Node_Str"" + rrwordStr + ""String_Node_Str""+ count+ ""String_Node_Str""+ dst;
break;
case RRAM:
opstr=""String_Node_Str"" + rrwordStr + ""String_Node_Str""+ count+ ""String_Node_Str""+ dst;
break;
case RLAM:
opstr=""String_Node_Str"" + rrwordStr + ""String_Node_Str""+ count+ ""String_Node_Str""+ dst;
break;
case RRUM:
opstr=""String_Node_Str"" + rrwordStr + ""String_Node_Str""+ count+ ""String_Node_Str""+ dst;
break;
}
break;
}
output+=dumpMem(startPC,size,memory);
output+=opstr + ""String_Node_Str"";
regs=""String_Node_Str"" + srcdata + ""String_Node_Str""+ Utils.hex16(reg[srcdata]);
regs+=""String_Node_Str"" + Utils.hex16(reg[SP]);
}
break;
case 1:
{
int dst=instruction & 0x000f;
int nextData=memory[pc] + (memory[pc + 1] << 8);
String opstr=null;
switch (instruction & 0xfff0) {
case CALLA_REG:
opstr=""String_Node_Str"" + dst;
break;
case CALLA_IND:
opstr=""String_Node_Str"" + dst;
break;
case CALLA_IND_AUTOINC:
opstr=""String_Node_Str"" + dst + ""String_Node_Str"";
break;
case CALLA_ABS:
opstr=""String_Node_Str"" + Utils.hex20(((dst << 16) | nextData));
size+=2;
break;
case CALLA_EDE:
opstr=""String_Node_Str"" + Utils.hex20(((dst << 16) | nextData)) + ""String_Node_Str"";
size+=2;
break;
case CALLA_IMM:
opstr=""String_Node_Str"" + Utils.hex20(((dst << 16) | nextData));
size+=2;
break;
default :
switch (instruction & 0xff00) {
case PUSHM_A:
opstr=""String_Node_Str"" + (1 + ((instruction >> 4) & 0x0f)) + ""String_Node_Str""+ (instruction & 0x0f);
break;
case PUSHM_W:
opstr=""String_Node_Str"" + (1 + ((instruction >> 4) & 0x0f)) + ""String_Node_Str""+ (instruction & 0x0f);
break;
case POPM_A:
opstr=""String_Node_Str"" + (1 + ((instruction >> 4) & 0x0f)) + ""String_Node_Str""+ (instruction & 0x0f);
break;
case POPM_W:
opstr=""String_Node_Str"" + (1 + ((instruction >> 4) & 0x0f)) + ""String_Node_Str""+ (instruction & 0x0f);
break;
}
}
if (opstr != null) {
output+=dumpMem(startPC,size,memory);
output+=opstr + ""String_Node_Str"";
regs=""String_Node_Str"" + dst + ""String_Node_Str""+ Utils.hex16(reg[dst]);
regs+=""String_Node_Str"" + Utils.hex16(reg[SP]);
}
 else {
int register=instruction & 0xf;
int ad=(instruction >> 4) & 3;
int dstAddress=0;
String adr=""String_Node_Str"";
switch (ad) {
case AM_REG:
adr=""String_Node_Str"" + register;
break;
case AM_INDEX:
dstAddress=memory[pc] + (memory[pc + 1] << 8);
adr=""String_Node_Str"" + register + ""String_Node_Str""+ dstAddress+ ""String_Node_Str"";
dstAddress=(register == CG1 ? 0 : reg[register]) + dstAddress;
pc+=2;
size+=2;
break;
case AM_IND_REG:
adr=""String_Node_Str"" + register + ""String_Node_Str"";
dstAddress=reg[register];
break;
case AM_IND_AUTOINC:
if (register == 0) {
int tmp=memory[pc] + (memory[pc + 1] << 8);
MapEntry me;
if (map != null && (me=map.getEntry(tmp)) != null) {
adr=me.getName();
}
 else {
adr=""String_Node_Str"" + Utils.hex16(tmp);
}
size+=2;
}
 else {
adr=""String_Node_Str"" + register + ""String_Node_Str"";
dstAddress=reg[register];
}
break;
}
switch (instruction & 0xff80) {
case RRC:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case SWPB:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case RRA:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case SXT:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case PUSH:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case CALL:
opstr=""String_Node_Str"";
break;
case RETI:
opstr=""String_Node_Str"";
break;
default :
if ((instruction & 0xf800) == 0x1800) {
int zc=(instruction & EXTWORD_ZC) > 0 ? 1 : 0;
int al=(instruction & EXTWORD_AL) > 0 ? 1 : 0;
int rp=(instruction & EXTWORD_REPEAT) > 0 ? 1 : 0;
int shi=(instruction & EXTWORD_SRC) >> 7;
int dhi=(instruction & EXTWORD_DST);
opstr=""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ zc+ ""String_Node_Str""+ rp+ ""String_Node_Str""+ al+ ""String_Node_Str""+ shi+ ""String_Node_Str""+ dhi;
dbg.setExtWord(true);
}
 else {
System.out.println(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(startPC));
opstr=""String_Node_Str"";
}
}
output+=dumpMem(startPC,size,memory);
output+=opstr + ""String_Node_Str"" + adr;
regs=""String_Node_Str"" + register + ""String_Node_Str""+ Utils.hex16(reg[register]);
regs+=""String_Node_Str"" + Utils.hex16(reg[SP]);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
String opstr=""String_Node_Str"";
switch (instruction & 0xfc00) {
case JNE:
opstr=""String_Node_Str"";
break;
case JEQ:
opstr=""String_Node_Str"";
break;
case JNC:
opstr=""String_Node_Str"";
break;
case JC:
opstr=""String_Node_Str"";
break;
case JN:
opstr=""String_Node_Str"";
break;
case JGE:
opstr=""String_Node_Str"";
break;
case JL:
opstr=""String_Node_Str"";
break;
case JMP:
opstr=""String_Node_Str"";
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
output+=dumpMem(startPC,size,memory);
output+=opstr + ""String_Node_Str"" + Utils.hex16(jmpOffset);
regs=""String_Node_Str"" + dumpSR(reg[SR]);
break;
default :
int dstRegister=(instruction & 0xf);
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
boolean dstRegMode=((instruction >> 7) & 1) == 0;
int dstAddress=0;
int srcAddress=0;
int src=0;
int dst=0;
boolean write=false;
boolean updateStatus=true;
String srcadr=""String_Node_Str"";
String dstadr=""String_Node_Str"";
switch (as) {
case AM_REG:
if (srcRegister == CG2) {
srcadr=""String_Node_Str"";
}
 else if (srcRegister == CG1) {
srcadr=""String_Node_Str"";
}
 else {
srcadr=getRegName(srcRegister);
}
break;
case AM_INDEX:
if (srcRegister == CG1) {
srcAddress=memory[pc] + (memory[pc + 1] << 8);
MapEntry me;
if (map != null && (me=map.getEntry(srcAddress)) != null) {
srcadr=""String_Node_Str"" + me.getName();
}
 else {
srcadr=""String_Node_Str"" + Utils.hex16(srcAddress);
}
size+=2;
}
 else if (srcRegister == CG2) {
srcadr=""String_Node_Str"";
}
 else {
srcAddress=reg[srcRegister] + memory[pc] + (memory[pc + 1] << 8);
srcadr=""String_Node_Str"" + Utils.hex16(memory[pc] + (memory[pc + 1] << 8)) + ""String_Node_Str""+ srcRegister+ ""String_Node_Str"";
size+=2;
}
break;
case AM_IND_REG:
if (srcRegister == CG2) {
srcadr=""String_Node_Str"";
}
 else if (srcRegister == CG1) {
srcadr=""String_Node_Str"";
}
 else {
srcadr=""String_Node_Str"" + getRegName(srcRegister);
}
break;
case AM_IND_AUTOINC:
if (srcRegister == CG2) {
srcadr=""String_Node_Str"";
}
 else if (srcRegister == CG1) {
srcadr=""String_Node_Str"";
}
 else if (srcRegister == PC) {
srcadr=""String_Node_Str"" + Utils.hex16(memory[pc] + (memory[pc + 1] << 8));
pc+=2;
size+=2;
}
 else if (srcRegister == CG2) {
srcadr=""String_Node_Str"";
}
 else {
srcadr=""String_Node_Str"" + getRegName(srcRegister) + ""String_Node_Str"";
srcAddress=reg[srcRegister];
}
break;
}
if (dstRegMode) {
dstadr=getRegName(dstRegister);
}
 else {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
MapEntry me=map != null ? map.getEntry(dstAddress) : null;
if (dstRegister == 2) {
if (me != null) {
dstadr=""String_Node_Str"" + me.getName();
}
 else {
dstadr=""String_Node_Str"" + Utils.hex16(dstAddress);
}
}
 else {
if (me != null) {
dstadr=me.getName() + ""String_Node_Str"" + dstRegister+ ""String_Node_Str"";
}
 else {
dstadr=""String_Node_Str"" + Utils.hex16(dstAddress) + ""String_Node_Str""+ dstRegister+ ""String_Node_Str"";
}
}
pc+=2;
size+=2;
}
if (!word) {
src=src & 0xff;
dst=dst & 0xff;
}
opstr=""String_Node_Str"";
switch (op) {
case MOV:
if (instruction == 0x3041) {
opstr=""String_Node_Str"";
}
 else {
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
}
break;
case ADD:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case ADDC:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case SUBC:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case SUB:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case CMP:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case DADD:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case BIT:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case BIC:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case BIS:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case XOR:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case AND:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
default :
if (startPC > 0x200) System.out.println(output + ""String_Node_Str"" + op+ ""String_Node_Str""+ Utils.binary16(instruction)+ ""String_Node_Str""+ Utils.hex16(instruction));
}
output+=dumpMem(startPC,size,memory);
output+=opstr + ""String_Node_Str"" + srcadr+ ""String_Node_Str""+ dstadr;
regs=""String_Node_Str"" + dstRegister + ""String_Node_Str""+ Utils.hex16(reg[dstRegister])+ ""String_Node_Str""+ srcRegister+ ""String_Node_Str""+ Utils.hex16(reg[srcRegister]);
regs+=""String_Node_Str"" + dumpSR(reg[SR]);
regs+=""String_Node_Str"" + Utils.hex16(reg[SP]);
regs+=""String_Node_Str"" + as;
srcAddress&=0xffff;
if (srcAddress != -1) {
srcAddress&=0xffff;
regs+=""String_Node_Str"" + Utils.hex16(memory[srcAddress] + (memory[(srcAddress + 1) % 0xffff] << 8));
}
}
dbg.setASMLine(output);
dbg.setRegs(regs);
dbg.setInstruction(instruction,size);
if (map != null) {
dbg.setFunction(map.getFunctionName(startPC));
}
if (!step) {
String line=""String_Node_Str"";
try {
line=input.readLine();
}
 catch (Exception e) {
}
if (line != null && line.length() > 0 && line.charAt(0) == 'r') {
System.out.println(""String_Node_Str"");
for (int i=0, n=16; i < n; i++) {
System.out.print(""String_Node_Str"" + i + ""String_Node_Str""+ Utils.hex16(reg[i])+ ""String_Node_Str"");
if (i % 7 == 0 && i != 0) System.out.println();
}
System.out.println();
}
}
return dbg;
}","public DbgInstruction disassemble(int pc,int[] memory,int[] reg,DbgInstruction dbg,int interrupt){
  int startPC=pc;
  int size=0;
  int instruction=memory[pc] + (memory[pc + 1] << 8);
  int op=instruction >> 12;
  boolean word=(instruction & 0x40) == 0;
  String output=""String_Node_Str"";
  if (interrupt > 0) {
    output=""String_Node_Str"" + Integer.toString(interrupt) + ' ';
  }
  String regs=""String_Node_Str"";
  if (pc < 0x0010) {
    output+=""String_Node_Str"" + Integer.toString(pc,16);
  }
 else   if (pc < 0x0100) {
    output+=""String_Node_Str"" + Integer.toString(pc,16);
  }
 else   if (pc < 0x1000) {
    output+=""String_Node_Str"" + Integer.toString(pc,16);
  }
 else {
    output+=Integer.toString(pc,16);
  }
  output+=""String_Node_Str"";
  pc+=2;
  size+=2;
switch (op) {
case 0:
{
      String opstr=""String_Node_Str"";
      op=instruction & 0xf0f0;
      int srcdata=(instruction & 0x0f00) >> 8;
      int dst=instruction & 0x000f;
      int nextData=memory[pc] + (memory[pc + 1] << 8);
      boolean rrword=true;
switch (op) {
case MOVA_IND:
        opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ dst;
      break;
case MOVA_IND_AUTOINC:
    opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ dst;
  break;
case MOVA_ABS2REG:
opstr=""String_Node_Str"" + Utils.hex20(((srcdata << 16) | nextData)) + ""String_Node_Str""+ dst;
size+=2;
break;
case MOVA_INDX2REG:
opstr=""String_Node_Str"" + Utils.hex16(nextData) + ""String_Node_Str""+ srcdata+ ""String_Node_Str""+ dst;
size+=2;
break;
case MOVA_REG2ABS:
opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ Utils.hex20(((dst << 16) | nextData));
size+=2;
break;
case MOVA_REG2INDX:
opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ Utils.hex16(nextData)+ ""String_Node_Str""+ dst+ ""String_Node_Str"";
size+=2;
break;
case MOVA_IMM2REG:
opstr=""String_Node_Str"" + Utils.hex20(((srcdata << 16) | nextData)) + ""String_Node_Str""+ dst;
size+=2;
break;
case CMPA_IMM:
opstr=""String_Node_Str"" + Utils.hex20(((srcdata << 16) | nextData)) + ""String_Node_Str""+ dst;
size+=2;
break;
case ADDA_IMM:
opstr=""String_Node_Str"" + Utils.hex20(((srcdata << 16) | nextData)) + ""String_Node_Str""+ dst;
size+=2;
break;
case SUBA_IMM:
opstr=""String_Node_Str"" + Utils.hex20(((srcdata << 16) | nextData)) + ""String_Node_Str""+ dst;
size+=2;
break;
case MOVA_REG:
opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ dst;
break;
case CMPA_REG:
opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ dst;
break;
case ADDA_REG:
opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ dst;
break;
case SUBA_REG:
opstr=""String_Node_Str"" + srcdata + ""String_Node_Str""+ dst;
break;
case RRXX_ADDR:
rrword=false;
case RRXX_WORD:
String rrwordStr=rrword ? ""String_Node_Str"" : ""String_Node_Str"";
int count=((instruction >> 10) & 0x03) + 1;
switch (instruction & RRMASK) {
case RRCM:
opstr=""String_Node_Str"" + rrwordStr + ""String_Node_Str""+ count+ ""String_Node_Str""+ dst;
break;
case RRAM:
opstr=""String_Node_Str"" + rrwordStr + ""String_Node_Str""+ count+ ""String_Node_Str""+ dst;
break;
case RLAM:
opstr=""String_Node_Str"" + rrwordStr + ""String_Node_Str""+ count+ ""String_Node_Str""+ dst;
break;
case RRUM:
opstr=""String_Node_Str"" + rrwordStr + ""String_Node_Str""+ count+ ""String_Node_Str""+ dst;
break;
}
break;
}
output+=dumpMem(startPC,size,memory);
output+=opstr + ""String_Node_Str"";
regs=""String_Node_Str"" + srcdata + ""String_Node_Str""+ Utils.hex16(reg[srcdata]);
regs+=""String_Node_Str"" + Utils.hex16(reg[SP]);
}
break;
case 1:
{
int dst=instruction & 0x000f;
int nextData=memory[pc] + (memory[pc + 1] << 8);
String opstr=null;
switch (instruction & 0xfff0) {
case CALLA_REG:
opstr=""String_Node_Str"" + dst;
break;
case CALLA_IND:
opstr=""String_Node_Str"" + dst;
break;
case CALLA_IND_AUTOINC:
opstr=""String_Node_Str"" + dst + ""String_Node_Str"";
break;
case CALLA_ABS:
opstr=""String_Node_Str"" + Utils.hex20(((dst << 16) | nextData));
size+=2;
break;
case CALLA_EDE:
opstr=""String_Node_Str"" + Utils.hex20(((dst << 16) | nextData)) + ""String_Node_Str"";
size+=2;
break;
case CALLA_IMM:
opstr=""String_Node_Str"" + Utils.hex20(((dst << 16) | nextData));
size+=2;
break;
default :
switch (instruction & 0xff00) {
case PUSHM_A:
opstr=""String_Node_Str"" + (1 + ((instruction >> 4) & 0x0f)) + ""String_Node_Str""+ (instruction & 0x0f);
break;
case PUSHM_W:
opstr=""String_Node_Str"" + (1 + ((instruction >> 4) & 0x0f)) + ""String_Node_Str""+ (instruction & 0x0f);
break;
case POPM_A:
opstr=""String_Node_Str"" + (1 + ((instruction >> 4) & 0x0f)) + ""String_Node_Str""+ (instruction & 0x0f);
break;
case POPM_W:
opstr=""String_Node_Str"" + (1 + ((instruction >> 4) & 0x0f)) + ""String_Node_Str""+ (instruction & 0x0f);
break;
}
}
if (opstr != null) {
output+=dumpMem(startPC,size,memory);
output+=opstr + ""String_Node_Str"";
regs=""String_Node_Str"" + dst + ""String_Node_Str""+ Utils.hex16(reg[dst]);
regs+=""String_Node_Str"" + Utils.hex16(reg[SP]);
}
 else {
int register=instruction & 0xf;
int ad=(instruction >> 4) & 3;
int dstAddress=0;
String adr=""String_Node_Str"";
switch (ad) {
case AM_REG:
adr=""String_Node_Str"" + register;
break;
case AM_INDEX:
dstAddress=memory[pc] + (memory[pc + 1] << 8);
adr=""String_Node_Str"" + register + ""String_Node_Str""+ dstAddress+ ""String_Node_Str"";
dstAddress=(register == CG1 ? 0 : reg[register]) + dstAddress;
pc+=2;
size+=2;
break;
case AM_IND_REG:
adr=""String_Node_Str"" + register + ""String_Node_Str"";
dstAddress=reg[register];
break;
case AM_IND_AUTOINC:
if (register == 0) {
int tmp=memory[pc] + (memory[pc + 1] << 8);
MapEntry me;
if (map != null && (me=map.getEntry(tmp)) != null) {
adr=me.getName();
}
 else {
adr=""String_Node_Str"" + Utils.hex16(tmp);
}
size+=2;
}
 else {
adr=""String_Node_Str"" + register + ""String_Node_Str"";
dstAddress=reg[register];
}
break;
}
switch (instruction & 0xff80) {
case RRC:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case SWPB:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case RRA:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case SXT:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case PUSH:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case CALL:
opstr=""String_Node_Str"";
break;
case RETI:
opstr=""String_Node_Str"";
break;
default :
if ((instruction & 0xf800) == 0x1800) {
int zc=(instruction & EXTWORD_ZC) > 0 ? 1 : 0;
int al=(instruction & EXTWORD_AL) > 0 ? 1 : 0;
int rp=(instruction & EXTWORD_REPEAT) > 0 ? 1 : 0;
int shi=(instruction & EXTWORD_SRC) >> 7;
int dhi=(instruction & EXTWORD_DST);
opstr=""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ zc+ ""String_Node_Str""+ rp+ ""String_Node_Str""+ al+ ""String_Node_Str""+ shi+ ""String_Node_Str""+ dhi;
dbg.setExtWord(true);
}
 else {
System.out.println(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(startPC));
opstr=""String_Node_Str"";
}
}
output+=dumpMem(startPC,size,memory);
output+=opstr + ""String_Node_Str"" + adr;
regs=""String_Node_Str"" + register + ""String_Node_Str""+ Utils.hex16(reg[register]);
regs+=""String_Node_Str"" + Utils.hex16(reg[SP]);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
String opstr=""String_Node_Str"";
switch (instruction & 0xfc00) {
case JNE:
opstr=""String_Node_Str"";
break;
case JEQ:
opstr=""String_Node_Str"";
break;
case JNC:
opstr=""String_Node_Str"";
break;
case JC:
opstr=""String_Node_Str"";
break;
case JN:
opstr=""String_Node_Str"";
break;
case JGE:
opstr=""String_Node_Str"";
break;
case JL:
opstr=""String_Node_Str"";
break;
case JMP:
opstr=""String_Node_Str"";
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
output+=dumpMem(startPC,size,memory);
output+=opstr + ""String_Node_Str"" + Utils.hex16(jmpOffset);
regs=""String_Node_Str"" + dumpSR(reg[SR]);
break;
default :
int dstRegister=(instruction & 0xf);
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
boolean dstRegMode=((instruction >> 7) & 1) == 0;
int dstAddress=0;
int srcAddress=0;
int src=0;
int dst=0;
boolean write=false;
boolean updateStatus=true;
String srcadr=""String_Node_Str"";
String dstadr=""String_Node_Str"";
switch (as) {
case AM_REG:
if (srcRegister == CG2) {
srcadr=""String_Node_Str"";
}
 else if (srcRegister == CG1) {
srcadr=""String_Node_Str"";
}
 else {
srcadr=getRegName(srcRegister);
}
break;
case AM_INDEX:
if (srcRegister == CG1) {
srcAddress=memory[pc] + (memory[pc + 1] << 8);
MapEntry me;
if (map != null && (me=map.getEntry(srcAddress)) != null) {
srcadr=""String_Node_Str"" + me.getName();
}
 else {
srcadr=""String_Node_Str"" + Utils.hex16(srcAddress);
}
size+=2;
}
 else if (srcRegister == CG2) {
srcadr=""String_Node_Str"";
}
 else {
srcAddress=reg[srcRegister] + memory[pc] + (memory[pc + 1] << 8);
srcadr=""String_Node_Str"" + Utils.hex16(memory[pc] + (memory[pc + 1] << 8)) + ""String_Node_Str""+ srcRegister+ ""String_Node_Str"";
size+=2;
}
pc+=2;
break;
case AM_IND_REG:
if (srcRegister == CG2) {
srcadr=""String_Node_Str"";
}
 else if (srcRegister == CG1) {
srcadr=""String_Node_Str"";
}
 else {
srcadr=""String_Node_Str"" + getRegName(srcRegister);
}
break;
case AM_IND_AUTOINC:
if (srcRegister == CG2) {
srcadr=""String_Node_Str"";
}
 else if (srcRegister == CG1) {
srcadr=""String_Node_Str"";
}
 else if (srcRegister == PC) {
srcadr=""String_Node_Str"" + Utils.hex16(memory[pc] + (memory[pc + 1] << 8));
pc+=2;
size+=2;
}
 else if (srcRegister == CG2) {
srcadr=""String_Node_Str"";
}
 else {
srcadr=""String_Node_Str"" + getRegName(srcRegister) + ""String_Node_Str"";
srcAddress=reg[srcRegister];
}
break;
}
if (dstRegMode) {
dstadr=getRegName(dstRegister);
}
 else {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
MapEntry me=map != null ? map.getEntry(dstAddress) : null;
if (dstRegister == 2) {
if (me != null) {
dstadr=""String_Node_Str"" + me.getName();
}
 else {
dstadr=""String_Node_Str"" + Utils.hex16(dstAddress);
}
}
 else {
if (me != null) {
dstadr=me.getName() + ""String_Node_Str"" + dstRegister+ ""String_Node_Str"";
}
 else {
dstadr=""String_Node_Str"" + Utils.hex16(dstAddress) + ""String_Node_Str""+ dstRegister+ ""String_Node_Str"";
}
}
pc+=2;
size+=2;
}
if (!word) {
src=src & 0xff;
dst=dst & 0xff;
}
opstr=""String_Node_Str"";
switch (op) {
case MOV:
if (instruction == 0x3041) {
opstr=""String_Node_Str"";
}
 else {
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
}
break;
case ADD:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case ADDC:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case SUBC:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case SUB:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case CMP:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case DADD:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case BIT:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case BIC:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case BIS:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case XOR:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case AND:
opstr=""String_Node_Str"" + (word ? ""String_Node_Str"" : ""String_Node_Str"");
break;
default :
if (startPC > 0x200) System.out.println(output + ""String_Node_Str"" + op+ ""String_Node_Str""+ Utils.binary16(instruction)+ ""String_Node_Str""+ Utils.hex16(instruction));
}
output+=dumpMem(startPC,size,memory);
output+=opstr + ""String_Node_Str"" + srcadr+ ""String_Node_Str""+ dstadr;
regs=""String_Node_Str"" + dstRegister + ""String_Node_Str""+ Utils.hex16(reg[dstRegister])+ ""String_Node_Str""+ srcRegister+ ""String_Node_Str""+ Utils.hex16(reg[srcRegister]);
regs+=""String_Node_Str"" + dumpSR(reg[SR]);
regs+=""String_Node_Str"" + Utils.hex16(reg[SP]);
regs+=""String_Node_Str"" + as;
srcAddress&=0xffff;
if (srcAddress != -1) {
srcAddress&=0xffff;
regs+=""String_Node_Str"" + Utils.hex16(memory[srcAddress] + (memory[(srcAddress + 1) % 0xffff] << 8));
}
}
dbg.setASMLine(output);
dbg.setRegs(regs);
dbg.setInstruction(instruction,size);
if (map != null) {
dbg.setFunction(map.getFunctionName(startPC));
}
if (!step) {
String line=""String_Node_Str"";
try {
line=input.readLine();
}
 catch (Exception e) {
}
if (line != null && line.length() > 0 && line.charAt(0) == 'r') {
System.out.println(""String_Node_Str"");
for (int i=0, n=16; i < n; i++) {
System.out.print(""String_Node_Str"" + i + ""String_Node_Str""+ Utils.hex16(reg[i])+ ""String_Node_Str"");
if (i % 7 == 0 && i != 0) System.out.println();
}
System.out.println();
}
}
return dbg;
}",0.999725802029065
5488,"private static String dumpMem(int pc,int size,int[] memory){
  String output=""String_Node_Str"";
  for (int i=0, n=4; i < n; i++) {
    if (size > i) {
      output+=Utils.hex8(memory[pc + i]) + ""String_Node_Str"";
    }
 else {
      output+=""String_Node_Str"";
    }
  }
  return output;
}","private static String dumpMem(int pc,int size,int[] memory){
  String output=""String_Node_Str"";
  for (int i=0, n=size; i < n; i++) {
    if (size > i) {
      output+=Utils.hex8(memory[pc + i]) + ""String_Node_Str"";
    }
 else {
      output+=""String_Node_Str"";
    }
  }
  return output;
}",0.9913644214162348
5489,"public synchronized void removeChart(Chart chart){
  charts=(Chart[])ArrayUtils.remove(charts,chart);
}","public synchronized void removeChart(Chart chart){
  charts=ArrayUtils.remove(charts,chart);
}",0.9543147208121828
5490,"public synchronized void addChart(Chart chart){
  charts=(Chart[])ArrayUtils.add(Chart.class,charts,chart);
}","public synchronized void addChart(Chart chart){
  charts=ArrayUtils.add(Chart.class,charts,chart);
}",0.9569377990430622
5491,"public StackUI(MSP430 cpu,int updateCyclePeriod){
  super(new BorderLayout());
  this.updateCyclePeriod=updateCyclePeriod;
  this.cpu=cpu;
  if (cpu.getDisAsm() != null) {
    MapTable mapTable=cpu.getDisAsm().getMap();
    if (mapTable != null) {
      this.heapStartAddress=mapTable.heapStartAddress;
      this.stackStartAddress=mapTable.stackStartAddress;
    }
  }
}","public StackUI(MSP430 cpu,int updateCyclePeriod){
  super(new BorderLayout());
  this.updateCyclePeriod=updateCyclePeriod;
  this.cpu=cpu;
}",0.547945205479452
5492,"@Override public void notifyWriteBefore(int type,int adr,int data){
  int size=((stackStartAddress - data) + 0xffff) % 0xffff;
  if (minData[pos] > size) {
    minData[pos]=size;
  }
  if (maxData[pos] < size) {
    maxData[pos]=size;
  }
  if (cpu.cpuCycles - lastCycles > updateCyclePeriod) {
    lastCycles=cpu.cpuCycles;
    pos=(pos + 1) % minData.length;
    minData[pos]=Integer.MAX_VALUE;
    maxData[pos]=0;
    update=true;
    repaint();
  }
}","@Override public void notifyWriteBefore(int register,int data,int mode){
  int size=stackStartAddress - data;
  if (minData[pos] > size) {
    minData[pos]=size;
  }
  if (maxData[pos] < size) {
    maxData[pos]=size;
  }
  if (cpu.cpuCycles - lastCycles > updateCyclePeriod) {
    lastCycles=cpu.cpuCycles;
    pos=(pos + 1) % minData.length;
    minData[pos]=Integer.MAX_VALUE;
    maxData[pos]=0;
    update=true;
    repaint();
  }
}",0.9450056116722784
5493,"private void setup(){
  if (chartPanel != null)   return;
  chartPanel=new ChartPanel();
  ConstantLineChart maxChart=new ConstantLineChart(""String_Node_Str"",this.stackStartAddress - this.heapStartAddress);
  maxChart.setConfig(""String_Node_Str"",Color.red);
  chartPanel.addChart(maxChart);
  minStackChart=new LineChart(""String_Node_Str"");
  minStackChart.setConfig(""String_Node_Str"",Color.green);
  chartPanel.addChart(minStackChart);
  maxStackChart=new LineChart(""String_Node_Str"");
  maxStackChart.setConfig(""String_Node_Str"",Color.green);
  chartPanel.addChart(maxStackChart);
  chartPanel.setAxisChart(maxStackChart);
  add(chartPanel,BorderLayout.CENTER);
  chartPanel.setMinimumSize(new Dimension(320,200));
  setPreferredSize(new Dimension(320,200));
  setSize(320,200);
  setMinimumSize(new Dimension(320,200));
  WindowManager wm=registry.getComponent(WindowManager.class);
  if (wm != null) {
    window=wm.createWindow(""String_Node_Str"");
    window.add(this);
  }
  registerMonitor=new RegisterMonitor.Adapter(){
    @Override public void notifyWriteBefore(    int type,    int adr,    int data){
      int size=((stackStartAddress - data) + 0xffff) % 0xffff;
      if (minData[pos] > size) {
        minData[pos]=size;
      }
      if (maxData[pos] < size) {
        maxData[pos]=size;
      }
      if (cpu.cpuCycles - lastCycles > updateCyclePeriod) {
        lastCycles=cpu.cpuCycles;
        pos=(pos + 1) % minData.length;
        minData[pos]=Integer.MAX_VALUE;
        maxData[pos]=0;
        update=true;
        repaint();
      }
    }
  }
;
}","private void setup(){
  if (chartPanel != null)   return;
  if (this.heapStartAddress < 0 && cpu.getDisAsm() != null) {
    MapTable mapTable=cpu.getDisAsm().getMap();
    if (mapTable != null) {
      this.heapStartAddress=mapTable.heapStartAddress;
      this.stackStartAddress=mapTable.stackStartAddress;
    }
  }
  if (this.stackStartAddress < 0) {
    this.stackStartAddress=cpu.config.ramStart + cpu.config.ramSize;
  }
  chartPanel=new ChartPanel();
  if (this.stackStartAddress > 0 && this.heapStartAddress > 0) {
    ConstantLineChart maxChart=new ConstantLineChart(""String_Node_Str"",this.stackStartAddress - this.heapStartAddress);
    maxChart.setConfig(""String_Node_Str"",Color.red);
    chartPanel.addChart(maxChart);
  }
  minStackChart=new LineChart(""String_Node_Str"");
  minStackChart.setConfig(""String_Node_Str"",Color.green);
  chartPanel.addChart(minStackChart);
  maxStackChart=new LineChart(""String_Node_Str"");
  maxStackChart.setConfig(""String_Node_Str"",Color.green);
  chartPanel.addChart(maxStackChart);
  chartPanel.setAxisChart(maxStackChart);
  add(chartPanel,BorderLayout.CENTER);
  chartPanel.setMinimumSize(new Dimension(320,200));
  setPreferredSize(new Dimension(320,200));
  setSize(320,200);
  setMinimumSize(new Dimension(320,200));
  WindowManager wm=registry.getComponent(WindowManager.class);
  if (wm != null) {
    window=wm.createWindow(""String_Node_Str"");
    window.add(this);
  }
  registerMonitor=new RegisterMonitor.Adapter(){
    @Override public void notifyWriteBefore(    int register,    int data,    int mode){
      int size=stackStartAddress - data;
      if (minData[pos] > size) {
        minData[pos]=size;
      }
      if (maxData[pos] < size) {
        maxData[pos]=size;
      }
      if (cpu.cpuCycles - lastCycles > updateCyclePeriod) {
        lastCycles=cpu.cpuCycles;
        pos=(pos + 1) % minData.length;
        minData[pos]=Integer.MAX_VALUE;
        maxData[pos]=0;
        update=true;
        repaint();
      }
    }
  }
;
}",0.8617886178861789
5494,"public MSP430Core(int type,ComponentRegistry registry,MSP430Config config){
  super(""String_Node_Str"",""String_Node_Str"",null);
  MAX_INTERRUPT=config.maxInterruptVector;
  MAX_MEM_IO=config.maxMemIO;
  MAX_MEM=config.maxMem;
  MSP430XArch=config.MSP430XArch;
  memory=new int[MAX_MEM];
  memorySegments=new Memory[MAX_MEM >> 8];
  flash=new Flash(this,memory,new FlashRange(config.mainFlashStart,config.mainFlashStart + config.mainFlashSize,512,64),new FlashRange(config.infoMemStart,config.infoMemStart + config.infoMemSize,128,64),config.flashControllerOffset);
  currentSegment=new Memory(){
    @Override public int read(    int address,    AccessMode mode,    AccessType type) throws EmulationException {
      if (address >= MAX_MEM) {
        throw new EmulationException(""String_Node_Str"" + MSP430Core.this.config.getAddressAsString(address));
      }
      return memorySegments[address >> 8].read(address,mode,type);
    }
    @Override public void write(    int dstAddress,    int data,    AccessMode mode) throws EmulationException {
      if (dstAddress >= MAX_MEM) {
        throw new EmulationException(""String_Node_Str"" + MSP430Core.this.config.getAddressAsString(dstAddress));
      }
      memorySegments[dstAddress >> 8].write(dstAddress,data,mode);
    }
    @Override public int get(    int address,    AccessMode mode){
      if (address >= MAX_MEM) {
        throw new EmulationException(""String_Node_Str"" + MSP430Core.this.config.getAddressAsString(address));
      }
      return memorySegments[address >> 8].get(address,mode);
    }
    @Override public void set(    int address,    int data,    AccessMode mode){
      if (address >= MAX_MEM) {
        throw new EmulationException(""String_Node_Str"" + MSP430Core.this.config.getAddressAsString(address));
      }
      memorySegments[address >> 8].set(address,data,mode);
    }
  }
;
  IOUnit voidIO=new IOUnit(""String_Node_Str"",cpu,memory,0){
    public void interruptServiced(    int vector){
    }
    public void write(    int address,    int value,    boolean word,    long cycles){
      logw(""String_Node_Str"" + Utils.hex(address,4));
    }
    public int read(    int address,    boolean word,    long cycles){
      logw(""String_Node_Str"" + Utils.hex(address,4));
      return 0;
    }
  }
;
  int maxSeg=MAX_MEM >> 8;
  Memory ramSegment=new RAMSegment(this);
  Memory flashSegment=new FlashSegment(this,flash);
  IOSegment ioSegment=new IOSegment(this,MAX_MEM_IO,voidIO);
  Memory noMemorySegment=new NoMemSegment(this);
  for (int i=0; i < maxSeg; i++) {
    if (config.isRAM(i << 8)) {
      memorySegments[i]=ramSegment;
    }
 else     if (config.isFlash(i << 8) || config.isInfoMem(i << 8)) {
      memorySegments[i]=flashSegment;
    }
 else     if (config.isIO(i << 8)) {
      memorySegments[i]=ioSegment;
    }
 else {
      memorySegments[i]=noMemorySegment;
    }
  }
  this.registry=registry;
  this.config=config;
  addChip(this);
  setModeNames(MODE_NAMES);
  ioUnits=new ArrayList<IOUnit>();
  ioSegment.setIORange(config.flashControllerOffset,6,flash);
  sfr=new SFR(this,memory);
  ioSegment.setIORange(config.sfrOffset,0x10,sfr);
  Timer[] timers=new Timer[config.timerConfig.length];
  for (int i=0; i < config.timerConfig.length; i++) {
    Timer t=new Timer(this,memory,config.timerConfig[i]);
    ioSegment.setIORange(config.timerConfig[i].offset,0x20,t);
    ioSegment.setIORange(config.timerConfig[i].timerIVAddr,1,t);
    timers[i]=t;
  }
  bcs=config.createClockSystem(this,memory,timers);
  ioSegment.setIORange(bcs.getAddressRangeMin(),bcs.getAddressRangeMax() - bcs.getAddressRangeMin() + 1,bcs);
  ioUnits.add(sfr);
  ioUnits.add(bcs);
  config.setup(this,ioUnits);
  for (int i=0; i < timers.length; i++) {
    ioUnits.add(timers[i]);
  }
  watchdog=new Watchdog(this);
  ioSegment.setIORange(config.watchdogOffset,1,watchdog);
  ioUnits.add(watchdog);
  bcs.reset(0);
}","public MSP430Core(int type,ComponentRegistry registry,MSP430Config config){
  super(""String_Node_Str"",""String_Node_Str"",null);
  MAX_INTERRUPT=config.maxInterruptVector;
  MAX_MEM_IO=config.maxMemIO;
  MAX_MEM=config.maxMem;
  MSP430XArch=config.MSP430XArch;
  memory=new int[MAX_MEM];
  memorySegments=new Memory[MAX_MEM >> 8];
  flash=new Flash(this,memory,new FlashRange(config.mainFlashStart,config.mainFlashStart + config.mainFlashSize,512,64),new FlashRange(config.infoMemStart,config.infoMemStart + config.infoMemSize,128,64),config.flashControllerOffset);
  currentSegment=new Memory(){
    @Override public int read(    int address,    AccessMode mode,    AccessType type) throws EmulationException {
      if (address >= MAX_MEM) {
        throw new EmulationException(""String_Node_Str"" + Utils.hex(address,4));
      }
      return memorySegments[address >> 8].read(address,mode,type);
    }
    @Override public void write(    int address,    int data,    AccessMode mode) throws EmulationException {
      if (address >= MAX_MEM) {
        throw new EmulationException(""String_Node_Str"" + Utils.hex(address,4));
      }
      memorySegments[address >> 8].write(address,data,mode);
    }
    @Override public int get(    int address,    AccessMode mode){
      if (address >= MAX_MEM) {
        throw new EmulationException(""String_Node_Str"" + Utils.hex(address,4));
      }
      return memorySegments[address >> 8].get(address,mode);
    }
    @Override public void set(    int address,    int data,    AccessMode mode){
      if (address >= MAX_MEM) {
        throw new EmulationException(""String_Node_Str"" + Utils.hex(address,4));
      }
      memorySegments[address >> 8].set(address,data,mode);
    }
  }
;
  IOUnit voidIO=new IOUnit(""String_Node_Str"",cpu,memory,0){
    public void interruptServiced(    int vector){
    }
    public void write(    int address,    int value,    boolean word,    long cycles){
      logw(""String_Node_Str"" + Utils.hex(address,4));
    }
    public int read(    int address,    boolean word,    long cycles){
      logw(""String_Node_Str"" + Utils.hex(address,4));
      return 0;
    }
  }
;
  int maxSeg=MAX_MEM >> 8;
  Memory ramSegment=new RAMSegment(this);
  Memory flashSegment=new FlashSegment(this,flash);
  IOSegment ioSegment=new IOSegment(this,MAX_MEM_IO,voidIO);
  Memory noMemorySegment=new NoMemSegment(this);
  for (int i=0; i < maxSeg; i++) {
    if (config.isRAM(i << 8)) {
      memorySegments[i]=ramSegment;
    }
 else     if (config.isFlash(i << 8) || config.isInfoMem(i << 8)) {
      memorySegments[i]=flashSegment;
    }
 else     if (config.isIO(i << 8)) {
      memorySegments[i]=ioSegment;
    }
 else {
      memorySegments[i]=noMemorySegment;
    }
  }
  this.registry=registry;
  this.config=config;
  addChip(this);
  setModeNames(MODE_NAMES);
  ioUnits=new ArrayList<IOUnit>();
  ioSegment.setIORange(config.flashControllerOffset,6,flash);
  sfr=new SFR(this,memory);
  ioSegment.setIORange(config.sfrOffset,0x10,sfr);
  Timer[] timers=new Timer[config.timerConfig.length];
  for (int i=0; i < config.timerConfig.length; i++) {
    Timer t=new Timer(this,memory,config.timerConfig[i]);
    ioSegment.setIORange(config.timerConfig[i].offset,0x20,t);
    ioSegment.setIORange(config.timerConfig[i].timerIVAddr,1,t);
    timers[i]=t;
  }
  bcs=config.createClockSystem(this,memory,timers);
  ioSegment.setIORange(bcs.getAddressRangeMin(),bcs.getAddressRangeMax() - bcs.getAddressRangeMin() + 1,bcs);
  ioUnits.add(sfr);
  ioUnits.add(bcs);
  config.setup(this,ioUnits);
  for (int i=0; i < timers.length; i++) {
    ioUnits.add(timers[i]);
  }
  watchdog=new Watchdog(this);
  ioSegment.setIORange(config.watchdogOffset,1,watchdog);
  ioUnits.add(watchdog);
  bcs.reset(0);
}",0.9624493000130838
5495,"@Override public int get(int address,AccessMode mode){
  if (address >= MAX_MEM) {
    throw new EmulationException(""String_Node_Str"" + MSP430Core.this.config.getAddressAsString(address));
  }
  return memorySegments[address >> 8].get(address,mode);
}","@Override public int get(int address,AccessMode mode){
  if (address >= MAX_MEM) {
    throw new EmulationException(""String_Node_Str"" + Utils.hex(address,4));
  }
  return memorySegments[address >> 8].get(address,mode);
}",0.8601694915254238
5496,"@Override public void set(int address,int data,AccessMode mode){
  if (address >= MAX_MEM) {
    throw new EmulationException(""String_Node_Str"" + MSP430Core.this.config.getAddressAsString(address));
  }
  memorySegments[address >> 8].set(address,data,mode);
}","@Override public void set(int address,int data,AccessMode mode){
  if (address >= MAX_MEM) {
    throw new EmulationException(""String_Node_Str"" + Utils.hex(address,4));
  }
  memorySegments[address >> 8].set(address,data,mode);
}",0.8647540983606558
5497,"public int emulateOP(long maxCycles) throws EmulationException {
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff || flash.blocksCPU()) {
    while (cycles >= nextEventCycles) {
      executeEvents();
    }
    if (interruptsEnabled && interruptMax > 0) {
      return -1;
    }
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return -1;
  }
  int pcBefore=pc;
  instruction=currentSegment.read(pc,AccessMode.WORD,AccessType.EXECUTE);
  if (isStopping) {
    return -2;
  }
  int ext3_0=0;
  int ext10_7=0;
  boolean repeatsInDstReg=false;
  boolean wordx20=false;
  if ((instruction & 0xf800) == 0x1800) {
    extWord=instruction;
    ext3_0=instruction & 0xf;
    ext10_7=(instruction >> 7) & 0xf;
    pc+=2;
    if ((instruction & 0x80) == 0x80) {
      repeatsInDstReg=true;
    }
    wordx20=(instruction & 0x40) == 0;
    instruction=currentSegment.read(pc,AccessMode.WORD,AccessType.EXECUTE);
  }
 else {
    extWord=0;
  }
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  int rval=0;
  int repeats=1;
  boolean zeroCarry=false;
  boolean word=(instruction & 0x40) == 0;
  AccessMode mode=wordx20 ? AccessMode.WORD20 : (word ? AccessMode.WORD : AccessMode.BYTE);
  if (mode == AccessMode.WORD20)   System.out.println(""String_Node_Str"");
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 0:
    op=instruction & 0xf0f0;
  if (!MSP430XArch)   throw new EmulationException(""String_Node_Str"");
int src=0;
int srcData=(instruction & 0x0f00) >> 8;
int dstData=(instruction & 0x000f);
boolean rrword=true;
mode=AccessMode.WORD20;
switch (op) {
case MOVA_IND:
writeRegister(dstData,currentSegment.read(readRegister(srcData),AccessMode.WORD20,AccessType.READ));
updateStatus=false;
cycles+=3;
break;
case MOVA_IND_AUTOINC:
if (profiler != null && instruction == 0x0110) {
profiler.profileReturn(cpuCycles);
}
writeRegister(PC,pc);
src=readRegister(srcData);
dst=currentSegment.read(src,AccessMode.WORD20,AccessType.READ);
writeRegister(srcData,src + 4);
writeRegister(dstData,dst);
updateStatus=false;
cycles+=3;
break;
case MOVA_ABS2REG:
src=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
writeRegister(PC,pc+=2);
dst=src + (srcData << 16);
dst=currentSegment.read(dst,AccessMode.WORD20,AccessType.READ);
writeRegister(dstData,dst);
updateStatus=false;
cycles+=4;
break;
case MOVA_INDX2REG:
int index=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
int indexModifier=readRegister(srcData);
if (index > 0x8000) {
index=-(0x10000 - index);
}
if (indexModifier > 0x8000) {
indexModifier=-(0x10000 - indexModifier);
}
writeRegister(dstData,currentSegment.read(indexModifier + index,AccessMode.WORD20,AccessType.READ));
writeRegister(PC,pc+=2);
updateStatus=false;
cycles+=4;
break;
case MOVA_REG2ABS:
dst=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
writeRegister(PC,pc+=2);
currentSegment.write(dst + (dstData << 16),readRegister(srcData),AccessMode.WORD20);
updateStatus=false;
cycles+=4;
break;
case MOVA_REG2INDX:
index=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
indexModifier=readRegister(dstData);
if (index > 0x8000) {
index=-(0x10000 - index);
}
if (indexModifier > 0x8000) {
indexModifier=-(0x10000 - indexModifier);
}
currentSegment.write(indexModifier + index,readRegister(srcData),AccessMode.WORD20);
writeRegister(PC,pc+=2);
updateStatus=false;
cycles+=4;
break;
case MOVA_IMM2REG:
src=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
writeRegister(PC,pc+=2);
dst=src + (srcData << 16);
dst&=0xfffff;
writeRegister(dstData,dst);
updateStatus=false;
cycles+=2;
break;
case ADDA_IMM:
int immData=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + (srcData << 16);
writeRegister(PC,pc+=2);
dst=readRegister(dstData) + immData;
System.out.println(""String_Node_Str"" + Utils.hex20(immData) + ""String_Node_Str""+ Utils.hex20(dst));
dst&=0xfffff;
writeRegister(dstData,dst);
cycles+=3;
break;
case CMPA_IMM:
{
immData=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + (srcData << 16);
writeRegister(PC,pc+=2);
sr=readRegister(SR);
int destRegValue=readRegister(dstData);
sr&=~(NEGATIVE | ZERO | CARRY| OVERFLOW);
if (destRegValue >= immData) {
sr|=CARRY;
}
if (destRegValue < immData) {
sr|=NEGATIVE;
}
if (destRegValue == immData) {
sr|=ZERO;
}
int cmpTmp=destRegValue - immData;
int b=0x80000;
if (((destRegValue ^ cmpTmp) & b) == 0 && (((destRegValue ^ immData) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
updateStatus=false;
cycles+=3;
break;
}
case SUBA_IMM:
immData=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + (srcData << 16);
writeRegister(PC,pc+=2);
dst=readRegister(dstData) - immData;
writeRegister(dstData,dst);
cycles+=3;
break;
case MOVA_REG:
cycles+=1;
writeRegister(dstData,readRegister(srcData));
break;
case CMPA_REG:
{
sr=readRegister(SR);
sr&=~(NEGATIVE | ZERO | CARRY| OVERFLOW);
int destRegValue=readRegister(dstData);
int srcRegValue=readRegister(srcData);
if (destRegValue >= srcRegValue) {
sr|=CARRY;
}
if (destRegValue < srcRegValue) {
sr|=NEGATIVE;
}
if (destRegValue == srcRegValue) {
sr|=ZERO;
}
int cmpTmp=destRegValue - srcRegValue;
int b=0x80000;
if (((destRegValue ^ cmpTmp) & b) == 0 && (((destRegValue ^ srcRegValue) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
updateStatus=false;
cycles+=1;
break;
}
case ADDA_REG:
dst=readRegister(dstData) + readRegister(srcData);
writeRegister(dstData,dst);
cycles+=1;
break;
case SUBA_REG:
dst=readRegister(dstData) - readRegister(srcData);
writeRegister(dstData,dst);
cycles+=1;
break;
case RRXX_ADDR:
rrword=false;
case RRXX_WORD:
int count=((instruction >> 10) & 0x03) + 1;
dst=readRegister(dstData);
sr=readRegister(SR);
int nxtCarry=0;
int carry=(sr & CARRY) > 0 ? 1 : 0;
if (rrword) {
mode=AccessMode.WORD;
dst=dst & 0xffff;
}
cycles+=1 + count;
switch (instruction & RRMASK) {
case RRCM:
int dst_low=dst & ((1 << count) - 1);
nxtCarry=(dst & (1 << (count + 1))) > 0 ? CARRY : 0;
dst=dst >> (count);
if (rrword) {
dst|=(dst_low << (17 - count)) | (carry << (16 - count));
}
 else {
dst|=(dst_low << (21 - count)) | (carry << (20 - count));
}
break;
case RRAM:
if ((dst & (rrword ? 0x8000 : 0x80000)) > 0) {
dst=dst | (rrword ? 0xf8000 : 0xf80000);
}
dst=dst >> (count - 1);
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
break;
case RLAM:
dst=dst << (count - 1);
nxtCarry=(dst & (rrword ? 0x8000 : 0x80000)) > 0 ? CARRY : 0;
dst=dst << 1;
break;
case RRUM:
dst=dst >> (count - 1);
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
break;
}
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
dst=dst & (rrword ? 0xffff : 0xfffff);
writeRegister(dstData,dst);
break;
default :
System.out.println(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
throw new EmulationException(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
}
break;
case 1:
{
dstRegister=instruction & 0xf;
if ((op=instruction & CALLA_MASK) > RETI) {
pc=readRegister(PC);
dst=-1;
updateStatus=false;
switch (op) {
case CALLA_REG:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
dst=readRegister(dstRegister);
System.out.println(""String_Node_Str"" + Utils.hex20(dst));
cycles+=5;
break;
case CALLA_INDEX:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
System.out.println(""String_Node_Str"" + dstRegister);
dst=readRegister(dstRegister);
System.out.println(""String_Node_Str"" + Utils.hex20(dst) + ""String_Node_Str""+ currentSegment.read(pc,AccessMode.WORD,AccessType.READ));
dst+=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
System.out.println(""String_Node_Str"" + Utils.hex20(dst));
dst=currentSegment.read(dst,AccessMode.WORD20,AccessType.READ);
System.out.println(""String_Node_Str"" + Utils.hex20(dst));
cycles+=5;
pc+=2;
break;
case CALLA_IMM:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
dst=(dstRegister << 16) | currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
pc+=2;
cycles+=5;
break;
case CALLA_ABS:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
dst=(dstRegister << 16) | currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
dst=currentSegment.read(dst,AccessMode.WORD20,AccessType.READ);
pc+=2;
cycles+=7;
break;
default :
AccessMode type=AccessMode.WORD;
int size=2;
sp=readRegister(SP);
switch (op & 0x1f00) {
case PUSHM_A:
type=AccessMode.WORD20;
size=4;
cycles+=2;
case PUSHM_W:
int n=1 + ((instruction >> 4) & 0x0f);
int regNo=instruction & 0x0f;
for (int i=0; i < n; i++) {
sp-=size;
cycles+=2;
currentSegment.write(sp,this.reg[regNo--],type);
if (regNo < 0) regNo=15;
}
writeRegister(SP,sp);
break;
case POPM_A:
type=AccessMode.WORD20;
size=4;
cycles+=2;
case POPM_W:
n=1 + ((instruction >> 4) & 0x0f);
regNo=instruction & 0x0f;
for (int i=0; i < n; i++) {
cycles+=2;
this.reg[regNo++]=currentSegment.read(sp,type,AccessType.READ);
sp+=size;
if (regNo > 15) regNo=0;
}
writeRegister(SP,sp);
break;
default :
System.out.println(""String_Node_Str"");
throw new EmulationException(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
}
}
if (dst != -1) {
currentSegment.write(sp,(pc >> 16) & 0xf,AccessMode.WORD);
sp=sp - 2;
currentSegment.write(sp,pc & 0xffff,AccessMode.WORD);
writeRegister(SP,sp);
writeRegister(PC,dst);
if (profiler != null) {
profileCall(dst,pc);
}
}
}
 else {
int ad=(instruction >> 4) & 3;
int nxtCarry=0;
op=instruction & 0xff80;
if (op == PUSH || op == CALL) {
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
}
if ((dstRegister == CG1 && ad > AM_INDEX) || dstRegister == CG2) {
dstRegMode=true;
cycles++;
}
 else {
switch (ad) {
case AM_REG:
dstRegMode=true;
cycles++;
break;
case AM_INDEX:
rval=readRegisterCG(dstRegister,ad);
if (rval <= 0xffff) {
dstAddress=(rval + currentSegment.read(pc,AccessMode.WORD,AccessType.READ)) & 0xffff;
}
 else {
dstAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + mode.bytes);
}
cycles+=3;
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
dst&=mode.mask;
if (repeatsInDstReg) {
repeats=1 + readRegister(ext3_0);
}
 else {
repeats=1 + ext3_0;
}
zeroCarry=(extWord & EXTWORD_ZC) > 0;
}
 else {
dst=currentSegment.read(dstAddress,word ? AccessMode.WORD : AccessMode.BYTE,AccessType.READ);
}
while (repeats-- > 0) {
sr=readRegister(SR);
if (repeats >= 0) {
if (zeroCarry) {
sr=sr & ~CARRY;
}
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
dst|=(sr & CARRY) > 0 ? mode.msb : 0;
write=true;
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=(dst & mode.msb) | dst >> 1;
write=true;
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xfff00 : dst & 0x7f;
write=true;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case PUSH:
if (word) {
currentSegment.write(sp,dst,AccessMode.WORD);
}
 else {
currentSegment.write(sp,dst & 0xff,AccessMode.WORD);
}
cycles+=(ad == AM_REG || ad == AM_IND_AUTOINC) ? 2 : 1;
write=false;
updateStatus=false;
break;
case CALL:
pc=readRegister(PC);
currentSegment.write(sp,pc,AccessMode.WORD);
writeRegister(PC,dst);
cycles+=(ad == AM_REG) ? 3 : (ad == AM_IND_AUTOINC) ? 2 : 1;
if (profiler != null) {
profileCall(dst,pc);
}
write=false;
updateStatus=false;
break;
case RETI:
servicedInterrupt=-1;
sp=readRegister(SP);
sr=currentSegment.read(sp,AccessMode.WORD,AccessType.READ);
writeRegister(SR,sr & 0x0fff);
sp=sp + 2;
writeRegister(PC,currentSegment.read(sp,AccessMode.WORD,AccessType.READ) | (sr & 0xf000) << 4);
sp=sp + 2;
writeRegister(SP,sp);
write=false;
updateStatus=false;
cycles+=4;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
if (profiler != null) {
profiler.profileRETI(cycles);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + Utils.hex16(instruction));
}
if (repeats > 0) {
dst&=mode.mask;
}
}
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
logw(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
updateStatus=false;
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
src=0;
if ((srcRegister == CG1 && as > AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
src&=mode.mask;
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
src&=mode.mask;
cycles+=dstRegMode ? 1 : 4;
if (dstRegister == PC) cycles++;
if (dstRegMode) {
if (repeatsInDstReg) {
repeats=1 + readRegister(ext3_0);
}
 else {
repeats=1 + ext3_0;
}
zeroCarry=(extWord & EXTWORD_ZC) > 0;
}
break;
case AM_INDEX:
{
int sval=readRegisterCG(srcRegister,as);
if (sval <= 0xffff) {
srcAddress=(sval + currentSegment.read(pc,AccessMode.WORD,AccessType.READ)) & 0xffff;
}
 else {
srcAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
if ((srcAddress & 0x8000) > 0) {
srcAddress|=0xf0000;
}
srcAddress+=sval;
srcAddress&=0xfffff;
}
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
}
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=dstRegMode ? 2 : 5;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,mode.bytes);
cycles+=dstRegMode ? 2 : 5;
}
if (dstRegister == PC) {
cycles++;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
dst&=mode.mask;
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
}
 else {
rval=readRegister(dstRegister);
if (rval <= 0xffff) {
dstAddress=(rval + currentSegment.read(pc,AccessMode.WORD,AccessType.READ)) & 0xffff;
}
 else {
dstAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
}
if (op != MOV) {
dst=currentSegment.read(dstAddress,word ? AccessMode.WORD : AccessMode.BYTE,AccessType.READ);
}
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
src=currentSegment.read(srcAddress,mode,AccessType.READ);
}
while (repeats-- > 0) {
sr=readRegister(SR);
if (repeats >= 0) {
if (zeroCarry) {
sr=sr & ~CARRY;
}
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
if (instruction == RETURN && profiler != null) {
profiler.profileReturn(cpuCycles);
}
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((sr & CARRY) > 0) ? 1 : 0;
case ADD:
sr&=~(OVERFLOW | CARRY);
int b=word ? 0x8000 : (wordx20 ? 0x80000 : 0x80);
tmp=(src ^ dst) & b;
dst=dst + src + tmpAdd;
int b2=word ? 0xffff : (wordx20 ? 0xfffff : 0xff);
if (dst > b2) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & b) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
b=mode.msb;
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=(dst - src);
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) log(""String_Node_Str"");
dst=dst + src + ((sr & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
sr=sr & ~(CARRY | OVERFLOW);
b=mode.msb;
if ((src & b) != 0 && (dst & b) != 0) {
sr|=OVERFLOW;
}
dst=src ^ dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
case AND:
sr=sr & ~(CARRY | OVERFLOW);
dst=src & dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
default :
String address=getAddressAsString(pc);
logw(""String_Node_Str"" + Integer.toHexString(op) + ""String_Node_Str""+ address);
if (EXCEPTION_ON_BAD_OPERATION) {
EmulationException ex=new EmulationException(""String_Node_Str"" + Integer.toHexString(op) + ""String_Node_Str""+ address);
ex.initCause(new Throwable(""String_Node_Str"" + pc));
throw ex;
}
}
if (repeats > 0 && srcRegister == dstRegister) {
src=dst;
src&=mode.mask;
}
}
}
dst&=mode.mask;
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
currentSegment.write(dstAddress,dst,mode);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | ((dst & mode.msb) > 0 ? NEGATIVE : 0);
writeRegister(SR,sr);
}
while (cycles >= nextEventCycles) {
executeEvents();
}
cpuCycles+=cycles - startCycles;
return pcBefore;
}","public int emulateOP(long maxCycles) throws EmulationException {
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff || flash.blocksCPU()) {
    while (cycles >= nextEventCycles) {
      executeEvents();
    }
    if (interruptsEnabled && interruptMax > 0) {
      return -1;
    }
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return -1;
  }
  int pcBefore=pc;
  instruction=currentSegment.read(pc,AccessMode.WORD,AccessType.EXECUTE);
  if (isStopping) {
    return -2;
  }
  int ext3_0=0;
  int ext10_7=0;
  boolean repeatsInDstReg=false;
  boolean wordx20=false;
  if ((instruction & 0xf800) == 0x1800) {
    extWord=instruction;
    ext3_0=instruction & 0xf;
    ext10_7=(instruction >> 7) & 0xf;
    pc+=2;
    if ((instruction & 0x80) == 0x80) {
      repeatsInDstReg=true;
    }
    wordx20=(instruction & 0x40) == 0;
    instruction=currentSegment.read(pc,AccessMode.WORD,AccessType.EXECUTE);
  }
 else {
    extWord=0;
  }
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  int rval=0;
  int repeats=1;
  boolean zeroCarry=false;
  boolean word=(instruction & 0x40) == 0;
  AccessMode mode=wordx20 ? AccessMode.WORD20 : (word ? AccessMode.WORD : AccessMode.BYTE);
  if (mode == AccessMode.WORD20)   System.out.println(""String_Node_Str"");
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 0:
    op=instruction & 0xf0f0;
  if (!MSP430XArch)   throw new EmulationException(""String_Node_Str"");
int src=0;
int srcData=(instruction & 0x0f00) >> 8;
int dstData=(instruction & 0x000f);
boolean rrword=true;
mode=AccessMode.WORD20;
switch (op) {
case MOVA_IND:
writeRegister(dstData,currentSegment.read(readRegister(srcData),AccessMode.WORD20,AccessType.READ));
updateStatus=false;
cycles+=3;
break;
case MOVA_IND_AUTOINC:
if (profiler != null && instruction == 0x0110) {
profiler.profileReturn(cpuCycles);
}
writeRegister(PC,pc);
src=readRegister(srcData);
dst=currentSegment.read(src,AccessMode.WORD20,AccessType.READ);
writeRegister(srcData,src + 4);
writeRegister(dstData,dst);
updateStatus=false;
cycles+=3;
break;
case MOVA_ABS2REG:
src=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
writeRegister(PC,pc+=2);
dst=src + (srcData << 16);
dst=currentSegment.read(dst,AccessMode.WORD20,AccessType.READ);
writeRegister(dstData,dst);
updateStatus=false;
cycles+=4;
break;
case MOVA_INDX2REG:
int index=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
int indexModifier=readRegister(srcData);
if (index > 0x8000) {
index=-(0x10000 - index);
}
if (indexModifier > 0x8000) {
indexModifier=-(0x10000 - indexModifier);
}
writeRegister(dstData,currentSegment.read(indexModifier + index,AccessMode.WORD20,AccessType.READ));
writeRegister(PC,pc+=2);
updateStatus=false;
cycles+=4;
break;
case MOVA_REG2ABS:
dst=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
writeRegister(PC,pc+=2);
currentSegment.write(dst + (dstData << 16),readRegister(srcData),AccessMode.WORD20);
updateStatus=false;
cycles+=4;
break;
case MOVA_REG2INDX:
index=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
indexModifier=readRegister(dstData);
if (index > 0x8000) {
index=-(0x10000 - index);
}
if (indexModifier > 0x8000) {
indexModifier=-(0x10000 - indexModifier);
}
currentSegment.write(indexModifier + index,readRegister(srcData),AccessMode.WORD20);
writeRegister(PC,pc+=2);
updateStatus=false;
cycles+=4;
break;
case MOVA_IMM2REG:
src=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
writeRegister(PC,pc+=2);
dst=src + (srcData << 16);
dst&=0xfffff;
writeRegister(dstData,dst);
updateStatus=false;
cycles+=2;
break;
case ADDA_IMM:
int immData=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + (srcData << 16);
writeRegister(PC,pc+=2);
dst=readRegister(dstData) + immData;
System.out.println(""String_Node_Str"" + Utils.hex20(immData) + ""String_Node_Str""+ Utils.hex20(dst));
dst&=0xfffff;
writeRegister(dstData,dst);
cycles+=3;
break;
case CMPA_IMM:
{
immData=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + (srcData << 16);
writeRegister(PC,pc+=2);
sr=readRegister(SR);
int destRegValue=readRegister(dstData);
sr&=~(NEGATIVE | ZERO | CARRY| OVERFLOW);
if (destRegValue >= immData) {
sr|=CARRY;
}
if (destRegValue < immData) {
sr|=NEGATIVE;
}
if (destRegValue == immData) {
sr|=ZERO;
}
int cmpTmp=destRegValue - immData;
int b=0x80000;
if (((destRegValue ^ cmpTmp) & b) == 0 && (((destRegValue ^ immData) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
updateStatus=false;
cycles+=3;
break;
}
case SUBA_IMM:
immData=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + (srcData << 16);
writeRegister(PC,pc+=2);
dst=readRegister(dstData) - immData;
writeRegister(dstData,dst);
cycles+=3;
break;
case MOVA_REG:
cycles+=1;
writeRegister(dstData,readRegister(srcData));
break;
case CMPA_REG:
{
sr=readRegister(SR);
sr&=~(NEGATIVE | ZERO | CARRY| OVERFLOW);
int destRegValue=readRegister(dstData);
int srcRegValue=readRegister(srcData);
if (destRegValue >= srcRegValue) {
sr|=CARRY;
}
if (destRegValue < srcRegValue) {
sr|=NEGATIVE;
}
if (destRegValue == srcRegValue) {
sr|=ZERO;
}
int cmpTmp=destRegValue - srcRegValue;
int b=0x80000;
if (((destRegValue ^ cmpTmp) & b) == 0 && (((destRegValue ^ srcRegValue) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
updateStatus=false;
cycles+=1;
break;
}
case ADDA_REG:
dst=readRegister(dstData) + readRegister(srcData);
writeRegister(dstData,dst);
cycles+=1;
break;
case SUBA_REG:
dst=readRegister(dstData) - readRegister(srcData);
writeRegister(dstData,dst);
cycles+=1;
break;
case RRXX_ADDR:
rrword=false;
case RRXX_WORD:
int count=((instruction >> 10) & 0x03) + 1;
dst=readRegister(dstData);
sr=readRegister(SR);
int nxtCarry=0;
int carry=(sr & CARRY) > 0 ? 1 : 0;
if (rrword) {
mode=AccessMode.WORD;
dst=dst & 0xffff;
}
cycles+=1 + count;
switch (instruction & RRMASK) {
case RRCM:
int dst_low=dst & ((1 << count) - 1);
nxtCarry=(dst & (1 << (count + 1))) > 0 ? CARRY : 0;
dst=dst >> (count);
if (rrword) {
dst|=(dst_low << (17 - count)) | (carry << (16 - count));
}
 else {
dst|=(dst_low << (21 - count)) | (carry << (20 - count));
}
break;
case RRAM:
if ((dst & (rrword ? 0x8000 : 0x80000)) > 0) {
dst=dst | (rrword ? 0xf8000 : 0xf80000);
}
dst=dst >> (count - 1);
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
break;
case RLAM:
dst=dst << (count - 1);
nxtCarry=(dst & (rrword ? 0x8000 : 0x80000)) > 0 ? CARRY : 0;
dst=dst << 1;
break;
case RRUM:
dst=dst >> (count - 1);
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
break;
}
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
dst=dst & (rrword ? 0xffff : 0xfffff);
writeRegister(dstData,dst);
break;
default :
System.out.println(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
throw new EmulationException(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
}
break;
case 1:
{
dstRegister=instruction & 0xf;
if ((op=instruction & CALLA_MASK) > RETI) {
pc=readRegister(PC);
dst=-1;
updateStatus=false;
switch (op) {
case CALLA_REG:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
dst=readRegister(dstRegister);
System.out.println(""String_Node_Str"" + Utils.hex20(dst));
cycles+=5;
break;
case CALLA_INDEX:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
System.out.println(""String_Node_Str"" + dstRegister);
dst=readRegister(dstRegister);
System.out.println(""String_Node_Str"" + Utils.hex20(dst) + ""String_Node_Str""+ currentSegment.read(pc,AccessMode.WORD,AccessType.READ));
dst+=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
System.out.println(""String_Node_Str"" + Utils.hex20(dst));
dst=currentSegment.read(dst,AccessMode.WORD20,AccessType.READ);
System.out.println(""String_Node_Str"" + Utils.hex20(dst));
cycles+=5;
pc+=2;
break;
case CALLA_IMM:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
dst=(dstRegister << 16) | currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
pc+=2;
cycles+=5;
break;
case CALLA_ABS:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
dst=(dstRegister << 16) | currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
dst=currentSegment.read(dst,AccessMode.WORD20,AccessType.READ);
pc+=2;
cycles+=7;
break;
default :
AccessMode type=AccessMode.WORD;
int size=2;
sp=readRegister(SP);
switch (op & 0x1f00) {
case PUSHM_A:
type=AccessMode.WORD20;
size=4;
cycles+=2;
case PUSHM_W:
int n=1 + ((instruction >> 4) & 0x0f);
int regNo=instruction & 0x0f;
for (int i=0; i < n; i++) {
sp-=size;
cycles+=2;
currentSegment.write(sp,this.reg[regNo--],type);
if (regNo < 0) regNo=15;
}
writeRegister(SP,sp);
break;
case POPM_A:
type=AccessMode.WORD20;
size=4;
cycles+=2;
case POPM_W:
n=1 + ((instruction >> 4) & 0x0f);
regNo=instruction & 0x0f;
for (int i=0; i < n; i++) {
cycles+=2;
this.reg[regNo++]=currentSegment.read(sp,type,AccessType.READ);
sp+=size;
if (regNo > 15) regNo=0;
}
writeRegister(SP,sp);
break;
default :
System.out.println(""String_Node_Str"");
throw new EmulationException(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
}
}
if (dst != -1) {
currentSegment.write(sp,(pc >> 16) & 0xf,AccessMode.WORD);
sp=sp - 2;
currentSegment.write(sp,pc & 0xffff,AccessMode.WORD);
writeRegister(SP,sp);
writeRegister(PC,dst);
if (profiler != null) {
profileCall(dst,pc);
}
}
}
 else {
int ad=(instruction >> 4) & 3;
int nxtCarry=0;
op=instruction & 0xff80;
if (op == PUSH || op == CALL) {
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
}
if ((dstRegister == CG1 && ad > AM_INDEX) || dstRegister == CG2) {
dstRegMode=true;
cycles++;
}
 else {
switch (ad) {
case AM_REG:
dstRegMode=true;
cycles++;
break;
case AM_INDEX:
rval=readRegisterCG(dstRegister,ad);
if (rval <= 0xffff) {
dstAddress=(rval + currentSegment.read(pc,AccessMode.WORD,AccessType.READ)) & 0xffff;
}
 else {
dstAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + mode.bytes);
}
cycles+=3;
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
dst&=mode.mask;
if (repeatsInDstReg) {
repeats=1 + readRegister(ext3_0);
}
 else {
repeats=1 + ext3_0;
}
zeroCarry=(extWord & EXTWORD_ZC) > 0;
}
 else {
dst=currentSegment.read(dstAddress,word ? AccessMode.WORD : AccessMode.BYTE,AccessType.READ);
}
while (repeats-- > 0) {
sr=readRegister(SR);
if (repeats >= 0) {
if (zeroCarry) {
sr=sr & ~CARRY;
}
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
dst|=(sr & CARRY) > 0 ? mode.msb : 0;
write=true;
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=(dst & mode.msb) | dst >> 1;
write=true;
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xfff00 : dst & 0x7f;
write=true;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case PUSH:
if (mode == AccessMode.WORD) {
currentSegment.write(sp,dst,AccessMode.WORD);
}
 else {
currentSegment.write(sp,dst & 0xff,AccessMode.WORD);
}
cycles+=(ad == AM_REG || ad == AM_IND_AUTOINC) ? 2 : 1;
write=false;
updateStatus=false;
break;
case CALL:
pc=readRegister(PC);
currentSegment.write(sp,pc,AccessMode.WORD);
writeRegister(PC,dst);
cycles+=(ad == AM_REG) ? 3 : (ad == AM_IND_AUTOINC) ? 2 : 1;
if (profiler != null) {
profileCall(dst,pc);
}
write=false;
updateStatus=false;
break;
case RETI:
servicedInterrupt=-1;
sp=readRegister(SP);
sr=currentSegment.read(sp,AccessMode.WORD,AccessType.READ);
writeRegister(SR,sr & 0x0fff);
sp=sp + 2;
writeRegister(PC,currentSegment.read(sp,AccessMode.WORD,AccessType.READ) | (sr & 0xf000) << 4);
sp=sp + 2;
writeRegister(SP,sp);
write=false;
updateStatus=false;
cycles+=4;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
if (profiler != null) {
profiler.profileRETI(cycles);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + Utils.hex16(instruction));
}
if (repeats > 0) {
dst&=mode.mask;
}
}
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
logw(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
updateStatus=false;
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
src=0;
if ((srcRegister == CG1 && as > AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
src&=mode.mask;
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
src&=mode.mask;
cycles+=dstRegMode ? 1 : 4;
if (dstRegister == PC) cycles++;
if (dstRegMode) {
if (repeatsInDstReg) {
repeats=1 + readRegister(ext3_0);
}
 else {
repeats=1 + ext3_0;
}
zeroCarry=(extWord & EXTWORD_ZC) > 0;
}
break;
case AM_INDEX:
{
int sval=readRegisterCG(srcRegister,as);
if (sval <= 0xffff) {
srcAddress=(sval + currentSegment.read(pc,AccessMode.WORD,AccessType.READ)) & 0xffff;
}
 else {
srcAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
if ((srcAddress & 0x8000) > 0) {
srcAddress|=0xf0000;
}
srcAddress+=sval;
srcAddress&=0xfffff;
}
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
}
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=dstRegMode ? 2 : 5;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,mode.bytes);
cycles+=dstRegMode ? 2 : 5;
}
if (dstRegister == PC) {
cycles++;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
dst&=mode.mask;
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
}
 else {
rval=readRegister(dstRegister);
if (rval <= 0xffff) {
dstAddress=(rval + currentSegment.read(pc,AccessMode.WORD,AccessType.READ)) & 0xffff;
}
 else {
dstAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
}
if (op != MOV) {
dst=currentSegment.read(dstAddress,word ? AccessMode.WORD : AccessMode.BYTE,AccessType.READ);
}
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
src=currentSegment.read(srcAddress,mode,AccessType.READ);
}
while (repeats-- > 0) {
sr=readRegister(SR);
if (repeats >= 0) {
if (zeroCarry) {
sr=sr & ~CARRY;
}
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
if (instruction == RETURN && profiler != null) {
profiler.profileReturn(cpuCycles);
}
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((sr & CARRY) > 0) ? 1 : 0;
case ADD:
sr&=~(OVERFLOW | CARRY);
int b=word ? 0x8000 : (wordx20 ? 0x80000 : 0x80);
tmp=(src ^ dst) & b;
dst=dst + src + tmpAdd;
int b2=word ? 0xffff : (wordx20 ? 0xfffff : 0xff);
if (dst > b2) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & b) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
b=mode.msb;
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=(dst - src);
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) log(""String_Node_Str"");
dst=dst + src + ((sr & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
sr=sr & ~(CARRY | OVERFLOW);
b=mode.msb;
if ((src & b) != 0 && (dst & b) != 0) {
sr|=OVERFLOW;
}
dst=src ^ dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
case AND:
sr=sr & ~(CARRY | OVERFLOW);
dst=src & dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
default :
String address=getAddressAsString(pc);
logw(""String_Node_Str"" + Integer.toHexString(op) + ""String_Node_Str""+ address);
if (EXCEPTION_ON_BAD_OPERATION) {
EmulationException ex=new EmulationException(""String_Node_Str"" + Integer.toHexString(op) + ""String_Node_Str""+ address);
ex.initCause(new Throwable(""String_Node_Str"" + pc));
throw ex;
}
}
if (repeats > 0 && srcRegister == dstRegister) {
src=dst;
src&=mode.mask;
}
}
}
dst&=mode.mask;
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
currentSegment.write(dstAddress,dst,mode);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | ((dst & mode.msb) > 0 ? NEGATIVE : 0);
writeRegister(SR,sr);
}
while (cycles >= nextEventCycles) {
executeEvents();
}
cpuCycles+=cycles - startCycles;
return pcBefore;
}",0.9992531326934248
5498,"public int emulateOP(long maxCycles) throws EmulationException {
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff || flash.blocksCPU()) {
    while (cycles >= nextEventCycles) {
      executeEvents();
    }
    if (interruptsEnabled && interruptMax > 0) {
      return -1;
    }
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return -1;
  }
  int pcBefore=pc;
  instruction=currentSegment.read(pc,AccessMode.WORD,AccessType.EXECUTE);
  if (isStopping) {
    return -2;
  }
  int ext3_0=0;
  int ext10_7=0;
  int extSrc=0;
  int extDst=0;
  boolean repeatsInDstReg=false;
  boolean wordx20=false;
  if ((instruction & 0xf800) == 0x1800) {
    extWord=instruction;
    ext3_0=instruction & 0xf;
    ext10_7=(instruction >> 7) & 0xf;
    extSrc=ext10_7 << 16;
    extDst=ext3_0 << 16;
    pc+=2;
    if ((instruction & 0x80) == 0x80) {
      repeatsInDstReg=true;
    }
    wordx20=(instruction & 0x40) == 0;
    instruction=currentSegment.read(pc,AccessMode.WORD,AccessType.EXECUTE);
  }
 else {
    extWord=0;
  }
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  int rval=0;
  int repeats=1;
  boolean zeroCarry=false;
  boolean word=(instruction & 0x40) == 0;
  AccessMode mode=wordx20 ? AccessMode.WORD20 : (word ? AccessMode.WORD : AccessMode.BYTE);
  if (mode == AccessMode.WORD20)   System.out.println(""String_Node_Str"");
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=-1;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 0:
    op=instruction & 0xf0f0;
  if (!MSP430XArch)   throw new EmulationException(""String_Node_Str"");
int src=0;
int srcData=(instruction & 0x0f00) >> 8;
int dstData=(instruction & 0x000f);
boolean rrword=true;
mode=AccessMode.WORD20;
switch (op) {
case MOVA_IND:
writeRegister(dstData,currentSegment.read(readRegister(srcData),AccessMode.WORD20,AccessType.READ));
updateStatus=false;
cycles+=3;
break;
case MOVA_IND_AUTOINC:
if (profiler != null && instruction == 0x0110) {
profiler.profileReturn(cpuCycles);
}
writeRegister(PC,pc);
src=readRegister(srcData);
dst=currentSegment.read(src,AccessMode.WORD20,AccessType.READ);
writeRegister(srcData,src + 4);
writeRegister(dstData,dst);
updateStatus=false;
cycles+=3;
break;
case MOVA_ABS2REG:
src=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
writeRegister(PC,pc+=2);
dst=src + (srcData << 16);
dst=currentSegment.read(dst,AccessMode.WORD20,AccessType.READ);
writeRegister(dstData,dst);
updateStatus=false;
cycles+=4;
break;
case MOVA_INDX2REG:
int index=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
int indexModifier=readRegister(srcData);
if (index > 0x8000) {
index=-(0x10000 - index);
}
if (indexModifier > 0x8000) {
indexModifier=-(0x10000 - indexModifier);
}
writeRegister(dstData,currentSegment.read(indexModifier + index,AccessMode.WORD20,AccessType.READ));
writeRegister(PC,pc+=2);
updateStatus=false;
cycles+=4;
break;
case MOVA_REG2ABS:
dst=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
writeRegister(PC,pc+=2);
currentSegment.write(dst + (dstData << 16),readRegister(srcData),AccessMode.WORD20);
updateStatus=false;
cycles+=4;
break;
case MOVA_REG2INDX:
index=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
indexModifier=readRegister(dstData);
if (index > 0x8000) {
index=-(0x10000 - index);
}
if (indexModifier > 0x8000) {
indexModifier=-(0x10000 - indexModifier);
}
currentSegment.write(indexModifier + index,readRegister(srcData),AccessMode.WORD20);
writeRegister(PC,pc+=2);
updateStatus=false;
cycles+=4;
break;
case MOVA_IMM2REG:
src=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
writeRegister(PC,pc+=2);
dst=src + (srcData << 16);
dst&=0xfffff;
writeRegister(dstData,dst);
updateStatus=false;
cycles+=2;
break;
case ADDA_IMM:
int immData=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + (srcData << 16);
writeRegister(PC,pc+=2);
dst=readRegister(dstData) + immData;
dst&=0xfffff;
writeRegister(dstData,dst);
cycles+=3;
break;
case CMPA_IMM:
{
immData=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + (srcData << 16);
writeRegister(PC,pc+=2);
sr=readRegister(SR);
int destRegValue=readRegister(dstData);
sr&=~(NEGATIVE | ZERO | CARRY| OVERFLOW);
if (destRegValue >= immData) {
sr|=CARRY;
}
if (destRegValue < immData) {
sr|=NEGATIVE;
}
if (destRegValue == immData) {
sr|=ZERO;
}
int cmpTmp=destRegValue - immData;
int b=0x80000;
if (((destRegValue ^ cmpTmp) & b) == 0 && (((destRegValue ^ immData) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
updateStatus=false;
cycles+=3;
break;
}
case SUBA_IMM:
immData=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + (srcData << 16);
writeRegister(PC,pc+=2);
dst=readRegister(dstData) - immData;
writeRegister(dstData,dst);
cycles+=3;
break;
case MOVA_REG:
cycles+=1;
writeRegister(dstData,readRegisterCG(srcData,0));
break;
case CMPA_REG:
{
sr=readRegister(SR);
sr&=~(NEGATIVE | ZERO | CARRY| OVERFLOW);
int destRegValue=readRegister(dstData);
int srcRegValue=readRegisterCG(srcData,0);
if (destRegValue >= srcRegValue) {
sr|=CARRY;
}
if (destRegValue < srcRegValue) {
sr|=NEGATIVE;
}
if (destRegValue == srcRegValue) {
sr|=ZERO;
}
int cmpTmp=destRegValue - srcRegValue;
int b=0x80000;
if (((destRegValue ^ cmpTmp) & b) == 0 && (((destRegValue ^ srcRegValue) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
updateStatus=false;
cycles+=1;
break;
}
case ADDA_REG:
dst=readRegister(dstData) + readRegisterCG(srcData,2);
writeRegister(dstData,dst);
cycles+=1;
break;
case SUBA_REG:
dst=readRegister(dstData) - readRegisterCG(srcData,2);
writeRegister(dstData,dst);
cycles+=1;
break;
case RRXX_ADDR:
rrword=false;
case RRXX_WORD:
int count=((instruction >> 10) & 0x03) + 1;
dst=readRegister(dstData);
sr=readRegister(SR);
int nxtCarry=0;
int carry=(sr & CARRY) > 0 ? 1 : 0;
if (rrword) {
mode=AccessMode.WORD;
dst=dst & 0xffff;
}
cycles+=1 + count;
switch (instruction & RRMASK) {
case RRCM:
int dst_low=dst & ((1 << count) - 1);
nxtCarry=(dst & (1 << (count + 1))) > 0 ? CARRY : 0;
dst=dst >> (count);
if (rrword) {
dst|=(dst_low << (17 - count)) | (carry << (16 - count));
}
 else {
dst|=(dst_low << (21 - count)) | (carry << (20 - count));
}
break;
case RRAM:
if ((dst & (rrword ? 0x8000 : 0x80000)) > 0) {
dst=dst | (rrword ? 0xf8000 : 0xf80000);
}
dst=dst >> (count - 1);
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
break;
case RLAM:
dst=dst << (count - 1);
nxtCarry=(dst & (rrword ? 0x8000 : 0x80000)) > 0 ? CARRY : 0;
dst=dst << 1;
break;
case RRUM:
dst=dst >> (count - 1);
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
break;
}
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
dst=dst & (rrword ? 0xffff : 0xfffff);
writeRegister(dstData,dst);
break;
default :
System.out.println(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
throw new EmulationException(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
}
break;
case 1:
{
dstRegister=instruction & 0xf;
if ((op=instruction & CALLA_MASK) > RETI) {
pc=readRegister(PC);
dst=-1;
updateStatus=false;
switch (op) {
case CALLA_REG:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
dst=readRegister(dstRegister);
System.out.println(""String_Node_Str"" + Utils.hex20(dst));
cycles+=5;
break;
case CALLA_INDEX:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
System.out.println(""String_Node_Str"" + dstRegister);
dst=readRegister(dstRegister);
int v=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
if ((v & 0x8000) != 0) {
v|=0xf0000;
}
System.out.println(""String_Node_Str"" + Utils.hex20(dst) + ""String_Node_Str""+ v);
dst+=v;
dst&=0xfffff;
System.out.println(""String_Node_Str"" + Utils.hex20(dst));
dst=currentSegment.read(dst,AccessMode.WORD20,AccessType.READ);
System.out.println(""String_Node_Str"" + Utils.hex20(dst));
cycles+=5;
pc+=2;
break;
case CALLA_IMM:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
dst=(dstRegister << 16) | currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
pc+=2;
cycles+=5;
break;
case CALLA_IND:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
dstAddress=readRegister(dstRegister);
dst=currentSegment.read(dstAddress,AccessMode.WORD20,AccessType.READ);
pc+=2;
cycles+=5;
break;
case CALLA_ABS:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
dst=(dstRegister << 16) | currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
dst=currentSegment.read(dst,AccessMode.WORD20,AccessType.READ);
pc+=2;
cycles+=7;
break;
default :
AccessMode type=AccessMode.WORD;
int size=2;
sp=readRegister(SP);
switch (op & 0x1f00) {
case PUSHM_A:
type=AccessMode.WORD20;
size=4;
cycles+=2;
case PUSHM_W:
int n=1 + ((instruction >> 4) & 0x0f);
int regNo=instruction & 0x0f;
for (int i=0; i < n; i++) {
sp-=size;
cycles+=2;
currentSegment.write(sp,this.reg[regNo--],type);
if (regNo < 0) regNo=15;
}
writeRegister(SP,sp);
break;
case POPM_A:
type=AccessMode.WORD20;
size=4;
cycles+=2;
case POPM_W:
n=1 + ((instruction >> 4) & 0x0f);
regNo=instruction & 0x0f;
for (int i=0; i < n; i++) {
cycles+=2;
this.reg[regNo++]=currentSegment.read(sp,type,AccessType.READ);
sp+=size;
if (regNo > 15) regNo=0;
}
writeRegister(SP,sp);
break;
default :
System.out.println(""String_Node_Str"");
throw new EmulationException(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
}
}
if (dst != -1) {
currentSegment.write(sp,(pc >> 16) & 0xf,AccessMode.WORD);
sp=sp - 2;
currentSegment.write(sp,pc & 0xffff,AccessMode.WORD);
writeRegister(SP,sp);
writeRegister(PC,dst);
if (profiler != null) {
profileCall(dst,pc);
}
}
}
 else {
int ad=(instruction >> 4) & 3;
int nxtCarry=0;
op=instruction & 0xff80;
if (op == PUSH || op == CALL) {
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
}
if ((dstRegister == CG1 && ad > AM_INDEX) || dstRegister == CG2) {
dstRegMode=true;
cycles++;
}
 else {
switch (ad) {
case AM_REG:
dstRegMode=true;
cycles++;
break;
case AM_INDEX:
rval=readRegisterCG(dstRegister,ad);
if (extWord != 0) {
dstAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + extDst;
dstAddress+=rval;
dstAddress&=0xfffff;
}
 else if (rval <= 0xffff) {
dstAddress=(rval + currentSegment.read(pc,AccessMode.WORD,AccessType.READ)) & 0xffff;
}
 else {
dstAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=pc;
dst=currentSegment.read(dstAddress,mode != AccessMode.BYTE ? AccessMode.WORD : AccessMode.BYTE,AccessType.READ);
dst+=extDst;
pc+=2;
writeRegister(PC,pc);
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + mode.bytes);
}
cycles+=3;
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
dst&=mode.mask;
if (repeatsInDstReg) {
repeats=1 + readRegister(ext3_0);
}
 else {
repeats=1 + ext3_0;
}
zeroCarry=(extWord & EXTWORD_ZC) > 0;
}
 else if (dst == -1) {
dst=currentSegment.read(dstAddress,mode,AccessType.READ);
}
while (repeats-- > 0) {
sr=readRegister(SR);
if (repeats >= 0) {
if (zeroCarry) {
sr=sr & ~CARRY;
}
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
dst|=(sr & CARRY) > 0 ? mode.msb : 0;
write=true;
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=(dst & mode.msb) | dst >> 1;
write=true;
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xfff00 : dst & 0x7f;
write=true;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case PUSH:
if (mode == AccessMode.WORD20) {
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
}
currentSegment.write(sp,dst,mode);
cycles+=(ad == AM_REG || ad == AM_IND_AUTOINC) ? 2 : 1;
write=false;
updateStatus=false;
break;
case CALL:
pc=readRegister(PC);
currentSegment.write(sp,pc,AccessMode.WORD);
writeRegister(PC,dst);
cycles+=(ad == AM_REG) ? 3 : (ad == AM_IND_AUTOINC) ? 2 : 1;
if (profiler != null) {
profileCall(dst,pc);
}
write=false;
updateStatus=false;
break;
case RETI:
servicedInterrupt=-1;
sp=readRegister(SP);
sr=currentSegment.read(sp,AccessMode.WORD,AccessType.READ);
writeRegister(SR,sr & 0x0fff);
sp=sp + 2;
writeRegister(PC,currentSegment.read(sp,AccessMode.WORD,AccessType.READ) | (sr & 0xf000) << 4);
sp=sp + 2;
writeRegister(SP,sp);
write=false;
updateStatus=false;
cycles+=4;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
if (profiler != null) {
profiler.profileRETI(cycles);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + Utils.hex16(instruction));
}
if (repeats > 0) {
dst&=mode.mask;
}
}
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
logw(WarningType.EMULATION_ERROR,""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
updateStatus=false;
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
src=0;
if ((srcRegister == CG1 && as > AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
src&=mode.mask;
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
src&=mode.mask;
cycles+=dstRegMode ? 1 : 4;
if (dstRegister == PC) cycles++;
if (dstRegMode) {
if (repeatsInDstReg) {
repeats=1 + readRegister(ext3_0);
}
 else {
repeats=1 + ext3_0;
}
zeroCarry=(extWord & EXTWORD_ZC) > 0;
}
break;
case AM_INDEX:
{
int sval=readRegisterCG(srcRegister,as);
if (extWord != 0) {
srcAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + extSrc;
srcAddress+=sval;
srcAddress&=0xfffff;
}
 else if (sval <= 0xffff) {
srcAddress=(sval + currentSegment.read(pc,AccessMode.WORD,AccessType.READ)) & 0xffff;
}
 else {
srcAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
if ((srcAddress & 0x8000) > 0) {
srcAddress|=0xf0000;
}
srcAddress+=sval;
srcAddress&=0xfffff;
}
pc+=2;
writeRegister(PC,pc);
cycles+=dstRegMode ? 3 : 6;
break;
}
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
src=currentSegment.read(pc,mode != AccessMode.BYTE ? AccessMode.WORD : AccessMode.BYTE,AccessType.READ);
src+=extSrc;
pc+=2;
writeRegister(PC,pc);
cycles+=dstRegMode ? 2 : 5;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,mode.bytes);
cycles+=dstRegMode ? 2 : 5;
}
if (dstRegister == PC) {
cycles++;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
dst&=mode.mask;
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
}
 else {
rval=readRegister(dstRegister);
if (rval <= 0xffff) {
dstAddress=(rval + currentSegment.read(pc,AccessMode.WORD,AccessType.READ)) & 0xffff;
}
 else {
dstAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
}
if (op != MOV) {
dst=currentSegment.read(dstAddress,word ? AccessMode.WORD : AccessMode.BYTE,AccessType.READ);
}
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
src=currentSegment.read(srcAddress,mode,AccessType.READ);
}
while (repeats-- > 0) {
sr=readRegister(SR);
if (repeats >= 0) {
if (zeroCarry) {
sr=sr & ~CARRY;
}
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
if (instruction == RETURN && profiler != null) {
profiler.profileReturn(cpuCycles);
}
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((sr & CARRY) > 0) ? 1 : 0;
case ADD:
sr&=~(OVERFLOW | CARRY);
int b=word ? 0x8000 : (wordx20 ? 0x80000 : 0x80);
tmp=(src ^ dst) & b;
dst=dst + src + tmpAdd;
int b2=word ? 0xffff : (wordx20 ? 0xfffff : 0xff);
if (dst > b2) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & b) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
b=mode.msb;
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=(dst - src);
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) log(""String_Node_Str"");
dst=dst + src + ((sr & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
sr=sr & ~(CARRY | OVERFLOW);
b=mode.msb;
if ((src & b) != 0 && (dst & b) != 0) {
sr|=OVERFLOW;
}
dst=src ^ dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
case AND:
sr=sr & ~(CARRY | OVERFLOW);
dst=src & dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
default :
String address=getAddressAsString(pc);
logw(WarningType.EMULATION_ERROR,""String_Node_Str"" + Integer.toHexString(op) + ""String_Node_Str""+ address);
if (EXCEPTION_ON_BAD_OPERATION) {
EmulationException ex=new EmulationException(""String_Node_Str"" + Integer.toHexString(op) + ""String_Node_Str""+ address);
ex.initCause(new Throwable(""String_Node_Str"" + pc));
throw ex;
}
}
if (repeats > 0 && srcRegister == dstRegister) {
src=dst;
src&=mode.mask;
}
}
}
dst&=mode.mask;
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
currentSegment.write(dstAddress,dst,mode);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | ((dst & mode.msb) > 0 ? NEGATIVE : 0);
writeRegister(SR,sr);
}
while (cycles >= nextEventCycles) {
executeEvents();
}
cpuCycles+=cycles - startCycles;
return pcBefore;
}","public int emulateOP(long maxCycles) throws EmulationException {
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff || flash.blocksCPU()) {
    while (cycles >= nextEventCycles) {
      executeEvents();
    }
    if (interruptsEnabled && interruptMax > 0) {
      return -1;
    }
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return -1;
  }
  int pcBefore=pc;
  instruction=currentSegment.read(pc,AccessMode.WORD,AccessType.EXECUTE);
  if (isStopping) {
    return -2;
  }
  int ext3_0=0;
  int ext10_7=0;
  int extSrc=0;
  int extDst=0;
  boolean repeatsInDstReg=false;
  boolean wordx20=false;
  if ((instruction & 0xf800) == 0x1800) {
    extWord=instruction;
    ext3_0=instruction & 0xf;
    ext10_7=(instruction >> 7) & 0xf;
    extSrc=ext10_7 << 16;
    extDst=ext3_0 << 16;
    pc+=2;
    if ((instruction & 0x80) == 0x80) {
      repeatsInDstReg=true;
    }
    wordx20=(instruction & 0x40) == 0;
    instruction=currentSegment.read(pc,AccessMode.WORD,AccessType.EXECUTE);
  }
 else {
    extWord=0;
  }
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  int rval=0;
  int repeats=1;
  boolean zeroCarry=false;
  boolean word=(instruction & 0x40) == 0;
  AccessMode mode=wordx20 ? AccessMode.WORD20 : (word ? AccessMode.WORD : AccessMode.BYTE);
  if (mode == AccessMode.WORD20)   System.out.println(""String_Node_Str"");
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=-1;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 0:
    op=instruction & 0xf0f0;
  if (!MSP430XArch)   throw new EmulationException(""String_Node_Str"");
int src=0;
int srcData=(instruction & 0x0f00) >> 8;
int dstData=(instruction & 0x000f);
boolean rrword=true;
mode=AccessMode.WORD20;
switch (op) {
case MOVA_IND:
writeRegister(dstData,currentSegment.read(readRegister(srcData),AccessMode.WORD20,AccessType.READ));
updateStatus=false;
cycles+=3;
break;
case MOVA_IND_AUTOINC:
if (profiler != null && instruction == 0x0110) {
profiler.profileReturn(cpuCycles);
}
writeRegister(PC,pc);
src=readRegister(srcData);
dst=currentSegment.read(src,AccessMode.WORD20,AccessType.READ);
writeRegister(srcData,src + 4);
writeRegister(dstData,dst);
updateStatus=false;
cycles+=3;
break;
case MOVA_ABS2REG:
src=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
writeRegister(PC,pc+=2);
dst=src + (srcData << 16);
dst=currentSegment.read(dst,AccessMode.WORD20,AccessType.READ);
writeRegister(dstData,dst);
updateStatus=false;
cycles+=4;
break;
case MOVA_INDX2REG:
int index=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
int indexModifier=readRegister(srcData);
if (index > 0x8000) {
index=-(0x10000 - index);
}
writeRegister(dstData,currentSegment.read(indexModifier + index,AccessMode.WORD20,AccessType.READ));
writeRegister(PC,pc+=2);
updateStatus=false;
cycles+=4;
break;
case MOVA_REG2ABS:
dst=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
writeRegister(PC,pc+=2);
currentSegment.write(dst + (dstData << 16),readRegister(srcData),AccessMode.WORD20);
updateStatus=false;
cycles+=4;
break;
case MOVA_REG2INDX:
index=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
indexModifier=readRegister(dstData);
if (index > 0x8000) {
index=-(0x10000 - index);
}
currentSegment.write(indexModifier + index,readRegister(srcData),AccessMode.WORD20);
writeRegister(PC,pc+=2);
updateStatus=false;
cycles+=4;
break;
case MOVA_IMM2REG:
src=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
writeRegister(PC,pc+=2);
dst=src + (srcData << 16);
dst&=0xfffff;
writeRegister(dstData,dst);
updateStatus=false;
cycles+=2;
break;
case ADDA_IMM:
int immData=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + (srcData << 16);
writeRegister(PC,pc+=2);
dst=readRegister(dstData) + immData;
dst&=0xfffff;
writeRegister(dstData,dst);
cycles+=3;
break;
case CMPA_IMM:
{
immData=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + (srcData << 16);
writeRegister(PC,pc+=2);
sr=readRegister(SR);
int destRegValue=readRegister(dstData);
sr&=~(NEGATIVE | ZERO | CARRY| OVERFLOW);
if (destRegValue >= immData) {
sr|=CARRY;
}
if (destRegValue < immData) {
sr|=NEGATIVE;
}
if (destRegValue == immData) {
sr|=ZERO;
}
int cmpTmp=destRegValue - immData;
int b=0x80000;
if (((destRegValue ^ cmpTmp) & b) == 0 && (((destRegValue ^ immData) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
updateStatus=false;
cycles+=3;
break;
}
case SUBA_IMM:
immData=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + (srcData << 16);
writeRegister(PC,pc+=2);
dst=readRegister(dstData) - immData;
writeRegister(dstData,dst);
cycles+=3;
break;
case MOVA_REG:
cycles+=1;
writeRegister(dstData,readRegisterCG(srcData,0));
break;
case CMPA_REG:
{
sr=readRegister(SR);
sr&=~(NEGATIVE | ZERO | CARRY| OVERFLOW);
int destRegValue=readRegister(dstData);
int srcRegValue=readRegisterCG(srcData,0);
if (destRegValue >= srcRegValue) {
sr|=CARRY;
}
if (destRegValue < srcRegValue) {
sr|=NEGATIVE;
}
if (destRegValue == srcRegValue) {
sr|=ZERO;
}
int cmpTmp=destRegValue - srcRegValue;
int b=0x80000;
if (((destRegValue ^ cmpTmp) & b) == 0 && (((destRegValue ^ srcRegValue) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
updateStatus=false;
cycles+=1;
break;
}
case ADDA_REG:
dst=readRegister(dstData) + readRegisterCG(srcData,2);
writeRegister(dstData,dst);
cycles+=1;
break;
case SUBA_REG:
dst=readRegister(dstData) - readRegisterCG(srcData,2);
writeRegister(dstData,dst);
cycles+=1;
break;
case RRXX_ADDR:
rrword=false;
case RRXX_WORD:
int count=((instruction >> 10) & 0x03) + 1;
dst=readRegister(dstData);
sr=readRegister(SR);
int nxtCarry=0;
int carry=(sr & CARRY) > 0 ? 1 : 0;
if (rrword) {
mode=AccessMode.WORD;
dst=dst & 0xffff;
}
cycles+=1 + count;
switch (instruction & RRMASK) {
case RRCM:
int dst_low=dst & ((1 << count) - 1);
nxtCarry=(dst & (1 << (count + 1))) > 0 ? CARRY : 0;
dst=dst >> (count);
if (rrword) {
dst|=(dst_low << (17 - count)) | (carry << (16 - count));
}
 else {
dst|=(dst_low << (21 - count)) | (carry << (20 - count));
}
break;
case RRAM:
if ((dst & (rrword ? 0x8000 : 0x80000)) > 0) {
dst=dst | (rrword ? 0xf8000 : 0xf80000);
}
dst=dst >> (count - 1);
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
break;
case RLAM:
dst=dst << (count - 1);
nxtCarry=(dst & (rrword ? 0x8000 : 0x80000)) > 0 ? CARRY : 0;
dst=dst << 1;
break;
case RRUM:
dst=dst >> (count - 1);
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
break;
}
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
dst=dst & (rrword ? 0xffff : 0xfffff);
writeRegister(dstData,dst);
break;
default :
System.out.println(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
throw new EmulationException(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
}
break;
case 1:
{
dstRegister=instruction & 0xf;
if ((op=instruction & CALLA_MASK) > RETI) {
pc=readRegister(PC);
dst=-1;
updateStatus=false;
switch (op) {
case CALLA_REG:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
dst=readRegister(dstRegister);
System.out.println(""String_Node_Str"" + Utils.hex20(dst));
cycles+=5;
break;
case CALLA_INDEX:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
System.out.println(""String_Node_Str"" + dstRegister);
dst=readRegister(dstRegister);
int v=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
if ((v & 0x8000) != 0) {
v|=0xf0000;
}
System.out.println(""String_Node_Str"" + Utils.hex20(dst) + ""String_Node_Str""+ v);
dst+=v;
dst&=0xfffff;
System.out.println(""String_Node_Str"" + Utils.hex20(dst));
dst=currentSegment.read(dst,AccessMode.WORD20,AccessType.READ);
System.out.println(""String_Node_Str"" + Utils.hex20(dst));
cycles+=5;
pc+=2;
break;
case CALLA_IMM:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
dst=(dstRegister << 16) | currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
pc+=2;
cycles+=5;
break;
case CALLA_IND:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
dstAddress=readRegister(dstRegister);
dst=currentSegment.read(dstAddress,AccessMode.WORD20,AccessType.READ);
pc+=2;
cycles+=5;
break;
case CALLA_ABS:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
dst=(dstRegister << 16) | currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
dst=currentSegment.read(dst,AccessMode.WORD20,AccessType.READ);
pc+=2;
cycles+=7;
break;
default :
AccessMode type=AccessMode.WORD;
int size=2;
sp=readRegister(SP);
switch (op & 0x1f00) {
case PUSHM_A:
type=AccessMode.WORD20;
size=4;
cycles+=2;
case PUSHM_W:
int n=1 + ((instruction >> 4) & 0x0f);
int regNo=instruction & 0x0f;
for (int i=0; i < n; i++) {
sp-=size;
cycles+=2;
currentSegment.write(sp,this.reg[regNo--],type);
if (regNo < 0) regNo=15;
}
writeRegister(SP,sp);
break;
case POPM_A:
type=AccessMode.WORD20;
size=4;
cycles+=2;
case POPM_W:
n=1 + ((instruction >> 4) & 0x0f);
regNo=instruction & 0x0f;
for (int i=0; i < n; i++) {
cycles+=2;
this.reg[regNo++]=currentSegment.read(sp,type,AccessType.READ);
sp+=size;
if (regNo > 15) regNo=0;
}
writeRegister(SP,sp);
break;
default :
System.out.println(""String_Node_Str"");
throw new EmulationException(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
}
}
if (dst != -1) {
currentSegment.write(sp,(pc >> 16) & 0xf,AccessMode.WORD);
sp=sp - 2;
currentSegment.write(sp,pc & 0xffff,AccessMode.WORD);
writeRegister(SP,sp);
writeRegister(PC,dst);
if (profiler != null) {
profileCall(dst,pc);
}
}
}
 else {
int ad=(instruction >> 4) & 3;
int nxtCarry=0;
op=instruction & 0xff80;
if (op == PUSH || op == CALL) {
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
}
if ((dstRegister == CG1 && ad > AM_INDEX) || dstRegister == CG2) {
dstRegMode=true;
cycles++;
}
 else {
switch (ad) {
case AM_REG:
dstRegMode=true;
cycles++;
break;
case AM_INDEX:
rval=readRegisterCG(dstRegister,ad);
if (extWord != 0) {
dstAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + extDst;
dstAddress+=rval;
dstAddress&=0xfffff;
}
 else if (rval <= 0xffff) {
dstAddress=(rval + currentSegment.read(pc,AccessMode.WORD,AccessType.READ)) & 0xffff;
}
 else {
dstAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=pc;
dst=currentSegment.read(dstAddress,mode != AccessMode.BYTE ? AccessMode.WORD : AccessMode.BYTE,AccessType.READ);
dst+=extDst;
pc+=2;
writeRegister(PC,pc);
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + mode.bytes);
}
cycles+=3;
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
dst&=mode.mask;
if (repeatsInDstReg) {
repeats=1 + readRegister(ext3_0);
}
 else {
repeats=1 + ext3_0;
}
zeroCarry=(extWord & EXTWORD_ZC) > 0;
}
 else if (dst == -1) {
dst=currentSegment.read(dstAddress,mode,AccessType.READ);
}
while (repeats-- > 0) {
sr=readRegister(SR);
if (repeats >= 0) {
if (zeroCarry) {
sr=sr & ~CARRY;
}
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
dst|=(sr & CARRY) > 0 ? mode.msb : 0;
write=true;
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=(dst & mode.msb) | dst >> 1;
write=true;
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xfff00 : dst & 0x7f;
write=true;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case PUSH:
if (mode == AccessMode.WORD20) {
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
}
currentSegment.write(sp,dst,mode);
cycles+=(ad == AM_REG || ad == AM_IND_AUTOINC) ? 2 : 1;
write=false;
updateStatus=false;
break;
case CALL:
pc=readRegister(PC);
currentSegment.write(sp,pc,AccessMode.WORD);
writeRegister(PC,dst);
cycles+=(ad == AM_REG) ? 3 : (ad == AM_IND_AUTOINC) ? 2 : 1;
if (profiler != null) {
profileCall(dst,pc);
}
write=false;
updateStatus=false;
break;
case RETI:
servicedInterrupt=-1;
sp=readRegister(SP);
sr=currentSegment.read(sp,AccessMode.WORD,AccessType.READ);
writeRegister(SR,sr & 0x0fff);
sp=sp + 2;
writeRegister(PC,currentSegment.read(sp,AccessMode.WORD,AccessType.READ) | (sr & 0xf000) << 4);
sp=sp + 2;
writeRegister(SP,sp);
write=false;
updateStatus=false;
cycles+=4;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
if (profiler != null) {
profiler.profileRETI(cycles);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + Utils.hex16(instruction));
}
if (repeats > 0) {
dst&=mode.mask;
}
}
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
logw(WarningType.EMULATION_ERROR,""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
updateStatus=false;
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
src=0;
if ((srcRegister == CG1 && as > AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
src&=mode.mask;
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
src&=mode.mask;
cycles+=dstRegMode ? 1 : 4;
if (dstRegister == PC) cycles++;
if (dstRegMode) {
if (repeatsInDstReg) {
repeats=1 + readRegister(ext3_0);
}
 else {
repeats=1 + ext3_0;
}
zeroCarry=(extWord & EXTWORD_ZC) > 0;
}
break;
case AM_INDEX:
{
int sval=readRegisterCG(srcRegister,as);
if (extWord != 0) {
srcAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ) + extSrc;
srcAddress+=sval;
srcAddress&=0xfffff;
}
 else if (sval <= 0xffff) {
srcAddress=(sval + currentSegment.read(pc,AccessMode.WORD,AccessType.READ)) & 0xffff;
}
 else {
srcAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
if ((srcAddress & 0x8000) > 0) {
srcAddress|=0xf0000;
}
srcAddress+=sval;
srcAddress&=0xfffff;
}
pc+=2;
writeRegister(PC,pc);
cycles+=dstRegMode ? 3 : 6;
break;
}
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
src=currentSegment.read(pc,mode != AccessMode.BYTE ? AccessMode.WORD : AccessMode.BYTE,AccessType.READ);
src+=extSrc;
pc+=2;
writeRegister(PC,pc);
cycles+=dstRegMode ? 2 : 5;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,mode.bytes);
cycles+=dstRegMode ? 2 : 5;
}
if (dstRegister == PC) {
cycles++;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
dst&=mode.mask;
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
}
 else {
rval=readRegister(dstRegister);
if (rval <= 0xffff) {
dstAddress=(rval + currentSegment.read(pc,AccessMode.WORD,AccessType.READ)) & 0xffff;
}
 else {
dstAddress=currentSegment.read(pc,AccessMode.WORD,AccessType.READ);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
}
if (op != MOV) {
dst=currentSegment.read(dstAddress,word ? AccessMode.WORD : AccessMode.BYTE,AccessType.READ);
}
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
src=currentSegment.read(srcAddress,mode,AccessType.READ);
}
while (repeats-- > 0) {
sr=readRegister(SR);
if (repeats >= 0) {
if (zeroCarry) {
sr=sr & ~CARRY;
}
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
if (instruction == RETURN && profiler != null) {
profiler.profileReturn(cpuCycles);
}
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((sr & CARRY) > 0) ? 1 : 0;
case ADD:
sr&=~(OVERFLOW | CARRY);
int b=word ? 0x8000 : (wordx20 ? 0x80000 : 0x80);
tmp=(src ^ dst) & b;
dst=dst + src + tmpAdd;
int b2=word ? 0xffff : (wordx20 ? 0xfffff : 0xff);
if (dst > b2) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & b) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
b=mode.msb;
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=(dst - src);
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) log(""String_Node_Str"");
dst=dst + src + ((sr & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
sr=sr & ~(CARRY | OVERFLOW);
b=mode.msb;
if ((src & b) != 0 && (dst & b) != 0) {
sr|=OVERFLOW;
}
dst=src ^ dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
case AND:
sr=sr & ~(CARRY | OVERFLOW);
dst=src & dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
default :
String address=getAddressAsString(pc);
logw(WarningType.EMULATION_ERROR,""String_Node_Str"" + Integer.toHexString(op) + ""String_Node_Str""+ address);
if (EXCEPTION_ON_BAD_OPERATION) {
EmulationException ex=new EmulationException(""String_Node_Str"" + Integer.toHexString(op) + ""String_Node_Str""+ address);
ex.initCause(new Throwable(""String_Node_Str"" + pc));
throw ex;
}
}
if (repeats > 0 && srcRegister == dstRegister) {
src=dst;
src&=mode.mask;
}
}
}
dst&=mode.mask;
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
currentSegment.write(dstAddress,dst,mode);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | ((dst & mode.msb) > 0 ? NEGATIVE : 0);
writeRegister(SR,sr);
}
while (cycles >= nextEventCycles) {
executeEvents();
}
cpuCycles+=cycles - startCycles;
return pcBefore;
}",0.9960486971379752
5499,"public void setupCommands(final ComponentRegistry registry,CommandHandler handler){
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    private PrintStream out;
    private Pattern pattern;
    private boolean isInverted=false;
    public int executeCommand(    CommandContext context){
      int index=0;
      int flags=0;
      while (index + 1 < context.getArgumentCount()) {
        if (""String_Node_Str"".equals(context.getArgument(index))) {
          flags|=Pattern.CASE_INSENSITIVE;
        }
 else         if (""String_Node_Str"".equals(context.getArgument(index))) {
          isInverted=true;
        }
 else {
          context.err.println(""String_Node_Str"" + context.getArgument(index));
          return 1;
        }
        index++;
      }
      out=context.out;
      pattern=Pattern.compile(context.getArgument(index),flags);
      return 0;
    }
    public void lineRead(    String line){
      boolean isMatch=pattern.matcher(line).find();
      if (isMatch ^ isInverted) {
        out.println(line);
      }
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    private PrintStream out;
    private MSP430 cpu;
    long startTime;
    public int executeCommand(    CommandContext context){
      cpu=registry.getComponent(MSP430.class);
      if (cpu == null) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
      out=context.out;
      startTime=System.currentTimeMillis() - (long)cpu.getTimeMillis();
      return 0;
    }
    public void lineRead(    String line){
      out.println(Long.toString(startTime + (long)cpu.getTimeMillis()) + ' ' + line);
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      MSP430 cpu=registry.getComponent(MSP430.class);
      if (cpu == null) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
 else       if (context.getArgumentCount() == 0) {
      }
 else {
        double d=context.getArgumentAsDouble(0);
        if (d > 0.0) {
          long rate=(long)(25000 * d);
          cpu.setSleepRate(rate);
        }
 else {
          context.err.println(""String_Node_Str"");
          return 1;
        }
      }
      long rate=cpu.getSleepRate();
      double d=rate / 25000.0;
      context.out.println(""String_Node_Str"" + (((int)(d * 100 + 0.5)) / 100.0));
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      StringBuilder sb=new StringBuilder();
      for (int i=0, n=context.getArgumentCount(); i < n; i++) {
        if (i > 0)         sb.append(' ');
        sb.append(context.getArgument(i));
      }
      context.out.println(sb.toString());
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      boolean verbose=false;
      if (context.getArgumentCount() > 1) {
        verbose=""String_Node_Str"".equals(context.getArgument(0));
      }
      File fp=new File(context.getArgument(context.getArgumentCount() - 1));
      if (!fp.canRead()) {
        context.err.println(""String_Node_Str"" + context.getArgument(0) + ""String_Node_Str"");
        return 1;
      }
      try {
        FileInputStream infs=new FileInputStream(fp);
        BufferedReader input=new BufferedReader(new InputStreamReader(infs));
        try {
          String line;
          while ((line=input.readLine()) != null) {
            if (verbose)             context.out.println(line);
            context.executeCommand(line);
          }
        }
  finally {
          input.close();
        }
      }
 catch (      IOException e) {
        e.printStackTrace(context.err);
        return 1;
      }
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
    private MSP430 cpu;
    private int period=1;
    private int count=0;
    private int maxCount=-1;
    private String commandLine;
    private boolean isRunning=true;
    public int executeCommand(    final CommandContext context){
      int index=0;
      do {
        String a=context.getArgument(index);
        if (a.startsWith(""String_Node_Str"")) {
          if (a.equals(""String_Node_Str"")) {
            period=context.getArgumentAsInt(index + 1);
            index+=2;
          }
 else           if (a.equals(""String_Node_Str"")) {
            maxCount=context.getArgumentAsInt(index + 1);
            index+=2;
          }
 else {
            context.err.println(""String_Node_Str"" + a);
            return 1;
          }
        }
 else {
          break;
        }
      }
 while (true);
      if (index + 1 < context.getArgumentCount()) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
      commandLine=context.getArgument(index);
      cpu=registry.getComponent(MSP430.class);
      if (cpu == null) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
      cpu.scheduleTimeEventMillis(new TimeEvent(0){
        @Override public void execute(        long t){
          if (isRunning) {
            count++;
            context.executeCommand(commandLine);
            if ((maxCount <= 0) || (count < maxCount)) {
              cpu.scheduleTimeEventMillis(this,period * 1000d);
            }
 else {
              stopCommand(context);
            }
          }
        }
      }
,period * 1000d);
      return 0;
    }
    public void stopCommand(    CommandContext context){
      isRunning=false;
      context.err.println(""String_Node_Str"" + commandLine + ']');
      context.exit(0);
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new ExecCommand());
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    String command=null;
    CommandContext context;
    public int executeCommand(    CommandContext context){
      StringBuilder sb=new StringBuilder();
      for (int i=0, n=context.getArgumentCount(); i < n; i++) {
        if (i > 0)         sb.append(' ');
        sb.append(context.getArgument(i));
      }
      command=sb.toString();
      this.context=context;
      return 0;
    }
    public void lineRead(    String line){
      context.executeCommand(command);
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    @Override public int executeCommand(    CommandContext context){
      String className=context.getArgument(0);
      String name=className;
      if (context.getArgumentCount() > 1) {
        name=context.getArgument(1);
      }
      if (registry.getComponent(name) != null) {
        context.err.println(""String_Node_Str"" + name + ""String_Node_Str"");
        return 1;
      }
      Class<?> pluginClass=null;
      PluginRepository plugins=(PluginRepository)registry.getComponent(""String_Node_Str"");
      try {
        try {
          pluginClass=plugins != null ? plugins.loadClass(className) : Class.forName(className);
        }
 catch (        ClassNotFoundException e) {
          String newClassName=""String_Node_Str"" + className;
          pluginClass=plugins != null ? plugins.loadClass(newClassName) : Class.forName(newClassName);
        }
        Object component=pluginClass.newInstance();
        registry.registerComponent(name,component);
        return 0;
      }
 catch (      Exception e1) {
        e1.printStackTrace(context.err);
      }
      return 1;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    @Override public int executeCommand(    CommandContext context){
      int index=0;
      boolean verbose=true;
      if (context.getArgumentCount() > 0 && ""String_Node_Str"".equals(context.getArgument(index))) {
        index++;
        verbose=false;
      }
      if (context.getArgumentCount() == index) {
        ServiceComponent[] sc=registry.getAllComponents(ServiceComponent.class);
        if (sc.length == 0) {
          context.out.println(""String_Node_Str"");
        }
 else {
          for (          ServiceComponent service : sc) {
            context.out.printf(""String_Node_Str"",service.getName(),service.getStatus());
          }
        }
        return 0;
      }
      String name=context.getArgument(index++);
      ServiceComponent sc=getServiceForName(registry,name);
      if (sc == null) {
        if (verbose) {
          context.err.println(""String_Node_Str"" + name + ""String_Node_Str"");
          return 1;
        }
        return 0;
      }
      if (context.getArgumentCount() == index) {
        context.out.printf(""String_Node_Str"",sc.getName(),sc.getStatus());
        return 0;
      }
      String operation=context.getArgument(index);
      if (""String_Node_Str"".equals(operation)) {
        if (sc.getStatus() == ServiceComponent.Status.STARTED) {
          context.out.println(""String_Node_Str"" + sc.getName() + ""String_Node_Str"");
        }
 else {
          sc.start();
          context.out.println(""String_Node_Str"" + sc.getName() + ""String_Node_Str"");
        }
        return 0;
      }
      if (""String_Node_Str"".equals(operation)) {
        if (sc.getStatus() == ServiceComponent.Status.STOPPED) {
          context.out.println(""String_Node_Str"" + sc.getName() + ""String_Node_Str"");
        }
 else {
          sc.stop();
          context.out.println(""String_Node_Str"" + sc.getName() + ""String_Node_Str"");
        }
        return 0;
      }
      context.err.println(""String_Node_Str"" + operation + ""String_Node_Str"");
      return 1;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    CommandContext context;
    RFSource source;
    RFListener listener;
    final MSP430 cpu=registry.getComponent(MSP430.class);
    public int executeCommand(    CommandContext ctx){
      this.context=ctx;
      String inout=context.getArgument(0);
      Chip chip=cpu.getChip(context.getArgument(1));
      if (chip == null) {
        context.err.println(""String_Node_Str"" + context.getArgument(1) + '\'');
        return 1;
      }
      if (""String_Node_Str"".equals(inout)) {
        if (chip instanceof RFSource) {
          source=(RFSource)chip;
          listener=new RFListener(){
            public void receivedByte(            byte data){
              context.out.println(Utils.hex8(data));
            }
          }
;
          source.addRFListener(listener);
        }
 else {
          context.err.println(""String_Node_Str"");
          return 1;
        }
      }
 else       if (""String_Node_Str"".equals(inout)) {
        listener=(RFListener)chip;
      }
 else {
        context.err.println(""String_Node_Str"" + inout);
        return 1;
      }
      return 0;
    }
    @Override public void lineRead(    String line){
      if (listener != null) {
        byte[] data=Utils.hexconv(line);
        if (data != null) {
          context.out.println(""String_Node_Str"" + line);
          for (int i=0; i < data.length; i++) {
            listener.receivedByte(data[i]);
          }
        }
 else {
          context.out.println(""String_Node_Str"" + line);
        }
      }
    }
    @Override public void stopCommand(    CommandContext context){
      if (source != null) {
        source.removeRFListener(listener);
      }
      super.stopCommand(context);
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      ConfigManager config=(ConfigManager)registry.getComponent(""String_Node_Str"");
      context.out.println(""String_Node_Str"");
      context.out.println(""String_Node_Str"" + MSP430Constants.VERSION);
      context.out.println(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + ""String_Node_Str""+ System.getProperty(""String_Node_Str""));
      context.out.println(""String_Node_Str"" + config.getProperty(""String_Node_Str"",""String_Node_Str""));
      context.out.println(""String_Node_Str"" + config.getProperty(""String_Node_Str"",""String_Node_Str""));
      context.out.println();
      if (context.getOption(""String_Node_Str"")) {
        context.out.println(""String_Node_Str"");
        registry.printRegistry(context.out);
      }
      if (context.getOption(""String_Node_Str"")) {
        context.out.println(""String_Node_Str"");
        config.print(context.out);
      }
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      System.exit(0);
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      System.exit(0);
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      ConfigManager config=(ConfigManager)registry.getComponent(""String_Node_Str"");
      config.setProperty(context.getArgument(0),context.getArgument(1));
      context.out.println(""String_Node_Str"" + context.getArgument(0) + ""String_Node_Str""+ context.getArgument(1));
      return 0;
    }
  }
);
}","public void setupCommands(final ComponentRegistry registry,CommandHandler handler){
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    private PrintStream out;
    private Pattern pattern;
    private boolean isInverted=false;
    public int executeCommand(    CommandContext context){
      int index=0;
      int flags=0;
      while (index + 1 < context.getArgumentCount()) {
        if (""String_Node_Str"".equals(context.getArgument(index))) {
          flags|=Pattern.CASE_INSENSITIVE;
        }
 else         if (""String_Node_Str"".equals(context.getArgument(index))) {
          isInverted=true;
        }
 else {
          context.err.println(""String_Node_Str"" + context.getArgument(index));
          return 1;
        }
        index++;
      }
      out=context.out;
      pattern=Pattern.compile(context.getArgument(index),flags);
      return 0;
    }
    public void lineRead(    String line){
      boolean isMatch=pattern.matcher(line).find();
      if (isMatch ^ isInverted) {
        out.println(line);
      }
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    private PrintStream out;
    private MSP430 cpu;
    long startTime;
    public int executeCommand(    CommandContext context){
      cpu=registry.getComponent(MSP430.class);
      if (cpu == null) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
      out=context.out;
      startTime=System.currentTimeMillis() - (long)cpu.getTimeMillis();
      return 0;
    }
    public void lineRead(    String line){
      out.println(Long.toString(startTime + (long)cpu.getTimeMillis()) + ' ' + line);
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      MSP430 cpu=registry.getComponent(MSP430.class);
      if (cpu == null) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
 else       if (context.getArgumentCount() == 0) {
      }
 else {
        double rate=context.getArgumentAsDouble(0);
        if (rate > 0.0) {
          cpu.setExecutionRate(rate);
        }
 else {
          context.err.println(""String_Node_Str"");
          return 1;
        }
      }
      double rate=cpu.getExecutionRate();
      context.out.printf(""String_Node_Str"",rate);
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      StringBuilder sb=new StringBuilder();
      for (int i=0, n=context.getArgumentCount(); i < n; i++) {
        if (i > 0)         sb.append(' ');
        sb.append(context.getArgument(i));
      }
      context.out.println(sb.toString());
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      boolean verbose=false;
      if (context.getArgumentCount() > 1) {
        verbose=""String_Node_Str"".equals(context.getArgument(0));
      }
      File fp=new File(context.getArgument(context.getArgumentCount() - 1));
      if (!fp.canRead()) {
        context.err.println(""String_Node_Str"" + context.getArgument(0) + ""String_Node_Str"");
        return 1;
      }
      try {
        FileInputStream infs=new FileInputStream(fp);
        BufferedReader input=new BufferedReader(new InputStreamReader(infs));
        try {
          String line;
          while ((line=input.readLine()) != null) {
            if (verbose)             context.out.println(line);
            context.executeCommand(line);
          }
        }
  finally {
          input.close();
        }
      }
 catch (      IOException e) {
        e.printStackTrace(context.err);
        return 1;
      }
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
    private MSP430 cpu;
    private int period=1;
    private int count=0;
    private int maxCount=-1;
    private String commandLine;
    private boolean isRunning=true;
    public int executeCommand(    final CommandContext context){
      int index=0;
      do {
        String a=context.getArgument(index);
        if (a.startsWith(""String_Node_Str"")) {
          if (a.equals(""String_Node_Str"")) {
            period=context.getArgumentAsInt(index + 1);
            index+=2;
          }
 else           if (a.equals(""String_Node_Str"")) {
            maxCount=context.getArgumentAsInt(index + 1);
            index+=2;
          }
 else {
            context.err.println(""String_Node_Str"" + a);
            return 1;
          }
        }
 else {
          break;
        }
      }
 while (true);
      if (index + 1 < context.getArgumentCount()) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
      commandLine=context.getArgument(index);
      cpu=registry.getComponent(MSP430.class);
      if (cpu == null) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
      cpu.scheduleTimeEventMillis(new TimeEvent(0){
        @Override public void execute(        long t){
          if (isRunning) {
            count++;
            context.executeCommand(commandLine);
            if ((maxCount <= 0) || (count < maxCount)) {
              cpu.scheduleTimeEventMillis(this,period * 1000d);
            }
 else {
              stopCommand(context);
            }
          }
        }
      }
,period * 1000d);
      return 0;
    }
    public void stopCommand(    CommandContext context){
      isRunning=false;
      context.err.println(""String_Node_Str"" + commandLine + ']');
      context.exit(0);
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new ExecCommand());
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    String command=null;
    CommandContext context;
    public int executeCommand(    CommandContext context){
      StringBuilder sb=new StringBuilder();
      for (int i=0, n=context.getArgumentCount(); i < n; i++) {
        if (i > 0)         sb.append(' ');
        sb.append(context.getArgument(i));
      }
      command=sb.toString();
      this.context=context;
      return 0;
    }
    public void lineRead(    String line){
      context.executeCommand(command);
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    @Override public int executeCommand(    CommandContext context){
      String className=context.getArgument(0);
      String name=className;
      if (context.getArgumentCount() > 1) {
        name=context.getArgument(1);
      }
      if (registry.getComponent(name) != null) {
        context.err.println(""String_Node_Str"" + name + ""String_Node_Str"");
        return 1;
      }
      Class<?> pluginClass=null;
      PluginRepository plugins=(PluginRepository)registry.getComponent(""String_Node_Str"");
      try {
        try {
          pluginClass=plugins != null ? plugins.loadClass(className) : Class.forName(className);
        }
 catch (        ClassNotFoundException e) {
          String newClassName=""String_Node_Str"" + className;
          pluginClass=plugins != null ? plugins.loadClass(newClassName) : Class.forName(newClassName);
        }
        Object component=pluginClass.newInstance();
        registry.registerComponent(name,component);
        return 0;
      }
 catch (      Exception e1) {
        e1.printStackTrace(context.err);
      }
      return 1;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    @Override public int executeCommand(    CommandContext context){
      int index=0;
      boolean verbose=true;
      if (context.getArgumentCount() > 0 && ""String_Node_Str"".equals(context.getArgument(index))) {
        index++;
        verbose=false;
      }
      if (context.getArgumentCount() == index) {
        ServiceComponent[] sc=registry.getAllComponents(ServiceComponent.class);
        if (sc.length == 0) {
          context.out.println(""String_Node_Str"");
        }
 else {
          for (          ServiceComponent service : sc) {
            context.out.printf(""String_Node_Str"",service.getName(),service.getStatus());
          }
        }
        return 0;
      }
      String name=context.getArgument(index++);
      ServiceComponent sc=getServiceForName(registry,name);
      if (sc == null) {
        if (verbose) {
          context.err.println(""String_Node_Str"" + name + ""String_Node_Str"");
          return 1;
        }
        return 0;
      }
      if (context.getArgumentCount() == index) {
        context.out.printf(""String_Node_Str"",sc.getName(),sc.getStatus());
        return 0;
      }
      String operation=context.getArgument(index);
      if (""String_Node_Str"".equals(operation)) {
        if (sc.getStatus() == ServiceComponent.Status.STARTED) {
          context.out.println(""String_Node_Str"" + sc.getName() + ""String_Node_Str"");
        }
 else {
          sc.start();
          context.out.println(""String_Node_Str"" + sc.getName() + ""String_Node_Str"");
        }
        return 0;
      }
      if (""String_Node_Str"".equals(operation)) {
        if (sc.getStatus() == ServiceComponent.Status.STOPPED) {
          context.out.println(""String_Node_Str"" + sc.getName() + ""String_Node_Str"");
        }
 else {
          sc.stop();
          context.out.println(""String_Node_Str"" + sc.getName() + ""String_Node_Str"");
        }
        return 0;
      }
      context.err.println(""String_Node_Str"" + operation + ""String_Node_Str"");
      return 1;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    CommandContext context;
    RFSource source;
    RFListener listener;
    final MSP430 cpu=registry.getComponent(MSP430.class);
    public int executeCommand(    CommandContext ctx){
      this.context=ctx;
      String inout=context.getArgument(0);
      Chip chip=cpu.getChip(context.getArgument(1));
      if (chip == null) {
        context.err.println(""String_Node_Str"" + context.getArgument(1) + '\'');
        return 1;
      }
      if (""String_Node_Str"".equals(inout)) {
        if (chip instanceof RFSource) {
          source=(RFSource)chip;
          listener=new RFListener(){
            public void receivedByte(            byte data){
              context.out.println(Utils.hex8(data));
            }
          }
;
          source.addRFListener(listener);
        }
 else {
          context.err.println(""String_Node_Str"");
          return 1;
        }
      }
 else       if (""String_Node_Str"".equals(inout)) {
        listener=(RFListener)chip;
      }
 else {
        context.err.println(""String_Node_Str"" + inout);
        return 1;
      }
      return 0;
    }
    @Override public void lineRead(    String line){
      if (listener != null) {
        byte[] data=Utils.hexconv(line);
        if (data != null) {
          context.out.println(""String_Node_Str"" + line);
          for (int i=0; i < data.length; i++) {
            listener.receivedByte(data[i]);
          }
        }
 else {
          context.out.println(""String_Node_Str"" + line);
        }
      }
    }
    @Override public void stopCommand(    CommandContext context){
      if (source != null) {
        source.removeRFListener(listener);
      }
      super.stopCommand(context);
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      ConfigManager config=(ConfigManager)registry.getComponent(""String_Node_Str"");
      context.out.println(""String_Node_Str"");
      context.out.println(""String_Node_Str"" + MSP430Constants.VERSION);
      context.out.println(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + ""String_Node_Str""+ System.getProperty(""String_Node_Str""));
      context.out.println(""String_Node_Str"" + config.getProperty(""String_Node_Str"",""String_Node_Str""));
      context.out.println(""String_Node_Str"" + config.getProperty(""String_Node_Str"",""String_Node_Str""));
      context.out.println();
      if (context.getOption(""String_Node_Str"")) {
        context.out.println(""String_Node_Str"");
        registry.printRegistry(context.out);
      }
      if (context.getOption(""String_Node_Str"")) {
        context.out.println(""String_Node_Str"");
        config.print(context.out);
      }
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      System.exit(0);
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      System.exit(0);
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      ConfigManager config=(ConfigManager)registry.getComponent(""String_Node_Str"");
      config.setProperty(context.getArgument(0),context.getArgument(1));
      context.out.println(""String_Node_Str"" + context.getArgument(0) + ""String_Node_Str""+ context.getArgument(1));
      return 0;
    }
  }
);
}",0.98197633703144
5500,"private void run() throws EmulationException {
  while (!isStopping) {
    if (cycles > nextOut && !debug) {
      printCPUSpeed(reg[PC]);
      nextOut=cycles + 20000007;
    }
    int pc=emulateOP(-1);
    if (pc >= 0) {
      if (execCounter != null) {
        execCounter[pc]++;
      }
      if (trace != null) {
        trace[tracePos++]=pc;
        if (tracePos >= trace.length)         tracePos=0;
      }
      if (debug) {
        if (servicedInterrupt >= 0) {
          disAsm.disassemble(pc,memory,reg,servicedInterrupt);
        }
 else {
          disAsm.disassemble(pc,memory,reg);
        }
      }
    }
    if (cycles > nextSleep) {
      try {
        Thread.sleep(10);
      }
 catch (      Exception e) {
      }
      nextSleep=cycles + sleepRate;
    }
  }
  isStopping=isBreaking=false;
}","private void run() throws EmulationException {
  while (!isStopping) {
    if (cycles > nextOut && !debug) {
      printCPUSpeed(reg[PC]);
      nextOut=cycles + 20000007;
    }
    int pc=emulateOP(-1);
    if (pc >= 0) {
      if (execCounter != null) {
        execCounter[pc]++;
      }
      if (trace != null) {
        trace[tracePos++]=pc;
        if (tracePos >= trace.length)         tracePos=0;
      }
      if (debug) {
        if (servicedInterrupt >= 0) {
          disAsm.disassemble(pc,memory,reg,servicedInterrupt);
        }
 else {
          disAsm.disassemble(pc,memory,reg);
        }
      }
    }
    if (cycles > nextSleep) {
      try {
        Thread.sleep(100);
      }
 catch (      Exception e) {
      }
      nextSleep=cycles + (long)(rate * dcoFrq / 10);
    }
  }
  isStopping=isBreaking=false;
}",0.9780755176613886
5501,"public int setup(MSP430Core cpu,ArrayList<IOUnit> ioUnits){
  Multiplier32 mp=new Multiplier32(cpu,cpu.memory,0x4c0);
  for (int i=0x4c0, n=0x4c0 + 30; i < n; i++) {
    cpu.memOut[i]=mp;
    cpu.memIn[i]=mp;
  }
  for (int i=0, n=uartConfig.length; i < n; i++) {
    GenericUSCI usci=new GenericUSCI(cpu,i,cpu.memory,this);
    for (int a=0; a < 0x20; a++) {
      cpu.setIO(a + uartConfig[i].offset,usci,false);
    }
    System.out.println(""String_Node_Str"" + usci.getName());
    ioUnits.add(usci);
  }
  ioUnits.add(IOPort.parseIOPort(cpu,47,portConfig[0]));
  ioUnits.add(IOPort.parseIOPort(cpu,42,portConfig[1]));
  for (int i=2; i < portConfig.length; i++) {
    ioUnits.add(IOPort.parseIOPort(cpu,0,portConfig[i]));
  }
  return portConfig.length + uartConfig.length;
}","public int setup(MSP430Core cpu,ArrayList<IOUnit> ioUnits){
  Multiplier32 mp=new Multiplier32(cpu,cpu.memory,0x4c0);
  for (int i=0x4c0, n=0x4c0 + 0x30; i < n; i++) {
    cpu.memOut[i]=mp;
    cpu.memIn[i]=mp;
  }
  for (int i=0, n=uartConfig.length; i < n; i++) {
    GenericUSCI usci=new GenericUSCI(cpu,i,cpu.memory,this);
    for (int a=0; a < 0x20; a++) {
      cpu.setIO(a + uartConfig[i].offset,usci,false);
    }
    System.out.println(""String_Node_Str"" + usci.getName());
    ioUnits.add(usci);
  }
  ioUnits.add(IOPort.parseIOPort(cpu,47,portConfig[0]));
  ioUnits.add(IOPort.parseIOPort(cpu,42,portConfig[1]));
  for (int i=2; i < portConfig.length; i++) {
    ioUnits.add(IOPort.parseIOPort(cpu,0,portConfig[i]));
  }
  return portConfig.length + uartConfig.length;
}",0.9987163029525032
5502,"private void readLines(ELFSection sec){
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + sec.getSize());
  }
  sec.reset();
  int endPos=0;
  ArrayList<LineEntry> lineData=new ArrayList<LineEntry>();
  while (sec.getPosition() < sec.getSize()) {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    int totLen=sec.readElf32();
    int version=sec.readElf16();
    int proLen=sec.readElf32();
    int minOpLen=sec.readElf8();
    int defaultIsStmt=sec.readElf8();
    int lineBase=Integer.valueOf(sec.readElf8()).byteValue();
    int lineRange=sec.readElf8();
    int opcodeBase=sec.readElf8();
    endPos+=4 + totLen;
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + totLen + ""String_Node_Str""+ endPos);
      System.out.println(""String_Node_Str"" + proLen);
      System.out.println(""String_Node_Str"" + version);
    }
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + lineBase);
      System.out.println(""String_Node_Str"" + lineRange);
      System.out.println(""String_Node_Str"" + opcodeBase);
    }
    for (int i=0; i < opcodeBase - 1; i++) {
      sec.readElf8();
    }
    if (DEBUG)     System.out.println(""String_Node_Str"");
    ArrayList<String> directories=new ArrayList<String>();
    directories.add(""String_Node_Str"");
    ArrayList<String> files=new ArrayList<String>();
    StringBuilder sb=new StringBuilder();
    int c;
    while ((c=sec.readElf8()) != 0) {
      sb.append((char)c);
      while ((c=sec.readElf8()) != 0) {
        sb.append((char)c);
      }
      if (DEBUG)       System.out.println(""String_Node_Str"" + sb.toString());
      directories.add(sb.toString());
      sb.setLength(0);
    }
    if (DEBUG)     System.out.println(""String_Node_Str"");
    long dirIndex=0;
    long time=0;
    long size=0;
    while ((c=sec.readElf8()) != 0) {
      sb.append((char)c);
      while ((c=sec.readElf8()) != 0) {
        sb.append((char)c);
      }
      dirIndex=sec.readLEB128();
      time=sec.readLEB128();
      size=sec.readLEB128();
      if (DEBUG)       System.out.println(""String_Node_Str"" + sb.toString() + ""String_Node_Str""+ dirIndex+ ""String_Node_Str""+ size);
      files.add(directories.get((int)dirIndex) + ""String_Node_Str"" + sb.toString());
      sb.setLength(0);
    }
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + sec.getPosition() + ""String_Node_Str""+ endPos);
      System.out.println(""String_Node_Str"");
      System.out.print(""String_Node_Str"");
    }
    while (sec.getPosition() < endPos) {
      lineAddress=0;
      lineFile=1;
      lineLine=1;
      lineColumn=0;
      endSequence=false;
      isStatement=defaultIsStmt != 0;
      isBasicBlock=false;
      lineData.clear();
      while (!endSequence) {
        int opCode=sec.readElf8();
        if (DEBUG)         System.out.print(""String_Node_Str"" + sec.getPosition() + ""String_Node_Str""+ Utils.hex8(opCode)+ ""String_Node_Str"");
switch (opCode) {
case DW_LNS_EXT:
          int len=(int)sec.readLEB128();
        int extIns=sec.readElf8();
      if (DEBUG)       System.out.println(""String_Node_Str"" + Utils.hex8(extIns) + ""String_Node_Str""+ len);
switch (extIns) {
case DW_LNE_end_sequence:
      endSequence=true;
    lineData.add(new LineEntry(lineLine,lineAddress,lineFile));
  lineAddress=0;
lineFile=1;
lineLine=1;
lineColumn=0;
isStatement=defaultIsStmt != 0;
isBasicBlock=false;
if (DEBUG) System.out.println(""String_Node_Str"");
break;
case DW_LNE_set_address:
lineAddress=sec.readElf16();
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress) + ""String_Node_Str""+ len+ ""String_Node_Str"");
break;
case DW_LNE_define_file:
{
String filename=sec.readString();
long directoryIndex=sec.readLEB128();
long lastModified=sec.readLEB128();
long fileSize=sec.readLEB128();
if (DEBUG) System.out.println(""String_Node_Str"" + filename + ""String_Node_Str""+ directoryIndex+ ""String_Node_Str""+ lastModified+ ""String_Node_Str""+ fileSize);
break;
}
case DW_LNE_set_discriminator:
sec.readElf8();
if (DEBUG) System.out.println(""String_Node_Str"");
break;
default :
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex8(extIns));
}
break;
case DW_LNS_copy:
if (DEBUG) System.out.println(""String_Node_Str"" + lineLine + ""String_Node_Str""+ Utils.hex16(lineAddress)+ ""String_Node_Str"");
lineData.add(new LineEntry(lineLine,lineAddress,lineFile));
isBasicBlock=false;
break;
case DW_LNS_advance_pc:
long add=sec.readLEB128();
lineAddress+=minOpLen * add;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress));
break;
case DW_LNS_advance_line:
long addLine=sec.readLEB128S();
lineLine+=addLine;
if (DEBUG) System.out.println(""String_Node_Str"" + lineLine + ""String_Node_Str""+ addLine+ ""String_Node_Str"");
break;
case DW_LNS_set_file:
lineFile=(int)sec.readLEB128();
if (DEBUG) System.out.println(""String_Node_Str"" + lineFile);
break;
case DW_LNS_set_column:
lineColumn=(int)sec.readLEB128();
if (DEBUG) System.out.println(""String_Node_Str"" + lineColumn);
break;
case DW_LNS_negate_stmt:
isStatement=!isStatement;
if (DEBUG) System.out.println(""String_Node_Str"");
break;
case DW_LNS_set_basic_block:
isBasicBlock=true;
if (DEBUG) System.out.println(""String_Node_Str"");
break;
case DW_LNS_const_add_pc:
if (DEBUG) System.out.println(""String_Node_Str"");
{
int adjustedOpcode=255 - opcodeBase;
int operationAdvance=adjustedOpcode / lineRange;
lineAddress+=minOpLen * operationAdvance;
}
break;
case DW_LNS_fixed_advance_pc:
int incr=sec.readElf16();
lineAddress+=incr;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress));
break;
case DW_LNS_set_prologue_end:
break;
case DW_LNS_set_epilogue_begin:
break;
case DW_LNS_set_isa:
sec.readLEB128();
break;
default :
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex8(opCode) + ""String_Node_Str""+ Utils.hex8(opCode - opcodeBase)+ ""String_Node_Str""+ lineRange);
}
int adjustedOpcode=opCode - opcodeBase;
int operationAdvance=adjustedOpcode / lineRange;
int lineInc=lineBase + (adjustedOpcode % lineRange);
lineLine+=lineInc;
lineAddress+=minOpLen * operationAdvance;
lineData.add(new LineEntry(lineLine,lineAddress,lineFile));
isBasicBlock=false;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress) + ""String_Node_Str""+ lineLine+ ""String_Node_Str""+ lineInc);
}
}
if (DEBUG) System.out.println(""String_Node_Str"" + sec.getPosition() + ""String_Node_Str""+ totLen+ ""String_Node_Str""+ endPos);
if (lineData.size() > 0) {
LineData lineTable=new LineData();
lineTable.lineEntries=lineData.toArray(new LineEntry[0]);
lineTable.includeDirs=directories.toArray(new String[0]);
lineTable.sourceFiles=files.toArray(new String[0]);
lineInfo.add(lineTable);
}
}
}
if (DEBUG) {
for (LineData data : lineInfo) {
System.out.println(""String_Node_Str"" + data.sourceFiles[0]);
System.out.println(""String_Node_Str"" + Utils.hex16(data.lineEntries[0].address));
System.out.println(""String_Node_Str"" + Utils.hex16(data.lineEntries[data.lineEntries.length - 1].address));
System.out.println(""String_Node_Str"" + Utils.hex16(data.lineEntries[data.lineEntries.length - 1].address - data.lineEntries[0].address));
}
}
}","private void readLines(ELFSection sec){
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + sec.getSize());
  }
  sec.reset();
  int endPos=0;
  ArrayList<LineEntry> lineData=new ArrayList<LineEntry>();
  while (sec.getPosition() < sec.getSize()) {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    int totLen=sec.readElf32();
    int version=sec.readElf16();
    int proLen=sec.readElf32();
    int minOpLen=sec.readElf8();
    int defaultIsStmt=sec.readElf8();
    int lineBase=Integer.valueOf(sec.readElf8()).byteValue();
    int lineRange=sec.readElf8();
    int opcodeBase=sec.readElf8();
    endPos+=4 + totLen;
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + totLen + ""String_Node_Str""+ endPos);
      System.out.println(""String_Node_Str"" + proLen);
      System.out.println(""String_Node_Str"" + version);
    }
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + lineBase);
      System.out.println(""String_Node_Str"" + lineRange);
      System.out.println(""String_Node_Str"" + opcodeBase);
    }
    for (int i=0; i < opcodeBase - 1; i++) {
      sec.readElf8();
    }
    if (DEBUG)     System.out.println(""String_Node_Str"");
    ArrayList<String> directories=new ArrayList<String>();
    directories.add(""String_Node_Str"");
    ArrayList<String> files=new ArrayList<String>();
    StringBuilder sb=new StringBuilder();
    int c;
    while ((c=sec.readElf8()) != 0) {
      sb.append((char)c);
      while ((c=sec.readElf8()) != 0) {
        sb.append((char)c);
      }
      if (DEBUG)       System.out.println(""String_Node_Str"" + sb.toString());
      directories.add(sb.toString());
      sb.setLength(0);
    }
    if (DEBUG)     System.out.println(""String_Node_Str"");
    long dirIndex=0;
    long time=0;
    long size=0;
    while ((c=sec.readElf8()) != 0) {
      sb.append((char)c);
      while ((c=sec.readElf8()) != 0) {
        sb.append((char)c);
      }
      dirIndex=sec.readLEB128();
      time=sec.readLEB128();
      size=sec.readLEB128();
      if (DEBUG)       System.out.println(""String_Node_Str"" + sb.toString() + ""String_Node_Str""+ dirIndex+ ""String_Node_Str""+ size);
      files.add(directories.get((int)dirIndex) + ""String_Node_Str"" + sb.toString());
      sb.setLength(0);
    }
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + sec.getPosition() + ""String_Node_Str""+ endPos);
      System.out.println(""String_Node_Str"");
      System.out.print(""String_Node_Str"");
    }
    while (sec.getPosition() < endPos) {
      lineAddress=0;
      lineFile=1;
      lineLine=1;
      lineColumn=0;
      endSequence=false;
      isStatement=defaultIsStmt != 0;
      isBasicBlock=false;
      lineData.clear();
      while (!endSequence) {
        int opCode=sec.readElf8();
        if (DEBUG)         System.out.print(""String_Node_Str"" + sec.getPosition() + ""String_Node_Str""+ Utils.hex8(opCode)+ ""String_Node_Str"");
switch (opCode) {
case DW_LNS_EXT:
          int len=(int)sec.readLEB128();
        int extPos=sec.getPosition();
      int extIns=sec.readElf8();
    if (DEBUG)     System.out.println(""String_Node_Str"" + Utils.hex8(extIns) + ""String_Node_Str""+ len);
switch (extIns) {
case DW_LNE_end_sequence:
    endSequence=true;
  lineData.add(new LineEntry(lineLine,lineAddress,lineFile));
lineAddress=0;
lineFile=1;
lineLine=1;
lineColumn=0;
isStatement=defaultIsStmt != 0;
isBasicBlock=false;
if (DEBUG) System.out.println(""String_Node_Str"");
break;
case DW_LNE_set_address:
if (len == 3) {
lineAddress=sec.readElf16();
}
 else if (len == 5) {
lineAddress=sec.readElf32();
}
 else {
throw new IllegalStateException(""String_Node_Str"" + (len - 1) + ""String_Node_Str"");
}
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress) + ""String_Node_Str""+ len+ ""String_Node_Str"");
break;
case DW_LNE_define_file:
{
String filename=sec.readString();
long directoryIndex=sec.readLEB128();
long lastModified=sec.readLEB128();
long fileSize=sec.readLEB128();
if (DEBUG) System.out.println(""String_Node_Str"" + filename + ""String_Node_Str""+ directoryIndex+ ""String_Node_Str""+ lastModified+ ""String_Node_Str""+ fileSize);
break;
}
case DW_LNE_set_discriminator:
sec.readElf8();
if (DEBUG) System.out.println(""String_Node_Str"");
break;
default :
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex8(extIns));
}
if (sec.getPosition() != extPos + len) {
throw new IllegalStateException(""String_Node_Str"" + (extPos + len) + ""String_Node_Str""+ sec.getPosition());
}
break;
case DW_LNS_copy:
if (DEBUG) System.out.println(""String_Node_Str"" + lineLine + ""String_Node_Str""+ Utils.hex16(lineAddress)+ ""String_Node_Str"");
lineData.add(new LineEntry(lineLine,lineAddress,lineFile));
isBasicBlock=false;
break;
case DW_LNS_advance_pc:
long add=sec.readLEB128();
lineAddress+=minOpLen * add;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress));
break;
case DW_LNS_advance_line:
long addLine=sec.readLEB128S();
lineLine+=addLine;
if (DEBUG) System.out.println(""String_Node_Str"" + lineLine + ""String_Node_Str""+ addLine+ ""String_Node_Str"");
break;
case DW_LNS_set_file:
lineFile=(int)sec.readLEB128();
if (DEBUG) System.out.println(""String_Node_Str"" + lineFile);
break;
case DW_LNS_set_column:
lineColumn=(int)sec.readLEB128();
if (DEBUG) System.out.println(""String_Node_Str"" + lineColumn);
break;
case DW_LNS_negate_stmt:
isStatement=!isStatement;
if (DEBUG) System.out.println(""String_Node_Str"");
break;
case DW_LNS_set_basic_block:
isBasicBlock=true;
if (DEBUG) System.out.println(""String_Node_Str"");
break;
case DW_LNS_const_add_pc:
if (DEBUG) System.out.println(""String_Node_Str"");
{
int adjustedOpcode=255 - opcodeBase;
int operationAdvance=adjustedOpcode / lineRange;
lineAddress+=minOpLen * operationAdvance;
}
break;
case DW_LNS_fixed_advance_pc:
int incr=sec.readElf16();
lineAddress+=incr;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress));
break;
case DW_LNS_set_prologue_end:
break;
case DW_LNS_set_epilogue_begin:
break;
case DW_LNS_set_isa:
sec.readLEB128();
break;
default :
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex8(opCode) + ""String_Node_Str""+ Utils.hex8(opCode - opcodeBase)+ ""String_Node_Str""+ lineRange);
}
int adjustedOpcode=opCode - opcodeBase;
int operationAdvance=adjustedOpcode / lineRange;
int lineInc=lineBase + (adjustedOpcode % lineRange);
lineLine+=lineInc;
lineAddress+=minOpLen * operationAdvance;
lineData.add(new LineEntry(lineLine,lineAddress,lineFile));
isBasicBlock=false;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress) + ""String_Node_Str""+ lineLine+ ""String_Node_Str""+ lineInc);
}
}
if (DEBUG) System.out.println(""String_Node_Str"" + sec.getPosition() + ""String_Node_Str""+ totLen+ ""String_Node_Str""+ endPos);
if (lineData.size() > 0) {
LineData lineTable=new LineData();
lineTable.lineEntries=lineData.toArray(new LineEntry[0]);
lineTable.includeDirs=directories.toArray(new String[0]);
lineTable.sourceFiles=files.toArray(new String[0]);
lineInfo.add(lineTable);
}
}
}
if (DEBUG) {
for (LineData data : lineInfo) {
System.out.println(""String_Node_Str"" + data.sourceFiles[0]);
System.out.println(""String_Node_Str"" + Utils.hex16(data.lineEntries[0].address));
System.out.println(""String_Node_Str"" + Utils.hex16(data.lineEntries[data.lineEntries.length - 1].address));
System.out.println(""String_Node_Str"" + Utils.hex16(data.lineEntries[data.lineEntries.length - 1].address - data.lineEntries[0].address));
}
}
}",0.975062000551116
5503,"private void resetTIV(long cycles){
  if (lastTIV == timerOverflow) {
    interruptPending=false;
    if (DEBUG) {
      log(""String_Node_Str"");
    }
  }
 else   if (lastTIV / 2 < noCompare) {
    if (DEBUG) {
      log(cpu.cycles + ""String_Node_Str"" + (lastTIV / 2));
    }
    ccr[lastTIV / 2].tcctl&=~CC_IFG;
  }
  cpu.flagInterrupt(ccr1Vector,this,false);
  lastTIV=0;
  for (int i=1; i < noCompare; i++) {
    ccr[i].triggerInterrupt(cycles);
  }
  if (lastTIV == 0 && interruptEnable & interruptPending) {
    cpu.flagInterrupt(ccr1Vector,this,true);
  }
}","private void resetTIV(long cycles){
  if (lastTIV == timerOverflow) {
    interruptPending=false;
    if (DEBUG) {
      log(""String_Node_Str"");
    }
  }
 else   if (lastTIV / 2 < noCompare) {
    if (DEBUG) {
      log(cpu.cycles + ""String_Node_Str"" + (lastTIV / 2));
    }
    ccr[lastTIV / 2].tcctl&=~CC_IFG;
  }
  cpu.flagInterrupt(ccr1Vector,this,false);
  lastTIV=0;
  for (int i=1; i < noCompare; i++) {
    ccr[i].triggerInterrupt(cycles);
  }
  if (lastTIV == 0 && interruptEnable & interruptPending) {
    lastTIV=timerOverflow;
    cpu.flagInterrupt(ccr1Vector,this,true);
  }
}",0.9765828274067648
5504,"@Override public int getSPIlen(){
  return 0;
}","@Override public int getSPIlen(){
  return spiLen;
}",0.9292929292929292
5505,"public int getOutputPowerIndicator(){
  return (registers[REG_TXPOWER] & 0x1f);
}","public int getOutputPowerIndicator(){
  return (memory[REG_TXPOWER] & 0x1f);
}",0.9182389937106918
5506,"/** 
 * External APIs for simulators simulating Radio medium, etc.
 */
public void updateActiveFrequency(){
  activeFrequency=registers[REG_FSCTRL] - 357 + 2405 - 0x4000;
  activeChannel=(registers[REG_FSCTRL] - 357 - 0x4000) / 5 + 11;
}","/** 
 * External APIs for simulators simulating Radio medium, etc.
 */
public void updateActiveFrequency(){
  activeFrequency=memory[REG_FSCTRL] - 357 + 2405 - 0x4000;
  activeChannel=(memory[REG_FSCTRL] - 357 - 0x4000) / 5 + 11;
}",0.935897435897436
5507,"@Override public String info(){
  updateActiveFrequency();
  return ""String_Node_Str"" + isRadioOn + ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ ((status & STATUS_XOSC16M_STABLE) > 0)+ ""String_Node_Str""+ ((status & STATUS_RSSI_VALID) > 0)+ ""String_Node_Str""+ cca+ ""String_Node_Str""+ ((registers[REG_GPIOPOLARITY] & FIFOP_POLARITY) == FIFOP_POLARITY)+ ""String_Node_Str""+ currentFIFOP+ ""String_Node_Str""+ currentFIFO+ ""String_Node_Str""+ currentSFD+ ""String_Node_Str""+ rxFIFO.stateToString()+ ""String_Node_Str""+ rxlen+ ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ command+ ""String_Node_Str""+ autoAck+ ""String_Node_Str""+ addressDecode+ ""String_Node_Str""+ autoCRC+ ""String_Node_Str""+ Utils.hex8(memory[RAM_PANID + 1])+ Utils.hex8(memory[RAM_PANID])+ ""String_Node_Str""+ Utils.hex8(memory[RAM_SHORTADDR + 1])+ Utils.hex8(memory[RAM_SHORTADDR])+ ""String_Node_Str""+ getLongAddress()+ ""String_Node_Str""+ activeChannel+ ""String_Node_Str""+ fifopThr+ ""String_Node_Str"";
}","@Override public String info(){
  updateActiveFrequency();
  return ""String_Node_Str"" + isRadioOn + ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ ((status & STATUS_XOSC16M_STABLE) > 0)+ ""String_Node_Str""+ ((status & STATUS_RSSI_VALID) > 0)+ ""String_Node_Str""+ cca+ ""String_Node_Str""+ ((memory[REG_GPIOPOLARITY] & FIFOP_POLARITY) == FIFOP_POLARITY)+ ""String_Node_Str""+ currentFIFOP+ ""String_Node_Str""+ currentFIFO+ ""String_Node_Str""+ currentSFD+ ""String_Node_Str""+ rxFIFO.stateToString()+ ""String_Node_Str""+ rxlen+ ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ command+ ""String_Node_Str""+ autoAck+ ""String_Node_Str""+ addressDecode+ ""String_Node_Str""+ autoCRC+ ""String_Node_Str""+ Utils.hex8(memory[RAM_PANID + 1])+ Utils.hex8(memory[RAM_PANID])+ ""String_Node_Str""+ Utils.hex8(memory[RAM_SHORTADDR + 1])+ Utils.hex8(memory[RAM_SHORTADDR])+ ""String_Node_Str""+ getLongAddress()+ ""String_Node_Str""+ activeChannel+ ""String_Node_Str""+ fifopThr+ ""String_Node_Str"";
}",0.9922560660815696
5508,"public int getRegister(int register){
  return registers[register];
}","public int getRegister(int register){
  return memory[register];
}",0.9037037037037036
5509,"public void receivedByte(byte data){
  if (DEBUG)   log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (overflow) {
    }
 else     if (rxFIFO.isFull()) {
      setRxOverflow();
    }
 else {
      if (!frameRejected) {
        rxFIFO.write(data);
        if (rxread == 0) {
          rxCrc.setCRC(0);
          rxlen=data & 0xff;
          decodeAddress=addressDecode;
          if (DEBUG)           log(""String_Node_Str"" + rxlen);
          setFIFO(true);
        }
 else         if (rxread < rxlen - 1) {
          rxCrc.addBitrev(data & 0xff);
          if (rxread == 1) {
            fcf0=data & 0xff;
            frameType=fcf0 & FRAME_TYPE;
          }
 else           if (rxread == 2) {
            fcf1=data & 0xff;
            if (frameType == TYPE_DATA_FRAME) {
              ackRequest=(fcf0 & ACK_REQUEST) > 0;
              destinationAddressMode=(fcf1 >> 2) & 3;
              if (addressDecode && destinationAddressMode != LONG_ADDRESS && destinationAddressMode != SHORT_ADDRESS) {
                rejectFrame();
              }
            }
 else             if (frameType == TYPE_BEACON_FRAME || frameType == TYPE_ACK_FRAME) {
              decodeAddress=false;
              ackRequest=false;
            }
 else             if (addressDecode) {
              rejectFrame();
            }
          }
 else           if (rxread == 3) {
            dsn=data & 0xff;
          }
 else           if (decodeAddress) {
            boolean flushPacket=false;
            if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
              flushPacket=!rxFIFO.tailEquals(memory,RAM_IEEEADDR,8);
              flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,8) && !rxFIFO.tailEquals(BC_ADDRESS,0,2,8);
              decodeAddress=false;
            }
 else             if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
              flushPacket=!rxFIFO.tailEquals(BC_ADDRESS,0,2) && !rxFIFO.tailEquals(memory,RAM_SHORTADDR,2);
              flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,2) && !rxFIFO.tailEquals(BC_ADDRESS,0,2,2);
              decodeAddress=false;
            }
            if (flushPacket) {
              rejectFrame();
            }
          }
        }
        if (currentFIFOP == false && rxFIFO.length() <= rxlen + 1 && !decodeAddress && !frameRejected && rxFIFO.length() > fifopThr) {
          setFIFOP(true);
          if (DEBUG)           log(""String_Node_Str"");
        }
      }
      if (rxread++ == rxlen) {
        if (frameRejected) {
          if (DEBUG)           log(""String_Node_Str"");
          setSFD(false);
          setState(RadioState.RX_WAIT);
          return;
        }
        int crc=rxFIFO.get(-2) << 8;
        crc+=rxFIFO.get(-1);
        crcOk=crc == rxCrc.getCRCBitrev();
        if (DEBUG && !crcOk) {
          log(""String_Node_Str"" + Utils.hex16(crc) + ""String_Node_Str""+ Utils.hex16(rxCrc.getCRCBitrev()));
        }
        rxFIFO.set(-2,registers[REG_RSSI] & 0xff);
        rxFIFO.set(-1,(corrval & 0x7F) | (crcOk ? 0x80 : 0));
        if (rxFIFO.length() <= rxlen + 1) {
          setFIFOP(true);
        }
 else {
          if (DEBUG)           log(""String_Node_Str"" + rxFIFO.length() + ""String_Node_Str""+ rxlen);
        }
        setSFD(false);
        if (DEBUG)         log(""String_Node_Str"" + rxFIFO.stateToString());
        if (((autoAck && ackRequest) || shouldAck) && crcOk) {
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}","public void receivedByte(byte data){
  if (DEBUG)   log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (overflow) {
    }
 else     if (rxFIFO.isFull()) {
      setRxOverflow();
    }
 else {
      if (!frameRejected) {
        rxFIFO.write(data);
        if (rxread == 0) {
          rxCrc.setCRC(0);
          rxlen=data & 0xff;
          decodeAddress=addressDecode;
          if (DEBUG)           log(""String_Node_Str"" + rxlen);
          setFIFO(true);
        }
 else         if (rxread < rxlen - 1) {
          rxCrc.addBitrev(data & 0xff);
          if (rxread == 1) {
            fcf0=data & 0xff;
            frameType=fcf0 & FRAME_TYPE;
          }
 else           if (rxread == 2) {
            fcf1=data & 0xff;
            if (frameType == TYPE_DATA_FRAME) {
              ackRequest=(fcf0 & ACK_REQUEST) > 0;
              destinationAddressMode=(fcf1 >> 2) & 3;
              if (addressDecode && destinationAddressMode != LONG_ADDRESS && destinationAddressMode != SHORT_ADDRESS) {
                rejectFrame();
              }
            }
 else             if (frameType == TYPE_BEACON_FRAME || frameType == TYPE_ACK_FRAME) {
              decodeAddress=false;
              ackRequest=false;
            }
 else             if (addressDecode) {
              rejectFrame();
            }
          }
 else           if (rxread == 3) {
            dsn=data & 0xff;
          }
 else           if (decodeAddress) {
            boolean flushPacket=false;
            if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
              flushPacket=!rxFIFO.tailEquals(memory,RAM_IEEEADDR,8);
              flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,8) && !rxFIFO.tailEquals(BC_ADDRESS,0,2,8);
              decodeAddress=false;
            }
 else             if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
              flushPacket=!rxFIFO.tailEquals(BC_ADDRESS,0,2) && !rxFIFO.tailEquals(memory,RAM_SHORTADDR,2);
              flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,2) && !rxFIFO.tailEquals(BC_ADDRESS,0,2,2);
              decodeAddress=false;
            }
            if (flushPacket) {
              rejectFrame();
            }
          }
        }
        if (currentFIFOP == false && rxFIFO.length() <= rxlen + 1 && !decodeAddress && !frameRejected && rxFIFO.length() > fifopThr) {
          setFIFOP(true);
          if (DEBUG)           log(""String_Node_Str"");
        }
      }
      if (rxread++ == rxlen) {
        if (frameRejected) {
          if (DEBUG)           log(""String_Node_Str"");
          setSFD(false);
          setState(RadioState.RX_WAIT);
          return;
        }
        int crc=rxFIFO.get(-2) << 8;
        crc+=rxFIFO.get(-1);
        crcOk=crc == rxCrc.getCRCBitrev();
        if (DEBUG && !crcOk) {
          log(""String_Node_Str"" + Utils.hex16(crc) + ""String_Node_Str""+ Utils.hex16(rxCrc.getCRCBitrev()));
        }
        rxFIFO.set(-2,memory[REG_RSSI] & 0xff);
        rxFIFO.set(-1,(corrval & 0x7F) | (crcOk ? 0x80 : 0));
        if (rxFIFO.length() <= rxlen + 1) {
          setFIFOP(true);
        }
 else {
          if (DEBUG)           log(""String_Node_Str"" + rxFIFO.length() + ""String_Node_Str""+ rxlen);
        }
        setSFD(false);
        if (DEBUG)         log(""String_Node_Str"" + rxFIFO.stateToString());
        if (((autoAck && ackRequest) || shouldAck) && crcOk) {
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}",0.9981565687599852
5510,"private void reset(){
  registers[REG_RSSISTAT]=0;
  fifoGPIO=gpio[1];
  fifopGPIO=gpio[2];
  ccaGPIO=gpio[3];
  sfdGPIO=gpio[4];
  for (int i=0; i < gpio.length; i++) {
    gpio[i].setPolarity(true);
  }
}","private void reset(){
  memory[REG_RSSISTAT]=0;
  fifoGPIO=gpio[1];
  fifopGPIO=gpio[2];
  ccaGPIO=gpio[3];
  sfdGPIO=gpio[4];
  for (int i=0; i < gpio.length; i++) {
    gpio[i].setPolarity(true);
  }
}",0.9633251833740832
5511,"public void setRegister(int register,int data){
  registers[register]=data;
}","public void setRegister(int register,int data){
  memory[register]=data;
}",0.913907284768212
5512,"public void dataReceived(USARTSource source,int data){
  outputSPI=status;
  if (DEBUG) {
    log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ ((data >= ' ' && data <= 'Z') ? (char)data : '.')+ ')'+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ 0+ ""String_Node_Str""+ stateMachine);
  }
  if (!chipSelect) {
    return;
  }
  if (stateMachine == RadioState.VREG_OFF) {
    source.byteReceived(0);
    logw(""String_Node_Str"");
    return;
  }
  if (command == null) {
    command=cc2520SPI.getCommand(data);
    if (command == null) {
      logw(""String_Node_Str"" + data);
    }
  }
  spiData[spiLen]=data;
  if (spiLen < (spiData.length - 1))   spiLen++;
  if (command != null) {
    command.dataReceived(data);
    if (spiLen == command.commandLen) {
      System.out.println(""String_Node_Str"" + command.name);
      command.executeSPICommand();
      command=null;
    }
  }
  if (instruction == -1) {
    if ((data & 0xc0) == INS_REGRD) {
      source.byteReceived(registers[data & 0x3f]);
      return;
    }
    if ((data & 0xc0) == INS_REGWR) {
      instruction=data;
      source.byteReceived(outputSPI);
      return;
    }
    if ((data & 0xf0) == INS_MEMRD || (data & 0xf0) == INS_MEMWR) {
      instruction=data;
      source.byteReceived(outputSPI);
      return;
    }
switch (data & 0xff) {
case INS_SNOP:
      break;
case INS_IBUFLD:
    instruction=data & 0xff;
  break;
case INS_SIBUFEX:
break;
case INS_SSAMPLECCA:
break;
case INS_SRES:
break;
case INS_RXBUF:
break;
case INS_RXBUFCP:
break;
case INS_RXBUFMOV:
break;
case INS_TXBUF:
break;
case INS_TXBUFCP:
break;
case INS_RANDOM:
break;
case INS_SXOSCON:
break;
case INS_STXCAL:
break;
case INS_SRXON:
break;
case INS_STXON:
break;
case INS_STXONCCA:
break;
case INS_SRFOFF:
break;
case INS_SXOSCOFF:
break;
case INS_SFLUSHRX:
break;
case INS_SFLUSHTX:
break;
case INS_SACK:
break;
case INS_SACKPEND:
break;
case INS_SNACK:
break;
case INS_SRXMASKBITSET:
break;
case INS_SRXMASKBITCLR:
break;
case INS_RXMASKAND:
break;
case INS_RXMASKOR:
break;
case INS_MEMCP:
break;
case INS_MEMCPR:
break;
case INS_MEMXCP:
break;
case INS_MEMXWR:
break;
case INS_BCLR:
break;
case INS_BSET:
break;
case INS_CTR:
break;
case INS_CBCMAC:
break;
case INS_UCBCMAC:
break;
case INS_CCM:
break;
case INS_UCCM:
break;
case INS_ECB:
break;
case INS_ECBO:
break;
case INS_ECBX:
break;
case INS_ECBXO:
break;
case INS_INC:
break;
case INS_ABORT:
break;
default :
logw(""String_Node_Str"" + data);
break;
}
source.byteReceived(outputSPI);
return;
}
}","public void dataReceived(USARTSource source,int data){
  outputSPI=status;
  if (DEBUG) {
    log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ ((data >= ' ' && data <= 'Z') ? (char)data : '.')+ ')'+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ 0+ ""String_Node_Str""+ stateMachine);
  }
  if (!chipSelect) {
    return;
  }
  if (stateMachine == RadioState.VREG_OFF) {
    source.byteReceived(0);
    logw(""String_Node_Str"");
    return;
  }
  if (command == null) {
    command=cc2520SPI.getCommand(data);
    if (command == null) {
      logw(""String_Node_Str"" + data);
    }
 else {
      logw(""String_Node_Str"" + command.name);
    }
  }
  spiData[spiLen]=data;
  if (spiLen < (spiData.length - 1))   spiLen++;
  if (command != null) {
    command.dataReceived(data);
    if (spiLen == command.commandLen) {
      command.executeSPICommand();
      command=null;
      spiLen=0;
    }
  }
  if (instruction == -1) {
    if ((data & 0xc0) == INS_REGRD) {
      source.byteReceived(memory[data & 0x3f]);
      return;
    }
    if ((data & 0xc0) == INS_REGWR) {
      instruction=data;
      source.byteReceived(outputSPI);
      return;
    }
    if ((data & 0xf0) == INS_MEMRD || (data & 0xf0) == INS_MEMWR) {
      instruction=data;
      source.byteReceived(outputSPI);
      return;
    }
switch (data & 0xff) {
case INS_SNOP:
      break;
case INS_IBUFLD:
    instruction=data & 0xff;
  break;
case INS_SIBUFEX:
break;
case INS_SSAMPLECCA:
break;
case INS_SRES:
break;
case INS_RXBUF:
break;
case INS_RXBUFCP:
break;
case INS_RXBUFMOV:
break;
case INS_TXBUF:
break;
case INS_TXBUFCP:
break;
case INS_RANDOM:
break;
case INS_SXOSCON:
break;
case INS_STXCAL:
break;
case INS_SRXON:
break;
case INS_STXON:
break;
case INS_STXONCCA:
break;
case INS_SRFOFF:
break;
case INS_SXOSCOFF:
break;
case INS_SFLUSHRX:
break;
case INS_SFLUSHTX:
break;
case INS_SACK:
break;
case INS_SACKPEND:
break;
case INS_SNACK:
break;
case INS_SRXMASKBITSET:
break;
case INS_SRXMASKBITCLR:
break;
case INS_RXMASKAND:
break;
case INS_RXMASKOR:
break;
case INS_MEMCP:
break;
case INS_MEMCPR:
break;
case INS_MEMXCP:
break;
case INS_MEMXWR:
break;
case INS_BCLR:
break;
case INS_BSET:
break;
case INS_CTR:
break;
case INS_CBCMAC:
break;
case INS_UCBCMAC:
break;
case INS_CCM:
break;
case INS_UCCM:
break;
case INS_ECB:
break;
case INS_ECBO:
break;
case INS_ECBX:
break;
case INS_ECBXO:
break;
case INS_INC:
break;
case INS_ABORT:
break;
default :
logw(""String_Node_Str"" + data);
break;
}
source.byteReceived(outputSPI);
return;
}
}",0.97003373685255
5513,"@Override public int getConfiguration(int parameter){
  return registers[parameter];
}","@Override public int getConfiguration(int parameter){
  return memory[parameter];
}",0.9230769230769232
5514,"void writeMemory(int address,int data){
}","void writeMemory(int address,int data){
  System.out.printf(""String_Node_Str"",address,data);
  int oldValue=memory[address];
  memory[address]=data;
switch (address) {
case REG_FIFOPCTRL:
    fifopThr=data & FIFOP_THR;
  if (DEBUG)   log(""String_Node_Str"" + Utils.hex16(oldValue) + ""String_Node_Str""+ Utils.hex16(data));
break;
case REG_GPIOPOLARITY:
if (DEBUG) log(""String_Node_Str"" + Utils.hex16(oldValue) + ""String_Node_Str""+ Utils.hex16(data));
if (oldValue != data) {
setFIFOP(currentFIFOP);
setFIFO(currentFIFO);
setSFD(currentSFD);
setCCA(currentCCA);
}
break;
case REG_MDMCTRL0:
addressDecode=(data & ADR_DECODE) != 0;
autoCRC=(data & ADR_AUTOCRC) != 0;
autoAck=(data & AUTOACK) != 0;
break;
case REG_FSCTRL:
{
ChannelListener listener=this.channelListener;
if (listener != null) {
int oldChannel=activeChannel;
updateActiveFrequency();
if (oldChannel != activeChannel) {
listener.channelChanged(activeChannel);
}
}
break;
}
}
configurationChanged(address,oldValue,data);
}",0.0802348336594911
5515,"public void setRSSI(int power){
  final int minp=-128 + RSSI_OFFSET;
  final int maxp=128 + RSSI_OFFSET;
  if (power < minp) {
    power=-minp;
  }
  if (power > maxp) {
    power=maxp;
  }
  if (DEBUG)   log(""String_Node_Str"" + power);
  rssi=power;
  registers[REG_RSSI]=power - RSSI_OFFSET;
  updateCCA();
}","public void setRSSI(int power){
  final int minp=-128 + RSSI_OFFSET;
  final int maxp=128 + RSSI_OFFSET;
  if (power < minp) {
    power=-minp;
  }
  if (power > maxp) {
    power=maxp;
  }
  if (DEBUG)   log(""String_Node_Str"" + power);
  rssi=power;
  memory[REG_RSSI]=power - RSSI_OFFSET;
  updateCCA();
}",0.9756888168557536
5516,"public void setChipSelect(boolean select){
  chipSelect=select;
  if (!chipSelect) {
    instruction=-1;
    spiLen=0;
    command=null;
  }
  if (DEBUG) {
    log(""String_Node_Str"" + chipSelect);
  }
}","public void setChipSelect(boolean select){
  chipSelect=select;
  if (!chipSelect) {
    instruction=-1;
    spiLen=0;
    if (command != null)     command.executeSPICommand();
    command=null;
  }
  if (DEBUG) {
    log(""String_Node_Str"" + chipSelect);
  }
}",0.8744588744588745
5517,"private boolean setState(RadioState state){
  if (DEBUG)   log(""String_Node_Str"" + stateMachine + ""String_Node_Str""+ state);
  stateMachine=state;
  registers[REG_FSMSTAT0]=(registers[REG_FSMSTAT0] & 0x3f);
switch (stateMachine) {
case VREG_OFF:
    if (DEBUG)     log(""String_Node_Str"");
  flushRX();
flushTX();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
registers[REG_RSSISTAT]=0;
crcOk=false;
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case POWER_DOWN:
rxFIFO.reset();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
registers[REG_RSSISTAT]=0;
crcOk=false;
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case RX_CALIBRATE:
setSymbolEvent(12);
setMode(MODE_RX_ON);
break;
case RX_SFD_SEARCH:
zeroSymbols=0;
if ((status & STATUS_RSSI_VALID) == 0) {
setSymbolEvent(8);
}
updateCCA();
setMode(MODE_RX_ON);
break;
case TX_CALIBRATE:
setSymbolEvent(12 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_FRAME:
txfifoPos=0;
crcOk=false;
txNext();
break;
case RX_WAIT:
setSymbolEvent(8);
setMode(MODE_RX_ON);
break;
case IDLE:
status&=~STATUS_RSSI_VALID;
registers[REG_RSSISTAT]=0;
setMode(MODE_TXRX_OFF);
updateCCA();
break;
case TX_ACK_CALIBRATE:
status|=STATUS_TX_ACTIVE;
setSymbolEvent(12 + 2 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_ACK_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_ACK:
ackPos=0;
crcOk=false;
ackNext();
break;
case RX_FRAME:
rxFIFO.mark();
rxread=0;
frameRejected=false;
shouldAck=false;
crcOk=false;
break;
}
stateChanged(stateMachine.state);
return true;
}","private boolean setState(RadioState state){
  if (DEBUG)   log(""String_Node_Str"" + stateMachine + ""String_Node_Str""+ state);
  stateMachine=state;
  memory[REG_FSMSTAT0]=(memory[REG_FSMSTAT0] & 0x3f);
switch (stateMachine) {
case VREG_OFF:
    if (DEBUG)     log(""String_Node_Str"");
  flushRX();
flushTX();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
memory[REG_RSSISTAT]=0;
crcOk=false;
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case POWER_DOWN:
rxFIFO.reset();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
memory[REG_RSSISTAT]=0;
crcOk=false;
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case RX_CALIBRATE:
setSymbolEvent(12);
setMode(MODE_RX_ON);
break;
case RX_SFD_SEARCH:
zeroSymbols=0;
if ((status & STATUS_RSSI_VALID) == 0) {
setSymbolEvent(8);
}
updateCCA();
setMode(MODE_RX_ON);
break;
case TX_CALIBRATE:
setSymbolEvent(12 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_FRAME:
txfifoPos=0;
crcOk=false;
txNext();
break;
case RX_WAIT:
setSymbolEvent(8);
setMode(MODE_RX_ON);
break;
case IDLE:
status&=~STATUS_RSSI_VALID;
memory[REG_RSSISTAT]=0;
setMode(MODE_TXRX_OFF);
updateCCA();
break;
case TX_ACK_CALIBRATE:
status|=STATUS_TX_ACTIVE;
setSymbolEvent(12 + 2 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_ACK_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_ACK:
ackPos=0;
crcOk=false;
ackNext();
break;
case RX_FRAME:
rxFIFO.mark();
rxread=0;
frameRejected=false;
shouldAck=false;
crcOk=false;
break;
}
stateChanged(stateMachine.state);
return true;
}",0.9773071104387292
5518,"public void dataReceived(USARTSource source,int data){
  outputSPI=status;
  if (DEBUG) {
    log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ ((data >= ' ' && data <= 'Z') ? (char)data : '.')+ ')'+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ 0+ ""String_Node_Str""+ stateMachine);
  }
  if (!chipSelect) {
    return;
  }
  if (stateMachine == RadioState.VREG_OFF) {
    source.byteReceived(0);
    logw(""String_Node_Str"");
    return;
  }
  if (command == null) {
    command=cc2520SPI.getCommand(data);
    if (command == null) {
      logw(""String_Node_Str"" + data);
    }
 else {
      logw(""String_Node_Str"" + command.name);
    }
  }
  spiData[spiLen]=data;
  if (spiLen < (spiData.length - 1))   spiLen++;
  if (command != null) {
    command.dataReceived(data);
    if (spiLen == command.commandLen) {
      command.executeSPICommand();
      command=null;
      spiLen=0;
    }
  }
  if (instruction == -1) {
    if ((data & 0xc0) == INS_REGRD) {
      source.byteReceived(memory[data & 0x3f]);
      return;
    }
    if ((data & 0xc0) == INS_REGWR) {
      instruction=data;
      source.byteReceived(outputSPI);
      return;
    }
    if ((data & 0xf0) == INS_MEMRD || (data & 0xf0) == INS_MEMWR) {
      instruction=data;
      source.byteReceived(outputSPI);
      return;
    }
switch (data & 0xff) {
case INS_SNOP:
      break;
case INS_IBUFLD:
    instruction=data & 0xff;
  break;
case INS_SIBUFEX:
break;
case INS_SSAMPLECCA:
break;
case INS_SRES:
break;
case INS_RXBUF:
break;
case INS_RXBUFCP:
break;
case INS_RXBUFMOV:
break;
case INS_TXBUF:
break;
case INS_TXBUFCP:
break;
case INS_RANDOM:
break;
case INS_SXOSCON:
break;
case INS_STXCAL:
break;
case INS_SRXON:
break;
case INS_STXON:
break;
case INS_STXONCCA:
break;
case INS_SRFOFF:
break;
case INS_SXOSCOFF:
break;
case INS_SFLUSHRX:
break;
case INS_SFLUSHTX:
break;
case INS_SACK:
break;
case INS_SACKPEND:
break;
case INS_SNACK:
break;
case INS_SRXMASKBITSET:
break;
case INS_SRXMASKBITCLR:
break;
case INS_RXMASKAND:
break;
case INS_RXMASKOR:
break;
case INS_MEMCP:
break;
case INS_MEMCPR:
break;
case INS_MEMXCP:
break;
case INS_MEMXWR:
break;
case INS_BCLR:
break;
case INS_BSET:
break;
case INS_CTR:
break;
case INS_CBCMAC:
break;
case INS_UCBCMAC:
break;
case INS_CCM:
break;
case INS_UCCM:
break;
case INS_ECB:
break;
case INS_ECBO:
break;
case INS_ECBX:
break;
case INS_ECBXO:
break;
case INS_INC:
break;
case INS_ABORT:
break;
default :
logw(""String_Node_Str"" + data);
break;
}
source.byteReceived(outputSPI);
return;
}
}","public void dataReceived(USARTSource source,int data){
  outputSPI=status;
  if (DEBUG) {
    log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ ((data >= ' ' && data <= 'Z') ? (char)data : '.')+ ')'+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ 0+ ""String_Node_Str""+ stateMachine);
  }
  if (!chipSelect) {
    return;
  }
  if (stateMachine == RadioState.VREG_OFF) {
    source.byteReceived(0);
    logw(""String_Node_Str"");
    return;
  }
  if (command == null) {
    command=cc2520SPI.getCommand(data);
    if (command == null) {
      logw(""String_Node_Str"" + data);
    }
 else {
      if (!""String_Node_Str"".equals(command.name)) {
        logw(""String_Node_Str"" + command.name);
      }
    }
  }
  spiData[spiLen]=data;
  if (spiLen < (spiData.length - 1))   spiLen++;
  if (command != null) {
    command.dataReceived(data);
    if (spiLen == command.commandLen) {
      command.executeSPICommand();
      command=null;
      spiLen=0;
    }
  }
  if (instruction == -1) {
    if ((data & 0xc0) == INS_REGRD) {
      source.byteReceived(memory[data & 0x3f]);
      return;
    }
    if ((data & 0xc0) == INS_REGWR) {
      instruction=data;
      source.byteReceived(outputSPI);
      return;
    }
    if ((data & 0xf0) == INS_MEMRD || (data & 0xf0) == INS_MEMWR) {
      instruction=data;
      source.byteReceived(outputSPI);
      return;
    }
switch (data & 0xff) {
case INS_SNOP:
      break;
case INS_IBUFLD:
    instruction=data & 0xff;
  break;
case INS_SIBUFEX:
break;
case INS_SSAMPLECCA:
break;
case INS_SRES:
break;
case INS_RXBUF:
break;
case INS_RXBUFCP:
break;
case INS_RXBUFMOV:
break;
case INS_TXBUF:
break;
case INS_TXBUFCP:
break;
case INS_RANDOM:
break;
case INS_SXOSCON:
break;
case INS_STXCAL:
break;
case INS_SRXON:
break;
case INS_STXON:
break;
case INS_STXONCCA:
break;
case INS_SRFOFF:
break;
case INS_SXOSCOFF:
break;
case INS_SFLUSHRX:
break;
case INS_SFLUSHTX:
break;
case INS_SACK:
break;
case INS_SACKPEND:
break;
case INS_SNACK:
break;
case INS_SRXMASKBITSET:
break;
case INS_SRXMASKBITCLR:
break;
case INS_RXMASKAND:
break;
case INS_RXMASKOR:
break;
case INS_MEMCP:
break;
case INS_MEMCPR:
break;
case INS_MEMXCP:
break;
case INS_MEMXWR:
break;
case INS_BCLR:
break;
case INS_BSET:
break;
case INS_CTR:
break;
case INS_CBCMAC:
break;
case INS_UCBCMAC:
break;
case INS_CCM:
break;
case INS_UCCM:
break;
case INS_ECB:
break;
case INS_ECBO:
break;
case INS_ECBX:
break;
case INS_ECBXO:
break;
case INS_INC:
break;
case INS_ABORT:
break;
default :
logw(""String_Node_Str"" + data);
break;
}
source.byteReceived(outputSPI);
return;
}
}",0.987683284457478
5519,"public CC2520SPI(CC2520 cc){
  cc2520=cc;
  SPICommand[] spiCommands={new SPICommand(""String_Node_Str"",cc2520){
    public void executeSPICommand(){
    }
  }
,new SPICommand(""String_Node_Str"",cc2520){
    public void executeSPICommand(){
      System.out.println(name + ""String_Node_Str"" + spiData.getSPIData()[1]);
      cc2520.instructionBuffer=spiData.getSPIData()[1];
    }
  }
,new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520){
    BitField adr=getBitField(""String_Node_Str"");
    int cAdr=0;
    public boolean dataReceived(    int data){
      if (spiData.getSPIlen() == 2) {
        cAdr=adr.getValue();
      }
 else       if (spiData.getSPIlen() > 2) {
        spiData.outputSPI(cc2520.readMemory(cAdr));
        cAdr=(cAdr + 1) & 0x3ff;
      }
      return true;
    }
    public void executeSPICommand(){
    }
  }
,new SPICommand(""String_Node_Str"",cc2520){
    BitField adr=getBitField(""String_Node_Str"");
    int cAdr=-1;
    public boolean dataReceived(    int data){
      int len=spiData.getSPIlen();
      int sdata[]=spiData.getSPIData();
      if (len == 2) {
        cAdr=adr.getValue();
      }
 else       if (len > 2) {
        cc2520.writeMemory(cAdr,data);
        cAdr=(cAdr + 1) & 0x3ff;
      }
      return true;
    }
    public void executeSPICommand(){
    }
  }
,new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520){
    public boolean dataReceived(    int data){
      if (spiData.getSPIlen() > 1) {
        cc2520.writeTXFIFO(data);
      }
      return true;
    }
  }
,new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520){
    public void executeSPICommand(){
      cc2520.stxon();
    }
  }
,new SPICommand(""String_Node_Str"",cc2520){
    public void executeSPICommand(){
      cc2520.stxoncca();
    }
  }
,new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520){
    public void executeSPICommand(){
      cc2520.flushRX();
    }
  }
,new SPICommand(""String_Node_Str"",cc2520){
    public void executeSPICommand(){
      cc2520.flushTX();
    }
  }
,new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520){
    BitField adr=getBitField(""String_Node_Str"");
    int cAdr=0;
    public boolean dataReceived(    int data){
      if (spiData.getSPIlen() == 1) {
        cAdr=adr.getValue();
      }
 else {
        spiData.outputSPI(cc2520.readMemory(cAdr));
        cAdr=(cAdr + 1) & 0x7f;
      }
      return true;
    }
    public void executeSPICommand(){
    }
  }
,new SPICommand(""String_Node_Str"",cc2520){
    BitField adr=getBitField(""String_Node_Str"");
    int cAdr=0;
    public boolean dataReceived(    int data){
      if (spiData.getSPIlen() == 1) {
        cAdr=adr.getValue();
      }
 else {
        cc2520.writeMemory(cAdr,data);
        cAdr=(cAdr + 1) & 0x7f;
      }
      return true;
    }
    public void executeSPICommand(){
    }
  }
};
  for (int i=0; i < spiCommands.length; i++) {
    SPICommand c=spiCommands[i];
    int maxv=1 << (8 - c.bitCount);
    int v=c.value;
    for (int j=0; j < maxv; j++) {
      System.out.printf(c.name + ""String_Node_Str"",(v + j));
      if (commands[v + j] != null) {
        System.out.println(""String_Node_Str"" + commands[v + j].name);
      }
      commands[v + j]=c;
    }
  }
}","public CC2520SPI(CC2520 cc){
  cc2520=cc;
  SPICommand[] spiCommands={new SPICommand(""String_Node_Str"",cc2520){
    public void executeSPICommand(){
    }
  }
,new SPICommand(""String_Node_Str"",cc2520){
    public void executeSPICommand(){
      System.out.println(name + ""String_Node_Str"" + spiData.getSPIData()[1]);
      cc2520.instructionBuffer=spiData.getSPIData()[1];
    }
  }
,new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520){
    BitField adr=getBitField(""String_Node_Str"");
    int cAdr=0;
    public boolean dataReceived(    int data){
      if (spiData.getSPIlen() == 2) {
        cAdr=adr.getValue();
      }
 else       if (spiData.getSPIlen() > 2) {
        spiData.outputSPI(cc2520.readMemory(cAdr));
        cAdr=(cAdr + 1) & 0x3ff;
      }
      return true;
    }
    public void executeSPICommand(){
    }
  }
,new SPICommand(""String_Node_Str"",cc2520){
    BitField adr=getBitField(""String_Node_Str"");
    int cAdr=-1;
    public boolean dataReceived(    int data){
      int len=spiData.getSPIlen();
      int sdata[]=spiData.getSPIData();
      if (len == 2) {
        cAdr=adr.getValue();
      }
 else       if (len > 2) {
        cc2520.writeMemory(cAdr,data);
        cAdr=(cAdr + 1) & 0x3ff;
      }
      return true;
    }
    public void executeSPICommand(){
    }
  }
,new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520){
    public boolean dataReceived(    int data){
      if (spiData.getSPIlen() > 1) {
        System.out.printf(""String_Node_Str"",data);
        cc2520.writeTXFIFO(data);
      }
      return true;
    }
    public void executeSPICommand(){
    }
  }
,new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520){
    public void executeSPICommand(){
      cc2520.stxon();
    }
  }
,new SPICommand(""String_Node_Str"",cc2520){
    public void executeSPICommand(){
      cc2520.stxoncca();
    }
  }
,new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520){
    public void executeSPICommand(){
      cc2520.flushRX();
    }
  }
,new SPICommand(""String_Node_Str"",cc2520){
    public void executeSPICommand(){
      cc2520.flushTX();
    }
  }
,new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520),new SPICommand(""String_Node_Str"",cc2520){
    BitField adr=getBitField(""String_Node_Str"");
    int cAdr=0;
    public boolean dataReceived(    int data){
      if (spiData.getSPIlen() == 1) {
        cAdr=adr.getValue();
      }
 else {
        spiData.outputSPI(cc2520.readMemory(cAdr));
        cAdr=(cAdr + 1) & 0x7f;
      }
      return true;
    }
    public void executeSPICommand(){
    }
  }
,new SPICommand(""String_Node_Str"",cc2520){
    BitField adr=getBitField(""String_Node_Str"");
    int cAdr=0;
    public boolean dataReceived(    int data){
      if (spiData.getSPIlen() == 1) {
        cAdr=adr.getValue();
      }
 else {
        cc2520.writeMemory(cAdr,data);
        cAdr=(cAdr + 1) & 0x7f;
      }
      return true;
    }
    public void executeSPICommand(){
    }
  }
};
  for (int i=0; i < spiCommands.length; i++) {
    SPICommand c=spiCommands[i];
    int maxv=1 << (8 - c.bitCount);
    int v=c.value;
    for (int j=0; j < maxv; j++) {
      System.out.printf(c.name + ""String_Node_Str"",(v + j));
      if (commands[v + j] != null) {
        System.out.println(""String_Node_Str"" + commands[v + j].name);
      }
      commands[v + j]=c;
    }
  }
}",0.9898750538560964
5520,"SPICommand(String pattern){
  String[] subs=pattern.split(""String_Node_Str"");
  name=subs[0];
  System.out.println(""String_Node_Str"" + subs[0]);
  value=0;
  mask=0;
  int c=0;
  int start=0;
  String currentName=""String_Node_Str"";
  bitCount=0;
  for (int i=1; i < subs.length; i++) {
    if (subs[i].equals(""String_Node_Str"")) {
      value=(value << 1) + 1;
      mask=(mask << 1) | 1;
      bitCount++;
    }
 else     if (subs[i].equals(""String_Node_Str"")) {
      value=(value << 1);
      mask=(mask << 1) | 1;
      bitCount++;
    }
 else     if (subs[i].equals(currentName)) {
    }
 else {
      if (start != 0) {
        System.out.println(""String_Node_Str"" + currentName + ""String_Node_Str""+ start+ ""String_Node_Str""+ (c - 1)+ ""String_Node_Str"");
        if (bitFields == null)         bitFields=new ArrayList<SPICommand.BitField>();
        bitFields.add(new BitField(currentName,start,c - 1));
      }
 else {
        System.out.println(""String_Node_Str"" + c);
        if (c < 8) {
          value=value << (8 - c);
          mask=mask << (8 - c);
        }
      }
      currentName=subs[i];
      start=c;
    }
    c++;
  }
  if (start != 0) {
    System.out.println(""String_Node_Str"" + currentName + ""String_Node_Str""+ start+ ""String_Node_Str""+ (c - 1)+ ""String_Node_Str"");
  }
  System.out.printf(""String_Node_Str"",value);
  System.out.printf(""String_Node_Str"",value);
}","SPICommand(String pattern){
  String[] subs=pattern.split(""String_Node_Str"");
  name=subs[0];
  System.out.println(""String_Node_Str"" + subs[0]);
  value=0;
  mask=0;
  int c=0;
  int start=0;
  String currentName=""String_Node_Str"";
  bitCount=0;
  for (int i=1; i < subs.length; i++) {
    if (subs[i].equals(""String_Node_Str"")) {
      if (c < 8) {
        value=(value << 1) + 1;
        mask=(mask << 1) | 1;
        bitCount++;
      }
    }
 else     if (subs[i].equals(""String_Node_Str"")) {
      if (c < 8) {
        value=(value << 1);
        mask=(mask << 1) | 1;
        bitCount++;
      }
    }
 else     if (subs[i].equals(currentName)) {
    }
 else {
      if (start != 0) {
        System.out.println(""String_Node_Str"" + currentName + ""String_Node_Str""+ start+ ""String_Node_Str""+ (c - 1)+ ""String_Node_Str"");
        if (bitFields == null)         bitFields=new ArrayList<SPICommand.BitField>();
        bitFields.add(new BitField(currentName,start,c - 1));
      }
 else {
        System.out.printf(""String_Node_Str"",c,value,mask);
        if (c < 8) {
          value=value << (8 - c);
          mask=mask << (8 - c);
        }
      }
      currentName=subs[i];
      start=c;
    }
    c++;
  }
  if (start != 0) {
    System.out.println(""String_Node_Str"" + currentName + ""String_Node_Str""+ start+ ""String_Node_Str""+ (c - 1)+ ""String_Node_Str"");
  }
  System.out.printf(""String_Node_Str"",value);
  System.out.printf(""String_Node_Str"",mask);
}",0.7038205397826849
5521,"private void readLines(ELFSection sec){
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + sec.getSize());
  }
  sec.reset();
  int endPos=0;
  ArrayList<LineEntry> lineData=new ArrayList<LineEntry>();
  while (sec.getPosition() < sec.getSize()) {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    int totLen=sec.readElf32();
    int version=sec.readElf16();
    int proLen=sec.readElf32();
    int minOpLen=sec.readElf8();
    int defaultIsStmt=sec.readElf8();
    int lineBase=sec.readElf8();
    int lineRange=sec.readElf8();
    int opcodeBase=sec.readElf8();
    endPos+=4 + totLen;
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + totLen + ""String_Node_Str""+ endPos);
      System.out.println(""String_Node_Str"" + proLen);
      System.out.println(""String_Node_Str"" + version);
    }
    if (lineBase > 127) {
      lineBase=lineBase - 256;
    }
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + lineBase);
      System.out.println(""String_Node_Str"" + lineRange);
      System.out.println(""String_Node_Str"" + opcodeBase);
    }
    for (int i=0; i < opcodeBase - 1; i++) {
      sec.readElf8();
    }
    if (DEBUG)     System.out.println(""String_Node_Str"");
    ArrayList<String> directories=new ArrayList<String>();
    directories.add(""String_Node_Str"");
    ArrayList<String> files=new ArrayList<String>();
    StringBuilder sb=new StringBuilder();
    int c;
    while ((c=sec.readElf8()) != 0) {
      sb.append((char)c);
      while ((c=sec.readElf8()) != 0)       sb.append((char)c);
      if (DEBUG)       System.out.println(""String_Node_Str"" + sb.toString());
      directories.add(sb.toString());
      sb.setLength(0);
    }
    if (DEBUG)     System.out.println(""String_Node_Str"");
    long dirIndex=0;
    long time=0;
    long size=0;
    while ((c=sec.readElf8()) != 0) {
      sb.append((char)c);
      while ((c=sec.readElf8()) != 0)       sb.append((char)c);
      dirIndex=sec.readLEB128();
      time=sec.readLEB128();
      size=sec.readLEB128();
      if (DEBUG)       System.out.println(""String_Node_Str"" + sb.toString() + ""String_Node_Str""+ dirIndex+ ""String_Node_Str""+ size);
      files.add(directories.get((int)dirIndex) + ""String_Node_Str"" + sb.toString());
      sb.setLength(0);
    }
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + sec.getPosition() + ""String_Node_Str""+ endPos);
      System.out.println(""String_Node_Str"");
      System.out.print(""String_Node_Str"");
    }
    while (sec.getPosition() < endPos) {
      lineAddress=0;
      lineFile=1;
      lineLine=1;
      lineColumn=0;
      endSequence=false;
      isStatement=defaultIsStmt != 0;
      isBasicBlock=false;
      lineData.clear();
      while (!endSequence) {
        int ins=sec.readElf8();
        if (DEBUG)         System.out.print(""String_Node_Str"" + sec.getPosition() + ""String_Node_Str""+ Utils.hex8(ins)+ ""String_Node_Str"");
switch (ins) {
case DW_LNS_EXT:
          int len=sec.readElf8();
        int extIns=sec.readElf8();
      if (DEBUG)       System.out.println(""String_Node_Str"" + Utils.hex8(extIns));
switch (extIns) {
case DW_LNE_end_sequence:
      endSequence=true;
    if (DEBUG)     System.out.println(""String_Node_Str"");
  break;
case DW_LNE_define_file:
if (DEBUG) System.out.println(""String_Node_Str"");
break;
case DW_LNE_set_address:
if (len == 2) lineAddress=sec.readElf8();
if (len == 3) lineAddress=sec.readElf16();
if (len == 5) lineAddress=sec.readElf32();
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress) + ""String_Node_Str""+ len+ ""String_Node_Str"");
break;
case DW_LNE_set_discriminator:
sec.readLEB128();
break;
}
break;
case DW_LNS_copy:
if (DEBUG) System.out.println(""String_Node_Str"" + lineLine + ""String_Node_Str""+ Utils.hex16(lineAddress)+ ""String_Node_Str"");
lineData.add(new LineEntry(lineLine,lineAddress));
isBasicBlock=false;
break;
case DW_LNS_advance_pc:
long add=sec.readLEB128();
lineAddress+=add * minOpLen;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress));
break;
case DW_LNS_advance_line:
long addLine=sec.readLEB128S();
lineLine+=addLine;
if (DEBUG) System.out.println(""String_Node_Str"" + lineLine + ""String_Node_Str""+ addLine+ ""String_Node_Str"");
break;
case DW_LNS_set_file:
lineFile=(int)sec.readLEB128();
if (DEBUG) System.out.println(""String_Node_Str"" + lineFile);
break;
case DW_LNS_set_column:
lineColumn=(int)sec.readLEB128();
if (DEBUG) System.out.println(""String_Node_Str"" + lineColumn);
break;
case DW_LNS_negate_stmt:
isStatement=!isStatement;
if (DEBUG) System.out.println(""String_Node_Str"");
break;
case DW_LNS_set_basic_block:
isBasicBlock=true;
if (DEBUG) System.out.println(""String_Node_Str"");
break;
case DW_LNS_const_add_pc:
if (DEBUG) System.out.println(""String_Node_Str"");
break;
case DW_LNS_fixed_advance_pc:
int incr=sec.readElf16();
lineAddress+=incr;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress));
break;
default :
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex8(ins));
}
int lineInc=lineBase + ((ins - opcodeBase) % lineRange);
int addrInc=(ins - opcodeBase) / lineRange;
lineAddress+=addrInc * minOpLen;
lineLine+=lineInc;
lineData.add(new LineEntry(lineLine,lineAddress));
isBasicBlock=false;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress) + ""String_Node_Str""+ lineLine+ ""String_Node_Str""+ lineInc);
}
}
if (DEBUG) System.out.println(""String_Node_Str"" + sec.getPosition() + ""String_Node_Str""+ totLen+ ""String_Node_Str""+ endPos);
if (lineData.size() > 0) {
LineData lineTable=new LineData();
lineTable.lineEntries=lineData.toArray(new LineEntry[0]);
lineTable.includeDirs=directories.toArray(new String[0]);
lineTable.sourceFiles=files.toArray(new String[0]);
lineInfo.add(lineTable);
}
}
}
if (DEBUG) {
for (LineData data : lineInfo) {
System.out.println(""String_Node_Str"" + data.sourceFiles[0]);
System.out.println(""String_Node_Str"" + Utils.hex16(data.lineEntries[0].address));
System.out.println(""String_Node_Str"" + Utils.hex16(data.lineEntries[data.lineEntries.length - 1].address));
System.out.println(""String_Node_Str"" + Utils.hex16(data.lineEntries[data.lineEntries.length - 1].address - data.lineEntries[0].address));
}
}
}","private void readLines(ELFSection sec){
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + sec.getSize());
  }
  sec.reset();
  int endPos=0;
  ArrayList<LineEntry> lineData=new ArrayList<LineEntry>();
  while (sec.getPosition() < sec.getSize()) {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    int totLen=sec.readElf32();
    int version=sec.readElf16();
    int proLen=sec.readElf32();
    int minOpLen=sec.readElf8();
    int defaultIsStmt=sec.readElf8();
    int lineBase=Integer.valueOf(sec.readElf8()).byteValue();
    int lineRange=sec.readElf8();
    int opcodeBase=sec.readElf8();
    endPos+=4 + totLen;
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + totLen + ""String_Node_Str""+ endPos);
      System.out.println(""String_Node_Str"" + proLen);
      System.out.println(""String_Node_Str"" + version);
    }
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + lineBase);
      System.out.println(""String_Node_Str"" + lineRange);
      System.out.println(""String_Node_Str"" + opcodeBase);
    }
    for (int i=0; i < opcodeBase - 1; i++) {
      sec.readElf8();
    }
    if (DEBUG)     System.out.println(""String_Node_Str"");
    ArrayList<String> directories=new ArrayList<String>();
    directories.add(""String_Node_Str"");
    ArrayList<String> files=new ArrayList<String>();
    StringBuilder sb=new StringBuilder();
    int c;
    while ((c=sec.readElf8()) != 0) {
      sb.append((char)c);
      while ((c=sec.readElf8()) != 0) {
        sb.append((char)c);
      }
      if (DEBUG)       System.out.println(""String_Node_Str"" + sb.toString());
      directories.add(sb.toString());
      sb.setLength(0);
    }
    if (DEBUG)     System.out.println(""String_Node_Str"");
    long dirIndex=0;
    long time=0;
    long size=0;
    while ((c=sec.readElf8()) != 0) {
      sb.append((char)c);
      while ((c=sec.readElf8()) != 0) {
        sb.append((char)c);
      }
      dirIndex=sec.readLEB128();
      time=sec.readLEB128();
      size=sec.readLEB128();
      if (DEBUG)       System.out.println(""String_Node_Str"" + sb.toString() + ""String_Node_Str""+ dirIndex+ ""String_Node_Str""+ size);
      files.add(directories.get((int)dirIndex) + ""String_Node_Str"" + sb.toString());
      sb.setLength(0);
    }
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + sec.getPosition() + ""String_Node_Str""+ endPos);
      System.out.println(""String_Node_Str"");
      System.out.print(""String_Node_Str"");
    }
    while (sec.getPosition() < endPos) {
      lineAddress=0;
      lineFile=1;
      lineLine=1;
      lineColumn=0;
      endSequence=false;
      isStatement=defaultIsStmt != 0;
      isBasicBlock=false;
      lineData.clear();
      while (!endSequence) {
        int opCode=sec.readElf8();
        if (DEBUG)         System.out.print(""String_Node_Str"" + sec.getPosition() + ""String_Node_Str""+ Utils.hex8(opCode)+ ""String_Node_Str"");
switch (opCode) {
case DW_LNS_EXT:
          int len=(int)sec.readLEB128();
        int extIns=sec.readElf8();
      if (DEBUG)       System.out.println(""String_Node_Str"" + Utils.hex8(extIns));
switch (extIns) {
case DW_LNE_end_sequence:
      endSequence=true;
    lineData.add(new LineEntry(lineLine,lineAddress,lineFile));
  lineAddress=0;
lineFile=1;
lineLine=1;
lineColumn=0;
isStatement=defaultIsStmt != 0;
isBasicBlock=false;
if (DEBUG) System.out.println(""String_Node_Str"");
break;
case DW_LNE_set_address:
lineAddress=sec.readElf16();
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress) + ""String_Node_Str""+ len+ ""String_Node_Str"");
break;
case DW_LNE_define_file:
if (DEBUG) System.out.println(""String_Node_Str"");
break;
case DW_LNE_set_discriminator:
sec.readElf8();
break;
default :
}
break;
case DW_LNS_copy:
if (DEBUG) System.out.println(""String_Node_Str"" + lineLine + ""String_Node_Str""+ Utils.hex16(lineAddress)+ ""String_Node_Str"");
lineData.add(new LineEntry(lineLine,lineAddress,lineFile));
isBasicBlock=false;
break;
case DW_LNS_advance_pc:
long add=sec.readLEB128();
lineAddress+=minOpLen * add;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress));
break;
case DW_LNS_advance_line:
long addLine=sec.readLEB128S();
lineLine+=addLine;
if (DEBUG) System.out.println(""String_Node_Str"" + lineLine + ""String_Node_Str""+ addLine+ ""String_Node_Str"");
break;
case DW_LNS_set_file:
lineFile=(int)sec.readLEB128();
if (DEBUG) System.out.println(""String_Node_Str"" + lineFile);
break;
case DW_LNS_set_column:
lineColumn=(int)sec.readLEB128();
if (DEBUG) System.out.println(""String_Node_Str"" + lineColumn);
break;
case DW_LNS_negate_stmt:
isStatement=!isStatement;
if (DEBUG) System.out.println(""String_Node_Str"");
break;
case DW_LNS_set_basic_block:
isBasicBlock=true;
if (DEBUG) System.out.println(""String_Node_Str"");
break;
case DW_LNS_const_add_pc:
if (DEBUG) System.out.println(""String_Node_Str"");
{
int adjustedOpcode=255 - opcodeBase;
int operationAdvance=adjustedOpcode / lineRange;
lineAddress+=minOpLen * operationAdvance;
}
break;
case DW_LNS_fixed_advance_pc:
int incr=sec.readElf16();
lineAddress+=incr;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress));
break;
case DW_LNS_set_prologue_end:
break;
case DW_LNS_set_epilogue_begin:
break;
case DW_LNS_set_isa:
sec.readLEB128();
break;
default :
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex8(opCode));
}
int adjustedOpcode=opCode - opcodeBase;
int operationAdvance=adjustedOpcode / lineRange;
int lineInc=lineBase + (adjustedOpcode % lineRange);
lineLine+=lineInc;
lineAddress+=minOpLen * operationAdvance;
lineData.add(new LineEntry(lineLine,lineAddress,lineFile));
isBasicBlock=false;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(lineAddress) + ""String_Node_Str""+ lineLine+ ""String_Node_Str""+ lineInc);
}
}
if (DEBUG) System.out.println(""String_Node_Str"" + sec.getPosition() + ""String_Node_Str""+ totLen+ ""String_Node_Str""+ endPos);
if (lineData.size() > 0) {
LineData lineTable=new LineData();
lineTable.lineEntries=lineData.toArray(new LineEntry[0]);
lineTable.includeDirs=directories.toArray(new String[0]);
lineTable.sourceFiles=files.toArray(new String[0]);
lineInfo.add(lineTable);
}
}
}
if (DEBUG) {
for (LineData data : lineInfo) {
System.out.println(""String_Node_Str"" + data.sourceFiles[0]);
System.out.println(""String_Node_Str"" + Utils.hex16(data.lineEntries[0].address));
System.out.println(""String_Node_Str"" + Utils.hex16(data.lineEntries[data.lineEntries.length - 1].address));
System.out.println(""String_Node_Str"" + Utils.hex16(data.lineEntries[data.lineEntries.length - 1].address - data.lineEntries[0].address));
}
}
}",0.8267624326645328
5522,"public DebugInfo getDebugInfo(int address){
  for (int i=0; i < lineInfo.size(); i++) {
    LineData data=lineInfo.get(i);
    int start=data.lineEntries[0].address;
    int end=data.lineEntries[data.lineEntries.length - 1].address;
    if (address <= end && address >= start) {
      for (int j=0; j < data.lineEntries.length; j++) {
        if (data.lineEntries[j].address >= address) {
          return new DebugInfo(data.lineEntries[j].line,null,data.sourceFiles[0],""String_Node_Str"");
        }
      }
    }
  }
  return null;
}","public DebugInfo getDebugInfo(int address){
  for (int i=0; i < lineInfo.size(); i++) {
    LineData data=lineInfo.get(i);
    int start=data.lineEntries[0].address;
    int end=data.lineEntries[data.lineEntries.length - 1].address;
    if (start == 0)     continue;
    if (address <= end && address >= start) {
      for (int j=0; j < data.lineEntries.length; j++) {
        LineEntry lineEntry=data.lineEntries[j];
        int startEntry=lineEntry.address;
        int endEntry;
        if (j + 1 < data.lineEntries.length) {
          endEntry=data.lineEntries[j + 1].address - 1;
        }
 else {
          continue;
        }
        if (address >= startEntry && address <= endEntry) {
          return new DebugInfo(lineEntry.line,null,data.sourceFiles[lineEntry.file - 1],""String_Node_Str"");
        }
      }
    }
  }
  return null;
}",0.6918056562726613
5523,"LineEntry(int line,int adr){
  this.line=line;
  address=adr;
}","LineEntry(int line,int adr,int file){
  this.line=line;
  this.address=adr;
  this.file=file;
}",0.7974683544303798
5524,"public int emulateOP(long maxCycles) throws EmulationException {
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff || flash.blocksCPU()) {
    while (cycles >= nextEventCycles) {
      executeEvents();
    }
    if (interruptsEnabled && interruptMax > 0) {
      return -1;
    }
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return -1;
  }
  CPUMonitor wp=watchPoints[pc];
  if (wp != null) {
    if (breakpointActive) {
      wp.cpuAction(CPUMonitor.EXECUTE,pc,0);
      breakpointActive=false;
      return -1;
    }
    breakpointActive=true;
  }
  wp=globalMonitor;
  if (wp != null) {
    wp.cpuAction(CPUMonitor.EXECUTE,pc,0);
  }
  int pcBefore=pc;
  instruction=read(pc,MODE_WORD);
  int ext3_0=0;
  boolean repeatsInDstReg=false;
  boolean wordx20=false;
  if ((instruction & 0xf800) == 0x1800) {
    extWord=instruction;
    ext3_0=instruction & 0xf;
    pc+=2;
    if ((instruction & 0x80) == 0x80) {
      repeatsInDstReg=true;
    }
    wordx20=(instruction & 0x40) == 0;
    instruction=read(pc,MODE_WORD);
  }
 else {
    extWord=0;
  }
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  int rval=0;
  int repeats=1;
  boolean zeroCarry=false;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 0:
    op=instruction & 0xf0f0;
  if (!MSP430XArch)   throw new EmulationException(""String_Node_Str"");
int src=0;
int srcData=(instruction & 0x0f00) >> 8;
int dstData=(instruction & 0x000f);
boolean rrword=true;
switch (op) {
case MOVA_IND:
writeRegister(dstData,readRegister(srcData));
updateStatus=false;
cycles+=3;
break;
case MOVA_IND_AUTOINC:
if (profiler != null && instruction == 0x0110) {
profiler.profileReturn(cpuCycles);
}
writeRegister(PC,pc);
src=readRegister(srcData);
dst=read(src,MODE_WORD20);
writeRegister(srcData,src + 4);
writeRegister(dstData,dst);
updateStatus=false;
cycles+=3;
break;
case MOVA_ABS2REG:
src=read(pc,MODE_WORD);
writeRegister(PC,pc+=2);
dst=src + (srcData << 16);
dst=read(dst,MODE_WORD20);
writeRegister(dstData,dst);
updateStatus=false;
cycles+=4;
break;
case MOVA_INDX2REG:
int index=read(pc,MODE_WORD);
int indexModifier=readRegister(srcData);
if (index > 0x8000) {
index=-(0x10000 - index);
}
if (indexModifier > 0x8000) {
indexModifier=-(0x10000 - indexModifier);
}
writeRegister(dstData,read(indexModifier + index,MODE_WORD20));
writeRegister(PC,pc+=2);
updateStatus=false;
cycles+=4;
break;
case MOVA_REG2ABS:
dst=read(pc,MODE_WORD);
writeRegister(PC,pc+=2);
write(dst + (dstData << 16),readRegister(srcData),MODE_WORD20);
updateStatus=false;
cycles+=4;
break;
case MOVA_REG2INDX:
index=read(pc,MODE_WORD);
indexModifier=readRegister(dstData);
if (index > 0x8000) {
index=-(0x10000 - index);
}
if (indexModifier > 0x8000) {
indexModifier=-(0x10000 - indexModifier);
}
write(indexModifier + index,readRegister(srcData),MODE_WORD20);
writeRegister(PC,pc+=2);
updateStatus=false;
cycles+=4;
break;
case MOVA_IMM2REG:
src=read(pc,MODE_WORD);
writeRegister(PC,pc+=2);
dst=src + (srcData << 16);
writeRegister(dstData,dst);
updateStatus=false;
cycles+=2;
break;
case ADDA_IMM:
int immData=read(pc,MODE_WORD) + (srcData << 16);
writeRegister(PC,pc+=2);
dst=readRegister(dstData) + immData;
writeRegister(dstData,dst);
cycles+=3;
break;
case CMPA_IMM:
{
immData=read(pc,MODE_WORD) + (srcData << 16);
writeRegister(PC,pc+=2);
sr=readRegister(SR);
int destRegValue=readRegister(dstData);
sr&=~(NEGATIVE | ZERO | CARRY| OVERFLOW);
if (destRegValue >= immData) {
sr|=CARRY;
}
if (destRegValue < immData) {
sr|=NEGATIVE;
}
if (destRegValue == immData) {
sr|=ZERO;
}
int cmpTmp=destRegValue - immData;
int b=0x80000;
if (((destRegValue ^ cmpTmp) & b) == 0 && (((destRegValue ^ immData) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
updateStatus=false;
cycles+=3;
break;
}
case SUBA_IMM:
immData=read(pc,MODE_WORD) + (srcData << 16);
writeRegister(PC,pc+=2);
dst=readRegister(dstData) - immData;
writeRegister(dstData,dst);
cycles+=3;
break;
case MOVA_REG:
cycles+=1;
writeRegister(dstData,readRegister(srcData));
break;
case CMPA_REG:
{
sr=readRegister(SR);
sr&=~(NEGATIVE | ZERO | CARRY| OVERFLOW);
int destRegValue=readRegister(dstData);
int srcRegValue=readRegister(srcData);
if (destRegValue >= srcRegValue) {
sr|=CARRY;
}
if (destRegValue < srcRegValue) {
sr|=NEGATIVE;
}
if (destRegValue == srcRegValue) {
sr|=ZERO;
}
int cmpTmp=destRegValue - srcRegValue;
int b=0x80000;
if (((destRegValue ^ cmpTmp) & b) == 0 && (((destRegValue ^ srcRegValue) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
updateStatus=false;
cycles+=1;
break;
}
case ADDA_REG:
dst=readRegister(dstData) + readRegister(srcData);
writeRegister(dstData,dst);
cycles+=1;
break;
case SUBA_REG:
dst=readRegister(dstData) - readRegister(srcData);
writeRegister(dstData,dst);
cycles+=1;
break;
case RRXX_ADDR:
rrword=false;
case RRXX_WORD:
int count=((instruction >> 10) & 0x03) + 1;
dst=readRegister(dstData);
sr=readRegister(SR);
int nxtCarry=0;
int carry=(sr & CARRY) > 0 ? 1 : 0;
if (rrword) {
dst=dst & 0xffff;
}
cycles+=1 + count;
switch (instruction & RRMASK) {
case RRCM:
int dst_low=dst & ((1 << count) - 1);
nxtCarry=(dst & (1 << (count + 1))) > 0 ? CARRY : 0;
dst=dst >> (count);
if (rrword) {
dst|=(dst_low << (17 - count)) | (carry << (16 - count));
}
 else {
dst|=(dst_low << (21 - count)) | (carry << (20 - count));
}
break;
case RRAM:
if ((dst & (rrword ? 0x8000 : 0x80000)) > 0) {
dst=dst | (rrword ? 0xf8000 : 0xf80000);
}
dst=dst >> (count - 1);
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
break;
case RLAM:
dst=dst << (count - 1);
nxtCarry=(dst & (rrword ? 0x8000 : 0x80000)) > 0 ? CARRY : 0;
dst=dst << 1;
break;
case RRUM:
dst=dst >> (count - 1);
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
break;
}
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
dst=dst & (rrword ? 0xffff : 0xfffff);
writeRegister(dstData,dst);
break;
default :
System.out.println(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
throw new EmulationException(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
}
break;
case 1:
{
dstRegister=instruction & 0xf;
if ((op=instruction & CALLA_MASK) > RETI) {
pc=readRegister(PC);
dst=-1;
updateStatus=false;
switch (op) {
case CALLA_IMM:
dst=(dstRegister << 16) | read(pc,MODE_WORD);
pc+=2;
cycles+=5;
break;
case CALLA_ABS:
dst=(dstRegister << 16) | read(pc,MODE_WORD);
dst=read(dst,MODE_WORD20);
pc+=2;
cycles+=7;
break;
default :
int type=MODE_WORD;
int size=2;
sp=readRegister(SP);
switch (op & 0x1f00) {
case PUSHM_A:
type=MODE_WORD20;
size=4;
cycles+=2;
case PUSHM_W:
int n=1 + ((instruction >> 4) & 0x0f);
int regNo=instruction & 0x0f;
for (int i=0; i < n; i++) {
sp-=size;
cycles+=2;
write(sp,this.reg[regNo--],type);
if (regNo < 0) regNo=15;
}
writeRegister(SP,sp);
break;
case POPM_A:
type=MODE_WORD20;
size=4;
cycles+=2;
case POPM_W:
n=1 + ((instruction >> 4) & 0x0f);
regNo=instruction & 0x0f;
for (int i=0; i < n; i++) {
cycles+=2;
this.reg[regNo++]=read(sp,type);
sp+=size;
if (regNo > 15) regNo=0;
}
writeRegister(SP,sp);
break;
default :
System.out.println(""String_Node_Str"");
throw new EmulationException(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
}
}
if (dst != -1) {
sp=readRegister(SP) - 2;
write(sp,(pc >> 16) & 0xf,MODE_WORD);
sp=sp - 2;
write(sp,pc & 0xffff,MODE_WORD);
writeRegister(SP,sp);
writeRegister(PC,dst);
if (profiler != null) {
profileCall(dst,pc);
}
}
}
 else {
int ad=(instruction >> 4) & 3;
int nxtCarry=0;
op=instruction & 0xff80;
if (op == PUSH || op == CALL) {
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
}
if ((dstRegister == CG1 && ad > AM_INDEX) || dstRegister == CG2) {
dstRegMode=true;
cycles++;
}
 else {
switch (ad) {
case AM_REG:
dstRegMode=true;
cycles++;
break;
case AM_INDEX:
rval=readRegisterCG(dstRegister,ad);
if (rval < 0xffff) {
dstAddress=(rval + read(pc,MODE_WORD)) & 0xffff;
}
 else {
dstAddress=read(pc,MODE_WORD);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
}
cycles+=3;
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (word) {
dst&=0xffff;
}
 else if (wordx20) {
dst&=0xfffff;
}
 else {
dst&=0xff;
}
if (repeatsInDstReg) {
repeats=1 + readRegister(ext3_0);
}
 else {
repeats=1 + ext3_0;
}
zeroCarry=(extWord & EXTWORD_ZC) > 0;
}
 else {
dst=read(dstAddress,word ? MODE_WORD : MODE_BYTE);
}
while (repeats-- > 0) {
sr=readRegister(SR);
if (repeats >= 0) {
if (zeroCarry) {
sr=sr & ~CARRY;
}
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(sr & CARRY) > 0 ? 0x8000 : 0;
}
 else if (wordx20) {
dst|=(sr & CARRY) > 0 ? 0x80000 : 0;
}
 else {
dst|=(sr & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else if (wordx20) {
dst=(dst & 0x80000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xfff00 : dst & 0x7f;
write=true;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case PUSH:
if (word) {
write(sp,dst,MODE_WORD);
}
 else {
write(sp,dst & 0xff,MODE_WORD);
}
cycles+=(ad == AM_REG || ad == AM_IND_AUTOINC) ? 2 : 1;
write=false;
updateStatus=false;
break;
case CALL:
pc=readRegister(PC);
write(sp,pc,MODE_WORD);
writeRegister(PC,dst);
cycles+=(ad == AM_REG) ? 3 : (ad == AM_IND_AUTOINC) ? 2 : 1;
if (profiler != null) {
profileCall(dst,pc);
}
write=false;
updateStatus=false;
break;
case RETI:
servicedInterrupt=-1;
sp=readRegister(SP);
sr=read(sp,MODE_WORD);
writeRegister(SR,sr & 0x0fff);
sp=sp + 2;
writeRegister(PC,read(sp,MODE_WORD) | (sr & 0xf000) << 4);
sp=sp + 2;
writeRegister(SP,sp);
write=false;
updateStatus=false;
cycles+=4;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
if (profiler != null) {
profiler.profileRETI(cycles);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + Utils.hex16(instruction));
}
if (repeats > 0) {
if (word) {
dst&=0xffff;
}
 else if (wordx20) {
dst&=0xfffff;
}
 else {
dst&=0xff;
}
}
}
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
logw(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
updateStatus=false;
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
src=0;
if ((srcRegister == CG1 && as > AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (word) {
src&=0xffff;
}
 else if (wordx20) {
src&=0xfffff;
}
 else {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (word) {
src&=0xffff;
}
 else if (wordx20) {
src&=0xfffff;
}
 else {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
if (dstRegister == PC) cycles++;
if (dstRegMode) {
if (repeatsInDstReg) {
repeats=1 + readRegister(ext3_0);
}
 else {
repeats=1 + ext3_0;
}
zeroCarry=(extWord & EXTWORD_ZC) > 0;
}
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + read(pc,MODE_WORD);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=dstRegMode ? 2 : 5;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
if (dstRegister == PC) {
cycles++;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
if (word) {
dst&=0xffff;
}
 else if (wordx20) {
dst&=0xfffff;
}
 else {
dst&=0xff;
}
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=read(pc,MODE_WORD);
}
 else {
rval=readRegister(dstRegister);
if (rval < 0xffff) {
dstAddress=(rval + read(pc,MODE_WORD)) & 0xffff;
}
 else {
dstAddress=read(pc,MODE_WORD);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
}
if (op != MOV) dst=read(dstAddress,word ? MODE_WORD : MODE_BYTE);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
src=read(srcAddress,word ? MODE_WORD : MODE_BYTE);
}
while (repeats-- > 0) {
sr=readRegister(SR);
if (repeats >= 0) {
if (zeroCarry) {
sr=sr & ~CARRY;
}
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
if (instruction == RETURN && profiler != null) {
profiler.profileReturn(cpuCycles);
}
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((sr & CARRY) > 0) ? 1 : 0;
case ADD:
sr&=~(OVERFLOW | CARRY);
int b=word ? 0x8000 : (wordx20 ? 0x80000 : 0x80);
tmp=(src ^ dst) & b;
dst=dst + src + tmpAdd;
int b2=word ? 0xffff : (wordx20 ? 0xfffff : 0xff);
if (dst > b2) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & b) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
b=word ? 0x8000 : (wordx20 ? 0x80000 : 0x80);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=(dst - src);
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) log(""String_Node_Str"");
dst=dst + src + ((sr & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
sr=sr & ~(CARRY | OVERFLOW);
b=word ? 0x8000 : (wordx20 ? 0x80000 : 0x80);
if ((src & b) != 0 && (dst & b) != 0) {
sr|=OVERFLOW;
}
dst=src ^ dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
case AND:
sr=sr & ~(CARRY | OVERFLOW);
dst=src & dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
default :
logw(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
if (EXCEPTION_ON_BAD_OPERATION) {
EmulationException ex=new EmulationException(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
ex.initCause(new Throwable(""String_Node_Str"" + pc));
throw ex;
}
}
if (repeats > 0 && srcRegister == dstRegister) {
src=dst;
if (word) {
src&=0xffff;
}
 else if (wordx20) {
src&=0xfffff;
}
 else {
src&=0xff;
}
}
}
}
if (word) {
dst&=0xffff;
}
 else if (wordx20) {
dst&=0xfffff;
}
 else {
dst&=0xff;
}
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word ? MODE_WORD : MODE_BYTE);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : (wordx20 ? ((dst & 0x80000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0)));
writeRegister(SR,sr);
}
while (cycles >= nextEventCycles) {
executeEvents();
}
cpuCycles+=cycles - startCycles;
return pcBefore;
}","public int emulateOP(long maxCycles) throws EmulationException {
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff || flash.blocksCPU()) {
    while (cycles >= nextEventCycles) {
      executeEvents();
    }
    if (interruptsEnabled && interruptMax > 0) {
      return -1;
    }
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return -1;
  }
  CPUMonitor wp=watchPoints[pc];
  if (wp != null) {
    if (breakpointActive) {
      wp.cpuAction(CPUMonitor.EXECUTE,pc,0);
      breakpointActive=false;
      return -1;
    }
    breakpointActive=true;
  }
  wp=globalMonitor;
  if (wp != null) {
    wp.cpuAction(CPUMonitor.EXECUTE,pc,0);
  }
  int pcBefore=pc;
  instruction=read(pc,MODE_WORD);
  int ext3_0=0;
  boolean repeatsInDstReg=false;
  boolean wordx20=false;
  if ((instruction & 0xf800) == 0x1800) {
    extWord=instruction;
    ext3_0=instruction & 0xf;
    pc+=2;
    if ((instruction & 0x80) == 0x80) {
      repeatsInDstReg=true;
    }
    wordx20=(instruction & 0x40) == 0;
    instruction=read(pc,MODE_WORD);
  }
 else {
    extWord=0;
  }
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  int rval=0;
  int repeats=1;
  boolean zeroCarry=false;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 0:
    op=instruction & 0xf0f0;
  if (!MSP430XArch)   throw new EmulationException(""String_Node_Str"");
int src=0;
int srcData=(instruction & 0x0f00) >> 8;
int dstData=(instruction & 0x000f);
boolean rrword=true;
switch (op) {
case MOVA_IND:
writeRegister(dstData,readRegister(srcData));
updateStatus=false;
cycles+=3;
break;
case MOVA_IND_AUTOINC:
if (profiler != null && instruction == 0x0110) {
profiler.profileReturn(cpuCycles);
}
writeRegister(PC,pc);
src=readRegister(srcData);
dst=read(src,MODE_WORD20);
writeRegister(srcData,src + 4);
writeRegister(dstData,dst);
updateStatus=false;
cycles+=3;
break;
case MOVA_ABS2REG:
src=read(pc,MODE_WORD);
writeRegister(PC,pc+=2);
dst=src + (srcData << 16);
dst=read(dst,MODE_WORD20);
writeRegister(dstData,dst);
updateStatus=false;
cycles+=4;
break;
case MOVA_INDX2REG:
int index=read(pc,MODE_WORD);
int indexModifier=readRegister(srcData);
if (index > 0x8000) {
index=-(0x10000 - index);
}
if (indexModifier > 0x8000) {
indexModifier=-(0x10000 - indexModifier);
}
writeRegister(dstData,read(indexModifier + index,MODE_WORD20));
writeRegister(PC,pc+=2);
updateStatus=false;
cycles+=4;
break;
case MOVA_REG2ABS:
dst=read(pc,MODE_WORD);
writeRegister(PC,pc+=2);
write(dst + (dstData << 16),readRegister(srcData),MODE_WORD20);
updateStatus=false;
cycles+=4;
break;
case MOVA_REG2INDX:
index=read(pc,MODE_WORD);
indexModifier=readRegister(dstData);
if (index > 0x8000) {
index=-(0x10000 - index);
}
if (indexModifier > 0x8000) {
indexModifier=-(0x10000 - indexModifier);
}
write(indexModifier + index,readRegister(srcData),MODE_WORD20);
writeRegister(PC,pc+=2);
updateStatus=false;
cycles+=4;
break;
case MOVA_IMM2REG:
src=read(pc,MODE_WORD);
writeRegister(PC,pc+=2);
dst=src + (srcData << 16);
writeRegister(dstData,dst);
updateStatus=false;
cycles+=2;
break;
case ADDA_IMM:
int immData=read(pc,MODE_WORD) + (srcData << 16);
writeRegister(PC,pc+=2);
dst=readRegister(dstData) + immData;
writeRegister(dstData,dst);
cycles+=3;
break;
case CMPA_IMM:
{
immData=read(pc,MODE_WORD) + (srcData << 16);
writeRegister(PC,pc+=2);
sr=readRegister(SR);
int destRegValue=readRegister(dstData);
sr&=~(NEGATIVE | ZERO | CARRY| OVERFLOW);
if (destRegValue >= immData) {
sr|=CARRY;
}
if (destRegValue < immData) {
sr|=NEGATIVE;
}
if (destRegValue == immData) {
sr|=ZERO;
}
int cmpTmp=destRegValue - immData;
int b=0x80000;
if (((destRegValue ^ cmpTmp) & b) == 0 && (((destRegValue ^ immData) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
updateStatus=false;
cycles+=3;
break;
}
case SUBA_IMM:
immData=read(pc,MODE_WORD) + (srcData << 16);
writeRegister(PC,pc+=2);
dst=readRegister(dstData) - immData;
writeRegister(dstData,dst);
cycles+=3;
break;
case MOVA_REG:
cycles+=1;
writeRegister(dstData,readRegister(srcData));
break;
case CMPA_REG:
{
sr=readRegister(SR);
sr&=~(NEGATIVE | ZERO | CARRY| OVERFLOW);
int destRegValue=readRegister(dstData);
int srcRegValue=readRegister(srcData);
if (destRegValue >= srcRegValue) {
sr|=CARRY;
}
if (destRegValue < srcRegValue) {
sr|=NEGATIVE;
}
if (destRegValue == srcRegValue) {
sr|=ZERO;
}
int cmpTmp=destRegValue - srcRegValue;
int b=0x80000;
if (((destRegValue ^ cmpTmp) & b) == 0 && (((destRegValue ^ srcRegValue) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
updateStatus=false;
cycles+=1;
break;
}
case ADDA_REG:
dst=readRegister(dstData) + readRegister(srcData);
writeRegister(dstData,dst);
cycles+=1;
break;
case SUBA_REG:
dst=readRegister(dstData) - readRegister(srcData);
writeRegister(dstData,dst);
cycles+=1;
break;
case RRXX_ADDR:
rrword=false;
case RRXX_WORD:
int count=((instruction >> 10) & 0x03) + 1;
dst=readRegister(dstData);
sr=readRegister(SR);
int nxtCarry=0;
int carry=(sr & CARRY) > 0 ? 1 : 0;
if (rrword) {
dst=dst & 0xffff;
}
cycles+=1 + count;
switch (instruction & RRMASK) {
case RRCM:
int dst_low=dst & ((1 << count) - 1);
nxtCarry=(dst & (1 << (count + 1))) > 0 ? CARRY : 0;
dst=dst >> (count);
if (rrword) {
dst|=(dst_low << (17 - count)) | (carry << (16 - count));
}
 else {
dst|=(dst_low << (21 - count)) | (carry << (20 - count));
}
break;
case RRAM:
if ((dst & (rrword ? 0x8000 : 0x80000)) > 0) {
dst=dst | (rrword ? 0xf8000 : 0xf80000);
}
dst=dst >> (count - 1);
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
break;
case RLAM:
dst=dst << (count - 1);
nxtCarry=(dst & (rrword ? 0x8000 : 0x80000)) > 0 ? CARRY : 0;
dst=dst << 1;
break;
case RRUM:
dst=dst >> (count - 1);
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
break;
}
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
dst=dst & (rrword ? 0xffff : 0xfffff);
writeRegister(dstData,dst);
break;
default :
System.out.println(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
throw new EmulationException(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
}
break;
case 1:
{
dstRegister=instruction & 0xf;
if ((op=instruction & CALLA_MASK) > RETI) {
pc=readRegister(PC);
dst=-1;
updateStatus=false;
switch (op) {
case CALLA_IMM:
dst=(dstRegister << 16) | read(pc,MODE_WORD);
pc+=2;
cycles+=5;
break;
case CALLA_ABS:
dst=(dstRegister << 16) | read(pc,MODE_WORD);
dst=read(dst,MODE_WORD20);
pc+=2;
cycles+=7;
break;
default :
int type=MODE_WORD;
int size=2;
sp=readRegister(SP);
switch (op & 0x1f00) {
case PUSHM_A:
type=MODE_WORD20;
size=4;
cycles+=2;
case PUSHM_W:
int n=1 + ((instruction >> 4) & 0x0f);
int regNo=instruction & 0x0f;
for (int i=0; i < n; i++) {
sp-=size;
cycles+=2;
write(sp,this.reg[regNo--],type);
if (regNo < 0) regNo=15;
}
writeRegister(SP,sp);
break;
case POPM_A:
type=MODE_WORD20;
size=4;
cycles+=2;
case POPM_W:
n=1 + ((instruction >> 4) & 0x0f);
regNo=instruction & 0x0f;
for (int i=0; i < n; i++) {
cycles+=2;
this.reg[regNo++]=read(sp,type);
sp+=size;
if (regNo > 15) regNo=0;
}
writeRegister(SP,sp);
break;
default :
System.out.println(""String_Node_Str"");
throw new EmulationException(""String_Node_Str"" + Utils.hex16(instruction) + ""String_Node_Str""+ Utils.hex16(op));
}
}
if (dst != -1) {
sp=readRegister(SP) - 2;
write(sp,(pc >> 16) & 0xf,MODE_WORD);
sp=sp - 2;
write(sp,pc & 0xffff,MODE_WORD);
writeRegister(SP,sp);
writeRegister(PC,dst);
if (profiler != null) {
profileCall(dst,pc);
}
}
}
 else {
int ad=(instruction >> 4) & 3;
int nxtCarry=0;
op=instruction & 0xff80;
if (op == PUSH || op == CALL) {
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
}
if ((dstRegister == CG1 && ad > AM_INDEX) || dstRegister == CG2) {
dstRegMode=true;
cycles++;
}
 else {
switch (ad) {
case AM_REG:
dstRegMode=true;
cycles++;
break;
case AM_INDEX:
rval=readRegisterCG(dstRegister,ad);
if (rval < 0xffff) {
dstAddress=(rval + read(pc,MODE_WORD)) & 0xffff;
}
 else {
dstAddress=read(pc,MODE_WORD);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
}
cycles+=3;
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (word) {
dst&=0xffff;
}
 else if (wordx20) {
dst&=0xfffff;
}
 else {
dst&=0xff;
}
if (repeatsInDstReg) {
repeats=1 + readRegister(ext3_0);
}
 else {
repeats=1 + ext3_0;
}
zeroCarry=(extWord & EXTWORD_ZC) > 0;
}
 else {
dst=read(dstAddress,word ? MODE_WORD : MODE_BYTE);
}
while (repeats-- > 0) {
sr=readRegister(SR);
if (repeats >= 0) {
if (zeroCarry) {
sr=sr & ~CARRY;
}
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(sr & CARRY) > 0 ? 0x8000 : 0;
}
 else if (wordx20) {
dst|=(sr & CARRY) > 0 ? 0x80000 : 0;
}
 else {
dst|=(sr & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else if (wordx20) {
dst=(dst & 0x80000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(sr & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xfff00 : dst & 0x7f;
write=true;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case PUSH:
if (word) {
write(sp,dst,MODE_WORD);
}
 else {
write(sp,dst & 0xff,MODE_WORD);
}
cycles+=(ad == AM_REG || ad == AM_IND_AUTOINC) ? 2 : 1;
write=false;
updateStatus=false;
break;
case CALL:
pc=readRegister(PC);
write(sp,pc,MODE_WORD);
writeRegister(PC,dst);
cycles+=(ad == AM_REG) ? 3 : (ad == AM_IND_AUTOINC) ? 2 : 1;
if (profiler != null) {
profileCall(dst,pc);
}
write=false;
updateStatus=false;
break;
case RETI:
servicedInterrupt=-1;
sp=readRegister(SP);
sr=read(sp,MODE_WORD);
writeRegister(SR,sr & 0x0fff);
sp=sp + 2;
writeRegister(PC,read(sp,MODE_WORD) | (sr & 0xf000) << 4);
sp=sp + 2;
writeRegister(SP,sp);
write=false;
updateStatus=false;
cycles+=4;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
if (profiler != null) {
profiler.profileRETI(cycles);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + Utils.hex16(instruction));
}
if (repeats > 0) {
if (word) {
dst&=0xffff;
}
 else if (wordx20) {
dst&=0xfffff;
}
 else {
dst&=0xff;
}
}
}
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
logw(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
updateStatus=false;
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
src=0;
if ((srcRegister == CG1 && as > AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (word) {
src&=0xffff;
}
 else if (wordx20) {
src&=0xfffff;
}
 else {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (word) {
src&=0xffff;
}
 else if (wordx20) {
src&=0xfffff;
}
 else {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
if (dstRegister == PC) cycles++;
if (dstRegMode) {
if (repeatsInDstReg) {
repeats=1 + readRegister(ext3_0);
}
 else {
repeats=1 + ext3_0;
}
zeroCarry=(extWord & EXTWORD_ZC) > 0;
}
break;
case AM_INDEX:
{
int sval=readRegisterCG(srcRegister,as);
if (sval < 0xffff) {
srcAddress=(sval + read(pc,MODE_WORD)) & 0xffff;
}
 else {
srcAddress=read(pc,MODE_WORD);
if ((srcAddress & 0x8000) > 0) {
srcAddress|=0xf0000;
}
srcAddress+=sval;
srcAddress&=0xfffff;
}
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
}
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=dstRegMode ? 2 : 5;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
if (dstRegister == PC) {
cycles++;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
if (word) {
dst&=0xffff;
}
 else if (wordx20) {
dst&=0xfffff;
}
 else {
dst&=0xff;
}
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=read(pc,MODE_WORD);
}
 else {
rval=readRegister(dstRegister);
if (rval < 0xffff) {
dstAddress=(rval + read(pc,MODE_WORD)) & 0xffff;
}
 else {
dstAddress=read(pc,MODE_WORD);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
}
if (op != MOV) dst=read(dstAddress,word ? MODE_WORD : MODE_BYTE);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
src=read(srcAddress,word ? MODE_WORD : MODE_BYTE);
}
while (repeats-- > 0) {
sr=readRegister(SR);
if (repeats >= 0) {
if (zeroCarry) {
sr=sr & ~CARRY;
}
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
if (instruction == RETURN && profiler != null) {
profiler.profileReturn(cpuCycles);
}
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((sr & CARRY) > 0) ? 1 : 0;
case ADD:
sr&=~(OVERFLOW | CARRY);
int b=word ? 0x8000 : (wordx20 ? 0x80000 : 0x80);
tmp=(src ^ dst) & b;
dst=dst + src + tmpAdd;
int b2=word ? 0xffff : (wordx20 ? 0xfffff : 0xff);
if (dst > b2) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & b) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
b=word ? 0x8000 : (wordx20 ? 0x80000 : 0x80);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=(dst - src);
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) log(""String_Node_Str"");
dst=dst + src + ((sr & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
sr=sr & ~(CARRY | OVERFLOW);
b=word ? 0x8000 : (wordx20 ? 0x80000 : 0x80);
if ((src & b) != 0 && (dst & b) != 0) {
sr|=OVERFLOW;
}
dst=src ^ dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
case AND:
sr=sr & ~(CARRY | OVERFLOW);
dst=src & dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
default :
logw(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
if (EXCEPTION_ON_BAD_OPERATION) {
EmulationException ex=new EmulationException(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
ex.initCause(new Throwable(""String_Node_Str"" + pc));
throw ex;
}
}
if (repeats > 0 && srcRegister == dstRegister) {
src=dst;
if (word) {
src&=0xffff;
}
 else if (wordx20) {
src&=0xfffff;
}
 else {
src&=0xff;
}
}
}
}
if (word) {
dst&=0xffff;
}
 else if (wordx20) {
dst&=0xfffff;
}
 else {
dst&=0xff;
}
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word ? MODE_WORD : MODE_BYTE);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : (wordx20 ? ((dst & 0x80000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0)));
writeRegister(SR,sr);
}
while (cycles >= nextEventCycles) {
executeEvents();
}
cpuCycles+=cycles - startCycles;
return pcBefore;
}",0.993620559334845
5525,"public long stepInstructions(int count) throws EmulationException {
  if (isRunning()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  setRunning(true);
  while (count-- > 0 && isRunning()) {
    int pc=emulateOP(-1);
    if (pc >= 0) {
      if (execCounter != null) {
        execCounter[pc]++;
      }
      if (trace != null) {
        trace[tracePos++]=pc;
        if (tracePos > trace.length)         tracePos=0;
      }
    }
    if (debug) {
      if (servicedInterrupt >= 0) {
        disAsm.disassemble(reg[PC],memory,reg,servicedInterrupt);
      }
 else {
        disAsm.disassemble(reg[PC],memory,reg);
      }
    }
  }
  setRunning(false);
  return cycles;
}","public long stepInstructions(int count) throws EmulationException {
  if (isRunning()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  setRunning(true);
  while (count-- > 0 && isRunning()) {
    int pc=emulateOP(-1);
    if (pc >= 0) {
      if (execCounter != null) {
        execCounter[pc]++;
      }
      if (trace != null) {
        trace[tracePos++]=pc;
        if (tracePos >= trace.length)         tracePos=0;
      }
    }
    if (debug) {
      if (servicedInterrupt >= 0) {
        disAsm.disassemble(reg[PC],memory,reg,servicedInterrupt);
      }
 else {
        disAsm.disassemble(reg[PC],memory,reg);
      }
    }
  }
  setRunning(false);
  return cycles;
}",0.9992748368382888
5526,"public long stepMicros(long jumpMicros,long executeMicros) throws EmulationException {
  int pc;
  if (isRunning()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (jumpMicros < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + jumpMicros);
  }
  if (!microClockReady) {
    lastMicrosCycles=maxCycles;
  }
  lastMicrosDelta+=jumpMicros;
  if (microClockReady) {
    maxCycles=lastMicrosCycles + (lastMicrosDelta * dcoFrq) / 1000000;
    if (cpuOff) {
      if (maxCycles > nextEventCycles) {
        lastMicrosDelta-=jumpMicros;
        printEventQueues(System.out);
        throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles+ ""String_Node_Str""+ nextEventCycles);
      }
    }
 else     if (maxCycles > cycles) {
      lastMicrosDelta-=jumpMicros;
      throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
    }
  }
  microClockReady=true;
  maxCycles=lastMicrosCycles + ((lastMicrosDelta + executeMicros) * dcoFrq) / 1000000;
  while (cycles < maxCycles || (cpuOff && (nextEventCycles < cycles))) {
    if ((pc=emulateOP(maxCycles)) >= 0) {
      if (execCounter != null) {
        execCounter[pc]++;
      }
      if (trace != null) {
        if (tracePos > trace.length) {
          tracePos=0;
        }
        trace[tracePos++]=pc;
      }
      if (debug) {
        if (servicedInterrupt >= 0) {
          disAsm.disassemble(pc,memory,reg,servicedInterrupt);
        }
 else {
          disAsm.disassemble(pc,memory,reg);
        }
      }
    }
  }
  if (cpuOff && !(interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0)) {
    lastReturnedMicros=(1000000 * (nextEventCycles - cycles)) / dcoFrq;
  }
 else {
    lastReturnedMicros=0;
  }
  if (cycles < maxCycles) {
    throw new RuntimeException(""String_Node_Str"" + cycles + ""String_Node_Str""+ maxCycles);
  }
  if (lastReturnedMicros < 0) {
    throw new RuntimeException(""String_Node_Str"" + lastReturnedMicros);
  }
  return lastReturnedMicros;
}","public long stepMicros(long jumpMicros,long executeMicros) throws EmulationException {
  int pc;
  if (isRunning()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (jumpMicros < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + jumpMicros);
  }
  if (!microClockReady) {
    lastMicrosCycles=maxCycles;
  }
  lastMicrosDelta+=jumpMicros;
  if (microClockReady) {
    maxCycles=lastMicrosCycles + (lastMicrosDelta * dcoFrq) / 1000000;
    if (cpuOff) {
      if (maxCycles > nextEventCycles) {
        lastMicrosDelta-=jumpMicros;
        printEventQueues(System.out);
        throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles+ ""String_Node_Str""+ nextEventCycles);
      }
    }
 else     if (maxCycles > cycles) {
      lastMicrosDelta-=jumpMicros;
      throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
    }
  }
  microClockReady=true;
  maxCycles=lastMicrosCycles + ((lastMicrosDelta + executeMicros) * dcoFrq) / 1000000;
  while (cycles < maxCycles || (cpuOff && (nextEventCycles < cycles))) {
    if ((pc=emulateOP(maxCycles)) >= 0) {
      if (execCounter != null) {
        execCounter[pc]++;
      }
      if (trace != null) {
        if (tracePos >= trace.length) {
          tracePos=0;
        }
        trace[tracePos++]=pc;
      }
      if (debug) {
        if (servicedInterrupt >= 0) {
          disAsm.disassemble(pc,memory,reg,servicedInterrupt);
        }
 else {
          disAsm.disassemble(pc,memory,reg);
        }
      }
    }
  }
  if (cpuOff && !(interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0)) {
    lastReturnedMicros=(1000000 * (nextEventCycles - cycles)) / dcoFrq;
  }
 else {
    lastReturnedMicros=0;
  }
  if (cycles < maxCycles) {
    throw new RuntimeException(""String_Node_Str"" + cycles + ""String_Node_Str""+ maxCycles);
  }
  if (lastReturnedMicros < 0) {
    throw new RuntimeException(""String_Node_Str"" + lastReturnedMicros);
  }
  return lastReturnedMicros;
}",0.999754962019113
5527,"public int setup(MSP430Core cpu,ArrayList<IOUnit> ioUnits){
  System.out.println(""String_Node_Str"");
  USART usart0=new USART(cpu,0,cpu.memory,0x70);
  USART usart1=new USART(cpu,1,cpu.memory,0x78);
  for (int i=0, n=8; i < n; i++) {
    cpu.memOut[0x70 + i]=usart0;
    cpu.memIn[0x70 + i]=usart0;
    cpu.memOut[0x78 + i]=usart1;
    cpu.memIn[0x78 + i]=usart1;
  }
  Multiplier mp=new Multiplier(cpu,cpu.memory,0);
  for (int i=0x130, n=0x13f; i < n; i++) {
    cpu.memOut[i]=mp;
    cpu.memIn[i]=mp;
  }
  ioUnits.add(usart0);
  ioUnits.add(usart1);
  DMA dma=new DMA(""String_Node_Str"",cpu.memory,0,cpu);
  for (int i=0, n=24; i < n; i++) {
    cpu.memOut[0x1E0 + i]=dma;
    cpu.memIn[0x1E0 + i]=dma;
  }
  cpu.memOut[0x122]=dma;
  cpu.memIn[0x124]=dma;
  dma.setDMATrigger(DMA.URXIFG0,usart0,0);
  dma.setDMATrigger(DMA.UTXIFG0,usart0,1);
  dma.setDMATrigger(DMA.URXIFG1,usart1,0);
  dma.setDMATrigger(DMA.UTXIFG1,usart1,1);
  dma.setInterruptMultiplexer(new InterruptMultiplexer(cpu,0));
  ioUnits.add(dma);
  ioUnits.add(new IOPort(cpu,1,4,cpu.memory,0x20));
  ioUnits.add(new IOPort(cpu,2,1,cpu.memory,0x28));
  for (int i=0, n=8; i < n; i++) {
    cpu.memOut[0x20 + i]=ioUnits.get(0);
    cpu.memOut[0x28 + i]=ioUnits.get(1);
    cpu.memIn[0x20 + i]=ioUnits.get(0);
    cpu.memIn[0x28 + i]=ioUnits.get(1);
  }
  for (int i=0, n=2; i < n; i++) {
    IOPort p=new IOPort(cpu,(3 + i),0,cpu.memory,0x18 + i * 4);
    ioUnits.add(p);
    cpu.memOut[0x18 + i * 4]=p;
    cpu.memOut[0x19 + i * 4]=p;
    cpu.memOut[0x1a + i * 4]=p;
    cpu.memOut[0x1b + i * 4]=p;
    cpu.memIn[0x18 + i * 4]=p;
    cpu.memIn[0x19 + i * 4]=p;
    cpu.memIn[0x1a + i * 4]=p;
    cpu.memIn[0x1b + i * 4]=p;
  }
  for (int i=0, n=2; i < n; i++) {
    IOPort p=new IOPort(cpu,(5 + i),0,cpu.memory,0x30 + i * 4);
    ioUnits.add(p);
    cpu.memOut[0x30 + i * 4]=p;
    cpu.memOut[0x31 + i * 4]=p;
    cpu.memOut[0x32 + i * 4]=p;
    cpu.memOut[0x33 + i * 4]=p;
    cpu.memIn[0x30 + i * 4]=p;
    cpu.memIn[0x31 + i * 4]=p;
    cpu.memIn[0x32 + i * 4]=p;
    cpu.memIn[0x33 + i * 4]=p;
  }
  return 3 + 6;
}","public int setup(MSP430Core cpu,ArrayList<IOUnit> ioUnits){
  System.out.println(""String_Node_Str"");
  USART usart0=new USART(cpu,0,cpu.memory,0x70);
  USART usart1=new USART(cpu,1,cpu.memory,0x78);
  for (int i=0, n=8; i < n; i++) {
    cpu.memOut[0x70 + i]=usart0;
    cpu.memIn[0x70 + i]=usart0;
    cpu.memOut[0x78 + i]=usart1;
    cpu.memIn[0x78 + i]=usart1;
  }
  Multiplier mp=new Multiplier(cpu,cpu.memory,0);
  for (int i=0x130, n=0x13f; i < n; i++) {
    cpu.memOut[i]=mp;
    cpu.memIn[i]=mp;
  }
  ioUnits.add(usart0);
  ioUnits.add(usart1);
  DMA dma=new DMA(""String_Node_Str"",cpu.memory,0,cpu);
  for (int i=0, n=24; i < n; i++) {
    cpu.memOut[0x1E0 + i]=dma;
    cpu.memIn[0x1E0 + i]=dma;
  }
  cpu.memOut[0x122]=dma;
  cpu.memIn[0x124]=dma;
  dma.setDMATrigger(DMA.URXIFG0,usart0,0);
  dma.setDMATrigger(DMA.UTXIFG0,usart0,1);
  dma.setDMATrigger(DMA.URXIFG1,usart1,0);
  dma.setDMATrigger(DMA.UTXIFG1,usart1,1);
  dma.setInterruptMultiplexer(new InterruptMultiplexer(cpu,0));
  ioUnits.add(dma);
  IOPort io1;
  IOPort io2;
  ioUnits.add(io1=new IOPort(cpu,1,4,cpu.memory,0x20));
  ioUnits.add(io2=new IOPort(cpu,2,1,cpu.memory,0x28));
  for (int i=0, n=8; i < n; i++) {
    cpu.memOut[0x20 + i]=io1;
    cpu.memOut[0x28 + i]=io2;
    cpu.memIn[0x20 + i]=io1;
    cpu.memIn[0x28 + i]=io2;
  }
  for (int i=0, n=2; i < n; i++) {
    IOPort p=new IOPort(cpu,(3 + i),0,cpu.memory,0x18 + i * 4);
    ioUnits.add(p);
    cpu.memOut[0x18 + i * 4]=p;
    cpu.memOut[0x19 + i * 4]=p;
    cpu.memOut[0x1a + i * 4]=p;
    cpu.memOut[0x1b + i * 4]=p;
    cpu.memIn[0x18 + i * 4]=p;
    cpu.memIn[0x19 + i * 4]=p;
    cpu.memIn[0x1a + i * 4]=p;
    cpu.memIn[0x1b + i * 4]=p;
  }
  for (int i=0, n=2; i < n; i++) {
    IOPort p=new IOPort(cpu,(5 + i),0,cpu.memory,0x30 + i * 4);
    ioUnits.add(p);
    cpu.memOut[0x30 + i * 4]=p;
    cpu.memOut[0x31 + i * 4]=p;
    cpu.memOut[0x32 + i * 4]=p;
    cpu.memOut[0x33 + i * 4]=p;
    cpu.memIn[0x30 + i * 4]=p;
    cpu.memIn[0x31 + i * 4]=p;
    cpu.memIn[0x32 + i * 4]=p;
    cpu.memIn[0x33 + i * 4]=p;
  }
  return 3 + 6;
}",0.9659145463274124
5528,"public int setup(MSP430Core cpu,ArrayList<IOUnit> ioUnits){
  Multiplier mp=new Multiplier(cpu,cpu.memory,0);
  for (int i=0x130, n=0x13f; i < n; i++) {
    cpu.memOut[i]=mp;
    cpu.memIn[i]=mp;
  }
  USCI usciA0=new USCI(cpu,0,cpu.memory,this);
  USCI usciB0=new USCI(cpu,1,cpu.memory,this);
  USCI usciA1=new USCI(cpu,2,cpu.memory,this);
  USCI usciB1=new USCI(cpu,3,cpu.memory,this);
  for (int i=0, n=8; i < n; i++) {
    cpu.memOut[0x60 + i]=usciA0;
    cpu.memIn[0x60 + i]=usciA0;
    cpu.memOut[0x68 + i]=usciB0;
    cpu.memIn[0x68 + i]=usciB0;
    cpu.memOut[0xd0 + i]=usciA1;
    cpu.memIn[0xd0 + i]=usciA1;
    cpu.memOut[0xd8 + i]=usciB1;
    cpu.memIn[0xd8 + i]=usciB1;
  }
  cpu.setIO(0x118,usciB0,true);
  cpu.setIO(0x11a,usciB0,true);
  cpu.setIO(0x17c,usciB1,true);
  cpu.setIO(0x17e,usciB1,true);
  ioUnits.add(usciA0);
  ioUnits.add(usciB0);
  ioUnits.add(usciA1);
  ioUnits.add(usciB1);
  cpu.memOut[6]=usciA1;
  cpu.memIn[6]=usciA1;
  cpu.memOut[7]=usciA1;
  cpu.memIn[7]=usciA1;
  ioUnits.add(new IOPort(cpu,1,4,cpu.memory,0x20));
  ioUnits.add(new IOPort(cpu,2,1,cpu.memory,0x28));
  for (int i=0, n=8; i < n; i++) {
    cpu.memOut[0x20 + i]=ioUnits.get(0);
    cpu.memOut[0x28 + i]=ioUnits.get(1);
    cpu.memIn[0x20 + i]=ioUnits.get(0);
    cpu.memIn[0x28 + i]=ioUnits.get(1);
  }
  for (int i=0, n=2; i < n; i++) {
    IOPort p=new IOPort(cpu,(3 + i),0,cpu.memory,0x18 + i * 4);
    ioUnits.add(p);
    cpu.memOut[0x18 + i * 4]=p;
    cpu.memOut[0x19 + i * 4]=p;
    cpu.memOut[0x1a + i * 4]=p;
    cpu.memOut[0x1b + i * 4]=p;
    cpu.memIn[0x18 + i * 4]=p;
    cpu.memIn[0x19 + i * 4]=p;
    cpu.memIn[0x1a + i * 4]=p;
    cpu.memIn[0x1b + i * 4]=p;
  }
  for (int i=0, n=2; i < n; i++) {
    IOPort p=new IOPort(cpu,(5 + i),0,cpu.memory,0x30 + i * 4);
    ioUnits.add(p);
    cpu.memOut[0x30 + i * 4]=p;
    cpu.memOut[0x31 + i * 4]=p;
    cpu.memOut[0x32 + i * 4]=p;
    cpu.memOut[0x33 + i * 4]=p;
    cpu.memIn[0x30 + i * 4]=p;
    cpu.memIn[0x31 + i * 4]=p;
    cpu.memIn[0x32 + i * 4]=p;
    cpu.memIn[0x33 + i * 4]=p;
  }
  return 4 + 6;
}","public int setup(MSP430Core cpu,ArrayList<IOUnit> ioUnits){
  Multiplier mp=new Multiplier(cpu,cpu.memory,0);
  for (int i=0x130, n=0x13f; i < n; i++) {
    cpu.memOut[i]=mp;
    cpu.memIn[i]=mp;
  }
  USCI usciA0=new USCI(cpu,0,cpu.memory,this);
  USCI usciB0=new USCI(cpu,1,cpu.memory,this);
  USCI usciA1=new USCI(cpu,2,cpu.memory,this);
  USCI usciB1=new USCI(cpu,3,cpu.memory,this);
  for (int i=0, n=8; i < n; i++) {
    cpu.memOut[0x60 + i]=usciA0;
    cpu.memIn[0x60 + i]=usciA0;
    cpu.memOut[0x68 + i]=usciB0;
    cpu.memIn[0x68 + i]=usciB0;
    cpu.memOut[0xd0 + i]=usciA1;
    cpu.memIn[0xd0 + i]=usciA1;
    cpu.memOut[0xd8 + i]=usciB1;
    cpu.memIn[0xd8 + i]=usciB1;
  }
  cpu.setIO(0x118,usciB0,true);
  cpu.setIO(0x11a,usciB0,true);
  cpu.setIO(0x17c,usciB1,true);
  cpu.setIO(0x17e,usciB1,true);
  ioUnits.add(usciA0);
  ioUnits.add(usciB0);
  ioUnits.add(usciA1);
  ioUnits.add(usciB1);
  cpu.memOut[6]=usciA1;
  cpu.memIn[6]=usciA1;
  cpu.memOut[7]=usciA1;
  cpu.memIn[7]=usciA1;
  IOPort io1;
  IOPort io2;
  ioUnits.add(io1=new IOPort(cpu,1,4,cpu.memory,0x20));
  ioUnits.add(io2=new IOPort(cpu,2,1,cpu.memory,0x28));
  for (int i=0, n=8; i < n; i++) {
    cpu.memOut[0x20 + i]=io1;
    cpu.memOut[0x28 + i]=io2;
    cpu.memIn[0x20 + i]=io1;
    cpu.memIn[0x28 + i]=io2;
  }
  for (int i=0, n=2; i < n; i++) {
    IOPort p=new IOPort(cpu,(3 + i),0,cpu.memory,0x18 + i * 4);
    ioUnits.add(p);
    cpu.memOut[0x18 + i * 4]=p;
    cpu.memOut[0x19 + i * 4]=p;
    cpu.memOut[0x1a + i * 4]=p;
    cpu.memOut[0x1b + i * 4]=p;
    cpu.memIn[0x18 + i * 4]=p;
    cpu.memIn[0x19 + i * 4]=p;
    cpu.memIn[0x1a + i * 4]=p;
    cpu.memIn[0x1b + i * 4]=p;
  }
  for (int i=0, n=2; i < n; i++) {
    IOPort p=new IOPort(cpu,(5 + i),0,cpu.memory,0x30 + i * 4);
    ioUnits.add(p);
    cpu.memOut[0x30 + i * 4]=p;
    cpu.memOut[0x31 + i * 4]=p;
    cpu.memOut[0x32 + i * 4]=p;
    cpu.memOut[0x33 + i * 4]=p;
    cpu.memIn[0x30 + i * 4]=p;
    cpu.memIn[0x31 + i * 4]=p;
    cpu.memIn[0x32 + i * 4]=p;
    cpu.memIn[0x33 + i * 4]=p;
  }
  return 4 + 6;
}",0.9656839052682455
5529,"private void setFIFOP(boolean fifop){
  fifoP=fifop;
  if (DEBUG)   log(""String_Node_Str"" + fifop);
  if ((registers[REG_IOCFG0] & FIFOP_POLARITY) == FIFOP_POLARITY) {
    fifopPort.setPinState(fifopPin,fifop ? 0 : 1);
  }
 else {
    fifopPort.setPinState(fifopPin,fifop ? 1 : 0);
  }
}","private void setFIFOP(boolean fifop){
  currentFIFOP=fifop;
  if (DEBUG)   log(""String_Node_Str"" + fifop);
  if ((registers[REG_IOCFG0] & FIFOP_POLARITY) == FIFOP_POLARITY) {
    fifopPort.setPinState(fifopPin,fifop ? 0 : 1);
  }
 else {
    fifopPort.setPinState(fifopPin,fifop ? 1 : 0);
  }
}",0.974182444061962
5530,"public String info(){
  updateActiveFrequency();
  return ""String_Node_Str"" + on + ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ ((status & STATUS_XOSC16M_STABLE) > 0)+ ""String_Node_Str""+ ((status & STATUS_RSSI_VALID) > 0)+ ""String_Node_Str""+ cca+ ""String_Node_Str""+ ((registers[REG_IOCFG0] & FIFOP_POLARITY) == FIFOP_POLARITY)+ ""String_Node_Str""+ fifoP+ ""String_Node_Str""+ currentFIFO+ ""String_Node_Str""+ currentSFD+ ""String_Node_Str""+ rxFIFO.stateToString()+ ""String_Node_Str""+ rxlen+ ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ state+ ""String_Node_Str""+ autoAck+ ""String_Node_Str""+ addressDecode+ ""String_Node_Str""+ autoCRC+ ""String_Node_Str""+ Utils.hex8(memory[RAM_PANID + 1])+ Utils.hex8(memory[RAM_PANID])+ ""String_Node_Str""+ Utils.hex8(memory[RAM_SHORTADDR + 1])+ Utils.hex8(memory[RAM_SHORTADDR])+ ""String_Node_Str""+ getLongAddress()+ ""String_Node_Str""+ activeChannel+ ""String_Node_Str""+ fifopThr+ ""String_Node_Str"";
}","public String info(){
  updateActiveFrequency();
  return ""String_Node_Str"" + on + ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ ((status & STATUS_XOSC16M_STABLE) > 0)+ ""String_Node_Str""+ ((status & STATUS_RSSI_VALID) > 0)+ ""String_Node_Str""+ cca+ ""String_Node_Str""+ ((registers[REG_IOCFG0] & FIFOP_POLARITY) == FIFOP_POLARITY)+ ""String_Node_Str""+ currentFIFOP+ ""String_Node_Str""+ currentFIFO+ ""String_Node_Str""+ currentSFD+ ""String_Node_Str""+ rxFIFO.stateToString()+ ""String_Node_Str""+ rxlen+ ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ state+ ""String_Node_Str""+ autoAck+ ""String_Node_Str""+ addressDecode+ ""String_Node_Str""+ autoCRC+ ""String_Node_Str""+ Utils.hex8(memory[RAM_PANID + 1])+ Utils.hex8(memory[RAM_PANID])+ ""String_Node_Str""+ Utils.hex8(memory[RAM_SHORTADDR + 1])+ Utils.hex8(memory[RAM_SHORTADDR])+ ""String_Node_Str""+ getLongAddress()+ ""String_Node_Str""+ activeChannel+ ""String_Node_Str""+ fifopThr+ ""String_Node_Str"";
}",0.9920339883165162
5531,"private void setSFD(boolean sfd){
  if ((registers[REG_IOCFG0] & SFD_POLARITY) == SFD_POLARITY)   sfdPort.setPinState(sfdPin,sfd ? 0 : 1);
 else   sfdPort.setPinState(sfdPin,sfd ? 1 : 0);
  currentSFD=sfd;
  if (DEBUG)   log(""String_Node_Str"" + sfd + ""String_Node_Str""+ cpu.cycles);
}","private void setSFD(boolean sfd){
  currentSFD=sfd;
  if ((registers[REG_IOCFG0] & SFD_POLARITY) == SFD_POLARITY)   sfdPort.setPinState(sfdPin,sfd ? 0 : 1);
 else   sfdPort.setPinState(sfdPin,sfd ? 1 : 0);
  if (DEBUG)   log(""String_Node_Str"" + sfd + ""String_Node_Str""+ cpu.cycles);
}",0.9366197183098592
5532,"public void receivedByte(byte data){
  if (DEBUG)   log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (overflow) {
    }
 else     if (rxFIFO.isFull()) {
      setRxOverflow();
    }
 else {
      if (!frameRejected) {
        rxFIFO.write(data);
        if (rxread == 0) {
          rxCrc.setCRC(0);
          rxlen=data & 0xff;
          decodeAddress=addressDecode;
          if (DEBUG)           log(""String_Node_Str"" + rxlen);
          setFIFO(true);
        }
 else         if (rxread < rxlen - 1) {
          rxCrc.addBitrev(data & 0xff);
          if (rxread == 1) {
            fcf0=data & 0xff;
            frameType=fcf0 & FRAME_TYPE;
          }
 else           if (rxread == 2) {
            fcf1=data & 0xff;
            if (frameType == TYPE_DATA_FRAME) {
              ackRequest=(fcf0 & ACK_REQUEST) > 0;
              destinationAddressMode=(fcf1 >> 2) & 3;
              if (addressDecode && destinationAddressMode != LONG_ADDRESS && destinationAddressMode != SHORT_ADDRESS) {
                rejectFrame();
              }
            }
 else             if (frameType == TYPE_BEACON_FRAME || frameType == TYPE_ACK_FRAME) {
              decodeAddress=false;
              ackRequest=false;
            }
 else             if (addressDecode) {
              rejectFrame();
            }
          }
 else           if (rxread == 3) {
            dsn=data & 0xff;
          }
 else           if (decodeAddress) {
            boolean flushPacket=false;
            if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
              flushPacket=!rxFIFO.tailEquals(memory,RAM_IEEEADDR,8);
              flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,8) && !rxFIFO.tailEquals(BC_ADDRESS,0,2,8);
              decodeAddress=false;
            }
 else             if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
              flushPacket=!rxFIFO.tailEquals(BC_ADDRESS,0,2) && !rxFIFO.tailEquals(memory,RAM_SHORTADDR,2);
              flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,2) && !rxFIFO.tailEquals(BC_ADDRESS,0,2,2);
              decodeAddress=false;
            }
            if (flushPacket) {
              rejectFrame();
            }
          }
        }
        if (fifoP == false && rxFIFO.length() <= rxlen + 1 && !decodeAddress && !frameRejected && rxFIFO.length() > fifopThr) {
          setFIFOP(true);
          if (DEBUG)           log(""String_Node_Str"");
        }
      }
      if (rxread++ == rxlen) {
        if (frameRejected) {
          if (DEBUG)           log(""String_Node_Str"");
          setSFD(false);
          setState(RadioState.RX_WAIT);
          return;
        }
        int crc=rxFIFO.get(-2) << 8;
        crc+=rxFIFO.get(-1);
        crcOk=crc == rxCrc.getCRCBitrev();
        if (DEBUG && !crcOk) {
          log(""String_Node_Str"" + Utils.hex16(crc) + ""String_Node_Str""+ Utils.hex16(rxCrc.getCRCBitrev()));
        }
        rxFIFO.set(-2,registers[REG_RSSI] & 0xff);
        rxFIFO.set(-1,37 | (crcOk ? 0x80 : 0));
        if (rxFIFO.length() <= rxlen + 1) {
          setFIFOP(true);
        }
 else {
          if (DEBUG)           log(""String_Node_Str"" + rxFIFO.length() + ""String_Node_Str""+ rxlen);
        }
        setSFD(false);
        if (DEBUG)         log(""String_Node_Str"" + rxFIFO.stateToString());
        if (((autoAck && ackRequest) || shouldAck) && crcOk) {
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}","public void receivedByte(byte data){
  if (DEBUG)   log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (overflow) {
    }
 else     if (rxFIFO.isFull()) {
      setRxOverflow();
    }
 else {
      if (!frameRejected) {
        rxFIFO.write(data);
        if (rxread == 0) {
          rxCrc.setCRC(0);
          rxlen=data & 0xff;
          decodeAddress=addressDecode;
          if (DEBUG)           log(""String_Node_Str"" + rxlen);
          setFIFO(true);
        }
 else         if (rxread < rxlen - 1) {
          rxCrc.addBitrev(data & 0xff);
          if (rxread == 1) {
            fcf0=data & 0xff;
            frameType=fcf0 & FRAME_TYPE;
          }
 else           if (rxread == 2) {
            fcf1=data & 0xff;
            if (frameType == TYPE_DATA_FRAME) {
              ackRequest=(fcf0 & ACK_REQUEST) > 0;
              destinationAddressMode=(fcf1 >> 2) & 3;
              if (addressDecode && destinationAddressMode != LONG_ADDRESS && destinationAddressMode != SHORT_ADDRESS) {
                rejectFrame();
              }
            }
 else             if (frameType == TYPE_BEACON_FRAME || frameType == TYPE_ACK_FRAME) {
              decodeAddress=false;
              ackRequest=false;
            }
 else             if (addressDecode) {
              rejectFrame();
            }
          }
 else           if (rxread == 3) {
            dsn=data & 0xff;
          }
 else           if (decodeAddress) {
            boolean flushPacket=false;
            if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
              flushPacket=!rxFIFO.tailEquals(memory,RAM_IEEEADDR,8);
              flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,8) && !rxFIFO.tailEquals(BC_ADDRESS,0,2,8);
              decodeAddress=false;
            }
 else             if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
              flushPacket=!rxFIFO.tailEquals(BC_ADDRESS,0,2) && !rxFIFO.tailEquals(memory,RAM_SHORTADDR,2);
              flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,2) && !rxFIFO.tailEquals(BC_ADDRESS,0,2,2);
              decodeAddress=false;
            }
            if (flushPacket) {
              rejectFrame();
            }
          }
        }
        if (currentFIFOP == false && rxFIFO.length() <= rxlen + 1 && !decodeAddress && !frameRejected && rxFIFO.length() > fifopThr) {
          setFIFOP(true);
          if (DEBUG)           log(""String_Node_Str"");
        }
      }
      if (rxread++ == rxlen) {
        if (frameRejected) {
          if (DEBUG)           log(""String_Node_Str"");
          setSFD(false);
          setState(RadioState.RX_WAIT);
          return;
        }
        int crc=rxFIFO.get(-2) << 8;
        crc+=rxFIFO.get(-1);
        crcOk=crc == rxCrc.getCRCBitrev();
        if (DEBUG && !crcOk) {
          log(""String_Node_Str"" + Utils.hex16(crc) + ""String_Node_Str""+ Utils.hex16(rxCrc.getCRCBitrev()));
        }
        rxFIFO.set(-2,registers[REG_RSSI] & 0xff);
        rxFIFO.set(-1,37 | (crcOk ? 0x80 : 0));
        if (rxFIFO.length() <= rxlen + 1) {
          setFIFOP(true);
        }
 else {
          if (DEBUG)           log(""String_Node_Str"" + rxFIFO.length() + ""String_Node_Str""+ rxlen);
        }
        setSFD(false);
        if (DEBUG)         log(""String_Node_Str"" + rxFIFO.stateToString());
        if (((autoAck && ackRequest) || shouldAck) && crcOk) {
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}",0.998149290561382
5533,"public void dataReceived(USARTSource source,int data){
  int oldStatus=status;
  if (DEBUG) {
    log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ ((data >= ' ' && data <= 'Z') ? (char)data : '.')+ ')'+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ state+ ""String_Node_Str""+ stateMachine);
  }
  if (!chipSelect) {
  }
 else   if (stateMachine != RadioState.VREG_OFF) {
switch (state) {
case WAITING:
      if ((data & FLAG_READ) != 0) {
        state=SpiState.READ_REGISTER;
      }
 else {
        state=SpiState.WRITE_REGISTER;
      }
    if ((data & FLAG_RAM) != 0) {
      state=SpiState.RAM_ACCESS;
      address=data & 0x7f;
    }
 else {
      address=data & 0x3f;
      if (address == REG_RXFIFO) {
        state=SpiState.READ_RXFIFO;
      }
 else       if (address == REG_TXFIFO) {
        state=SpiState.WRITE_TXFIFO;
      }
    }
  if (data < 0x0f) {
    strobe(data);
    state=SpiState.WAITING;
  }
pos=0;
break;
case WRITE_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
registers[address]=(registers[address] & 0xff) | (data << 8);
pos=1;
}
 else {
source.byteReceived(registers[address] & 0xff);
registers[address]=(registers[address] & 0xff00) | data;
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
data=registers[address];
setReg(address,data);
state=SpiState.WAITING;
}
break;
case READ_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
pos=1;
}
 else {
source.byteReceived(registers[address] & 0xff);
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
state=SpiState.WAITING;
}
return;
case READ_RXFIFO:
{
int fifoData=rxFIFO.read();
if (DEBUG) log(""String_Node_Str"" + rxFIFO.stateToString());
source.byteReceived(fifoData);
if (fifoP && !overflow) {
if (rxFIFO.length() <= fifopThr) {
if (DEBUG) log(""String_Node_Str"" + rxFIFO.stateToString());
setFIFOP(false);
}
}
if (rxfifoReadLeft == 0) {
rxfifoReadLeft=fifoData;
if (DEBUG) log(""String_Node_Str"" + rxfifoReadLeft + ""String_Node_Str""+ rxFIFO.stateToString());
}
 else if (--rxfifoReadLeft == 0) {
if (rxFIFO.length() > 0) {
if (rxFIFO.length() > rxFIFO.peek(0) || (rxFIFO.length() > fifopThr && !decodeAddress && !frameRejected)) {
if (DEBUG) log(""String_Node_Str"" + rxFIFO.stateToString());
if (!overflow) setFIFOP(true);
}
}
}
if (rxFIFO.length() == 0) {
if (DEBUG) log(""String_Node_Str"");
setFIFO(false);
}
}
return;
case WRITE_TXFIFO:
if (txfifoFlush) {
txCursor=0;
txfifoFlush=false;
}
if (DEBUG) log(""String_Node_Str"" + data + ""String_Node_Str""+ txCursor);
if (txCursor == 0) {
if ((data & 0xff) > 127) {
logger.warning(this,""String_Node_Str"" + (data & 0xff));
}
}
 else if (txCursor > 127) {
logger.warning(this,""String_Node_Str"");
txCursor=0;
}
memory[RAM_TXFIFO + txCursor]=data & 0xff;
txCursor++;
if (sendEvents) {
sendEvent(""String_Node_Str"",null);
}
break;
case RAM_ACCESS:
if (pos == 0) {
address|=(data << 1) & 0x180;
ramRead=(data & 0x20) != 0;
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ ramRead);
}
pos++;
}
 else {
if (!ramRead) {
memory[address++]=data;
if (address >= 0x180) {
logger.warning(this,""String_Node_Str"");
address=0;
}
if (DEBUG && address == RAM_PANID + 2) {
log(""String_Node_Str"" + Utils.hex8(memory[RAM_PANID]) + Utils.hex8(memory[RAM_PANID + 1]));
}
}
 else {
source.byteReceived(memory[address++]);
if (address >= 0x180) {
logger.warning(this,""String_Node_Str"");
address=0;
}
return;
}
}
break;
}
source.byteReceived(oldStatus);
}
 else {
source.byteReceived(0);
logw(""String_Node_Str"");
}
}","public void dataReceived(USARTSource source,int data){
  int oldStatus=status;
  if (DEBUG) {
    log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ ((data >= ' ' && data <= 'Z') ? (char)data : '.')+ ')'+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ state+ ""String_Node_Str""+ stateMachine);
  }
  if (!chipSelect) {
  }
 else   if (stateMachine != RadioState.VREG_OFF) {
switch (state) {
case WAITING:
      if ((data & FLAG_READ) != 0) {
        state=SpiState.READ_REGISTER;
      }
 else {
        state=SpiState.WRITE_REGISTER;
      }
    if ((data & FLAG_RAM) != 0) {
      state=SpiState.RAM_ACCESS;
      usartDataAddress=data & 0x7f;
    }
 else {
      usartDataAddress=data & 0x3f;
      if (usartDataAddress == REG_RXFIFO) {
        state=SpiState.READ_RXFIFO;
      }
 else       if (usartDataAddress == REG_TXFIFO) {
        state=SpiState.WRITE_TXFIFO;
      }
    }
  if (data < 0x0f) {
    strobe(data);
    state=SpiState.WAITING;
  }
usartDataPos=0;
break;
case WRITE_REGISTER:
if (usartDataPos == 0) {
source.byteReceived(registers[usartDataAddress] >> 8);
usartDataValue=data << 8;
usartDataPos=1;
}
 else {
source.byteReceived(registers[usartDataAddress] & 0xff);
usartDataValue|=data;
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex8(usartDataAddress) + ""String_Node_Str""+ usartDataValue);
}
setReg(usartDataAddress,usartDataValue);
state=SpiState.WAITING;
}
break;
case READ_REGISTER:
if (usartDataPos == 0) {
source.byteReceived(registers[usartDataAddress] >> 8);
usartDataPos=1;
}
 else {
source.byteReceived(registers[usartDataAddress] & 0xff);
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex8(usartDataAddress) + ""String_Node_Str""+ registers[usartDataAddress]);
}
state=SpiState.WAITING;
}
return;
case READ_RXFIFO:
{
int fifoData=rxFIFO.read();
if (DEBUG) log(""String_Node_Str"" + rxFIFO.stateToString());
source.byteReceived(fifoData);
if (currentFIFOP && !overflow) {
if (rxFIFO.length() <= fifopThr) {
if (DEBUG) log(""String_Node_Str"" + rxFIFO.stateToString());
setFIFOP(false);
}
}
if (rxfifoReadLeft == 0) {
rxfifoReadLeft=fifoData;
if (DEBUG) log(""String_Node_Str"" + rxfifoReadLeft + ""String_Node_Str""+ rxFIFO.stateToString());
}
 else if (--rxfifoReadLeft == 0) {
if (rxFIFO.length() > 0) {
if (rxFIFO.length() > rxFIFO.peek(0) || (rxFIFO.length() > fifopThr && !decodeAddress && !frameRejected)) {
if (DEBUG) log(""String_Node_Str"" + rxFIFO.stateToString());
if (!overflow) setFIFOP(true);
}
}
}
if (rxFIFO.length() == 0) {
if (DEBUG) log(""String_Node_Str"");
setFIFO(false);
}
}
return;
case WRITE_TXFIFO:
if (txfifoFlush) {
txCursor=0;
txfifoFlush=false;
}
if (DEBUG) log(""String_Node_Str"" + data + ""String_Node_Str""+ txCursor);
if (txCursor == 0) {
if ((data & 0xff) > 127) {
logger.warning(this,""String_Node_Str"" + (data & 0xff));
}
}
 else if (txCursor > 127) {
logger.warning(this,""String_Node_Str"");
txCursor=0;
}
memory[RAM_TXFIFO + txCursor]=data & 0xff;
txCursor++;
if (sendEvents) {
sendEvent(""String_Node_Str"",null);
}
break;
case RAM_ACCESS:
if (usartDataPos == 0) {
usartDataAddress|=(data << 1) & 0x180;
ramRead=(data & FLAG_RAM_READ) != 0;
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex16(usartDataAddress) + ""String_Node_Str""+ ramRead);
}
usartDataPos++;
}
 else {
if (!ramRead) {
memory[usartDataAddress++]=data;
if (usartDataAddress >= 0x180) {
logger.warning(this,""String_Node_Str"");
usartDataAddress=0;
}
if (DEBUG && usartDataAddress == RAM_PANID + 2) {
log(""String_Node_Str"" + Utils.hex8(memory[RAM_PANID]) + Utils.hex8(memory[RAM_PANID + 1]));
}
}
 else {
source.byteReceived(memory[usartDataAddress++]);
if (usartDataAddress >= 0x180) {
logger.warning(this,""String_Node_Str"");
usartDataAddress=0;
}
return;
}
}
break;
}
source.byteReceived(oldStatus);
}
 else {
source.byteReceived(0);
logw(""String_Node_Str"");
}
}",0.9223904813412656
5534,"private void setReg(int address,int data){
  int oldValue=registers[address];
  registers[address]=data;
switch (address) {
case REG_IOCFG0:
    fifopThr=data & FIFOP_THR;
  if (DEBUG)   log(""String_Node_Str"" + registers[address]);
break;
case REG_IOCFG1:
if (DEBUG) log(""String_Node_Str"" + ((registers[address] & SFDMUX) >> SFDMUX) + ""String_Node_Str""+ (registers[address] & CCAMUX));
updateCCA();
break;
case REG_MDMCTRL0:
addressDecode=(data & ADR_DECODE) != 0;
autoCRC=(data & ADR_AUTOCRC) != 0;
autoAck=(data & AUTOACK) != 0;
break;
case REG_FSCTRL:
if (cl != null) {
updateActiveFrequency();
cl.changedChannel(activeChannel);
}
break;
}
configurationChanged(address,oldValue,data);
}","private void setReg(int address,int data){
  int oldValue=registers[address];
  registers[address]=data;
switch (address) {
case REG_IOCFG0:
    fifopThr=data & FIFOP_THR;
  if (DEBUG)   log(""String_Node_Str"" + Utils.hex16(oldValue) + ""String_Node_Str""+ Utils.hex16(data));
if ((oldValue & POLARITY_MASK) != (data & POLARITY_MASK)) {
  setFIFOP(currentFIFOP);
  setFIFO(currentFIFO);
  setSFD(currentSFD);
  setCCA(currentCCA);
}
break;
case REG_IOCFG1:
if (DEBUG) log(""String_Node_Str"" + ((registers[address] & SFDMUX) >> SFDMUX) + ""String_Node_Str""+ (registers[address] & CCAMUX));
updateCCA();
break;
case REG_MDMCTRL0:
addressDecode=(data & ADR_DECODE) != 0;
autoCRC=(data & ADR_AUTOCRC) != 0;
autoAck=(data & AUTOACK) != 0;
break;
case REG_FSCTRL:
if (cl != null) {
updateActiveFrequency();
cl.changedChannel(activeChannel);
}
break;
}
configurationChanged(address,oldValue,data);
}",0.8489847715736041
5535,"private void setFIFO(boolean fifo){
  if (DEBUG)   log(""String_Node_Str"" + fifo);
  currentFIFO=fifo;
  fifoPort.setPinState(fifoPin,fifo ? 1 : 0);
}","private void setFIFO(boolean fifo){
  currentFIFO=fifo;
  if (DEBUG)   log(""String_Node_Str"" + fifo);
  if ((registers[REG_IOCFG0] & FIFO_POLARITY) == FIFO_POLARITY) {
    fifoPort.setPinState(fifoPin,fifo ? 0 : 1);
  }
 else {
    fifoPort.setPinState(fifoPin,fifo ? 1 : 0);
  }
}",0.6139534883720931
5536,"private void setInternalCCA(boolean clear){
  setCCAPin(clear);
  if (DEBUG)   log(""String_Node_Str"" + clear);
}","private void setInternalCCA(boolean clear){
  setCCA(clear);
  if (DEBUG)   log(""String_Node_Str"" + clear);
}",0.986425339366516
5537,"public void setChipSelect(boolean select){
  chipSelect=select;
  if (!chipSelect) {
    state=SpiState.WAITING;
  }
  if (DEBUG) {
    log(""String_Node_Str"" + chipSelect);
  }
}","public void setChipSelect(boolean select){
  chipSelect=select;
  if (!chipSelect) {
    if (state == SpiState.WRITE_REGISTER && usartDataPos == 1) {
      usartDataValue=(registers[usartDataAddress] & 0xff) | (usartDataValue & 0xff00);
      if (DEBUG) {
        log(""String_Node_Str"" + Utils.hex8(usartDataAddress) + ""String_Node_Str""+ usartDataValue);
      }
      setReg(usartDataAddress,usartDataValue);
    }
    state=SpiState.WAITING;
  }
  if (DEBUG) {
    log(""String_Node_Str"" + chipSelect);
  }
}",0.5181950509461426
5538,"public CC2420(MSP430Core cpu){
  super(""String_Node_Str"",""String_Node_Str"",cpu);
  rxFIFO=new ArrayFIFO(""String_Node_Str"",memory,RAM_RXFIFO,128);
  registers[REG_SNOP]=0;
  registers[REG_TXCTRL]=0xa0ff;
  setModeNames(MODE_NAMES);
  setMode(MODE_POWER_OFF);
  fifoP=false;
  rxFIFO.reset();
  overflow=false;
  reset();
}","public CC2420(MSP430Core cpu){
  super(""String_Node_Str"",""String_Node_Str"",cpu);
  rxFIFO=new ArrayFIFO(""String_Node_Str"",memory,RAM_RXFIFO,128);
  registers[REG_SNOP]=0;
  registers[REG_TXCTRL]=0xa0ff;
  setModeNames(MODE_NAMES);
  setMode(MODE_POWER_OFF);
  currentFIFOP=false;
  rxFIFO.reset();
  overflow=false;
  reset();
}",0.9768875192604006
5539,"public int read(int address,int mode) throws EmulationException {
  int val=0;
  if (address > MAX_MEM) {
    printWarning(ADDRESS_OUT_OF_BOUNDS_READ,address);
    address%=MAX_MEM;
  }
  boolean word=mode != MODE_BYTE;
  if (address < MAX_MEM_IO) {
    val=memIn[address].read(address,word,cycles);
    if (mode == MODE_WORD20) {
      val|=memIn[address + 2].read(address,word,cycles) << 16;
    }
  }
 else {
    if (isFlashBusy && flash.addressInFlash(address)) {
      flash.notifyRead(address);
    }
    val=memory[address] & 0xff;
    if (mode > MODE_BYTE) {
      val|=(memory[address + 1] << 8);
      if ((address & 1) != 0) {
        printWarning(MISALIGNED_READ,address);
      }
      if (mode == MODE_WORD20) {
        val|=(memory[address + 2] << 16) | (memory[address + 3] << 24);
        val&=0xfffff;
      }
 else {
        val&=0xffff;
      }
    }
  }
  CPUMonitor wp=watchPoints[address];
  if (wp != null) {
    wp.cpuAction(CPUMonitor.MEMORY_READ,address,val);
  }
  wp=globalMonitor;
  if (wp != null) {
    wp.cpuAction(CPUMonitor.MEMORY_READ,address,val);
  }
  return val;
}","public int read(int address,int mode) throws EmulationException {
  int val=0;
  if (address >= MAX_MEM) {
    printWarning(ADDRESS_OUT_OF_BOUNDS_READ,address);
    address%=MAX_MEM;
  }
  boolean word=mode != MODE_BYTE;
  if (address < MAX_MEM_IO) {
    val=memIn[address].read(address,word,cycles);
    if (mode == MODE_WORD20) {
      val|=memIn[address + 2].read(address,word,cycles) << 16;
    }
  }
 else {
    if (isFlashBusy && flash.addressInFlash(address)) {
      flash.notifyRead(address);
    }
    val=memory[address] & 0xff;
    if (mode > MODE_BYTE) {
      val|=(memory[address + 1] << 8);
      if ((address & 1) != 0) {
        printWarning(MISALIGNED_READ,address);
      }
      if (mode == MODE_WORD20) {
        val|=(memory[address + 2] << 16) | (memory[address + 3] << 24);
        val&=0xfffff;
      }
 else {
        val&=0xffff;
      }
    }
  }
  CPUMonitor wp=watchPoints[address];
  if (wp != null) {
    wp.cpuAction(CPUMonitor.MEMORY_READ,address,val);
  }
  wp=globalMonitor;
  if (wp != null) {
    wp.cpuAction(CPUMonitor.MEMORY_READ,address,val);
  }
  return val;
}",0.9995473064735174
5540,"public String[] getSourceFiles(){
  return null;
}","public String[] getSourceFiles(){
  String[] sourceFilesArray=new String[lineInfo.size()];
  for (int i=0; i < lineInfo.size(); i++) {
    sourceFilesArray[i]=lineInfo.get(i).sourceFiles[0];
  }
  return sourceFilesArray;
}",0.271062271062271
5541,"public ArrayList<Integer> getExecutableAddresses(){
  return null;
}","public ArrayList<Integer> getExecutableAddresses(){
  ArrayList<Integer> executableAddresses=new ArrayList<Integer>();
  for (  LineData data : lineInfo) {
    for (    LineEntry entry : data.lineEntries) {
      executableAddresses.add(entry.address);
    }
  }
  return executableAddresses;
}",0.3149171270718232
5542,"public void receivedByte(byte data){
  if (DEBUG)   log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (overflow) {
    }
 else     if (rxFIFO.isFull()) {
      setRxOverflow();
    }
 else {
      if (!frameRejected) {
        rxFIFO.write(data);
        if (rxread == 0) {
          rxCrc.setCRC(0);
          rxlen=data & 0xff;
          decodeAddress=false;
          if (DEBUG)           log(""String_Node_Str"" + rxlen);
          setFIFO(true);
        }
 else         if (rxread < rxlen - 1) {
          rxCrc.addBitrev(data & 0xff);
          if (rxread == 1) {
            fcf0=data & 0xff;
            frameType=fcf0 & FRAME_TYPE;
          }
 else           if (rxread == 2) {
            fcf1=data & 0xff;
            decodeAddress=addressDecode;
            if (frameType == TYPE_DATA_FRAME) {
              ackRequest=(fcf0 & ACK_REQUEST) > 0;
              destinationAddressMode=(fcf1 >> 2) & 3;
              if (addressDecode && destinationAddressMode != LONG_ADDRESS && destinationAddressMode != SHORT_ADDRESS) {
                rejectFrame();
              }
            }
 else             if (frameType == TYPE_BEACON_FRAME || frameType == TYPE_ACK_FRAME) {
              decodeAddress=false;
              ackRequest=false;
            }
 else             if (addressDecode) {
              rejectFrame();
            }
          }
 else           if (rxread == 3) {
            dsn=data & 0xff;
          }
 else           if (decodeAddress) {
            boolean flushPacket=false;
            if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
              flushPacket=!rxFIFO.tailEquals(memory,RAM_IEEEADDR,8);
              flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,8);
              decodeAddress=false;
            }
 else             if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
              flushPacket=!rxFIFO.tailEquals(BC_ADDRESS,0,2) && !rxFIFO.tailEquals(memory,RAM_SHORTADDR,2);
              flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,2);
              decodeAddress=false;
            }
            if (flushPacket) {
              rejectFrame();
            }
          }
        }
      }
      if (rxread++ == rxlen) {
        if (frameRejected) {
          log(""String_Node_Str"");
          setSFD(false);
          setState(RadioState.RX_WAIT);
          return;
        }
        int crc=rxFIFO.get(-2) << 8;
        crc+=rxFIFO.get(-1);
        if (DEBUG && crc != rxCrc.getCRCBitrev()) {
          log(""String_Node_Str"" + Utils.hex16(crc) + ""String_Node_Str""+ Utils.hex16(rxCrc.getCRCBitrev()));
        }
        rxFIFO.set(-2,registers[REG_RSSI] & 0xff);
        rxFIFO.set(-1,37 | (crc == rxCrc.getCRCBitrev() ? 0x80 : 0));
        if (rxFIFO.length() <= rxlen + 1) {
          setFIFOP(true);
        }
 else {
          if (DEBUG)           log(""String_Node_Str"" + rxFIFO.length() + ""String_Node_Str""+ rxlen);
        }
        setSFD(false);
        if (DEBUG)         log(""String_Node_Str"" + rxFIFO.stateToString());
        if ((autoAck && ackRequest && (crc == rxCrc.getCRCBitrev())) || shouldAck) {
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}","public void receivedByte(byte data){
  if (DEBUG)   log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (overflow) {
    }
 else     if (rxFIFO.isFull()) {
      setRxOverflow();
    }
 else {
      if (!frameRejected) {
        rxFIFO.write(data);
        if (rxread == 0) {
          rxCrc.setCRC(0);
          rxlen=data & 0xff;
          decodeAddress=false;
          if (DEBUG)           log(""String_Node_Str"" + rxlen);
          setFIFO(true);
        }
 else         if (rxread < rxlen - 1) {
          rxCrc.addBitrev(data & 0xff);
          if (rxread == 1) {
            fcf0=data & 0xff;
            frameType=fcf0 & FRAME_TYPE;
          }
 else           if (rxread == 2) {
            fcf1=data & 0xff;
            decodeAddress=addressDecode;
            if (frameType == TYPE_DATA_FRAME) {
              ackRequest=(fcf0 & ACK_REQUEST) > 0;
              destinationAddressMode=(fcf1 >> 2) & 3;
              if (addressDecode && destinationAddressMode != LONG_ADDRESS && destinationAddressMode != SHORT_ADDRESS) {
                rejectFrame();
              }
            }
 else             if (frameType == TYPE_BEACON_FRAME || frameType == TYPE_ACK_FRAME) {
              decodeAddress=false;
              ackRequest=false;
            }
 else             if (addressDecode) {
              rejectFrame();
            }
          }
 else           if (rxread == 3) {
            dsn=data & 0xff;
          }
 else           if (decodeAddress) {
            boolean flushPacket=false;
            if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
              flushPacket=!rxFIFO.tailEquals(memory,RAM_IEEEADDR,8);
              flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,8);
              decodeAddress=false;
            }
 else             if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
              flushPacket=!rxFIFO.tailEquals(BC_ADDRESS,0,2) && !rxFIFO.tailEquals(memory,RAM_SHORTADDR,2);
              flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,2);
              decodeAddress=false;
            }
            if (flushPacket) {
              rejectFrame();
            }
          }
        }
      }
      if (rxread++ == rxlen) {
        if (frameRejected) {
          log(""String_Node_Str"");
          setSFD(false);
          setState(RadioState.RX_WAIT);
          return;
        }
        int crc=rxFIFO.get(-2) << 8;
        crc+=rxFIFO.get(-1);
        crcOk=crc == rxCrc.getCRCBitrev();
        if (DEBUG && !crcOk) {
          log(""String_Node_Str"" + Utils.hex16(crc) + ""String_Node_Str""+ Utils.hex16(rxCrc.getCRCBitrev()));
        }
        rxFIFO.set(-2,registers[REG_RSSI] & 0xff);
        rxFIFO.set(-1,37 | (crcOk ? 0x80 : 0));
        if (rxFIFO.length() <= rxlen + 1) {
          setFIFOP(true);
        }
 else {
          if (DEBUG)           log(""String_Node_Str"" + rxFIFO.length() + ""String_Node_Str""+ rxlen);
        }
        setSFD(false);
        if (DEBUG)         log(""String_Node_Str"" + rxFIFO.stateToString());
        if (((autoAck && ackRequest) || shouldAck) && crcOk) {
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}",0.9785316724092236
5543,"private void strobe(int data){
  if (DEBUG) {
    log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ Reg.values()[data]);
  }
  if ((stateMachine == RadioState.POWER_DOWN) && (data != REG_SXOSCON)) {
    if (DEBUG)     log(""String_Node_Str"" + data + ""String_Node_Str"");
    return;
  }
switch (data) {
case REG_SNOP:
    if (DEBUG)     log(""String_Node_Str"" + Utils.hex8(status) + ""String_Node_Str""+ cpu.cycles);
  break;
case REG_SRXON:
if (stateMachine == RadioState.IDLE) {
  setState(RadioState.RX_CALIBRATE);
  if (DEBUG) {
    log(""String_Node_Str"");
  }
}
 else {
  if (DEBUG)   log(""String_Node_Str"");
}
break;
case REG_SRFOFF:
if (DEBUG) {
log(""String_Node_Str"" + cpu.cycles);
if (stateMachine == RadioState.TX_ACK || stateMachine == RadioState.TX_FRAME || stateMachine == RadioState.RX_FRAME) {
log(""String_Node_Str"" + stateMachine);
}
}
setState(RadioState.IDLE);
break;
case REG_STXON:
if ((stateMachine == RadioState.IDLE) || (stateMachine == RadioState.RX_CALIBRATE) || (stateMachine == RadioState.RX_SFD_SEARCH)|| (stateMachine == RadioState.RX_FRAME)|| (stateMachine == RadioState.RX_OVERFLOW)|| (stateMachine == RadioState.RX_WAIT)) {
status|=STATUS_TX_ACTIVE;
setState(RadioState.TX_CALIBRATE);
if (sendEvents) {
sendEvent(""String_Node_Str"",null);
}
if (DEBUG) log(""String_Node_Str"" + cpu.cycles);
}
break;
case REG_STXONCCA:
if ((stateMachine == RadioState.RX_CALIBRATE) || (stateMachine == RadioState.RX_SFD_SEARCH) || (stateMachine == RadioState.RX_FRAME)|| (stateMachine == RadioState.RX_OVERFLOW)|| (stateMachine == RadioState.RX_WAIT)) {
if (sendEvents) {
sendEvent(""String_Node_Str"",null);
}
if (cca) {
status|=STATUS_TX_ACTIVE;
setState(RadioState.TX_CALIBRATE);
if (DEBUG) log(""String_Node_Str"" + cpu.cycles);
}
 else {
if (DEBUG) log(""String_Node_Str"");
}
}
break;
case REG_SFLUSHRX:
flushRX();
break;
case REG_SFLUSHTX:
if (DEBUG) log(""String_Node_Str"");
flushTX();
break;
case REG_SXOSCON:
startOscillator();
break;
case REG_SXOSCOFF:
stopOscillator();
break;
case REG_SACK:
setState(RadioState.TX_ACK_CALIBRATE);
break;
default :
if (DEBUG) {
log(""String_Node_Str"" + data);
}
break;
}
}","private void strobe(int data){
  if (DEBUG) {
    log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ Reg.values()[data]);
  }
  if ((stateMachine == RadioState.POWER_DOWN) && (data != REG_SXOSCON)) {
    if (DEBUG)     log(""String_Node_Str"" + data + ""String_Node_Str"");
    return;
  }
switch (data) {
case REG_SNOP:
    if (DEBUG)     log(""String_Node_Str"" + Utils.hex8(status) + ""String_Node_Str""+ cpu.cycles);
  break;
case REG_SRXON:
if (stateMachine == RadioState.IDLE) {
  setState(RadioState.RX_CALIBRATE);
  if (DEBUG) {
    log(""String_Node_Str"");
  }
}
 else {
  if (DEBUG)   log(""String_Node_Str"");
}
break;
case REG_SRFOFF:
if (DEBUG) {
log(""String_Node_Str"" + cpu.cycles);
if (stateMachine == RadioState.TX_ACK || stateMachine == RadioState.TX_FRAME || stateMachine == RadioState.RX_FRAME) {
log(""String_Node_Str"" + stateMachine);
}
}
setState(RadioState.IDLE);
break;
case REG_STXON:
if ((stateMachine == RadioState.IDLE) || (stateMachine == RadioState.RX_CALIBRATE) || (stateMachine == RadioState.RX_SFD_SEARCH)|| (stateMachine == RadioState.RX_FRAME)|| (stateMachine == RadioState.RX_OVERFLOW)|| (stateMachine == RadioState.RX_WAIT)) {
status|=STATUS_TX_ACTIVE;
setState(RadioState.TX_CALIBRATE);
if (sendEvents) {
sendEvent(""String_Node_Str"",null);
}
if (DEBUG) log(""String_Node_Str"" + cpu.cycles);
}
break;
case REG_STXONCCA:
if ((stateMachine == RadioState.RX_CALIBRATE) || (stateMachine == RadioState.RX_SFD_SEARCH) || (stateMachine == RadioState.RX_FRAME)|| (stateMachine == RadioState.RX_OVERFLOW)|| (stateMachine == RadioState.RX_WAIT)) {
if (sendEvents) {
sendEvent(""String_Node_Str"",null);
}
if (cca) {
status|=STATUS_TX_ACTIVE;
setState(RadioState.TX_CALIBRATE);
if (DEBUG) log(""String_Node_Str"" + cpu.cycles);
}
 else {
if (DEBUG) log(""String_Node_Str"");
}
}
break;
case REG_SFLUSHRX:
flushRX();
break;
case REG_SFLUSHTX:
if (DEBUG) log(""String_Node_Str"");
flushTX();
break;
case REG_SXOSCON:
startOscillator();
break;
case REG_SXOSCOFF:
stopOscillator();
break;
case REG_SACK:
if (stateMachine == RadioState.RX_FRAME) {
shouldAck=true;
}
 else if (crcOk) {
setState(RadioState.TX_ACK_CALIBRATE);
}
break;
default :
if (DEBUG) {
log(""String_Node_Str"" + data);
}
break;
}
}",0.9810972798524664
5544,"private boolean setState(RadioState state){
  if (DEBUG)   log(""String_Node_Str"" + stateMachine + ""String_Node_Str""+ state);
  stateMachine=state;
  registers[REG_FSMSTATE]=state.getFSMState();
switch (stateMachine) {
case VREG_OFF:
    if (DEBUG)     log(""String_Node_Str"");
  flushRX();
flushTX();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case POWER_DOWN:
rxFIFO.reset();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case RX_CALIBRATE:
setSymbolEvent(12);
setMode(MODE_RX_ON);
break;
case RX_SFD_SEARCH:
zeroSymbols=0;
if ((status & STATUS_RSSI_VALID) == 0) {
setSymbolEvent(8);
}
updateCCA();
setMode(MODE_RX_ON);
break;
case TX_CALIBRATE:
setSymbolEvent(12 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_FRAME:
txfifoPos=0;
txNext();
break;
case RX_WAIT:
setSymbolEvent(8);
setMode(MODE_RX_ON);
break;
case IDLE:
status&=~STATUS_RSSI_VALID;
setMode(MODE_TXRX_OFF);
updateCCA();
break;
case TX_ACK_CALIBRATE:
status|=STATUS_TX_ACTIVE;
setSymbolEvent(12 + 2 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_ACK_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_ACK:
ackPos=0;
ackNext();
break;
case RX_FRAME:
rxFIFO.mark();
rxread=0;
frameRejected=false;
break;
}
if (stateListener != null) {
stateListener.newState(stateMachine);
}
stateChanged(stateMachine.state);
return true;
}","private boolean setState(RadioState state){
  if (DEBUG)   log(""String_Node_Str"" + stateMachine + ""String_Node_Str""+ state);
  stateMachine=state;
  registers[REG_FSMSTATE]=state.getFSMState();
switch (stateMachine) {
case VREG_OFF:
    if (DEBUG)     log(""String_Node_Str"");
  flushRX();
flushTX();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case POWER_DOWN:
rxFIFO.reset();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case RX_CALIBRATE:
setSymbolEvent(12);
setMode(MODE_RX_ON);
break;
case RX_SFD_SEARCH:
zeroSymbols=0;
if ((status & STATUS_RSSI_VALID) == 0) {
setSymbolEvent(8);
}
updateCCA();
setMode(MODE_RX_ON);
break;
case TX_CALIBRATE:
setSymbolEvent(12 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_FRAME:
txfifoPos=0;
txNext();
break;
case RX_WAIT:
setSymbolEvent(8);
setMode(MODE_RX_ON);
break;
case IDLE:
status&=~STATUS_RSSI_VALID;
setMode(MODE_TXRX_OFF);
updateCCA();
break;
case TX_ACK_CALIBRATE:
status|=STATUS_TX_ACTIVE;
setSymbolEvent(12 + 2 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_ACK_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_ACK:
ackPos=0;
ackNext();
break;
case RX_FRAME:
rxFIFO.mark();
rxread=0;
frameRejected=false;
shouldAck=false;
crcOk=false;
break;
}
if (stateListener != null) {
stateListener.newState(stateMachine);
}
stateChanged(stateMachine.state);
return true;
}",0.9904336734693876
5545,"public void setupCommands(ComponentRegistry registry,CommandHandler ch){
  this.registry=registry;
  final MSP430 cpu=(MSP430)registry.getComponent(MSP430.class);
  final GenericNode node=(GenericNode)registry.getComponent(""String_Node_Str"");
  if (cpu != null) {
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int address=0;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        if (baddr < 0) {
          context.err.println(""String_Node_Str"" + context.getArgument(0));
          return 1;
        }
        cpu.setBreakPoint(address=baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            context.out.println(""String_Node_Str"" + Utils.hex16(adr));
            cpu.stop();
          }
        }
);
        context.err.println(""String_Node_Str"" + Utils.hex16(baddr));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int address=0;
      int length=1;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        if (baddr == -1) {
          context.err.println(""String_Node_Str"" + context.getArgument(0));
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          for (int i=1; i < context.getArgumentCount(); i++) {
            String modeStr=context.getArgument(i);
            if (Character.isDigit(modeStr.charAt(0))) {
              length=Integer.parseInt(modeStr);
            }
 else             if (""String_Node_Str"".equals(modeStr)) {
              mode=Utils.ASCII_UNMODIFIED;
            }
 else             if (""String_Node_Str"".equals(modeStr)) {
              mode=10;
            }
 else             if (""String_Node_Str"".equals(modeStr)) {
              mode=Utils.HEX;
            }
          }
        }
        CPUMonitor monitor=new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0 || mode == 10) {
              int pc=cpu.readRegister(0);
              String adrStr=getSymOrAddr(context,adr);
              String pcStr=getSymOrAddrELF(getELF(),pc);
              String op=""String_Node_Str"";
              if (type == MEMORY_READ) {
                op=""String_Node_Str"";
              }
 else               if (type == MEMORY_WRITE) {
                op=""String_Node_Str"";
              }
              context.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pcStr+ ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
              if (mode == 10) {
                cpu.stop();
              }
            }
 else {
              if (length > 1) {
                for (int i=address; i < address + length; i++) {
                  context.out.print(Utils.toString(cpu.memory[i],Utils.BYTE,mode));
                }
                context.out.println();
              }
 else {
                context.out.print(Utils.toString(data,Utils.BYTE,mode));
              }
            }
          }
        }
;
        cpu.setBreakPoint(address=baddr,monitor);
        if (length > 1) {
          for (int i=1; i < length; i++) {
            cpu.setBreakPoint(address + i,monitor);
          }
        }
        context.err.println(""String_Node_Str"" + Utils.hex16(baddr));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
        context.exit(0);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int register=0;
      public int executeCommand(      final CommandContext context){
        register=context.getArgumentAsRegister(0);
        if (register < 0) {
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          String modeStr=context.getArgument(1);
          if (""String_Node_Str"".equals(modeStr)) {
            mode=1;
          }
 else {
            context.err.println(""String_Node_Str"" + modeStr);
            return -1;
          }
        }
        cpu.setRegisterWriteMonitor(register,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0) {
              int pc=cpu.readRegister(0);
              String adrStr=getRegisterName(register);
              String pcStr=getSymOrAddrELF(getELF(),pc);
              context.out.println(""String_Node_Str"" + pcStr + ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
            }
 else {
              context.out.println(data);
            }
          }
        }
);
        context.err.println(""String_Node_Str"" + getRegisterName(register));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(register);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(baddr,null);
        return 0;
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
      public int executeCommand(      final CommandContext context){
        String regExp=context.getArgument(0);
        MapEntry[] entries=context.getMapTable().getEntries(regExp);
        boolean found=false;
        for (int i=0; i < entries.length; i++) {
          MapEntry mapEntry=entries[i];
          int address=mapEntry.getAddress();
          context.out.println(""String_Node_Str"" + mapEntry.getName() + ""String_Node_Str""+ Utils.hex16(address)+ ""String_Node_Str""+ Utils.hex8(cpu.memory[address])+ ""String_Node_Str""+ Utils.hex8(cpu.memory[address + 1])+ ""String_Node_Str""+ mapEntry.getType()+ ""String_Node_Str""+ mapEntry.getFile());
          found=true;
        }
        if (!found) {
          context.err.println(""String_Node_Str"" + regExp + '\'');
        }
        return 0;
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
      public int executeCommand(      final CommandContext context){
        int adr=context.getArgumentAsAddress(0);
        DebugInfo di=getELF().getDebugInfo(adr);
        if (di == null) {
          di=getELF().getDebugInfo(adr + 1);
        }
        if (di != null) {
          di.getLine();
          context.out.println(di);
        }
 else {
          context.err.println(""String_Node_Str"" + context.getArgument(0));
        }
        return 0;
      }
    }
);
    if (node != null) {
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.stop();
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)));
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.start();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          throw new EmulationException(context.getArgument(0));
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int nr=context.getArgumentCount() > 0 ? context.getArgumentAsInt(0) : 1;
          long cyc=cpu.cycles;
          if (cpu.isRunning()) {
            context.err.println(""String_Node_Str"");
            return -1;
          }
          try {
            node.step(nr);
          }
 catch (          Exception e) {
            e.printStackTrace(context.out);
          }
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)) + ""String_Node_Str""+ (cpu.cycles - cyc)+ ""String_Node_Str""+ cpu.cycles+ ""String_Node_Str"");
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          long cyc=cpu.cycles;
          if (cpu.isRunning()) {
            context.err.println(""String_Node_Str"");
            return -1;
          }
          long nxt=0;
          try {
            nxt=cpu.stepMicros(context.getArgumentAsLong(0),context.getArgumentAsLong(1));
          }
 catch (          Exception e) {
            e.printStackTrace(context.out);
          }
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)) + ""String_Node_Str""+ (cpu.cycles - cyc)+ ""String_Node_Str""+ cpu.cycles+ ""String_Node_Str""+ nxt);
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int stackEnd=context.getMapTable().heapStartAddress;
          int stackStart=context.getMapTable().stackStartAddress;
          int current=cpu.readRegister(MSP430Constants.SP);
          context.out.println(""String_Node_Str"" + Utils.hex16(current) + ""String_Node_Str""+ (stackStart - current)+ ""String_Node_Str""+ (stackStart - stackEnd)+ ')');
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int adr=context.getArgumentAsAddress(0);
          if (adr != -1) {
            try {
              context.out.println(context.getArgument(0) + ""String_Node_Str"" + Utils.hex16(cpu.read(adr,adr >= 0x100)));
            }
 catch (            Exception e) {
              e.printStackTrace(context.err);
            }
            return 0;
          }
          context.err.println(""String_Node_Str"" + context.getArgument(0));
          return 1;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int register=context.getArgumentAsRegister(0);
          if (register >= 0) {
            context.out.println(context.getArgument(0) + ""String_Node_Str"" + Utils.hex16(cpu.readRegister(register)));
            return 0;
          }
          return -1;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          cpu.reset();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          long time=((long)(cpu.getTimeMillis()));
          long wallDiff=System.currentTimeMillis() - lastWall;
          context.out.println(""String_Node_Str"" + time + ""String_Node_Str""+ (time - lastCall)+ ""String_Node_Str""+ ""String_Node_Str""+ wallDiff+ ""String_Node_Str""+ (wallDiff == 0 ? ""String_Node_Str"" : ""String_Node_Str"" + (time - lastCall) / wallDiff));
          lastCall=time;
          lastWall=System.currentTimeMillis();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int start=context.getArgumentAsAddress(0);
          if (start < 0) {
            context.err.println(""String_Node_Str"" + context.getArgument(0));
            return 1;
          }
          int count=context.getArgumentAsInt(1);
          int mode=Utils.DEC;
          int type=Utils.UBYTE;
          boolean signed=false;
          if (context.getArgumentCount() > 2) {
            int pos=2;
            int acount=context.getArgumentCount();
            if (acount > 4)             acount=4;
            while (pos < acount) {
              String tS=context.getArgument(pos++);
              if (""String_Node_Str"".equals(tS)) {
              }
 else               if (""String_Node_Str"".equals(tS)) {
                type=Utils.BYTE;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                type=Utils.WORD;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                type=Utils.UWORD;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                mode=Utils.HEX;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                mode=Utils.ASCII;
                type=Utils.BYTE;
              }
            }
          }
          for (int i=0; i < count; i++) {
            int data=0;
            data=cpu.memory[start++];
            if (Utils.size(type) == 2) {
              data=data + (cpu.memory[start++] << 8);
            }
            context.out.print((mode != Utils.ASCII ? ""String_Node_Str"" : ""String_Node_Str"") + Utils.toString(data,type,mode));
          }
          context.out.println();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int count=context.getArgumentCount();
          int adr=context.getArgumentAsAddress(0);
          String arg2=context.getArgument(1);
          int type=Utils.BYTE;
          int mode=Utils.DEC;
          boolean typeRead=false;
          if (count > 2) {
            if (""String_Node_Str"".equals(arg2)) {
              mode=Utils.ASCII;
              typeRead=true;
            }
            if (""String_Node_Str"".equals(arg2)) {
              type=Utils.WORD;
              typeRead=true;
            }
          }
          for (int i=typeRead ? 2 : 1; i < count; i++) {
            if (mode == Utils.DEC) {
              int val=context.getArgumentAsInt(i);
              boolean word=Utils.size(type) == 2 | val > 0xff;
              try {
                cpu.write(adr,val,word);
                adr+=word ? 2 : 1;
              }
 catch (              EmulationException e) {
                e.printStackTrace(context.out);
              }
            }
 else             if (mode == Utils.ASCII) {
              String data=context.getArgument(i);
              for (int j=0; j < data.length(); j++) {
                cpu.write(adr++,data.charAt(j) & 0xff,false);
              }
            }
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          Memory xmem=(Memory)DebugCommands.this.registry.getComponent(""String_Node_Str"");
          if (xmem == null) {
            context.err.println(""String_Node_Str"");
            return 0;
          }
          int start=context.getArgumentAsAddress(0);
          int count=context.getArgumentAsInt(1);
          int size=1;
          boolean signed=false;
          if (context.getArgumentCount() > 2) {
            String tS=context.getArgument(2);
            if (""String_Node_Str"".equals(tS)) {
              signed=true;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              signed=true;
              size=2;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              size=2;
            }
          }
          for (int i=0; i < count; i++) {
            int data=0;
            data=xmem.readByte(start++);
            if (size == 2) {
              data=data + (xmem.readByte(start++) << 8);
            }
            context.out.print(""String_Node_Str"" + data);
          }
          context.out.println();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          Memory xmem=(Memory)DebugCommands.this.registry.getComponent(""String_Node_Str"");
          if (xmem == null) {
            context.err.println(""String_Node_Str"");
            return 0;
          }
          int adr=context.getArgumentAsAddress(0);
          int val=context.getArgumentAsInt(1);
          boolean word=val > 0xff;
          if (word) {
            xmem.writeByte(adr,val >> 8);
            val=val & 0xff;
            adr++;
          }
          xmem.writeByte(adr,val & 0xff);
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        private GDBStubs stubs=null;
        public int executeCommand(        CommandContext context){
          if (stubs != null) {
            context.err.println(""String_Node_Str"");
          }
 else {
            int port=context.getArgumentAsInt(0);
            stubs=new GDBStubs();
            stubs.setupServer(cpu,port);
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
        private Loggable[] loggables=null;
        @Override public int executeCommand(        CommandContext context){
          if (context.getArgumentCount() == 0) {
            Loggable[] loggable=cpu.getLoggables();
            for (            Loggable unit : loggable) {
              String id=unit.getID();
              String name=unit.getName();
              if (id == name) {
                context.out.println(""String_Node_Str"" + id);
              }
 else {
                context.out.println(""String_Node_Str"" + id + ""String_Node_Str""+ name+ ')');
              }
            }
            context.exit(0);
            return 0;
          }
          Loggable[] logs=new Loggable[context.getArgumentCount()];
          for (int i=0, n=context.getArgumentCount(); i < n; i++) {
            logs[i]=cpu.getLoggable(context.getArgument(i));
            if (logs[i] == null) {
              context.err.println(""String_Node_Str"" + context.getArgument(i) + '\'');
              return 1;
            }
          }
          for (          Loggable l : logs) {
            l.setLogStream(context.out);
          }
          this.loggables=logs;
          return 0;
        }
        public void stopCommand(        CommandContext context){
          if (loggables != null) {
            for (            Loggable l : loggables) {
              l.clearLogStream();
            }
          }
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        @Override public int executeCommand(        CommandContext context){
          if (""String_Node_Str"".equals(context.getArgument(0))) {
            int size=cpu.getTraceSize();
            DisAsm disAsm=cpu.getDisAsm();
            for (int i=0; i < size; i++) {
              int pc=cpu.getBackTrace(size - 1 - i);
              DbgInstruction inst=disAsm.getDbgInstruction(pc,cpu);
              inst.setPos(pc);
              System.out.println(inst);
            }
          }
 else {
            cpu.setTrace(context.getArgumentAsInt(0));
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        @Override public int executeCommand(        CommandContext context){
          cpu.printEventQueues(context.out);
          return 0;
        }
      }
);
    }
  }
}","public void setupCommands(ComponentRegistry registry,CommandHandler ch){
  this.registry=registry;
  final MSP430 cpu=(MSP430)registry.getComponent(MSP430.class);
  final GenericNode node=(GenericNode)registry.getComponent(""String_Node_Str"");
  if (cpu != null) {
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int address=0;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        if (baddr < 0) {
          context.err.println(""String_Node_Str"" + context.getArgument(0));
          return 1;
        }
        cpu.setBreakPoint(address=baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            context.out.println(""String_Node_Str"" + Utils.hex16(adr));
            cpu.stop();
          }
        }
);
        context.err.println(""String_Node_Str"" + Utils.hex16(baddr));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int address=0;
      int length=1;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        if (baddr == -1) {
          context.err.println(""String_Node_Str"" + context.getArgument(0));
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          for (int i=1; i < context.getArgumentCount(); i++) {
            String modeStr=context.getArgument(i);
            if (Character.isDigit(modeStr.charAt(0))) {
              length=Integer.parseInt(modeStr);
            }
 else             if (""String_Node_Str"".equals(modeStr)) {
              mode=Utils.ASCII_UNMODIFIED;
            }
 else             if (""String_Node_Str"".equals(modeStr)) {
              mode=10;
            }
 else             if (""String_Node_Str"".equals(modeStr)) {
              mode=Utils.HEX;
            }
          }
        }
        CPUMonitor monitor=new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0 || mode == 10) {
              int pc=cpu.readRegister(0);
              String adrStr=getSymOrAddr(context,adr);
              String pcStr=getSymOrAddrELF(getELF(),pc);
              String op=""String_Node_Str"";
              if (type == MEMORY_READ) {
                op=""String_Node_Str"";
              }
 else               if (type == MEMORY_WRITE) {
                op=""String_Node_Str"";
              }
              context.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pcStr+ ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
              if (mode == 10) {
                cpu.stop();
              }
            }
 else {
              if (length > 1) {
                for (int i=address; i < address + length; i++) {
                  context.out.print(Utils.toString(cpu.memory[i],Utils.BYTE,mode));
                }
                context.out.println();
              }
 else {
                context.out.print(Utils.toString(data,Utils.BYTE,mode));
              }
            }
          }
        }
;
        cpu.setBreakPoint(address=baddr,monitor);
        if (length > 1) {
          for (int i=1; i < length; i++) {
            cpu.setBreakPoint(address + i,monitor);
          }
        }
        context.err.println(""String_Node_Str"" + Utils.hex16(baddr));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
        context.exit(0);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int register=0;
      public int executeCommand(      final CommandContext context){
        register=context.getArgumentAsRegister(0);
        if (register < 0) {
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          String modeStr=context.getArgument(1);
          if (""String_Node_Str"".equals(modeStr)) {
            mode=1;
          }
 else {
            context.err.println(""String_Node_Str"" + modeStr);
            return -1;
          }
        }
        cpu.setRegisterWriteMonitor(register,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0) {
              int pc=cpu.readRegister(0);
              String adrStr=getRegisterName(register);
              String pcStr=getSymOrAddrELF(getELF(),pc);
              context.out.println(""String_Node_Str"" + pcStr + ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
            }
 else {
              context.out.println(data);
            }
          }
        }
);
        context.err.println(""String_Node_Str"" + getRegisterName(register));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(register);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(baddr,null);
        return 0;
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
      public int executeCommand(      final CommandContext context){
        String regExp=context.getArgument(0);
        MapEntry[] entries=context.getMapTable().getEntries(regExp);
        boolean found=false;
        for (int i=0; i < entries.length; i++) {
          MapEntry mapEntry=entries[i];
          int address=mapEntry.getAddress();
          context.out.println(""String_Node_Str"" + mapEntry.getName() + ""String_Node_Str""+ Utils.hex16(address)+ ""String_Node_Str""+ Utils.hex8(cpu.memory[address])+ ""String_Node_Str""+ Utils.hex8(cpu.memory[address + 1])+ ""String_Node_Str""+ mapEntry.getType()+ ""String_Node_Str""+ mapEntry.getFile());
          found=true;
        }
        if (!found) {
          context.err.println(""String_Node_Str"" + regExp + '\'');
        }
        return 0;
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
      public int executeCommand(      final CommandContext context){
        int adr=context.getArgumentAsAddress(0);
        DebugInfo di=getELF().getDebugInfo(adr);
        if (di == null) {
          di=getELF().getDebugInfo(adr + 1);
        }
        if (di != null) {
          di.getLine();
          context.out.println(di);
        }
 else {
          context.err.println(""String_Node_Str"" + context.getArgument(0));
        }
        return 0;
      }
    }
);
    if (node != null) {
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.stop();
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)));
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.start();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          throw new EmulationException(context.getArgument(0));
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int nr=context.getArgumentCount() > 0 ? context.getArgumentAsInt(0) : 1;
          long cyc=cpu.cycles;
          if (cpu.isRunning()) {
            context.err.println(""String_Node_Str"");
            return -1;
          }
          try {
            node.step(nr);
          }
 catch (          Exception e) {
            e.printStackTrace(context.out);
          }
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)) + ""String_Node_Str""+ (cpu.cycles - cyc)+ ""String_Node_Str""+ cpu.cycles+ ""String_Node_Str"");
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          long cyc=cpu.cycles;
          if (cpu.isRunning()) {
            context.err.println(""String_Node_Str"");
            return -1;
          }
          long nxt=0;
          try {
            nxt=cpu.stepMicros(context.getArgumentAsLong(0),context.getArgumentAsLong(1));
          }
 catch (          Exception e) {
            e.printStackTrace(context.out);
          }
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)) + ""String_Node_Str""+ (cpu.cycles - cyc)+ ""String_Node_Str""+ cpu.cycles+ ""String_Node_Str""+ nxt);
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int stackEnd=context.getMapTable().heapStartAddress;
          int stackStart=context.getMapTable().stackStartAddress;
          int current=cpu.readRegister(MSP430Constants.SP);
          context.out.println(""String_Node_Str"" + Utils.hex16(current) + ""String_Node_Str""+ (stackStart - current)+ ""String_Node_Str""+ (stackStart - stackEnd)+ ')');
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int adr=context.getArgumentAsAddress(0);
          if (adr != -1) {
            try {
              context.out.println(context.getArgument(0) + ""String_Node_Str"" + Utils.hex16(cpu.read(adr,adr >= 0x100 ? MSP430Constants.MODE_WORD : MSP430Constants.MODE_BYTE)));
            }
 catch (            Exception e) {
              e.printStackTrace(context.err);
            }
            return 0;
          }
          context.err.println(""String_Node_Str"" + context.getArgument(0));
          return 1;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int register=context.getArgumentAsRegister(0);
          if (register >= 0) {
            context.out.println(context.getArgument(0) + ""String_Node_Str"" + Utils.hex16(cpu.readRegister(register)));
            return 0;
          }
          return -1;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          cpu.reset();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          long time=((long)(cpu.getTimeMillis()));
          long wallDiff=System.currentTimeMillis() - lastWall;
          context.out.println(""String_Node_Str"" + time + ""String_Node_Str""+ (time - lastCall)+ ""String_Node_Str""+ ""String_Node_Str""+ wallDiff+ ""String_Node_Str""+ (wallDiff == 0 ? ""String_Node_Str"" : ""String_Node_Str"" + (time - lastCall) / wallDiff));
          lastCall=time;
          lastWall=System.currentTimeMillis();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int start=context.getArgumentAsAddress(0);
          if (start < 0) {
            context.err.println(""String_Node_Str"" + context.getArgument(0));
            return 1;
          }
          int count=context.getArgumentAsInt(1);
          int mode=Utils.DEC;
          int type=Utils.UBYTE;
          boolean signed=false;
          if (context.getArgumentCount() > 2) {
            int pos=2;
            int acount=context.getArgumentCount();
            if (acount > 4)             acount=4;
            while (pos < acount) {
              String tS=context.getArgument(pos++);
              if (""String_Node_Str"".equals(tS)) {
              }
 else               if (""String_Node_Str"".equals(tS)) {
                type=Utils.BYTE;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                type=Utils.WORD;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                type=Utils.UWORD;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                mode=Utils.HEX;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                mode=Utils.ASCII;
                type=Utils.BYTE;
              }
            }
          }
          for (int i=0; i < count; i++) {
            int data=0;
            data=cpu.memory[start++];
            if (Utils.size(type) == 2) {
              data=data + (cpu.memory[start++] << 8);
            }
            context.out.print((mode != Utils.ASCII ? ""String_Node_Str"" : ""String_Node_Str"") + Utils.toString(data,type,mode));
          }
          context.out.println();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int count=context.getArgumentCount();
          int adr=context.getArgumentAsAddress(0);
          String arg2=context.getArgument(1);
          int type=Utils.BYTE;
          int mode=Utils.DEC;
          boolean typeRead=false;
          if (count > 2) {
            if (""String_Node_Str"".equals(arg2)) {
              mode=Utils.ASCII;
              typeRead=true;
            }
            if (""String_Node_Str"".equals(arg2)) {
              type=Utils.WORD;
              typeRead=true;
            }
          }
          for (int i=typeRead ? 2 : 1; i < count; i++) {
            if (mode == Utils.DEC) {
              int val=context.getArgumentAsInt(i);
              boolean word=Utils.size(type) == 2 | val > 0xff;
              try {
                cpu.write(adr,val,word ? MSP430Constants.MODE_WORD : MSP430Constants.MODE_BYTE);
                adr+=word ? 2 : 1;
              }
 catch (              EmulationException e) {
                e.printStackTrace(context.out);
              }
            }
 else             if (mode == Utils.ASCII) {
              String data=context.getArgument(i);
              for (int j=0; j < data.length(); j++) {
                cpu.write(adr++,data.charAt(j) & 0xff,MSP430Constants.MODE_WORD);
              }
            }
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          Memory xmem=(Memory)DebugCommands.this.registry.getComponent(""String_Node_Str"");
          if (xmem == null) {
            context.err.println(""String_Node_Str"");
            return 0;
          }
          int start=context.getArgumentAsAddress(0);
          int count=context.getArgumentAsInt(1);
          int size=1;
          boolean signed=false;
          if (context.getArgumentCount() > 2) {
            String tS=context.getArgument(2);
            if (""String_Node_Str"".equals(tS)) {
              signed=true;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              signed=true;
              size=2;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              size=2;
            }
          }
          for (int i=0; i < count; i++) {
            int data=0;
            data=xmem.readByte(start++);
            if (size == 2) {
              data=data + (xmem.readByte(start++) << 8);
            }
            context.out.print(""String_Node_Str"" + data);
          }
          context.out.println();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          Memory xmem=(Memory)DebugCommands.this.registry.getComponent(""String_Node_Str"");
          if (xmem == null) {
            context.err.println(""String_Node_Str"");
            return 0;
          }
          int adr=context.getArgumentAsAddress(0);
          int val=context.getArgumentAsInt(1);
          boolean word=val > 0xff;
          if (word) {
            xmem.writeByte(adr,val >> 8);
            val=val & 0xff;
            adr++;
          }
          xmem.writeByte(adr,val & 0xff);
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        private GDBStubs stubs=null;
        public int executeCommand(        CommandContext context){
          if (stubs != null) {
            context.err.println(""String_Node_Str"");
          }
 else {
            int port=context.getArgumentAsInt(0);
            stubs=new GDBStubs();
            stubs.setupServer(cpu,port);
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
        private Loggable[] loggables=null;
        @Override public int executeCommand(        CommandContext context){
          if (context.getArgumentCount() == 0) {
            Loggable[] loggable=cpu.getLoggables();
            for (            Loggable unit : loggable) {
              String id=unit.getID();
              String name=unit.getName();
              if (id == name) {
                context.out.println(""String_Node_Str"" + id);
              }
 else {
                context.out.println(""String_Node_Str"" + id + ""String_Node_Str""+ name+ ')');
              }
            }
            context.exit(0);
            return 0;
          }
          Loggable[] logs=new Loggable[context.getArgumentCount()];
          for (int i=0, n=context.getArgumentCount(); i < n; i++) {
            logs[i]=cpu.getLoggable(context.getArgument(i));
            if (logs[i] == null) {
              context.err.println(""String_Node_Str"" + context.getArgument(i) + '\'');
              return 1;
            }
          }
          for (          Loggable l : logs) {
            l.setLogStream(context.out);
          }
          this.loggables=logs;
          return 0;
        }
        public void stopCommand(        CommandContext context){
          if (loggables != null) {
            for (            Loggable l : loggables) {
              l.clearLogStream();
            }
          }
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        @Override public int executeCommand(        CommandContext context){
          if (""String_Node_Str"".equals(context.getArgument(0))) {
            int size=cpu.getTraceSize();
            DisAsm disAsm=cpu.getDisAsm();
            for (int i=0; i < size; i++) {
              int pc=cpu.getBackTrace(size - 1 - i);
              DbgInstruction inst=disAsm.getDbgInstruction(pc,cpu);
              inst.setPos(pc);
              System.out.println(inst);
            }
          }
 else {
            cpu.setTrace(context.getArgumentAsInt(0));
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        @Override public int executeCommand(        CommandContext context){
          cpu.printEventQueues(context.out);
          return 0;
        }
      }
);
    }
  }
}",0.9964702957991548
5546,"private void handleCmd(String cmd,int[] cmdBytes,int cmdLen) throws IOException, EmulationException {
  System.out.println(""String_Node_Str"" + cmd);
  char c=cmd.charAt(0);
switch (c) {
case 'H':
    sendResponse(OK);
  break;
case 'q':
if (""String_Node_Str"".equals(cmd)) {
  sendResponse(""String_Node_Str"");
}
 else if (""String_Node_Str"".equals(cmd)) {
  sendResponse(""String_Node_Str"");
}
 else if (""String_Node_Str"".equals(cmd)) {
  sendResponse(""String_Node_Str"");
}
 else if (""String_Node_Str"".equals(cmd)) {
  sendResponse(""String_Node_Str"");
}
 else if (""String_Node_Str"".equals(cmd)) {
  sendResponse(OK);
}
 else {
  System.out.println(""String_Node_Str"");
  sendResponse(""String_Node_Str"");
}
break;
case '?':
sendResponse(""String_Node_Str"");
break;
case 'g':
readRegisters();
break;
case 'k':
sendResponse(OK);
break;
case 'm':
case 'M':
case 'X':
String cmd2=cmd.substring(1);
String wdata[]=cmd2.split(""String_Node_Str"");
int cPos=cmd.indexOf(':');
if (cPos > 0) {
cmd2=wdata[0];
}
String parts[]=cmd2.split(""String_Node_Str"");
int addr=Integer.decode(""String_Node_Str"" + parts[0]);
int len=Integer.decode(""String_Node_Str"" + parts[1]);
String data=""String_Node_Str"";
if (c == 'm') {
System.out.println(""String_Node_Str"" + addr + ""String_Node_Str""+ len);
for (int i=0; i < len; i++) {
data+=Utils.hex8(cpu.memory[addr++] & 0xff);
}
sendResponse(data);
}
 else {
System.out.println(""String_Node_Str"" + addr + ""String_Node_Str""+ len+ ""String_Node_Str""+ ((wdata.length > 1) ? wdata[1] : ""String_Node_Str""));
cPos++;
for (int i=0; i < len; i++) {
System.out.println(""String_Node_Str"" + cmdBytes[cPos] + ""String_Node_Str""+ addr+ ""String_Node_Str""+ cPos);
cpu.write(addr++,cmdBytes[cPos++],false);
}
sendResponse(OK);
}
break;
case 'C':
sendResponse(""String_Node_Str"");
break;
default :
System.out.println(""String_Node_Str"");
sendResponse(""String_Node_Str"");
}
}","private void handleCmd(String cmd,int[] cmdBytes,int cmdLen) throws IOException, EmulationException {
  System.out.println(""String_Node_Str"" + cmd);
  char c=cmd.charAt(0);
switch (c) {
case 'H':
    sendResponse(OK);
  break;
case 'q':
if (""String_Node_Str"".equals(cmd)) {
  sendResponse(""String_Node_Str"");
}
 else if (""String_Node_Str"".equals(cmd)) {
  sendResponse(""String_Node_Str"");
}
 else if (""String_Node_Str"".equals(cmd)) {
  sendResponse(""String_Node_Str"");
}
 else if (""String_Node_Str"".equals(cmd)) {
  sendResponse(""String_Node_Str"");
}
 else if (""String_Node_Str"".equals(cmd)) {
  sendResponse(OK);
}
 else {
  System.out.println(""String_Node_Str"");
  sendResponse(""String_Node_Str"");
}
break;
case '?':
sendResponse(""String_Node_Str"");
break;
case 'g':
readRegisters();
break;
case 'k':
sendResponse(OK);
break;
case 'm':
case 'M':
case 'X':
String cmd2=cmd.substring(1);
String wdata[]=cmd2.split(""String_Node_Str"");
int cPos=cmd.indexOf(':');
if (cPos > 0) {
cmd2=wdata[0];
}
String parts[]=cmd2.split(""String_Node_Str"");
int addr=Integer.decode(""String_Node_Str"" + parts[0]);
int len=Integer.decode(""String_Node_Str"" + parts[1]);
String data=""String_Node_Str"";
if (c == 'm') {
System.out.println(""String_Node_Str"" + addr + ""String_Node_Str""+ len);
for (int i=0; i < len; i++) {
data+=Utils.hex8(cpu.memory[addr++] & 0xff);
}
sendResponse(data);
}
 else {
System.out.println(""String_Node_Str"" + addr + ""String_Node_Str""+ len+ ""String_Node_Str""+ ((wdata.length > 1) ? wdata[1] : ""String_Node_Str""));
cPos++;
for (int i=0; i < len; i++) {
System.out.println(""String_Node_Str"" + cmdBytes[cPos] + ""String_Node_Str""+ addr+ ""String_Node_Str""+ cPos);
cpu.write(addr++,cmdBytes[cPos++],MSP430Constants.MODE_BYTE);
}
sendResponse(OK);
}
break;
case 'C':
sendResponse(""String_Node_Str"");
break;
default :
System.out.println(""String_Node_Str"");
sendResponse(""String_Node_Str"");
}
}",0.9920127795527156
5547,"private void run() throws EmulationException {
  while (isRunning()) {
    if (debug) {
      if (servicedInterrupt >= 0) {
        disAsm.disassemble(reg[PC],memory,reg,servicedInterrupt);
      }
 else {
        disAsm.disassemble(reg[PC],memory,reg);
      }
    }
    if (cycles > nextOut && !debug) {
      printCPUSpeed(reg[PC]);
      nextOut=cycles + 20000007;
    }
    if (emulateOP(-1)) {
      instCtr++;
      if (execCounter != null) {
        execCounter[reg[PC]]++;
      }
      if (trace != null) {
        trace[tracePos++]=reg[PC];
        if (tracePos >= trace.length)         tracePos=0;
      }
    }
    if (cycles > nextSleep) {
      try {
        Thread.sleep(10);
      }
 catch (      Exception e) {
      }
      nextSleep=cycles + sleepRate;
    }
  }
}","private void run() throws EmulationException {
  int pc;
  while (isRunning()) {
    if (debug) {
      if (servicedInterrupt >= 0) {
        disAsm.disassemble(reg[PC],memory,reg,servicedInterrupt);
      }
 else {
        disAsm.disassemble(reg[PC],memory,reg);
      }
    }
    if (cycles > nextOut && !debug) {
      printCPUSpeed(reg[PC]);
      nextOut=cycles + 20000007;
    }
    if ((pc=emulateOP(-1)) >= 0) {
      instCtr++;
      if (execCounter != null) {
        execCounter[pc]++;
      }
      if (trace != null) {
        trace[tracePos++]=pc;
        if (tracePos >= trace.length)         tracePos=0;
      }
    }
    if (cycles > nextSleep) {
      try {
        Thread.sleep(10);
      }
 catch (      Exception e) {
      }
      nextSleep=cycles + sleepRate;
    }
  }
}",0.9759188846641318
5548,"public long stepInstructions(int count) throws EmulationException {
  if (isRunning()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  setRunning(true);
  while (count-- > 0 && isRunning()) {
    if (debug) {
      if (servicedInterrupt >= 0) {
        disAsm.disassemble(reg[PC],memory,reg,servicedInterrupt);
      }
 else {
        disAsm.disassemble(reg[PC],memory,reg);
      }
    }
    boolean emuOP=emulateOP(-1);
    if (emuOP) {
      if (execCounter != null) {
        execCounter[reg[PC]]++;
      }
      if (trace != null) {
        trace[tracePos++]=reg[PC];
        if (tracePos > trace.length)         tracePos=0;
      }
    }
  }
  setRunning(false);
  return cycles;
}","public long stepInstructions(int count) throws EmulationException {
  if (isRunning()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  setRunning(true);
  while (count-- > 0 && isRunning()) {
    int pc=emulateOP(-1);
    if (pc >= 0) {
      if (execCounter != null) {
        execCounter[pc]++;
      }
      if (trace != null) {
        trace[tracePos++]=pc;
        if (tracePos > trace.length)         tracePos=0;
      }
    }
    if (debug) {
      if (servicedInterrupt >= 0) {
        disAsm.disassemble(reg[PC],memory,reg,servicedInterrupt);
      }
 else {
        disAsm.disassemble(reg[PC],memory,reg);
      }
    }
  }
  setRunning(false);
  return cycles;
}",0.6432160804020101
5549,"public long stepMicros(long jumpMicros,long executeMicros) throws EmulationException {
  if (isRunning()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (jumpMicros < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + jumpMicros);
  }
  if (!microClockReady) {
    lastMicrosCycles=maxCycles;
  }
  lastMicrosDelta+=jumpMicros;
  if (microClockReady) {
    maxCycles=lastMicrosCycles + (lastMicrosDelta * dcoFrq) / 1000000;
    if (cpuOff) {
      if (maxCycles > nextEventCycles) {
        lastMicrosDelta-=jumpMicros;
        printEventQueues(System.out);
        throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles+ ""String_Node_Str""+ nextEventCycles);
      }
    }
 else     if (maxCycles > cycles) {
      lastMicrosDelta-=jumpMicros;
      throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
    }
  }
  microClockReady=true;
  maxCycles=lastMicrosCycles + ((lastMicrosDelta + executeMicros) * dcoFrq) / 1000000;
  if (debug) {
    if (servicedInterrupt >= 0) {
      disAsm.disassemble(reg[PC],memory,reg,servicedInterrupt);
    }
 else {
      disAsm.disassemble(reg[PC],memory,reg);
    }
  }
  while (cycles < maxCycles || (cpuOff && (nextEventCycles < cycles))) {
    if (emulateOP(maxCycles)) {
      if (execCounter != null) {
        execCounter[reg[PC]]++;
      }
      if (trace != null) {
        if (tracePos > trace.length) {
          tracePos=0;
        }
        trace[tracePos++]=reg[PC];
      }
    }
  }
  if (cpuOff && !(interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0)) {
    lastReturnedMicros=(1000000 * (nextEventCycles - cycles)) / dcoFrq;
  }
 else {
    lastReturnedMicros=0;
  }
  if (cycles < maxCycles) {
    throw new RuntimeException(""String_Node_Str"" + cycles + ""String_Node_Str""+ maxCycles);
  }
  if (lastReturnedMicros < 0) {
    throw new RuntimeException(""String_Node_Str"" + lastReturnedMicros);
  }
  return lastReturnedMicros;
}","public long stepMicros(long jumpMicros,long executeMicros) throws EmulationException {
  int pc;
  if (isRunning()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (jumpMicros < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + jumpMicros);
  }
  if (!microClockReady) {
    lastMicrosCycles=maxCycles;
  }
  lastMicrosDelta+=jumpMicros;
  if (microClockReady) {
    maxCycles=lastMicrosCycles + (lastMicrosDelta * dcoFrq) / 1000000;
    if (cpuOff) {
      if (maxCycles > nextEventCycles) {
        lastMicrosDelta-=jumpMicros;
        printEventQueues(System.out);
        throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles+ ""String_Node_Str""+ nextEventCycles);
      }
    }
 else     if (maxCycles > cycles) {
      lastMicrosDelta-=jumpMicros;
      throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
    }
  }
  microClockReady=true;
  maxCycles=lastMicrosCycles + ((lastMicrosDelta + executeMicros) * dcoFrq) / 1000000;
  while (cycles < maxCycles || (cpuOff && (nextEventCycles < cycles))) {
    if ((pc=emulateOP(maxCycles)) >= 0) {
      if (execCounter != null) {
        execCounter[reg[PC]]++;
      }
      if (trace != null) {
        if (tracePos > trace.length) {
          tracePos=0;
        }
        trace[tracePos++]=pc;
      }
      if (debug) {
        if (servicedInterrupt >= 0) {
          disAsm.disassemble(pc,memory,reg,servicedInterrupt);
        }
 else {
          disAsm.disassemble(pc,memory,reg);
        }
      }
    }
  }
  if (cpuOff && !(interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0)) {
    lastReturnedMicros=(1000000 * (nextEventCycles - cycles)) / dcoFrq;
  }
 else {
    lastReturnedMicros=0;
  }
  if (cycles < maxCycles) {
    throw new RuntimeException(""String_Node_Str"" + cycles + ""String_Node_Str""+ maxCycles);
  }
  if (lastReturnedMicros < 0) {
    throw new RuntimeException(""String_Node_Str"" + lastReturnedMicros);
  }
  return lastReturnedMicros;
}",0.8572837071727878
5550,"public MSP430Core(int type,ComponentRegistry registry,MSP430Config config){
  super(""String_Node_Str"",""String_Node_Str"",null);
  MAX_INTERRUPT=config.maxInterruptVector;
  MAX_MEM_IO=config.maxMemIO;
  MAX_MEM=config.maxMem;
  memOut=new IOUnit[MAX_MEM_IO];
  memIn=new IOUnit[MAX_MEM_IO];
  MSP430XArch=config.MSP430XArch;
  memory=new int[MAX_MEM];
  breakPoints=new CPUMonitor[MAX_MEM];
  IOUnit voidIO=new IOUnit(id,memory,0){
    public void interruptServiced(    int vector){
    }
    public void write(    int address,    int value,    boolean word,    long cycles){
      logw(""String_Node_Str"" + address);
    }
    public int read(    int address,    boolean word,    long cycles){
      logw(""String_Node_Str"" + address);
      return 0;
    }
  }
;
  for (int i=0; i < MAX_MEM_IO; i++) {
    memOut[i]=voidIO;
    memIn[i]=voidIO;
  }
  this.registry=registry;
  this.config=config;
  addChip(this);
  setModeNames(MODE_NAMES);
  ioUnits=new ArrayList<IOUnit>();
  Timer ta=new Timer(this,memory,config.timerConfig[0]);
  Timer tb=new Timer(this,memory,config.timerConfig[1]);
  for (int i=0, n=0x20; i < n; i++) {
    memOut[config.timerConfig[0].offset + i]=ta;
    memIn[config.timerConfig[0].offset + i]=ta;
    memOut[config.timerConfig[1].offset + i]=tb;
    memIn[config.timerConfig[1].offset + i]=tb;
  }
  flash=new Flash(this,memory,new FlashRange(0x4000,0x10000,512,64),new FlashRange(0x1000,0x01100,128,64));
  for (int i=0x128; i < 0x12e; i++) {
    memOut[i]=flash;
    memIn[i]=flash;
  }
  sfr=new SFR(this,memory);
  for (int i=0, n=0x10; i < n; i++) {
    memOut[i]=sfr;
    memIn[i]=sfr;
  }
  watchdog=new Watchdog(this);
  memOut[0x120]=watchdog;
  memIn[0x120]=watchdog;
  memIn[Timer.TAIV]=ta;
  memOut[Timer.TAIV]=ta;
  memIn[Timer.TBIV]=tb;
  memOut[Timer.TBIV]=tb;
  bcs=new BasicClockModule(this,memory,0,new Timer[]{ta,tb});
  for (int i=0x56, n=0x59; i < n; i++) {
    memOut[i]=bcs;
    memIn[i]=bcs;
  }
  Multiplier mp=new Multiplier(this,memory,0);
  for (int i=0x130, n=0x13f; i < n; i++) {
    memOut[i]=mp;
    memIn[i]=mp;
  }
  ioUnits.add(sfr);
  ioUnits.add(bcs);
  config.setup(this,ioUnits);
  ioUnits.add(ta);
  ioUnits.add(tb);
  ADC12 adc12=new ADC12(this);
  ioUnits.add(adc12);
  ioUnits.add(watchdog);
  for (int i=0, n=16; i < n; i++) {
    memOut[0x80 + i]=adc12;
    memIn[0x80 + i]=adc12;
    memOut[0x140 + i]=adc12;
    memIn[0x140 + i]=adc12;
    memOut[0x150 + i]=adc12;
    memIn[0x150 + i]=adc12;
  }
  for (int i=0, n=8; i < n; i++) {
    memOut[0x1A0 + i]=adc12;
    memIn[0x1A0 + i]=adc12;
  }
}","public MSP430Core(int type,ComponentRegistry registry,MSP430Config config){
  super(""String_Node_Str"",""String_Node_Str"",null);
  MAX_INTERRUPT=config.maxInterruptVector;
  MAX_MEM_IO=config.maxMemIO;
  MAX_MEM=config.maxMem;
  memOut=new IOUnit[MAX_MEM_IO];
  memIn=new IOUnit[MAX_MEM_IO];
  MSP430XArch=config.MSP430XArch;
  memory=new int[MAX_MEM];
  breakPoints=new CPUMonitor[MAX_MEM];
  System.out.println(""String_Node_Str"" + MAX_MEM + ""String_Node_Str"");
  IOUnit voidIO=new IOUnit(id,memory,0){
    public void interruptServiced(    int vector){
    }
    public void write(    int address,    int value,    boolean word,    long cycles){
      logw(""String_Node_Str"" + address);
    }
    public int read(    int address,    boolean word,    long cycles){
      logw(""String_Node_Str"" + address);
      return 0;
    }
  }
;
  for (int i=0; i < MAX_MEM_IO; i++) {
    memOut[i]=voidIO;
    memIn[i]=voidIO;
  }
  this.registry=registry;
  this.config=config;
  addChip(this);
  setModeNames(MODE_NAMES);
  ioUnits=new ArrayList<IOUnit>();
  Timer ta=new Timer(this,memory,config.timerConfig[0]);
  Timer tb=new Timer(this,memory,config.timerConfig[1]);
  for (int i=0, n=0x20; i < n; i++) {
    memOut[config.timerConfig[0].offset + i]=ta;
    memIn[config.timerConfig[0].offset + i]=ta;
    memOut[config.timerConfig[1].offset + i]=tb;
    memIn[config.timerConfig[1].offset + i]=tb;
  }
  flash=new Flash(this,memory,new FlashRange(0x4000,0x10000,512,64),new FlashRange(0x1000,0x01100,128,64));
  for (int i=0x128; i < 0x12e; i++) {
    memOut[i]=flash;
    memIn[i]=flash;
  }
  sfr=new SFR(this,memory);
  for (int i=0, n=0x10; i < n; i++) {
    memOut[i]=sfr;
    memIn[i]=sfr;
  }
  watchdog=new Watchdog(this);
  memOut[0x120]=watchdog;
  memIn[0x120]=watchdog;
  memIn[Timer.TAIV]=ta;
  memOut[Timer.TAIV]=ta;
  memIn[Timer.TBIV]=tb;
  memOut[Timer.TBIV]=tb;
  bcs=new BasicClockModule(this,memory,0,new Timer[]{ta,tb});
  for (int i=0x56, n=0x59; i < n; i++) {
    memOut[i]=bcs;
    memIn[i]=bcs;
  }
  Multiplier mp=new Multiplier(this,memory,0);
  for (int i=0x130, n=0x13f; i < n; i++) {
    memOut[i]=mp;
    memIn[i]=mp;
  }
  ioUnits.add(sfr);
  ioUnits.add(bcs);
  config.setup(this,ioUnits);
  ioUnits.add(ta);
  ioUnits.add(tb);
  ADC12 adc12=new ADC12(this);
  ioUnits.add(adc12);
  ioUnits.add(watchdog);
  for (int i=0, n=16; i < n; i++) {
    memOut[0x80 + i]=adc12;
    memIn[0x80 + i]=adc12;
    memOut[0x140 + i]=adc12;
    memIn[0x140 + i]=adc12;
    memOut[0x150 + i]=adc12;
    memIn[0x150 + i]=adc12;
  }
  for (int i=0, n=8; i < n; i++) {
    memOut[0x1A0 + i]=adc12;
    memIn[0x1A0 + i]=adc12;
  }
}",0.986369744672682
5551,"private void internalReset(){
  for (int i=0, n=16; i < n; i++) {
    interruptSource[i]=null;
  }
  servicedInterruptUnit=null;
  servicedInterrupt=-1;
  interruptMax=-1;
  writeRegister(SR,0);
  cycleEventQueue.removeAll();
  vTimeEventQueue.removeAll();
  bcs.reset();
  for (  Chip chip : chips) {
    chip.notifyReset();
  }
  resetIOUnits();
  if (profiler != null) {
    profiler.resetProfile();
  }
}","private void internalReset(){
  for (int i=0, n=64; i < n; i++) {
    interruptSource[i]=null;
  }
  servicedInterruptUnit=null;
  servicedInterrupt=-1;
  interruptMax=-1;
  writeRegister(SR,0);
  cycleEventQueue.removeAll();
  vTimeEventQueue.removeAll();
  bcs.reset();
  for (  Chip chip : chips) {
    chip.notifyReset();
  }
  resetIOUnits();
  if (profiler != null) {
    profiler.resetProfile();
  }
}",0.9975490196078431
5552,"public boolean emulateOP(long maxCycles) throws EmulationException {
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff || flash.blocksCPU()) {
    while (cycles >= nextEventCycles) {
      executeEvents();
    }
    if (interruptsEnabled && interruptMax > 0) {
      return false;
    }
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return false;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.EXECUTE,pc,0);
      breakpointActive=false;
      return false;
    }
    breakpointActive=true;
  }
  if (globalMonitor != null) {
    globalMonitor.cpuAction(CPUMonitor.EXECUTE,pc,0);
  }
  instruction=read(pc,MODE_WORD);
  if ((instruction & 0xff00) == 0x1800) {
    System.out.println(""String_Node_Str"");
    extWord=instruction;
    pc+=2;
    instruction=read(pc,MODE_WORD);
  }
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  int rval=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 0:
    op=instruction & 0xf0f0;
  System.out.println(""String_Node_Str"" + Utils.hex16(op) + ""String_Node_Str""+ Utils.hex16(instruction)+ ""String_Node_Str""+ getAddressAsString(pc - 2));
int src=0;
int srcData=(instruction & 0x0f00) >> 8;
int dstData=(instruction & 0x000f);
switch (op) {
case MOVA_IMM2REG:
src=read(pc,MODE_WORD);
writeRegister(PC,pc+=2);
dst=src + (srcData << 16);
System.out.println(""String_Node_Str"" + getAddressAsString(dst) + ""String_Node_Str""+ dstData);
writeRegister(dstData,dst);
break;
case CMPA_IMM:
break;
case CMPA_REG:
break;
default :
System.out.println(""String_Node_Str"");
throw new EmulationException(""String_Node_Str"");
}
break;
case 1:
{
dstRegister=instruction & 0xf;
if ((op=instruction & CALLA_MASK) > RETI) {
pc=readRegister(PC);
dst=-1;
switch (op) {
case CALLA_IMM:
dst=(dstRegister << 16) | read(pc,MODE_WORD);
pc+=2;
cycles+=4;
break;
default :
System.out.println(""String_Node_Str"");
}
if (dst != -1) {
sp=readRegister(SP) - 2;
write(sp,(pc >> 16) & 0xf,MODE_WORD);
sp=sp - 2;
write(sp,pc & 0xffff,MODE_WORD);
writeRegister(SP,sp);
writeRegister(PC,dst);
}
}
 else {
int ad=(instruction >> 4) & 3;
int nxtCarry=0;
op=instruction & 0xff80;
if (op == PUSH || op == CALL) {
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
}
if ((dstRegister == CG1 && ad > AM_INDEX) || dstRegister == CG2) {
dstRegMode=true;
cycles++;
}
 else {
switch (ad) {
case AM_REG:
dstRegMode=true;
cycles++;
break;
case AM_INDEX:
rval=readRegisterCG(dstRegister,ad);
if (rval < 0xffff) {
dstAddress=(rval + read(pc,MODE_WORD)) & 0xffff;
}
 else {
dstAddress=read(pc,MODE_WORD);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
}
cycles+=3;
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word ? MODE_WORD : MODE_BYTE);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SXT:
sr=readRegister(SR);
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case PUSH:
if (word) {
write(sp,dst,MODE_WORD);
}
 else {
write(sp,dst & 0xff,MODE_WORD);
}
cycles+=(ad == AM_REG || ad == AM_IND_AUTOINC) ? 2 : 1;
write=false;
updateStatus=false;
break;
case CALL:
pc=readRegister(PC);
write(sp,pc,MODE_WORD);
writeRegister(PC,dst);
cycles+=(ad == AM_REG) ? 3 : (ad == AM_IND_AUTOINC) ? 2 : 1;
if (profiler != null) {
MapEntry function=map.getEntry(dst);
if (function == null) {
function=getFunction(map,dst);
}
profiler.profileCall(function,cpuCycles,pc);
}
write=false;
updateStatus=false;
break;
case RETI:
servicedInterrupt=-1;
sp=readRegister(SP);
sr=read(sp,MODE_WORD);
writeRegister(SR,sr & 0x0fff);
sp=sp + 2;
writeRegister(PC,read(sp,MODE_WORD) | (sr & 0xf000) << 4);
sp=sp + 2;
writeRegister(SP,sp);
write=false;
updateStatus=false;
cycles+=4;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
if (profiler != null) {
profiler.profileRETI(cycles);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
logw(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
updateStatus=false;
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
src=0;
if ((srcRegister == CG1 && as > AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
if (dstRegister == PC) cycles++;
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + read(pc,MODE_WORD);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=dstRegMode ? 2 : 5;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
if (dstRegister == PC) {
cycles++;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=read(pc,MODE_WORD);
}
 else {
rval=readRegister(dstRegister);
if (rval < 0xffff) {
dstAddress=(rval + read(pc,MODE_WORD)) & 0xffff;
}
 else {
dstAddress=read(pc,MODE_WORD);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
}
if (op != MOV) dst=read(dstAddress,word ? MODE_WORD : MODE_BYTE);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word ? MODE_WORD : MODE_BYTE);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
if (instruction == RETURN && profiler != null) {
profiler.profileReturn(cpuCycles);
}
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=(dst - src);
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) log(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if ((src & (word ? 0x8000 : 0x80)) != 0 && (dst & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
dst=src ^ dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
case AND:
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
dst=src & dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
default :
logw(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
if (EXCEPTION_ON_BAD_OPERATION) {
EmulationException ex=new EmulationException(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
ex.initCause(new Throwable(""String_Node_Str"" + pc));
throw ex;
}
}
}
if (word) {
dst&=0xffff;
}
 else {
dst&=0xff;
}
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word ? MODE_WORD : MODE_BYTE);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
while (cycles >= nextEventCycles) {
executeEvents();
}
cpuCycles+=cycles - startCycles;
return true;
}","public int emulateOP(long maxCycles) throws EmulationException {
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff || flash.blocksCPU()) {
    while (cycles >= nextEventCycles) {
      executeEvents();
    }
    if (interruptsEnabled && interruptMax > 0) {
      return -1;
    }
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return -1;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.EXECUTE,pc,0);
      breakpointActive=false;
      return -1;
    }
    breakpointActive=true;
  }
  if (globalMonitor != null) {
    globalMonitor.cpuAction(CPUMonitor.EXECUTE,pc,0);
  }
  int pcBefore=pc;
  instruction=read(pc,MODE_WORD);
  if ((instruction & 0xff00) == 0x1800) {
    System.out.println(""String_Node_Str"");
    extWord=instruction;
    pc+=2;
    instruction=read(pc,MODE_WORD);
  }
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  int rval=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 0:
    op=instruction & 0xf0f0;
  System.out.println(""String_Node_Str"" + Utils.hex16(op) + ""String_Node_Str""+ Utils.hex16(instruction)+ ""String_Node_Str""+ getAddressAsString(pc - 2));
int src=0;
int srcData=(instruction & 0x0f00) >> 8;
int dstData=(instruction & 0x000f);
switch (op) {
case MOVA_IMM2REG:
src=read(pc,MODE_WORD);
writeRegister(PC,pc+=2);
dst=src + (srcData << 16);
System.out.println(""String_Node_Str"" + getAddressAsString(dst) + ""String_Node_Str""+ dstData);
writeRegister(dstData,dst);
break;
case CMPA_IMM:
break;
case CMPA_REG:
break;
default :
System.out.println(""String_Node_Str"");
throw new EmulationException(""String_Node_Str"");
}
break;
case 1:
{
dstRegister=instruction & 0xf;
if ((op=instruction & CALLA_MASK) > RETI) {
pc=readRegister(PC);
dst=-1;
switch (op) {
case CALLA_IMM:
dst=(dstRegister << 16) | read(pc,MODE_WORD);
pc+=2;
cycles+=4;
break;
default :
System.out.println(""String_Node_Str"");
}
if (dst != -1) {
sp=readRegister(SP) - 2;
write(sp,(pc >> 16) & 0xf,MODE_WORD);
sp=sp - 2;
write(sp,pc & 0xffff,MODE_WORD);
writeRegister(SP,sp);
writeRegister(PC,dst);
}
}
 else {
int ad=(instruction >> 4) & 3;
int nxtCarry=0;
op=instruction & 0xff80;
if (op == PUSH || op == CALL) {
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
}
if ((dstRegister == CG1 && ad > AM_INDEX) || dstRegister == CG2) {
dstRegMode=true;
cycles++;
}
 else {
switch (ad) {
case AM_REG:
dstRegMode=true;
cycles++;
break;
case AM_INDEX:
rval=readRegisterCG(dstRegister,ad);
if (rval < 0xffff) {
dstAddress=(rval + read(pc,MODE_WORD)) & 0xffff;
}
 else {
dstAddress=read(pc,MODE_WORD);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
}
cycles+=3;
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word ? MODE_WORD : MODE_BYTE);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SXT:
sr=readRegister(SR);
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case PUSH:
if (word) {
write(sp,dst,MODE_WORD);
}
 else {
write(sp,dst & 0xff,MODE_WORD);
}
cycles+=(ad == AM_REG || ad == AM_IND_AUTOINC) ? 2 : 1;
write=false;
updateStatus=false;
break;
case CALL:
pc=readRegister(PC);
write(sp,pc,MODE_WORD);
writeRegister(PC,dst);
cycles+=(ad == AM_REG) ? 3 : (ad == AM_IND_AUTOINC) ? 2 : 1;
if (profiler != null) {
MapEntry function=map.getEntry(dst);
if (function == null) {
function=getFunction(map,dst);
}
profiler.profileCall(function,cpuCycles,pc);
}
write=false;
updateStatus=false;
break;
case RETI:
servicedInterrupt=-1;
sp=readRegister(SP);
sr=read(sp,MODE_WORD);
writeRegister(SR,sr & 0x0fff);
sp=sp + 2;
writeRegister(PC,read(sp,MODE_WORD) | (sr & 0xf000) << 4);
sp=sp + 2;
writeRegister(SP,sp);
write=false;
updateStatus=false;
cycles+=4;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
if (profiler != null) {
profiler.profileRETI(cycles);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
logw(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
updateStatus=false;
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
src=0;
if ((srcRegister == CG1 && as > AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
if (dstRegister == PC) cycles++;
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + read(pc,MODE_WORD);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=dstRegMode ? 2 : 5;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
if (dstRegister == PC) {
cycles++;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=read(pc,MODE_WORD);
}
 else {
rval=readRegister(dstRegister);
if (rval < 0xffff) {
dstAddress=(rval + read(pc,MODE_WORD)) & 0xffff;
}
 else {
dstAddress=read(pc,MODE_WORD);
if ((dstAddress & 0x8000) > 0) {
dstAddress|=0xf0000;
}
dstAddress+=rval;
dstAddress&=0xfffff;
}
}
if (op != MOV) dst=read(dstAddress,word ? MODE_WORD : MODE_BYTE);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word ? MODE_WORD : MODE_BYTE);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
if (instruction == RETURN && profiler != null) {
profiler.profileReturn(cpuCycles);
}
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=(dst - src);
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) log(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if ((src & (word ? 0x8000 : 0x80)) != 0 && (dst & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
dst=src ^ dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
case AND:
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
dst=src & dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
default :
logw(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
if (EXCEPTION_ON_BAD_OPERATION) {
EmulationException ex=new EmulationException(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
ex.initCause(new Throwable(""String_Node_Str"" + pc));
throw ex;
}
}
}
if (word) {
dst&=0xffff;
}
 else {
dst&=0xff;
}
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word ? MODE_WORD : MODE_BYTE);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
while (cycles >= nextEventCycles) {
executeEvents();
}
cpuCycles+=cycles - startCycles;
return pcBefore;
}",0.997067735314241
5553,"private void rejectFrame(){
  rxFIFO.restore();
  setSFD(false);
  setFIFO(rxFIFO.length() > 0);
  setState(RadioState.RX_SFD_SEARCH);
}","private void rejectFrame(){
  rxFIFO.restore();
  setSFD(false);
  setFIFO(rxFIFO.length() > 0);
  frameRejected=true;
}",0.84375
5554,"public String info(){
  updateActiveFrequency();
  return ""String_Node_Str"" + on + ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ ((status & STATUS_XOSC16M_STABLE) > 0)+ ""String_Node_Str""+ ((status & STATUS_RSSI_VALID) > 0)+ ""String_Node_Str""+ cca+ ""String_Node_Str""+ ((registers[REG_IOCFG0] & FIFOP_POLARITY) == FIFOP_POLARITY)+ ""String_Node_Str""+ fifoP+ ""String_Node_Str""+ currentFIFO+ ""String_Node_Str""+ currentSFD+ ""String_Node_Str""+ rxFIFO.stateToString()+ ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ state+ ""String_Node_Str""+ autoAck+ ""String_Node_Str""+ addressDecode+ ""String_Node_Str""+ autoCRC+ ""String_Node_Str""+ Utils.hex8(memory[RAM_PANID + 1])+ Utils.hex8(memory[RAM_PANID])+ ""String_Node_Str""+ Utils.hex8(memory[RAM_SHORTADDR + 1])+ Utils.hex8(memory[RAM_SHORTADDR])+ ""String_Node_Str""+ getLongAddress()+ ""String_Node_Str""+ activeChannel+ ""String_Node_Str"";
}","public String info(){
  updateActiveFrequency();
  return ""String_Node_Str"" + on + ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ ((status & STATUS_XOSC16M_STABLE) > 0)+ ""String_Node_Str""+ ((status & STATUS_RSSI_VALID) > 0)+ ""String_Node_Str""+ cca+ ""String_Node_Str""+ ((registers[REG_IOCFG0] & FIFOP_POLARITY) == FIFOP_POLARITY)+ ""String_Node_Str""+ fifoP+ ""String_Node_Str""+ currentFIFO+ ""String_Node_Str""+ currentSFD+ ""String_Node_Str""+ rxFIFO.stateToString()+ ""String_Node_Str""+ rxlen+ ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ state+ ""String_Node_Str""+ autoAck+ ""String_Node_Str""+ addressDecode+ ""String_Node_Str""+ autoCRC+ ""String_Node_Str""+ Utils.hex8(memory[RAM_PANID + 1])+ Utils.hex8(memory[RAM_PANID])+ ""String_Node_Str""+ Utils.hex8(memory[RAM_SHORTADDR + 1])+ Utils.hex8(memory[RAM_SHORTADDR])+ ""String_Node_Str""+ getLongAddress()+ ""String_Node_Str""+ activeChannel+ ""String_Node_Str"";
}",0.9854910714285714
5555,"public void receivedByte(byte data){
  if (DEBUG)   log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (overflow) {
    }
 else     if (rxFIFO.isFull()) {
      setRxOverflow();
    }
 else {
      rxFIFO.write(data);
      if (rxread == 0) {
        rxCrc.setCRC(0);
        rxlen=data & 0xff;
        decodeAddress=false;
        if (DEBUG)         log(""String_Node_Str"" + rxlen);
        setFIFO(true);
      }
 else       if (rxread < rxlen - 1) {
        rxCrc.addBitrev(data & 0xff);
        if (rxread == 1) {
          fcf0=data & 0xff;
          frameType=fcf0 & FRAME_TYPE;
        }
 else         if (rxread == 2) {
          fcf1=data & 0xff;
          decodeAddress=addressDecode;
          if (frameType == TYPE_DATA_FRAME) {
            ackRequest=(fcf0 & ACK_REQUEST) > 0;
            destinationAddressMode=(fcf1 >> 2) & 3;
            if (addressDecode && destinationAddressMode != LONG_ADDRESS && destinationAddressMode != SHORT_ADDRESS) {
              rejectFrame();
            }
          }
 else           if (frameType == TYPE_BEACON_FRAME || frameType == TYPE_ACK_FRAME) {
            decodeAddress=false;
            ackRequest=false;
          }
 else           if (addressDecode) {
            rejectFrame();
          }
        }
 else         if (rxread == 3) {
          dsn=data & 0xff;
        }
 else         if (decodeAddress) {
          boolean flushPacket=false;
          if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
            flushPacket=!rxFIFO.tailEquals(memory,RAM_IEEEADDR,8);
            flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,8);
            decodeAddress=false;
          }
 else           if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
            flushPacket=!rxFIFO.tailEquals(BC_ADDRESS,0,2) && !rxFIFO.tailEquals(memory,RAM_SHORTADDR,2);
            flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,2);
            decodeAddress=false;
          }
          if (flushPacket) {
            rejectFrame();
          }
        }
      }
      if (rxread++ == rxlen) {
        int crc=rxFIFO.get(-2) << 8;
        crc+=rxFIFO.get(-1);
        if (DEBUG && crc != rxCrc.getCRCBitrev()) {
          log(""String_Node_Str"" + Utils.hex16(crc) + ""String_Node_Str""+ Utils.hex16(rxCrc.getCRCBitrev()));
        }
        rxFIFO.set(-2,registers[REG_RSSI] & 0xff);
        rxFIFO.set(-1,37 | (crc == rxCrc.getCRCBitrev() ? 0x80 : 0));
        if (rxFIFO.length() <= rxlen + 1) {
          setFIFOP(true);
        }
 else {
          if (DEBUG)           log(""String_Node_Str"" + rxFIFO.length() + ""String_Node_Str""+ rxlen);
        }
        setSFD(false);
        if (DEBUG)         log(""String_Node_Str"" + rxFIFO.stateToString());
        if ((autoAck && ackRequest && (crc == rxCrc.getCRCBitrev())) || shouldAck) {
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}","public void receivedByte(byte data){
  if (DEBUG)   log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (overflow) {
    }
 else     if (rxFIFO.isFull()) {
      setRxOverflow();
    }
 else {
      if (!frameRejected) {
        rxFIFO.write(data);
        if (rxread == 0) {
          rxCrc.setCRC(0);
          rxlen=data & 0xff;
          decodeAddress=false;
          if (DEBUG)           log(""String_Node_Str"" + rxlen);
          setFIFO(true);
        }
 else         if (rxread < rxlen - 1) {
          rxCrc.addBitrev(data & 0xff);
          if (rxread == 1) {
            fcf0=data & 0xff;
            frameType=fcf0 & FRAME_TYPE;
          }
 else           if (rxread == 2) {
            fcf1=data & 0xff;
            decodeAddress=addressDecode;
            if (frameType == TYPE_DATA_FRAME) {
              ackRequest=(fcf0 & ACK_REQUEST) > 0;
              destinationAddressMode=(fcf1 >> 2) & 3;
              if (addressDecode && destinationAddressMode != LONG_ADDRESS && destinationAddressMode != SHORT_ADDRESS) {
                rejectFrame();
              }
            }
 else             if (frameType == TYPE_BEACON_FRAME || frameType == TYPE_ACK_FRAME) {
              decodeAddress=false;
              ackRequest=false;
            }
 else             if (addressDecode) {
              rejectFrame();
            }
          }
 else           if (rxread == 3) {
            dsn=data & 0xff;
          }
 else           if (decodeAddress) {
            boolean flushPacket=false;
            if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
              flushPacket=!rxFIFO.tailEquals(memory,RAM_IEEEADDR,8);
              flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,8);
              decodeAddress=false;
            }
 else             if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
              flushPacket=!rxFIFO.tailEquals(BC_ADDRESS,0,2) && !rxFIFO.tailEquals(memory,RAM_SHORTADDR,2);
              flushPacket|=!rxFIFO.tailEquals(memory,RAM_PANID,2,2);
              decodeAddress=false;
            }
            if (flushPacket) {
              rejectFrame();
            }
          }
        }
      }
      if (rxread++ == rxlen) {
        if (frameRejected) {
          log(""String_Node_Str"");
          setSFD(false);
          setState(RadioState.RX_WAIT);
          return;
        }
        int crc=rxFIFO.get(-2) << 8;
        crc+=rxFIFO.get(-1);
        if (DEBUG && crc != rxCrc.getCRCBitrev()) {
          log(""String_Node_Str"" + Utils.hex16(crc) + ""String_Node_Str""+ Utils.hex16(rxCrc.getCRCBitrev()));
        }
        rxFIFO.set(-2,registers[REG_RSSI] & 0xff);
        rxFIFO.set(-1,37 | (crc == rxCrc.getCRCBitrev() ? 0x80 : 0));
        if (rxFIFO.length() <= rxlen + 1) {
          setFIFOP(true);
        }
 else {
          if (DEBUG)           log(""String_Node_Str"" + rxFIFO.length() + ""String_Node_Str""+ rxlen);
        }
        setSFD(false);
        if (DEBUG)         log(""String_Node_Str"" + rxFIFO.stateToString());
        if ((autoAck && ackRequest && (crc == rxCrc.getCRCBitrev())) || shouldAck) {
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}",0.9359009628610728
5556,"private boolean setState(RadioState state){
  if (DEBUG)   log(""String_Node_Str"" + stateMachine + ""String_Node_Str""+ state);
  stateMachine=state;
  registers[REG_FSMSTATE]=state.getFSMState();
switch (stateMachine) {
case VREG_OFF:
    if (DEBUG)     log(""String_Node_Str"");
  flushRX();
flushTX();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case POWER_DOWN:
rxFIFO.reset();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case RX_CALIBRATE:
setSymbolEvent(12);
setMode(MODE_RX_ON);
break;
case RX_SFD_SEARCH:
zeroSymbols=0;
if ((status & STATUS_RSSI_VALID) == 0) {
setSymbolEvent(8);
}
updateCCA();
setMode(MODE_RX_ON);
break;
case TX_CALIBRATE:
setSymbolEvent(12 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_FRAME:
txfifoPos=0;
txNext();
break;
case RX_WAIT:
setSymbolEvent(8);
setMode(MODE_RX_ON);
break;
case IDLE:
status&=~STATUS_RSSI_VALID;
setMode(MODE_TXRX_OFF);
updateCCA();
break;
case TX_ACK_CALIBRATE:
status|=STATUS_TX_ACTIVE;
setSymbolEvent(12 + 2 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_ACK_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_ACK:
ackPos=0;
ackNext();
break;
case RX_FRAME:
rxFIFO.mark();
rxread=0;
break;
}
if (stateListener != null) {
stateListener.newState(stateMachine);
}
stateChanged(stateMachine.state);
return true;
}","private boolean setState(RadioState state){
  if (DEBUG)   log(""String_Node_Str"" + stateMachine + ""String_Node_Str""+ state);
  stateMachine=state;
  registers[REG_FSMSTATE]=state.getFSMState();
switch (stateMachine) {
case VREG_OFF:
    if (DEBUG)     log(""String_Node_Str"");
  flushRX();
flushTX();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case POWER_DOWN:
rxFIFO.reset();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case RX_CALIBRATE:
setSymbolEvent(12);
setMode(MODE_RX_ON);
break;
case RX_SFD_SEARCH:
zeroSymbols=0;
if ((status & STATUS_RSSI_VALID) == 0) {
setSymbolEvent(8);
}
updateCCA();
setMode(MODE_RX_ON);
break;
case TX_CALIBRATE:
setSymbolEvent(12 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_FRAME:
txfifoPos=0;
txNext();
break;
case RX_WAIT:
setSymbolEvent(8);
setMode(MODE_RX_ON);
break;
case IDLE:
status&=~STATUS_RSSI_VALID;
setMode(MODE_TXRX_OFF);
updateCCA();
break;
case TX_ACK_CALIBRATE:
status|=STATUS_TX_ACTIVE;
setSymbolEvent(12 + 2 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_ACK_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_ACK:
ackPos=0;
ackNext();
break;
case RX_FRAME:
rxFIFO.mark();
rxread=0;
frameRejected=false;
break;
}
if (stateListener != null) {
stateListener.newState(stateMachine);
}
stateChanged(stateMachine.state);
return true;
}",0.993192868719611
5557,"private void triggerAccessViolation(String reason){
  if (DEBUG)   log(""String_Node_Str"" + reason + ""String_Node_Str""+ Utils.hex16(cpu.readRegister(MSP430.PC)));
  statusreg|=ACCVIFG;
  if (sfr.isIEBitsSet(SFR.IE1,ACCVIE)) {
    cpu.flagInterrupt(NMI_VECTOR,this,true);
  }
}","private void triggerAccessViolation(String reason){
  if (DEBUG)   log(""String_Node_Str"" + reason + ""String_Node_Str""+ Utils.hex16(cpu.readRegister(MSP430.PC)));
  statusreg|=ACCVIFG;
  if (cpu.getSFR().isIEBitsSet(SFR.IE1,ACCVIE)) {
    cpu.flagInterrupt(NMI_VECTOR,this,true);
  }
}",0.9731663685152058
5558,"public Flash(MSP430Core cpu,int[] memory,FlashRange main_range,FlashRange info_range){
  super(""String_Node_Str"",""String_Node_Str"",memory,FCTL1);
  this.cpu=cpu;
  this.memory=memory;
  this.main_range=main_range;
  this.info_range=info_range;
  this.sfr=cpu.getSFR();
  locked=true;
  reset(MSP430.RESET_POR);
}","public Flash(MSP430Core cpu,int[] memory,FlashRange main_range,FlashRange info_range){
  super(""String_Node_Str"",""String_Node_Str"",memory,FCTL1);
  this.cpu=cpu;
  this.memory=memory;
  this.main_range=main_range;
  this.info_range=info_range;
  locked=true;
  reset(MSP430.RESET_POR);
}",0.9582637729549248
5559,"void resetCounter(long cycles){
  double divider=1.0;
  if (clockSource == SRC_ACLK) {
    divider=1.0 * core.smclkFrq / core.aclkFrq;
  }
  divider=divider * inputDivider;
  long cycctr=cycles - counterStart;
  double tick=cycctr / divider;
  counterPassed=(int)(divider * (tick - (long)(tick)));
  counterStart=cycles - counterPassed;
  counterAcc=counter;
  updateCyclesMultiplicator();
  if (DEBUG)   System.out.println(getName() + ""String_Node_Str"" + cycles+ ""String_Node_Str""+ cyclesMultiplicator);
  core.scheduleCycleEvent(counterTrigger,(long)((0x100000 - counter) * cyclesMultiplicator));
}","void resetCounter(long cycles){
  double divider=1.0;
  if (clockSource == SRC_ACLK) {
    divider=1.0 * core.smclkFrq / core.aclkFrq;
  }
  divider=divider * inputDivider;
  long cycctr=cycles - counterStart;
  double tick=cycctr / divider;
  counterPassed=(int)(divider * (tick - (long)(tick)));
  counterStart=cycles - counterPassed;
  counterAcc=counter;
  updateCyclesMultiplicator();
  if (DEBUG)   System.out.println(getName() + ""String_Node_Str"" + cycles+ ""String_Node_Str""+ cyclesMultiplicator);
  core.scheduleCycleEvent(counterTrigger,cycles + (long)((0x10000 - counter) * cyclesMultiplicator));
}",0.9917218543046358
5560,"public void execute(long t){
  interruptPending=true;
  nextTimerTrigger=(long)(nextTimerTrigger + 0x10000 * cyclesMultiplicator);
  core.scheduleCycleEvent(this,nextTimerTrigger);
  if (lastTIV == 0 && interruptEnable) {
    lastTIV=memory[tiv]=timerOverflow;
    core.flagInterrupt(ccr1Vector,Timer.this,true);
  }
}","public void execute(long t){
  interruptPending=true;
  nextTimerTrigger=(long)(nextTimerTrigger + 0x10000 * cyclesMultiplicator);
  core.scheduleCycleEvent(this,nextTimerTrigger);
  if (lastTIV == 0 && interruptEnable) {
    lastTIV=memory[tiv]=timerOverflow;
    core.flagInterrupt(ccr1Vector,Timer.this,true);
  }
 else {
  }
}",0.9814814814814816
5561,"private void triggerAccessViolation(String reason){
  if (DEBUG)   log(""String_Node_Str"" + reason + ""String_Node_Str""+ Utils.hex16(cpu.readRegister(MSP430.PC)));
  statusreg|=ACCVIFG;
  if (cpu.getSFR().isIEBitsSet(SFR.IE1,ACCVIE)) {
    cpu.flagInterrupt(NMI_VECTOR,this,true);
  }
}","private void triggerAccessViolation(String reason){
  logw(""String_Node_Str"" + reason + ""String_Node_Str""+ Utils.hex16(cpu.readRegister(MSP430.PC)));
  statusreg|=ACCVIFG;
  if (cpu.getSFR().isIEBitsSet(SFR.IE1,ACCVIE)) {
    cpu.flagInterrupt(NMI_VECTOR,this,true);
  }
}",0.9640287769784172
5562,"private void triggerEndBlockWrite(){
  if (DEBUG) {
    log(""String_Node_Str"");
  }
  current_write_mode=WriteMode.WRITE_BLOCK_FINISH;
  waitFlashProcess(BLOCKWRITE_END_TIME);
}","private void triggerEndBlockWrite(){
  if (DEBUG) {
    log(""String_Node_Str"");
  }
  currentWriteMode=WriteMode.WRITE_BLOCK_FINISH;
  waitFlashProcess(BLOCKWRITE_END_TIME);
}",0.9829545454545454
5563,"private EraseMode getEraseMode(int regdata){
  int idx=(regdata & ERASE_MASK) >> ERASE_SHIFT;
  for (  EraseMode em : EraseMode.values()) {
    if (em.ordinal() == idx)     return em;
  }
  throw new IllegalArgumentException(""String_Node_Str"" + regdata);
}","private WriteMode getEraseMode(int regdata){
  int idx=(regdata & ERASE_MASK) >> ERASE_SHIFT;
  for (  WriteMode em : WriteMode.values()) {
    if (em.ordinal() == idx)     return em;
  }
  throw new IllegalArgumentException(""String_Node_Str"" + regdata);
}",0.953125
5564,"public void flashWrite(int address,int data,boolean word){
  int wait_time=-1;
  if (locked) {
    if (DEBUG) {
      log(""String_Node_Str"");
    }
    return;
  }
  if (busy || wait == false) {
    if (!((mode & BLKWRT) != 0 && wait)) {
      triggerAccessViolation(""String_Node_Str"");
      return;
    }
  }
switch (current_erase) {
case ERASE_SEGMENT:
    int a_area_start[]=new int[1];
  int a_area_end[]=new int[1];
getSegmentRange(address,a_area_start,a_area_end);
int area_start=a_area_start[0];
int area_end=a_area_end[0];
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ Utils.hex16(area_start)+ ""String_Node_Str""+ Utils.hex16(area_end));
}
for (int i=area_start; i < area_end; i++) {
memory[i]=0xff;
}
waitFlashProcess(SEGMENT_ERASE_TIME);
return;
case ERASE_MAIN:
if (!main_range.isInRange(address)) {
return;
}
for (int i=main_range.start; i < main_range.end; i++) {
memory[i]=0xff;
}
waitFlashProcess(MASS_ERASE_TIME);
return;
case ERASE_ALL:
for (int i=main_range.start; i < main_range.end; i++) {
memory[i]=0xff;
}
for (int i=info_range.start; i < main_range.end; i++) {
memory[i]=0xff;
}
waitFlashProcess(MASS_ERASE_TIME);
return;
}
switch (current_write_mode) {
case WRITE_BLOCK:
wait=false;
if (blockwrite_count == 0) {
wait_time=BLOCKWRITE_FIRST_TIME;
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex16(address));
}
if (addressInFlash(cpu.readRegister(MSP430.PC))) {
logw(""String_Node_Str"");
}
}
 else {
wait_time=BLOCKWRITE_TIME;
}
break;
case WRITE_SINGLE:
wait_time=WRITE_TIME;
break;
}
memory[address]&=data & 0xff;
if (word) {
memory[address + 1]&=(data >> 8) & 0xff;
}
if (wait_time < 0) {
throw new RuntimeException(""String_Node_Str"");
}
waitFlashProcess(wait_time);
}","public void flashWrite(int address,int data,boolean word){
  int wait_time=-1;
  if (locked) {
    if (DEBUG) {
      log(""String_Node_Str"");
    }
    return;
  }
  if (busy || wait == false) {
    if (!((mode & BLKWRT) != 0 && wait)) {
      triggerAccessViolation(""String_Node_Str"");
      return;
    }
  }
switch (currentWriteMode) {
case ERASE_SEGMENT:
    int a_area_start[]=new int[1];
  int a_area_end[]=new int[1];
getSegmentRange(address,a_area_start,a_area_end);
int area_start=a_area_start[0];
int area_end=a_area_end[0];
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ Utils.hex16(area_start)+ ""String_Node_Str""+ Utils.hex16(area_end));
}
for (int i=area_start; i < area_end; i++) {
memory[i]=0xff;
}
waitFlashProcess(SEGMENT_ERASE_TIME);
break;
case ERASE_MAIN:
if (!main_range.isInRange(address)) {
return;
}
for (int i=main_range.start; i < main_range.end; i++) {
memory[i]=0xff;
}
waitFlashProcess(MASS_ERASE_TIME);
break;
case ERASE_ALL:
for (int i=main_range.start; i < main_range.end; i++) {
memory[i]=0xff;
}
for (int i=info_range.start; i < main_range.end; i++) {
memory[i]=0xff;
}
waitFlashProcess(MASS_ERASE_TIME);
break;
case WRITE_SINGLE:
case WRITE_BLOCK:
if (currentWriteMode == WriteMode.WRITE_BLOCK) {
wait=false;
if (blockwriteCount == 0) {
wait_time=BLOCKWRITE_FIRST_TIME;
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex16(address));
}
if (addressInFlash(cpu.readRegister(MSP430.PC))) {
logw(""String_Node_Str"");
}
}
 else {
wait_time=BLOCKWRITE_TIME;
}
}
 else {
wait_time=WRITE_TIME;
}
memory[address]&=data & 0xff;
if (word) {
memory[address + 1]&=(data >> 8) & 0xff;
}
if (DEBUG) {
log(""String_Node_Str"" + data + ""String_Node_Str""+ Utils.hex16(address));
}
waitFlashProcess(wait_time);
break;
}
}",0.896987087517934
5565,"public Flash(MSP430Core cpu,int[] memory,FlashRange main_range,FlashRange info_range){
  super(""String_Node_Str"",""String_Node_Str"",memory,FCTL1);
  this.cpu=cpu;
  this.memory=memory;
  this.main_range=main_range;
  this.info_range=info_range;
  locked=true;
  reset(MSP430.RESET_POR);
}","public Flash(MSP430Core cpu,int[] memory,FlashRange main_range,FlashRange info_range){
  super(""String_Node_Str"",""String_Node_Str"",memory,FCTL1);
  this.cpu=cpu;
  this.memory=memory;
  this.main_range=main_range;
  this.info_range=info_range;
  locked=true;
  Arrays.fill(memory,main_range.start,main_range.end,0xff);
  Arrays.fill(memory,info_range.start,info_range.end,0xff);
  reset(MSP430.RESET_POR);
}",0.8270893371757925
5566,"public void write(int address,int value,boolean word,long cycles){
  if (!word) {
    logw(""String_Node_Str"");
    return;
  }
  if (!(address == FCTL1 || address == FCTL2 || address == FCTL3)) {
    return;
  }
  if (!checkKey(value)) {
    return;
  }
  int regdata=value & CMDMASK;
switch (address) {
case FCTL1:
    if ((mode & ERASE_MASK) != 0 || (mode & WRT) != 0) {
      if (!((mode & BLKWRT) != 0 && wait)) {
        triggerAccessViolation(""String_Node_Str"");
        return;
      }
    }
  if ((mode & ERASE_MASK) != (regdata & ERASE_MASK)) {
    if ((mode & ERASE_MASK) == 0) {
      triggerErase(regdata);
    }
    mode&=~ERASE_MASK;
    mode|=regdata & ERASE_MASK;
  }
if ((mode & WRT) != (regdata & WRT)) {
  if ((regdata & WRT) != 0) {
    if ((regdata & BLKWRT) != 0) {
      triggerBlockWrite();
      mode|=BLKWRT;
    }
 else {
      triggerSingleWrite();
    }
    mode&=~WRT;
    mode|=regdata & WRT;
  }
}
if ((mode & BLKWRT) != 0 && (regdata & BLKWRT) == 0) {
triggerEndBlockWrite();
mode&=~BLKWRT;
}
break;
case FCTL2:
if (busy) {
triggerAccessViolation(""String_Node_Str"");
return;
}
clockcfg=regdata;
break;
case FCTL3:
if ((statusreg & EMEX) == 0 && (regdata & EMEX) == 1) {
triggerEmergencyExit();
}
if (locked && (regdata & LOCK) == 0) {
triggerUnlockFlash();
}
 else {
if (!locked && (regdata & LOCK) != 0) {
triggerLockFlash();
}
}
if (((statusreg ^ regdata) & KEYV) != 0) {
statusreg^=KEYV;
}
if (((statusreg ^ regdata) & ACCVIFG) != 0) {
statusreg^=ACCVIFG;
}
break;
}
}","public void write(int address,int value,boolean word,long cycles){
  if (!word) {
    logw(""String_Node_Str"");
    return;
  }
  if (!(address == FCTL1 || address == FCTL2 || address == FCTL3)) {
    return;
  }
  if (!checkKey(value)) {
    return;
  }
  int regdata=value & CMDMASK;
switch (address) {
case FCTL1:
    if (busy && ((mode & BLKWRT) == 0 || wait == false)) {
      triggerAccessViolation(""String_Node_Str"");
      return;
    }
  if ((mode & ERASE_MASK) != (regdata & ERASE_MASK)) {
    if ((mode & ERASE_MASK) == 0) {
      triggerErase(regdata);
    }
    mode&=~ERASE_MASK;
    mode|=regdata & ERASE_MASK;
  }
if ((mode & WRT) != (regdata & WRT)) {
  if ((regdata & WRT) != 0) {
    if ((regdata & BLKWRT) != 0) {
      triggerBlockWrite();
      mode|=BLKWRT;
    }
 else {
      triggerSingleWrite();
    }
  }
  mode&=~WRT;
  mode|=regdata & WRT;
}
if ((mode & BLKWRT) != 0 && (regdata & BLKWRT) == 0) {
triggerEndBlockWrite();
mode&=~BLKWRT;
}
break;
case FCTL2:
if (busy) {
triggerAccessViolation(""String_Node_Str"");
return;
}
clockcfg=regdata;
break;
case FCTL3:
if ((statusreg & EMEX) == 0 && (regdata & EMEX) == 1) {
triggerEmergencyExit();
}
if (locked && (regdata & LOCK) == 0) {
triggerUnlockFlash();
}
 else {
if (!locked && (regdata & LOCK) != 0) {
triggerLockFlash();
}
}
if (((statusreg ^ regdata) & KEYV) != 0) {
statusreg^=KEYV;
}
if (((statusreg ^ regdata) & ACCVIFG) != 0) {
statusreg^=ACCVIFG;
}
break;
}
}",0.8328246863343506
5567,"private void triggerEmergencyExit(){
  mode=0;
  busy=false;
  wait=true;
  locked=true;
  current_erase=EraseMode.ERASE_NONE;
  current_write_mode=WriteMode.WRITE_NONE;
}","private void triggerEmergencyExit(){
  mode=0;
  busy=false;
  wait=true;
  locked=true;
  currentWriteMode=WriteMode.NONE;
}",0.831081081081081
5568,"public void notifyRead(int address){
  if (busy) {
    triggerAccessViolation(""String_Node_Str"");
    return;
  }
  if (DEBUG) {
    if (wait == false && current_write_mode == WriteMode.WRITE_BLOCK) {
      log(""String_Node_Str"");
      log(""String_Node_Str"" + Utils.hex16(cpu.readRegister(MSP430.PC)) + ""String_Node_Str""+ Utils.hex16(address));
    }
  }
}","public void notifyRead(int address){
  if (busy) {
    triggerAccessViolation(""String_Node_Str"");
    return;
  }
  if (DEBUG) {
    if (wait == false && currentWriteMode == WriteMode.WRITE_BLOCK) {
      log(""String_Node_Str"");
      log(""String_Node_Str"" + Utils.hex16(cpu.readRegister(MSP430.PC)) + ""String_Node_Str""+ Utils.hex16(address));
    }
  }
}",0.9803370786516854
5569,"private void triggerBlockWrite(){
  if (DEBUG) {
    log(""String_Node_Str"");
  }
  current_write_mode=WriteMode.WRITE_BLOCK;
  blockwrite_count=0;
}","private void triggerBlockWrite(){
  if (DEBUG) {
    log(""String_Node_Str"");
  }
  currentWriteMode=WriteMode.WRITE_BLOCK;
  blockwriteCount=0;
}",0.969283276450512
5570,"private void triggerErase(int newmode){
  current_erase=getEraseMode(newmode);
}","private void triggerErase(int newmode){
  currentWriteMode=getEraseMode(newmode);
}",0.9325153374233128
5571,"public void reset(int type){
  if (DEBUG) {
    log(""String_Node_Str"");
  }
  if (type == MSP430.RESET_POR)   statusreg=0;
  mode=0;
  clockcfg=0x42;
  busy=false;
  wait=true;
  locked=true;
  current_erase=EraseMode.ERASE_NONE;
  current_write_mode=WriteMode.WRITE_NONE;
}","public void reset(int type){
  if (DEBUG) {
    log(""String_Node_Str"");
  }
  if (type == MSP430.RESET_POR)   statusreg=0;
  mode=0;
  clockcfg=0x42;
  busy=false;
  wait=true;
  locked=true;
  currentWriteMode=WriteMode.NONE;
}",0.852589641434263
5572,"private void triggerSingleWrite(){
  current_write_mode=WriteMode.WRITE_SINGLE;
}","private void triggerSingleWrite(){
  currentWriteMode=WriteMode.WRITE_SINGLE;
}",0.9625
5573,"public void registerComponent(String name,Object component){
synchronized (components) {
    components.add(new ComponentEntry(name,component));
  }
  if (component instanceof ActiveComponent) {
    ((ActiveComponent)component).init(name,this);
    if (running) {
      ((ActiveComponent)component).start();
    }
  }
 else   if (component instanceof ServiceComponent) {
    ((ServiceComponent)component).init(name,this);
  }
}","public void registerComponent(String name,Object component){
synchronized (this) {
    components.add(new ComponentEntry(name,component));
  }
  if (component instanceof ActiveComponent) {
    ((ActiveComponent)component).init(name,this);
    if (running) {
      ((ActiveComponent)component).start();
    }
  }
 else   if (component instanceof ServiceComponent) {
    ((ServiceComponent)component).init(name,this);
  }
}",0.9858490566037736
5574,"public CC2420(MSP430Core cpu){
  rxFIFO=new ArrayFIFO(memory,RAM_RXFIFO,128);
  registers[REG_SNOP]=0;
  registers[REG_TXCTRL]=0xa0ff;
  this.cpu=cpu;
  setModeNames(MODE_NAMES);
  setMode(MODE_POWER_OFF);
  fifoP=false;
  rxFIFO.reset();
  overflow=false;
  reset();
  cpu.addChip(this);
}","public CC2420(MSP430Core cpu){
  rxFIFO=new ArrayFIFO(""String_Node_Str"",memory,RAM_RXFIFO,128);
  registers[REG_SNOP]=0;
  registers[REG_TXCTRL]=0xa0ff;
  this.cpu=cpu;
  setModeNames(MODE_NAMES);
  setMode(MODE_POWER_OFF);
  fifoP=false;
  rxFIFO.reset();
  overflow=false;
  reset();
  cpu.addChip(this);
}",0.9698996655518396
5575,"public void write(int address,int value,boolean word,long cycles){
  if (address == WDTCTL) {
    if ((value >> 8) == 0x5a) {
      wdtctl=value & 0xff;
      if (DEBUG)       System.out.println(getName() + ""String_Node_Str"" + Utils.hex8(wdtctl));
      wdtOn=(value & 0x80) == 0;
      boolean lastACLK=sourceACLK;
      sourceACLK=(value & WDTSSEL) != 0;
      if ((value & WDTCNTCL) != 0) {
        delay=DELAY[value & WDTISx];
      }
      timerMode=(value & WDTMSEL) != 0;
      if (wdtOn) {
        if (DEBUG)         System.out.println(""String_Node_Str"" + delay);
        scheduleTimer();
      }
 else {
        wdtTrigger.remove();
      }
    }
 else {
      cpu.flagInterrupt(RESET_VECTOR,this,true);
    }
  }
}","public void write(int address,int value,boolean word,long cycles){
  if (address == WDTCTL) {
    if ((value >> 8) == 0x5a) {
      wdtctl=value & 0xff;
      if (DEBUG)       System.out.println(getName() + ""String_Node_Str"" + Utils.hex8(wdtctl)+ ""String_Node_Str""+ cpu.getPC());
      wdtOn=(value & 0x80) == 0;
      boolean lastACLK=sourceACLK;
      sourceACLK=(value & WDTSSEL) != 0;
      if ((value & WDTCNTCL) != 0) {
        delay=DELAY[value & WDTISx];
      }
      timerMode=(value & WDTMSEL) != 0;
      if (wdtOn) {
        if (DEBUG)         System.out.println(""String_Node_Str"" + delay);
        scheduleTimer();
      }
 else {
        wdtTrigger.remove();
      }
    }
 else {
      cpu.flagInterrupt(RESET_VECTOR,this,true);
    }
  }
}",0.9783783783783784
5576,"public int read(){
  int v=memory[start + readPos++];
  if (readPos >= size) {
    readPos=0;
  }
  len--;
  if (len < 0) {
    if (STRICT) {
      throw new EmulationException(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
  return v & 0xff;
}","public int read(){
  if (len <= 0) {
    if (STRICT) {
      throw new EmulationException(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      return 0;
    }
  }
  int v=memory[start + readPos++];
  if (readPos >= size) {
    readPos=0;
  }
  len--;
  return v & 0xff;
}",0.631578947368421
5577,"public String stateToString(){
  return ""String_Node_Str"" + len + ""String_Node_Str""+ readPos+ ""String_Node_Str""+ writePos;
}","public String stateToString(){
  return name + ""String_Node_Str"" + len+ ""String_Node_Str""+ readPos+ ""String_Node_Str""+ writePos;
}",0.968503937007874
5578,"public ArrayFIFO(int[] mem,int start,int size){
  memory=mem;
  this.start=start;
  this.size=size;
  len=0;
}","public ArrayFIFO(String name,int[] mem,int start,int size){
  memory=mem;
  this.name=name;
  this.start=start;
  this.size=size;
  len=0;
}",0.88
5579,"public void receivedByte(byte data){
  log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      rxread=0;
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (rxfifoLen == 128) {
      setRxOverflow();
    }
 else {
      memory[RAM_RXFIFO + rxfifoWritePos]=data & 0xFF;
      rxfifoWritePos=(rxfifoWritePos + 1) & 127;
      rxfifoLen++;
      if (rxread == 0) {
        rxCrc.setCRC(0);
        rxlen=data & 0xff;
        rxPacketStart=rxfifoWritePos;
        System.out.println(""String_Node_Str"" + rxfifoWritePos + ""String_Node_Str""+ rxlen);
        decodeAddress=false;
        if (DEBUG)         log(""String_Node_Str"" + rxlen);
        setFIFO(true);
      }
 else       if (rxread < rxlen - 1) {
        rxCrc.addBitrev(data & 0xff);
        if (rxread == 2) {
          if (TYPE_DATA_FRAME == (memory[RAM_RXFIFO + rxPacketStart] & FRAME_TYPE)) {
            decodeAddress=addressDecode;
            ackRequest=(memory[RAM_RXFIFO + rxPacketStart] & ACK_REQUEST) > 0;
            destinationAddressMode=(memory[RAM_RXFIFO + ((rxPacketStart + 1) & 127)] >> 2) & 3;
          }
 else {
            decodeAddress=false;
            ackRequest=false;
          }
          dsn=data & 0xff;
        }
 else         if (rxread == 3) {
          dsn=data & 0xff;
        }
        if (decodeAddress) {
          boolean flushPacket=false;
          if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
            int addrPos=rxPacketStart + 5;
            for (int i=0; i < 8; i++) {
              if (memory[RAM_IEEEADDR + i] != memory[RAM_RXFIFO + ((addrPos + i) & 127)]) {
                flushPacket=true;
              }
            }
            decodeAddress=false;
          }
 else           if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
            int addrPos=rxPacketStart + 5;
            boolean bc=true;
            for (int i=0; i < 2; i++) {
              int addrData=memory[RAM_RXFIFO + ((addrPos + i) & 127)];
              if (bc && addrData != 0xff) {
                bc=false;
              }
              if (memory[RAM_SHORTADDR + i] != addrData) {
                flushPacket=true;
              }
            }
            if (bc)             flushPacket=false;
            decodeAddress=false;
          }
          if (flushPacket) {
            rxfifoLen=rxfifoLen - rxread;
            rxfifoWritePos=(rxPacketStart - 1 + 128) & 127;
            System.out.println(""String_Node_Str"" + rxfifoWritePos);
            setSFD(false);
            setFIFO(rxfifoLen > 0);
            setState(RadioState.RX_SFD_SEARCH);
          }
        }
      }
      if (rxread++ == rxlen) {
        int crc=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)] << 8;
        crc+=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)];
        if (true && crc != rxCrc.getCRCBitrev()) {
          System.out.println(""String_Node_Str"" + Utils.hex16(crc) + ""String_Node_Str""+ Utils.hex16(rxCrc.getCRCBitrev()));
        }
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)]=(registers[REG_RSSI]) & 0xff;
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)]=37 | (crc == rxCrc.getCRCBitrev() ? 0x80 : 0);
        if (rxfifoLen <= rxlen + 1) {
          setFIFOP(true);
        }
 else {
          System.out.println(""String_Node_Str"" + rxfifoLen + ""String_Node_Str""+ rxlen);
        }
        setSFD(false);
        if (DEBUG)         log(""String_Node_Str"" + lastPacketStart + ""String_Node_Str""+ rxPacketStart);
        if ((autoAck && ackRequest) || shouldAck) {
          System.out.println(""String_Node_Str"" + lastPacketStart + ""String_Node_Str""+ rxlen+ ""String_Node_Str""+ dsn+ ""String_Node_Str""+ memory[(RAM_RXFIFO + lastPacketStart + 2) & 127]);
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}","public void receivedByte(byte data){
  log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      rxread=0;
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (rxfifoLen == 128) {
      setRxOverflow();
    }
 else {
      memory[RAM_RXFIFO + rxfifoWritePos]=data & 0xFF;
      rxfifoWritePos=(rxfifoWritePos + 1) & 127;
      rxfifoLen++;
      if (rxread == 0) {
        rxCrc.setCRC(0);
        rxlen=data & 0xff;
        rxPacketStart=rxfifoWritePos;
        System.out.println(""String_Node_Str"" + rxfifoWritePos + ""String_Node_Str""+ rxlen);
        decodeAddress=false;
        if (DEBUG)         log(""String_Node_Str"" + rxlen);
        setFIFO(true);
      }
 else       if (rxread < rxlen - 1) {
        rxCrc.addBitrev(data & 0xff);
        if (rxread == 2) {
          if (TYPE_DATA_FRAME == (memory[RAM_RXFIFO + rxPacketStart] & FRAME_TYPE)) {
            decodeAddress=addressDecode;
            ackRequest=(memory[RAM_RXFIFO + rxPacketStart] & ACK_REQUEST) > 0;
            destinationAddressMode=(memory[RAM_RXFIFO + ((rxPacketStart + 1) & 127)] >> 2) & 3;
          }
 else {
            decodeAddress=false;
            ackRequest=false;
          }
          dsn=data & 0xff;
        }
 else         if (rxread == 3) {
          dsn=data & 0xff;
        }
        if (decodeAddress) {
          boolean flushPacket=false;
          if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
            int addrPos=rxPacketStart + 5;
            for (int i=0; i < 8; i++) {
              if (memory[RAM_IEEEADDR + i] != memory[RAM_RXFIFO + ((addrPos + i) & 127)]) {
                flushPacket=true;
              }
            }
            decodeAddress=false;
          }
 else           if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
            int addrPos=rxPacketStart + 5;
            boolean bc=true;
            for (int i=0; i < 2; i++) {
              int addrData=memory[RAM_RXFIFO + ((addrPos + i) & 127)];
              if (bc && addrData != 0xff) {
                bc=false;
              }
              if (memory[RAM_SHORTADDR + i] != addrData) {
                flushPacket=true;
              }
            }
            if (bc)             flushPacket=false;
            decodeAddress=false;
          }
          if (flushPacket) {
            rxfifoLen=rxfifoLen - rxread;
            rxfifoWritePos=(rxPacketStart - 1 + 128) & 127;
            System.out.println(""String_Node_Str"" + rxfifoWritePos);
            setSFD(false);
            setFIFO(rxfifoLen > 0);
            setState(RadioState.RX_SFD_SEARCH);
          }
        }
      }
      if (rxread++ == rxlen) {
        int crc=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)] << 8;
        crc+=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)];
        if (true && crc != rxCrc.getCRCBitrev()) {
          System.out.println(""String_Node_Str"" + Utils.hex16(crc) + ""String_Node_Str""+ Utils.hex16(rxCrc.getCRCBitrev()));
        }
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)]=(registers[REG_RSSI]) & 0xff;
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)]=37 | (crc == rxCrc.getCRCBitrev() ? 0x80 : 0);
        if (rxfifoLen <= rxlen + 1) {
          setFIFOP(true);
        }
 else {
          System.out.println(""String_Node_Str"" + rxfifoLen + ""String_Node_Str""+ rxlen);
        }
        setSFD(false);
        if (DEBUG)         log(""String_Node_Str"" + lastPacketStart + ""String_Node_Str""+ rxPacketStart);
        if ((autoAck && ackRequest) || shouldAck) {
          System.out.println(""String_Node_Str"" + lastPacketStart + ""String_Node_Str""+ rxlen+ ""String_Node_Str""+ dsn+ ""String_Node_Str""+ memory[RAM_RXFIFO + ((lastPacketStart + 2) & 127)]);
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}",0.9995394888326042
5580,"private int rev8bits(int v){
  int r=0;
  int s=7;
  for (v>>=1; v > 0; v>>=1) {
    r<<=1;
    r|=v & 1;
    s--;
  }
  r<<=s;
  return r;
}","private static int rev8bits(int v){
  int r=0;
  int s=8;
  while (v > 0) {
    r=(r << 1) | v & 1;
    v=(v >> 1) & 0xff;
    s--;
  }
  r<<=s;
  return r & 0xff;
}",0.7777777777777778
5581,"private int crc8Add(int acc,int data){
  int i;
  acc^=data;
  for (i=0; i < 8; i++) {
    if ((acc & 0x80) != 0) {
      acc=(acc << 1) ^ 0x31;
    }
 else {
      acc<<=1;
    }
  }
  return acc & 0xff;
}","private int crc8Add(int acc,int data){
  int i;
  acc^=(data & 0xff);
  for (i=0; i < 8; i++) {
    if ((acc & 0x80) != 0) {
      acc=((acc << 1) ^ 0x31) & 0xff;
    }
 else {
      acc<<=1;
    }
  }
  return acc & 0xff;
}",0.9395348837209302
5582,"public void execute(long t){
  if (readData == CMD_MEASURE_TEMP) {
    output[0]=temp >> 8;
    output[1]=temp & 0xff;
  }
 else   if (readData == CMD_MEASURE_HUM) {
    output[0]=humid >> 8;
    output[1]=humid & 0xff;
  }
 else {
    return;
  }
  int crc=0;
  crc=crc8Add(crc,readData);
  crc=crc8Add(crc,output[0]);
  crc=crc8Add(crc,output[1]);
  if (DEBUG)   System.out.println(""String_Node_Str"" + crc + ""String_Node_Str""+ rev8bits(crc));
  output[2]=rev8bits(crc);
  sdataPort.setPinState(sdataPin,IOPort.PIN_LOW);
  state=WRITE_BYTE;
  writeData=output[0];
  writePos=0;
  writeLen=3;
}","public void execute(long t){
  if (readData == CMD_MEASURE_TEMP) {
    output[0]=(temp >> 8) & 0xff;
    output[1]=temp & 0xff;
  }
 else   if (readData == CMD_MEASURE_HUM) {
    output[0]=(humid >> 8) & 0xff;
    output[1]=humid & 0xff;
  }
 else {
    return;
  }
  temp+=1;
  humid+=1;
  int crc=0;
  crc=crc8Add(crc,readData);
  crc=crc8Add(crc,output[0]);
  crc=crc8Add(crc,output[1]);
  if (DEBUG)   System.out.println(""String_Node_Str"" + Utils.hex8(crc) + ""String_Node_Str""+ Utils.hex8(rev8bits(crc)));
  output[2]=rev8bits(crc);
  sdataPort.setPinState(sdataPin,IOPort.PIN_LOW);
  state=WRITE_BYTE;
  writeData=output[0];
  writePos=0;
  writeLen=3;
}",0.9433359936153232
5583,"public void interruptServiced(int vector){
  irqTriggered[vector]=false;
  int pos=irqTriggeredPos[vector];
  int bit=pos & 7;
  if (pos > 8) {
    ifg1&=~(1 << bit);
  }
 else {
    ifg2&=~(1 << bit);
  }
  cpu.flagInterrupt(vector,this,false);
  if (sfrModule[pos] != null) {
    sfrModule[pos].interruptServiced(vector);
  }
}","public void interruptServiced(int vector){
  irqTriggered[vector]=false;
  int pos=irqTriggeredPos[vector];
  int bit=pos & 7;
  if (pos < 8) {
    ifg1&=~(1 << bit);
  }
 else {
    ifg2&=~(1 << bit);
  }
  cpu.flagInterrupt(vector,this,false);
  if (sfrModule[pos] != null) {
    sfrModule[pos].interruptServiced(vector);
  }
}",0.9969604863221884
5584,"public void write(int address,int value,boolean word,long cycles){
  if (DEBUG)   System.out.println(getName() + ""String_Node_Str"" + address+ ""String_Node_Str""+ value);
switch (address) {
case IE1:
case IE2:
    updateIE(address - IE1,value);
  break;
case IFG1:
case IFG2:
updateIFG(address - IFG1,value);
break;
case ME1:
case ME2:
updateME(address - ME1,value);
default :
memory[address]=value;
}
}","public void write(int address,int value,boolean word,long cycles){
  if (DEBUG)   System.out.println(getName() + ""String_Node_Str"" + address+ ""String_Node_Str""+ value);
switch (address) {
case IE1:
case IE2:
    updateIE(address - IE1,value);
  break;
case IFG1:
case IFG2:
updateIFG(address - IFG1,value);
break;
case ME1:
case ME2:
updateME(address - ME1,value);
}
memory[address]=value;
}",0.9848484848484848
5585,"public void reset(int type){
  nextTXReady=cpu.cycles + 100;
  txShiftReg=nextTXByte=-1;
  transmitting=false;
  clrBitIFG(urxifg);
  setBitIFG(utxifg);
  utctl|=UTCTL_TXEMPTY;
  cpu.scheduleCycleEvent(txTrigger,nextTXReady);
  txEnabled=false;
  rxEnabled=false;
}","public void reset(int type){
  nextTXReady=cpu.cycles + 100;
  txShiftReg=nextTXByte=-1;
  transmitting=false;
  clrBitIFG(urxifg);
  setBitIFG(utxifg);
  utctl|=UTCTL_TXEMPTY;
  txEnabled=false;
  rxEnabled=false;
}",0.8191268191268192
5586,"public void interruptServiced(int vector){
  irqTriggered[vector]=false;
  int pos=irqTriggeredPos[vector];
  if (autoclear[vector]) {
    int bit=pos & 7;
    if (pos < 8) {
      ifg1&=~(1 << bit);
    }
 else {
      ifg2&=~(1 << bit);
    }
  }
  cpu.flagInterrupt(vector,this,false);
  if (sfrModule[pos] != null) {
    sfrModule[pos].interruptServiced(vector);
  }
}","public void interruptServiced(int vector){
  irqTriggered[vector]=false;
  int pos=irqTriggeredPos[vector];
  if (autoclear[vector]) {
    int bit=pos & 7;
    if (pos < 8) {
      ifg1&=~(1 << bit);
    }
 else {
      ifg2&=~(1 << bit);
    }
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + sfrModule[pos] + ""String_Node_Str""+ vector);
    }
  }
  cpu.flagInterrupt(vector,this,false);
  if (sfrModule[pos] != null) {
    sfrModule[pos].interruptServiced(vector);
  }
}",0.851808634772462
5587,"private void updateIRQ(int pos,int change){
  int ifg=pos == 0 ? ifg1 : ifg2;
  int ie=pos == 0 ? ie1 : ie2;
  pos=pos * 8;
  for (int i=0; i < 8; i++) {
    if ((change & 1) == 1) {
      if (sfrModule[pos] != null && !irqTriggered[irqVector[pos]]) {
        if (DEBUG)         System.out.println(""String_Node_Str"" + sfrModule[pos].getName() + ""String_Node_Str""+ pos+ ""String_Node_Str""+ (ie & ifg & 1)+ ""String_Node_Str""+ change);
        if ((ie & ifg & 1) > 0) {
          int vector=irqVector[pos];
          irqTriggered[vector]=true;
          irqTriggeredPos[vector]=pos;
          cpu.flagInterrupt(irqVector[pos],this,true);
        }
      }
    }
    pos++;
    change=change >> 1;
    ifg=ifg >> 1;
    ie=ie >> 1;
  }
}","private void updateIRQ(int pos,int change){
  int ifg=pos == 0 ? ifg1 : ifg2;
  int ie=pos == 0 ? ie1 : ie2;
  pos=pos * 8;
  for (int i=0; i < 8; i++) {
    if ((change & 1) == 1) {
      if (sfrModule[pos] != null && !irqTriggered[irqVector[pos]]) {
        if (DEBUG)         System.out.println(""String_Node_Str"" + sfrModule[pos].getName() + ""String_Node_Str""+ pos+ ""String_Node_Str""+ (ie & 1)+ ""String_Node_Str""+ (ifg & 1)+ ""String_Node_Str""+ change);
        if ((ie & ifg & 1) > 0) {
          int vector=irqVector[pos];
          irqTriggered[vector]=true;
          irqTriggeredPos[vector]=pos;
          cpu.flagInterrupt(vector,this,true);
        }
      }
    }
    pos++;
    change=change >> 1;
    ifg=ifg >> 1;
    ie=ie >> 1;
  }
}",0.9702702702702702
5588,"private void triggerWDT(long time){
  if (timerMode) {
    SFR sfr=cpu.getSFR();
    sfr.setBitIFG(0,WATCHDOG_INTERRUPT_BIT);
    scheduleTimer();
  }
 else {
    System.out.println(""String_Node_Str"");
    cpu.generateTrace(System.out);
    cpu.flagInterrupt(RESET_VECTOR,this,true);
  }
}","private void triggerWDT(long time){
  if (timerMode) {
    SFR sfr=cpu.getSFR();
    sfr.setBitIFG(0,WATCHDOG_INTERRUPT_VALUE);
    scheduleTimer();
  }
 else {
    System.out.println(""String_Node_Str"");
    cpu.generateTrace(System.out);
    cpu.flagInterrupt(RESET_VECTOR,this,true);
  }
}",0.4482758620689655
5589,"public void receivedByte(byte data){
  log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      rxread=0;
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (rxfifoLen == 128) {
      setRxOverflow();
    }
 else {
      memory[RAM_RXFIFO + rxfifoWritePos]=data & 0xFF;
      rxfifoWritePos=(rxfifoWritePos + 1) & 127;
      rxfifoLen++;
      if (rxread == 0) {
        rxCrc.setCRC(0);
        rxlen=data & 0xff;
        rxPacketStart=rxfifoWritePos;
        System.out.println(""String_Node_Str"" + rxfifoWritePos + ""String_Node_Str""+ rxlen);
        decodeAddress=false;
        if (DEBUG)         log(""String_Node_Str"" + rxlen);
        setFIFO(true);
      }
 else       if (rxread < rxlen - 1) {
        rxCrc.addBitrev(data & 0xff);
        if (rxread == 2) {
          if (TYPE_DATA_FRAME == (memory[RAM_RXFIFO + rxPacketStart] & FRAME_TYPE)) {
            decodeAddress=addressDecode;
            ackRequest=(memory[RAM_RXFIFO + rxPacketStart] & ACK_REQUEST) > 0;
            destinationAddressMode=(memory[RAM_RXFIFO + ((rxPacketStart + 1) & 127)] >> 2) & 3;
          }
 else {
            decodeAddress=false;
            ackRequest=false;
          }
        }
 else         if (rxread == 3) {
          dsn=data & 0xff;
        }
        if (decodeAddress) {
          boolean flushPacket=false;
          if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
            int addrPos=rxPacketStart + 5;
            for (int i=0; i < 8; i++) {
              if (memory[RAM_IEEEADDR + i] != memory[RAM_RXFIFO + ((addrPos + i) & 127)]) {
                flushPacket=true;
              }
            }
            decodeAddress=false;
          }
 else           if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
            int addrPos=rxPacketStart + 5;
            boolean bc=true;
            for (int i=0; i < 2; i++) {
              int addrData=memory[RAM_RXFIFO + ((addrPos + i) & 127)];
              if (bc && addrData != 0xff) {
                bc=false;
              }
              if (memory[RAM_SHORTADDR + i] != addrData) {
                flushPacket=true;
              }
            }
            if (bc)             flushPacket=false;
            decodeAddress=false;
          }
          if (flushPacket) {
            rxfifoLen=rxfifoLen - rxread;
            rxfifoWritePos=(rxPacketStart - 1 + 128) & 127;
            System.out.println(""String_Node_Str"" + rxfifoWritePos);
            setSFD(false);
            setFIFO(rxfifoLen > 0);
            setState(RadioState.RX_SFD_SEARCH);
          }
        }
      }
      if (rxread++ == rxlen) {
        int crc=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)] << 8;
        crc+=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)];
        if (true && crc != rxCrc.getCRCBitrev()) {
          System.out.println(""String_Node_Str"" + Utils.hex16(crc) + ""String_Node_Str""+ Utils.hex16(rxCrc.getCRCBitrev()));
        }
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)]=(registers[REG_RSSI]) & 0xff;
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)]=37 | (crc == rxCrc.getCRCBitrev() ? 0x80 : 0);
        if (rxfifoLen <= rxlen + 1) {
          setFIFOP(true);
        }
 else {
          System.out.println(""String_Node_Str"" + rxfifoLen + ""String_Node_Str""+ rxlen);
        }
        setSFD(false);
        if (DEBUG)         log(""String_Node_Str"" + rxPacketStart + ""String_Node_Str""+ rxPacketStart);
        if ((autoAck && ackRequest) || shouldAck) {
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}","public void receivedByte(byte data){
  log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      rxread=0;
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (rxfifoLen == 128) {
      setRxOverflow();
    }
 else {
      memory[RAM_RXFIFO + rxfifoWritePos]=data & 0xFF;
      rxfifoWritePos=(rxfifoWritePos + 1) & 127;
      rxfifoLen++;
      if (rxread == 0) {
        rxCrc.setCRC(0);
        rxlen=data & 0xff;
        rxPacketStart=rxfifoWritePos;
        System.out.println(""String_Node_Str"" + rxfifoWritePos + ""String_Node_Str""+ rxlen);
        decodeAddress=false;
        if (DEBUG)         log(""String_Node_Str"" + rxlen);
        setFIFO(true);
      }
 else       if (rxread < rxlen - 1) {
        rxCrc.addBitrev(data & 0xff);
        if (rxread == 2) {
          if (TYPE_DATA_FRAME == (memory[RAM_RXFIFO + rxPacketStart] & FRAME_TYPE)) {
            decodeAddress=addressDecode;
            ackRequest=(memory[RAM_RXFIFO + rxPacketStart] & ACK_REQUEST) > 0;
            destinationAddressMode=(memory[RAM_RXFIFO + ((rxPacketStart + 1) & 127)] >> 2) & 3;
          }
 else {
            decodeAddress=false;
            ackRequest=false;
          }
        }
 else         if (rxread == 3) {
          dsn=data & 0xff;
        }
        if (decodeAddress) {
          boolean flushPacket=false;
          if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
            int addrPos=rxPacketStart + 5;
            for (int i=0; i < 8; i++) {
              if (memory[RAM_IEEEADDR + i] != memory[RAM_RXFIFO + ((addrPos + i) & 127)]) {
                flushPacket=true;
              }
            }
            decodeAddress=false;
          }
 else           if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
            int addrPos=rxPacketStart + 5;
            boolean bc=true;
            for (int i=0; i < 2; i++) {
              int addrData=memory[RAM_RXFIFO + ((addrPos + i) & 127)];
              if (bc && addrData != 0xff) {
                bc=false;
              }
              if (memory[RAM_SHORTADDR + i] != addrData) {
                flushPacket=true;
              }
            }
            if (bc)             flushPacket=false;
            decodeAddress=false;
          }
          if (flushPacket) {
            rxfifoLen=rxfifoLen - (rxread + 1);
            rxfifoWritePos=(rxPacketStart - 1 + 128) & 127;
            System.out.println(""String_Node_Str"" + rxfifoWritePos + ""String_Node_Str""+ rxfifoLen);
            setSFD(false);
            setFIFO(rxfifoLen > 0);
            setState(RadioState.RX_SFD_SEARCH);
          }
        }
      }
      if (rxread++ == rxlen) {
        int crc=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)] << 8;
        crc+=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)];
        if (true && crc != rxCrc.getCRCBitrev()) {
          System.out.println(""String_Node_Str"" + Utils.hex16(crc) + ""String_Node_Str""+ Utils.hex16(rxCrc.getCRCBitrev()));
        }
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)]=(registers[REG_RSSI]) & 0xff;
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)]=37 | (crc == rxCrc.getCRCBitrev() ? 0x80 : 0);
        if (rxfifoLen <= rxlen + 1) {
          setFIFOP(true);
        }
 else {
          System.out.println(""String_Node_Str"" + rxfifoLen + ""String_Node_Str""+ rxlen);
        }
        setSFD(false);
        if (DEBUG)         log(""String_Node_Str"" + rxPacketStart + ""String_Node_Str""+ rxPacketStart);
        if ((autoAck && ackRequest) || shouldAck) {
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}",0.9940885510918084
5590,"public void receivedByte(byte data){
  log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      rxread=0;
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (rxfifoLen == 128) {
      setRxOverflow();
    }
 else {
      memory[RAM_RXFIFO + rxfifoWritePos]=data & 0xFF;
      rxfifoWritePos=(rxfifoWritePos + 1) & 127;
      rxfifoLen++;
      if (rxread == 0) {
        rxCrc.setCRC(0);
        rxlen=data & 0xff;
        rxPacketStart=rxfifoWritePos;
        decodeAddress=false;
        if (DEBUG)         log(""String_Node_Str"" + rxlen);
        setFIFO(true);
      }
 else       if (rxread < rxlen - 1) {
        rxCrc.addBitrev(data & 0xff);
        if (rxread == 2) {
          if (TYPE_DATA_FRAME == (memory[RAM_RXFIFO + rxPacketStart] & FRAME_TYPE)) {
            decodeAddress=addressDecode & (memory[RAM_RXFIFO + rxPacketStart] & ACK_REQUEST) > 0;
            destinationAddressMode=(memory[RAM_RXFIFO + ((rxPacketStart + 1) & 127)] >> 2) & 3;
          }
        }
 else         if (rxread == 3) {
          dsn=data & 0xff;
        }
        if (decodeAddress) {
          boolean flushPacket=false;
          if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
            int addrPos=rxPacketStart + 5;
            for (int i=0; i < 8; i++) {
              if (memory[RAM_IEEEADDR + i] != memory[RAM_RXFIFO + ((addrPos + i) & 127)]) {
                flushPacket=true;
              }
            }
            decodeAddress=false;
          }
 else           if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
            int addrPos=rxPacketStart + 5;
            boolean bc=true;
            for (int i=0; i < 2; i++) {
              int addrData=memory[RAM_RXFIFO + ((addrPos + i) & 127)];
              if (bc && addrData != 0xff) {
                bc=false;
              }
              if (memory[RAM_SHORTADDR + i] != addrData) {
                flushPacket=true;
              }
            }
            if (bc)             flushPacket=false;
            decodeAddress=false;
          }
          if (flushPacket) {
            rxfifoLen=rxfifoLen - rxread;
            rxfifoWritePos=(rxPacketStart - 1 + 128) & 127;
            setSFD(false);
            setFIFO(rxfifoLen > 0);
            setState(RadioState.RX_SFD_SEARCH);
          }
        }
      }
      if (rxread++ == rxlen) {
        int crc=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)] << 8;
        crc+=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)];
        if (true && crc != rxCrc.getCRCBitrev()) {
          System.out.println(""String_Node_Str"" + Utils.hex16(crc) + ""String_Node_Str""+ Utils.hex16(rxCrc.getCRCBitrev()));
        }
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)]=(registers[REG_RSSI]) & 0xff;
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)]=37 | (crc == rxCrc.getCRCBitrev() ? 0x80 : 0);
        if (rxfifoLen <= rxlen) {
          setFIFOP(true);
        }
        setSFD(false);
        if (DEBUG)         log(""String_Node_Str"" + lastPacketStart + ""String_Node_Str""+ rxPacketStart);
        if ((autoAck && checkAutoack()) || shouldAck) {
          ackBuf[ACK_SEQPOS]=memory[RAM_RXFIFO + lastPacketStart + 2];
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}","public void receivedByte(byte data){
  log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      rxread=0;
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (rxfifoLen == 128) {
      setRxOverflow();
    }
 else {
      memory[RAM_RXFIFO + rxfifoWritePos]=data & 0xFF;
      rxfifoWritePos=(rxfifoWritePos + 1) & 127;
      rxfifoLen++;
      if (rxread == 0) {
        rxCrc.setCRC(0);
        rxlen=data & 0xff;
        rxPacketStart=rxfifoWritePos;
        decodeAddress=false;
        if (DEBUG)         log(""String_Node_Str"" + rxlen);
        setFIFO(true);
      }
 else       if (rxread < rxlen - 1) {
        rxCrc.addBitrev(data & 0xff);
        if (rxread == 2) {
          if (TYPE_DATA_FRAME == (memory[RAM_RXFIFO + rxPacketStart] & FRAME_TYPE)) {
            decodeAddress=addressDecode & (memory[RAM_RXFIFO + rxPacketStart] & ACK_REQUEST) > 0;
            destinationAddressMode=(memory[RAM_RXFIFO + ((rxPacketStart + 1) & 127)] >> 2) & 3;
          }
        }
 else         if (rxread == 3) {
          dsn=data & 0xff;
        }
        if (decodeAddress) {
          boolean flushPacket=false;
          if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
            int addrPos=rxPacketStart + 5;
            for (int i=0; i < 8; i++) {
              if (memory[RAM_IEEEADDR + i] != memory[RAM_RXFIFO + ((addrPos + i) & 127)]) {
                flushPacket=true;
              }
            }
            decodeAddress=false;
          }
 else           if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
            int addrPos=rxPacketStart + 5;
            boolean bc=true;
            for (int i=0; i < 2; i++) {
              int addrData=memory[RAM_RXFIFO + ((addrPos + i) & 127)];
              if (bc && addrData != 0xff) {
                bc=false;
              }
              if (memory[RAM_SHORTADDR + i] != addrData) {
                flushPacket=true;
              }
            }
            if (bc)             flushPacket=false;
            decodeAddress=false;
          }
          if (flushPacket) {
            rxfifoLen=rxfifoLen - rxread;
            rxfifoWritePos=(rxPacketStart - 1 + 128) & 127;
            setSFD(false);
            setFIFO(rxfifoLen > 0);
            setState(RadioState.RX_SFD_SEARCH);
          }
        }
      }
      if (rxread++ == rxlen) {
        int crc=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)] << 8;
        crc+=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)];
        if (true && crc != rxCrc.getCRCBitrev()) {
          System.out.println(""String_Node_Str"" + Utils.hex16(crc) + ""String_Node_Str""+ Utils.hex16(rxCrc.getCRCBitrev()));
        }
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)]=(registers[REG_RSSI]) & 0xff;
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)]=37 | (crc == rxCrc.getCRCBitrev() ? 0x80 : 0);
        if (rxfifoLen <= rxlen + 1) {
          setFIFOP(true);
        }
 else {
          System.out.println(""String_Node_Str"" + rxfifoLen + ""String_Node_Str""+ rxlen);
        }
        setSFD(false);
        if (DEBUG)         log(""String_Node_Str"" + lastPacketStart + ""String_Node_Str""+ rxPacketStart);
        if ((autoAck && checkAutoack()) || shouldAck) {
          ackBuf[ACK_SEQPOS]=memory[RAM_RXFIFO + lastPacketStart + 2];
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}",0.9858393408856848
5591,"public void dataReceived(USART source,int data){
  int oldStatus=status;
  if (DEBUG) {
    log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ ((data >= ' ' && data <= 'Z') ? (char)data : '.')+ ')'+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ state+ ""String_Node_Str""+ stateMachine);
  }
  if ((stateMachine != RadioState.VREG_OFF) && chipSelect) {
switch (state) {
case WAITING:
      if ((data & FLAG_READ) != 0) {
        state=SpiState.READ_REGISTER;
      }
 else {
        state=SpiState.WRITE_REGISTER;
      }
    if ((data & FLAG_RAM) != 0) {
      state=SpiState.RAM_ACCESS;
      address=data & 0x7f;
    }
 else {
      address=data & 0x3f;
      if (address == REG_RXFIFO) {
        state=SpiState.READ_RXFIFO;
      }
 else       if (address == REG_TXFIFO) {
        state=SpiState.WRITE_TXFIFO;
      }
    }
  if (data < 0x0f) {
    strobe(data);
    state=SpiState.WAITING;
  }
pos=0;
break;
case WRITE_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
registers[address]=(registers[address] & 0xff) | (data << 8);
pos=1;
}
 else {
source.byteReceived(registers[address] & 0xff);
registers[address]=(registers[address] & 0xff00) | data;
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
data=registers[address];
setReg(address,data);
state=SpiState.WAITING;
}
break;
case READ_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
pos=1;
}
 else {
source.byteReceived(registers[address] & 0xff);
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
state=SpiState.WAITING;
}
return;
case READ_RXFIFO:
if (DEBUG) log(""String_Node_Str"" + rxfifoReadPos + ""String_Node_Str""+ (memory[RAM_RXFIFO + rxfifoReadPos] & 0xFF)+ ""String_Node_Str""+ rxfifoLen);
source.byteReceived((memory[RAM_RXFIFO + rxfifoReadPos] & 0xFF));
if (rxfifoLen > 0) {
if (rxfifoReadLeft == 0) {
rxfifoReadLeft=(memory[RAM_RXFIFO + rxfifoReadPos] & 0xFF);
}
 else if (--rxfifoReadLeft == 0) {
if (rxfifoLen > 1 && rxfifoLen >= (memory[RAM_RXFIFO + (rxfifoReadPos + 1) & 127] & 0xFF) + 1) {
if (!overflow) setFIFOP(true);
}
}
rxfifoReadPos=(rxfifoReadPos + 1) & 127;
rxfifoLen--;
}
if (rxfifoLen == 0) {
if (DEBUG) log(""String_Node_Str"");
setFIFO(false);
}
if (fifoP && !overflow) {
if (DEBUG) log(""String_Node_Str"" + rxfifoReadPos + ""String_Node_Str""+ lastPacketStart);
setFIFOP(false);
}
return;
case WRITE_TXFIFO:
if (txfifoFlush) {
txCursor=0;
txfifoFlush=false;
}
if (DEBUG) log(""String_Node_Str"" + data + ""String_Node_Str""+ txCursor);
if (txCursor == 0) {
if ((data & 0xff) > 127) {
logger.warning(this,""String_Node_Str"");
}
}
 else if (txCursor > 127) {
logger.warning(this,""String_Node_Str"");
txCursor=0;
}
memory[RAM_TXFIFO + txCursor]=data & 0xff;
txCursor++;
if (sendEvents) {
sendEvent(""String_Node_Str"",null);
}
break;
case RAM_ACCESS:
if (pos == 0) {
address|=(data << 1) & 0x180;
ramRead=(data & 0x20) != 0;
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ ramRead);
}
pos++;
}
 else {
if (!ramRead) {
memory[address++]=data;
if (address >= 0x180) {
logger.warning(this,""String_Node_Str"");
address=0;
}
if (DEBUG && address == RAM_PANID + 2) {
log(""String_Node_Str"" + Utils.hex8(memory[RAM_PANID]) + Utils.hex8(memory[RAM_PANID + 1]));
}
}
 else {
source.byteReceived(memory[address++]);
if (address >= 0x180) {
logger.warning(this,""String_Node_Str"");
address=0;
}
return;
}
}
break;
}
source.byteReceived(oldStatus);
}
}","public void dataReceived(USART source,int data){
  int oldStatus=status;
  if (DEBUG) {
    log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ ((data >= ' ' && data <= 'Z') ? (char)data : '.')+ ')'+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ state+ ""String_Node_Str""+ stateMachine);
  }
  if ((stateMachine != RadioState.VREG_OFF) && chipSelect) {
switch (state) {
case WAITING:
      if ((data & FLAG_READ) != 0) {
        state=SpiState.READ_REGISTER;
      }
 else {
        state=SpiState.WRITE_REGISTER;
      }
    if ((data & FLAG_RAM) != 0) {
      state=SpiState.RAM_ACCESS;
      address=data & 0x7f;
    }
 else {
      address=data & 0x3f;
      if (address == REG_RXFIFO) {
        state=SpiState.READ_RXFIFO;
      }
 else       if (address == REG_TXFIFO) {
        state=SpiState.WRITE_TXFIFO;
      }
    }
  if (data < 0x0f) {
    strobe(data);
    state=SpiState.WAITING;
  }
pos=0;
break;
case WRITE_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
registers[address]=(registers[address] & 0xff) | (data << 8);
pos=1;
}
 else {
source.byteReceived(registers[address] & 0xff);
registers[address]=(registers[address] & 0xff00) | data;
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
data=registers[address];
setReg(address,data);
state=SpiState.WAITING;
}
break;
case READ_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
pos=1;
}
 else {
source.byteReceived(registers[address] & 0xff);
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
state=SpiState.WAITING;
}
return;
case READ_RXFIFO:
if (DEBUG) log(""String_Node_Str"" + rxfifoReadPos + ""String_Node_Str""+ (memory[RAM_RXFIFO + rxfifoReadPos] & 0xFF)+ ""String_Node_Str""+ rxfifoLen);
source.byteReceived((memory[RAM_RXFIFO + rxfifoReadPos] & 0xFF));
if (rxfifoLen > 0) {
if (fifoP && !overflow) {
if (DEBUG) log(""String_Node_Str"" + rxfifoReadPos + ""String_Node_Str""+ lastPacketStart);
setFIFOP(false);
}
if (rxfifoReadLeft == 0) {
rxfifoReadLeft=(memory[RAM_RXFIFO + rxfifoReadPos] & 0xFF);
System.out.println(""String_Node_Str"" + rxfifoReadLeft);
}
 else if (--rxfifoReadLeft == 0) {
if (rxfifoLen > 1 && rxfifoLen >= (memory[RAM_RXFIFO + (rxfifoReadPos + 1) & 127] & 0xFF) + 1) {
System.out.println(""String_Node_Str"");
if (!overflow) setFIFOP(true);
}
}
rxfifoReadPos=(rxfifoReadPos + 1) & 127;
rxfifoLen--;
}
if (rxfifoLen == 0) {
if (DEBUG) log(""String_Node_Str"");
setFIFO(false);
}
return;
case WRITE_TXFIFO:
if (txfifoFlush) {
txCursor=0;
txfifoFlush=false;
}
if (DEBUG) log(""String_Node_Str"" + data + ""String_Node_Str""+ txCursor);
if (txCursor == 0) {
if ((data & 0xff) > 127) {
logger.warning(this,""String_Node_Str"");
}
}
 else if (txCursor > 127) {
logger.warning(this,""String_Node_Str"");
txCursor=0;
}
memory[RAM_TXFIFO + txCursor]=data & 0xff;
txCursor++;
if (sendEvents) {
sendEvent(""String_Node_Str"",null);
}
break;
case RAM_ACCESS:
if (pos == 0) {
address|=(data << 1) & 0x180;
ramRead=(data & 0x20) != 0;
if (DEBUG) {
log(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ ramRead);
}
pos++;
}
 else {
if (!ramRead) {
memory[address++]=data;
if (address >= 0x180) {
logger.warning(this,""String_Node_Str"");
address=0;
}
if (DEBUG && address == RAM_PANID + 2) {
log(""String_Node_Str"" + Utils.hex8(memory[RAM_PANID]) + Utils.hex8(memory[RAM_PANID + 1]));
}
}
 else {
source.byteReceived(memory[address++]);
if (address >= 0x180) {
logger.warning(this,""String_Node_Str"");
address=0;
}
return;
}
}
break;
}
source.byteReceived(oldStatus);
}
}",0.8824109280383045
5592,"private void flushRX(){
  if (DEBUG) {
    log(""String_Node_Str"" + rxfifoLen);
  }
  rxfifoReadPos=0;
  rxfifoWritePos=0;
  rxfifoLen=0;
  setSFD(false);
  setFIFOP(false);
  setFIFO(false);
  overflow=false;
  if ((stateMachine == RadioState.RX_CALIBRATE) || (stateMachine == RadioState.RX_SFD_SEARCH) || (stateMachine == RadioState.RX_FRAME)|| (stateMachine == RadioState.RX_OVERFLOW)|| (stateMachine == RadioState.RX_WAIT)) {
    setState(RadioState.RX_SFD_SEARCH);
  }
}","private void flushRX(){
  if (DEBUG) {
    log(""String_Node_Str"" + rxfifoLen);
  }
  rxfifoReadPos=0;
  rxfifoReadLeft=0;
  rxfifoWritePos=0;
  rxfifoLen=0;
  setSFD(false);
  setFIFOP(false);
  setFIFO(false);
  overflow=false;
  if ((stateMachine == RadioState.RX_CALIBRATE) || (stateMachine == RadioState.RX_SFD_SEARCH) || (stateMachine == RadioState.RX_FRAME)|| (stateMachine == RadioState.RX_OVERFLOW)|| (stateMachine == RadioState.RX_WAIT)) {
    setState(RadioState.RX_SFD_SEARCH);
  }
}",0.9793388429752066
5593,"private boolean setState(RadioState state){
  if (DEBUG)   log(""String_Node_Str"" + stateMachine + ""String_Node_Str""+ state);
  stateMachine=state;
  registers[REG_FSMSTATE]=state.getFSMState();
switch (stateMachine) {
case VREG_OFF:
    if (DEBUG)     log(""String_Node_Str"");
  flushRX();
flushTX();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case POWER_DOWN:
rxfifoReadPos=0;
rxfifoWritePos=0;
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case RX_CALIBRATE:
setSymbolEvent(8);
setMode(MODE_RX_ON);
break;
case RX_SFD_SEARCH:
zeroSymbols=0;
status|=STATUS_RSSI_VALID;
updateCCA();
setMode(MODE_RX_ON);
break;
case TX_CALIBRATE:
setSymbolEvent(12 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_FRAME:
txfifoPos=0;
txNext();
break;
case RX_WAIT:
setSymbolEvent(8);
setMode(MODE_RX_ON);
break;
case IDLE:
status&=~STATUS_RSSI_VALID;
setMode(MODE_TXRX_OFF);
updateCCA();
break;
case TX_ACK_CALIBRATE:
status|=STATUS_TX_ACTIVE;
setSymbolEvent(12 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_ACK_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_ACK:
ackPos=0;
ackNext();
break;
}
if (stateListener != null) {
stateListener.newState(stateMachine);
}
return true;
}","private boolean setState(RadioState state){
  if (DEBUG)   log(""String_Node_Str"" + stateMachine + ""String_Node_Str""+ state);
  stateMachine=state;
  registers[REG_FSMSTATE]=state.getFSMState();
switch (stateMachine) {
case VREG_OFF:
    if (DEBUG)     log(""String_Node_Str"");
  flushRX();
flushTX();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case POWER_DOWN:
rxfifoReadPos=0;
rxfifoReadLeft=0;
rxfifoWritePos=0;
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
reset();
setMode(MODE_POWER_OFF);
updateCCA();
break;
case RX_CALIBRATE:
setSymbolEvent(8);
setMode(MODE_RX_ON);
break;
case RX_SFD_SEARCH:
zeroSymbols=0;
status|=STATUS_RSSI_VALID;
updateCCA();
setMode(MODE_RX_ON);
break;
case TX_CALIBRATE:
setSymbolEvent(12 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_FRAME:
txfifoPos=0;
txNext();
break;
case RX_WAIT:
setSymbolEvent(8);
setMode(MODE_RX_ON);
break;
case IDLE:
status&=~STATUS_RSSI_VALID;
setMode(MODE_TXRX_OFF);
updateCCA();
break;
case TX_ACK_CALIBRATE:
status|=STATUS_TX_ACTIVE;
setSymbolEvent(12 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_ACK_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_ACK:
ackPos=0;
ackNext();
break;
}
if (stateListener != null) {
stateListener.newState(stateMachine);
}
return true;
}",0.993745656706046
5594,"private boolean checkAutoack(){
  boolean ackReq=(memory[RAM_RXFIFO + lastPacketStart] & ACK_REQUEST) != 0;
  if (!ackReq)   return false;
  System.out.println(""String_Node_Str"");
  int destAddrMode=(memory[RAM_RXFIFO + (lastPacketStart + 1) & 127] >> 2) & 3;
  if (destAddrMode == LONG_ADDRESS) {
    int addrSize=8;
    int addrPos=lastPacketStart + 5;
    for (int i=0; i < addrSize; i++) {
      System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ memory[RAM_IEEEADDR + i]+ ""String_Node_Str""+ memory[RAM_RXFIFO + ((addrPos + i) & 127)]);
      if (memory[RAM_IEEEADDR + i] != memory[RAM_RXFIFO + ((addrPos + i) & 127)]) {
        return false;
      }
    }
  }
 else {
    int addrPos=lastPacketStart + 5;
    for (int i=0; i < 2; i++) {
      System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ memory[RAM_SHORTADDR + i]+ ""String_Node_Str""+ memory[RAM_RXFIFO + ((addrPos + i) & 127)]);
      if (memory[RAM_SHORTADDR + i] != memory[RAM_RXFIFO + ((addrPos + i) & 127)]) {
        return false;
      }
    }
  }
  System.out.println(""String_Node_Str"" + memory[RAM_IEEEADDR]);
  return true;
}","private boolean checkAutoack(){
  boolean ackReq=(memory[RAM_RXFIFO + lastPacketStart] & ACK_REQUEST) != 0;
  if (!ackReq)   return false;
  return true;
}",0.2437106918238993
5595,"public void receivedByte(byte data){
  log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      rxread=0;
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (rxfifoLen == 128) {
      setRxOverflow();
    }
 else {
      memory[RAM_RXFIFO + rxfifoWritePos]=data & 0xFF;
      rxfifoWritePos=(rxfifoWritePos + 1) & 127;
      rxfifoLen++;
      if (rxread == 0) {
        rxCrc.setCRC(0);
        rxlen=data & 0xff;
        rxPacketStart=rxfifoWritePos;
        decodeAddress=false;
        if (DEBUG)         log(""String_Node_Str"" + rxlen);
        setFIFO(true);
      }
 else       if (rxread < rxlen - 2) {
        rxCrc.add(data & 0xff);
        if (rxread == 2) {
          if (TYPE_DATA_FRAME == (memory[RAM_RXFIFO + rxPacketStart] & FRAME_TYPE)) {
            decodeAddress=addressDecode & (memory[RAM_RXFIFO + rxPacketStart] & ACK_REQUEST) > 0;
            destinationAddressMode=(memory[RAM_RXFIFO + (rxPacketStart + 1)] >> 2) & 3;
          }
        }
        if (decodeAddress) {
          boolean flushPacket=false;
          if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
            int addrPos=rxPacketStart + 5;
            for (int i=0; i < 8; i++) {
              if (memory[RAM_IEEEADDR + i] != memory[RAM_RXFIFO + ((addrPos + i) & 127)]) {
                flushPacket=true;
              }
            }
            System.out.print(""String_Node_Str"" + !flushPacket + ""String_Node_Str"");
            for (int i=0; i < 8; i++) {
              System.out.print(Utils.hex8(memory[RAM_RXFIFO + ((addrPos + i) & 127)]) + ""String_Node_Str"");
            }
            System.out.println(""String_Node_Str"" + memory[RAM_IEEEADDR]);
            decodeAddress=false;
          }
 else           if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
            int addrPos=rxPacketStart + 5;
            boolean bc=true;
            for (int i=0; i < 2; i++) {
              int addrData=memory[RAM_RXFIFO + ((addrPos + i) & 127)];
              if (bc && addrData != 0xff) {
                bc=false;
              }
              if (memory[RAM_SHORTADDR + i] != addrData) {
                flushPacket=true;
              }
            }
            if (bc)             flushPacket=false;
            System.out.print(""String_Node_Str"" + !flushPacket + ""String_Node_Str"");
            for (int i=0; i < 2; i++) {
              System.out.print(Utils.hex8(memory[RAM_RXFIFO + ((addrPos + i) & 127)]) + ""String_Node_Str"");
            }
            System.out.println(""String_Node_Str"" + memory[RAM_IEEEADDR]);
            decodeAddress=false;
          }
          if (flushPacket) {
            System.out.println(""String_Node_Str"");
            rxfifoLen=rxfifoLen - rxread;
            rxfifoWritePos=(rxPacketStart - 1 + 128) & 127;
            System.out.println(""String_Node_Str"" + rxfifoWritePos + ""String_Node_Str""+ rxfifoReadPos);
            setSFD(false);
            setFIFOP(false);
            setFIFO(false);
            setState(RadioState.RX_SFD_SEARCH);
          }
        }
      }
      if (rxread++ == rxlen) {
        int crc=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)] << 8;
        crc+=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)];
        if (DEBUG && crc != rxCrc.getCRC()) {
          log(""String_Node_Str"" + crc + ""String_Node_Str""+ rxCrc.getCRC());
        }
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)]=(registers[REG_RSSI]) & 0xff;
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)]=37 | (crc == rxCrc.getCRC() ? 0x80 : 0);
        setFIFOP(true);
        setSFD(false);
        lastPacketStart=(rxfifoWritePos + 128 - rxlen) & 127;
        if (true || DEBUG)         log(""String_Node_Str"" + lastPacketStart);
        if ((autoAck && checkAutoack()) || shouldAck) {
          ackBuf[ACK_SEQPOS]=memory[RAM_RXFIFO + lastPacketStart + 2];
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}","public void receivedByte(byte data){
  log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      zeroSymbols++;
    }
 else     if (zeroSymbols >= 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      rxread=0;
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (rxfifoLen == 128) {
      setRxOverflow();
    }
 else {
      memory[RAM_RXFIFO + rxfifoWritePos]=data & 0xFF;
      rxfifoWritePos=(rxfifoWritePos + 1) & 127;
      rxfifoLen++;
      if (rxread == 0) {
        rxCrc.setCRC(0);
        rxlen=data & 0xff;
        rxPacketStart=rxfifoWritePos;
        decodeAddress=false;
        if (DEBUG)         log(""String_Node_Str"" + rxlen);
        setFIFO(true);
      }
 else       if (rxread < rxlen - 2) {
        rxCrc.add(data & 0xff);
        if (rxread == 2) {
          if (TYPE_DATA_FRAME == (memory[RAM_RXFIFO + rxPacketStart] & FRAME_TYPE)) {
            decodeAddress=addressDecode & (memory[RAM_RXFIFO + rxPacketStart] & ACK_REQUEST) > 0;
            destinationAddressMode=(memory[RAM_RXFIFO + ((rxPacketStart + 1) & 127)] >> 2) & 3;
          }
        }
        if (decodeAddress) {
          boolean flushPacket=false;
          if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
            int addrPos=rxPacketStart + 5;
            for (int i=0; i < 8; i++) {
              if (memory[RAM_IEEEADDR + i] != memory[RAM_RXFIFO + ((addrPos + i) & 127)]) {
                flushPacket=true;
              }
            }
            decodeAddress=false;
          }
 else           if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5) {
            int addrPos=rxPacketStart + 5;
            boolean bc=true;
            for (int i=0; i < 2; i++) {
              int addrData=memory[RAM_RXFIFO + ((addrPos + i) & 127)];
              if (bc && addrData != 0xff) {
                bc=false;
              }
              if (memory[RAM_SHORTADDR + i] != addrData) {
                flushPacket=true;
              }
            }
            if (bc)             flushPacket=false;
            decodeAddress=false;
          }
          if (flushPacket) {
            rxfifoLen=rxfifoLen - rxread;
            rxfifoWritePos=(rxPacketStart - 1 + 128) & 127;
            setSFD(false);
            setFIFOP(false);
            setFIFO(false);
            setState(RadioState.RX_SFD_SEARCH);
          }
        }
      }
      if (rxread++ == rxlen) {
        int crc=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)] << 8;
        crc+=memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)];
        if (DEBUG && crc != rxCrc.getCRC()) {
          log(""String_Node_Str"" + crc + ""String_Node_Str""+ rxCrc.getCRC());
        }
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)]=(registers[REG_RSSI]) & 0xff;
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)]=37 | (crc == rxCrc.getCRC() ? 0x80 : 0);
        setFIFOP(true);
        setSFD(false);
        lastPacketStart=(rxfifoWritePos + 128 - rxlen) & 127;
        if (DEBUG)         log(""String_Node_Str"" + lastPacketStart + ""String_Node_Str""+ rxPacketStart);
        if ((autoAck && checkAutoack()) || shouldAck) {
          ackBuf[ACK_SEQPOS]=memory[RAM_RXFIFO + lastPacketStart + 2];
          setState(RadioState.TX_ACK_CALIBRATE);
        }
 else {
          setState(RadioState.RX_WAIT);
        }
      }
    }
  }
}",0.7583606956098747
5596,"public long stepMicros(long jumpMicros,long executeMicros) throws EmulationException {
  if (isRunning()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (jumpMicros < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + jumpMicros);
  }
  if (!microClockReady) {
    System.out.println(""String_Node_Str"" + cycles);
    lastMicrosCycles=cycles;
    microClockReady=true;
  }
  lastMicrosDelta+=jumpMicros;
  long maxCycles=lastMicrosCycles + (lastMicrosDelta * dcoFrq) / 1000000;
  if (cpuOff) {
    if (maxCycles > nextEventCycles) {
      lastMicrosDelta-=jumpMicros;
      throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
    }
  }
 else   if (maxCycles > cycles) {
    lastMicrosDelta-=jumpMicros;
    throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
  }
  maxCycles=lastMicrosCycles + ((lastMicrosDelta + executeMicros) * dcoFrq) / 1000000;
  System.out.println(""String_Node_Str"" + cycles + ""String_Node_Str""+ (jumpMicros)+ ""String_Node_Str""+ executeMicros+ ""String_Node_Str""+ maxCycles);
  if (debug) {
    if (servicedInterrupt >= 0) {
      disAsm.disassemble(reg[PC],memory,reg,servicedInterrupt);
    }
 else {
      disAsm.disassemble(reg[PC],memory,reg);
    }
  }
  boolean emuOP=false;
  while (cycles < maxCycles) {
    if (emuOP=emulateOP(maxCycles)) {
      if (execCounter != null) {
        execCounter[reg[PC]]++;
      }
      if (trace != null) {
        trace[tracePos++]=reg[PC];
        if (tracePos > trace.length)         tracePos=0;
      }
    }
  }
  if (cpuOff) {
    lastReturnedMicros=(1000000 * (nextEventCycles - cycles)) / dcoFrq;
  }
 else {
    lastReturnedMicros=0;
  }
  return lastReturnedMicros;
}","public long stepMicros(long jumpMicros,long executeMicros) throws EmulationException {
  if (isRunning()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (jumpMicros < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + jumpMicros);
  }
  if (!microClockReady) {
    lastMicrosCycles=maxCycles;
  }
  lastMicrosDelta+=jumpMicros;
  if (microClockReady) {
    maxCycles=lastMicrosCycles + (lastMicrosDelta * dcoFrq) / 1000000;
    if (cpuOff) {
      if (maxCycles > nextEventCycles) {
        lastMicrosDelta-=jumpMicros;
        throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
      }
    }
 else     if (maxCycles > cycles) {
      lastMicrosDelta-=jumpMicros;
      throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
    }
  }
  microClockReady=true;
  maxCycles=lastMicrosCycles + ((lastMicrosDelta + executeMicros) * dcoFrq) / 1000000;
  if (debug) {
    if (servicedInterrupt >= 0) {
      disAsm.disassemble(reg[PC],memory,reg,servicedInterrupt);
    }
 else {
      disAsm.disassemble(reg[PC],memory,reg);
    }
  }
  boolean emuOP=false;
  while (cycles < maxCycles || (cpuOff && (nextEventCycles < cycles))) {
    if (emuOP=emulateOP(maxCycles)) {
      if (execCounter != null) {
        execCounter[reg[PC]]++;
      }
      if (trace != null) {
        if (tracePos > trace.length) {
          tracePos=0;
        }
        trace[tracePos++]=reg[PC];
      }
    }
  }
  if (cpuOff) {
    lastReturnedMicros=(1000000 * (nextEventCycles - cycles)) / dcoFrq;
  }
 else {
    lastReturnedMicros=0;
  }
  if (cycles < maxCycles) {
    throw new RuntimeException(""String_Node_Str"" + cycles + ""String_Node_Str""+ maxCycles);
  }
  if (lastReturnedMicros < 0) {
    throw new RuntimeException(""String_Node_Str"" + lastReturnedMicros);
  }
  return lastReturnedMicros;
}",0.7751641137855579
5597,"public void setupCommands(ComponentRegistry registry,CommandHandler ch){
  this.registry=registry;
  final MSP430 cpu=(MSP430)registry.getComponent(MSP430.class);
  final GenericNode node=(GenericNode)registry.getComponent(""String_Node_Str"");
  if (cpu != null) {
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int address=0;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        if (baddr < 0) {
          context.err.println(""String_Node_Str"" + context.getArgument(0));
          return 1;
        }
        cpu.setBreakPoint(address=baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            context.out.println(""String_Node_Str"" + Utils.hex16(adr));
            cpu.stop();
          }
        }
);
        context.out.println(""String_Node_Str"" + Utils.hex16(baddr));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int address=0;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        if (baddr == -1) {
          context.err.println(""String_Node_Str"" + context.getArgument(0));
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          String modeStr=context.getArgument(1);
          if (""String_Node_Str"".equals(modeStr)) {
            mode=1;
          }
 else           if (""String_Node_Str"".equals(modeStr)) {
            mode=2;
          }
        }
        cpu.setBreakPoint(address=baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0 || mode == 2) {
              int pc=cpu.readRegister(0);
              String adrStr=getSymOrAddr(context,adr);
              String pcStr=getSymOrAddrELF(getELF(),pc);
              String op=""String_Node_Str"";
              if (type == MEMORY_READ) {
                op=""String_Node_Str"";
              }
 else               if (type == MEMORY_WRITE) {
                op=""String_Node_Str"";
              }
              context.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pcStr+ ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
              if (mode == 2) {
                cpu.stop();
              }
            }
 else {
              context.out.print((char)data);
            }
          }
        }
);
        context.out.println(""String_Node_Str"" + Utils.hex16(baddr));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
        context.exit(0);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int register=0;
      public int executeCommand(      final CommandContext context){
        register=context.getArgumentAsRegister(0);
        if (register < 0) {
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          String modeStr=context.getArgument(1);
          if (""String_Node_Str"".equals(modeStr)) {
            mode=1;
          }
 else {
            context.err.println(""String_Node_Str"" + modeStr);
            return -1;
          }
        }
        cpu.setRegisterWriteMonitor(register,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0) {
              int pc=cpu.readRegister(0);
              String adrStr=getRegisterName(register);
              String pcStr=getSymOrAddrELF(getELF(),pc);
              context.out.println(""String_Node_Str"" + pcStr + ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
            }
 else {
              context.out.println(data);
            }
          }
        }
);
        context.out.println(""String_Node_Str"" + getRegisterName(register));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(register);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new Command(){
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(baddr,null);
        return 0;
      }
      public String getArgumentHelp(      String commandName){
        return ""String_Node_Str"";
      }
      public String getCommandHelp(      String commandName){
        return ""String_Node_Str"";
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
      public int executeCommand(      final CommandContext context){
        String regExp=context.getArgument(0);
        MapEntry[] entries=context.getMapTable().getEntries(regExp);
        for (int i=0; i < entries.length; i++) {
          MapEntry mapEntry=entries[i];
          int address=mapEntry.getAddress();
          context.out.println(""String_Node_Str"" + mapEntry.getName() + ""String_Node_Str""+ Utils.hex16(address)+ ""String_Node_Str""+ Utils.hex8(cpu.memory[address])+ ""String_Node_Str""+ Utils.hex8(cpu.memory[address + 1])+ ""String_Node_Str"");
        }
        return 0;
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
      public int executeCommand(      final CommandContext context){
        int adr=context.getArgumentAsAddress(0);
        DebugInfo di=getELF().getDebugInfo(adr);
        if (di == null) {
          di=getELF().getDebugInfo(adr + 1);
        }
        if (di != null) {
          di.getLine();
          context.out.println(di);
        }
 else {
          context.err.println(""String_Node_Str"" + context.getArgument(0));
        }
        return 0;
      }
    }
);
    if (node != null) {
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.stop();
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)));
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.start();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int nr=context.getArgumentCount() > 0 ? context.getArgumentAsInt(0) : 1;
          long cyc=cpu.cycles;
          if (cpu.isRunning()) {
            context.err.println(""String_Node_Str"");
            return -1;
          }
          try {
            node.step(nr);
          }
 catch (          Exception e) {
            e.printStackTrace(context.out);
          }
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)) + ""String_Node_Str""+ (cpu.cycles - cyc)+ ""String_Node_Str""+ cpu.cycles+ ""String_Node_Str"");
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int nr=context.getArgumentCount() > 0 ? context.getArgumentAsInt(0) : 1;
          long cyc=cpu.cycles;
          if (cpu.isRunning()) {
            context.err.println(""String_Node_Str"");
            return -1;
          }
          long nxt=0;
          try {
            nxt=cpu.stepMicros(context.getArgumentAsLong(0),context.getArgumentAsLong(1));
          }
 catch (          Exception e) {
            e.printStackTrace(context.out);
          }
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)) + ""String_Node_Str""+ (cpu.cycles - cyc)+ ""String_Node_Str""+ cpu.cycles+ ""String_Node_Str""+ nxt);
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int stackEnd=context.getMapTable().heapStartAddress;
          int stackStart=context.getMapTable().stackStartAddress;
          int current=cpu.readRegister(MSP430Constants.SP);
          context.out.println(""String_Node_Str"" + Utils.hex16(current) + ""String_Node_Str""+ (stackStart - current)+ ""String_Node_Str""+ (stackStart - stackEnd)+ ')');
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int adr=context.getArgumentAsAddress(0);
          if (adr != -1) {
            try {
              context.out.println(""String_Node_Str"" + context.getArgument(0) + ""String_Node_Str""+ Utils.hex16(cpu.read(adr,adr >= 0x100)));
            }
 catch (            Exception e) {
              e.printStackTrace(context.out);
            }
            return 0;
          }
 else {
            context.err.println(""String_Node_Str"" + context.getArgument(0));
            return 1;
          }
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int register=context.getArgumentAsRegister(0);
          if (register >= 0) {
            context.out.println(context.getArgument(0) + ""String_Node_Str"" + Utils.hex16(cpu.readRegister(register)));
            return 0;
          }
          return -1;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          cpu.reset();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          long time=((long)(cpu.getTimeMillis()));
          long wallDiff=System.currentTimeMillis() - lastWall;
          context.out.println(""String_Node_Str"" + time + ""String_Node_Str""+ (time - lastCall)+ ""String_Node_Str""+ ""String_Node_Str""+ wallDiff+ ""String_Node_Str""+ (wallDiff == 0 ? ""String_Node_Str"" : ""String_Node_Str"" + (time - lastCall) / wallDiff));
          lastCall=time;
          lastWall=System.currentTimeMillis();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int start=context.getArgumentAsAddress(0);
          int count=context.getArgumentAsInt(1);
          int mode=Utils.DEC;
          int type=Utils.UBYTE;
          boolean signed=false;
          if (context.getArgumentCount() > 2) {
            int pos=2;
            int acount=context.getArgumentCount();
            if (acount > 4)             acount=4;
            while (pos < acount) {
              String tS=context.getArgument(pos++);
              if (""String_Node_Str"".equals(tS)) {
              }
 else               if (""String_Node_Str"".equals(tS)) {
                type=Utils.BYTE;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                type=Utils.WORD;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                type=Utils.UWORD;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                mode=Utils.HEX;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                mode=Utils.ASCII;
                type=Utils.BYTE;
              }
            }
          }
          for (int i=0; i < count; i++) {
            int data=0;
            data=cpu.memory[start++];
            if (Utils.size(type) == 2) {
              data=data + (cpu.memory[start++] << 8);
            }
            context.out.print((mode != Utils.ASCII ? ""String_Node_Str"" : ""String_Node_Str"") + Utils.toString(data,type,mode));
          }
          context.out.println();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int count=context.getArgumentCount();
          int adr=context.getArgumentAsAddress(0);
          String arg2=context.getArgument(1);
          int type=Utils.BYTE;
          int mode=Utils.DEC;
          boolean typeRead=false;
          if (count > 2) {
            if (""String_Node_Str"".equals(arg2)) {
              mode=Utils.ASCII;
              typeRead=true;
            }
            if (""String_Node_Str"".equals(arg2)) {
              type=Utils.WORD;
              typeRead=true;
            }
          }
          for (int i=typeRead ? 2 : 1; i < count; i++) {
            if (mode == Utils.DEC) {
              int val=context.getArgumentAsInt(i);
              boolean word=Utils.size(type) == 2 | val > 0xff;
              try {
                cpu.write(adr,val,word);
                adr+=word ? 2 : 1;
              }
 catch (              EmulationException e) {
                e.printStackTrace(context.out);
              }
            }
 else             if (mode == Utils.ASCII) {
              String data=context.getArgument(i);
              for (int j=0; j < data.length(); j++) {
                cpu.write(adr++,data.charAt(j) & 0xff,false);
              }
            }
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          Memory xmem=(Memory)DebugCommands.this.registry.getComponent(""String_Node_Str"");
          if (xmem == null) {
            context.err.println(""String_Node_Str"");
            return 0;
          }
          int start=context.getArgumentAsAddress(0);
          int count=context.getArgumentAsInt(1);
          int size=1;
          boolean signed=false;
          if (context.getArgumentCount() > 2) {
            String tS=context.getArgument(2);
            if (""String_Node_Str"".equals(tS)) {
              signed=true;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              signed=true;
              size=2;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              size=2;
            }
          }
          for (int i=0; i < count; i++) {
            int data=0;
            data=xmem.readByte(start++);
            if (size == 2) {
              data=data + (xmem.readByte(start++) << 8);
            }
            context.out.print(""String_Node_Str"" + data);
          }
          context.out.println();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          Memory xmem=(Memory)DebugCommands.this.registry.getComponent(""String_Node_Str"");
          if (xmem == null) {
            context.err.println(""String_Node_Str"");
            return 0;
          }
          int adr=context.getArgumentAsAddress(0);
          int val=context.getArgumentAsInt(1);
          boolean word=val > 0xff;
          if (word) {
            xmem.writeByte(adr,val >> 8);
            val=val & 0xff;
            adr++;
          }
          xmem.writeByte(adr,val & 0xff);
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        private GDBStubs stubs=null;
        public int executeCommand(        CommandContext context){
          if (stubs != null) {
            context.err.println(""String_Node_Str"");
          }
 else {
            int port=context.getArgumentAsInt(0);
            stubs=new GDBStubs();
            stubs.setupServer(cpu,port);
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        @Override public int executeCommand(        CommandContext context){
          Chip[] chips=cpu.getChips();
          for (int i=0; i < chips.length; i++) {
            context.out.println(chips[i].getName());
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
        Chip chip=null;
        @Override public int executeCommand(        CommandContext context){
          chip=cpu.getChip(context.getArgument(0));
          if (chip == null) {
            context.err.println(""String_Node_Str"" + context.getArgument(0));
          }
          chip.setLogStream(context.out);
          return 0;
        }
        public void stopCommand(        CommandContext context){
          chip.clearLogStream();
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        @Override public int executeCommand(        CommandContext context){
          if (""String_Node_Str"".equals(context.getArgument(0))) {
            int size=cpu.getTraceSize();
            DisAsm disAsm=cpu.getDisAsm();
            for (int i=0; i < size; i++) {
              int pc=cpu.getBackTrace(i);
              DbgInstruction inst=disAsm.getDbgInstruction(pc,cpu);
              inst.setPos(pc);
              System.out.println(inst);
            }
          }
 else {
            cpu.setTrace(context.getArgumentAsInt(0));
          }
          return 0;
        }
      }
);
    }
  }
}","public void setupCommands(ComponentRegistry registry,CommandHandler ch){
  this.registry=registry;
  final MSP430 cpu=(MSP430)registry.getComponent(MSP430.class);
  final GenericNode node=(GenericNode)registry.getComponent(""String_Node_Str"");
  if (cpu != null) {
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int address=0;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        if (baddr < 0) {
          context.err.println(""String_Node_Str"" + context.getArgument(0));
          return 1;
        }
        cpu.setBreakPoint(address=baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            context.out.println(""String_Node_Str"" + Utils.hex16(adr));
            cpu.stop();
          }
        }
);
        context.out.println(""String_Node_Str"" + Utils.hex16(baddr));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int address=0;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        if (baddr == -1) {
          context.err.println(""String_Node_Str"" + context.getArgument(0));
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          String modeStr=context.getArgument(1);
          if (""String_Node_Str"".equals(modeStr)) {
            mode=1;
          }
 else           if (""String_Node_Str"".equals(modeStr)) {
            mode=2;
          }
        }
        cpu.setBreakPoint(address=baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0 || mode == 2) {
              int pc=cpu.readRegister(0);
              String adrStr=getSymOrAddr(context,adr);
              String pcStr=getSymOrAddrELF(getELF(),pc);
              String op=""String_Node_Str"";
              if (type == MEMORY_READ) {
                op=""String_Node_Str"";
              }
 else               if (type == MEMORY_WRITE) {
                op=""String_Node_Str"";
              }
              context.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pcStr+ ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
              if (mode == 2) {
                cpu.stop();
              }
            }
 else {
              context.out.print((char)data);
            }
          }
        }
);
        context.out.println(""String_Node_Str"" + Utils.hex16(baddr));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
        context.exit(0);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int register=0;
      public int executeCommand(      final CommandContext context){
        register=context.getArgumentAsRegister(0);
        if (register < 0) {
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          String modeStr=context.getArgument(1);
          if (""String_Node_Str"".equals(modeStr)) {
            mode=1;
          }
 else {
            context.err.println(""String_Node_Str"" + modeStr);
            return -1;
          }
        }
        cpu.setRegisterWriteMonitor(register,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0) {
              int pc=cpu.readRegister(0);
              String adrStr=getRegisterName(register);
              String pcStr=getSymOrAddrELF(getELF(),pc);
              context.out.println(""String_Node_Str"" + pcStr + ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
            }
 else {
              context.out.println(data);
            }
          }
        }
);
        context.out.println(""String_Node_Str"" + getRegisterName(register));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(register);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new Command(){
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(baddr,null);
        return 0;
      }
      public String getArgumentHelp(      String commandName){
        return ""String_Node_Str"";
      }
      public String getCommandHelp(      String commandName){
        return ""String_Node_Str"";
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
      public int executeCommand(      final CommandContext context){
        String regExp=context.getArgument(0);
        MapEntry[] entries=context.getMapTable().getEntries(regExp);
        for (int i=0; i < entries.length; i++) {
          MapEntry mapEntry=entries[i];
          int address=mapEntry.getAddress();
          context.out.println(""String_Node_Str"" + mapEntry.getName() + ""String_Node_Str""+ Utils.hex16(address)+ ""String_Node_Str""+ Utils.hex8(cpu.memory[address])+ ""String_Node_Str""+ Utils.hex8(cpu.memory[address + 1])+ ""String_Node_Str"");
        }
        return 0;
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
      public int executeCommand(      final CommandContext context){
        int adr=context.getArgumentAsAddress(0);
        DebugInfo di=getELF().getDebugInfo(adr);
        if (di == null) {
          di=getELF().getDebugInfo(adr + 1);
        }
        if (di != null) {
          di.getLine();
          context.out.println(di);
        }
 else {
          context.err.println(""String_Node_Str"" + context.getArgument(0));
        }
        return 0;
      }
    }
);
    if (node != null) {
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.stop();
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)));
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.start();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int nr=context.getArgumentCount() > 0 ? context.getArgumentAsInt(0) : 1;
          long cyc=cpu.cycles;
          if (cpu.isRunning()) {
            context.err.println(""String_Node_Str"");
            return -1;
          }
          try {
            node.step(nr);
          }
 catch (          Exception e) {
            e.printStackTrace(context.out);
          }
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)) + ""String_Node_Str""+ (cpu.cycles - cyc)+ ""String_Node_Str""+ cpu.cycles+ ""String_Node_Str"");
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int nr=context.getArgumentCount() > 0 ? context.getArgumentAsInt(0) : 1;
          long cyc=cpu.cycles;
          if (cpu.isRunning()) {
            context.err.println(""String_Node_Str"");
            return -1;
          }
          long nxt=0;
          try {
            nxt=cpu.stepMicros(context.getArgumentAsLong(0),context.getArgumentAsLong(1));
          }
 catch (          Exception e) {
            e.printStackTrace(context.out);
          }
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)) + ""String_Node_Str""+ (cpu.cycles - cyc)+ ""String_Node_Str""+ cpu.cycles+ ""String_Node_Str""+ nxt);
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int stackEnd=context.getMapTable().heapStartAddress;
          int stackStart=context.getMapTable().stackStartAddress;
          int current=cpu.readRegister(MSP430Constants.SP);
          context.out.println(""String_Node_Str"" + Utils.hex16(current) + ""String_Node_Str""+ (stackStart - current)+ ""String_Node_Str""+ (stackStart - stackEnd)+ ')');
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int adr=context.getArgumentAsAddress(0);
          if (adr != -1) {
            try {
              context.out.println(""String_Node_Str"" + context.getArgument(0) + ""String_Node_Str""+ Utils.hex16(cpu.read(adr,adr >= 0x100)));
            }
 catch (            Exception e) {
              e.printStackTrace(context.out);
            }
            return 0;
          }
 else {
            context.err.println(""String_Node_Str"" + context.getArgument(0));
            return 1;
          }
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int register=context.getArgumentAsRegister(0);
          if (register >= 0) {
            context.out.println(context.getArgument(0) + ""String_Node_Str"" + Utils.hex16(cpu.readRegister(register)));
            return 0;
          }
          return -1;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          cpu.reset();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          long time=((long)(cpu.getTimeMillis()));
          long wallDiff=System.currentTimeMillis() - lastWall;
          context.out.println(""String_Node_Str"" + time + ""String_Node_Str""+ (time - lastCall)+ ""String_Node_Str""+ ""String_Node_Str""+ wallDiff+ ""String_Node_Str""+ (wallDiff == 0 ? ""String_Node_Str"" : ""String_Node_Str"" + (time - lastCall) / wallDiff));
          lastCall=time;
          lastWall=System.currentTimeMillis();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int start=context.getArgumentAsAddress(0);
          int count=context.getArgumentAsInt(1);
          int mode=Utils.DEC;
          int type=Utils.UBYTE;
          boolean signed=false;
          if (context.getArgumentCount() > 2) {
            int pos=2;
            int acount=context.getArgumentCount();
            if (acount > 4)             acount=4;
            while (pos < acount) {
              String tS=context.getArgument(pos++);
              if (""String_Node_Str"".equals(tS)) {
              }
 else               if (""String_Node_Str"".equals(tS)) {
                type=Utils.BYTE;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                type=Utils.WORD;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                type=Utils.UWORD;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                mode=Utils.HEX;
              }
 else               if (""String_Node_Str"".equals(tS)) {
                mode=Utils.ASCII;
                type=Utils.BYTE;
              }
            }
          }
          for (int i=0; i < count; i++) {
            int data=0;
            data=cpu.memory[start++];
            if (Utils.size(type) == 2) {
              data=data + (cpu.memory[start++] << 8);
            }
            context.out.print((mode != Utils.ASCII ? ""String_Node_Str"" : ""String_Node_Str"") + Utils.toString(data,type,mode));
          }
          context.out.println();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int count=context.getArgumentCount();
          int adr=context.getArgumentAsAddress(0);
          String arg2=context.getArgument(1);
          int type=Utils.BYTE;
          int mode=Utils.DEC;
          boolean typeRead=false;
          if (count > 2) {
            if (""String_Node_Str"".equals(arg2)) {
              mode=Utils.ASCII;
              typeRead=true;
            }
            if (""String_Node_Str"".equals(arg2)) {
              type=Utils.WORD;
              typeRead=true;
            }
          }
          for (int i=typeRead ? 2 : 1; i < count; i++) {
            if (mode == Utils.DEC) {
              int val=context.getArgumentAsInt(i);
              boolean word=Utils.size(type) == 2 | val > 0xff;
              try {
                cpu.write(adr,val,word);
                adr+=word ? 2 : 1;
              }
 catch (              EmulationException e) {
                e.printStackTrace(context.out);
              }
            }
 else             if (mode == Utils.ASCII) {
              String data=context.getArgument(i);
              for (int j=0; j < data.length(); j++) {
                cpu.write(adr++,data.charAt(j) & 0xff,false);
              }
            }
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          Memory xmem=(Memory)DebugCommands.this.registry.getComponent(""String_Node_Str"");
          if (xmem == null) {
            context.err.println(""String_Node_Str"");
            return 0;
          }
          int start=context.getArgumentAsAddress(0);
          int count=context.getArgumentAsInt(1);
          int size=1;
          boolean signed=false;
          if (context.getArgumentCount() > 2) {
            String tS=context.getArgument(2);
            if (""String_Node_Str"".equals(tS)) {
              signed=true;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              signed=true;
              size=2;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              size=2;
            }
          }
          for (int i=0; i < count; i++) {
            int data=0;
            data=xmem.readByte(start++);
            if (size == 2) {
              data=data + (xmem.readByte(start++) << 8);
            }
            context.out.print(""String_Node_Str"" + data);
          }
          context.out.println();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          Memory xmem=(Memory)DebugCommands.this.registry.getComponent(""String_Node_Str"");
          if (xmem == null) {
            context.err.println(""String_Node_Str"");
            return 0;
          }
          int adr=context.getArgumentAsAddress(0);
          int val=context.getArgumentAsInt(1);
          boolean word=val > 0xff;
          if (word) {
            xmem.writeByte(adr,val >> 8);
            val=val & 0xff;
            adr++;
          }
          xmem.writeByte(adr,val & 0xff);
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        private GDBStubs stubs=null;
        public int executeCommand(        CommandContext context){
          if (stubs != null) {
            context.err.println(""String_Node_Str"");
          }
 else {
            int port=context.getArgumentAsInt(0);
            stubs=new GDBStubs();
            stubs.setupServer(cpu,port);
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        @Override public int executeCommand(        CommandContext context){
          Chip[] chips=cpu.getChips();
          for (int i=0; i < chips.length; i++) {
            context.out.println(chips[i].getName());
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
        Chip chip=null;
        @Override public int executeCommand(        CommandContext context){
          chip=cpu.getChip(context.getArgument(0));
          if (chip == null) {
            context.err.println(""String_Node_Str"" + context.getArgument(0));
          }
          chip.setLogStream(context.out);
          return 0;
        }
        public void stopCommand(        CommandContext context){
          chip.clearLogStream();
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        @Override public int executeCommand(        CommandContext context){
          if (""String_Node_Str"".equals(context.getArgument(0))) {
            int size=cpu.getTraceSize();
            DisAsm disAsm=cpu.getDisAsm();
            for (int i=0; i < size; i++) {
              int pc=cpu.getBackTrace(size - 1 - i);
              DbgInstruction inst=disAsm.getDbgInstruction(pc,cpu);
              inst.setPos(pc);
              System.out.println(inst);
            }
          }
 else {
            cpu.setTrace(context.getArgumentAsInt(0));
          }
          return 0;
        }
      }
);
    }
  }
}",0.9996951979827648
5598,"@Override public int executeCommand(CommandContext context){
  if (""String_Node_Str"".equals(context.getArgument(0))) {
    int size=cpu.getTraceSize();
    DisAsm disAsm=cpu.getDisAsm();
    for (int i=0; i < size; i++) {
      int pc=cpu.getBackTrace(i);
      DbgInstruction inst=disAsm.getDbgInstruction(pc,cpu);
      inst.setPos(pc);
      System.out.println(inst);
    }
  }
 else {
    cpu.setTrace(context.getArgumentAsInt(0));
  }
  return 0;
}","@Override public int executeCommand(CommandContext context){
  if (""String_Node_Str"".equals(context.getArgument(0))) {
    int size=cpu.getTraceSize();
    DisAsm disAsm=cpu.getDisAsm();
    for (int i=0; i < size; i++) {
      int pc=cpu.getBackTrace(size - 1 - i);
      DbgInstruction inst=disAsm.getDbgInstruction(pc,cpu);
      inst.setPos(pc);
      System.out.println(inst);
    }
  }
 else {
    cpu.setTrace(context.getArgumentAsInt(0));
  }
  return 0;
}",0.9880043620501636
5599,"public long stepMicros(long jumpMicros,long executeMicros) throws EmulationException {
  if (isRunning()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (jumpMicros < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + jumpMicros);
  }
  if (lastMicrosDelta == 0) {
    System.out.println(""String_Node_Str"" + cycles);
    lastMicrosCycles=cycles;
  }
  lastMicrosDelta+=jumpMicros;
  long maxCycles=lastMicrosCycles + (lastMicrosDelta * dcoFrq) / 1000000;
  if (cpuOff) {
    if (maxCycles > nextEventCycles) {
      lastMicrosDelta-=jumpMicros;
      throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
    }
  }
 else   if (maxCycles > cycles) {
    lastMicrosDelta-=jumpMicros;
    throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
  }
  maxCycles=lastMicrosCycles + ((lastMicrosDelta + executeMicros) * dcoFrq) / 1000000;
  System.out.println(""String_Node_Str"" + cycles + ""String_Node_Str""+ (jumpMicros)+ ""String_Node_Str""+ executeMicros+ ""String_Node_Str""+ maxCycles);
  if (debug) {
    if (servicedInterrupt >= 0) {
      disAsm.disassemble(reg[PC],memory,reg,servicedInterrupt);
    }
 else {
      disAsm.disassemble(reg[PC],memory,reg);
    }
  }
  boolean emuOP=false;
  if (maxCycles > 0) {
    while (cycles < maxCycles && !(emuOP=emulateOP(maxCycles))) {
    }
  }
  if (emuOP) {
    if ((instCtr % 10000007) == 0 && !debug) {
      printCPUSpeed(reg[PC]);
    }
    if (execCounter != null) {
      execCounter[reg[PC]]++;
    }
    if (trace != null) {
      trace[tracePos++]=reg[PC];
      if (tracePos > trace.length)       tracePos=0;
    }
  }
  if (cpuOff) {
    lastReturnedMicros=(1000000 * (nextEventCycles - cycles)) / dcoFrq;
  }
 else {
    lastReturnedMicros=0;
  }
  return lastReturnedMicros;
}","public long stepMicros(long jumpMicros,long executeMicros) throws EmulationException {
  if (isRunning()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (jumpMicros < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + jumpMicros);
  }
  if (!microClockReady) {
    System.out.println(""String_Node_Str"" + cycles);
    lastMicrosCycles=cycles;
    microClockReady=true;
  }
  lastMicrosDelta+=jumpMicros;
  long maxCycles=lastMicrosCycles + (lastMicrosDelta * dcoFrq) / 1000000;
  if (cpuOff) {
    if (maxCycles > nextEventCycles) {
      lastMicrosDelta-=jumpMicros;
      throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
    }
  }
 else   if (maxCycles > cycles) {
    lastMicrosDelta-=jumpMicros;
    throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
  }
  maxCycles=lastMicrosCycles + ((lastMicrosDelta + executeMicros) * dcoFrq) / 1000000;
  System.out.println(""String_Node_Str"" + cycles + ""String_Node_Str""+ (jumpMicros)+ ""String_Node_Str""+ executeMicros+ ""String_Node_Str""+ maxCycles);
  if (debug) {
    if (servicedInterrupt >= 0) {
      disAsm.disassemble(reg[PC],memory,reg,servicedInterrupt);
    }
 else {
      disAsm.disassemble(reg[PC],memory,reg);
    }
  }
  boolean emuOP=false;
  if (maxCycles > 0) {
    while (cycles < maxCycles && !(emuOP=emulateOP(maxCycles))) {
    }
  }
  if (emuOP) {
    if ((instCtr % 10000007) == 0 && !debug) {
      printCPUSpeed(reg[PC]);
    }
    if (execCounter != null) {
      execCounter[reg[PC]]++;
    }
    if (trace != null) {
      trace[tracePos++]=reg[PC];
      if (tracePos > trace.length)       tracePos=0;
    }
  }
  if (cpuOff) {
    lastReturnedMicros=(1000000 * (nextEventCycles - cycles)) / dcoFrq;
  }
 else {
    lastReturnedMicros=0;
  }
  return lastReturnedMicros;
}",0.9396551724137931
5600,"public void setDCOFrq(int frequency,int smclkFrq){
  dcoFrq=frequency;
  this.smclkFrq=smclkFrq;
  lastVTime=getTime();
  lastCyclesTime=cycles;
  lastMicrosDelta=0;
  currentDCOFactor=1.0 * BasicClockModule.MAX_DCO_FRQ / frequency;
  if (DEBUG)   System.out.println(""String_Node_Str"" + smclkFrq);
}","public void setDCOFrq(int frequency,int smclkFrq){
  dcoFrq=frequency;
  this.smclkFrq=smclkFrq;
  lastVTime=getTime();
  lastCyclesTime=cycles;
  lastMicrosDelta=0;
  currentDCOFactor=1.0 * BasicClockModule.MAX_DCO_FRQ / frequency;
  if (DEBUG)   System.out.println(""String_Node_Str"" + smclkFrq);
  dcoReset();
}",0.977124183006536
5601,"public long stepMicros(long jumpMicros,long executeMicros) throws EmulationException {
  if (isRunning()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (jumpMicros < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + jumpMicros);
  }
  if (!microClockReady) {
    System.out.println(""String_Node_Str"" + cycles);
    lastMicrosCycles=cycles;
    microClockReady=true;
  }
  lastMicrosDelta+=jumpMicros;
  long maxCycles=lastMicrosCycles + (lastMicrosDelta * dcoFrq) / 1000000;
  if (cpuOff) {
    if (maxCycles > nextEventCycles) {
      lastMicrosDelta-=jumpMicros;
      throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
    }
  }
 else   if (maxCycles > cycles) {
    lastMicrosDelta-=jumpMicros;
    throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
  }
  maxCycles=lastMicrosCycles + ((lastMicrosDelta + executeMicros) * dcoFrq) / 1000000;
  System.out.println(""String_Node_Str"" + cycles + ""String_Node_Str""+ (jumpMicros)+ ""String_Node_Str""+ executeMicros+ ""String_Node_Str""+ maxCycles);
  if (debug) {
    if (servicedInterrupt >= 0) {
      disAsm.disassemble(reg[PC],memory,reg,servicedInterrupt);
    }
 else {
      disAsm.disassemble(reg[PC],memory,reg);
    }
  }
  boolean emuOP=false;
  if (maxCycles > 0) {
    while (cycles < maxCycles && !(emuOP=emulateOP(maxCycles))) {
    }
  }
  if (emuOP) {
    if ((instCtr % 10000007) == 0 && !debug) {
      printCPUSpeed(reg[PC]);
    }
    if (execCounter != null) {
      execCounter[reg[PC]]++;
    }
    if (trace != null) {
      trace[tracePos++]=reg[PC];
      if (tracePos > trace.length)       tracePos=0;
    }
  }
  if (cpuOff) {
    lastReturnedMicros=(1000000 * (nextEventCycles - cycles)) / dcoFrq;
  }
 else {
    lastReturnedMicros=0;
  }
  return lastReturnedMicros;
}","public long stepMicros(long jumpMicros,long executeMicros) throws EmulationException {
  if (isRunning()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (jumpMicros < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + jumpMicros);
  }
  if (!microClockReady) {
    System.out.println(""String_Node_Str"" + cycles);
    lastMicrosCycles=cycles;
    microClockReady=true;
  }
  lastMicrosDelta+=jumpMicros;
  long maxCycles=lastMicrosCycles + (lastMicrosDelta * dcoFrq) / 1000000;
  if (cpuOff) {
    if (maxCycles > nextEventCycles) {
      lastMicrosDelta-=jumpMicros;
      throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
    }
  }
 else   if (maxCycles > cycles) {
    lastMicrosDelta-=jumpMicros;
    throw new IllegalArgumentException(""String_Node_Str"" + maxCycles + ""String_Node_Str""+ cycles);
  }
  maxCycles=lastMicrosCycles + ((lastMicrosDelta + executeMicros) * dcoFrq) / 1000000;
  System.out.println(""String_Node_Str"" + cycles + ""String_Node_Str""+ (jumpMicros)+ ""String_Node_Str""+ executeMicros+ ""String_Node_Str""+ maxCycles);
  if (debug) {
    if (servicedInterrupt >= 0) {
      disAsm.disassemble(reg[PC],memory,reg,servicedInterrupt);
    }
 else {
      disAsm.disassemble(reg[PC],memory,reg);
    }
  }
  boolean emuOP=false;
  while (cycles < maxCycles) {
    if (emuOP=emulateOP(maxCycles)) {
      if (execCounter != null) {
        execCounter[reg[PC]]++;
      }
      if (trace != null) {
        trace[tracePos++]=reg[PC];
        if (tracePos > trace.length)         tracePos=0;
      }
    }
  }
  if (cpuOff) {
    lastReturnedMicros=(1000000 * (nextEventCycles - cycles)) / dcoFrq;
  }
 else {
    lastReturnedMicros=0;
  }
  return lastReturnedMicros;
}",0.8941565600882029
5602,"private void updateTCCTL(int cctl,long cycles){
  boolean input=false;
  if (inputSrc[cctl] == SRC_ACLK) {
    int aTicks=clockSpeed / core.aclkFrq;
    updateCounter(cycles);
    if (counter % aTicks > aTicks / 2) {
      input=true;
    }
  }
  tcctl[cctl]=(tcctl[cctl] & ~CC_I) | (input ? CC_I : 0);
}","private void updateTCCTL(int cctl,long cycles){
  boolean input=false;
  if (inputSrc[cctl] == SRC_ACLK) {
    int aTicks=clockSpeed / core.aclkFrq;
    updateCounter(cycles);
    if (aTicks > 0 && counter % aTicks > aTicks / 2) {
      input=true;
    }
  }
  tcctl[cctl]=(tcctl[cctl] & ~CC_I) | (input ? CC_I : 0);
}",0.977491961414791
5603,"public void setupCommands(final ComponentRegistry registry,CommandHandler handler){
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    private PrintStream out;
    private Pattern pattern;
    private boolean isInverted=false;
    public int executeCommand(    CommandContext context){
      int index=0;
      int flags=0;
      while (index + 1 < context.getArgumentCount()) {
        if (""String_Node_Str"".equals(context.getArgument(index))) {
          flags|=Pattern.CASE_INSENSITIVE;
        }
 else         if (""String_Node_Str"".equals(context.getArgument(index))) {
          isInverted=true;
        }
 else {
          context.err.println(""String_Node_Str"" + context.getArgument(index));
          return 1;
        }
        index++;
      }
      out=context.out;
      pattern=Pattern.compile(context.getArgument(index),flags);
      return 0;
    }
    public void lineRead(    String line){
      boolean isMatch=pattern.matcher(line).find();
      if (isMatch ^ isInverted) {
        out.println(line);
      }
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    private PrintStream out;
    private MSP430 cpu;
    long startTime;
    public int executeCommand(    CommandContext context){
      cpu=(MSP430)registry.getComponent(MSP430.class);
      if (cpu == null) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
      out=context.out;
      startTime=System.currentTimeMillis() - (long)cpu.getTimeMillis();
      return 0;
    }
    public void lineRead(    String line){
      out.println(Long.toString(startTime + (long)cpu.getTimeMillis()) + ' ' + line);
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      MSP430 cpu=(MSP430)registry.getComponent(MSP430.class);
      if (cpu == null) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
 else       if (context.getArgumentCount() == 0) {
        long rate=cpu.getSleepRate();
        double d=rate / 25000.0;
        context.out.println(""String_Node_Str"" + (((int)(d * 100 + 0.5)) / 100.0));
      }
 else {
        double d=context.getArgumentAsDouble(0);
        if (d > 0.0) {
          long rate=(long)(25000 * d);
          cpu.setSleepRate(rate);
        }
 else {
          context.err.println(""String_Node_Str"");
          return 1;
        }
      }
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      StringBuilder sb=new StringBuilder();
      for (int i=0, n=context.getArgumentCount(); i < n; i++) {
        if (i > 0)         sb.append(' ');
        sb.append(context.getArgument(i));
      }
      context.out.println(sb.toString());
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      boolean verbose=false;
      if (context.getArgumentCount() > 1) {
        verbose=""String_Node_Str"".equals(context.getArgument(0));
      }
      File fp=new File(context.getArgument(context.getArgumentCount() - 1));
      if (!fp.canRead()) {
        context.err.println(""String_Node_Str"" + context.getArgument(0) + ""String_Node_Str"");
        return 1;
      }
      try {
        FileInputStream infs=new FileInputStream(fp);
        BufferedReader input=new BufferedReader(new InputStreamReader(infs));
        try {
          String line;
          while ((line=input.readLine()) != null) {
            if (verbose)             context.out.println(line);
            context.executeCommand(line);
          }
        }
  finally {
          input.close();
        }
      }
 catch (      IOException e) {
        e.printStackTrace(context.err);
        return 1;
      }
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
    private MSP430 cpu;
    private int period=1;
    private int count=0;
    private int maxCount=-1;
    private String commandLine;
    private boolean isRunning=true;
    public int executeCommand(    final CommandContext context){
      int index=0;
      do {
        String a=context.getArgument(index);
        if (a.startsWith(""String_Node_Str"")) {
          if (a.equals(""String_Node_Str"")) {
            period=context.getArgumentAsInt(index + 1);
            index+=2;
          }
 else           if (a.equals(""String_Node_Str"")) {
            maxCount=context.getArgumentAsInt(index + 1);
            index+=2;
          }
 else {
            context.err.println(""String_Node_Str"" + a);
            return 1;
          }
        }
 else {
          break;
        }
      }
 while (true);
      if (index + 1 < context.getArgumentCount()) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
      commandLine=context.getArgument(index);
      cpu=(MSP430)registry.getComponent(MSP430.class);
      if (cpu == null) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
      cpu.scheduleTimeEventMillis(new TimeEvent(0){
        @Override public void execute(        long t){
          if (isRunning) {
            count++;
            context.executeCommand(commandLine);
            if ((maxCount <= 0) || (count < maxCount)) {
              cpu.scheduleTimeEventMillis(this,period * 1000d);
            }
 else {
              stopCommand(context);
            }
          }
        }
      }
,period * 1000d);
      return 0;
    }
    public void stopCommand(    CommandContext context){
      isRunning=false;
      context.err.println(""String_Node_Str"" + commandLine + ']');
      context.exit(0);
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new ExecCommand());
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    String command=null;
    CommandContext context;
    public int executeCommand(    CommandContext context){
      StringBuilder sb=new StringBuilder();
      for (int i=0, n=context.getArgumentCount(); i < n; i++) {
        if (i > 0)         sb.append(' ');
        sb.append(context.getArgument(i));
      }
      command=sb.toString();
      this.context=context;
      return 0;
    }
    public void lineRead(    String line){
      context.executeCommand(command);
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    @Override public int executeCommand(    CommandContext context){
      String className=context.getArgument(0);
      String name=className;
      if (context.getArgumentCount() > 1) {
        name=context.getArgument(1);
      }
      if (registry.getComponent(name) != null) {
        context.err.println(""String_Node_Str"" + name + ""String_Node_Str"");
        return 1;
      }
      Class pluginClass=null;
      PluginRepository plugins=(PluginRepository)registry.getComponent(""String_Node_Str"");
      try {
        try {
          pluginClass=plugins != null ? plugins.loadClass(className) : Class.forName(className);
        }
 catch (        ClassNotFoundException e) {
          String newClassName=""String_Node_Str"" + className;
          pluginClass=plugins != null ? plugins.loadClass(newClassName) : Class.forName(newClassName);
        }
        Object component=pluginClass.newInstance();
        registry.registerComponent(name,component);
        return 0;
      }
 catch (      Exception e1) {
        e1.printStackTrace(context.err);
      }
      return 1;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    @Override public int executeCommand(    CommandContext context){
      if (context.getArgumentCount() == 0) {
        ServiceComponent[] sc=(ServiceComponent[])registry.getAllComponents(ServiceComponent.class);
        for (int i=0; i < sc.length; i++) {
          context.out.printf(""String_Node_Str"",sc[i].getName(),sc[i].getStatus());
        }
      }
 else       if (context.getArgumentCount() == 1) {
        String name=context.getArgument(0);
        ServiceComponent sc=getServiceForName(registry,name);
        if (sc != null) {
          context.out.printf(""String_Node_Str"",sc.getName(),sc.getStatus());
        }
 else {
          context.out.println(""String_Node_Str"" + name);
        }
      }
 else {
        String name=context.getArgument(0);
        String operation=context.getArgument(1);
        if (""String_Node_Str"".equals(operation)) {
          ServiceComponent sc=getServiceForName(registry,name);
          if (sc != null) {
            sc.start();
            context.out.println(""String_Node_Str"" + sc.getName() + ""String_Node_Str"");
          }
 else {
            context.out.println(""String_Node_Str"" + name);
          }
        }
 else         if (""String_Node_Str"".equals(operation)) {
          ServiceComponent sc=getServiceForName(registry,name);
          if (sc != null) {
            sc.start();
            context.out.println(""String_Node_Str"" + sc.getName() + ""String_Node_Str"");
          }
 else {
            context.out.println(""String_Node_Str"" + name);
          }
        }
      }
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    CommandContext context;
    RFListener listener;
    final MSP430 cpu=(MSP430)registry.getComponent(MSP430.class);
    public int executeCommand(    CommandContext ctx){
      this.context=ctx;
      String inout=context.getArgument(0);
      Chip chip=cpu.getChip(context.getArgument(1));
      if (""String_Node_Str"".equals(inout)) {
        if (chip instanceof RFSource) {
          ((RFSource)chip).setRFListener(new RFListener(){
            public void receivedByte(            byte data){
              context.out.println(""String_Node_Str"" + Utils.hex8(data));
            }
          }
);
        }
      }
 else       if (""String_Node_Str"".equals(inout)) {
        listener=(RFListener)chip;
      }
 else {
        context.err.println(""String_Node_Str"" + inout);
      }
      return 0;
    }
    public void lineRead(    String line){
      if (listener != null) {
        byte[] data=Utils.hexconv(line);
        context.out.println(""String_Node_Str"" + line);
        for (int i=0; i < data.length; i++) {
          listener.receivedByte(data[i]);
        }
      }
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      ArgumentManager config=(ArgumentManager)registry.getComponent(""String_Node_Str"");
      context.out.println(""String_Node_Str"");
      context.out.println(""String_Node_Str"" + MSP430Constants.VERSION);
      context.out.println(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + ""String_Node_Str""+ System.getProperty(""String_Node_Str""));
      context.out.println(""String_Node_Str"" + config.getProperty(""String_Node_Str""));
      context.out.println(""String_Node_Str"" + config.getProperty(""String_Node_Str""));
      context.out.println();
      if (context.getOption(""String_Node_Str"")) {
        context.out.println(""String_Node_Str"");
        registry.printRegistry(context.out);
      }
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      System.exit(0);
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      System.exit(0);
      return 0;
    }
  }
);
}","public void setupCommands(final ComponentRegistry registry,CommandHandler handler){
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    private PrintStream out;
    private Pattern pattern;
    private boolean isInverted=false;
    public int executeCommand(    CommandContext context){
      int index=0;
      int flags=0;
      while (index + 1 < context.getArgumentCount()) {
        if (""String_Node_Str"".equals(context.getArgument(index))) {
          flags|=Pattern.CASE_INSENSITIVE;
        }
 else         if (""String_Node_Str"".equals(context.getArgument(index))) {
          isInverted=true;
        }
 else {
          context.err.println(""String_Node_Str"" + context.getArgument(index));
          return 1;
        }
        index++;
      }
      out=context.out;
      pattern=Pattern.compile(context.getArgument(index),flags);
      return 0;
    }
    public void lineRead(    String line){
      boolean isMatch=pattern.matcher(line).find();
      if (isMatch ^ isInverted) {
        out.println(line);
      }
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    private PrintStream out;
    private MSP430 cpu;
    long startTime;
    public int executeCommand(    CommandContext context){
      cpu=(MSP430)registry.getComponent(MSP430.class);
      if (cpu == null) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
      out=context.out;
      startTime=System.currentTimeMillis() - (long)cpu.getTimeMillis();
      return 0;
    }
    public void lineRead(    String line){
      out.println(Long.toString(startTime + (long)cpu.getTimeMillis()) + ' ' + line);
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      MSP430 cpu=(MSP430)registry.getComponent(MSP430.class);
      if (cpu == null) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
 else       if (context.getArgumentCount() == 0) {
        long rate=cpu.getSleepRate();
        double d=rate / 25000.0;
        context.out.println(""String_Node_Str"" + (((int)(d * 100 + 0.5)) / 100.0));
      }
 else {
        double d=context.getArgumentAsDouble(0);
        if (d > 0.0) {
          long rate=(long)(25000 * d);
          cpu.setSleepRate(rate);
        }
 else {
          context.err.println(""String_Node_Str"");
          return 1;
        }
      }
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      StringBuilder sb=new StringBuilder();
      for (int i=0, n=context.getArgumentCount(); i < n; i++) {
        if (i > 0)         sb.append(' ');
        sb.append(context.getArgument(i));
      }
      context.out.println(sb.toString());
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      boolean verbose=false;
      if (context.getArgumentCount() > 1) {
        verbose=""String_Node_Str"".equals(context.getArgument(0));
      }
      File fp=new File(context.getArgument(context.getArgumentCount() - 1));
      if (!fp.canRead()) {
        context.err.println(""String_Node_Str"" + context.getArgument(0) + ""String_Node_Str"");
        return 1;
      }
      try {
        FileInputStream infs=new FileInputStream(fp);
        BufferedReader input=new BufferedReader(new InputStreamReader(infs));
        try {
          String line;
          while ((line=input.readLine()) != null) {
            if (verbose)             context.out.println(line);
            context.executeCommand(line);
          }
        }
  finally {
          input.close();
        }
      }
 catch (      IOException e) {
        e.printStackTrace(context.err);
        return 1;
      }
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
    private MSP430 cpu;
    private int period=1;
    private int count=0;
    private int maxCount=-1;
    private String commandLine;
    private boolean isRunning=true;
    public int executeCommand(    final CommandContext context){
      int index=0;
      do {
        String a=context.getArgument(index);
        if (a.startsWith(""String_Node_Str"")) {
          if (a.equals(""String_Node_Str"")) {
            period=context.getArgumentAsInt(index + 1);
            index+=2;
          }
 else           if (a.equals(""String_Node_Str"")) {
            maxCount=context.getArgumentAsInt(index + 1);
            index+=2;
          }
 else {
            context.err.println(""String_Node_Str"" + a);
            return 1;
          }
        }
 else {
          break;
        }
      }
 while (true);
      if (index + 1 < context.getArgumentCount()) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
      commandLine=context.getArgument(index);
      cpu=(MSP430)registry.getComponent(MSP430.class);
      if (cpu == null) {
        context.err.println(""String_Node_Str"");
        return 1;
      }
      cpu.scheduleTimeEventMillis(new TimeEvent(0){
        @Override public void execute(        long t){
          if (isRunning) {
            count++;
            context.executeCommand(commandLine);
            if ((maxCount <= 0) || (count < maxCount)) {
              cpu.scheduleTimeEventMillis(this,period * 1000d);
            }
 else {
              stopCommand(context);
            }
          }
        }
      }
,period * 1000d);
      return 0;
    }
    public void stopCommand(    CommandContext context){
      isRunning=false;
      context.err.println(""String_Node_Str"" + commandLine + ']');
      context.exit(0);
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new ExecCommand());
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    String command=null;
    CommandContext context;
    public int executeCommand(    CommandContext context){
      StringBuilder sb=new StringBuilder();
      for (int i=0, n=context.getArgumentCount(); i < n; i++) {
        if (i > 0)         sb.append(' ');
        sb.append(context.getArgument(i));
      }
      command=sb.toString();
      this.context=context;
      return 0;
    }
    public void lineRead(    String line){
      context.executeCommand(command);
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    @Override public int executeCommand(    CommandContext context){
      String className=context.getArgument(0);
      String name=className;
      if (context.getArgumentCount() > 1) {
        name=context.getArgument(1);
      }
      if (registry.getComponent(name) != null) {
        context.err.println(""String_Node_Str"" + name + ""String_Node_Str"");
        return 1;
      }
      Class pluginClass=null;
      PluginRepository plugins=(PluginRepository)registry.getComponent(""String_Node_Str"");
      try {
        try {
          pluginClass=plugins != null ? plugins.loadClass(className) : Class.forName(className);
        }
 catch (        ClassNotFoundException e) {
          String newClassName=""String_Node_Str"" + className;
          pluginClass=plugins != null ? plugins.loadClass(newClassName) : Class.forName(newClassName);
        }
        Object component=pluginClass.newInstance();
        registry.registerComponent(name,component);
        return 0;
      }
 catch (      Exception e1) {
        e1.printStackTrace(context.err);
      }
      return 1;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    @Override public int executeCommand(    CommandContext context){
      if (context.getArgumentCount() == 0) {
        ServiceComponent[] sc=(ServiceComponent[])registry.getAllComponents(ServiceComponent.class);
        for (int i=0; i < sc.length; i++) {
          context.out.printf(""String_Node_Str"",sc[i].getName(),sc[i].getStatus());
        }
      }
 else       if (context.getArgumentCount() == 1) {
        String name=context.getArgument(0);
        ServiceComponent sc=getServiceForName(registry,name);
        if (sc != null) {
          context.out.printf(""String_Node_Str"",sc.getName(),sc.getStatus());
        }
 else {
          context.out.println(""String_Node_Str"" + name);
        }
      }
 else {
        String name=context.getArgument(0);
        String operation=context.getArgument(1);
        if (""String_Node_Str"".equals(operation)) {
          ServiceComponent sc=getServiceForName(registry,name);
          if (sc != null) {
            sc.start();
            context.out.println(""String_Node_Str"" + sc.getName() + ""String_Node_Str"");
          }
 else {
            context.out.println(""String_Node_Str"" + name);
          }
        }
 else         if (""String_Node_Str"".equals(operation)) {
          ServiceComponent sc=getServiceForName(registry,name);
          if (sc != null) {
            sc.stop();
            context.out.println(""String_Node_Str"" + sc.getName() + ""String_Node_Str"");
          }
 else {
            context.out.println(""String_Node_Str"" + name);
          }
        }
      }
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicLineCommand(""String_Node_Str"",""String_Node_Str""){
    CommandContext context;
    RFListener listener;
    final MSP430 cpu=(MSP430)registry.getComponent(MSP430.class);
    public int executeCommand(    CommandContext ctx){
      this.context=ctx;
      String inout=context.getArgument(0);
      Chip chip=cpu.getChip(context.getArgument(1));
      if (""String_Node_Str"".equals(inout)) {
        if (chip instanceof RFSource) {
          ((RFSource)chip).setRFListener(new RFListener(){
            public void receivedByte(            byte data){
              context.out.println(""String_Node_Str"" + Utils.hex8(data));
            }
          }
);
        }
      }
 else       if (""String_Node_Str"".equals(inout)) {
        listener=(RFListener)chip;
      }
 else {
        context.err.println(""String_Node_Str"" + inout);
      }
      return 0;
    }
    public void lineRead(    String line){
      if (listener != null) {
        byte[] data=Utils.hexconv(line);
        context.out.println(""String_Node_Str"" + line);
        for (int i=0; i < data.length; i++) {
          listener.receivedByte(data[i]);
        }
      }
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      ArgumentManager config=(ArgumentManager)registry.getComponent(""String_Node_Str"");
      context.out.println(""String_Node_Str"");
      context.out.println(""String_Node_Str"" + MSP430Constants.VERSION);
      context.out.println(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + ""String_Node_Str""+ System.getProperty(""String_Node_Str""));
      context.out.println(""String_Node_Str"" + config.getProperty(""String_Node_Str""));
      context.out.println(""String_Node_Str"" + config.getProperty(""String_Node_Str""));
      context.out.println();
      if (context.getOption(""String_Node_Str"")) {
        context.out.println(""String_Node_Str"");
        registry.printRegistry(context.out);
      }
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      System.exit(0);
      return 0;
    }
  }
);
  handler.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      System.exit(0);
      return 0;
    }
  }
);
}",0.9997911008982662
5604,"public void setupNode(){
  setupNodePorts();
  stats.addMonitor(this);
  stats.addMonitor(radio);
  stats.addMonitor(cpu);
  if (!config.getPropertyAsBoolean(""String_Node_Str"",true)) {
    gui=new ESBGui(this);
    DataChart dataChart=new DataChart(""String_Node_Str"",""String_Node_Str"");
    DataSourceSampler dss=dataChart.setupChipFrame(cpu);
    dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",TR1001.MODE_RX_ON));
    dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",TR1001.MODE_TXRX_ON));
    dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",MSP430.MODE_ACTIVE));
  }
}","public void setupNode(){
  setupNodePorts();
  stats.addMonitor(this);
  stats.addMonitor(radio);
  stats.addMonitor(cpu);
  if (!config.getPropertyAsBoolean(""String_Node_Str"",true)) {
    gui=new ESBGui(this);
    DataChart dataChart=new DataChart(registry,""String_Node_Str"",""String_Node_Str"");
    DataSourceSampler dss=dataChart.setupChipFrame(cpu);
    dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",TR1001.MODE_RX_ON));
    dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",TR1001.MODE_TXRX_ON));
    dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",MSP430.MODE_ACTIVE));
  }
}",0.9934162399414777
5605,"private void handlePendingConnections(){
  while (true) {
    TCPConnection connection=null;
synchronized (this) {
      while (pending.size() == 0)       try {
        System.out.println(""String_Node_Str"");
        wait();
        System.out.println(""String_Node_Str"");
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      connection=(TCPConnection)pending.firstElement();
      pending.removeElementAt(0);
    }
    InputStream input=connection.getInputStream();
    OutputStream output=connection.getOutputStream();
    connection.setTimeout(5000);
    try {
      System.out.println(""String_Node_Str"" + input);
      String reqLine=readLine(input);
      reqLine=reqLine.trim();
      int space=reqLine.indexOf(' ');
      if (space == -1) {
        return;
      }
      String method=reqLine.substring(0,space);
      String path=reqLine.substring(space + 1,reqLine.lastIndexOf(' '));
      System.out.println(""String_Node_Str"" + method);
      System.out.println(""String_Node_Str"" + path);
      int query=reqLine.indexOf('?');
      if (query > 0) {
        path=path.substring(0,query);
      }
      HttpServlet servlet=(HttpServlet)servlets.get(path);
      if (servlet == null) {
        output.write(""String_Node_Str"".getBytes());
        output.close();
        input.close();
        connection.close();
      }
 else {
        String line=null;
        while ((line=readLine(input)) != null) {
          line=line.trim();
          System.out.println(""String_Node_Str"" + line);
          if (line.length() == 0) {
            break;
          }
        }
        HttpServletRequest req=new HttpServletRequest(connection,method,path);
        HttpServletResponse resp=new HttpServletResponse(connection);
        servlet.service(req,resp);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
 finally {
      try {
        output.close();
      }
 catch (      IOException e) {
      }
      connection.close();
    }
  }
}","private void handlePendingConnections(){
  while (true) {
    TCPConnection connection=null;
synchronized (this) {
      while (pending.size() == 0)       try {
        System.out.println(""String_Node_Str"");
        status=""String_Node_Str"";
        wait();
        System.out.println(""String_Node_Str"");
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      status=""String_Node_Str"";
      connection=(TCPConnection)pending.firstElement();
      pending.removeElementAt(0);
    }
    InputStream input=connection.getInputStream();
    OutputStream output=connection.getOutputStream();
    connection.setTimeout(5000);
    try {
      System.out.println(""String_Node_Str"" + input);
      status=""String_Node_Str"";
      String reqLine=readLine(input);
      reqLine=reqLine.trim();
      if (!handleRequest(reqLine,input,output,connection)) {
        output.write(""String_Node_Str"".getBytes());
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
 finally {
      try {
        output.close();
        input.close();
      }
 catch (      IOException e) {
      }
      connection.close();
    }
  }
}",0.6326789107029765
5606,"public byte[] parseAddress(String addressStr){
  byte[] address=new byte[16];
  int hexVal=0;
  int pos=0;
  int splitPos=0;
  addressStr=addressStr.toLowerCase();
  for (int i=0; i < addressStr.length() && pos < 16; i++) {
    char c=addressStr.charAt(i);
    if (c == ':') {
      address[pos++]=(byte)(hexVal >> 8);
      address[pos++]=(byte)(hexVal & 0xff);
      if (i + 1 < addressStr.length() && addressStr.charAt(i + 1) == ':') {
        splitPos=pos;
      }
      hexVal=0;
    }
 else     if (c >= '0' && c <= '9') {
      hexVal=(hexVal << 4) + c - '0';
    }
 else     if (c >= 'a' && c <= 'f') {
      hexVal=(hexVal << 4) + c - 'a' + 10;
    }
  }
  if (splitPos != 0) {
  }
  return address;
}","public static byte[] parseAddress(String addressStr){
  byte[] address=new byte[16];
  int hexVal=0;
  int pos=0;
  int splitPos=0;
  addressStr=addressStr.toLowerCase();
  for (int i=0; i < addressStr.length() && pos < 16; i++) {
    char c=addressStr.charAt(i);
    if (c == ':') {
      address[pos++]=(byte)(hexVal >> 8);
      address[pos++]=(byte)(hexVal & 0xff);
      if (i + 1 < addressStr.length() && addressStr.charAt(i + 1) == ':') {
        splitPos=pos;
      }
      hexVal=0;
    }
 else     if (c >= '0' && c <= '9') {
      hexVal=(hexVal << 4) + c - '0';
    }
 else     if (c >= 'a' && c <= 'f') {
      hexVal=(hexVal << 4) + c - 'a' + 10;
    }
  }
  if (splitPos != 0) {
  }
  return address;
}",0.9950946040644708
5607,"public void write(int address,int data,boolean word,long cycles){
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ data+ ""String_Node_Str""+ word);
  }
  if (MSP430Constants.DEBUGGING_LEVEL > 0) {
    System.out.println(""String_Node_Str"" + Integer.toString(address,16) + ""String_Node_Str""+ data);
  }
switch (address) {
case MPY:
    op1=mpy=data;
  if (DEBUG)   System.out.println(getName() + ""String_Node_Str"" + data);
signed=false;
accumulating=false;
break;
case MPYS:
op1=mpys=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
signed=true;
accumulating=false;
break;
case MAC:
op1=mac=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
signed=false;
accumulating=true;
break;
case MACS:
op1=macs=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
signed=true;
accumulating=true;
break;
case RESLO:
resLo=data;
break;
case RESHI:
resHi=data;
break;
case OP2:
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
sumext=0;
op2=data;
if (signed) {
if (!word) {
if (op1 > 0x80) op1=op1 | 0xff00;
if (op2 > 0x80) op2=op2 | 0xff00;
}
op1=op1 > 0x8000 ? op1 - 0x10000 : op1;
op2=op2 > 0x8000 ? op2 - 0x10000 : op2;
}
long res=(long)op1 * (long)op2;
if (DEBUG) System.out.println(""String_Node_Str"" + op1 + ""String_Node_Str""+ op2+ ""String_Node_Str""+ res);
if (signed) {
sumext=res < 0 ? 0xffff : 0;
}
if (accumulating) {
res+=((long)resHi << 16) + resLo;
if (!signed && res > 0xffffffff) {
sumext=1;
}
}
resHi=(int)((res >> 16) & 0xffff);
resLo=(int)(res & 0xffff);
if (DEBUG) System.out.println(""String_Node_Str"" + res);
break;
}
}","public void write(int address,int data,boolean word,long cycles){
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ data+ ""String_Node_Str""+ word);
  }
  if (MSP430Constants.DEBUGGING_LEVEL > 0) {
    System.out.println(""String_Node_Str"" + Integer.toString(address,16) + ""String_Node_Str""+ data);
  }
switch (address) {
case MPY:
    op1=mpy=data;
  if (DEBUG)   System.out.println(getName() + ""String_Node_Str"" + data);
signed=false;
accumulating=false;
break;
case MPYS:
op1=mpys=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
signed=true;
accumulating=false;
break;
case MAC:
op1=mac=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
signed=false;
accumulating=true;
break;
case MACS:
op1=macs=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
signed=true;
accumulating=true;
break;
case RESLO:
resLo=data;
break;
case RESHI:
resHi=data;
break;
case OP2:
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
sumext=0;
op2=data;
if (signed) {
if (!word) {
if (op1 > 0x80) op1=op1 | 0xff00;
if (op2 > 0x80) op2=op2 | 0xff00;
}
op1=op1 > 0x8000 ? op1 - 0x10000 : op1;
op2=op2 > 0x8000 ? op2 - 0x10000 : op2;
}
long res=(long)op1 * (long)op2;
if (DEBUG) System.out.println(""String_Node_Str"" + op1 + ""String_Node_Str""+ op2+ ""String_Node_Str""+ res);
if (signed) {
sumext=res < 0 ? 0xffff : 0;
}
if (accumulating) {
res+=((long)resHi << 16) + resLo;
if (!signed) {
sumext=res > 0xffffffffL ? 1 : 0;
}
}
 else if (!signed) {
sumext=0;
}
resHi=(int)((res >> 16) & 0xffff);
resLo=(int)(res & 0xffff);
if (DEBUG) System.out.println(""String_Node_Str"" + res);
break;
}
}",0.9842776624147136
5608,"private int serviceInterrupt(int pc){
  int pcBefore=pc;
  int spBefore=readRegister(SP);
  int sp=spBefore;
  int sr=readRegister(SR);
  if (profiler != null) {
    profiler.profileInterrupt(interruptMax,cycles);
  }
  if (flash.blocksCPU()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (interruptMax < 15) {
    writeRegister(SP,sp=spBefore - 2);
    memory[sp]=pc & 0xff;
    memory[sp + 1]=(pc >> 8) & 0xff;
    writeRegister(SP,sp=sp - 2);
    memory[sp]=sr & 0xff;
    memory[sp + 1]=(sr >> 8) & 0xff;
  }
  writeRegister(PC,pc=memory[0xffe0 + interruptMax * 2] + (memory[0xffe0 + interruptMax * 2 + 1] << 8));
  writeRegister(SR,sr & ~CPUOFF & ~SCG1& ~OSCOFF);
  servicedInterrupt=interruptMax;
  servicedInterruptUnit=interruptSource[servicedInterrupt];
  reevaluateInterrupts();
  if (servicedInterrupt == 15) {
    internalReset();
  }
  cycles+=6;
  if (debugInterrupts) {
    System.out.println(""String_Node_Str"" + servicedInterrupt + ""String_Node_Str""+ pcBefore+ ""String_Node_Str""+ pc+ ""String_Node_Str""+ spBefore);
  }
  if (servicedInterruptUnit != null) {
    if (debugInterrupts) {
      System.out.println(""String_Node_Str"" + servicedInterruptUnit.getName());
    }
    servicedInterruptUnit.interruptServiced(servicedInterrupt);
  }
  return pc;
}","private int serviceInterrupt(int pc){
  int pcBefore=pc;
  int spBefore=readRegister(SP);
  int sp=spBefore;
  int sr=readRegister(SR);
  if (profiler != null) {
    profiler.profileInterrupt(interruptMax,cycles);
  }
  if (flash.blocksCPU()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (interruptMax < 15) {
    writeRegister(SP,sp=spBefore - 2);
    memory[sp]=pc & 0xff;
    memory[sp + 1]=(pc >> 8) & 0xff;
    writeRegister(SP,sp=sp - 2);
    memory[sp]=sr & 0xff;
    memory[sp + 1]=(sr >> 8) & 0xff;
  }
  writeRegister(SR,0);
  writeRegister(PC,pc=memory[0xffe0 + interruptMax * 2] + (memory[0xffe0 + interruptMax * 2 + 1] << 8));
  servicedInterrupt=interruptMax;
  servicedInterruptUnit=interruptSource[servicedInterrupt];
  reevaluateInterrupts();
  if (servicedInterrupt == 15) {
    internalReset();
  }
  cycles+=6;
  if (debugInterrupts) {
    System.out.println(""String_Node_Str"" + servicedInterrupt + ""String_Node_Str""+ pcBefore+ ""String_Node_Str""+ pc+ ""String_Node_Str""+ spBefore);
  }
  if (servicedInterruptUnit != null) {
    if (debugInterrupts) {
      System.out.println(""String_Node_Str"" + servicedInterruptUnit.getName());
    }
    servicedInterruptUnit.interruptServiced(servicedInterrupt);
  }
  return pc;
}",0.9709576138147566
5609,"synchronized void receive(TCPPacket tcpPacket){
  int plen=tcpPacket.payload == null ? 0 : tcpPacket.payload.length;
  if (tcpPacket.isAck()) {
    if (sentUnack < tcpPacket.ackNo && sendNext >= tcpPacket.ackNo) {
      int noAcked=tcpPacket.ackNo - sentUnack;
      sentUnack=tcpPacket.ackNo;
      bufPos+=noAcked;
      if (bufPos >= outgoingBuffer.length)       bufPos=0;
      System.out.println(""String_Node_Str"" + noAcked + ""String_Node_Str""+ bufPos+ ""String_Node_Str""+ bufNextEmpty+ ""String_Node_Str""+ Integer.toString(sentUnack & 0xffff,16)+ ""String_Node_Str""+ Integer.toString(sendNext & 0xffff,16));
      notify();
    }
 else {
      System.out.println(""String_Node_Str"" + Integer.toString(tcpPacket.ackNo & 0xffff,16) + ""String_Node_Str""+ Integer.toString(sendNext & 0xffff,16)+ ""String_Node_Str""+ Integer.toString(sentUnack & 0xffff,16));
      if (tcpPacket.ackNo == sentUnack) {
        resend();
      }
    }
  }
  if (receiveNext == tcpPacket.seqNo) {
  }
 else {
    System.out.println(""String_Node_Str"" + Integer.toString(receiveNext & 0xffff,16) + ""String_Node_Str""+ Integer.toString(tcpPacket.seqNo & 0xffff,16));
  }
  receiveNext=tcpPacket.seqNo + plen;
  if (tcpPacket.isFin()) {
    if (tcpListener != null && plen > 0) {
      tcpListener.connectionClosed(this);
    }
  }
  if (plen > 0) {
    TCPPacket tcpReply=TCPHandler.createAck(tcpPacket,0);
    tcpReply.ackNo=tcpPacket.seqNo + plen;
    tcpReply.seqNo=sendNext;
    send(tcpReply);
    if (tcpListener != null) {
      tcpListener.tcpDataReceived(this,tcpPacket);
    }
  }
}","synchronized void receive(TCPPacket tcpPacket){
  int plen=tcpPacket.payload == null ? 0 : tcpPacket.payload.length;
  if (tcpPacket.isAck()) {
    if (sentUnack < tcpPacket.ackNo && sendNext >= tcpPacket.ackNo) {
      int noAcked=tcpPacket.ackNo - sentUnack;
      sentUnack=tcpPacket.ackNo;
      bufPos+=noAcked;
      if (bufPos >= outgoingBuffer.length)       bufPos-=outgoingBuffer.length;
      System.out.println(""String_Node_Str"" + noAcked + ""String_Node_Str""+ bufPos+ ""String_Node_Str""+ bufNextEmpty+ ""String_Node_Str""+ Integer.toString(sentUnack & 0xffff,16)+ ""String_Node_Str""+ Integer.toString(sendNext & 0xffff,16)+ ""String_Node_Str""+ outSize()+ ""String_Node_Str""+ (sendNext - sentUnack));
      notify();
    }
 else {
      System.out.println(""String_Node_Str"" + Integer.toString(tcpPacket.ackNo & 0xffff,16) + ""String_Node_Str""+ Integer.toString(sendNext & 0xffff,16)+ ""String_Node_Str""+ Integer.toString(sentUnack & 0xffff,16));
      if (tcpPacket.ackNo == sentUnack) {
        resend();
      }
    }
  }
  if (receiveNext == tcpPacket.seqNo) {
  }
 else {
    System.out.println(""String_Node_Str"" + Integer.toString(receiveNext & 0xffff,16) + ""String_Node_Str""+ Integer.toString(tcpPacket.seqNo & 0xffff,16));
  }
  receiveNext=tcpPacket.seqNo + plen;
  if (tcpPacket.isFin()) {
    if (tcpListener != null && plen > 0) {
      tcpListener.connectionClosed(this);
    }
  }
  if (plen > 0) {
    TCPPacket tcpReply=TCPHandler.createAck(tcpPacket,0);
    tcpReply.ackNo=tcpPacket.seqNo + plen;
    tcpReply.seqNo=sendNext;
    send(tcpReply);
    if (tcpListener != null) {
      tcpListener.tcpDataReceived(this,tcpPacket);
    }
  }
}",0.9695652173913044
5610,"/** 
 * \brief check whether the 112-bit group-id of the multicast address is mappable to a 9-bit group-id It is true if the group is the all nodes or all routers group.
 */
public byte[] generatePacketData(IPv6Packet packet){
  int enc1=0, enc2=0;
  byte[] data=new byte[40 + 8];
  int pos=2;
  if (packet.flowLabel == 0) {
    enc1|=IPHC_VF_C;
  }
  if (packet.trafficClass == 0) {
    enc1|=IPHC_TC_C;
  }
  if ((enc1 & IPHC_VF_C) == 0) {
    pos+=writeVFlow(packet,data,pos);
  }
  if ((enc1 & IPHC_TC_C) == 0) {
    data[pos++]=(byte)(packet.trafficClass & 0xff);
  }
  if (packet.nextHeader == UDPPacket.DISPATCH) {
    enc1|=IPHC_NH_C;
  }
 else {
    data[pos++]=(byte)(packet.nextHeader & 0xff);
  }
switch (packet.hopLimit) {
case 1:
    enc1|=IPHC_TTL_1;
  break;
case 64:
enc1|=IPHC_TTL_64;
break;
case 255:
enc1|=IPHC_TTL_255;
break;
default :
data[pos++]=(byte)(packet.hopLimit & 0xff);
}
int context;
if ((context=lookupContext(packet.sourceAddress)) != -1) {
if (DEBUG) System.out.println(""String_Node_Str"" + context);
enc2|=context << 4;
if (packet.isSourceMACBased()) {
enc2|=IPHC_SAM_0;
}
 else if (is16bitCompressable(packet.sourceAddress)) {
enc2|=IPHC_SAM_16;
data[pos++]=packet.sourceAddress[14];
data[pos++]=packet.sourceAddress[15];
}
 else {
enc2|=IPHC_SAM_64;
System.arraycopy(packet.sourceAddress,8,data,pos,8);
pos+=8;
}
}
 else {
if (DEBUG) System.out.println(""String_Node_Str"");
enc2|=IPHC_SAM_I;
System.arraycopy(packet.sourceAddress,0,data,pos,16);
pos+=16;
}
IPv6Packet.printAddress(System.out,packet.destAddress);
if (packet.isMulticastDestination()) {
if (isMulticastCompressable(packet.destAddress)) {
enc2|=IPHC_DAM_16;
data[pos]=(byte)IPHC_MCAST_RANGE;
data[pos++]|=(packet.destAddress[1] & 0x0F) << 1;
data[pos++]=packet.destAddress[15];
}
 else {
enc2|=IPHC_DAM_I;
System.arraycopy(packet.destAddress,0,data,pos,16);
pos+=16;
}
}
 else {
if ((context=lookupContext(packet.destAddress)) != -1) {
if (DEBUG) System.out.println(""String_Node_Str"" + context);
enc2|=context;
if (packet.isDestinationMACBased()) {
enc2|=IPHC_DAM_0;
}
 else {
if (is16bitCompressable(packet.destAddress)) {
enc2|=IPHC_DAM_16;
data[pos++]=packet.destAddress[14];
data[pos++]=packet.destAddress[15];
}
 else {
enc2|=IPHC_DAM_64;
System.arraycopy(packet.destAddress,8,data,pos,8);
pos+=8;
}
}
}
 else {
if (DEBUG) System.out.println(""String_Node_Str"");
enc2|=IPHC_DAM_I;
System.arraycopy(packet.destAddress,0,data,pos,16);
pos+=16;
}
}
if (packet.nextHeader == UDPPacket.DISPATCH) {
UDPPacket udp=(UDPPacket)packet.getIPPayload();
if (udp.sourcePort >= UDP_PORT_MIN && udp.sourcePort < UDP_PORT_MAX && udp.destinationPort >= UDP_PORT_MIN && udp.destinationPort < UDP_PORT_MAX) {
data[pos++]=(byte)NHC_UDP_C;
data[pos++]=(byte)(((udp.sourcePort - UDP_PORT_MIN) << 4) + (udp.destinationPort - UDP_PORT_MIN));
int checksum=udp.doVirtualChecksum(packet);
data[pos++]=(byte)(checksum >> 8);
data[pos++]=(byte)(checksum & 0xff);
}
 else {
data[pos++]=(byte)NHC_UDP_I;
data[pos++]=(byte)(udp.sourcePort >> 8);
data[pos++]=(byte)(udp.sourcePort & 0xff);
data[pos++]=(byte)(udp.destinationPort >> 8);
data[pos++]=(byte)(udp.destinationPort & 0xff);
int checksum=udp.doVirtualChecksum(packet);
data[pos++]=(byte)(checksum >> 8);
data[pos++]=(byte)(checksum & 0xff);
}
}
data[0]=(byte)(enc1 & 0xff);
data[1]=(byte)(enc2 & 0xff);
if (DEBUG) System.out.println(""String_Node_Str"" + pos + ""String_Node_Str""+ Utils.hex8(enc1)+ ""String_Node_Str""+ Utils.hex8(enc2));
if (DEBUG) {
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.sourceAddress);
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.destAddress);
}
byte[] pload;
if (packet.nextHeader == UDPPacket.DISPATCH) {
UDPPacket udp=(UDPPacket)packet.getIPPayload();
pload=udp.payload;
}
 else {
IPPayload payload=packet.getIPPayload();
pload=payload.generatePacketData(packet);
}
if (DEBUG) System.out.println(""String_Node_Str"" + pload.length);
byte[] dataPacket=new byte[pos + pload.length];
System.arraycopy(data,0,dataPacket,0,pos);
System.arraycopy(pload,0,dataPacket,pos,pload.length);
return dataPacket;
}","/** 
 * \brief check whether the 112-bit group-id of the multicast address is mappable to a 9-bit group-id It is true if the group is the all nodes or all routers group.
 */
public byte[] generatePacketData(IPv6Packet packet){
  int enc1=0, enc2=0;
  byte[] data=new byte[40 + 8];
  int pos=2;
  if (packet.flowLabel == 0) {
    enc1|=IPHC_VF_C;
  }
  if (packet.trafficClass == 0) {
    enc1|=IPHC_TC_C;
  }
  if ((enc1 & IPHC_VF_C) == 0) {
    pos+=writeVFlow(packet,data,pos);
  }
  if ((enc1 & IPHC_TC_C) == 0) {
    data[pos++]=(byte)(packet.trafficClass & 0xff);
  }
  if (packet.nextHeader == UDPPacket.DISPATCH) {
    enc1|=IPHC_NH_C;
  }
 else {
    data[pos++]=(byte)(packet.nextHeader & 0xff);
  }
switch (packet.hopLimit) {
case 1:
    enc1|=IPHC_TTL_1;
  break;
case 64:
enc1|=IPHC_TTL_64;
break;
case 255:
enc1|=IPHC_TTL_255;
break;
default :
data[pos++]=(byte)(packet.hopLimit & 0xff);
}
int context;
if ((context=lookupContext(packet.sourceAddress)) != -1) {
if (DEBUG) System.out.println(""String_Node_Str"" + context);
enc2|=context << 4;
if (packet.isSourceMACBased()) {
enc2|=IPHC_SAM_0;
}
 else if (is16bitCompressable(packet.sourceAddress)) {
enc2|=IPHC_SAM_16;
data[pos++]=packet.sourceAddress[14];
data[pos++]=packet.sourceAddress[15];
}
 else {
enc2|=IPHC_SAM_64;
System.arraycopy(packet.sourceAddress,8,data,pos,8);
pos+=8;
}
}
 else {
if (DEBUG) System.out.println(""String_Node_Str"");
enc2|=IPHC_SAM_I;
System.arraycopy(packet.sourceAddress,0,data,pos,16);
pos+=16;
}
if (packet.isMulticastDestination()) {
if (isMulticastCompressable(packet.destAddress)) {
enc2|=IPHC_DAM_16;
data[pos]=(byte)IPHC_MCAST_RANGE;
data[pos++]|=(packet.destAddress[1] & 0x0F) << 1;
data[pos++]=packet.destAddress[15];
}
 else {
enc2|=IPHC_DAM_I;
System.arraycopy(packet.destAddress,0,data,pos,16);
pos+=16;
}
}
 else {
if ((context=lookupContext(packet.destAddress)) != -1) {
if (DEBUG) System.out.println(""String_Node_Str"" + context);
enc2|=context;
if (packet.isDestinationMACBased()) {
enc2|=IPHC_DAM_0;
}
 else {
if (is16bitCompressable(packet.destAddress)) {
enc2|=IPHC_DAM_16;
data[pos++]=packet.destAddress[14];
data[pos++]=packet.destAddress[15];
}
 else {
enc2|=IPHC_DAM_64;
System.arraycopy(packet.destAddress,8,data,pos,8);
pos+=8;
}
}
}
 else {
if (DEBUG) System.out.println(""String_Node_Str"");
enc2|=IPHC_DAM_I;
System.arraycopy(packet.destAddress,0,data,pos,16);
pos+=16;
}
}
if (packet.nextHeader == UDPPacket.DISPATCH) {
UDPPacket udp=(UDPPacket)packet.getIPPayload();
if (udp.sourcePort >= UDP_PORT_MIN && udp.sourcePort < UDP_PORT_MAX && udp.destinationPort >= UDP_PORT_MIN && udp.destinationPort < UDP_PORT_MAX) {
data[pos++]=(byte)NHC_UDP_C;
data[pos++]=(byte)(((udp.sourcePort - UDP_PORT_MIN) << 4) + (udp.destinationPort - UDP_PORT_MIN));
int checksum=udp.doVirtualChecksum(packet);
data[pos++]=(byte)(checksum >> 8);
data[pos++]=(byte)(checksum & 0xff);
}
 else {
data[pos++]=(byte)NHC_UDP_I;
data[pos++]=(byte)(udp.sourcePort >> 8);
data[pos++]=(byte)(udp.sourcePort & 0xff);
data[pos++]=(byte)(udp.destinationPort >> 8);
data[pos++]=(byte)(udp.destinationPort & 0xff);
int checksum=udp.doVirtualChecksum(packet);
data[pos++]=(byte)(checksum >> 8);
data[pos++]=(byte)(checksum & 0xff);
}
}
data[0]=(byte)(enc1 & 0xff);
data[1]=(byte)(enc2 & 0xff);
if (DEBUG) System.out.println(""String_Node_Str"" + pos + ""String_Node_Str""+ Utils.hex8(enc1)+ ""String_Node_Str""+ Utils.hex8(enc2));
if (DEBUG) {
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.sourceAddress);
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.destAddress);
}
byte[] pload;
if (packet.nextHeader == UDPPacket.DISPATCH) {
UDPPacket udp=(UDPPacket)packet.getIPPayload();
pload=udp.payload;
}
 else {
IPPayload payload=packet.getIPPayload();
pload=payload.generatePacketData(packet);
}
if (DEBUG) System.out.println(""String_Node_Str"" + pload.length);
byte[] dataPacket=new byte[pos + pload.length];
System.arraycopy(data,0,dataPacket,0,pos);
System.arraycopy(pload,0,dataPacket,pos,pload.length);
return dataPacket;
}",0.9931573802541545
5611,"private boolean isForMe(byte[] address){
  IPv6Packet.printAddress(System.out,address);
  if (Utils.equals(myIPAddress,address) || Utils.equals(myLocalIPAddress,address) || Utils.equals(myLocalSolicited,address))   return true;
  if (isRouter && Utils.equals(ALL_ROUTERS,address))   return true;
  if (Utils.equals(ALL_NODES,address))   return true;
  if (Utils.equals(UNSPECIFIED,address))   return true;
  return false;
}","private boolean isForMe(byte[] address){
  if (Utils.equals(myIPAddress,address) || Utils.equals(myLocalIPAddress,address) || Utils.equals(myLocalSolicited,address))   return true;
  if (isRouter && Utils.equals(ALL_ROUTERS,address))   return true;
  if (Utils.equals(ALL_NODES,address))   return true;
  if (Utils.equals(UNSPECIFIED,address))   return true;
  return false;
}",0.9411764705882352
5612,"void receive(TCPPacket tcpPacket){
  int plen=tcpPacket.payload == null ? 0 : tcpPacket.payload.length;
  receiveNext=tcpPacket.seqNo + plen;
  if (tcpPacket.isAck()) {
    if (sendNext == tcpPacket.ackNo) {
      sentUnack=tcpPacket.ackNo;
    }
 else {
      System.out.println(""String_Node_Str"" + Integer.toString(tcpPacket.ackNo,16) + ""String_Node_Str""+ Integer.toString(sendNext,16));
    }
  }
  if (receiveNext == tcpPacket.seqNo) {
  }
 else {
    System.out.println(""String_Node_Str"" + receiveNext + ""String_Node_Str""+ tcpPacket.seqNo);
  }
  if (tcpPacket.isFin()) {
    if (tcpListener != null && plen > 0) {
      tcpListener.connectionClosed(this);
    }
  }
  TCPPacket tcpReply=TCPHandler.createAck(tcpPacket,0);
  tcpReply.ackNo=tcpPacket.seqNo + plen;
  tcpReply.seqNo=sendNext;
  send(tcpReply);
  if (plen > 0)   if (tcpListener != null) {
    tcpListener.tcpDataReceived(this,tcpPacket);
  }
}","void receive(TCPPacket tcpPacket){
  int plen=tcpPacket.payload == null ? 0 : tcpPacket.payload.length;
  if (tcpPacket.isAck()) {
    if (sendNext == tcpPacket.ackNo) {
      sentUnack=tcpPacket.ackNo;
    }
 else {
      System.out.println(""String_Node_Str"" + Integer.toString(tcpPacket.ackNo,16) + ""String_Node_Str""+ Integer.toString(sendNext,16));
    }
  }
  if (receiveNext == tcpPacket.seqNo) {
  }
 else {
    System.out.println(""String_Node_Str"" + Integer.toString(receiveNext,16) + ""String_Node_Str""+ Integer.toString(tcpPacket.seqNo,16));
  }
  receiveNext=tcpPacket.seqNo + plen;
  if (tcpPacket.isFin()) {
    if (tcpListener != null && plen > 0) {
      tcpListener.connectionClosed(this);
    }
  }
  TCPPacket tcpReply=TCPHandler.createAck(tcpPacket,0);
  tcpReply.ackNo=tcpPacket.seqNo + plen;
  tcpReply.seqNo=sendNext;
  send(tcpReply);
  if (plen > 0)   if (tcpListener != null) {
    tcpListener.tcpDataReceived(this,tcpPacket);
  }
}",0.936830835117773
5613,"public void handlePacket(IPv6Packet packet){
  TCPPacket tcpPacket=(TCPPacket)packet.getIPPayload();
  TCPConnection connection=findConnection(packet,tcpPacket);
  if (connection == null) {
    connection=findListenConnection(packet,tcpPacket);
    if (connection == null) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      if ((tcpPacket.flags & TCPPacket.SYN) > 0) {
        TCPPacket tcpReply=createAck(tcpPacket,TCPPacket.SYN);
        TCPConnection tc=new TCPConnection(ipStack,packet.netInterface);
        tc.externalIP=packet.sourceAddress;
        tc.externalPort=tcpPacket.sourcePort;
        tc.localIP=ipStack.myIPAddress;
        tc.localPort=tcpPacket.destinationPort;
        tc.state=TCPConnection.SYN_RECEIVED;
        tc.receiveNext=tcpPacket.seqNo + 1;
        tc.sentUnack=tc.sendNext=tcpReply.seqNo=(int)(System.currentTimeMillis() * 7);
        addConnection(tc);
        tcpReply.ackNo=tcpPacket.seqNo + 1;
        System.out.println(""String_Node_Str"" + tcpReply);
        tc.send(tcpReply);
        tc.sentUnack=tc.sendNext=tc.sendNext + 1;
        connection.newConnection(tc);
      }
    }
  }
 else {
    System.out.println(""String_Node_Str"");
switch (connection.state) {
case TCPConnection.SYN_RECEIVED:
      if (tcpPacket.isAck()) {
        System.out.println(""String_Node_Str"");
        connection.state=TCPConnection.ESTABLISHED;
      }
    break;
case TCPConnection.ESTABLISHED:
  if (tcpPacket.isAck() && (tcpPacket.payload == null || tcpPacket.payload.length == 0)) {
    return;
  }
if (tcpPacket.isFin()) {
  connection.state=TCPConnection.CLOSE_WAIT;
}
connection.receive(tcpPacket);
break;
case TCPConnection.LAST_ACK:
if (tcpPacket.isAck()) {
connection.state=TCPConnection.CLOSED;
}
break;
case TCPConnection.FIN_WAIT_1:
if (tcpPacket.isAck()) {
connection.state=TCPConnection.FIN_WAIT_2;
}
break;
case TCPConnection.FIN_WAIT_2:
if (tcpPacket.isFin()) {
System.out.println(""String_Node_Str"");
connection.state=TCPConnection.TIME_WAIT;
connection.lastSendTime=System.currentTimeMillis();
}
break;
case TCPConnection.CLOSE_WAIT:
break;
}
}
}","public void handlePacket(IPv6Packet packet){
  TCPPacket tcpPacket=(TCPPacket)packet.getIPPayload();
  TCPConnection connection=findConnection(packet,tcpPacket);
  if (connection == null) {
    connection=findListenConnection(packet,tcpPacket);
    if (connection == null) {
      System.out.println(""String_Node_Str"");
    }
 else {
      if ((tcpPacket.flags & TCPPacket.SYN) > 0) {
        TCPPacket tcpReply=createAck(tcpPacket,TCPPacket.SYN);
        TCPConnection tc=new TCPConnection(ipStack,packet.netInterface);
        tc.externalIP=packet.sourceAddress;
        tc.externalPort=tcpPacket.sourcePort;
        tc.localIP=ipStack.myIPAddress;
        tc.localPort=tcpPacket.destinationPort;
        tc.state=TCPConnection.SYN_RECEIVED;
        tc.receiveNext=tcpPacket.seqNo + 1;
        tc.sentUnack=tc.sendNext=tcpReply.seqNo=(int)(System.currentTimeMillis() * 7);
        addConnection(tc);
        tcpReply.ackNo=tcpPacket.seqNo + 1;
        tc.send(tcpReply);
        tc.sentUnack=tc.sendNext=tc.sendNext + 1;
        connection.newConnection(tc);
      }
    }
  }
 else {
switch (connection.state) {
case TCPConnection.SYN_RECEIVED:
      if (tcpPacket.isAck()) {
        System.out.println(""String_Node_Str"");
        connection.state=TCPConnection.ESTABLISHED;
      }
    break;
case TCPConnection.ESTABLISHED:
  if (tcpPacket.isAck() && (tcpPacket.payload == null || tcpPacket.payload.length == 0)) {
    return;
  }
if (tcpPacket.isFin()) {
  connection.state=TCPConnection.CLOSE_WAIT;
}
connection.receive(tcpPacket);
break;
case TCPConnection.LAST_ACK:
if (tcpPacket.isAck()) {
connection.state=TCPConnection.CLOSED;
}
break;
case TCPConnection.FIN_WAIT_1:
if (tcpPacket.isAck()) {
connection.state=TCPConnection.FIN_WAIT_2;
}
break;
case TCPConnection.FIN_WAIT_2:
if (tcpPacket.isFin()) {
System.out.println(""String_Node_Str"");
connection.state=TCPConnection.TIME_WAIT;
connection.lastSendTime=System.currentTimeMillis();
}
break;
case TCPConnection.CLOSE_WAIT:
break;
}
}
}",0.9352657004830918
5614,"public int read() throws IOException {
  if (closed) {
    return -1;
  }
  if (firstByte == nextEmpty) {
    System.out.println(""String_Node_Str"");
synchronized (this) {
      try {
        wait();
        System.out.println(""String_Node_Str"" + available());
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
  if (!closed) {
    int data=inputBuffer[firstByte++];
    if (firstByte >= inputBuffer.length)     firstByte=0;
    return (data & 0xff);
  }
 else {
    return -1;
  }
}","public int read() throws IOException {
  if (closed) {
    return -1;
  }
  if (firstByte == nextEmpty) {
synchronized (this) {
      try {
        wait();
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
  if (!closed) {
    int data=inputBuffer[firstByte++];
    if (firstByte >= inputBuffer.length)     firstByte=0;
    return (data & 0xff);
  }
 else {
    return -1;
  }
}",0.8905263157894737
5615,"public void tcpDataReceived(TCPConnection source,TCPPacket packet){
  System.out.println(""String_Node_Str"");
  byte[] payload=packet.payload;
  if (payload == null || payload.length == 0)   return;
  int pos=0;
  if (inputBuffer.length - available() > payload.length) {
    while (pos < payload.length) {
      inputBuffer[nextEmpty++]=payload[pos++];
      if (nextEmpty >= inputBuffer.length) {
        nextEmpty=0;
      }
    }
    notifyReader();
  }
 else {
    System.out.println(""String_Node_Str"");
  }
}","public void tcpDataReceived(TCPConnection source,TCPPacket packet){
  byte[] payload=packet.payload;
  if (payload == null || payload.length == 0)   return;
  int pos=0;
  if (inputBuffer.length - available() > payload.length) {
    while (pos < payload.length) {
      inputBuffer[nextEmpty++]=payload[pos++];
      if (nextEmpty >= inputBuffer.length) {
        nextEmpty=0;
      }
    }
    notifyReader();
  }
 else {
    System.out.println(""String_Node_Str"");
  }
}",0.958290946083418
5616,"public synchronized void flush() throws IOException {
  System.out.println(""String_Node_Str"");
  byte[] buffer=new byte[pos];
  for (int i=0; i < pos; i++) {
    buffer[i]=output[i];
  }
  pos=0;
  connection.send(buffer);
}","public synchronized void flush() throws IOException {
  byte[] buffer=new byte[pos];
  for (int i=0; i < pos; i++) {
    buffer[i]=output[i];
  }
  pos=0;
  connection.send(buffer);
}",0.8992628992628993
5617,"public void printPacket(PrintStream out){
  out.println(""String_Node_Str"" + sourcePort + ""String_Node_Str""+ destinationPort+ ""String_Node_Str""+ Utils.hex8(flags));
  out.println(""String_Node_Str"" + seqNo + ""String_Node_Str""+ ackNo);
  if (payload != null) {
    for (int i=0; i < payload.length; i++) {
      out.print((char)payload[i]);
    }
    System.out.println();
  }
}","public void printPacket(PrintStream out){
  out.print(""String_Node_Str"" + sourcePort + ""String_Node_Str""+ destinationPort+ ""String_Node_Str""+ Utils.hex8(flags)+ ""String_Node_Str""+ Integer.toString(seqNo,16)+ ""String_Node_Str""+ Integer.toString(ackNo,16));
  if (payload != null) {
    System.out.print(""String_Node_Str"");
    int len=8;
    if (payload.length < len)     len=payload.length;
    for (int i=0; i < len; i++) {
      out.print((char)payload[i]);
    }
  }
  System.out.println(""String_Node_Str"");
}",0.6606538895152199
5618,"private void programPage(){
  writeStatus(0.64);
  ensureLoaded(blockWriteAddress);
  for (int i=0; i < readMemory.length; i++) {
    readMemory[i]&=buffer[i];
  }
  writeBack(blockWriteAddress,readMemory);
}","private void programPage(){
  if (writing)   System.out.println(""String_Node_Str"" + cpu.getPC());
  writeStatus(PROGRAM_PAGE_MILLIS);
  ensureLoaded(blockWriteAddress);
  for (int i=0; i < readMemory.length; i++) {
    readMemory[i]&=buffer[i];
  }
  writeBack(blockWriteAddress,readMemory);
}",0.782435129740519
5619,"public void dataReceived(USART source,int data){
  if (chipSelect) {
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + data);
    }
switch (state) {
case READ_IDENT:
      source.byteReceived(identity[pos]);
    pos++;
  if (pos >= identity.length) {
    pos=0;
  }
return;
case WRITE_STATUS:
status=data;
source.byteReceived(0);
return;
case READ_DATA:
if (pos < 3) {
readAddress=(readAddress << 8) + data;
source.byteReceived(0);
pos++;
if (DEBUG && pos == 3) {
System.out.println(""String_Node_Str"" + Integer.toHexString(readAddress));
}
}
 else {
source.byteReceived(readMemory(readAddress++));
if (readAddress > 0xfffff) {
readAddress=0;
}
}
return;
case SECTOR_ERASE:
if (pos < 3) {
readAddress=(readAddress << 8) + data;
source.byteReceived(0);
pos++;
if (pos == 3) {
sectorErase(readAddress);
}
}
return;
case PAGE_PROGRAM:
if (pos < 3) {
readAddress=(readAddress << 8) + data;
source.byteReceived(0);
pos++;
if (pos == 3) {
for (int i=0; i < buffer.length; i++) {
buffer[i]=(byte)0xff;
}
blockWriteAddress=readAddress & 0xfff00;
if (DEBUG) {
System.out.println(""String_Node_Str"" + Integer.toHexString(readAddress));
}
}
}
 else {
source.byteReceived(0);
writeBuffer((readAddress++) & 0xff,data);
}
return;
}
if (DEBUG) {
System.out.println(""String_Node_Str"" + data);
}
switch (data) {
case WRITE_ENABLE:
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
writeEnable=true;
break;
case WRITE_DISABLE:
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
writeEnable=false;
break;
case READ_IDENT:
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
state=READ_IDENT;
pos=0;
source.byteReceived(identity[pos++]);
return;
case READ_STATUS:
status=(status & (0xff - 1 - 2)) | (writeEnable ? 0x02 : 0x00) | (writing ? 0x01 : 0x00);
source.byteReceived(status);
if (DEBUG) {
System.out.println(""String_Node_Str"" + status);
}
return;
case WRITE_STATUS:
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
state=WRITE_STATUS;
break;
case READ_DATA:
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
state=READ_DATA;
pos=readAddress=0;
break;
case PAGE_PROGRAM:
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
state=PAGE_PROGRAM;
pos=readAddress=0;
break;
case SECTOR_ERASE:
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
state=SECTOR_ERASE;
pos=0;
break;
case BULK_ERASE:
System.out.println(""String_Node_Str"");
break;
}
source.byteReceived(0);
}
}","public void dataReceived(USART source,int data){
  if (chipSelect) {
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + data);
    }
switch (state) {
case READ_STATUS:
      source.byteReceived(status);
    return;
case READ_IDENT:
  source.byteReceived(identity[pos]);
pos++;
if (pos >= identity.length) {
pos=0;
}
return;
case WRITE_STATUS:
status=data;
source.byteReceived(0);
return;
case READ_DATA:
if (pos < 3) {
readAddress=(readAddress << 8) + data;
source.byteReceived(0);
pos++;
if (DEBUG && pos == 3) {
System.out.println(""String_Node_Str"" + Integer.toHexString(readAddress));
}
}
 else {
source.byteReceived(readMemory(readAddress++));
if (readAddress > 0xfffff) {
readAddress=0;
}
}
return;
case SECTOR_ERASE:
if (pos < 3) {
readAddress=(readAddress << 8) + data;
source.byteReceived(0);
pos++;
if (pos == 3) {
sectorErase(readAddress);
}
}
return;
case PAGE_PROGRAM:
if (pos < 3) {
readAddress=(readAddress << 8) + data;
source.byteReceived(0);
pos++;
if (pos == 3) {
for (int i=0; i < buffer.length; i++) {
buffer[i]=(byte)0xff;
}
blockWriteAddress=readAddress & 0xfff00;
if (DEBUG) {
System.out.println(""String_Node_Str"" + Integer.toHexString(readAddress));
}
}
}
 else {
source.byteReceived(0);
writeBuffer((readAddress++) & 0xff,data);
}
return;
}
if (DEBUG) {
System.out.println(""String_Node_Str"" + data);
}
switch (data) {
case WRITE_ENABLE:
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
writeEnable=true;
break;
case WRITE_DISABLE:
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
writeEnable=false;
break;
case READ_IDENT:
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
state=READ_IDENT;
pos=0;
source.byteReceived(0);
return;
case READ_STATUS:
status=(status & (0xff - 1 - 2)) | (writeEnable ? 0x02 : 0x00) | (writing ? 0x01 : 0x00);
state=READ_STATUS;
source.byteReceived(0);
if (DEBUG) {
System.out.println(""String_Node_Str"" + status + ""String_Node_Str""+ cpu.getPC());
}
return;
case WRITE_STATUS:
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
state=WRITE_STATUS;
break;
case READ_DATA:
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
state=READ_DATA;
pos=readAddress=0;
break;
case PAGE_PROGRAM:
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
state=PAGE_PROGRAM;
pos=readAddress=0;
break;
case SECTOR_ERASE:
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
state=SECTOR_ERASE;
pos=0;
break;
case BULK_ERASE:
System.out.println(""String_Node_Str"");
break;
}
source.byteReceived(0);
}
}",0.9649484536082474
5620,"private void sectorErase(int address){
  writeStatus(600);
  int sectorAddress=address & 0xf0000;
  loadedAddress=-1;
  for (int i=0; i < buffer.length; i++) {
    buffer[i]=(byte)0xff;
  }
  blockWriteAddress=sectorAddress;
  for (int i=0; i < 0x100; i++) {
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + Integer.toHexString(blockWriteAddress));
    }
    writeBack(blockWriteAddress,buffer);
    blockWriteAddress+=0x100;
  }
}","private void sectorErase(int address){
  writeStatus(SECTOR_ERASE_MILLIS);
  int sectorAddress=address & 0xf0000;
  loadedAddress=-1;
  for (int i=0; i < buffer.length; i++) {
    buffer[i]=(byte)0xff;
  }
  blockWriteAddress=sectorAddress;
  for (int i=0; i < 0x100; i++) {
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + Integer.toHexString(blockWriteAddress));
    }
    writeBack(blockWriteAddress,buffer);
    blockWriteAddress+=0x100;
  }
}",0.9756637168141592
5621,"private void handlePendingConnections(){
  while (true) {
    TCPConnection connection=null;
synchronized (this) {
      while (pending.size() == 0)       try {
        System.out.println(""String_Node_Str"");
        wait();
        System.out.println(""String_Node_Str"");
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      connection=(TCPConnection)pending.firstElement();
      pending.removeElementAt(0);
    }
    InputStream input=connection.getInputStream();
    OutputStream output=connection.getOutputStream();
    try {
      System.out.println(""String_Node_Str"" + input);
      String reqLine=readLine(input);
      reqLine=reqLine.trim();
      int space=reqLine.indexOf(' ');
      String method=reqLine.substring(0,space);
      String path=reqLine.substring(space + 1,reqLine.lastIndexOf(' '));
      System.out.println(""String_Node_Str"" + method);
      System.out.println(""String_Node_Str"" + path);
      int query=reqLine.indexOf('?');
      if (query > 0) {
        path=path.substring(0,query);
      }
      HttpServlet servlet=(HttpServlet)servlets.get(path);
      if (servlet == null) {
        output.write(""String_Node_Str"".getBytes());
        output.close();
        input.close();
        connection.close();
      }
 else {
        String line=null;
        while ((line=readLine(input)) != null) {
          line=line.trim();
          System.out.println(""String_Node_Str"" + line);
          if (line.length() == 0) {
            break;
          }
        }
        HttpServletRequest req=new HttpServletRequest(connection,method,path);
        HttpServletResponse resp=new HttpServletResponse(connection);
        servlet.service(req,resp);
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
 finally {
      try {
        output.close();
      }
 catch (      IOException e) {
      }
      connection.close();
    }
  }
}","private void handlePendingConnections(){
  while (true) {
    TCPConnection connection=null;
synchronized (this) {
      while (pending.size() == 0)       try {
        System.out.println(""String_Node_Str"");
        wait();
        System.out.println(""String_Node_Str"");
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      connection=(TCPConnection)pending.firstElement();
      pending.removeElementAt(0);
    }
    InputStream input=connection.getInputStream();
    OutputStream output=connection.getOutputStream();
    connection.setTimeout(5000);
    try {
      System.out.println(""String_Node_Str"" + input);
      String reqLine=readLine(input);
      reqLine=reqLine.trim();
      int space=reqLine.indexOf(' ');
      if (space == -1) {
        return;
      }
      String method=reqLine.substring(0,space);
      String path=reqLine.substring(space + 1,reqLine.lastIndexOf(' '));
      System.out.println(""String_Node_Str"" + method);
      System.out.println(""String_Node_Str"" + path);
      int query=reqLine.indexOf('?');
      if (query > 0) {
        path=path.substring(0,query);
      }
      HttpServlet servlet=(HttpServlet)servlets.get(path);
      if (servlet == null) {
        output.write(""String_Node_Str"".getBytes());
        output.close();
        input.close();
        connection.close();
      }
 else {
        String line=null;
        while ((line=readLine(input)) != null) {
          line=line.trim();
          System.out.println(""String_Node_Str"" + line);
          if (line.length() == 0) {
            break;
          }
        }
        HttpServletRequest req=new HttpServletRequest(connection,method,path);
        HttpServletResponse resp=new HttpServletResponse(connection);
        servlet.service(req,resp);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
 finally {
      try {
        output.close();
      }
 catch (      IOException e) {
      }
      connection.close();
    }
  }
}",0.906026557711951
5622,"synchronized void receive(TCPPacket tcpPacket){
  int plen=tcpPacket.payload == null ? 0 : tcpPacket.payload.length;
  if (tcpPacket.isAck()) {
    if (sentUnack <= tcpPacket.ackNo && sendNext >= tcpPacket.ackNo) {
      int noAcked=tcpPacket.ackNo - sentUnack;
      sentUnack=tcpPacket.ackNo;
      bufPos+=noAcked;
      if (bufPos >= outgoingBuffer.length)       bufPos-=outgoingBuffer.length;
      System.out.println(""String_Node_Str"" + noAcked + ""String_Node_Str""+ bufPos+ ""String_Node_Str""+ bufNextEmpty+ ""String_Node_Str""+ Integer.toString(sentUnack & 0xffff,16)+ ""String_Node_Str""+ Integer.toString(sendNext & 0xffff,16)+ ""String_Node_Str""+ outSize()+ ""String_Node_Str""+ (sendNext - sentUnack)+ ""String_Node_Str""+ plen);
      notify();
      if (closing && sentUnack == sendNext) {
        sendFIN();
      }
    }
 else {
      System.out.println(""String_Node_Str"" + Integer.toString(tcpPacket.ackNo & 0xffff,16) + ""String_Node_Str""+ Integer.toString(sendNext & 0xffff,16)+ ""String_Node_Str""+ Integer.toString(sentUnack & 0xffff,16));
      if (tcpPacket.ackNo == sentUnack) {
        resend();
      }
    }
  }
  if (receiveNext == tcpPacket.seqNo) {
    receiveNext=tcpPacket.seqNo + plen;
    if (plen > 0) {
      sendAck(tcpPacket);
      if (tcpListener != null) {
        tcpListener.tcpDataReceived(this,tcpPacket);
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
 else {
    System.out.println(""String_Node_Str"" + Integer.toString(receiveNext & 0xffff,16) + ""String_Node_Str""+ Integer.toString(tcpPacket.seqNo & 0xffff,16));
    sendAck(tcpPacket);
  }
  if (tcpPacket.isFin()) {
    if (plen == 0) {
      sendAck(tcpPacket);
    }
    if (tcpListener != null && plen > 0) {
      tcpListener.connectionClosed(this);
    }
  }
}","synchronized void receive(TCPPacket tcpPacket){
  int plen=tcpPacket.payload == null ? 0 : tcpPacket.payload.length;
  if (tcpPacket.isAck()) {
    if (sentUnack <= tcpPacket.ackNo && sendNext >= tcpPacket.ackNo) {
      int noAcked=tcpPacket.ackNo - sentUnack;
      sentUnack=tcpPacket.ackNo;
      bufPos+=noAcked;
      if (bufPos >= outgoingBuffer.length)       bufPos-=outgoingBuffer.length;
      System.out.println(""String_Node_Str"" + noAcked + ""String_Node_Str""+ bufPos+ ""String_Node_Str""+ bufNextEmpty+ ""String_Node_Str""+ Integer.toString(sentUnack & 0xffff,16)+ ""String_Node_Str""+ Integer.toString(sendNext & 0xffff,16)+ ""String_Node_Str""+ outSize()+ ""String_Node_Str""+ (sendNext - sentUnack)+ ""String_Node_Str""+ plen);
      notify();
      if (state == ESTABLISHED && closing && outSize() == 0) {
        state=FIN_WAIT_1;
        sendFIN();
      }
    }
 else {
      System.out.println(""String_Node_Str"" + Integer.toString(tcpPacket.ackNo & 0xffff,16) + ""String_Node_Str""+ Integer.toString(sendNext & 0xffff,16)+ ""String_Node_Str""+ Integer.toString(sentUnack & 0xffff,16));
      if (tcpPacket.ackNo == sentUnack) {
        resend();
      }
    }
  }
  if (receiveNext == tcpPacket.seqNo) {
    receiveNext=tcpPacket.seqNo + plen;
    if (tcpPacket.isFin()) {
      receiveNext++;
      if (plen == 0)       sendAck(tcpPacket);
    }
    if (plen > 0) {
      sendAck(tcpPacket);
      if (tcpListener != null) {
        tcpListener.tcpDataReceived(this,tcpPacket);
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
 else {
    System.out.println(""String_Node_Str"" + Integer.toString(receiveNext & 0xffff,16) + ""String_Node_Str""+ Integer.toString(tcpPacket.seqNo & 0xffff,16));
    sendAck(tcpPacket);
  }
}",0.8934727324102854
5623,"private void sendFIN(){
  System.out.println(""String_Node_Str"");
  TCPPacket packet=createPacket();
  packet.flags|=TCPPacket.FIN;
  state=FIN_WAIT_1;
  send(packet);
}","void sendFIN(){
  System.out.println(""String_Node_Str"");
  TCPPacket packet=createPacket();
  packet.flags|=TCPPacket.FIN;
  try {
    send(packet);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.6772486772486772
5624,"void sendAck(TCPPacket tcpPacket){
  TCPPacket tcpReply=TCPHandler.createAck(tcpPacket,0);
  tcpReply.ackNo=receiveNext;
  tcpReply.seqNo=sendNext;
  send(tcpReply);
}","void sendAck(TCPPacket tcpPacket){
  TCPPacket tcpReply=TCPHandler.createAck(tcpPacket,0);
  try {
    send(tcpReply);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.6743515850144092
5625,"private synchronized void copyToBuffer(byte[] data){
  int empty=outgoingBuffer.length - outSize();
  while (empty < data.length || state != TCPConnection.ESTABLISHED) {
    try {
      System.out.println(""String_Node_Str"");
      wait(1000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
      return;
    }
    empty=outgoingBuffer.length - outSize();
  }
  for (int i=0; i < data.length; i++) {
    outgoingBuffer[bufNextEmpty++]=data[i];
    if (bufNextEmpty >= outgoingBuffer.length)     bufNextEmpty=0;
  }
}","private synchronized void copyToBuffer(byte[] data) throws IOException {
  int empty=outgoingBuffer.length - outSize();
  while (empty < data.length || state == TCPConnection.SYN_RECEIVED || state == TCPConnection.SYN_SENT) {
    if (state == TCPConnection.CLOSED)     throw new IOException(""String_Node_Str"");
    try {
      System.out.println(""String_Node_Str"" + state);
      wait(1000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
      return;
    }
    empty=outgoingBuffer.length - outSize();
  }
  for (int i=0; i < data.length; i++) {
    outgoingBuffer[bufNextEmpty++]=data[i];
    if (bufNextEmpty >= outgoingBuffer.length)     bufNextEmpty=0;
  }
}",0.8459657701711492
5626,"public void close(){
  if (state == ESTABLISHED) {
    System.out.println(""String_Node_Str"" + outSize());
    closing=true;
    if (outSize() == 0) {
      sendFIN();
    }
  }
}","public void close(){
  if (state == ESTABLISHED) {
    System.out.println(""String_Node_Str"" + outSize());
    closing=true;
    if (outSize() == 0) {
      state=FIN_WAIT_1;
      sendFIN();
    }
  }
}",0.936842105263158
5627,"private synchronized void addConnection(TCPConnection c){
  activeConnections[connectionNo++]=c;
}","private synchronized void addConnection(TCPConnection c){
  c.pos=(byte)connectionNo;
  activeConnections[connectionNo++]=c;
}",0.875
5628,"public void handlePacket(IPv6Packet packet){
  TCPPacket tcpPacket=(TCPPacket)packet.getIPPayload();
  TCPConnection connection=findConnection(packet,tcpPacket);
  if (connection == null) {
    connection=findListenConnection(packet,tcpPacket);
    if (connection == null) {
      System.out.println(""String_Node_Str"");
    }
 else {
      if (tcpPacket.isSyn()) {
        TCPPacket tcpReply=createAck(tcpPacket,TCPPacket.SYN);
        TCPConnection tc=new TCPConnection(ipStack,packet.netInterface);
        tc.externalIP=packet.sourceAddress;
        tc.externalPort=tcpPacket.sourcePort;
        tc.localIP=ipStack.myIPAddress;
        tc.localPort=tcpPacket.destinationPort;
        tc.state=TCPConnection.SYN_RECEIVED;
        tc.receiveNext=tcpPacket.seqNo + 1;
        tc.sentUnack=tc.sendNext=tcpReply.seqNo=(int)(System.currentTimeMillis() * 7);
        addConnection(tc);
        connection.newConnection(tc);
        tcpReply.ackNo=tc.receiveNext;
        tc.send(tcpReply);
        tc.sentUnack=tc.sendNext=tc.sendNext + 1;
        tc.serverConnection=connection;
      }
    }
  }
 else {
switch (connection.state) {
case TCPConnection.SYN_RECEIVED:
      if (tcpPacket.isAck()) {
        System.out.println(""String_Node_Str"");
        connection.state=TCPConnection.ESTABLISHED;
        connection.receive(tcpPacket);
synchronized (connection) {
          connection.notify();
        }
      }
    break;
case TCPConnection.ESTABLISHED:
  if (tcpPacket.isFin()) {
    connection.state=TCPConnection.CLOSE_WAIT;
  }
connection.receive(tcpPacket);
break;
case TCPConnection.LAST_ACK:
if (tcpPacket.isAck()) {
connection.state=TCPConnection.CLOSED;
}
break;
case TCPConnection.FIN_WAIT_1:
if (tcpPacket.isAck()) {
connection.state=TCPConnection.FIN_WAIT_2;
connection.receive(tcpPacket);
}
if (tcpPacket.isFin()) {
connection.state=TCPConnection.TIME_WAIT;
connection.lastSendTime=System.currentTimeMillis();
connection.receiveNext++;
connection.sendAck(tcpPacket);
}
break;
case TCPConnection.FIN_WAIT_2:
if (tcpPacket.isFin()) {
System.out.println(""String_Node_Str"");
connection.state=TCPConnection.TIME_WAIT;
connection.lastSendTime=System.currentTimeMillis();
connection.receiveNext++;
connection.sendAck(tcpPacket);
}
break;
case TCPConnection.CLOSE_WAIT:
break;
}
}
}","public void handlePacket(IPv6Packet packet){
  TCPPacket tcpPacket=(TCPPacket)packet.getIPPayload();
  TCPConnection connection=findConnection(packet,tcpPacket);
  if (connection == null) {
    connection=findListenConnection(packet,tcpPacket);
    if (connection == null) {
      System.out.println(""String_Node_Str"");
    }
 else {
      if (tcpPacket.isSyn()) {
        TCPPacket tcpReply=createAck(tcpPacket,TCPPacket.SYN);
        TCPConnection tc=new TCPConnection(ipStack,packet.netInterface);
        tc.externalIP=packet.sourceAddress;
        tc.externalPort=tcpPacket.sourcePort;
        tc.localIP=ipStack.myIPAddress;
        tc.localPort=tcpPacket.destinationPort;
        tc.state=TCPConnection.SYN_RECEIVED;
        tc.receiveNext=tcpPacket.seqNo + 1;
        tc.sentUnack=tc.sendNext=tcpReply.seqNo=(int)(System.currentTimeMillis() * 7);
        addConnection(tc);
        connection.newConnection(tc);
        tcpReply.ackNo=tc.receiveNext;
        try {
          tc.send(tcpReply);
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
        tc.sentUnack=tc.sendNext=tc.sendNext + 1;
        tc.serverConnection=connection;
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
 else {
switch (connection.state) {
case TCPConnection.SYN_RECEIVED:
      if (tcpPacket.isAck()) {
        System.out.println(""String_Node_Str"" + connection.pos);
        connection.state=TCPConnection.ESTABLISHED;
        connection.receive(tcpPacket);
synchronized (connection) {
          connection.notify();
        }
      }
    break;
case TCPConnection.ESTABLISHED:
  if (tcpPacket.isFin()) {
    connection.state=TCPConnection.CLOSE_WAIT;
  }
connection.receive(tcpPacket);
break;
case TCPConnection.LAST_ACK:
if (tcpPacket.isAck()) {
System.out.println(""String_Node_Str"" + connection.pos);
connection.state=TCPConnection.CLOSED;
}
break;
case TCPConnection.FIN_WAIT_1:
if (tcpPacket.isAck()) {
connection.state=TCPConnection.FIN_WAIT_2;
connection.receive(tcpPacket);
}
if (tcpPacket.isFin()) {
connection.state=TCPConnection.TIME_WAIT;
connection.lastSendTime=System.currentTimeMillis();
connection.receiveNext++;
connection.sendAck(tcpPacket);
}
break;
case TCPConnection.FIN_WAIT_2:
if (tcpPacket.isFin()) {
System.out.println(""String_Node_Str"" + connection.pos);
connection.state=TCPConnection.TIME_WAIT;
connection.lastSendTime=System.currentTimeMillis();
connection.receiveNext++;
connection.sendAck(tcpPacket);
}
break;
case TCPConnection.CLOSE_WAIT:
break;
}
}
}",0.9475430230147212
5629,"public synchronized void run(){
  if (connectionNo > 0) {
    long time=System.currentTimeMillis();
    for (int i=0; i < connectionNo; i++) {
      TCPConnection connection=activeConnections[i];
switch (connection.state) {
case TCPConnection.ESTABLISHED:
        if (connection.outSize() > 0 && (connection.lastSendTime + connection.retransmissionTime < time)) {
          System.out.println(""String_Node_Str"");
          connection.resend();
        }
      break;
case TCPConnection.CLOSE_WAIT:
    if (connection.bufPos == connection.bufNextEmpty) {
      System.out.println(""String_Node_Str"");
      TCPPacket packet=connection.createPacket();
      packet.flags|=TCPPacket.FIN;
      connection.state=TCPConnection.LAST_ACK;
      connection.send(packet);
    }
 else {
    }
  break;
case TCPConnection.TIME_WAIT:
if (connection.lastSendTime < time + TCPConnection.TIME_WAIT_MILLIS) {
  System.out.println(""String_Node_Str"");
  connection.state=TCPConnection.CLOSED;
  connectionNo--;
  if (i > 0) {
    activeConnections[i]=activeConnections[connectionNo];
    i--;
  }
}
break;
}
}
}
}","public synchronized void run(){
  if (connectionNo > 0) {
    long time=System.currentTimeMillis();
    for (int i=0; i < connectionNo; i++) {
      TCPConnection connection=activeConnections[i];
switch (connection.state) {
case TCPConnection.ESTABLISHED:
        if (connection.outSize() > 0 && (connection.lastSendTime + connection.retransmissionTime < time)) {
          System.out.println(""String_Node_Str"");
          connection.resend();
        }
      if (connection.timeout != -1) {
        if (connection.lastSendTime + connection.timeout < time) {
          connection.close();
        }
      }
    break;
case TCPConnection.CLOSE_WAIT:
  if (connection.outSize() == 0) {
    System.out.println(""String_Node_Str"");
    connection.state=TCPConnection.LAST_ACK;
    connection.sendFIN();
  }
 else {
    connection.resend();
  }
break;
case TCPConnection.TIME_WAIT:
if (connection.lastSendTime + TCPConnection.TIME_WAIT_MILLIS < time) {
System.out.println(""String_Node_Str"");
connection.state=TCPConnection.CLOSED;
}
break;
case TCPConnection.CLOSED:
System.out.println(""String_Node_Str"" + connection.pos);
connection.closed();
connectionNo--;
if (connectionNo > 0) {
activeConnections[i]=activeConnections[connectionNo];
activeConnections[i].pos=(byte)i;
i--;
}
break;
}
}
}
}",0.7232255354892902
5630,"public void connectionClosed(TCPConnection connection){
}","public void connectionClosed(TCPConnection connection){
  closed=true;
  System.out.println(""String_Node_Str"");
  notifyReader();
}",0.6063829787234043
5631,"void receive(TCPPacket tcpPacket){
  int plen=tcpPacket.payload == null ? 0 : tcpPacket.payload.length;
  if (tcpPacket.isAck()) {
    if (sendNext == tcpPacket.ackNo) {
      sentUnack=tcpPacket.ackNo;
    }
 else {
      System.out.println(""String_Node_Str"" + Integer.toString(tcpPacket.ackNo,16) + ""String_Node_Str""+ Integer.toString(sendNext,16));
    }
  }
  if (receiveNext == tcpPacket.seqNo) {
  }
 else {
    System.out.println(""String_Node_Str"" + Integer.toString(receiveNext,16) + ""String_Node_Str""+ Integer.toString(tcpPacket.seqNo,16));
  }
  receiveNext=tcpPacket.seqNo + plen;
  if (tcpPacket.isFin()) {
    if (tcpListener != null && plen > 0) {
      tcpListener.connectionClosed(this);
    }
  }
  TCPPacket tcpReply=TCPHandler.createAck(tcpPacket,0);
  tcpReply.ackNo=tcpPacket.seqNo + plen;
  tcpReply.seqNo=sendNext;
  send(tcpReply);
  if (plen > 0)   if (tcpListener != null) {
    tcpListener.tcpDataReceived(this,tcpPacket);
  }
}","synchronized void receive(TCPPacket tcpPacket){
  int plen=tcpPacket.payload == null ? 0 : tcpPacket.payload.length;
  if (tcpPacket.isAck()) {
    if (sendNext == tcpPacket.ackNo) {
      int noAcked=tcpPacket.ackNo - sentUnack;
      sentUnack=tcpPacket.ackNo;
      bufPos+=noAcked;
      System.out.println(""String_Node_Str"" + noAcked + ""String_Node_Str""+ bufPos+ ""String_Node_Str""+ bufNextEmpty);
      notify();
    }
 else {
      System.out.println(""String_Node_Str"" + Integer.toString(tcpPacket.ackNo,16) + ""String_Node_Str""+ Integer.toString(sendNext,16)+ ""String_Node_Str""+ Integer.toString(sentUnack,16));
      if (tcpPacket.ackNo == sentUnack) {
        resend();
      }
    }
  }
  if (receiveNext == tcpPacket.seqNo) {
  }
 else {
    System.out.println(""String_Node_Str"" + Integer.toString(receiveNext,16) + ""String_Node_Str""+ Integer.toString(tcpPacket.seqNo,16));
  }
  receiveNext=tcpPacket.seqNo + plen;
  if (tcpPacket.isFin()) {
    if (tcpListener != null && plen > 0) {
      tcpListener.connectionClosed(this);
    }
  }
  if (plen > 0) {
    TCPPacket tcpReply=TCPHandler.createAck(tcpPacket,0);
    tcpReply.ackNo=tcpPacket.seqNo + plen;
    tcpReply.seqNo=sendNext;
    send(tcpReply);
    if (tcpListener != null) {
      tcpListener.tcpDataReceived(this,tcpPacket);
    }
  }
}",0.681095406360424
5632,"public void handlePacket(IPv6Packet packet){
  TCPPacket tcpPacket=(TCPPacket)packet.getIPPayload();
  TCPConnection connection=findConnection(packet,tcpPacket);
  if (connection == null) {
    connection=findListenConnection(packet,tcpPacket);
    if (connection == null) {
      System.out.println(""String_Node_Str"");
    }
 else {
      if ((tcpPacket.flags & TCPPacket.SYN) > 0) {
        TCPPacket tcpReply=createAck(tcpPacket,TCPPacket.SYN);
        TCPConnection tc=new TCPConnection(ipStack,packet.netInterface);
        tc.externalIP=packet.sourceAddress;
        tc.externalPort=tcpPacket.sourcePort;
        tc.localIP=ipStack.myIPAddress;
        tc.localPort=tcpPacket.destinationPort;
        tc.state=TCPConnection.SYN_RECEIVED;
        tc.receiveNext=tcpPacket.seqNo + 1;
        tc.sentUnack=tc.sendNext=tcpReply.seqNo=(int)(System.currentTimeMillis() * 7);
        addConnection(tc);
        tcpReply.ackNo=tcpPacket.seqNo + 1;
        tc.send(tcpReply);
        tc.sentUnack=tc.sendNext=tc.sendNext + 1;
        connection.newConnection(tc);
      }
    }
  }
 else {
switch (connection.state) {
case TCPConnection.SYN_RECEIVED:
      if (tcpPacket.isAck()) {
        System.out.println(""String_Node_Str"");
        connection.state=TCPConnection.ESTABLISHED;
      }
    break;
case TCPConnection.ESTABLISHED:
  if (tcpPacket.isAck() && (tcpPacket.payload == null || tcpPacket.payload.length == 0)) {
    return;
  }
if (tcpPacket.isFin()) {
  connection.state=TCPConnection.CLOSE_WAIT;
}
connection.receive(tcpPacket);
break;
case TCPConnection.LAST_ACK:
if (tcpPacket.isAck()) {
connection.state=TCPConnection.CLOSED;
}
break;
case TCPConnection.FIN_WAIT_1:
if (tcpPacket.isAck()) {
connection.state=TCPConnection.FIN_WAIT_2;
}
break;
case TCPConnection.FIN_WAIT_2:
if (tcpPacket.isFin()) {
System.out.println(""String_Node_Str"");
connection.state=TCPConnection.TIME_WAIT;
connection.lastSendTime=System.currentTimeMillis();
}
break;
case TCPConnection.CLOSE_WAIT:
break;
}
}
}","public void handlePacket(IPv6Packet packet){
  TCPPacket tcpPacket=(TCPPacket)packet.getIPPayload();
  TCPConnection connection=findConnection(packet,tcpPacket);
  if (connection == null) {
    connection=findListenConnection(packet,tcpPacket);
    if (connection == null) {
      System.out.println(""String_Node_Str"");
    }
 else {
      if ((tcpPacket.flags & TCPPacket.SYN) > 0) {
        TCPPacket tcpReply=createAck(tcpPacket,TCPPacket.SYN);
        TCPConnection tc=new TCPConnection(ipStack,packet.netInterface);
        tc.externalIP=packet.sourceAddress;
        tc.externalPort=tcpPacket.sourcePort;
        tc.localIP=ipStack.myIPAddress;
        tc.localPort=tcpPacket.destinationPort;
        tc.state=TCPConnection.SYN_RECEIVED;
        tc.receiveNext=tcpPacket.seqNo + 1;
        tc.sentUnack=tc.sendNext=tcpReply.seqNo=(int)(System.currentTimeMillis() * 7);
        addConnection(tc);
        tcpReply.ackNo=tcpPacket.seqNo + 1;
        tc.send(tcpReply);
        tc.sentUnack=tc.sendNext=tc.sendNext + 1;
        connection.newConnection(tc);
      }
    }
  }
 else {
switch (connection.state) {
case TCPConnection.SYN_RECEIVED:
      if (tcpPacket.isAck()) {
        System.out.println(""String_Node_Str"");
        connection.state=TCPConnection.ESTABLISHED;
      }
    break;
case TCPConnection.ESTABLISHED:
  if (tcpPacket.isFin()) {
    connection.state=TCPConnection.CLOSE_WAIT;
  }
connection.receive(tcpPacket);
break;
case TCPConnection.LAST_ACK:
if (tcpPacket.isAck()) {
connection.state=TCPConnection.CLOSED;
}
break;
case TCPConnection.FIN_WAIT_1:
if (tcpPacket.isAck()) {
connection.state=TCPConnection.FIN_WAIT_2;
}
break;
case TCPConnection.FIN_WAIT_2:
if (tcpPacket.isFin()) {
System.out.println(""String_Node_Str"");
connection.state=TCPConnection.TIME_WAIT;
connection.lastSendTime=System.currentTimeMillis();
}
break;
case TCPConnection.CLOSE_WAIT:
break;
}
}
}",0.97097354225533
5633,"public synchronized void run(){
  if (connectionNo > 0) {
    long time=System.currentTimeMillis();
    for (int i=0; i < connectionNo; i++) {
      TCPConnection connection=activeConnections[i];
switch (connection.state) {
case TCPConnection.CLOSE_WAIT:
        if (connection.bufFirst == connection.bufLast) {
          System.out.println(""String_Node_Str"");
          TCPPacket packet=connection.createPacket();
          packet.flags|=TCPPacket.FIN;
          connection.state=TCPConnection.LAST_ACK;
          connection.send(packet);
        }
 else {
        }
      break;
case TCPConnection.TIME_WAIT:
    if (connection.lastSendTime < time + TCPConnection.TIME_WAIT_MILLIS) {
      System.out.println(""String_Node_Str"");
      connection.state=TCPConnection.CLOSED;
      connectionNo--;
      if (i > 0) {
        activeConnections[i]=activeConnections[connectionNo];
        i--;
      }
    }
  break;
}
}
}
}","public synchronized void run(){
  if (connectionNo > 0) {
    long time=System.currentTimeMillis();
    for (int i=0; i < connectionNo; i++) {
      TCPConnection connection=activeConnections[i];
switch (connection.state) {
case TCPConnection.CLOSE_WAIT:
        if (connection.bufPos == connection.bufNextEmpty) {
          System.out.println(""String_Node_Str"");
          TCPPacket packet=connection.createPacket();
          packet.flags|=TCPPacket.FIN;
          connection.state=TCPConnection.LAST_ACK;
          connection.send(packet);
        }
 else {
        }
      break;
case TCPConnection.TIME_WAIT:
    if (connection.lastSendTime < time + TCPConnection.TIME_WAIT_MILLIS) {
      System.out.println(""String_Node_Str"");
      connection.state=TCPConnection.CLOSED;
      connectionNo--;
      if (i > 0) {
        activeConnections[i]=activeConnections[connectionNo];
        i--;
      }
    }
  break;
}
}
}
}",0.9886302111532216
5634,"private synchronized void notifyReader(){
  System.out.println(""String_Node_Str"");
  notify();
}","private synchronized void notifyReader(){
  notify();
}",0.7284768211920529
5635,"public void parsePacketData(IPv6Packet packet){
  sourcePort=packet.get16(0);
  destinationPort=packet.get16(2);
  seqNo=packet.get32(4);
  ackNo=packet.get32(8);
  offset=(packet.getData(12) & 0xff) >> 4;
  flags=packet.getData(13);
  window=packet.get16(14);
  checksum=packet.get16(16);
  urgentPointer=packet.get16(18);
  packet.setData(16,(byte)0);
  packet.setData(17,(byte)0);
  byte[] data=packet.getPayload();
  int sum=packet.upperLayerHeaderChecksum();
  sum=IPv6Packet.checkSum(sum,data,data.length);
  sum=(~sum) & 0xffff;
  if (sum == checksum) {
  }
 else {
    System.out.println(""String_Node_Str"" + Utils.hex16(checksum) + ""String_Node_Str""+ Utils.hex16(sum));
  }
  if (data.length - (offset * 4) > 0) {
    int len=data.length - (offset * 4);
    System.out.println(""String_Node_Str"" + offset + ""String_Node_Str""+ len);
    payload=new byte[len];
    System.arraycopy(data,(offset * 4),payload,0,len);
  }
}","public void parsePacketData(IPv6Packet packet){
  sourcePort=packet.get16(0);
  destinationPort=packet.get16(2);
  seqNo=packet.get32(4);
  ackNo=packet.get32(8);
  offset=(packet.getData(12) & 0xff) >> 4;
  flags=packet.getData(13);
  window=packet.get16(14);
  checksum=packet.get16(16);
  urgentPointer=packet.get16(18);
  packet.setData(16,(byte)0);
  packet.setData(17,(byte)0);
  byte[] data=packet.getPayload();
  int sum=packet.upperLayerHeaderChecksum();
  sum=IPv6Packet.checkSum(sum,data,data.length);
  sum=(~sum) & 0xffff;
  if (sum == checksum) {
  }
 else {
    System.out.println(""String_Node_Str"" + Utils.hex16(checksum) + ""String_Node_Str""+ Utils.hex16(sum));
  }
  if (data.length - (offset * 4) > 0) {
    int len=data.length - (offset * 4);
    payload=new byte[len];
    System.arraycopy(data,(offset * 4),payload,0,len);
  }
}",0.9566197183098591
5636,"public void parsePacketData(IPv6Packet packet){
  dispatch=packet.getDispatch();
  payloadData=packet.getPayload();
}","public void parsePacketData(IPv6Packet packet){
  dispatch=packet.getDispatch();
  payloadData=packet.getPayload();
  int len=0;
  if (payloadData != null)   len=payloadData.length;
  System.out.println(""String_Node_Str"" + len + ""String_Node_Str"");
}",0.6376021798365122
5637,"public void handlePacket(IPv6Packet packet){
  ICMP6Packet icmpPacket=new ICMP6Packet();
  icmpPacket.parsePacketData(packet);
  packet.setIPPayload(icmpPacket);
  icmpPacket.printPacket(System.out);
  ICMP6Packet p;
  IPv6Packet ipp;
switch (icmpPacket.type) {
case ICMP6Packet.ECHO_REQUEST:
    p=new ICMP6Packet();
  p.type=ICMP6Packet.ECHO_REPLY;
p.seqNo=icmpPacket.seqNo;
p.id=icmpPacket.id;
p.echoData=icmpPacket.echoData;
ipp=new IPv6Packet();
ipp.setIPPayload(p);
ipp.destAddress=packet.sourceAddress;
ipp.sourceAddress=ipStack.myIPAddress;
ipStack.sendPacket(ipp,packet.netInterface);
break;
case ICMP6Packet.ECHO_REPLY:
System.out.println(""String_Node_Str"");
break;
case ICMP6Packet.NEIGHBOR_SOLICITATION:
p=new ICMP6Packet();
p.targetAddress=icmpPacket.targetAddress;
p.type=ICMP6Packet.NEIGHBOR_ADVERTISEMENT;
p.flags=ICMP6Packet.FLAG_SOLICITED | ICMP6Packet.FLAG_OVERRIDE;
if (ipStack.isRouter()) {
p.flags|=ICMP6Packet.FLAG_ROUTER;
}
p.addLinkOption(ICMP6Packet.TARGET_LINKADDR,ipStack.getLinkLayerAddress());
ipp=new IPv6Packet();
ipp.setIPPayload(p);
ipp.destAddress=packet.sourceAddress;
if (ipp.destAddress[0] == 0xfe && ipp.destAddress[1] == 0x80) {
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,ipp.destAddress);
System.out.println();
ipp.sourceAddress=ipStack.myLocalIPAddress;
}
 else {
ipp.sourceAddress=ipStack.myIPAddress;
}
ipStack.sendPacket(ipp,packet.netInterface);
break;
case ICMP6Packet.ROUTER_SOLICITATION:
if (ipStack.isRouter()) {
p=new ICMP6Packet();
p.targetAddress=icmpPacket.targetAddress;
p.type=ICMP6Packet.ROUTER_ADVERTISEMENT;
p.flags=ICMP6Packet.FLAG_SOLICITED | ICMP6Packet.FLAG_OVERRIDE;
p.updateRA(ipStack);
ipp=new IPv6Packet();
ipp.setIPPayload(p);
ipp.destAddress=IPStack.ALL_NODES;
ipp.sourceAddress=ipStack.myLocalIPAddress;
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,ipp.destAddress);
packet.printPacket(System.out);
ipStack.getNeighborManager().receiveNDMessage(packet);
ipStack.sendPacket(ipp,packet.netInterface);
}
break;
case ICMP6Packet.ROUTER_ADVERTISEMENT:
if (!ipStack.isRouter()) {
byte[] prefixInfo=icmpPacket.getOption(ICMP6Packet.PREFIX_INFO);
if (prefixInfo != null) {
byte[] prefix=new byte[16];
System.arraycopy(prefixInfo,16,prefix,0,prefix.length);
int size=prefixInfo[2];
ipStack.setPrefix(prefix,size);
ipStack.getNeighborManager().receiveNDMessage(packet);
}
}
break;
}
}","public void handlePacket(IPv6Packet packet){
  ICMP6Packet icmpPacket=new ICMP6Packet();
  icmpPacket.parsePacketData(packet);
  packet.setIPPayload(icmpPacket);
  icmpPacket.printPacket(System.out);
  ICMP6Packet p;
  IPv6Packet ipp;
switch (icmpPacket.type) {
case ICMP6Packet.ECHO_REQUEST:
    p=new ICMP6Packet();
  p.type=ICMP6Packet.ECHO_REPLY;
p.seqNo=icmpPacket.seqNo;
p.id=icmpPacket.id;
p.echoData=icmpPacket.echoData;
ipp=new IPv6Packet();
ipp.setIPPayload(p);
ipp.destAddress=packet.sourceAddress;
ipp.sourceAddress=ipStack.myIPAddress;
ipStack.sendPacket(ipp,packet.netInterface);
break;
case ICMP6Packet.ECHO_REPLY:
System.out.println(""String_Node_Str"");
break;
case ICMP6Packet.NEIGHBOR_SOLICITATION:
p=new ICMP6Packet();
p.targetAddress=icmpPacket.targetAddress;
p.type=ICMP6Packet.NEIGHBOR_ADVERTISEMENT;
p.flags=ICMP6Packet.FLAG_SOLICITED | ICMP6Packet.FLAG_OVERRIDE;
if (ipStack.isRouter()) {
p.flags|=ICMP6Packet.FLAG_ROUTER;
}
p.addLinkOption(ICMP6Packet.TARGET_LINKADDR,ipStack.getLinkLayerAddress());
ipp=new IPv6Packet();
ipp.setIPPayload(p);
ipp.destAddress=packet.sourceAddress;
if (ipp.destAddress[0] == 0xfe && ipp.destAddress[1] == 0x80) {
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,ipp.destAddress);
System.out.println();
ipp.sourceAddress=ipStack.myLocalIPAddress;
}
 else {
ipp.sourceAddress=ipStack.myIPAddress;
}
ipStack.sendPacket(ipp,packet.netInterface);
break;
case ICMP6Packet.ROUTER_SOLICITATION:
ipStack.getNeighborManager().receiveNDMessage(packet);
break;
case ICMP6Packet.ROUTER_ADVERTISEMENT:
if (!ipStack.isRouter()) {
byte[] prefixInfo=icmpPacket.getOption(ICMP6Packet.PREFIX_INFO);
if (prefixInfo != null) {
byte[] prefix=new byte[16];
System.arraycopy(prefixInfo,16,prefix,0,prefix.length);
int size=prefixInfo[2];
ipStack.setPrefix(prefix,size);
ipStack.getNeighborManager().receiveNDMessage(packet);
}
}
break;
}
}",0.8821611551001397
5638,"public void receivePacket(IPv6Packet packet){
  if (DEBUG) {
    System.out.println(""String_Node_Str"");
    packet.printPacket(System.out);
  }
  if (isForMe(packet.getDestinationAddress())) {
    if (DEBUG)     System.out.println(""String_Node_Str"" + packet.getDispatch());
switch (packet.nextHeader) {
case ICMP6Packet.DISPATCH:
      icmp6Handler.handlePacket(packet);
    if (networkEventListener != null) {
      networkEventListener.packetHandled(packet);
    }
  break;
case UDPPacket.DISPATCH:
if (packet.getIPPayload() != null) {
  packet.getIPPayload().printPacket(System.out);
  udpHandler.handlePacket(packet,(UDPPacket)packet.getIPPayload());
}
 else {
  UDPPacket p=new UDPPacket();
  p.parsePacketData(packet);
  p.printPacket(System.out);
  packet.setIPPayload(p);
  udpHandler.handlePacket(packet,p);
}
if (networkEventListener != null) {
networkEventListener.packetHandled(packet);
}
break;
case TCPPacket.DISPATCH:
TCPPacket p=new TCPPacket();
p.parsePacketData(packet);
p.printPacket(System.out);
packet.setIPPayload(p);
tcpHandler.handlePacket(packet);
if (networkEventListener != null) {
networkEventListener.packetHandled(packet);
}
break;
}
}
 else if (!isOnLink(packet.getDestinationAddress()) && packet.netInterface != tunnel) {
System.out.println(""String_Node_Str"" + tunnel);
if (packet.ipPayload == null) {
packet.setIPPayload(new BytePayload(packet));
}
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,myIPAddress);
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.getDestinationAddress());
if (tunnel != null && tunnel.isReady()) {
tunnel.sendPacket(packet);
}
}
 else if (packet.netInterface != linkLayerHandler) {
System.out.println(""String_Node_Str"" + packet.getDestinationAddress() + ""String_Node_Str"");
if (packet.ipPayload == null) {
packet.setIPPayload(new BytePayload(packet));
if (findRoute(packet)) {
linkLayerHandler.sendPacket(packet);
}
}
}
 else {
System.out.println(""String_Node_Str"");
}
}","public void receivePacket(IPv6Packet packet){
  if (DEBUG) {
    System.out.println(""String_Node_Str"");
    packet.printPacket(System.out);
  }
  if (isForMe(packet.getDestinationAddress())) {
    if (DEBUG)     System.out.println(""String_Node_Str"" + packet.getDispatch());
switch (packet.nextHeader) {
case ICMP6Packet.DISPATCH:
      icmp6Handler.handlePacket(packet);
    if (networkEventListener != null) {
      networkEventListener.packetHandled(packet);
    }
  break;
case UDPPacket.DISPATCH:
if (packet.getIPPayload() != null) {
  packet.getIPPayload().printPacket(System.out);
  udpHandler.handlePacket(packet,(UDPPacket)packet.getIPPayload());
}
 else {
  UDPPacket p=new UDPPacket();
  p.parsePacketData(packet);
  p.printPacket(System.out);
  packet.setIPPayload(p);
  udpHandler.handlePacket(packet,p);
}
if (networkEventListener != null) {
networkEventListener.packetHandled(packet);
}
break;
case TCPPacket.DISPATCH:
TCPPacket p=new TCPPacket();
p.parsePacketData(packet);
p.printPacket(System.out);
packet.setIPPayload(p);
tcpHandler.handlePacket(packet);
if (networkEventListener != null) {
networkEventListener.packetHandled(packet);
}
break;
}
}
 else if (!isOnLink(packet.getDestinationAddress()) && packet.netInterface != tunnel) {
System.out.println(""String_Node_Str"" + tunnel);
if (packet.ipPayload == null) {
System.out.println(""String_Node_Str"");
packet.setIPPayload(new BytePayload(packet));
}
 else {
System.out.println(""String_Node_Str"");
}
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,myIPAddress);
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.getDestinationAddress());
if (tunnel != null && tunnel.isReady()) {
tunnel.sendPacket(packet);
}
}
 else if (packet.netInterface != linkLayerHandler) {
System.out.println(""String_Node_Str"" + packet.getDestinationAddress() + ""String_Node_Str"");
if (packet.ipPayload == null) {
packet.setIPPayload(new BytePayload(packet));
if (findRoute(packet)) {
linkLayerHandler.sendPacket(packet);
}
}
}
 else {
System.out.println(""String_Node_Str"");
}
}",0.7523387493845396
5639,"public void receiveNDMessage(IPv6Packet packet){
  ICMP6Packet payload=(ICMP6Packet)packet.getIPPayload();
  Neighbor nei=null;
switch (payload.type) {
case ICMP6Packet.ROUTER_SOLICITATION:
    nei=neigborTable.addNeighbor(packet.sourceAddress,packet.getLinkSource());
  if (nei != null) {
    nei.setState(Neighbor.REACHABLE);
  }
break;
case ICMP6Packet.ROUTER_ADVERTISEMENT:
nei=neigborTable.addNeighbor(packet.sourceAddress,packet.getLinkSource());
neigborTable.setDefrouter(nei);
nei.setState(Neighbor.REACHABLE);
break;
}
}","public void receiveNDMessage(IPv6Packet packet){
  ICMP6Packet payload=(ICMP6Packet)packet.getIPPayload();
  Neighbor nei=null;
switch (payload.type) {
case ICMP6Packet.ROUTER_SOLICITATION:
    nei=neigborTable.addNeighbor(packet.sourceAddress,packet.getLinkSource());
  if (nei != null) {
    nei.setState(Neighbor.REACHABLE);
  }
if (ipStack.isRouter()) {
  ICMP6Packet p=new ICMP6Packet();
  p.targetAddress=payload.targetAddress;
  p.type=ICMP6Packet.ROUTER_ADVERTISEMENT;
  p.flags=ICMP6Packet.FLAG_SOLICITED | ICMP6Packet.FLAG_OVERRIDE;
  p.updateRA(ipStack);
  IPv6Packet ipp=new IPv6Packet();
  ipp.setIPPayload(p);
  ipp.destAddress=IPStack.ALL_NODES;
  ipp.sourceAddress=ipStack.myLocalIPAddress;
  System.out.print(""String_Node_Str"");
  IPv6Packet.printAddress(System.out,ipp.destAddress);
  packet.printPacket(System.out);
  ipStack.sendPacket(ipp,packet.netInterface);
}
break;
case ICMP6Packet.ROUTER_ADVERTISEMENT:
nei=neigborTable.addNeighbor(packet.sourceAddress,packet.getLinkSource());
neigborTable.setDefrouter(nei);
nei.setState(Neighbor.REACHABLE);
break;
}
}",0.6422360248447205
5640,"public byte[] generatePacketData(IPv6Packet packet){
  return null;
}","public byte[] generatePacketData(IPv6Packet packet){
  int size=payload != null ? payload.length : 0;
  size+=8;
  byte[] data=new byte[size];
  int pos=0;
  data[pos++]=(byte)(sourcePort >> 8);
  data[pos++]=(byte)(sourcePort & 0xff);
  data[pos++]=(byte)(destinationPort >> 8);
  data[pos++]=(byte)(destinationPort & 0xff);
  data[pos++]=(byte)(size >> 8);
  data[pos++]=(byte)(size & 0xff);
  data[pos++]=0;
  data[pos++]=0;
  if (payload != null) {
    System.arraycopy(payload,0,data,pos,payload.length);
  }
  packet.payloadLen=size;
  int sum=packet.upperLayerHeaderChecksum();
  sum=IPv6Packet.checkSum(sum,data,size);
  sum=(~sum) & 0xffff;
  data[6]=(byte)(sum >> 8);
  data[7]=(byte)(sum & 0xff);
  return data;
}",0.1412358133669609
5641,"/** 
 * \brief check whether the 112-bit group-id of the multicast address is mappable to a 9-bit group-id It is true if the group is the all nodes or all routers group.
 */
public byte[] generatePacketData(IPv6Packet packet){
  int enc1=0, enc2=0;
  byte[] data=new byte[40];
  int pos=2;
  if (packet.flowLabel == 0) {
    enc1|=IPHC_VF_C;
  }
  if (packet.trafficClass == 0) {
    enc1|=IPHC_TC_C;
  }
  if ((enc1 & IPHC_VF_C) == 0) {
    pos+=packet.writeVFlow(data,pos);
  }
  if ((enc1 & IPHC_TC_C) == 0) {
    data[pos++]=(byte)(packet.trafficClass & 0xff);
  }
  data[pos++]=(byte)(packet.nextHeader & 0xff);
switch (packet.hopLimit) {
case 1:
    enc1|=IPHC_TTL_1;
  break;
case 64:
enc1|=IPHC_TTL_64;
break;
case 255:
enc1|=IPHC_TTL_255;
break;
default :
data[pos++]=(byte)(packet.hopLimit & 0xff);
}
int context;
if ((context=lookupContext(packet.sourceAddress)) != -1) {
enc2|=context << 4;
if (packet.isSourceMACBased()) {
enc2|=IPHC_SAM_0;
}
 else if (is16bitCompressable(packet.sourceAddress)) {
enc2|=IPHC_SAM_16;
data[pos++]=packet.sourceAddress[14];
data[pos++]=packet.sourceAddress[15];
}
 else {
enc2|=IPHC_SAM_64;
System.arraycopy(packet.sourceAddress,8,data,pos,8);
pos+=8;
}
}
 else {
enc2|=IPHC_SAM_I;
System.arraycopy(packet.sourceAddress,0,data,pos,16);
pos+=16;
}
if (packet.isMulticastDestination()) {
if (isMulticastCompressable(packet.destAddress)) {
enc2|=IPHC_DAM_16;
data[pos]=(byte)IPHC_MCAST_RANGE;
data[pos++]|=(packet.destAddress[1] & 0x0F) << 1;
data[pos++]=packet.destAddress[15];
}
 else {
enc2|=IPHC_DAM_I;
System.arraycopy(packet.destAddress,0,data,pos,16);
pos+=16;
}
}
 else {
if ((context=lookupContext(packet.destAddress)) != -1) {
enc2|=context;
if (packet.isDestinationMACBased()) {
enc2|=IPHC_DAM_0;
}
 else {
if (is16bitCompressable(packet.destAddress)) {
enc2|=IPHC_DAM_16;
data[pos++]=packet.destAddress[14];
data[pos++]=packet.destAddress[15];
}
 else {
enc2|=IPHC_DAM_64;
System.arraycopy(data,pos,packet.destAddress,8,8);
pos+=8;
}
}
}
 else {
enc2|=IPHC_DAM_I;
System.arraycopy(data,pos,packet.destAddress,0,16);
pos+=16;
}
}
data[0]=(byte)(enc1 & 0xff);
data[1]=(byte)(enc2 & 0xff);
if (DEBUG) System.out.println(""String_Node_Str"" + pos + ""String_Node_Str""+ Utils.hex8(enc1)+ ""String_Node_Str""+ Utils.hex8(enc2));
IPPayload payload=packet.getIPPayload();
byte[] pload=payload.generatePacketData(packet);
if (DEBUG) System.out.println(""String_Node_Str"" + pload.length);
byte[] dataPacket=new byte[pos + pload.length];
System.arraycopy(data,0,dataPacket,0,pos);
System.arraycopy(pload,0,dataPacket,pos,pload.length);
return dataPacket;
}","/** 
 * \brief check whether the 112-bit group-id of the multicast address is mappable to a 9-bit group-id It is true if the group is the all nodes or all routers group.
 */
public byte[] generatePacketData(IPv6Packet packet){
  int enc1=0, enc2=0;
  byte[] data=new byte[40];
  int pos=2;
  if (packet.flowLabel == 0) {
    enc1|=IPHC_VF_C;
  }
  if (packet.trafficClass == 0) {
    enc1|=IPHC_TC_C;
  }
  if ((enc1 & IPHC_VF_C) == 0) {
    pos+=packet.writeVFlow(data,pos);
  }
  if ((enc1 & IPHC_TC_C) == 0) {
    data[pos++]=(byte)(packet.trafficClass & 0xff);
  }
  data[pos++]=(byte)(packet.nextHeader & 0xff);
switch (packet.hopLimit) {
case 1:
    enc1|=IPHC_TTL_1;
  break;
case 64:
enc1|=IPHC_TTL_64;
break;
case 255:
enc1|=IPHC_TTL_255;
break;
default :
data[pos++]=(byte)(packet.hopLimit & 0xff);
}
int context;
if ((context=lookupContext(packet.sourceAddress)) != -1) {
enc2|=context << 4;
if (packet.isSourceMACBased()) {
enc2|=IPHC_SAM_0;
}
 else if (is16bitCompressable(packet.sourceAddress)) {
enc2|=IPHC_SAM_16;
data[pos++]=packet.sourceAddress[14];
data[pos++]=packet.sourceAddress[15];
}
 else {
enc2|=IPHC_SAM_64;
System.arraycopy(packet.sourceAddress,8,data,pos,8);
pos+=8;
}
}
 else {
enc2|=IPHC_SAM_I;
System.arraycopy(packet.sourceAddress,0,data,pos,16);
pos+=16;
}
if (packet.isMulticastDestination()) {
if (isMulticastCompressable(packet.destAddress)) {
enc2|=IPHC_DAM_16;
data[pos]=(byte)IPHC_MCAST_RANGE;
data[pos++]|=(packet.destAddress[1] & 0x0F) << 1;
data[pos++]=packet.destAddress[15];
}
 else {
enc2|=IPHC_DAM_I;
System.arraycopy(packet.destAddress,0,data,pos,16);
pos+=16;
}
}
 else {
if ((context=lookupContext(packet.destAddress)) != -1) {
enc2|=context;
if (packet.isDestinationMACBased()) {
enc2|=IPHC_DAM_0;
}
 else {
if (is16bitCompressable(packet.destAddress)) {
enc2|=IPHC_DAM_16;
data[pos++]=packet.destAddress[14];
data[pos++]=packet.destAddress[15];
}
 else {
enc2|=IPHC_DAM_64;
System.arraycopy(packet.destAddress,8,data,pos,8);
pos+=8;
}
}
}
 else {
if (DEBUG) System.out.println(""String_Node_Str"");
enc2|=IPHC_DAM_I;
System.arraycopy(packet.destAddress,0,data,pos,16);
pos+=16;
}
}
data[0]=(byte)(enc1 & 0xff);
data[1]=(byte)(enc2 & 0xff);
if (DEBUG) System.out.println(""String_Node_Str"" + pos + ""String_Node_Str""+ Utils.hex8(enc1)+ ""String_Node_Str""+ Utils.hex8(enc2));
if (DEBUG) {
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.sourceAddress);
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.destAddress);
}
IPPayload payload=packet.getIPPayload();
byte[] pload=payload.generatePacketData(packet);
if (DEBUG) System.out.println(""String_Node_Str"" + pload.length);
byte[] dataPacket=new byte[pos + pload.length];
System.arraycopy(data,0,dataPacket,0,pos);
System.arraycopy(pload,0,dataPacket,pos,pload.length);
return dataPacket;
}",0.833180062534486
5642,"public void parsePacketData(IPv6Packet packet){
  if (packet.nextHeader == 58) {
    type=packet.getData(0) & 0xff;
    code=packet.getData(1) & 0xff;
    checksum=((packet.getData(2) & 0xff) << 8) | packet.getData(3) & 0xff;
    packet.setData(2,(byte)0);
    packet.setData(3,(byte)0);
switch (type) {
case ECHO_REQUEST:
case ECHO_REPLY:
      id=packet.get16(4);
    seqNo=packet.get16(6);
  break;
case NEIGHBOR_SOLICITATION:
case NEIGHBOR_ADVERTISEMENT:
if (type == NEIGHBOR_ADVERTISEMENT) {
  flags=packet.getData(4) & 0xff;
}
packet.copy(8,targetAddress,0,16);
break;
}
byte[] data=packet.getPayload();
System.out.println(""String_Node_Str"" + data.length);
int sum=packet.upperLayerHeaderChecksum();
sum=IPv6Packet.checkSum(sum,data,data.length);
sum=(~sum) & 0xffff;
if (sum == checksum) {
System.out.println(""String_Node_Str"");
}
 else {
System.out.printf(""String_Node_Str"",checksum,sum);
}
}
}","public void parsePacketData(IPv6Packet packet){
  if (packet.nextHeader == 58) {
    type=packet.getData(0) & 0xff;
    code=packet.getData(1) & 0xff;
    checksum=((packet.getData(2) & 0xff) << 8) | packet.getData(3) & 0xff;
    packet.setData(2,(byte)0);
    packet.setData(3,(byte)0);
switch (type) {
case ECHO_REQUEST:
case ECHO_REPLY:
      id=packet.get16(4);
    seqNo=packet.get16(6);
  break;
case NEIGHBOR_SOLICITATION:
case NEIGHBOR_ADVERTISEMENT:
if (type == NEIGHBOR_ADVERTISEMENT) {
  flags=packet.getData(4) & 0xff;
}
targetAddress=new byte[16];
packet.copy(8,targetAddress,0,16);
break;
}
byte[] data=packet.getPayload();
System.out.println(""String_Node_Str"" + data.length);
int sum=packet.upperLayerHeaderChecksum();
sum=IPv6Packet.checkSum(sum,data,data.length);
sum=(~sum) & 0xffff;
if (sum == checksum) {
System.out.println(""String_Node_Str"");
}
 else {
System.out.printf(""String_Node_Str"",checksum,sum);
}
}
}",0.9847161572052402
5643,"public void handlePacket(IPv6Packet packet){
  ICMP6Packet icmpPacket=new ICMP6Packet();
  icmpPacket.parsePacketData(packet);
  icmpPacket.printPacket(System.out);
  ICMP6Packet p;
  IPv6Packet ipp;
switch (icmpPacket.type) {
case ICMP6Packet.NEIGHBOR_SOLICITATION:
    p=new ICMP6Packet();
  p.targetAddress=icmpPacket.targetAddress;
p.type=ICMP6Packet.NEIGHBOR_ADVERTISEMENT;
p.flags=ICMP6Packet.FLAG_SOLICITED | ICMP6Packet.FLAG_OVERRIDE;
ipp=new IPv6Packet();
ipp.setIPPayload(p);
ipp.destAddress=packet.sourceAddress;
ipStack.sendPacket(ipp);
break;
case ICMP6Packet.ROUTER_SOLICITATION:
p=new ICMP6Packet();
p.targetAddress=icmpPacket.targetAddress;
p.type=ICMP6Packet.ROUTER_ADVERTISEMENT;
p.flags=ICMP6Packet.FLAG_SOLICITED | ICMP6Packet.FLAG_OVERRIDE;
ipp=new IPv6Packet();
ipp.setIPPayload(p);
ipp.destAddress=packet.sourceAddress;
ipStack.sendPacket(ipp);
break;
}
}","public void handlePacket(IPv6Packet packet){
  ICMP6Packet icmpPacket=new ICMP6Packet();
  icmpPacket.parsePacketData(packet);
  icmpPacket.printPacket(System.out);
  ICMP6Packet p;
  IPv6Packet ipp;
switch (icmpPacket.type) {
case ICMP6Packet.NEIGHBOR_SOLICITATION:
    p=new ICMP6Packet();
  p.targetAddress=icmpPacket.targetAddress;
p.type=ICMP6Packet.NEIGHBOR_ADVERTISEMENT;
p.flags=ICMP6Packet.FLAG_SOLICITED | ICMP6Packet.FLAG_OVERRIDE;
ipp=new IPv6Packet();
ipp.setIPPayload(p);
ipp.destAddress=packet.sourceAddress;
ipStack.sendPacket(ipp);
break;
case ICMP6Packet.ROUTER_SOLICITATION:
p=new ICMP6Packet();
p.targetAddress=icmpPacket.targetAddress;
p.type=ICMP6Packet.ROUTER_ADVERTISEMENT;
p.flags=ICMP6Packet.FLAG_SOLICITED | ICMP6Packet.FLAG_OVERRIDE;
p.updateRA(ipStack);
ipp=new IPv6Packet();
ipp.setIPPayload(p);
ipp.destAddress=packet.sourceAddress;
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,ipp.destAddress);
ipStack.sendPacket(ipp);
break;
}
}",0.9405463310123192
5644,"public int read(int address,boolean word,long cycles){
  if (address == TAIV || address == TBIV) {
    int val=lastTIV;
    resetTIV(cycles);
    return val;
  }
  int val=0;
  int index=address - offset;
switch (index) {
case TR:
    val=updateCounter(cycles);
  break;
case TCTL:
val=tctl;
if (interruptPending) {
val|=1;
}
 else {
val&=0xfffe;
}
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ inputDivider+ ""String_Node_Str""+ getSourceName(clockSource)+ ""String_Node_Str""+ interruptEnable+ ""String_Node_Str""+ interruptPending+ ""String_Node_Str""+ mode);
}
break;
case TCCTL0:
case TCCTL1:
case TCCTL2:
case TCCTL3:
case TCCTL4:
case TCCTL5:
case TCCTL6:
int i=(index - TCCTL0) / 2;
val=tcctl[i];
break;
case TCCR0:
case TCCR1:
case TCCR2:
case TCCR3:
case TCCR4:
case TCCR5:
case TCCR6:
i=(index - TCCR0) / 2;
val=tccr[i];
break;
default :
System.out.println(""String_Node_Str"");
}
if (DEBUG && false) {
System.out.println(getName() + ""String_Node_Str"" + getName(address)+ ""String_Node_Str""+ Utils.hex16(address)+ ""String_Node_Str""+ Utils.hex16(val)+ ""String_Node_Str""+ val+ ""String_Node_Str"");
}
return val & 0xffff;
}","public int read(int address,boolean word,long cycles){
  if (address == TAIV || address == TBIV) {
    int val=lastTIV;
    resetTIV(cycles);
    return val;
  }
  int val=0;
  int index=address - offset;
switch (index) {
case TR:
    val=updateCounter(cycles);
  break;
case TCTL:
val=tctl;
if (interruptPending) {
val|=1;
}
 else {
val&=0xfffe;
}
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ inputDivider+ ""String_Node_Str""+ getSourceName(clockSource)+ ""String_Node_Str""+ interruptEnable+ ""String_Node_Str""+ interruptPending+ ""String_Node_Str""+ mode);
}
break;
case TCCTL0:
case TCCTL1:
case TCCTL2:
case TCCTL3:
case TCCTL4:
case TCCTL5:
case TCCTL6:
int i=(index - TCCTL0) / 2;
updateTCCTL(i,cycles);
val=tcctl[i];
break;
case TCCR0:
case TCCR1:
case TCCR2:
case TCCR3:
case TCCR4:
case TCCR5:
case TCCR6:
i=(index - TCCR0) / 2;
val=tccr[i];
break;
default :
System.out.println(""String_Node_Str"");
}
if (DEBUG && false) {
System.out.println(getName() + ""String_Node_Str"" + getName(address)+ ""String_Node_Str""+ Utils.hex16(address)+ ""String_Node_Str""+ Utils.hex16(val)+ ""String_Node_Str""+ val+ ""String_Node_Str"");
}
return val & 0xffff;
}",0.9901498929336188
5645,"public void handlePacket(IPv6Packet packet){
  ICMP6Packet icmpPacket=new ICMP6Packet();
  icmpPacket.parsePacketData(packet);
  packet.setIPPayload(icmpPacket);
  icmpPacket.printPacket(System.out);
  ICMP6Packet p;
  IPv6Packet ipp;
switch (icmpPacket.type) {
case ICMP6Packet.ECHO_REQUEST:
    p=new ICMP6Packet();
  p.type=ICMP6Packet.ECHO_REPLY;
p.seqNo=icmpPacket.seqNo;
p.id=icmpPacket.id;
p.echoData=icmpPacket.echoData;
ipp=new IPv6Packet();
ipp.setIPPayload(p);
ipp.destAddress=packet.sourceAddress;
ipp.sourceAddress=ipStack.myIPAddress;
ipStack.sendPacket(ipp,packet.netInterface);
break;
case ICMP6Packet.ECHO_REPLY:
System.out.println(""String_Node_Str"");
break;
case ICMP6Packet.NEIGHBOR_SOLICITATION:
p=new ICMP6Packet();
p.targetAddress=icmpPacket.targetAddress;
p.type=ICMP6Packet.NEIGHBOR_ADVERTISEMENT;
p.flags=ICMP6Packet.FLAG_SOLICITED | ICMP6Packet.FLAG_OVERRIDE;
if (ipStack.isRouter()) {
p.flags|=ICMP6Packet.FLAG_ROUTER;
}
p.addLinkOption(ICMP6Packet.TARGET_LINKADDR,ipStack.getLinkLayerAddress());
ipp=new IPv6Packet();
ipp.setIPPayload(p);
ipp.destAddress=packet.sourceAddress;
if (ipp.destAddress[0] == 0xfe && ipp.destAddress[1] == 0x80) {
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,ipp.destAddress);
System.out.println();
ipp.sourceAddress=ipStack.myLocalIPAddress;
}
 else {
ipp.sourceAddress=ipStack.myIPAddress;
}
ipStack.sendPacket(ipp,packet.netInterface);
break;
case ICMP6Packet.ROUTER_SOLICITATION:
if (ipStack.isRouter()) {
p=new ICMP6Packet();
p.targetAddress=icmpPacket.targetAddress;
p.type=ICMP6Packet.ROUTER_ADVERTISEMENT;
p.flags=ICMP6Packet.FLAG_SOLICITED | ICMP6Packet.FLAG_OVERRIDE;
p.updateRA(ipStack);
ipp=new IPv6Packet();
ipp.setIPPayload(p);
ipp.destAddress=IPStack.ALL_NODES;
ipp.sourceAddress=ipStack.myLocalIPAddress;
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,ipp.destAddress);
packet.printPacket(System.out);
ipStack.sendPacket(ipp,packet.netInterface);
}
break;
case ICMP6Packet.ROUTER_ADVERTISEMENT:
if (!ipStack.isRouter()) {
byte[] prefixInfo=icmpPacket.getOption(ICMP6Packet.PREFIX_INFO);
if (prefixInfo != null) {
byte[] prefix=new byte[16];
System.arraycopy(prefixInfo,16,prefix,0,prefix.length);
int size=prefixInfo[2];
ipStack.setPrefix(prefix,size);
System.out.println(""String_Node_Str"");
NeighborTable nt=ipStack.getNeighborTable();
Neighbor nei=nt.addNeighbor(packet.sourceAddress,packet.getLinkSource());
nt.setDefrouter(nei);
nei.setState(Neighbor.REACHABLE);
}
}
break;
}
}","public void handlePacket(IPv6Packet packet){
  ICMP6Packet icmpPacket=new ICMP6Packet();
  icmpPacket.parsePacketData(packet);
  packet.setIPPayload(icmpPacket);
  icmpPacket.printPacket(System.out);
  ICMP6Packet p;
  IPv6Packet ipp;
switch (icmpPacket.type) {
case ICMP6Packet.ECHO_REQUEST:
    p=new ICMP6Packet();
  p.type=ICMP6Packet.ECHO_REPLY;
p.seqNo=icmpPacket.seqNo;
p.id=icmpPacket.id;
p.echoData=icmpPacket.echoData;
ipp=new IPv6Packet();
ipp.setIPPayload(p);
ipp.destAddress=packet.sourceAddress;
ipp.sourceAddress=ipStack.myIPAddress;
ipStack.sendPacket(ipp,packet.netInterface);
break;
case ICMP6Packet.ECHO_REPLY:
System.out.println(""String_Node_Str"");
break;
case ICMP6Packet.NEIGHBOR_SOLICITATION:
p=new ICMP6Packet();
p.targetAddress=icmpPacket.targetAddress;
p.type=ICMP6Packet.NEIGHBOR_ADVERTISEMENT;
p.flags=ICMP6Packet.FLAG_SOLICITED | ICMP6Packet.FLAG_OVERRIDE;
if (ipStack.isRouter()) {
p.flags|=ICMP6Packet.FLAG_ROUTER;
}
p.addLinkOption(ICMP6Packet.TARGET_LINKADDR,ipStack.getLinkLayerAddress());
ipp=new IPv6Packet();
ipp.setIPPayload(p);
ipp.destAddress=packet.sourceAddress;
if (ipp.destAddress[0] == 0xfe && ipp.destAddress[1] == 0x80) {
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,ipp.destAddress);
System.out.println();
ipp.sourceAddress=ipStack.myLocalIPAddress;
}
 else {
ipp.sourceAddress=ipStack.myIPAddress;
}
ipStack.sendPacket(ipp,packet.netInterface);
break;
case ICMP6Packet.ROUTER_SOLICITATION:
if (ipStack.isRouter()) {
p=new ICMP6Packet();
p.targetAddress=icmpPacket.targetAddress;
p.type=ICMP6Packet.ROUTER_ADVERTISEMENT;
p.flags=ICMP6Packet.FLAG_SOLICITED | ICMP6Packet.FLAG_OVERRIDE;
p.updateRA(ipStack);
ipp=new IPv6Packet();
ipp.setIPPayload(p);
ipp.destAddress=IPStack.ALL_NODES;
ipp.sourceAddress=ipStack.myLocalIPAddress;
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,ipp.destAddress);
packet.printPacket(System.out);
ipStack.sendPacket(ipp,packet.netInterface);
}
break;
case ICMP6Packet.ROUTER_ADVERTISEMENT:
if (!ipStack.isRouter()) {
byte[] prefixInfo=icmpPacket.getOption(ICMP6Packet.PREFIX_INFO);
if (prefixInfo != null) {
byte[] prefix=new byte[16];
System.arraycopy(prefixInfo,16,prefix,0,prefix.length);
int size=prefixInfo[2];
ipStack.setPrefix(prefix,size);
NeighborTable nt=ipStack.getNeighborTable();
Neighbor nei=nt.addNeighbor(packet.sourceAddress,packet.getLinkSource());
nt.setDefrouter(nei);
nei.setState(Neighbor.REACHABLE);
}
}
break;
}
}",0.9921513382974442
5646,"private int updateCounter(long cycles){
  if (mode == STOP)   return counter;
  double divider=1;
  if (clockSource == SRC_ACLK) {
    divider=1.0 * core.smclkFrq / core.aclkFrq;
  }
  divider=divider * inputDivider;
  long cycctr=cycles - counterStart;
  double tick=cycctr / divider;
  counterPassed=(int)(divider * (tick - (long)(tick)));
  long bigCounter=(long)(tick + counterAcc);
switch (mode) {
case CONTIN:
    counter=(int)(bigCounter & 0xffff);
  break;
case UP:
counter=(int)(bigCounter % tccr[0]);
break;
case UPDWN:
counter=(int)(bigCounter % (tccr[0] * 2));
if (counter > tccr[0]) {
counter=2 * tccr[0] - counter;
}
}
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cycctr+ ""String_Node_Str""+ divider+ ""String_Node_Str""+ mode+ ""String_Node_Str""+ counter);
}
return counter;
}","private int updateCounter(long cycles){
  if (mode == STOP)   return counter;
  double divider=1;
  if (clockSource == SRC_ACLK) {
    divider=1.0 * core.smclkFrq / core.aclkFrq;
  }
  divider=divider * inputDivider;
  long cycctr=cycles - counterStart;
  double tick=cycctr / divider;
  counterPassed=(int)(divider * (tick - (long)(tick)));
  long bigCounter=(long)(tick + counterAcc);
switch (mode) {
case CONTIN:
    counter=(int)(bigCounter & 0xffff);
  break;
case UP:
if (tccr[0] == 0) {
  counter=0;
}
 else {
  counter=(int)(bigCounter % tccr[0]);
}
break;
case UPDWN:
if (tccr[0] == 0) {
counter=0;
}
 else {
counter=(int)(bigCounter % (tccr[0] * 2));
if (counter > tccr[0]) {
counter=2 * tccr[0] - counter;
}
}
}
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cycctr+ ""String_Node_Str""+ divider+ ""String_Node_Str""+ mode+ ""String_Node_Str""+ counter);
}
return counter;
}",0.9471210340775558
5647,"public void parsePacketData(IPv6Packet packet){
  int pos=2;
  int enc0=packet.getData(0);
  int enc1=packet.getData(1);
  if ((enc0 & 0x40) == 0) {
    if ((enc0 & 0x80) == 0) {
      packet.version=(packet.getData(pos) & 0xf0) >> 4;
      packet.trafficClass=((packet.getData(pos) & 0x0f) << 4) + ((packet.getData(pos + 1) & 0xff) >> 4);
      packet.flowLabel=(packet.getData(pos + 1) & 0x0f) << 16 + (packet.getData(pos + 2) & 0xff) << 8 + packet.getData(pos + 3) & 0xff;
      pos+=4;
    }
 else {
      packet.version=6;
      packet.trafficClass=0;
      packet.flowLabel=(packet.getData(pos) & 0x0f) << 16 + (packet.getData(pos + 1) & 0xff) << 8 + packet.getData(pos + 2) & 0xff;
      ;
      pos+=3;
    }
  }
 else {
    packet.version=6;
    packet.flowLabel=0;
    if ((enc0 & 0x80) == 0) {
      packet.trafficClass=(packet.getData(pos) & 0xff);
      pos++;
    }
 else {
      packet.trafficClass=0;
    }
  }
  if ((enc0 & 0x20) == 0) {
    packet.nextHeader=packet.getData(pos++);
  }
switch (enc0 & 0x18) {
case IPHC_TTL_1:
    packet.hopLimit=1;
  break;
case IPHC_TTL_64:
packet.hopLimit=64;
break;
case IPHC_TTL_255:
packet.hopLimit=0xff;
break;
case IPHC_TTL_I:
packet.hopLimit=packet.getData(pos++);
break;
}
int srcAddress=(packet.getData(1) & 0x30) >> 4;
AddrContext context=lookupContext(srcAddress);
switch (enc1 & 0xc0) {
case IPHC_SAM_0:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.sourceAddress,0,8);
byte[] linkAddress=packet.getLinkSource();
System.arraycopy(linkAddress,0,packet.sourceAddress,8,8);
packet.sourceAddress[8]^=0x02;
break;
case IPHC_SAM_16:
if ((packet.getData(pos) & 0x80) == 0) {
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.sourceAddress,0,8);
java.util.Arrays.fill(packet.sourceAddress,8,14,(byte)0);
packet.sourceAddress[14]=packet.getData(pos);
packet.sourceAddress[15]=packet.getData(pos + 1);
pos+=2;
}
 else {
java.util.Arrays.fill(packet.sourceAddress,0,16,(byte)0);
packet.sourceAddress[0]=(byte)0xff;
packet.sourceAddress[1]=(byte)(((packet.getData(pos) & 0xff) >> 1) & 0x0f);
packet.sourceAddress[15]=packet.getData(pos + 1);
pos+=2;
}
break;
case IPHC_SAM_64:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.sourceAddress,0,8);
packet.copy(pos,packet.sourceAddress,8,8);
pos+=8;
break;
case IPHC_SAM_I:
packet.copy(pos,packet.sourceAddress,0,16);
pos+=16;
break;
}
context=lookupContext(packet.getData(2) & 0x03);
switch (enc1 & 0x0C) {
case IPHC_DAM_0:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.destAddress,0,8);
byte[] destAddress=packet.getLinkDestination();
System.arraycopy(destAddress,0,packet.destAddress,8,8);
packet.destAddress[8]^=0x02;
break;
case IPHC_DAM_16:
if ((packet.getData(pos) & 0x80) == 0) {
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.destAddress,0,8);
packet.destAddress[14]=packet.getData(pos);
packet.destAddress[15]=packet.getData(pos + 1);
pos+=2;
}
 else {
System.out.println(""String_Node_Str"" + packet.getData(pos) + ""String_Node_Str""+ packet.getData(pos + 1));
java.util.Arrays.fill(packet.destAddress,0,16,(byte)0);
packet.destAddress[0]=(byte)0xff;
packet.destAddress[1]=(byte)(((packet.getData(pos) & 0xff) >> 1) & 0x0F);
packet.destAddress[15]=(byte)(packet.getData(pos + 1) & 0xff);
pos+=2;
}
break;
case IPHC_DAM_64:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.destAddress,0,8);
packet.copy(pos,packet.destAddress,8,8);
pos+=8;
break;
case IPHC_DAM_I:
packet.copy(pos,packet.destAddress,0,16);
pos+=16;
break;
}
if ((enc0 & 0x20) != 0) {
if ((packet.getData(pos) & 0xfc) == NHC_UDP_ID) {
System.out.println(""String_Node_Str"");
packet.nextHeader=PROTO_UDP;
int srcPort=0;
int destPort=0;
int checkSum=0;
switch (packet.getData(pos) & 0xff) {
case NHC_UDP_C:
srcPort=UDP_PORT_MIN + ((packet.getData(pos + 1) & 0xff) >> 4);
destPort=UDP_PORT_MIN + (packet.getData(pos + 1) & 0x0F);
checkSum=((packet.getData(pos + 2) & 0xff) << 8) + (packet.getData(pos + 3) & 0xff);
pos+=4;
break;
case NHC_UDP_I:
srcPort=((packet.getData(pos + 1) & 0xff) << 8) + (packet.getData(pos + 2) & 0xff);
destPort=((packet.getData(pos + 3) & 0xff) << 8) + (packet.getData(pos + 4) & 0xff);
checkSum=((packet.getData(pos + 5) & 0xff) << 8) + (packet.getData(pos + 6) & 0xff);
pos+=7;
break;
default :
System.out.println(""String_Node_Str"");
return;
}
System.out.println(""String_Node_Str"" + destPort);
System.out.println(""String_Node_Str"" + srcPort);
System.out.println(""String_Node_Str"" + srcPort);
}
}
boolean frag=false;
if (!frag) {
packet.incPos(pos);
}
 else {
}
System.out.println(""String_Node_Str"" + Utils.hex8(enc0) + ""String_Node_Str""+ Utils.hex8(enc1));
System.out.println(""String_Node_Str"" + packet.hopLimit);
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.sourceAddress);
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.destAddress);
System.out.println();
packet.payloadLen=packet.getPayloadLength();
}","public void parsePacketData(IPv6Packet packet){
  int pos=2;
  int enc1=packet.getData(0);
  int enc2=packet.getData(1);
  if ((enc1 & 0x40) == 0) {
    if ((enc1 & 0x80) == 0) {
      packet.version=(packet.getData(pos) & 0xf0) >> 4;
      packet.trafficClass=((packet.getData(pos) & 0x0f) << 4) + ((packet.getData(pos + 1) & 0xff) >> 4);
      packet.flowLabel=(packet.getData(pos + 1) & 0x0f) << 16 + (packet.getData(pos + 2) & 0xff) << 8 + packet.getData(pos + 3) & 0xff;
      pos+=4;
    }
 else {
      packet.version=6;
      packet.trafficClass=0;
      packet.flowLabel=(packet.getData(pos) & 0x0f) << 16 + (packet.getData(pos + 1) & 0xff) << 8 + packet.getData(pos + 2) & 0xff;
      ;
      pos+=3;
    }
  }
 else {
    packet.version=6;
    packet.flowLabel=0;
    if ((enc1 & 0x80) == 0) {
      packet.trafficClass=(packet.getData(pos) & 0xff);
      pos++;
    }
 else {
      packet.trafficClass=0;
    }
  }
  if ((enc1 & 0x20) == 0) {
    packet.nextHeader=packet.getData(pos++);
  }
switch (enc1 & 0x18) {
case IPHC_TTL_1:
    packet.hopLimit=1;
  break;
case IPHC_TTL_64:
packet.hopLimit=64;
break;
case IPHC_TTL_255:
packet.hopLimit=0xff;
break;
case IPHC_TTL_I:
packet.hopLimit=packet.getData(pos++);
break;
}
int srcAddress=(enc2 & 0x30) >> 4;
AddrContext context=lookupContext(srcAddress);
if (DEBUG) {
System.out.println(""String_Node_Str"" + (enc2 & 0xc0) + ""String_Node_Str""+ srcAddress);
}
switch (enc2 & 0xc0) {
case IPHC_SAM_0:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.sourceAddress,0,8);
byte[] linkAddress=packet.getLinkSource();
System.arraycopy(linkAddress,0,packet.sourceAddress,8,8);
packet.sourceAddress[8]^=0x02;
break;
case IPHC_SAM_16:
if ((packet.getData(pos) & 0x80) == 0) {
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.sourceAddress,0,8);
java.util.Arrays.fill(packet.sourceAddress,8,14,(byte)0);
packet.sourceAddress[14]=packet.getData(pos);
packet.sourceAddress[15]=packet.getData(pos + 1);
pos+=2;
}
 else {
java.util.Arrays.fill(packet.sourceAddress,0,16,(byte)0);
packet.sourceAddress[0]=(byte)0xff;
packet.sourceAddress[1]=(byte)(((packet.getData(pos) & 0xff) >> 1) & 0x0f);
packet.sourceAddress[15]=packet.getData(pos + 1);
pos+=2;
}
break;
case IPHC_SAM_64:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.sourceAddress,0,8);
packet.copy(pos,packet.sourceAddress,8,8);
pos+=8;
break;
case IPHC_SAM_I:
if (DEBUG) System.out.println(""String_Node_Str"");
packet.copy(pos,packet.sourceAddress,0,16);
pos+=16;
break;
}
context=lookupContext(enc2 & 0x03);
if (DEBUG) {
System.out.println(""String_Node_Str"" + (enc2 & 0x0c) + ""String_Node_Str""+ (enc2 & 0x03));
}
switch (enc2 & 0x0C) {
case IPHC_DAM_0:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.destAddress,0,8);
byte[] destAddress=packet.getLinkDestination();
System.arraycopy(destAddress,0,packet.destAddress,8,8);
packet.destAddress[8]^=0x02;
break;
case IPHC_DAM_16:
if ((packet.getData(pos) & 0x80) == 0) {
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.destAddress,0,8);
packet.destAddress[14]=packet.getData(pos);
packet.destAddress[15]=packet.getData(pos + 1);
pos+=2;
}
 else {
System.out.println(""String_Node_Str"" + packet.getData(pos) + ""String_Node_Str""+ packet.getData(pos + 1));
java.util.Arrays.fill(packet.destAddress,0,16,(byte)0);
packet.destAddress[0]=(byte)0xff;
packet.destAddress[1]=(byte)(((packet.getData(pos) & 0xff) >> 1) & 0x0F);
packet.destAddress[15]=(byte)(packet.getData(pos + 1) & 0xff);
pos+=2;
}
break;
case IPHC_DAM_64:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.destAddress,0,8);
packet.copy(pos,packet.destAddress,8,8);
pos+=8;
break;
case IPHC_DAM_I:
packet.copy(pos,packet.destAddress,0,16);
pos+=16;
break;
}
if ((enc1 & 0x20) != 0) {
if ((packet.getData(pos) & 0xfc) == NHC_UDP_ID) {
System.out.println(""String_Node_Str"");
packet.nextHeader=PROTO_UDP;
int srcPort=0;
int destPort=0;
int checkSum=0;
switch (packet.getData(pos) & 0xff) {
case NHC_UDP_C:
srcPort=UDP_PORT_MIN + ((packet.getData(pos + 1) & 0xff) >> 4);
destPort=UDP_PORT_MIN + (packet.getData(pos + 1) & 0x0F);
checkSum=((packet.getData(pos + 2) & 0xff) << 8) + (packet.getData(pos + 3) & 0xff);
pos+=4;
break;
case NHC_UDP_I:
srcPort=((packet.getData(pos + 1) & 0xff) << 8) + (packet.getData(pos + 2) & 0xff);
destPort=((packet.getData(pos + 3) & 0xff) << 8) + (packet.getData(pos + 4) & 0xff);
checkSum=((packet.getData(pos + 5) & 0xff) << 8) + (packet.getData(pos + 6) & 0xff);
pos+=7;
break;
default :
System.out.println(""String_Node_Str"");
return;
}
System.out.println(""String_Node_Str"" + destPort);
System.out.println(""String_Node_Str"" + srcPort);
System.out.println(""String_Node_Str"" + srcPort);
}
}
boolean frag=false;
if (!frag) {
packet.incPos(pos);
}
 else {
}
System.out.println(""String_Node_Str"" + Utils.hex8(enc1) + ""String_Node_Str""+ Utils.hex8(enc2));
System.out.println(""String_Node_Str"" + packet.hopLimit);
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.sourceAddress);
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.destAddress);
System.out.println();
packet.payloadLen=packet.getPayloadLength();
}",0.964926969950693
5648,"/** 
 * \brief check whether the 112-bit group-id of the multicast address is mappable to a 9-bit group-id It is true if the group is the all nodes or all routers group.
 */
public byte[] generatePacketData(IPv6Packet packet){
  int enc1=0, enc2=0;
  byte[] data=new byte[40];
  int pos=2;
  if (packet.flowLabel == 0) {
    enc1|=IPHC_VF_C;
  }
  if (packet.trafficClass == 0) {
    enc1|=IPHC_TC_C;
  }
  if ((enc1 & IPHC_VF_C) == 0) {
    pos+=packet.writeVFlow(data,pos);
  }
  if ((enc1 & IPHC_TC_C) == 0) {
    data[pos++]=(byte)(packet.trafficClass & 0xff);
  }
  data[pos++]=(byte)(packet.nextHeader & 0xff);
switch (packet.hopLimit) {
case 1:
    enc1|=IPHC_TTL_1;
  break;
case 64:
enc1|=IPHC_TTL_64;
break;
case 255:
enc1|=IPHC_TTL_255;
break;
default :
data[pos++]=(byte)(packet.hopLimit & 0xff);
}
int context;
if ((context=lookupContext(packet.sourceAddress)) != -1) {
enc2|=context << 4;
if (packet.isSourceMACBased()) {
enc2|=IPHC_SAM_0;
}
 else if (is16bitCompressable(packet.sourceAddress)) {
enc2|=IPHC_SAM_16;
data[pos++]=packet.sourceAddress[14];
data[pos++]=packet.sourceAddress[15];
}
 else {
enc2|=IPHC_SAM_64;
System.arraycopy(packet.sourceAddress,8,data,pos,8);
pos+=8;
}
}
 else {
enc2|=IPHC_SAM_I;
System.arraycopy(packet.sourceAddress,0,data,pos,16);
pos+=16;
}
if (packet.isMulticastDestination()) {
if (isMulticastCompressable(packet.destAddress)) {
enc2|=IPHC_DAM_16;
data[pos]=(byte)IPHC_MCAST_RANGE;
data[pos++]|=(packet.destAddress[1] & 0x0F) << 1;
data[pos++]=packet.destAddress[15];
}
 else {
enc2|=IPHC_DAM_I;
System.arraycopy(packet.destAddress,0,data,pos,16);
pos+=16;
}
}
 else {
if ((context=lookupContext(packet.destAddress)) != -1) {
enc2|=context;
if (packet.isDestinationMACBased()) {
enc2|=IPHC_DAM_0;
}
 else {
if (is16bitCompressable(packet.destAddress)) {
enc2|=IPHC_DAM_16;
data[pos++]=packet.destAddress[14];
data[pos++]=packet.destAddress[15];
}
 else {
enc2|=IPHC_DAM_64;
System.arraycopy(packet.destAddress,8,data,pos,8);
pos+=8;
}
}
}
 else {
if (DEBUG) System.out.println(""String_Node_Str"");
enc2|=IPHC_DAM_I;
System.arraycopy(packet.destAddress,0,data,pos,16);
pos+=16;
}
}
data[0]=(byte)(enc1 & 0xff);
data[1]=(byte)(enc2 & 0xff);
if (DEBUG) System.out.println(""String_Node_Str"" + pos + ""String_Node_Str""+ Utils.hex8(enc1)+ ""String_Node_Str""+ Utils.hex8(enc2));
if (DEBUG) {
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.sourceAddress);
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.destAddress);
}
IPPayload payload=packet.getIPPayload();
byte[] pload=payload.generatePacketData(packet);
if (DEBUG) System.out.println(""String_Node_Str"" + pload.length);
byte[] dataPacket=new byte[pos + pload.length];
System.arraycopy(data,0,dataPacket,0,pos);
System.arraycopy(pload,0,dataPacket,pos,pload.length);
return dataPacket;
}","/** 
 * \brief check whether the 112-bit group-id of the multicast address is mappable to a 9-bit group-id It is true if the group is the all nodes or all routers group.
 */
public byte[] generatePacketData(IPv6Packet packet){
  int enc1=0, enc2=0;
  byte[] data=new byte[40];
  int pos=2;
  if (packet.flowLabel == 0) {
    enc1|=IPHC_VF_C;
  }
  if (packet.trafficClass == 0) {
    enc1|=IPHC_TC_C;
  }
  if ((enc1 & IPHC_VF_C) == 0) {
    pos+=packet.writeVFlow(data,pos);
  }
  if ((enc1 & IPHC_TC_C) == 0) {
    data[pos++]=(byte)(packet.trafficClass & 0xff);
  }
  data[pos++]=(byte)(packet.nextHeader & 0xff);
switch (packet.hopLimit) {
case 1:
    enc1|=IPHC_TTL_1;
  break;
case 64:
enc1|=IPHC_TTL_64;
break;
case 255:
enc1|=IPHC_TTL_255;
break;
default :
data[pos++]=(byte)(packet.hopLimit & 0xff);
}
int context;
if ((context=lookupContext(packet.sourceAddress)) != -1) {
if (DEBUG) System.out.println(""String_Node_Str"" + context);
enc2|=context << 4;
if (packet.isSourceMACBased()) {
enc2|=IPHC_SAM_0;
}
 else if (is16bitCompressable(packet.sourceAddress)) {
enc2|=IPHC_SAM_16;
data[pos++]=packet.sourceAddress[14];
data[pos++]=packet.sourceAddress[15];
}
 else {
enc2|=IPHC_SAM_64;
System.arraycopy(packet.sourceAddress,8,data,pos,8);
pos+=8;
}
}
 else {
if (DEBUG) System.out.println(""String_Node_Str"");
enc2|=IPHC_SAM_I;
System.arraycopy(packet.sourceAddress,0,data,pos,16);
pos+=16;
}
if (packet.isMulticastDestination()) {
if (isMulticastCompressable(packet.destAddress)) {
enc2|=IPHC_DAM_16;
data[pos]=(byte)IPHC_MCAST_RANGE;
data[pos++]|=(packet.destAddress[1] & 0x0F) << 1;
data[pos++]=packet.destAddress[15];
}
 else {
enc2|=IPHC_DAM_I;
System.arraycopy(packet.destAddress,0,data,pos,16);
pos+=16;
}
}
 else {
if ((context=lookupContext(packet.destAddress)) != -1) {
if (DEBUG) System.out.println(""String_Node_Str"" + context);
enc2|=context;
if (packet.isDestinationMACBased()) {
enc2|=IPHC_DAM_0;
}
 else {
if (is16bitCompressable(packet.destAddress)) {
enc2|=IPHC_DAM_16;
data[pos++]=packet.destAddress[14];
data[pos++]=packet.destAddress[15];
}
 else {
enc2|=IPHC_DAM_64;
System.arraycopy(packet.destAddress,8,data,pos,8);
pos+=8;
}
}
}
 else {
if (DEBUG) System.out.println(""String_Node_Str"");
enc2|=IPHC_DAM_I;
System.arraycopy(packet.destAddress,0,data,pos,16);
pos+=16;
}
}
data[0]=(byte)(enc1 & 0xff);
data[1]=(byte)(enc2 & 0xff);
if (DEBUG) System.out.println(""String_Node_Str"" + pos + ""String_Node_Str""+ Utils.hex8(enc1)+ ""String_Node_Str""+ Utils.hex8(enc2));
if (DEBUG) {
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.sourceAddress);
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.destAddress);
}
IPPayload payload=packet.getIPPayload();
byte[] pload=payload.generatePacketData(packet);
if (DEBUG) System.out.println(""String_Node_Str"" + pload.length);
byte[] dataPacket=new byte[pos + pload.length];
System.arraycopy(data,0,dataPacket,0,pos);
System.arraycopy(pload,0,dataPacket,pos,pload.length);
return dataPacket;
}",0.4372013651877133
5649,"public HC01Packeter(){
  contexts[0]=new AddrContext();
  contexts[1]=new AddrContext();
  contexts[2]=new AddrContext();
  contexts[3]=new AddrContext();
  contexts[0].used=1;
  contexts[0].number=0;
  contexts[0].prefix[0]=(byte)0xfe;
  contexts[0].prefix[1]=(byte)0x80;
  contexts[1].used=1;
  contexts[1].number=1;
  contexts[1].prefix[0]=(byte)0xaa;
  contexts[1].prefix[1]=(byte)0xaa;
}","public HC01Packeter(){
  contexts[0]=new AddrContext();
  contexts[1]=new AddrContext();
  contexts[0].number=0;
  contexts[0].prefix[0]=(byte)0xfe;
  contexts[0].prefix[1]=(byte)0x80;
  contexts[1].number=1;
  contexts[1].prefix[0]=(byte)0xaa;
  contexts[1].prefix[1]=(byte)0xaa;
}",0.8367952522255193
5650,"public MSP430Core(int type){
  setModeNames(MODE_NAMES);
  int passIO=0;
  ioUnits=new IOUnit[PORTS + 7];
  Timer ta=new Timer(this,Timer.TIMER_Ax149,memory,0x160);
  Timer tb=new Timer(this,Timer.TIMER_Bx149,memory,0x180);
  for (int i=0, n=0x20; i < n; i++) {
    memOut[0x160 + i]=ta;
    memOut[0x180 + i]=tb;
    memIn[0x160 + i]=ta;
    memIn[0x180 + i]=tb;
  }
  Watchdog wdt=new Watchdog(this);
  memOut[0x120]=wdt;
  memIn[0x120]=wdt;
  flash=new Flash(this,memory,new FlashRange(0x4000,0x10000,512,64),new FlashRange(0x1000,0x01100,128,64));
  for (int i=0x128; i < 0x12e; i++) {
    memOut[i]=flash;
    memIn[i]=flash;
  }
  sfr=new SFR(this,memory);
  for (int i=0, n=0x10; i < n; i++) {
    memOut[i]=sfr;
    memIn[i]=sfr;
  }
  memIn[Timer.TAIV]=ta;
  memIn[Timer.TBIV]=tb;
  bcs=new BasicClockModule(this,memory,0,new Timer[]{ta,tb});
  for (int i=0x56, n=0x59; i < n; i++) {
    memOut[i]=bcs;
  }
  Multiplier mp=new Multiplier(this,memory,0);
  for (int i=0x130, n=0x13f; i < n; i++) {
    memOut[i]=mp;
    memIn[i]=mp;
  }
  USART usart0=new USART(this,memory,0x70);
  USART usart1=new USART(this,memory,0x78);
  for (int i=0, n=8; i < n; i++) {
    memOut[0x70 + i]=usart0;
    memIn[0x70 + i]=usart0;
    memOut[0x78 + i]=usart1;
    memIn[0x78 + i]=usart1;
  }
  ioUnits[0]=new IOPort(this,""String_Node_Str"",4,memory,0x20);
  ioUnits[1]=new IOPort(this,""String_Node_Str"",1,memory,0x28);
  for (int i=0, n=8; i < n; i++) {
    memOut[0x20 + i]=ioUnits[0];
    memOut[0x28 + i]=ioUnits[1];
  }
  for (int i=0, n=2; i < n; i++) {
    ioUnits[i + 2]=new IOPort(this,""String_Node_Str"" + (3 + i),0,memory,0x18 + i * 4);
    memOut[0x18 + i * 4]=ioUnits[i + 2];
    memOut[0x19 + i * 4]=ioUnits[i + 2];
    memOut[0x1a + i * 4]=ioUnits[i + 2];
    memOut[0x1b + i * 4]=ioUnits[i + 2];
    ioUnits[i + 4]=new IOPort(this,""String_Node_Str"" + (5 + i),0,memory,0x30 + i * 4);
    memOut[0x30 + i * 4]=ioUnits[i + 4];
    memOut[0x31 + i * 4]=ioUnits[i + 4];
    memOut[0x32 + i * 4]=ioUnits[i + 4];
    memOut[0x33 + i * 4]=ioUnits[i + 4];
  }
  passIO=6;
  ioUnits[passIO++]=bcs;
  ioUnits[passIO++]=usart0;
  ioUnits[passIO++]=usart1;
  ioUnits[passIO++]=ta;
  ioUnits[passIO++]=tb;
  ADC12 adc12=new ADC12(this);
  ioUnits[passIO++]=adc12;
  ioUnits[passIO++]=sfr;
  for (int i=0, n=16; i < n; i++) {
    memOut[0x80 + i]=adc12;
    memIn[0x80 + i]=adc12;
    memOut[0x140 + i]=adc12;
    memIn[0x140 + i]=adc12;
    memOut[0x150 + i]=adc12;
    memIn[0x150 + i]=adc12;
  }
  for (int i=0, n=8; i < n; i++) {
    memOut[0x1A0 + i]=adc12;
    memIn[0x1A0 + i]=adc12;
  }
  if (DEBUG)   System.out.println(""String_Node_Str"" + passIO);
}","public MSP430Core(int type){
  setModeNames(MODE_NAMES);
  int passIO=0;
  ioUnits=new IOUnit[PORTS + 7];
  Timer ta=new Timer(this,Timer.TIMER_Ax149,memory,0x160);
  Timer tb=new Timer(this,Timer.TIMER_Bx149,memory,0x180);
  for (int i=0, n=0x20; i < n; i++) {
    memOut[0x160 + i]=ta;
    memOut[0x180 + i]=tb;
    memIn[0x160 + i]=ta;
    memIn[0x180 + i]=tb;
  }
  Watchdog wdt=new Watchdog(this);
  memOut[0x120]=wdt;
  memIn[0x120]=wdt;
  flash=new Flash(this,memory,new FlashRange(0x4000,0x10000,512,64),new FlashRange(0x1000,0x01100,128,64));
  for (int i=0x128; i < 0x12e; i++) {
    memOut[i]=flash;
    memIn[i]=flash;
  }
  sfr=new SFR(this,memory);
  for (int i=0, n=0x10; i < n; i++) {
    memOut[i]=sfr;
    memIn[i]=sfr;
  }
  memIn[Timer.TAIV]=ta;
  memOut[Timer.TAIV]=ta;
  memIn[Timer.TBIV]=tb;
  memOut[Timer.TBIV]=tb;
  bcs=new BasicClockModule(this,memory,0,new Timer[]{ta,tb});
  for (int i=0x56, n=0x59; i < n; i++) {
    memOut[i]=bcs;
  }
  Multiplier mp=new Multiplier(this,memory,0);
  for (int i=0x130, n=0x13f; i < n; i++) {
    memOut[i]=mp;
    memIn[i]=mp;
  }
  USART usart0=new USART(this,memory,0x70);
  USART usart1=new USART(this,memory,0x78);
  for (int i=0, n=8; i < n; i++) {
    memOut[0x70 + i]=usart0;
    memIn[0x70 + i]=usart0;
    memOut[0x78 + i]=usart1;
    memIn[0x78 + i]=usart1;
  }
  ioUnits[0]=new IOPort(this,""String_Node_Str"",4,memory,0x20);
  ioUnits[1]=new IOPort(this,""String_Node_Str"",1,memory,0x28);
  for (int i=0, n=8; i < n; i++) {
    memOut[0x20 + i]=ioUnits[0];
    memOut[0x28 + i]=ioUnits[1];
  }
  for (int i=0, n=2; i < n; i++) {
    ioUnits[i + 2]=new IOPort(this,""String_Node_Str"" + (3 + i),0,memory,0x18 + i * 4);
    memOut[0x18 + i * 4]=ioUnits[i + 2];
    memOut[0x19 + i * 4]=ioUnits[i + 2];
    memOut[0x1a + i * 4]=ioUnits[i + 2];
    memOut[0x1b + i * 4]=ioUnits[i + 2];
    ioUnits[i + 4]=new IOPort(this,""String_Node_Str"" + (5 + i),0,memory,0x30 + i * 4);
    memOut[0x30 + i * 4]=ioUnits[i + 4];
    memOut[0x31 + i * 4]=ioUnits[i + 4];
    memOut[0x32 + i * 4]=ioUnits[i + 4];
    memOut[0x33 + i * 4]=ioUnits[i + 4];
  }
  passIO=6;
  ioUnits[passIO++]=bcs;
  ioUnits[passIO++]=usart0;
  ioUnits[passIO++]=usart1;
  ioUnits[passIO++]=ta;
  ioUnits[passIO++]=tb;
  ADC12 adc12=new ADC12(this);
  ioUnits[passIO++]=adc12;
  ioUnits[passIO++]=sfr;
  for (int i=0, n=16; i < n; i++) {
    memOut[0x80 + i]=adc12;
    memIn[0x80 + i]=adc12;
    memOut[0x140 + i]=adc12;
    memIn[0x140 + i]=adc12;
    memOut[0x150 + i]=adc12;
    memIn[0x150 + i]=adc12;
  }
  for (int i=0, n=8; i < n; i++) {
    memOut[0x1A0 + i]=adc12;
    memIn[0x1A0 + i]=adc12;
  }
  if (DEBUG)   System.out.println(""String_Node_Str"" + passIO);
}",0.9899103139013452
5651,"public void write(int address,int data,boolean word,long cycles){
  int iAddress=address - offset;
switch (iAddress) {
case TR:
    setCounter(data,cycles);
  break;
case TCTL:
if (DEBUG) {
  System.out.println(getName() + ""String_Node_Str"" + Utils.hex16(data));
}
inputDivider=1 << ((data >> 6) & 3);
clockSource=srcMap[(data >> 8) & 3];
updateCyclesMultiplicator();
if ((data & TCLR) != 0) {
counter=0;
resetCounter(cycles);
updateCaptures(-1,cycles);
}
int newMode=(data >> 4) & 3;
if (mode == STOP && newMode != STOP) {
resetCounter(cycles);
nextTimerTrigger=(long)(cycles + cyclesMultiplicator * ((0xffff - counter) & 0xffff));
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"");
}
recalculateCompares(cycles);
}
mode=newMode;
interruptEnable=(data & 0x02) > 0;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ inputDivider+ ""String_Node_Str""+ getSourceName(clockSource)+ ""String_Node_Str""+ interruptEnable+ ""String_Node_Str""+ interruptPending+ ""String_Node_Str""+ mode+ ((data & TCLR) != 0 ? ""String_Node_Str"" : ""String_Node_Str""));
}
tctl=data;
tctl&=~0x04;
if ((data & 0x01) == 0) {
interruptPending=false;
}
updateCaptures(-1,cycles);
break;
case TCCTL0:
case TCCTL1:
case TCCTL2:
case TCCTL3:
case TCCTL4:
case TCCTL5:
case TCCTL6:
int index=(iAddress - TCCTL0) / 2;
tcctl[index]=data;
outMode[index]=(data >> 5) & 7;
boolean oldCapture=captureOn[index];
captureOn[index]=(data & 0x100) > 0;
sync[index]=(data & 0x800) > 0;
inputSel[index]=(data >> 12) & 3;
int src=inputSrc[index]=srcMap[4 + index * 4 + inputSel[index]];
capMode[index]=(data >> 14) & 3;
if (!oldCapture && captureOn[index] && (src & SRC_PORT) != 0) {
int port=(src & 0xff) >> 4;
int pin=src & 0x0f;
IOPort ioPort=core.getIOPort(port);
System.out.println(getName() + ""String_Node_Str"" + port+ ""String_Node_Str""+ pin+ ""String_Node_Str"");
ioPort.setTimerCapture(this,pin);
}
updateCounter(cycles);
triggerInterrupts(cycles);
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ capNames[capMode[index]]+ ""String_Node_Str""+ inputSel[index]+ ""String_Node_Str""+ getSourceName(inputSrc[index])+ ""String_Node_Str""+ captureOn[index]+ ""String_Node_Str""+ ((data & CC_IE) != 0));
}
updateCaptures(index,cycles);
break;
case TCCR0:
case TCCR1:
case TCCR2:
case TCCR3:
case TCCR4:
case TCCR5:
case TCCR6:
index=(iAddress - TCCR0) / 2;
updateCounter(cycles);
if (index == 0) {
if (counter > data && (mode == UPDWN || mode == UP)) {
counter=0;
}
resetCounter(cycles);
}
tccr[index]=data;
int diff=data - counter;
if (diff < 0) {
diff+=0x10000;
}
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ Utils.hex16(counter)+ ""String_Node_Str""+ Utils.hex16(diff));
}
expCaptureTime[index]=cycles + (long)(cyclesMultiplicator * diff + 1) - counterPassed;
if (DEBUG && counterPassed > 0) {
System.out.println(getName() + ""String_Node_Str"" + counterPassed+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ index+ ""String_Node_Str""+ data+ ""String_Node_Str""+ diff+ ""String_Node_Str""+ cyclesMultiplicator+ ""String_Node_Str""+ expCaptureTime[index]);
}
counterPassed=0;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cycles+ ""String_Node_Str""+ index+ ""String_Node_Str""+ expCaptureTime[index]+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ data+ ""String_Node_Str""+ (100 * (cyclesMultiplicator * diff * 1L) / 2500000) / 100.0 + ""String_Node_Str"" + ""String_Node_Str"" + expCaptureTime[index]);
}
calculateNextEventTime(cycles);
}
}","public void write(int address,int data,boolean word,long cycles){
  if (address == TAIV || address == TBIV) {
    resetTIV(cycles);
  }
  int iAddress=address - offset;
switch (iAddress) {
case TR:
    setCounter(data,cycles);
  break;
case TCTL:
if (DEBUG) {
  System.out.println(getName() + ""String_Node_Str"" + Utils.hex16(data));
}
inputDivider=1 << ((data >> 6) & 3);
clockSource=srcMap[(data >> 8) & 3];
updateCyclesMultiplicator();
if ((data & TCLR) != 0) {
counter=0;
resetCounter(cycles);
updateCaptures(-1,cycles);
}
int newMode=(data >> 4) & 3;
if (mode == STOP && newMode != STOP) {
resetCounter(cycles);
nextTimerTrigger=(long)(cycles + cyclesMultiplicator * ((0xffff - counter) & 0xffff));
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"");
}
recalculateCompares(cycles);
}
mode=newMode;
interruptEnable=(data & 0x02) > 0;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ inputDivider+ ""String_Node_Str""+ getSourceName(clockSource)+ ""String_Node_Str""+ interruptEnable+ ""String_Node_Str""+ interruptPending+ ""String_Node_Str""+ mode+ ((data & TCLR) != 0 ? ""String_Node_Str"" : ""String_Node_Str""));
}
tctl=data;
tctl&=~0x04;
if ((data & 0x01) == 0) {
interruptPending=false;
}
updateCaptures(-1,cycles);
break;
case TCCTL0:
case TCCTL1:
case TCCTL2:
case TCCTL3:
case TCCTL4:
case TCCTL5:
case TCCTL6:
int index=(iAddress - TCCTL0) / 2;
tcctl[index]=data;
outMode[index]=(data >> 5) & 7;
boolean oldCapture=captureOn[index];
captureOn[index]=(data & 0x100) > 0;
sync[index]=(data & 0x800) > 0;
inputSel[index]=(data >> 12) & 3;
int src=inputSrc[index]=srcMap[4 + index * 4 + inputSel[index]];
capMode[index]=(data >> 14) & 3;
if (!oldCapture && captureOn[index] && (src & SRC_PORT) != 0) {
int port=(src & 0xff) >> 4;
int pin=src & 0x0f;
IOPort ioPort=core.getIOPort(port);
System.out.println(getName() + ""String_Node_Str"" + port+ ""String_Node_Str""+ pin+ ""String_Node_Str"");
ioPort.setTimerCapture(this,pin);
}
updateCounter(cycles);
triggerInterrupts(cycles);
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ capNames[capMode[index]]+ ""String_Node_Str""+ inputSel[index]+ ""String_Node_Str""+ getSourceName(inputSrc[index])+ ""String_Node_Str""+ captureOn[index]+ ""String_Node_Str""+ ((data & CC_IE) != 0));
}
updateCaptures(index,cycles);
break;
case TCCR0:
case TCCR1:
case TCCR2:
case TCCR3:
case TCCR4:
case TCCR5:
case TCCR6:
index=(iAddress - TCCR0) / 2;
updateCounter(cycles);
if (index == 0) {
if (counter > data && (mode == UPDWN || mode == UP)) {
counter=0;
}
resetCounter(cycles);
}
tccr[index]=data;
int diff=data - counter;
if (diff < 0) {
diff+=0x10000;
}
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ Utils.hex16(counter)+ ""String_Node_Str""+ Utils.hex16(diff));
}
expCaptureTime[index]=cycles + (long)(cyclesMultiplicator * diff + 1) - counterPassed;
if (DEBUG && counterPassed > 0) {
System.out.println(getName() + ""String_Node_Str"" + counterPassed+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ index+ ""String_Node_Str""+ data+ ""String_Node_Str""+ diff+ ""String_Node_Str""+ cyclesMultiplicator+ ""String_Node_Str""+ expCaptureTime[index]);
}
counterPassed=0;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cycles+ ""String_Node_Str""+ index+ ""String_Node_Str""+ expCaptureTime[index]+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ data+ ""String_Node_Str""+ (100 * (cyclesMultiplicator * diff * 1L) / 2500000) / 100.0 + ""String_Node_Str"" + ""String_Node_Str"" + expCaptureTime[index]);
}
calculateNextEventTime(cycles);
}
}",0.9904109589041096
5652,"public static boolean isELF(File file){
  InputStream input=null;
  try {
    input=new FileInputStream(file);
    for (int i=0; i < MAGIC.length; i++) {
      if (MAGIC[i] != input.read()) {
        return false;
      }
    }
  }
 catch (  IOException ioe) {
  }
 finally {
    if (input != null) {
      try {
        input.close();
      }
 catch (      Exception e) {
      }
    }
  }
  return true;
}","public static boolean isELF(File file){
  InputStream input=null;
  try {
    input=new FileInputStream(file);
    for (int i=0; i < MAGIC.length; i++) {
      if (MAGIC[i] != input.read()) {
        return false;
      }
    }
  }
 catch (  IOException ioe) {
    return false;
  }
 finally {
    if (input != null) {
      try {
        input.close();
      }
 catch (      Exception e) {
      }
    }
  }
  return true;
}",0.9783653846153846
5653,"public void interruptServiced(int vector){
}","public void interruptServiced(int vector){
  irqTriggered[vector]=false;
  int pos=irqTriggeredPos[vector];
  int bit=pos & 7;
  if (pos > 8) {
    ifg1&=~(1 << bit);
  }
 else {
    ifg2&=~(1 << bit);
  }
  cpu.flagInterrupt(vector,this,false);
  if (sfrModule[pos] != null) {
    sfrModule[pos].interruptServiced(vector);
  }
}",0.2359249329758713
5654,"private void updateIRQ(int pos,int change){
  int ifg=pos == 0 ? ifg1 : ifg2;
  int ie=pos == 0 ? ie1 : ie2;
  pos=pos * 8;
  for (int i=0; i < 8; i++) {
    if ((change & 1) == 1) {
      if (sfrModule[pos] != null) {
        if (DEBUG)         System.out.println(""String_Node_Str"" + sfrModule[pos].getName() + ""String_Node_Str""+ (ie & ifg & 1));
        cpu.flagInterrupt(irqVector[pos],sfrModule[pos],(ie & ifg & 1) > 0);
      }
    }
    pos++;
    change=change >> 1;
    ifg=ifg >> 1;
    ie=ie >> 1;
  }
}","private void updateIRQ(int pos,int change){
  int ifg=pos == 0 ? ifg1 : ifg2;
  int ie=pos == 0 ? ie1 : ie2;
  pos=pos * 8;
  for (int i=0; i < 8; i++) {
    if ((change & 1) == 1) {
      if (sfrModule[pos] != null && !irqTriggered[irqVector[pos]]) {
        if (DEBUG)         System.out.println(""String_Node_Str"" + sfrModule[pos].getName() + ""String_Node_Str""+ pos+ ""String_Node_Str""+ (ie & ifg & 1)+ ""String_Node_Str""+ change);
        if ((ie & ifg & 1) > 0) {
          int vector=irqVector[pos];
          irqTriggered[vector]=true;
          irqTriggeredPos[vector]=pos;
          cpu.flagInterrupt(irqVector[pos],this,true);
        }
      }
    }
    pos++;
    change=change >> 1;
    ifg=ifg >> 1;
    ie=ie >> 1;
  }
}",0.7309236947791165
5655,"public void reset(int type){
  ie1=0;
  ie2=0;
  ifg1=0;
  ifg2=0;
  me1=0;
  me2=0;
}","public void reset(int type){
  ie1=0;
  ie2=0;
  ifg1=0;
  ifg2=0;
  me1=0;
  me2=0;
  for (int i=0; i < irqTriggered.length; i++) {
    irqTriggered[i]=false;
  }
}",0.6852589641434262
5656,"public void interruptServiced(int vector){
  cpu.flagInterrupt(vector,this,false);
}","public void interruptServiced(int vector){
}",0.6875
5657,"public int read(int address,boolean word,long cycles){
  address=address - offset;
switch (address) {
case UCTL:
    if (DEBUG)     System.out.println(getName() + ""String_Node_Str"");
  return uctl;
case UTCTL:
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + utctl);
return utctl;
case URCTL:
return urctl;
case UMCTL:
return umctl;
case UBR0:
return ubr0;
case UBR1:
return ubr1;
case UTXBUF:
return utxbuf;
case URXBUF:
int tmp=urxbuf;
if (MSP430Constants.DEBUGGING_LEVEL > 0) {
System.out.println(getName() + ""String_Node_Str"");
}
clrBitIFG(urxifg);
if (listener != null) {
listener.stateChanged(USARTListener.RXFLAG_CLEARED);
}
return tmp;
}
return 0;
}","public int read(int address,boolean word,long cycles){
  address=address - offset;
switch (address) {
case UCTL:
    if (DEBUG)     System.out.println(getName() + ""String_Node_Str"");
  return uctl;
case UTCTL:
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + utctl);
return utctl;
case URCTL:
return urctl;
case UMCTL:
return umctl;
case UBR0:
return ubr0;
case UBR1:
return ubr1;
case UTXBUF:
return utxbuf;
case URXBUF:
int tmp=urxbuf;
if (MSP430Constants.DEBUGGING_LEVEL > 0) {
System.out.println(getName() + ""String_Node_Str"" + cpu.getPC());
}
clrBitIFG(urxifg);
if (listener != null) {
listener.stateChanged(USARTListener.RXFLAG_CLEARED);
}
return tmp;
}
return 0;
}",0.9896602658788776
5658,"/** 
 * Creates a new <code>USART</code> instance.
 */
public USART(MSP430Core cpu,int[] memory,int offset){
  super(memory,offset);
  this.cpu=cpu;
  sfr=cpu.getSFR();
  if (offset == 0x78) {
    uartID=1;
  }
  if (uartID == 0) {
    sfr.registerSFDModule(0,USART0_RX_BIT,this,USART0_RX_VEC);
    sfr.registerSFDModule(0,USART0_TX_BIT,this,USART0_TX_VEC);
    utxifg=UTXIFG0;
    urxifg=URXIFG0;
    txbit=USART0_TX_BIT;
  }
 else {
    sfr.registerSFDModule(1,USART1_RX_BIT,this,USART1_RX_VEC);
    sfr.registerSFDModule(1,USART1_TX_BIT,this,USART1_TX_VEC);
    utxifg=UTXIFG1;
    urxifg=URXIFG1;
    txbit=USART1_TX_BIT;
  }
  reset(0);
}","/** 
 * Creates a new <code>USART</code> instance.
 */
public USART(MSP430Core cpu,int[] memory,int offset){
  super(memory,offset);
  this.cpu=cpu;
  sfr=cpu.getSFR();
  if (offset == 0x78) {
    uartID=1;
  }
  if (uartID == 0) {
    sfr.registerSFDModule(0,USART0_RX_BIT,this,USART0_RX_VEC);
    sfr.registerSFDModule(0,USART0_TX_BIT,this,USART0_TX_VEC);
    utxifg=UTXIFG0;
    urxifg=URXIFG0;
    txbit=USART0_TX_BIT;
    rxVector=USART0_RX_VEC;
  }
 else {
    sfr.registerSFDModule(1,USART1_RX_BIT,this,USART1_RX_VEC);
    sfr.registerSFDModule(1,USART1_TX_BIT,this,USART1_TX_VEC);
    utxifg=UTXIFG1;
    urxifg=URXIFG1;
    txbit=USART1_TX_BIT;
    rxVector=USART1_RX_VEC;
  }
  reset(0);
}",0.9582712369597616
5659,"public void reset(int type){
  nextTXReady=cpu.cycles + 1000;
  nextTXByte=-1;
  clrBitIFG(utxifg | urxifg);
  utctl|=UTCTL_TXEMPTY;
  cpu.scheduleCycleEvent(txTrigger,nextTXReady);
  txEnabled=false;
  rxEnabled=false;
}","public void reset(int type){
  nextTXReady=cpu.cycles + 100;
  nextTXByte=-1;
  clrBitIFG(utxifg | urxifg);
  utctl|=UTCTL_TXEMPTY;
  cpu.scheduleCycleEvent(txTrigger,nextTXReady);
  txEnabled=false;
  rxEnabled=false;
}",0.9977324263038548
5660,"public boolean emulateOP(long maxCycles) throws EmulationException {
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (cycles >= nextEventCycles) {
    executeEvents();
  }
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff) {
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return false;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return false;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad > AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
}
cycles+=3;
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
cycles+=(ad == AM_REG || ad == AM_IND_AUTOINC) ? 2 : 1;
write=false;
updateStatus=false;
break;
case CALL:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
cycles+=(ad == AM_REG) ? 3 : (ad == AM_IND_AUTOINC) ? 2 : 1;
if (profiler != null) {
MapEntry function=map.getEntry(dst);
if (function == null) {
function=getFunction(map,dst);
}
profiler.profileCall(function,cpuCycles);
}
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
cycles+=4;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
if (profiler != null) {
profiler.profileRETI(cycles);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as > AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
if (dstRegister == PC) cycles++;
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=dstRegMode ? 2 : 5;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
if (dstRegister == PC) {
cycles++;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
if (op != MOV) dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
if (instruction == RETURN && profiler != null) {
profiler.profileReturn(cpuCycles);
}
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=(dst - src);
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
dst=src ^ dst;
write=true;
break;
case AND:
dst=src & dst;
write=true;
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
if (EXCEPTION_ON_BAD_OPERATION) {
EmulationException ex=new EmulationException(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
ex.initCause(new Throwable(""String_Node_Str"" + pc));
throw ex;
}
}
}
if (word) {
dst&=0xffff;
}
 else {
dst&=0xff;
}
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
cpuCycles+=cycles - startCycles;
return true;
}","public boolean emulateOP(long maxCycles) throws EmulationException {
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (cycles >= nextEventCycles) {
    executeEvents();
  }
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff) {
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return false;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return false;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad > AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
}
cycles+=3;
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SXT:
sr=readRegister(SR);
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
cycles+=(ad == AM_REG || ad == AM_IND_AUTOINC) ? 2 : 1;
write=false;
updateStatus=false;
break;
case CALL:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
cycles+=(ad == AM_REG) ? 3 : (ad == AM_IND_AUTOINC) ? 2 : 1;
if (profiler != null) {
MapEntry function=map.getEntry(dst);
if (function == null) {
function=getFunction(map,dst);
}
profiler.profileCall(function,cpuCycles);
}
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
cycles+=4;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
if (profiler != null) {
profiler.profileRETI(cycles);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
updateStatus=false;
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as > AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
if (dstRegister == PC) cycles++;
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=dstRegMode ? 2 : 5;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
if (dstRegister == PC) {
cycles++;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
if (op != MOV) dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
if (instruction == RETURN && profiler != null) {
profiler.profileReturn(cpuCycles);
}
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=(dst - src);
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if ((src & (word ? 0x8000 : 0x80)) != 0 && (dst & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
dst=src ^ dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
case AND:
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
dst=src & dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
if (EXCEPTION_ON_BAD_OPERATION) {
EmulationException ex=new EmulationException(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
ex.initCause(new Throwable(""String_Node_Str"" + pc));
throw ex;
}
}
}
if (word) {
dst&=0xffff;
}
 else {
dst&=0xff;
}
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
cpuCycles+=cycles - startCycles;
return true;
}",0.9718571857185718
5661,"public void setPacketData(IPv6Packet packet,byte[] data,int len){
  int pos=2;
  if ((data[0] & 0x40) == 0) {
    if ((data[0] & 0x80) == 0) {
      packet.version=(data[pos] & 0xf0) >> 4;
      packet.trafficClass=((data[pos] & 0x0f) << 4) + ((data[pos + 1] & 0xff) >> 4);
      packet.flowLabel=(data[pos + 1] & 0x0f) << 16 + (data[pos + 2] & 0xff) << 8 + data[pos + 3] & 0xff;
      pos+=4;
    }
 else {
      packet.version=6;
      packet.trafficClass=0;
      packet.flowLabel=(data[pos] & 0x0f) << 16 + (data[pos + 1] & 0xff) << 8 + data[pos + 2] & 0xff;
      ;
      pos+=3;
    }
  }
 else {
    packet.version=6;
    packet.flowLabel=0;
    if ((data[0] & 0x80) == 0) {
      packet.trafficClass=(data[pos] & 0xff);
      pos++;
    }
 else {
      packet.trafficClass=0;
    }
  }
  if ((data[0] & 0x20) == 0) {
    packet.nextHeader=data[pos++];
  }
switch (data[0] & 0x18) {
case IPHC_TTL_1:
    packet.hopLimit=1;
  break;
case IPHC_TTL_64:
packet.hopLimit=64;
break;
case IPHC_TTL_255:
packet.hopLimit=0xff;
break;
case IPHC_TTL_I:
packet.hopLimit=data[pos++];
break;
}
int srcAddress=(data[1] & 0x30) >> 4;
AddrContext context=lookupContext(srcAddress);
switch (data[1] & 0xc0) {
case IPHC_SAM_0:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.sourceAddress,0,8);
byte[] linkAddress=getLinkSourceAddress(packet);
System.arraycopy(linkAddress,0,packet.sourceAddress,8,8);
break;
case IPHC_SAM_16:
if ((data[pos] & 0x80) == 0) {
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.sourceAddress,0,8);
java.util.Arrays.fill(packet.sourceAddress,8,14,(byte)0);
packet.sourceAddress[14]=data[pos];
packet.sourceAddress[15]=data[pos + 1];
pos+=2;
}
 else {
java.util.Arrays.fill(packet.sourceAddress,0,16,(byte)0);
packet.sourceAddress[0]=(byte)0xff;
packet.sourceAddress[1]=(byte)(((data[pos] & 0xff) >> 1) & 0x0f);
packet.sourceAddress[15]=data[pos + 1];
pos+=2;
}
break;
case IPHC_SAM_64:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.sourceAddress,0,8);
System.arraycopy(data,pos,packet.sourceAddress,8,8);
pos+=8;
break;
case IPHC_SAM_I:
System.arraycopy(data,pos,packet.sourceAddress,0,16);
pos+=16;
break;
}
context=lookupContext(data[2] & 0x03);
switch (data[1] & 0x0C) {
case IPHC_DAM_0:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.destAddress,0,8);
byte[] destAddress=getLinkDestinationAddress(packet);
System.arraycopy(destAddress,0,packet.destAddress,8,8);
break;
case IPHC_DAM_16:
if ((data[pos] & 0x80) == 0) {
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.destAddress,0,8);
packet.destAddress[14]=data[pos];
packet.destAddress[15]=data[pos + 1];
pos+=2;
}
 else {
System.out.println(""String_Node_Str"");
java.util.Arrays.fill(packet.destAddress,0,16,(byte)0);
packet.destAddress[0]=(byte)0xff;
packet.destAddress[1]=(byte)(((data[pos] & 0xff) >> 1) & 0x0F);
packet.destAddress[15]=data[pos + 1];
pos+=2;
}
break;
case IPHC_DAM_64:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.destAddress,0,8);
System.arraycopy(data,pos,packet.destAddress,8,8);
pos+=8;
break;
case IPHC_DAM_I:
System.arraycopy(data,pos,packet.destAddress,0,16);
pos+=16;
break;
}
if ((data[0] & 0x20) != 0) {
if ((data[pos] & 0xfc) == NHC_UDP_ID) {
packet.nextHeader=PROTO_UDP;
int srcPort=0;
int destPort=0;
int checkSum=0;
switch (data[pos] & 0xff) {
case NHC_UDP_C:
srcPort=UDP_PORT_MIN + (data[pos + 1] >> 4);
destPort=UDP_PORT_MIN + (data[pos + 1] & 0x0F);
checkSum=(data[pos + 2] << 8) + data[pos + 3];
pos+=4;
break;
case NHC_UDP_I:
srcPort=((data[pos + 1] & 0xff) << 8) + (data[pos + 2] & 0xff);
destPort=((data[pos + 3] & 0xff) << 8) + (data[pos + 4] & 0xff);
checkSum=((data[pos + 5] & 0xff) << 8) + (data[pos + 6] & 0xff);
pos+=7;
break;
default :
System.out.println(""String_Node_Str"");
return;
}
System.out.println(""String_Node_Str"" + destPort);
System.out.println(""String_Node_Str"" + srcPort);
System.out.println(""String_Node_Str"" + srcPort);
}
}
boolean frag=false;
if (!frag) {
int plen=len - pos;
packet.setPayload(data,pos,plen);
}
 else {
}
System.out.println(""String_Node_Str"" + Utils.hex8(data[0]) + ""String_Node_Str""+ Utils.hex8(data[1]));
System.out.println(""String_Node_Str"" + packet.hopLimit);
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.sourceAddress);
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.destAddress);
System.out.println();
}","public void setPacketData(IPv6Packet packet,byte[] data,int len){
  int pos=2;
  if ((data[0] & 0x40) == 0) {
    if ((data[0] & 0x80) == 0) {
      packet.version=(data[pos] & 0xf0) >> 4;
      packet.trafficClass=((data[pos] & 0x0f) << 4) + ((data[pos + 1] & 0xff) >> 4);
      packet.flowLabel=(data[pos + 1] & 0x0f) << 16 + (data[pos + 2] & 0xff) << 8 + data[pos + 3] & 0xff;
      pos+=4;
    }
 else {
      packet.version=6;
      packet.trafficClass=0;
      packet.flowLabel=(data[pos] & 0x0f) << 16 + (data[pos + 1] & 0xff) << 8 + data[pos + 2] & 0xff;
      ;
      pos+=3;
    }
  }
 else {
    packet.version=6;
    packet.flowLabel=0;
    if ((data[0] & 0x80) == 0) {
      packet.trafficClass=(data[pos] & 0xff);
      pos++;
    }
 else {
      packet.trafficClass=0;
    }
  }
  if ((data[0] & 0x20) == 0) {
    packet.nextHeader=data[pos++];
  }
switch (data[0] & 0x18) {
case IPHC_TTL_1:
    packet.hopLimit=1;
  break;
case IPHC_TTL_64:
packet.hopLimit=64;
break;
case IPHC_TTL_255:
packet.hopLimit=0xff;
break;
case IPHC_TTL_I:
packet.hopLimit=data[pos++];
break;
}
int srcAddress=(data[1] & 0x30) >> 4;
AddrContext context=lookupContext(srcAddress);
switch (data[1] & 0xc0) {
case IPHC_SAM_0:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.sourceAddress,0,8);
byte[] linkAddress=getLinkSourceAddress(packet);
System.arraycopy(linkAddress,0,packet.sourceAddress,8,8);
break;
case IPHC_SAM_16:
if ((data[pos] & 0x80) == 0) {
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.sourceAddress,0,8);
java.util.Arrays.fill(packet.sourceAddress,8,14,(byte)0);
packet.sourceAddress[14]=data[pos];
packet.sourceAddress[15]=data[pos + 1];
pos+=2;
}
 else {
java.util.Arrays.fill(packet.sourceAddress,0,16,(byte)0);
packet.sourceAddress[0]=(byte)0xff;
packet.sourceAddress[1]=(byte)(((data[pos] & 0xff) >> 1) & 0x0f);
packet.sourceAddress[15]=data[pos + 1];
pos+=2;
}
break;
case IPHC_SAM_64:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.sourceAddress,0,8);
System.arraycopy(data,pos,packet.sourceAddress,8,8);
pos+=8;
break;
case IPHC_SAM_I:
System.arraycopy(data,pos,packet.sourceAddress,0,16);
pos+=16;
break;
}
context=lookupContext(data[2] & 0x03);
switch (data[1] & 0x0C) {
case IPHC_DAM_0:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.destAddress,0,8);
byte[] destAddress=getLinkDestinationAddress(packet);
System.arraycopy(destAddress,0,packet.destAddress,8,8);
break;
case IPHC_DAM_16:
if ((data[pos] & 0x80) == 0) {
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.destAddress,0,8);
packet.destAddress[14]=data[pos];
packet.destAddress[15]=data[pos + 1];
pos+=2;
}
 else {
System.out.println(""String_Node_Str"");
java.util.Arrays.fill(packet.destAddress,0,16,(byte)0);
packet.destAddress[0]=(byte)0xff;
packet.destAddress[1]=(byte)(((data[pos] & 0xff) >> 1) & 0x0F);
packet.destAddress[15]=data[pos + 1];
pos+=2;
}
break;
case IPHC_DAM_64:
if (context == null) {
System.out.println(""String_Node_Str"");
return;
}
System.arraycopy(context.prefix,0,packet.destAddress,0,8);
System.arraycopy(data,pos,packet.destAddress,8,8);
pos+=8;
break;
case IPHC_DAM_I:
System.arraycopy(data,pos,packet.destAddress,0,16);
pos+=16;
break;
}
if ((data[0] & 0x20) != 0) {
if ((data[pos] & 0xfc) == NHC_UDP_ID) {
packet.nextHeader=PROTO_UDP;
int srcPort=0;
int destPort=0;
int checkSum=0;
switch (data[pos] & 0xff) {
case NHC_UDP_C:
srcPort=UDP_PORT_MIN + ((data[pos + 1] & 0xff) >> 4);
destPort=UDP_PORT_MIN + (data[pos + 1] & 0x0F);
checkSum=((data[pos + 2] & 0xff) << 8) + (data[pos + 3] & 0xff);
pos+=4;
break;
case NHC_UDP_I:
srcPort=((data[pos + 1] & 0xff) << 8) + (data[pos + 2] & 0xff);
destPort=((data[pos + 3] & 0xff) << 8) + (data[pos + 4] & 0xff);
checkSum=((data[pos + 5] & 0xff) << 8) + (data[pos + 6] & 0xff);
pos+=7;
break;
default :
System.out.println(""String_Node_Str"");
return;
}
System.out.println(""String_Node_Str"" + destPort);
System.out.println(""String_Node_Str"" + srcPort);
System.out.println(""String_Node_Str"" + srcPort);
}
}
boolean frag=false;
if (!frag) {
int plen=len - pos;
packet.setPayload(data,pos,plen);
}
 else {
}
System.out.println(""String_Node_Str"" + Utils.hex8(data[0]) + ""String_Node_Str""+ Utils.hex8(data[1]));
System.out.println(""String_Node_Str"" + packet.hopLimit);
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.sourceAddress);
System.out.print(""String_Node_Str"");
IPv6Packet.printAddress(System.out,packet.destAddress);
System.out.println();
}",0.9971479877469104
5662,"public void setPayloadPacket(Packet packet){
  payloadPacket=packet;
}","public void setPayloadPacket(Packet packet){
  payloadPacket=packet;
  if (packet.getContainerPacket() != this) {
    packet.setContainerPacket(this);
  }
}",0.6194690265486725
5663,"public void setContainerPacket(Packet packet){
  containerPacket=packet;
}","public void setContainerPacket(Packet packet){
  containerPacket=packet;
  if (packet.getPayloadPacket() != this) {
    packet.setPayloadPacket(this);
  }
}",0.6434782608695652
5664,"public IEEE802154Packet(Packet container){
  byte[] payload=container.getPayload();
  setPacketData(container,payload,payload.length);
}","public IEEE802154Packet(){
}",0.3414634146341463
5665,"public boolean isDestinationMACBased(){
  return false;
}","public boolean isDestinationMACBased(){
  byte[] macAddress=containerPacket.getDestinationAddress();
  return isMACBased(destAddress,macAddress);
}",0.5392156862745098
5666,"public boolean isSourceMACBased(){
  return false;
}","public boolean isSourceMACBased(){
  byte[] macAddress=containerPacket.getSourceAddress();
  return isMACBased(sourceAddress,macAddress);
}",0.5235602094240838
5667,"public static int checkSum(int sum,byte[] data,int size){
  for (int i=0; i < size; i+=2) {
    int dsum=((data[i] & 0xff) << 8) | (data[i + 1] & 0xff);
    sum=(sum + dsum) & 0xffff;
    if (sum < dsum)     sum++;
  }
  if ((size & 1) > 0) {
    int dsum=((data[size - 1] & 0xff) << 8);
    sum=(sum + dsum) & 0xffff;
    if (sum < dsum)     sum++;
  }
  return sum;
}","public static int checkSum(int sum,byte[] data,int size){
  for (int i=0; i < size - 1; i+=2) {
    int dsum=((data[i] & 0xff) << 8) | (data[i + 1] & 0xff);
    sum=(sum + dsum) & 0xffff;
    if (sum < dsum)     sum++;
  }
  if ((size & 1) > 0) {
    int dsum=((data[size - 1] & 0xff) << 8);
    sum=(sum + dsum) & 0xffff;
    if (sum < dsum)     sum++;
  }
  return sum;
}",0.9946091644204852
5668,"public void sendPacket(Packet payload){
}","public void sendPacket(Packet payload){
  if (payload instanceof IPv6Packet) {
    IEEE802154Packet p=new IEEE802154Packet();
  }
}",0.4767441860465116
5669,"public void notifyPacketHandlers(byte[] payload,int len){
  for (int i=0; i < packetHandlers.size(); i++) {
    try {
      packetHandlers.get(i).setPacketData(payload,len);
    }
 catch (    Exception e) {
    }
  }
}","public void notifyPacketHandlers(byte[] payload,int len){
  for (int i=0; i < packetHandlers.size(); i++) {
    try {
      packetHandlers.get(i).setPacketData(this,payload,len);
    }
 catch (    Exception e) {
    }
  }
}",0.9886621315192744
5670,"public void setPacketData(byte[] data,int plen){
  if (data.length > PREAMBLE.length) {
    int pos=0;
    for (int i=0; i < PREAMBLE.length; i++) {
      if (data[i] != PREAMBLE[i]) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      pos++;
    }
    len=data[pos] & 0xff;
    if (len + 5 <= plen) {
      payload=new byte[len & 0xff];
      System.arraycopy(data,pos + 1,payload,0,len);
      System.out.println(""String_Node_Str"");
      valid=true;
      notifyPacketHandlers(payload,payload.length);
      return;
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
}","public void setPacketData(Packet container,byte[] data,int plen){
  if (data.length > PREAMBLE.length) {
    int pos=0;
    for (int i=0; i < PREAMBLE.length; i++) {
      if (data[i] != PREAMBLE[i]) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      pos++;
    }
    len=data[pos] & 0xff;
    if (len + 5 <= plen) {
      payload=new byte[len & 0xff];
      System.arraycopy(data,pos + 1,payload,0,len);
      System.out.println(""String_Node_Str"");
      valid=true;
      notifyPacketHandlers(payload,payload.length);
      return;
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
}",0.9865824782951856
5671,"public void printPacket(PrintStream out){
  if (valid) {
    out.println(""String_Node_Str"" + len + ""String_Node_Str"");
  }
}","public void printPacket(PrintStream out){
  if (valid) {
    out.print(""String_Node_Str"" + len + ""String_Node_Str"");
    for (int i=0; i < len; i++) {
      out.printf(""String_Node_Str"",payload[i] & 0xff);
      if ((i & 3) == 3) {
        out.print(""String_Node_Str"");
      }
    }
    out.println();
  }
}",0.5648148148148148
5672,"public void receivedByte(byte data){
  packetBuffer[pos++]=data;
switch (mode) {
case SFD_SEARCH:
    if (sfdSearch < 4 && data == 0)     sfdSearch++;
  if (sfdSearch == 4 && data == 0x7a) {
    mode=LEN;
    sfdSearch=0;
  }
break;
case LEN:
mode=PACKET;
packetLen=data & 0xff;
System.out.println(""String_Node_Str"" + packetLen);
break;
case PACKET:
if (pos == packetLen + PREAMBLE.length + 1) {
setPacketData(packetBuffer,pos);
mode=SFD_SEARCH;
}
break;
}
}","public void receivedByte(byte data){
  packetBuffer[pos++]=data;
switch (mode) {
case SFD_SEARCH:
    if (sfdSearch < 4 && data == 0)     sfdSearch++;
  if (sfdSearch == 4 && data == 0x7a) {
    mode=LEN;
    sfdSearch=0;
  }
break;
case LEN:
mode=PACKET;
packetLen=data & 0xff;
System.out.println(""String_Node_Str"" + packetLen);
break;
case PACKET:
if (pos == packetLen + PREAMBLE.length + 1) {
setPacketData(this,packetBuffer,pos);
mode=SFD_SEARCH;
}
break;
}
}",0.99457111834962
5673,"public static void main(String[] args){
  CC2420Packet p=new CC2420Packet();
  p.addInnerPacketHandler(new IEEE802154Packet());
  int[] data=new int[]{0,0,0,0,0x7a,48,0x41,0xCC,0x74,0xCD,0xAB,0x55,0x44,0x33,0xFE,0xFF,0x22,0x11,0x02,0x16,0x15,0x14,0xFE,0xFF,0x13,0x12,0x02,0x03,0xC0,0x9D,0x06,0x80,0x00,0x01,0xAD,0x39,0x00,0x50,0xAE,0xC4,0x9D,0xC6,0x00,0x00,0x00,0x01,0x50,0x10,0x13,0x10,0xE7,0xBF,0x00,0x00};
  for (int i=0; i < data.length; i++) {
    p.receivedByte((byte)(data[i] & 0xff));
  }
  p.printPacketStack(System.out);
}","public static void main(String[] args){
  CC2420Packet p=new CC2420Packet();
  IEEE802154Packet p2=new IEEE802154Packet();
  p.addInnerPacketHandler(p2);
  p2.addInnerPacketHandler(new HC01Packet());
  int[] data=new int[]{0,0,0,0,0x7a,48,0x41,0xCC,0x74,0xCD,0xAB,0x55,0x44,0x33,0xFE,0xFF,0x22,0x11,0x02,0x16,0x15,0x14,0xFE,0xFF,0x13,0x12,0x02,0x03,0xC0,0x9D,0x06,0x80,0x00,0x01,0xAD,0x39,0x00,0x50,0xAE,0xC4,0x9D,0xC6,0x00,0x00,0x00,0x01,0x50,0x10,0x13,0x10,0xE7,0xBF,0x00,0x00};
  for (int i=0; i < data.length; i++) {
    p.receivedByte((byte)(data[i] & 0xff));
  }
  p.printPacketStack(System.out);
}",0.9190140845070424
5674,"public boolean emulateOP(long maxCycles) throws EmulationException {
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (cycles >= nextEventCycles) {
    executeEvents();
  }
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff || flash.blocksCPU()) {
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return false;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return false;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad > AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
}
cycles+=3;
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SXT:
sr=readRegister(SR);
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
cycles+=(ad == AM_REG || ad == AM_IND_AUTOINC) ? 2 : 1;
write=false;
updateStatus=false;
break;
case CALL:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
cycles+=(ad == AM_REG) ? 3 : (ad == AM_IND_AUTOINC) ? 2 : 1;
if (profiler != null) {
MapEntry function=map.getEntry(dst);
if (function == null) {
function=getFunction(map,dst);
}
profiler.profileCall(function,cpuCycles);
}
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
cycles+=4;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
if (profiler != null) {
profiler.profileRETI(cycles);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
updateStatus=false;
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as > AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
if (dstRegister == PC) cycles++;
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=dstRegMode ? 2 : 5;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
if (dstRegister == PC) {
cycles++;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
if (op != MOV) dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
if (instruction == RETURN && profiler != null) {
profiler.profileReturn(cpuCycles);
}
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=(dst - src);
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if ((src & (word ? 0x8000 : 0x80)) != 0 && (dst & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
dst=src ^ dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
case AND:
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
dst=src & dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
if (EXCEPTION_ON_BAD_OPERATION) {
EmulationException ex=new EmulationException(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
ex.initCause(new Throwable(""String_Node_Str"" + pc));
throw ex;
}
}
}
if (word) {
dst&=0xffff;
}
 else {
dst&=0xff;
}
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
cpuCycles+=cycles - startCycles;
return true;
}","public boolean emulateOP(long maxCycles) throws EmulationException {
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (cycles >= nextEventCycles) {
    executeEvents();
  }
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff || flash.blocksCPU()) {
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return false;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return false;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH || op == CALL) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad > AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
}
cycles+=3;
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~(CARRY | OVERFLOW)) | nxtCarry);
break;
case SXT:
sr=readRegister(SR);
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
cycles+=(ad == AM_REG || ad == AM_IND_AUTOINC) ? 2 : 1;
write=false;
updateStatus=false;
break;
case CALL:
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
cycles+=(ad == AM_REG) ? 3 : (ad == AM_IND_AUTOINC) ? 2 : 1;
if (profiler != null) {
MapEntry function=map.getEntry(dst);
if (function == null) {
function=getFunction(map,dst);
}
profiler.profileCall(function,cpuCycles);
}
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
cycles+=4;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
if (profiler != null) {
profiler.profileRETI(cycles);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
updateStatus=false;
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as > AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
if (dstRegister == PC) cycles++;
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=dstRegMode ? 2 : 5;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
if (dstRegister == PC) {
cycles++;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
if (op != MOV) dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
if (instruction == RETURN && profiler != null) {
profiler.profileReturn(cpuCycles);
}
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=(dst - src);
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if ((src & (word ? 0x8000 : 0x80)) != 0 && (dst & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
dst=src ^ dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
case AND:
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
dst=src & dst;
if (dst != 0) {
sr|=CARRY;
}
write=true;
writeRegister(SR,sr);
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
if (EXCEPTION_ON_BAD_OPERATION) {
EmulationException ex=new EmulationException(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
ex.initCause(new Throwable(""String_Node_Str"" + pc));
throw ex;
}
}
}
if (word) {
dst&=0xffff;
}
 else {
dst&=0xff;
}
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
cpuCycles+=cycles - startCycles;
return true;
}",0.9964371239997664
5675,"public void profileRETI(long cycles){
  if (servicedInterrupt > -1) {
    interruptTime[servicedInterrupt]+=cycles - lastInterruptTime[servicedInterrupt];
    interruptCount[servicedInterrupt]++;
  }
  newIRQ=false;
  if (logger != null && !hideIRQ) {
    logger.println(""String_Node_Str"" + servicedInterrupt + ""String_Node_Str""+ (cycles - lastInterruptTime[servicedInterrupt]));
    interruptLevel=0;
  }
  servicedInterrupt=-1;
}","public void profileRETI(long cycles){
  if (servicedInterrupt > -1) {
    interruptTime[servicedInterrupt]+=cycles - lastInterruptTime[servicedInterrupt];
    interruptCount[servicedInterrupt]++;
  }
  newIRQ=false;
  if (logger != null && !hideIRQ) {
    logger.println(""String_Node_Str"" + servicedInterrupt + ""String_Node_Str""+ (cycles - lastInterruptTime[servicedInterrupt]));
  }
  interruptLevel=0;
  servicedInterrupt=-1;
}",0.9930232558139536
5676,"public int read(int address,boolean word,long cycles){
switch (address) {
case ADC12CTL0:
    return adc12ctl0;
case ADC12CTL1:
  return adc12ctl1;
case ADC12IE:
return adc12ie;
case ADC12IFG:
return adc12ifg;
default :
if (address >= ADC12MCTL0 && address <= ADC12MCTL15) {
return adc12mctl[address - ADC12MCTL0];
}
 else if (address >= ADC12MEM0) {
int reg=address - ADC12MEM0;
adc12ifg&=~(1 << reg);
if (adc12iv == reg + 6) {
core.flagInterrupt(adc12Vector,this,false);
adc12iv=0;
}
return adc12mem[reg];
}
}
return 0;
}","public int read(int address,boolean word,long cycles){
switch (address) {
case ADC12CTL0:
    return adc12ctl0;
case ADC12CTL1:
  return adc12ctl1;
case ADC12IE:
return adc12ie;
case ADC12IFG:
return adc12ifg;
default :
if (address >= ADC12MCTL0 && address <= ADC12MCTL15) {
return adc12mctl[address - ADC12MCTL0];
}
 else if (address >= ADC12MEM0) {
int reg=(address - ADC12MEM0) / 2;
adc12ifg&=~(1 << reg);
if (adc12iv == reg * 2 + 6) {
core.flagInterrupt(adc12Vector,this,false);
adc12iv=0;
}
return adc12mem[reg];
}
}
return 0;
}",0.990530303030303
5677,"public TimeEvent popFirst(){
  TimeEvent tmp=first;
  if (tmp != null) {
    first=tmp.nextEvent;
    tmp.nextEvent=null;
  }
  if (first != null) {
    nextTime=first.time;
  }
 else {
    nextTime=0;
  }
  tmp.scheduledIn=null;
  eventCount--;
  return tmp;
}","public TimeEvent popFirst(){
  TimeEvent tmp=first;
  if (tmp != null) {
    first=tmp.nextEvent;
    tmp.nextEvent=null;
    tmp.scheduledIn=null;
  }
  if (first != null) {
    nextTime=first.time;
  }
 else {
    nextTime=0;
  }
  eventCount--;
  return tmp;
}",0.683206106870229
5678,"private void txNext(){
  if (txfifoPos <= memory[RAM_TXFIFO]) {
    if (listener != null) {
      if (DEBUG)       log(""String_Node_Str"" + Utils.hex8(memory[RAM_TXFIFO + txfifoPos] & 0xFF));
      listener.receivedByte((byte)(memory[RAM_TXFIFO + txfifoPos] & 0xFF));
    }
    txfifoPos++;
    long time=cpu.scheduleTimeEventMillis(sendEvent,SYMBOL_PERIOD * 2);
  }
 else {
    if (DEBUG)     log(""String_Node_Str"");
    status&=~STATUS_TX_ACTIVE;
    setSFD(false);
    if (overflow) {
      setState(RadioState.RX_OVERFLOW);
    }
 else {
      setState(RadioState.RX_CALIBRATE);
    }
    setMode(MODE_RX_ON);
    txfifoFlush=true;
  }
}","private void txNext(){
  if (txfifoPos <= memory[RAM_TXFIFO]) {
    if (txfifoPos > 0x7f) {
      log(""String_Node_Str"" + txfifoPos);
    }
    if (listener != null) {
      if (DEBUG)       log(""String_Node_Str"" + Utils.hex8(memory[RAM_TXFIFO + (txfifoPos & 0x7f)] & 0xFF));
      listener.receivedByte((byte)(memory[RAM_TXFIFO + (txfifoPos & 0x7f)] & 0xFF));
    }
    txfifoPos++;
    long time=cpu.scheduleTimeEventMillis(sendEvent,SYMBOL_PERIOD * 2);
  }
 else {
    if (DEBUG)     log(""String_Node_Str"");
    status&=~STATUS_TX_ACTIVE;
    setSFD(false);
    if (overflow) {
      setState(RadioState.RX_OVERFLOW);
    }
 else {
      setState(RadioState.RX_CALIBRATE);
    }
    setMode(MODE_RX_ON);
    txfifoFlush=true;
  }
}",0.9315866084425036
5679,"@Override public void interruptServiced(int vector){
  cpu.flagInterrupt(RESET_VECTOR,this,false);
}","public void interruptServiced(int vector){
  cpu.flagInterrupt(RESET_VECTOR,this,false);
}",0.9473684210526316
5680,"@Override public String getName(){
  return ""String_Node_Str"";
}","public String getName(){
  return ""String_Node_Str"";
}",0.9152542372881356
5681,"public void interruptServiced(int vector){
  if (vector == ccr0Vector) {
    core.flagInterrupt(ccr0Vector,this,false);
    tcctl[0]&=~CC_IFG;
    System.out.println(getName() + ""String_Node_Str"");
  }
  if (MSP430Core.debugInterrupts || true) {
    System.out.println(getName() + ""String_Node_Str"" + lastTIV+ ""String_Node_Str""+ core.cycles+ ""String_Node_Str""+ (core.cycles - triggerTime));
  }
}","public void interruptServiced(int vector){
  if (vector == ccr0Vector) {
    core.flagInterrupt(ccr0Vector,this,false);
    tcctl[0]&=~CC_IFG;
    System.out.println(getName() + ""String_Node_Str"");
  }
  if (MSP430Core.debugInterrupts || true) {
    System.out.println(getName() + ""String_Node_Str"" + lastTIV+ ""String_Node_Str""+ core.cycles+ ""String_Node_Str""+ (core.cycles - triggerTime));
  }
  triggerInterrupts(core.cycles);
}",0.9588377723970944
5682,"public void triggerInterrupts(long cycles){
  boolean trigger=false;
  int tIndex=0;
  for (int i=0, n=noCompare; i < n; i++) {
    boolean newTrigger=(tcctl[i] & CC_TRIGGER_INT) == CC_TRIGGER_INT;
    trigger=trigger | newTrigger;
    if (i == 0) {
      if (DEBUG) {
        System.out.println(getName() + ""String_Node_Str"" + tccr[0]+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ expCaptureTime[0]);
      }
      if (counter != tccr[0]) {
        System.out.print(""String_Node_Str"");
        System.out.println(getName() + ""String_Node_Str"" + tccr[0]+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ expCaptureTime[0]);
      }
      core.flagInterrupt(ccr0Vector,this,trigger);
      if (trigger) {
        lastTIV=0;
        triggerTime=cycles;
        return;
      }
    }
 else {
      if (newTrigger) {
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + i+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ i+ ""String_Node_Str""+ tccr[i]+ ""String_Node_Str""+ counter);
        }
        tIndex=i;
      }
    }
  }
  if (trigger) {
    lastTIV=memory[tiv]=tIndex * 2;
    triggerTime=cycles;
    if (DEBUG)     System.out.println(getName() + ""String_Node_Str"" + tIndex+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ tIndex+ ""String_Node_Str""+ tccr[tIndex]+ ""String_Node_Str""+ counter);
    if (counter != tccr[tIndex]) {
      System.out.print(""String_Node_Str"");
      System.out.println(getName() + ""String_Node_Str"" + tIndex+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ tIndex+ ""String_Node_Str""+ tccr[tIndex]+ ""String_Node_Str""+ counter);
    }
  }
  if (!trigger) {
    if (interruptEnable && interruptPending) {
      trigger=true;
      lastTIV=memory[tiv]=timerOverflow;
    }
  }
  core.flagInterrupt(ccr1Vector,this,trigger);
}","public void triggerInterrupts(long cycles){
  boolean trigger=false;
  int tIndex=0;
  for (int i=0, n=noCompare; i < n; i++) {
    boolean newTrigger=(tcctl[i] & CC_TRIGGER_INT) == CC_TRIGGER_INT;
    trigger=trigger | newTrigger;
    if (i == 0) {
      if (DEBUG) {
        System.out.println(getName() + ""String_Node_Str"" + tccr[0]+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ expCaptureTime[0]);
      }
      if (counter != tccr[0] && trigger) {
        System.out.print(""String_Node_Str"");
        System.out.println(getName() + ""String_Node_Str"" + tccr[0]+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ expCaptureTime[0]);
      }
      core.flagInterrupt(ccr0Vector,this,trigger);
      if (trigger) {
        lastTIV=0;
        triggerTime=cycles;
        return;
      }
    }
 else {
      if (newTrigger) {
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + i+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ i+ ""String_Node_Str""+ tccr[i]+ ""String_Node_Str""+ counter);
        }
        tIndex=i;
        break;
      }
    }
  }
  if (trigger) {
    lastTIV=memory[tiv]=tIndex * 2;
    triggerTime=cycles;
    if (DEBUG)     System.out.println(getName() + ""String_Node_Str"" + tIndex+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ tIndex+ ""String_Node_Str""+ tccr[tIndex]+ ""String_Node_Str""+ counter);
    if (counter != tccr[tIndex]) {
      System.out.print(""String_Node_Str"");
      System.out.println(getName() + ""String_Node_Str"" + tIndex+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ tIndex+ ""String_Node_Str""+ tccr[tIndex]+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ expCaptureTime[tIndex]);
    }
  }
  if (!trigger) {
    if (interruptEnable && interruptPending) {
      trigger=true;
      lastTIV=memory[tiv]=timerOverflow;
    }
  }
  core.flagInterrupt(ccr1Vector,this,trigger);
}",0.981476510067114
5683,"public void execute(long t){
  updateTimers(t);
}","public void execute(long t){
  updateTimers(core.cycles);
}",0.8888888888888888
5684,"private void resetTIV(long cycles){
  if (lastTIV == timerOverflow) {
    interruptPending=false;
    lastTIV=0;
    if (DEBUG) {
      System.out.println(getName() + ""String_Node_Str"");
    }
    triggerInterrupts(cycles);
  }
  if (lastTIV / 2 < noCompare) {
    if (DEBUG) {
      System.out.println(getName() + ""String_Node_Str"" + lastTIV);
    }
    tcctl[lastTIV / 2]&=~CC_IFG;
    triggerInterrupts(cycles);
  }
}","private void resetTIV(long cycles){
  if (lastTIV == timerOverflow) {
    interruptPending=false;
    lastTIV=0;
    if (DEBUG) {
      System.out.println(getName() + ""String_Node_Str"");
    }
    triggerInterrupts(cycles);
  }
  if (lastTIV / 2 < noCompare) {
    if (DEBUG || true) {
      System.out.println(getName() + ""String_Node_Str"" + (lastTIV / 2));
    }
    tcctl[lastTIV / 2]&=~CC_IFG;
    triggerInterrupts(cycles);
  }
}",0.9672131147540984
5685,"private void recalculateCompares(long cycles){
  for (int i=0; i < expCaptureTime.length; i++) {
    if (expCaptureTime[i] != 0) {
      int diff=tccr[i] - counter;
      if (diff < 0) {
        diff+=0x10000;
      }
      expCaptureTime[i]=cycles + (long)(diff * cyclesMultiplicator);
      if (i == 0) {
        System.out.println(""String_Node_Str"" + expCaptureTime[0] + ""String_Node_Str""+ cycles);
      }
    }
  }
}","private void recalculateCompares(long cycles){
  System.out.println(""String_Node_Str"");
  for (int i=0; i < expCaptureTime.length; i++) {
    if (expCaptureTime[i] != 0) {
      int diff=tccr[i] - counter;
      if (diff < 0) {
        diff+=0x10000;
      }
      expCaptureTime[i]=cycles + (long)(diff * cyclesMultiplicator);
      if (i == 0) {
        System.out.println(""String_Node_Str"" + expCaptureTime[0] + ""String_Node_Str""+ cycles);
      }
    }
  }
}",0.9535673839184596
5686,"private void updateTimers(long cycles){
  if (mode == STOP) {
    if (DEBUG) {
      System.out.println(""String_Node_Str"");
    }
    return;
  }
  updateCounter(cycles);
  if (cycles >= nextTimerTrigger) {
    interruptPending=true;
    nextTimerTrigger=(long)(nextTimerTrigger + 0x10000 * cyclesMultiplicator);
  }
  for (int i=0, n=noCompare; i < n; i++) {
    if (expCaptureTime[i] != -1 && cycles >= expCaptureTime[i]) {
      if (DEBUG || i < 2) {
        System.out.println(getName() + (captureOn[i] ? ""String_Node_Str"" : ""String_Node_Str"") + i+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ expCaptureTime[i]+ ""String_Node_Str""+ Utils.hex16(expCompare[i])+ ""String_Node_Str""+ Utils.hex16(updateCounter(cycles)));
      }
      tcctl[i]|=CC_IFG;
      if (captureOn[i]) {
        tccr[i]=expCompare[i];
        expCompare[i]=(expCompare[i] + expCapInterval[i]) & 0xffff;
        expCaptureTime[i]+=expCapInterval[i] * cyclesMultiplicator;
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + expCaptureTime[i]);
        }
      }
 else {
        expCaptureTime[i]=expCaptureTime[i] + (long)(0x10000 * cyclesMultiplicator);
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + expCaptureTime[i]);
        }
      }
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + Utils.hex16(offset + TCCTL0 + i * 2 + 1));
      }
    }
  }
  triggerInterrupts(cycles);
  calculateNextEventTime(cycles);
}","private void updateTimers(long cycles){
  if (mode == STOP) {
    if (DEBUG) {
      System.out.println(""String_Node_Str"");
    }
    return;
  }
  updateCounter(cycles);
  if (cycles >= nextTimerTrigger) {
    interruptPending=true;
    nextTimerTrigger=(long)(nextTimerTrigger + 0x10000 * cyclesMultiplicator);
  }
  for (int i=0, n=noCompare; i < n; i++) {
    if (expCaptureTime[i] != -1 && cycles >= expCaptureTime[i]) {
      if (DEBUG || true) {
        System.out.println(getName() + (captureOn[i] ? ""String_Node_Str"" : ""String_Node_Str"") + i+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ expCaptureTime[i]+ ""String_Node_Str""+ Utils.hex16(expCompare[i])+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ i+ ""String_Node_Str""+ tccr[i]);
      }
      tcctl[i]|=CC_IFG;
      if (captureOn[i]) {
        tccr[i]=expCompare[i];
        expCompare[i]=(expCompare[i] + expCapInterval[i]) & 0xffff;
        expCaptureTime[i]+=expCapInterval[i] * cyclesMultiplicator;
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + expCaptureTime[i]);
        }
      }
 else {
        expCaptureTime[i]=expCaptureTime[i] + (long)(0x10000 * cyclesMultiplicator);
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + expCaptureTime[i]);
        }
      }
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + Utils.hex16(offset + TCCTL0 + i * 2 + 1));
      }
    }
  }
  triggerInterrupts(cycles);
  calculateNextEventTime(cycles);
}",0.9662390276839972
5687,"public boolean emulateOP(long maxCycles){
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (cycles >= nextEventCycles) {
    executeEvents();
  }
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff) {
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return false;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return false;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad != AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
cycles+=5;
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
cycles+=3;
}
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
write=false;
updateStatus=false;
break;
case CALL:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as != AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=3;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
if (op != MOV) dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=dst - src;
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
dst=src ^ dst;
write=true;
break;
case AND:
dst=src & dst;
write=true;
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
}
}
if (word) {
dst&=0xffff;
}
 else {
dst&=0xff;
}
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
cpuCycles+=cycles - startCycles;
return true;
}","public boolean emulateOP(long maxCycles){
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (cycles >= nextEventCycles) {
    executeEvents();
  }
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff) {
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return false;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return false;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad > AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
cycles+=5;
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
cycles+=3;
}
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
write=false;
updateStatus=false;
break;
case CALL:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as > AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=3;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
if (op != MOV) dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=dst - src;
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
dst=src ^ dst;
write=true;
break;
case AND:
dst=src & dst;
write=true;
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
}
}
if (word) {
dst&=0xffff;
}
 else {
dst&=0xff;
}
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
cpuCycles+=cycles - startCycles;
return true;
}",0.9995934959349594
5688,"public void setVRegOn(boolean on){
  if (this.on == on)   return;
  if (on) {
    cpu.scheduleTimeEventMillis(vregEvent,0.1);
    if (DEBUG)     log(getName() + ""String_Node_Str"" + cpu.cycles+ ""String_Node_Str""+ vregEvent.getTime()+ ""String_Node_Str""+ cpu.getTime());
  }
 else {
    this.on=on;
    setState(RadioState.VREG_OFF);
  }
}","public void setVRegOn(boolean newOn){
  if (on == newOn)   return;
  if (newOn) {
    cpu.scheduleTimeEventMillis(vregEvent,0.1);
    if (DEBUG)     log(getName() + ""String_Node_Str"" + cpu.cycles+ ""String_Node_Str""+ vregEvent.getTime()+ ""String_Node_Str""+ cpu.getTime());
  }
 else {
    on=false;
    setState(RadioState.VREG_OFF);
  }
}",0.9525222551928784
5689,"private void flushRX(){
  if (DEBUG) {
    log(""String_Node_Str"" + rxfifoLen);
  }
  rxfifoReadPos=0;
  rxfifoWritePos=0;
  rxfifoLen=0;
  setSFD(false);
  setFIFOP(false);
  setFIFO(false);
  overflow=false;
  setState(RadioState.RX_SFD_SEARCH);
}","private void flushRX(){
  if (DEBUG) {
    log(""String_Node_Str"" + rxfifoLen);
  }
  rxfifoReadPos=0;
  rxfifoWritePos=0;
  rxfifoLen=0;
  setSFD(false);
  setFIFOP(false);
  setFIFO(false);
  overflow=false;
  if ((stateMachine == RadioState.RX_CALIBRATE) || (stateMachine == RadioState.RX_SFD_SEARCH) || (stateMachine == RadioState.RX_FRAME)|| (stateMachine == RadioState.RX_OVERFLOW)|| (stateMachine == RadioState.RX_WAIT)) {
    setState(RadioState.RX_SFD_SEARCH);
  }
}",0.6565096952908587
5690,"public void receivedByte(byte data){
  log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols);
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      if (zeroSymbols < 4)       zeroSymbols++;
      return;
    }
 else     if (zeroSymbols == 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      rxread=0;
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (rxfifoLen == 128) {
      setRxOverflow();
    }
 else {
      memory[RAM_RXFIFO + rxfifoWritePos++]=data & 0xFF;
      rxfifoLen++;
      if (rxfifoWritePos == 128) {
        if (DEBUG)         log(""String_Node_Str"");
        rxfifoWritePos=0;
      }
      if (rxread == 0) {
        rxlen=data & 0xff;
        if (DEBUG)         log(""String_Node_Str"" + rxlen);
        setFIFO(true);
      }
      if (rxread++ == rxlen) {
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)]=(registers[REG_RSSI]) & 0xff;
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)]=37 | 0x80;
        setFIFOP(true);
        setSFD(false);
        lastPacketStart=(rxfifoWritePos + 128 - rxlen) & 127;
        if (DEBUG)         log(""String_Node_Str"" + lastPacketStart);
        setState(RadioState.RX_WAIT);
      }
    }
  }
 else   if (DEBUG) {
    log(""String_Node_Str"" + stateMachine);
  }
}","public void receivedByte(byte data){
  log(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ stateMachine+ ""String_Node_Str""+ zeroSymbols+ ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? ""String_Node_Str"" : ""String_Node_Str""));
  if (stateMachine == RadioState.RX_SFD_SEARCH) {
    if (data == 0) {
      if (zeroSymbols < 4)       zeroSymbols++;
      return;
    }
 else     if (zeroSymbols == 4 && data == 0x7A) {
      setSFD(true);
      if (DEBUG)       log(""String_Node_Str"");
      rxread=0;
      setState(RadioState.RX_FRAME);
    }
 else {
      zeroSymbols=0;
    }
  }
 else   if (stateMachine == RadioState.RX_FRAME) {
    if (rxfifoLen == 128) {
      setRxOverflow();
    }
 else {
      memory[RAM_RXFIFO + rxfifoWritePos++]=data & 0xFF;
      rxfifoLen++;
      if (rxfifoWritePos == 128) {
        if (DEBUG)         log(""String_Node_Str"");
        rxfifoWritePos=0;
      }
      if (rxread == 0) {
        rxlen=data & 0xff;
        if (DEBUG)         log(""String_Node_Str"" + rxlen);
        setFIFO(true);
      }
      if (rxread++ == rxlen) {
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)]=(registers[REG_RSSI]) & 0xff;
        memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)]=37 | 0x80;
        setFIFOP(true);
        setSFD(false);
        lastPacketStart=(rxfifoWritePos + 128 - rxlen) & 127;
        if (DEBUG)         log(""String_Node_Str"" + lastPacketStart);
        setState(RadioState.RX_WAIT);
      }
    }
  }
}",0.935126050420168
5691,"private boolean setState(RadioState state){
  stateMachine=state;
switch (stateMachine) {
case VREG_OFF:
    if (DEBUG)     log(""String_Node_Str"");
  flushRX();
flushTX();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
setMode(MODE_POWER_OFF);
updateCCA();
break;
case POWER_DOWN:
rxfifoReadPos=0;
rxfifoWritePos=0;
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
setMode(MODE_POWER_OFF);
updateCCA();
break;
case RX_CALIBRATE:
setSymbolEvent(12);
setMode(MODE_RX_ON);
break;
case RX_SFD_SEARCH:
zeroSymbols=0;
status|=STATUS_RSSI_VALID;
updateCCA();
break;
case TX_CALIBRATE:
setSymbolEvent(12 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_FRAME:
txfifoPos=0;
txNext();
break;
case RX_WAIT:
setSymbolEvent(8);
break;
case IDLE:
status&=~STATUS_RSSI_VALID;
setMode(MODE_TXRX_OFF);
updateCCA();
break;
}
return true;
}","private boolean setState(RadioState state){
  if (DEBUG)   log(""String_Node_Str"" + stateMachine + ""String_Node_Str""+ state);
  stateMachine=state;
switch (stateMachine) {
case VREG_OFF:
    if (DEBUG)     log(""String_Node_Str"");
  flushRX();
flushTX();
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
setMode(MODE_POWER_OFF);
updateCCA();
break;
case POWER_DOWN:
rxfifoReadPos=0;
rxfifoWritePos=0;
status&=~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
setMode(MODE_POWER_OFF);
updateCCA();
break;
case RX_CALIBRATE:
setSymbolEvent(12);
setMode(MODE_RX_ON);
break;
case RX_SFD_SEARCH:
zeroSymbols=0;
status|=STATUS_RSSI_VALID;
updateCCA();
break;
case TX_CALIBRATE:
setSymbolEvent(12 + 2);
setMode(MODE_TXRX_ON);
break;
case TX_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case TX_FRAME:
txfifoPos=0;
txNext();
break;
case RX_WAIT:
setSymbolEvent(8);
break;
case IDLE:
status&=~STATUS_RSSI_VALID;
setMode(MODE_TXRX_OFF);
updateCCA();
break;
}
return true;
}",0.958139534883721
5692,"public void setupCommands(ComponentRegistry registry,CommandHandler ch){
  this.registry=registry;
  final MSP430 cpu=(MSP430)registry.getComponent(MSP430.class);
  final ELF elf=(ELF)registry.getComponent(ELF.class);
  final GenericNode node=(GenericNode)registry.getComponent(""String_Node_Str"");
  if (cpu != null) {
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int address=0;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(address=baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            context.out.println(""String_Node_Str"" + adr);
          }
        }
);
        context.out.println(""String_Node_Str"" + baddr);
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int address=0;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        if (baddr == -1) {
          context.out.println(""String_Node_Str"" + context.getArgument(0));
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          String modeStr=context.getArgument(1);
          if (""String_Node_Str"".equals(modeStr)) {
            mode=1;
          }
 else           if (""String_Node_Str"".equals(modeStr)) {
            mode=2;
          }
        }
        cpu.setBreakPoint(address=baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0 || mode == 2) {
              int pc=cpu.readRegister(0);
              String adrStr=getSymOrAddr(context,adr);
              String pcStr=getSymOrAddrELF(elf,pc);
              String op=""String_Node_Str"";
              if (type == MEMORY_READ) {
                op=""String_Node_Str"";
              }
 else               if (type == MEMORY_WRITE) {
                op=""String_Node_Str"";
              }
              context.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pcStr+ ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
              if (mode == 2) {
                cpu.stop();
              }
            }
 else {
              context.out.print((char)data);
            }
          }
        }
);
        context.out.println(""String_Node_Str"" + baddr);
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
        context.exit(0);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int register=0;
      public int executeCommand(      final CommandContext context){
        register=context.getArgumentAsRegister(0);
        if (register < 0) {
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          String modeStr=context.getArgument(1);
          if (""String_Node_Str"".equals(modeStr)) {
            mode=1;
          }
 else {
            context.err.println(""String_Node_Str"" + modeStr);
            return -1;
          }
        }
        cpu.setRegisterWriteMonitor(register,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0) {
              int pc=cpu.readRegister(0);
              String adrStr=getRegisterName(register);
              String pcStr=getSymOrAddrELF(elf,pc);
              context.out.println(""String_Node_Str"" + pcStr + ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
            }
 else {
              context.out.println(data);
            }
          }
        }
);
        context.out.println(""String_Node_Str"" + getRegisterName(register));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(register);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new Command(){
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(baddr,null);
        return 0;
      }
      public String getArgumentHelp(      String commandName){
        return ""String_Node_Str"";
      }
      public String getCommandHelp(      String commandName){
        return ""String_Node_Str"";
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
      public int executeCommand(      final CommandContext context){
        String regExp=context.getArgument(0);
        MapEntry[] entries=context.getMapTable().getEntries(regExp);
        for (int i=0; i < entries.length; i++) {
          MapEntry mapEntry=entries[i];
          context.out.println(""String_Node_Str"" + mapEntry.getName() + ""String_Node_Str""+ Utils.hex16(mapEntry.getAddress()));
        }
        return 0;
      }
    }
);
    if (node != null) {
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.stop();
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)));
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.start();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int nr=context.getArgumentCount() > 0 ? context.getArgumentAsInt(0) : 1;
          long cyc=cpu.cycles;
          node.step(nr);
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)) + ""String_Node_Str""+ (cpu.cycles - cyc)+ ""String_Node_Str""+ cpu.cycles+ ""String_Node_Str"");
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int stackEnd=context.getMapTable().heapStartAddress;
          int stackStart=context.getMapTable().stackStartAddress;
          int current=cpu.readRegister(MSP430Constants.SP);
          context.out.println(""String_Node_Str"" + Utils.hex16(current) + ""String_Node_Str""+ (stackStart - current)+ ""String_Node_Str""+ (stackStart - stackEnd)+ ')');
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int adr=context.getArgumentAsAddress(0);
          if (adr != -1) {
            context.out.println(""String_Node_Str"" + context.getArgument(0) + ""String_Node_Str""+ Utils.hex16(cpu.read(adr,adr >= 0x100)));
          }
 else {
            context.out.println(""String_Node_Str"");
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int register=context.getArgumentAsRegister(0);
          if (register >= 0) {
            context.out.println(context.getArgument(0) + ""String_Node_Str"" + Utils.hex16(cpu.readRegister(register)));
            return 0;
          }
          return -1;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          cpu.reset();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          long time=((long)(cpu.getTimeMillis()));
          context.out.println(""String_Node_Str"" + time + ""String_Node_Str""+ (time - lastCall)+ ""String_Node_Str""+ ""String_Node_Str""+ (System.currentTimeMillis() - lastWall)+ ""String_Node_Str"");
          lastCall=time;
          lastWall=System.currentTimeMillis();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int start=context.getArgumentAsAddress(0);
          int count=context.getArgumentAsInt(1);
          int size=1;
          boolean signed=false;
          if (context.getArgumentCount() > 2) {
            String tS=context.getArgument(2);
            if (""String_Node_Str"".equals(tS)) {
              signed=true;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              signed=true;
              size=2;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              size=2;
            }
          }
          for (int i=0; i < count; i++) {
            int data=0;
            data=cpu.memory[start++];
            if (size == 2) {
              data=data + (cpu.memory[start++] << 8);
            }
            context.out.print(""String_Node_Str"" + data);
          }
          context.out.println();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int adr=context.getArgumentAsAddress(0);
          int val=context.getArgumentAsInt(1);
          boolean word=val > 0xff;
          cpu.write(adr,val,word);
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          Memory xmem=(Memory)DebugCommands.this.registry.getComponent(""String_Node_Str"");
          if (xmem == null) {
            context.err.println(""String_Node_Str"");
            return 0;
          }
          int start=context.getArgumentAsAddress(0);
          int count=context.getArgumentAsInt(1);
          int size=1;
          boolean signed=false;
          if (context.getArgumentCount() > 2) {
            String tS=context.getArgument(2);
            if (""String_Node_Str"".equals(tS)) {
              signed=true;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              signed=true;
              size=2;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              size=2;
            }
          }
          for (int i=0; i < count; i++) {
            int data=0;
            data=xmem.readByte(start++);
            if (size == 2) {
              data=data + (xmem.readByte(start++) << 8);
            }
            context.out.print(""String_Node_Str"" + data);
          }
          context.out.println();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          Memory xmem=(Memory)DebugCommands.this.registry.getComponent(""String_Node_Str"");
          if (xmem == null) {
            context.err.println(""String_Node_Str"");
            return 0;
          }
          int adr=context.getArgumentAsAddress(0);
          int val=context.getArgumentAsInt(1);
          boolean word=val > 0xff;
          if (word) {
            xmem.writeByte(adr,val >> 8);
            val=val & 0xff;
            adr++;
          }
          xmem.writeByte(adr,val & 0xff);
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        @Override public int executeCommand(        CommandContext context){
          Chip[] chips=cpu.getChips();
          for (int i=0; i < chips.length; i++) {
            context.out.println(chips[i].getName());
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
        Chip chip=null;
        @Override public int executeCommand(        CommandContext context){
          chip=cpu.getChip(context.getArgument(0));
          if (chip == null) {
            context.err.println(""String_Node_Str"" + context.getArgument(0));
          }
          chip.setLogStream(context.out);
          return 0;
        }
        public void stopCommand(        CommandContext context){
          chip.clearLogStream();
        }
      }
);
    }
  }
}","public void setupCommands(ComponentRegistry registry,CommandHandler ch){
  this.registry=registry;
  final MSP430 cpu=(MSP430)registry.getComponent(MSP430.class);
  final ELF elf=(ELF)registry.getComponent(ELF.class);
  final GenericNode node=(GenericNode)registry.getComponent(""String_Node_Str"");
  if (cpu != null) {
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int address=0;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(address=baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            context.out.println(""String_Node_Str"" + adr);
          }
        }
);
        context.out.println(""String_Node_Str"" + baddr);
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int address=0;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        if (baddr == -1) {
          context.out.println(""String_Node_Str"" + context.getArgument(0));
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          String modeStr=context.getArgument(1);
          if (""String_Node_Str"".equals(modeStr)) {
            mode=1;
          }
 else           if (""String_Node_Str"".equals(modeStr)) {
            mode=2;
          }
        }
        cpu.setBreakPoint(address=baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0 || mode == 2) {
              int pc=cpu.readRegister(0);
              String adrStr=getSymOrAddr(context,adr);
              String pcStr=getSymOrAddrELF(elf,pc);
              String op=""String_Node_Str"";
              if (type == MEMORY_READ) {
                op=""String_Node_Str"";
              }
 else               if (type == MEMORY_WRITE) {
                op=""String_Node_Str"";
              }
              context.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pcStr+ ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
              if (mode == 2) {
                cpu.stop();
              }
            }
 else {
              context.out.print((char)data);
            }
          }
        }
);
        context.out.println(""String_Node_Str"" + baddr);
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
        context.exit(0);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int register=0;
      public int executeCommand(      final CommandContext context){
        register=context.getArgumentAsRegister(0);
        if (register < 0) {
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          String modeStr=context.getArgument(1);
          if (""String_Node_Str"".equals(modeStr)) {
            mode=1;
          }
 else {
            context.err.println(""String_Node_Str"" + modeStr);
            return -1;
          }
        }
        cpu.setRegisterWriteMonitor(register,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0) {
              int pc=cpu.readRegister(0);
              String adrStr=getRegisterName(register);
              String pcStr=getSymOrAddrELF(elf,pc);
              context.out.println(""String_Node_Str"" + pcStr + ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
            }
 else {
              context.out.println(data);
            }
          }
        }
);
        context.out.println(""String_Node_Str"" + getRegisterName(register));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(register);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new Command(){
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(baddr,null);
        return 0;
      }
      public String getArgumentHelp(      String commandName){
        return ""String_Node_Str"";
      }
      public String getCommandHelp(      String commandName){
        return ""String_Node_Str"";
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
      public int executeCommand(      final CommandContext context){
        String regExp=context.getArgument(0);
        MapEntry[] entries=context.getMapTable().getEntries(regExp);
        for (int i=0; i < entries.length; i++) {
          MapEntry mapEntry=entries[i];
          int address=mapEntry.getAddress();
          context.out.println(""String_Node_Str"" + mapEntry.getName() + ""String_Node_Str""+ Utils.hex16(address)+ ""String_Node_Str""+ Utils.hex8(cpu.memory[address])+ ""String_Node_Str""+ Utils.hex8(cpu.memory[address + 1])+ ""String_Node_Str"");
        }
        return 0;
      }
    }
);
    if (node != null) {
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.stop();
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)));
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.start();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int nr=context.getArgumentCount() > 0 ? context.getArgumentAsInt(0) : 1;
          long cyc=cpu.cycles;
          node.step(nr);
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)) + ""String_Node_Str""+ (cpu.cycles - cyc)+ ""String_Node_Str""+ cpu.cycles+ ""String_Node_Str"");
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int stackEnd=context.getMapTable().heapStartAddress;
          int stackStart=context.getMapTable().stackStartAddress;
          int current=cpu.readRegister(MSP430Constants.SP);
          context.out.println(""String_Node_Str"" + Utils.hex16(current) + ""String_Node_Str""+ (stackStart - current)+ ""String_Node_Str""+ (stackStart - stackEnd)+ ')');
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int adr=context.getArgumentAsAddress(0);
          if (adr != -1) {
            context.out.println(""String_Node_Str"" + context.getArgument(0) + ""String_Node_Str""+ Utils.hex16(cpu.read(adr,adr >= 0x100)));
          }
 else {
            context.out.println(""String_Node_Str"");
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int register=context.getArgumentAsRegister(0);
          if (register >= 0) {
            context.out.println(context.getArgument(0) + ""String_Node_Str"" + Utils.hex16(cpu.readRegister(register)));
            return 0;
          }
          return -1;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          cpu.reset();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          long time=((long)(cpu.getTimeMillis()));
          context.out.println(""String_Node_Str"" + time + ""String_Node_Str""+ (time - lastCall)+ ""String_Node_Str""+ ""String_Node_Str""+ (System.currentTimeMillis() - lastWall)+ ""String_Node_Str"");
          lastCall=time;
          lastWall=System.currentTimeMillis();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int start=context.getArgumentAsAddress(0);
          int count=context.getArgumentAsInt(1);
          int size=1;
          boolean signed=false;
          if (context.getArgumentCount() > 2) {
            String tS=context.getArgument(2);
            if (""String_Node_Str"".equals(tS)) {
              signed=true;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              signed=true;
              size=2;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              size=2;
            }
          }
          for (int i=0; i < count; i++) {
            int data=0;
            data=cpu.memory[start++];
            if (size == 2) {
              data=data + (cpu.memory[start++] << 8);
            }
            context.out.print(""String_Node_Str"" + data);
          }
          context.out.println();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int adr=context.getArgumentAsAddress(0);
          int val=context.getArgumentAsInt(1);
          boolean word=val > 0xff;
          cpu.write(adr,val,word);
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          Memory xmem=(Memory)DebugCommands.this.registry.getComponent(""String_Node_Str"");
          if (xmem == null) {
            context.err.println(""String_Node_Str"");
            return 0;
          }
          int start=context.getArgumentAsAddress(0);
          int count=context.getArgumentAsInt(1);
          int size=1;
          boolean signed=false;
          if (context.getArgumentCount() > 2) {
            String tS=context.getArgument(2);
            if (""String_Node_Str"".equals(tS)) {
              signed=true;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              signed=true;
              size=2;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              size=2;
            }
          }
          for (int i=0; i < count; i++) {
            int data=0;
            data=xmem.readByte(start++);
            if (size == 2) {
              data=data + (xmem.readByte(start++) << 8);
            }
            context.out.print(""String_Node_Str"" + data);
          }
          context.out.println();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          Memory xmem=(Memory)DebugCommands.this.registry.getComponent(""String_Node_Str"");
          if (xmem == null) {
            context.err.println(""String_Node_Str"");
            return 0;
          }
          int adr=context.getArgumentAsAddress(0);
          int val=context.getArgumentAsInt(1);
          boolean word=val > 0xff;
          if (word) {
            xmem.writeByte(adr,val >> 8);
            val=val & 0xff;
            adr++;
          }
          xmem.writeByte(adr,val & 0xff);
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        @Override public int executeCommand(        CommandContext context){
          Chip[] chips=cpu.getChips();
          for (int i=0; i < chips.length; i++) {
            context.out.println(chips[i].getName());
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
        Chip chip=null;
        @Override public int executeCommand(        CommandContext context){
          chip=cpu.getChip(context.getArgument(0));
          if (chip == null) {
            context.err.println(""String_Node_Str"" + context.getArgument(0));
          }
          chip.setLogStream(context.out);
          return 0;
        }
        public void stopCommand(        CommandContext context){
          chip.clearLogStream();
        }
      }
);
    }
  }
}",0.9923828575825192
5693,"private void shrNext(){
  if (shr_pos == 5) {
    setSFD(true);
    setState(STATE_TX_FRAME);
  }
 else {
    listener.receivedByte(SHR[shr_pos++]);
    cpu.scheduleTimeEventMillis(shrEvent,SYMBOL_PERIOD * 2);
  }
}","private void shrNext(){
  if (shrPos == 5) {
    setSFD(true);
    setState(STATE_TX_FRAME);
  }
 else {
    listener.receivedByte(SHR[shrPos++]);
    cpu.scheduleTimeEventMillis(shrEvent,SYMBOL_PERIOD * 2);
  }
}",0.985981308411215
5694,"public void setFIFOP(boolean fifop){
  if ((registers[REG_IOCFG0] & FIFOP_POLARITY) == FIFOP_POLARITY) {
    fifopPort.setPinState(fifopPin,fifop ? 0 : 1);
  }
 else {
    fifopPort.setPinState(fifopPin,fifop ? 1 : 0);
  }
}","private void setFIFOP(boolean fifop){
  if ((registers[REG_IOCFG0] & FIFOP_POLARITY) == FIFOP_POLARITY) {
    fifopPort.setPinState(fifopPin,fifop ? 0 : 1);
  }
 else {
    fifopPort.setPinState(fifopPin,fifop ? 1 : 0);
  }
}",0.975501113585746
5695,"public void dataReceived(USART source,int data){
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ ((data >= ' ' && data <= 'Z') ? (char)data : '.')+ ')'+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ state+ ""String_Node_Str""+ stateMachine);
  }
  if ((stateMachine != STATE_VREG_OFF) && chipSelect) {
switch (state) {
case WAITING:
      if ((data & FLAG_READ) != 0) {
        state=READ_REGISTER;
      }
 else {
        state=WRITE_REGISTER;
      }
    if ((data & FLAG_RAM) != 0) {
      state=RAM_ACCESS;
      address=data & 0x7f;
    }
 else {
      address=data & 0x3f;
      if (address == REG_RXFIFO) {
        state=READ_RXFIFO;
      }
 else       if (address == REG_TXFIFO) {
        state=WRITE_TXFIFO;
      }
    }
  if (data < 0x0f) {
    strobe(data);
  }
pos=0;
break;
case WRITE_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
registers[address]=(registers[address] & 0xff) | (data << 8);
pos=1;
}
 else {
source.byteReceived(registers[address] & 0xff);
registers[address]=(registers[address] & 0xff00) | data;
state=WAITING;
}
break;
case READ_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
pos=1;
}
 else {
source.byteReceived(registers[address] & 0xff);
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
state=WAITING;
}
return;
case READ_RXFIFO:
if (rxfifo_len == 0) break;
if (DEBUG) System.out.println(""String_Node_Str"" + rxfifo_read_pos + ""String_Node_Str""+ (memory[RAM_RXFIFO + rxfifo_read_pos] & 0xFF));
source.byteReceived((memory[RAM_RXFIFO + rxfifo_read_pos] & 0xFF));
rxfifo_read_pos++;
setFIFOP(false);
if (--rxfifo_len == 0) setFIFO(false);
if (rxfifo_read_pos >= 128) {
rxfifo_read_pos=0;
}
if (rxPacket) {
rxPacket=false;
setFIFOP(false);
}
return;
case WRITE_TXFIFO:
if (txfifo_flush) {
txCursor=0;
txfifo_flush=false;
}
if (DEBUG) System.out.println(""String_Node_Str"" + data + ""String_Node_Str""+ txCursor);
memory[RAM_TXFIFO + txCursor++]=data & 0xff;
break;
case RAM_ACCESS:
if (pos == 0) {
address=address | (data << 1) & 0x180;
ramRead=(data & 0x20) != 0;
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ ramRead);
}
pos++;
}
 else {
if (!ramRead) {
memory[address++]=data;
if (DEBUG && address == RAM_PANID + 2) {
System.out.println(""String_Node_Str"" + Utils.hex8(memory[RAM_PANID]) + Utils.hex8(memory[RAM_PANID + 1]));
}
}
 else {
source.byteReceived(memory[address++]);
return;
}
}
break;
}
source.byteReceived(status);
}
}","public void dataReceived(USART source,int data){
  int oldStatus=status;
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ ((data >= ' ' && data <= 'Z') ? (char)data : '.')+ ')'+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ state+ ""String_Node_Str""+ stateMachine);
  }
  if ((stateMachine != STATE_VREG_OFF) && chipSelect) {
switch (state) {
case WAITING:
      if ((data & FLAG_READ) != 0) {
        state=READ_REGISTER;
      }
 else {
        state=WRITE_REGISTER;
      }
    if ((data & FLAG_RAM) != 0) {
      state=RAM_ACCESS;
      address=data & 0x7f;
    }
 else {
      address=data & 0x3f;
      if (address == REG_RXFIFO) {
        state=READ_RXFIFO;
      }
 else       if (address == REG_TXFIFO) {
        state=WRITE_TXFIFO;
      }
    }
  if (data < 0x0f) {
    strobe(data);
  }
pos=0;
break;
case WRITE_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
registers[address]=(registers[address] & 0xff) | (data << 8);
pos=1;
}
 else {
source.byteReceived(registers[address] & 0xff);
registers[address]=(registers[address] & 0xff00) | data;
state=WAITING;
}
break;
case READ_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
pos=1;
}
 else {
source.byteReceived(registers[address] & 0xff);
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
state=WAITING;
}
return;
case READ_RXFIFO:
if (rxfifoLen == 0) break;
if (DEBUG) System.out.println(""String_Node_Str"" + rxfifoReadPos + ""String_Node_Str""+ (memory[RAM_RXFIFO + rxfifoReadPos] & 0xFF));
source.byteReceived((memory[RAM_RXFIFO + rxfifoReadPos] & 0xFF));
rxfifoReadPos++;
setFIFOP(false);
if (--rxfifoLen == 0) setFIFO(false);
if (rxfifoReadPos >= 128) {
rxfifoReadPos=0;
}
if (rxPacket) {
rxPacket=false;
setFIFOP(false);
}
return;
case WRITE_TXFIFO:
if (txfifoFlush) {
txCursor=0;
txfifoFlush=false;
}
if (DEBUG) System.out.println(""String_Node_Str"" + data + ""String_Node_Str""+ txCursor);
memory[RAM_TXFIFO + txCursor++]=data & 0xff;
break;
case RAM_ACCESS:
if (pos == 0) {
address=address | (data << 1) & 0x180;
ramRead=(data & 0x20) != 0;
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ ramRead);
}
pos++;
}
 else {
if (!ramRead) {
memory[address++]=data;
if (DEBUG && address == RAM_PANID + 2) {
System.out.println(""String_Node_Str"" + Utils.hex8(memory[RAM_PANID]) + Utils.hex8(memory[RAM_PANID + 1]));
}
}
 else {
source.byteReceived(memory[address++]);
return;
}
}
break;
}
source.byteReceived(oldStatus);
}
}",0.9781473602784762
5696,"public String chipinfo(){
  return ""String_Node_Str"" + on + ""String_Node_Str""+ ((status & STATUS_XOSC16M_STABLE) > 0)+ ""String_Node_Str""+ ((status & STATUS_RSSI_VALID) > 0)+ ""String_Node_Str"";
}","public String chipinfo(){
  return ""String_Node_Str"" + on + ""String_Node_Str""+ ((status & STATUS_XOSC16M_STABLE) > 0)+ ""String_Node_Str""+ ((status & STATUS_RSSI_VALID) > 0)+ ""String_Node_Str""+ cca+ ""String_Node_Str"";
}",0.941747572815534
5697,"private void txNext(){
  if (txfifo_pos <= memory[RAM_TXFIFO]) {
    listener.receivedByte((byte)(memory[RAM_TXFIFO + txfifo_pos++] & 0xFF));
    long time=cpu.scheduleTimeEventMillis(sendEvent,SYMBOL_PERIOD * 2);
  }
 else {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    status&=~STATUS_TX_ACTIVE;
    setSFD(false);
    setState(STATE_RX_CALIBRATE);
    setMode(MODE_RX_ON);
    txfifo_flush=true;
  }
}","private void txNext(){
  if (txfifoPos <= memory[RAM_TXFIFO]) {
    listener.receivedByte((byte)(memory[RAM_TXFIFO + txfifoPos++] & 0xFF));
    long time=cpu.scheduleTimeEventMillis(sendEvent,SYMBOL_PERIOD * 2);
  }
 else {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    status&=~STATUS_TX_ACTIVE;
    setSFD(false);
    setState(STATE_RX_CALIBRATE);
    setMode(MODE_RX_ON);
    txfifoFlush=true;
  }
}",0.9892729439809296
5698,"private void flushRX(){
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + rxfifo_len);
  }
  rxPacket=false;
  rxfifo_read_pos=0;
  rxfifo_write_pos=0;
  rxfifo_len=0;
  setClear(true);
  setSFD(false);
  setFIFOP(false);
}","private void flushRX(){
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + rxfifoLen);
  }
  rxPacket=false;
  rxfifoReadPos=0;
  rxfifoWritePos=0;
  rxfifoLen=0;
  setCCA(true);
  setSFD(false);
  setFIFOP(false);
}",0.9295154185022028
5699,"public void setFIFO(boolean fifo){
  fifoPort.setPinState(fifoPin,fifo ? 1 : 0);
}","private void setFIFO(boolean fifo){
  fifoPort.setPinState(fifoPin,fifo ? 1 : 0);
}",0.9454545454545454
5700,"public void execute(long t){
switch (stateMachine) {
case STATE_RX_CALIBRATE:
    setClear(true);
  setState(STATE_RX_SFD_SEARCH);
break;
case STATE_TX_CALIBRATE:
setState(STATE_TX_PREAMBLE);
break;
case STATE_RX_WAIT:
setClear(true);
setState(STATE_RX_SFD_SEARCH);
break;
}
}","public void execute(long t){
switch (stateMachine) {
case STATE_RX_CALIBRATE:
    setCCA(true);
  setState(STATE_RX_SFD_SEARCH);
break;
case STATE_TX_CALIBRATE:
setState(STATE_TX_PREAMBLE);
break;
case STATE_RX_WAIT:
setCCA(true);
setState(STATE_RX_SFD_SEARCH);
break;
}
}",0.978102189781022
5701,"public void setSFD(boolean sfd){
  if (DEBUG)   System.out.println(""String_Node_Str"" + sfd);
  sfdPort.setPinState(sfdPin,sfd ? 1 : 0);
}","private void setSFD(boolean sfd){
  if (DEBUG)   System.out.println(""String_Node_Str"" + sfd);
  sfdPort.setPinState(sfdPin,sfd ? 1 : 0);
}",0.9672727272727272
5702,"public void setRxOverflow(){
  if (DEBUG)   System.out.println(""String_Node_Str"" + rxfifo_read_pos + ""String_Node_Str""+ rxfifo_write_pos);
  setFIFOP(true);
  setFIFO(false);
}","public void setRxOverflow(){
  if (DEBUG)   System.out.println(""String_Node_Str"" + rxfifoReadPos + ""String_Node_Str""+ rxfifoWritePos);
  setFIFOP(true);
  setFIFO(false);
}",0.9655172413793104
5703,"public void receivedByte(byte data){
  if (cca)   setClear(false);
  if (stateMachine == STATE_RX_SFD_SEARCH) {
    if (data == 0) {
      zero_symbols++;
      return;
    }
    if (zero_symbols == 4) {
      if (data == 0x7A) {
        setSFD(true);
        if (DEBUG)         System.out.println(""String_Node_Str"");
        rxread=0;
        setState(STATE_RX_FRAME);
      }
 else {
        zero_symbols=0;
      }
    }
  }
 else   if (stateMachine == STATE_RX_FRAME) {
    if (rxfifo_len == 128) {
      setRxOverflow();
    }
 else {
      memory[RAM_RXFIFO + rxfifo_write_pos++]=data & 0xFF;
      rxfifo_len++;
      if (rxfifo_write_pos == 128) {
        if (DEBUG)         System.out.println(""String_Node_Str"");
        rxfifo_write_pos=0;
      }
      if (rxread == 0) {
        rxlen=(int)data;
        if (DEBUG)         System.out.println(""String_Node_Str"" + rxlen);
        setFIFO(true);
      }
      if (rxread++ == rxlen) {
        memory[RAM_RXFIFO + (rxfifo_write_pos - 2)]=(registers[REG_RSSI]) & 0xff;
        memory[RAM_RXFIFO + (rxfifo_write_pos - 1)]=37 | 0x80;
        setFIFOP(true);
        setSFD(false);
        if (DEBUG)         System.out.println(""String_Node_Str"");
        setState(STATE_RX_WAIT);
      }
    }
  }
}","public void receivedByte(byte data){
  if (cca)   setCCA(false);
  if (stateMachine == STATE_RX_SFD_SEARCH) {
    if (data == 0) {
      zero_symbols++;
      return;
    }
    if (zero_symbols == 4) {
      if (data == 0x7A) {
        setSFD(true);
        if (DEBUG)         System.out.println(""String_Node_Str"");
        rxread=0;
        setState(STATE_RX_FRAME);
      }
 else {
        zero_symbols=0;
      }
    }
  }
 else   if (stateMachine == STATE_RX_FRAME) {
    if (rxfifoLen == 128) {
      setRxOverflow();
    }
 else {
      memory[RAM_RXFIFO + rxfifoWritePos++]=data & 0xFF;
      rxfifoLen++;
      if (rxfifoWritePos == 128) {
        if (DEBUG)         System.out.println(""String_Node_Str"");
        rxfifoWritePos=0;
      }
      if (rxread == 0) {
        rxlen=(int)data;
        if (DEBUG)         System.out.println(""String_Node_Str"" + rxlen);
        setFIFO(true);
      }
      if (rxread++ == rxlen) {
        memory[RAM_RXFIFO + (rxfifoWritePos - 2)]=(registers[REG_RSSI]) & 0xff;
        memory[RAM_RXFIFO + (rxfifoWritePos - 1)]=37 | 0x80;
        setFIFOP(true);
        setSFD(false);
        if (DEBUG)         System.out.println(""String_Node_Str"");
        setState(STATE_RX_WAIT);
      }
    }
  }
}",0.967121090617482
5704,"private boolean setState(int state){
  stateMachine=state;
switch (stateMachine) {
case STATE_VREG_OFF:
    if (DEBUG)     System.out.println(""String_Node_Str"");
  break;
case STATE_POWER_DOWN:
rxfifo_read_pos=0;
rxfifo_write_pos=0;
break;
case STATE_RX_CALIBRATE:
setSymbolEvent(12);
break;
case STATE_RX_SFD_SEARCH:
zero_symbols=0;
status|=STATUS_RSSI_VALID;
break;
case STATE_TX_CALIBRATE:
setSymbolEvent(12 + 2);
break;
case STATE_TX_PREAMBLE:
shr_pos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case STATE_TX_FRAME:
txfifo_pos=0;
txNext();
break;
case STATE_RX_WAIT:
setSymbolEvent(8);
break;
case STATE_IDLE:
status&=~STATUS_RSSI_VALID;
break;
}
return true;
}","private boolean setState(int state){
  stateMachine=state;
switch (stateMachine) {
case STATE_VREG_OFF:
    if (DEBUG)     System.out.println(""String_Node_Str"");
  break;
case STATE_POWER_DOWN:
rxfifoReadPos=0;
rxfifoWritePos=0;
break;
case STATE_RX_CALIBRATE:
setSymbolEvent(12);
break;
case STATE_RX_SFD_SEARCH:
zero_symbols=0;
status|=STATUS_RSSI_VALID;
break;
case STATE_TX_CALIBRATE:
setSymbolEvent(12 + 2);
break;
case STATE_TX_PREAMBLE:
shrPos=0;
SHR[0]=0;
SHR[1]=0;
SHR[2]=0;
SHR[3]=0;
SHR[4]=0x7A;
shrNext();
break;
case STATE_TX_FRAME:
txfifoPos=0;
txNext();
break;
case STATE_RX_WAIT:
setSymbolEvent(8);
break;
case STATE_IDLE:
status&=~STATUS_RSSI_VALID;
break;
}
return true;
}",0.9812409812409812
5705,"public CC2420(MSP430Core cpu){
  registers[REG_SNOP]=0;
  registers[REG_TXCTRL]=0xa0ff;
  this.cpu=cpu;
  setModeNames(MODE_NAMES);
  setMode(MODE_POWER_OFF);
  rxPacket=false;
  rxfifo_read_pos=0;
  rxfifo_write_pos=0;
  cca=false;
}","public CC2420(MSP430Core cpu){
  registers[REG_SNOP]=0;
  registers[REG_TXCTRL]=0xa0ff;
  this.cpu=cpu;
  setModeNames(MODE_NAMES);
  setMode(MODE_POWER_OFF);
  rxPacket=false;
  rxfifoReadPos=0;
  rxfifoWritePos=0;
}",0.8470066518847007
5706,"public void setCCA(boolean cca){
  if ((registers[REG_IOCFG0] & CCA_POLARITY) == CCA_POLARITY)   ccaPort.setPinState(ccaPin,cca ? 0 : 1);
 else   ccaPort.setPinState(ccaPin,cca ? 1 : 0);
}","public void setCCA(boolean clear){
  cca=clear;
  setCCAPin(clear);
  if (DEBUG)   System.out.println(""String_Node_Str"" + clear);
}",0.3887147335423197
5707,"private void shrNext(){
  if (shrPos == 5) {
    setSFD(true);
    setState(STATE_TX_FRAME);
  }
 else {
    if (listener != null) {
      listener.receivedByte(SHR[shrPos++]);
    }
    cpu.scheduleTimeEventMillis(shrEvent,SYMBOL_PERIOD * 2);
  }
}","private void shrNext(){
  if (shrPos == 5) {
    setSFD(true);
    setState(STATE_TX_FRAME);
  }
 else {
    if (listener != null) {
      listener.receivedByte(SHR[shrPos]);
    }
    shrPos++;
    cpu.scheduleTimeEventMillis(shrEvent,SYMBOL_PERIOD * 2);
  }
}",0.9411764705882352
5708,"private void txNext(){
  if (txfifoPos <= memory[RAM_TXFIFO]) {
    if (listener != null) {
      listener.receivedByte((byte)(memory[RAM_TXFIFO + txfifoPos++] & 0xFF));
    }
    long time=cpu.scheduleTimeEventMillis(sendEvent,SYMBOL_PERIOD * 2);
  }
 else {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    status&=~STATUS_TX_ACTIVE;
    setSFD(false);
    setState(STATE_RX_CALIBRATE);
    setMode(MODE_RX_ON);
    txfifoFlush=true;
  }
}","private void txNext(){
  if (txfifoPos <= memory[RAM_TXFIFO]) {
    if (listener != null) {
      listener.receivedByte((byte)(memory[RAM_TXFIFO + txfifoPos] & 0xFF));
    }
    txfifoPos++;
    long time=cpu.scheduleTimeEventMillis(sendEvent,SYMBOL_PERIOD * 2);
  }
 else {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    status&=~STATUS_TX_ACTIVE;
    setSFD(false);
    setState(STATE_RX_CALIBRATE);
    setMode(MODE_RX_ON);
    txfifoFlush=true;
  }
}",0.9469122426868906
5709,"public void dataReceived(USART source,int data){
  radio.dataReceived(source,data);
  flash.dataReceived(source,data);
  if (!radio.getChipSelect() && !flash.getChipSelect()) {
    source.byteReceived(0);
  }
}","public void dataReceived(USART source,int data){
  radio.dataReceived(source,data);
  flash.dataReceived(source,data);
  if (!radio.getChipSelect() && !flash.getChipSelect()) {
  }
}",0.9285714285714286
5710,"public boolean emulateOP(long maxCycles){
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (cycles >= nextEventCycles) {
    executeEvents();
  }
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff) {
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return false;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return false;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad != AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
cycles+=5;
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
cycles+=3;
}
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
write=false;
updateStatus=false;
break;
case CALL:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as != AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=3;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
if (op != MOV) dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=dst - src;
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
dst=src ^ dst;
write=true;
break;
case AND:
dst=src & dst;
write=true;
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
}
}
dst&=0xffff;
if (write) {
if (dstRegMode) {
if (!word) dst&=0xff;
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
cpuCycles+=cycles - startCycles;
return true;
}","public boolean emulateOP(long maxCycles){
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (cycles >= nextEventCycles) {
    executeEvents();
  }
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff) {
    if (maxCycles >= 0 && maxCycles < nextEventCycles) {
      cycles=cycles < maxCycles ? maxCycles : cycles;
    }
 else {
      cycles=nextEventCycles;
    }
    return false;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return false;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad != AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
cycles+=5;
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
cycles+=3;
}
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
write=false;
updateStatus=false;
break;
case CALL:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as != AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=3;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
break;
}
}
if (dstRegMode) {
if (op != MOV) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
if (op != MOV) dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=dst - src;
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
dst=src ^ dst;
write=true;
break;
case AND:
dst=src & dst;
write=true;
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
}
}
if (word) {
dst&=0xffff;
}
 else {
dst&=0xff;
}
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
cpuCycles+=cycles - startCycles;
return true;
}",0.9961353312088956
5711,"public void dataReceived(USART source,int data){
  int oldStatus=status;
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ ((data >= ' ' && data <= 'Z') ? (char)data : '.')+ ')'+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ state+ ""String_Node_Str""+ stateMachine);
  }
  if ((stateMachine != STATE_VREG_OFF) && chipSelect) {
switch (state) {
case WAITING:
      if ((data & FLAG_READ) != 0) {
        state=READ_REGISTER;
      }
 else {
        state=WRITE_REGISTER;
      }
    if ((data & FLAG_RAM) != 0) {
      state=RAM_ACCESS;
      address=data & 0x7f;
    }
 else {
      address=data & 0x3f;
      if (address == REG_RXFIFO) {
        state=READ_RXFIFO;
      }
 else       if (address == REG_TXFIFO) {
        state=WRITE_TXFIFO;
      }
    }
  if (data < 0x0f) {
    strobe(data);
  }
pos=0;
break;
case WRITE_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
registers[address]=(registers[address] & 0xff) | (data << 8);
pos=1;
}
 else {
source.byteReceived(registers[address] & 0xff);
registers[address]=(registers[address] & 0xff00) | data;
state=WAITING;
}
break;
case READ_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
pos=1;
}
 else {
source.byteReceived(registers[address] & 0xff);
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
state=WAITING;
}
return;
case READ_RXFIFO:
if (rxfifoLen == 0) break;
if (DEBUG) System.out.println(""String_Node_Str"" + rxfifoReadPos + ""String_Node_Str""+ (memory[RAM_RXFIFO + rxfifoReadPos] & 0xFF));
source.byteReceived((memory[RAM_RXFIFO + rxfifoReadPos] & 0xFF));
rxfifoReadPos++;
setFIFOP(false);
if (--rxfifoLen == 0) setFIFO(false);
if (rxfifoReadPos >= 128) {
rxfifoReadPos=0;
}
if (rxPacket) {
rxPacket=false;
setFIFOP(false);
}
return;
case WRITE_TXFIFO:
if (txfifoFlush) {
txCursor=0;
txfifoFlush=false;
}
if (DEBUG) System.out.println(""String_Node_Str"" + data + ""String_Node_Str""+ txCursor);
memory[RAM_TXFIFO + txCursor++]=data & 0xff;
break;
case RAM_ACCESS:
if (pos == 0) {
address=address | (data << 1) & 0x180;
ramRead=(data & 0x20) != 0;
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ ramRead);
}
pos++;
}
 else {
if (!ramRead) {
memory[address++]=data;
if (DEBUG && address == RAM_PANID + 2) {
System.out.println(""String_Node_Str"" + Utils.hex8(memory[RAM_PANID]) + Utils.hex8(memory[RAM_PANID + 1]));
}
}
 else {
source.byteReceived(memory[address++]);
return;
}
}
break;
}
source.byteReceived(oldStatus);
}
}","public void dataReceived(USART source,int data){
  int oldStatus=status;
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + Utils.hex8(data) + ""String_Node_Str""+ ((data >= ' ' && data <= 'Z') ? (char)data : '.')+ ')'+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ state+ ""String_Node_Str""+ stateMachine);
  }
  if ((stateMachine != STATE_VREG_OFF) && chipSelect) {
switch (state) {
case WAITING:
      if ((data & FLAG_READ) != 0) {
        state=READ_REGISTER;
      }
 else {
        state=WRITE_REGISTER;
      }
    if ((data & FLAG_RAM) != 0) {
      state=RAM_ACCESS;
      address=data & 0x7f;
    }
 else {
      address=data & 0x3f;
      if (address == REG_RXFIFO) {
        state=READ_RXFIFO;
      }
 else       if (address == REG_TXFIFO) {
        state=WRITE_TXFIFO;
      }
    }
  if (data < 0x0f) {
    strobe(data);
    state=WAITING;
  }
pos=0;
break;
case WRITE_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
registers[address]=(registers[address] & 0xff) | (data << 8);
pos=1;
}
 else {
source.byteReceived(registers[address] & 0xff);
registers[address]=(registers[address] & 0xff00) | data;
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
switch (address) {
case REG_IOCFG0:
  System.out.println(""String_Node_Str"" + registers[address]);
break;
case REG_IOCFG1:
System.out.println(""String_Node_Str"" + ((registers[address] & SFDMUX) >> SFDMUX) + ""String_Node_Str""+ (registers[address] & CCAMUX));
if ((registers[address] & CCAMUX) == CCA_CCA) setCCA(false);
break;
}
}
state=WAITING;
}
break;
case READ_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
pos=1;
}
 else {
source.byteReceived(registers[address] & 0xff);
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
state=WAITING;
}
return;
case READ_RXFIFO:
if (rxfifoLen == 0) break;
if (DEBUG) System.out.println(""String_Node_Str"" + rxfifoReadPos + ""String_Node_Str""+ (memory[RAM_RXFIFO + rxfifoReadPos] & 0xFF));
source.byteReceived((memory[RAM_RXFIFO + rxfifoReadPos] & 0xFF));
rxfifoReadPos++;
setFIFOP(false);
if (--rxfifoLen == 0) setFIFO(false);
if (rxfifoReadPos >= 128) {
rxfifoReadPos=0;
}
if (rxPacket) {
rxPacket=false;
setFIFOP(false);
}
return;
case WRITE_TXFIFO:
if (txfifoFlush) {
txCursor=0;
txfifoFlush=false;
}
if (DEBUG) System.out.println(""String_Node_Str"" + data + ""String_Node_Str""+ txCursor);
memory[RAM_TXFIFO + txCursor++]=data & 0xff;
break;
case RAM_ACCESS:
if (pos == 0) {
address=address | (data << 1) & 0x180;
ramRead=(data & 0x20) != 0;
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ ramRead);
}
pos++;
}
 else {
if (!ramRead) {
memory[address++]=data;
if (DEBUG && address == RAM_PANID + 2) {
System.out.println(""String_Node_Str"" + Utils.hex8(memory[RAM_PANID]) + Utils.hex8(memory[RAM_PANID + 1]));
}
}
 else {
source.byteReceived(memory[address++]);
return;
}
}
break;
}
source.byteReceived(oldStatus);
}
}",0.8410419989367358
5712,"public String chipinfo(){
  return ""String_Node_Str"" + on + ""String_Node_Str""+ ((status & STATUS_XOSC16M_STABLE) > 0)+ ""String_Node_Str""+ ((status & STATUS_RSSI_VALID) > 0)+ ""String_Node_Str""+ cca+ ""String_Node_Str"";
}","public String chipinfo(){
  return ""String_Node_Str"" + on + ""String_Node_Str""+ ((status & STATUS_XOSC16M_STABLE) > 0)+ ""String_Node_Str""+ ((status & STATUS_RSSI_VALID) > 0)+ ""String_Node_Str""+ cca+ ""String_Node_Str""+ ((registers[REG_IOCFG0] & FIFOP_POLARITY) == FIFOP_POLARITY)+ ""String_Node_Str"";
}",0.8433268858800773
5713,"public ESBGui(ESBNode node){
  this.node=node;
  setBackground(Color.black);
  setOpaque(true);
  esbImage=new ImageIcon(""String_Node_Str"");
  if (esbImage.getIconWidth() == 0 || esbImage.getIconHeight() == 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  setPreferredSize(new Dimension(esbImage.getIconWidth(),esbImage.getIconHeight()));
  window=new JFrame(""String_Node_Str"");
  window.add(this);
  WindowUtils.restoreWindowBounds(""String_Node_Str"",window);
  WindowUtils.addSaveOnShutdown(""String_Node_Str"",window);
  window.setVisible(true);
  window.addKeyListener(this);
  addMouseMotionListener(this);
  addMouseListener(this);
  MSP430 cpu=node.getCPU();
  IOUnit usart=cpu.getIOUnit(""String_Node_Str"");
  if (usart instanceof USART) {
    serial=new SerialMon((USART)usart,""String_Node_Str"");
    ((USART)usart).setUSARTListener(serial);
  }
  IOUnit adc=cpu.getIOUnit(""String_Node_Str"");
  if (adc instanceof ADC12) {
    ((ADC12)adc).setADCInput(0,this);
  }
  beeper=new Beeper();
  cpu.addIOUnit(-1,0,-1,0,beeper,true);
  AudioFormat af=new AudioFormat(SAMPLE_RATE,16,1,true,false);
  DataLine.Info dlin=new DataLine.Info(TargetDataLine.class,af,DL_BUFFER_SIZE);
  try {
    inDataLine=(TargetDataLine)AudioSystem.getLine(dlin);
    if (inDataLine == null) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"" + inDataLine.getFormat());
      inDataLine.open(inDataLine.getFormat(),DL_BUFFER_SIZE);
      inDataLine.start();
    }
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
}","public ESBGui(ESBNode node){
  this.node=node;
  setBackground(Color.black);
  setOpaque(true);
  esbImage=new ImageIcon(""String_Node_Str"");
  if (esbImage.getIconWidth() == 0 || esbImage.getIconHeight() == 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  setPreferredSize(new Dimension(esbImage.getIconWidth(),esbImage.getIconHeight()));
  window=new JFrame(""String_Node_Str"");
  window.add(this);
  WindowUtils.restoreWindowBounds(""String_Node_Str"",window);
  WindowUtils.addSaveOnShutdown(""String_Node_Str"",window);
  window.setVisible(true);
  window.addKeyListener(this);
  addMouseMotionListener(this);
  addMouseListener(this);
  MSP430 cpu=node.getCPU();
  IOUnit usart=cpu.getIOUnit(""String_Node_Str"");
  if (usart instanceof USART) {
    serial=new SerialMon((USART)usart,""String_Node_Str"");
    ((USART)usart).setUSARTListener(serial);
  }
  IOUnit adc=cpu.getIOUnit(""String_Node_Str"");
  if (adc instanceof ADC12) {
    ((ADC12)adc).setADCInput(0,this);
  }
  beeper=new Beeper();
  cpu.addIOUnit(-1,0,-1,0,beeper);
  AudioFormat af=new AudioFormat(SAMPLE_RATE,16,1,true,false);
  DataLine.Info dlin=new DataLine.Info(TargetDataLine.class,af,DL_BUFFER_SIZE);
  try {
    inDataLine=(TargetDataLine)AudioSystem.getLine(dlin);
    if (inDataLine == null) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"" + inDataLine.getFormat());
      inDataLine.open(inDataLine.getFormat(),DL_BUFFER_SIZE);
      inDataLine.start();
    }
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
}",0.9984496124031008
5714,"private boolean checkInit(char c){
  if (INIT_COMMAND[initPos] == c) {
    initPos++;
    if (initPos == INIT_COMMAND.length) {
      initPos=0;
      System.out.println(""String_Node_Str"");
      return true;
    }
  }
 else {
    initPos=0;
  }
  return false;
}","private boolean checkInit(char c){
  if (INIT_COMMAND[initPos] == c) {
    initPos++;
    if (initPos == INIT_COMMAND.length) {
      initPos=0;
      System.out.println(""String_Node_Str"");
      return true;
    }
  }
 else {
    initPos=0;
    if (c == INIT_COMMAND[0]) {
      initPos=1;
    }
  }
  return false;
}",0.9053356282271944
5715,"public void write(int address,int data,boolean word,long cycles){
  memory[address]=data & 0xff;
  if (word) {
    memory[address + 1]=(data >> 8) & 0xff;
  }
  int iAddress=address - offset;
  if (DEBUG) {
    try {
      System.out.println(""String_Node_Str"" + getName() + ""String_Node_Str""+ (interrupt > 0 ? iNames[iAddress] : names[iAddress])+ ""String_Node_Str""+ Utils.hex8(address)+ ""String_Node_Str""+ Utils.hex8(data)+ ""String_Node_Str""+ Utils.binary8(data)+ ""String_Node_Str""+ word);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
switch (iAddress) {
case IN:
    break;
case OUT:
  if (listener != null) {
    listener.portWrite(this,data | (~dirReg) & 0xff);
  }
break;
case DIR:
dirReg=data;
break;
case SEL:
if (interrupt > 0) {
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + data);
}
interruptFlag&=data;
memory[offset + IFG]=interruptFlag;
cpu.flagInterrupt(interrupt,this,(interruptFlag & interruptEnable) > 0);
}
 else {
}
break;
case IES:
break;
case IE:
interruptEnable=data;
break;
case ISEL:
}
}","public void write(int address,int data,boolean word,long cycles){
  memory[address]=data & 0xff;
  if (word) {
    memory[address + 1]=(data >> 8) & 0xff;
  }
  int iAddress=address - offset;
  if (DEBUG) {
    try {
      System.out.println(""String_Node_Str"" + getName() + ""String_Node_Str""+ (interrupt > 0 ? iNames[iAddress] : names[iAddress])+ ""String_Node_Str""+ Utils.hex8(address)+ ""String_Node_Str""+ Utils.hex8(data)+ ""String_Node_Str""+ Utils.binary8(data)+ ""String_Node_Str""+ word);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
switch (iAddress) {
case IN:
    break;
case OUT:
  out=data;
if (listener != null) {
  listener.portWrite(this,out | (~dirReg) & 0xff);
}
break;
case DIR:
dirReg=data;
if (listener != null) {
listener.portWrite(this,out | (~dirReg) & 0xff);
}
break;
case SEL:
if (interrupt > 0) {
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + data);
}
interruptFlag&=data;
memory[offset + IFG]=interruptFlag;
cpu.flagInterrupt(interrupt,this,(interruptFlag & interruptEnable) > 0);
}
 else {
}
break;
case IES:
break;
case IE:
interruptEnable=data;
break;
case ISEL:
}
}",0.9560841720036596
5716,"public void setFIFOP(boolean fifop){
  fifopState=fifop;
  if ((registers[REG_IOCFG0] & FIFOP_POLARITY) == FIFOP_POLARITY) {
    fifopPort.setPinState(fifopPin,fifop ? 0 : 1);
  }
 else {
    fifopPort.setPinState(fifopPin,fifop ? 1 : 0);
  }
}","public void setFIFOP(boolean fifop){
  if ((registers[REG_IOCFG0] & FIFOP_POLARITY) == FIFOP_POLARITY) {
    fifopPort.setPinState(fifopPin,fifop ? 0 : 1);
  }
 else {
    fifopPort.setPinState(fifopPin,fifop ? 1 : 0);
  }
}",0.9572649572649572
5717,"public void setVRegOn(boolean on){
  if (this.on == on)   return;
  if (on) {
    cpu.scheduleTimeEventMillis(vregEvent,0.1);
  }
 else {
    this.on=on;
    setState(STATE_VREG_OFF);
  }
}","public void setVRegOn(boolean on){
  if (this.on == on)   return;
  if (on) {
    cpu.scheduleTimeEventMillis(vregEvent,0.1);
    System.out.println(getName() + ""String_Node_Str"" + cpu.cycles+ ""String_Node_Str""+ vregEvent.getTime()+ ""String_Node_Str""+ cpu.getTime());
  }
 else {
    this.on=on;
    setState(STATE_VREG_OFF);
  }
}",0.7269230769230769
5718,"public void write(int address,int value,boolean word,long cycles){
switch (address) {
case ADC12CTL0:
    adc12ctl0=value;
  shTime0=SHTBITS[(value >> 8) & 0x0f];
shTime1=SHTBITS[(value >> 12) & 0x0f];
adc12On=(value & 0x10) > 0;
enableConversion=(value & 0x02) > 0;
startConversion=(value & 0x01) > 0;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + shTime0+ ""String_Node_Str""+ shTime1+ ""String_Node_Str""+ enableConversion+ ""String_Node_Str""+ startConversion+ ""String_Node_Str""+ adc12On);
if (adc12On && enableConversion && startConversion) {
convert();
}
break;
case ADC12CTL1:
adc12ctl1=value;
startMem=(value >> 12) & 0xf;
shSource=(value >> 10) & 0x3;
adcDiv=((value >> 5) & 0x7) + 1;
conSeq=(value >> 1) & 0x03;
adcSSel=(value >> 3) & 0x03;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + startMem+ ""String_Node_Str""+ shSource+ ""String_Node_Str""+ conSeq+ ""String_Node_Str""+ adcDiv+ ""String_Node_Str""+ adcSSel);
break;
case ADC12IE:
adc12ie=value;
break;
case ADC12IFG:
adc12ifg=value;
break;
default :
if (address >= ADC12MCTL0 && address <= ADC12MCTL15) {
adc12mctl[address - ADC12MCTL0]=value & 0xff;
System.out.println(""String_Node_Str"" + (address - ADC12MCTL0) + ""String_Node_Str""+ (value & 0xf));
if ((value & 0x80) != 0) {
System.out.println(""String_Node_Str"" + (address - ADC12MCTL0) + ""String_Node_Str"");
}
}
}
}","public void write(int address,int value,boolean word,long cycles){
switch (address) {
case ADC12CTL0:
    adc12ctl0=value;
  shTime0=SHTBITS[(value >> 8) & 0x0f];
shTime1=SHTBITS[(value >> 12) & 0x0f];
adc12On=(value & 0x10) > 0;
enableConversion=(value & 0x02) > 0;
startConversion=(value & 0x01) > 0;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + shTime0+ ""String_Node_Str""+ shTime1+ ""String_Node_Str""+ enableConversion+ ""String_Node_Str""+ startConversion+ ""String_Node_Str""+ adc12On);
if (adc12On && enableConversion && startConversion) {
adcTrigger.time=core.getTime();
convert();
}
break;
case ADC12CTL1:
adc12ctl1=value;
startMem=(value >> 12) & 0xf;
shSource=(value >> 10) & 0x3;
adcDiv=((value >> 5) & 0x7) + 1;
conSeq=(value >> 1) & 0x03;
adcSSel=(value >> 3) & 0x03;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + startMem+ ""String_Node_Str""+ shSource+ ""String_Node_Str""+ conSeq+ ""String_Node_Str""+ adcDiv+ ""String_Node_Str""+ adcSSel);
break;
case ADC12IE:
adc12ie=value;
break;
case ADC12IFG:
adc12ifg=value;
break;
default :
if (address >= ADC12MCTL0 && address <= ADC12MCTL15) {
adc12mctl[address - ADC12MCTL0]=value & 0xff;
System.out.println(""String_Node_Str"" + (address - ADC12MCTL0) + ""String_Node_Str""+ (value & 0xf));
if ((value & 0x80) != 0) {
System.out.println(""String_Node_Str"" + (address - ADC12MCTL0) + ""String_Node_Str"");
}
}
}
}",0.9883211678832116
5719,"public void receivedByte(byte data){
  if (cca)   setClear(false);
  if (stateMachine == STATE_RX_SFD_SEARCH) {
    if (data == 0) {
      zero_symbols++;
      return;
    }
    if (zero_symbols == 4) {
      if (data == 0x7A) {
        setSFD(true);
        if (DEBUG)         System.out.println(""String_Node_Str"");
        rxread=0;
        setState(STATE_RX_FRAME);
      }
 else {
        zero_symbols=0;
      }
    }
  }
 else   if (stateMachine == STATE_RX_FRAME) {
    if (rxfifo_len == 128) {
      setRxOverflow();
    }
 else {
      memory[RAM_RXFIFO + rxfifo_write_pos++]=data & 0xFF;
      rxfifo_len++;
      if (rxfifo_write_pos == 128) {
        if (DEBUG)         System.out.println(""String_Node_Str"");
        rxfifo_write_pos=0;
      }
      if (rxread == 0) {
        rxlen=(int)data;
        if (DEBUG)         System.out.println(""String_Node_Str"" + rxlen);
        setFIFO(true);
      }
      if (rxread++ == rxlen) {
        memory[RAM_RXFIFO + (rxfifo_write_pos - 2)]=(registers[REG_RSSI]) & 0xff;
        memory[RAM_RXFIFO + (rxfifo_write_pos - 1)]=37 | 0x80;
        setFIFOP(true);
        setSFD(false);
        if (DEBUG)         System.out.println(""String_Node_Str"");
        setState(STATE_RX_WAIT);
      }
    }
  }
}","public void receivedByte(byte data){
  if (cca)   setClear(false);
  if (stateMachine == STATE_RX_WAIT) {
    setState(STATE_RX_SFD_SEARCH);
  }
  if (stateMachine == STATE_RX_SFD_SEARCH) {
    if (data == 0) {
      zero_symbols++;
      return;
    }
    if (zero_symbols == 4) {
      if (data == 0x7A) {
        setSFD(true);
        if (DEBUG)         System.out.println(""String_Node_Str"");
        rxread=0;
        setState(STATE_RX_FRAME);
      }
 else {
        zero_symbols=0;
      }
    }
  }
 else   if (stateMachine == STATE_RX_FRAME) {
    if (rxfifo_len == 128) {
      setRxOverflow();
    }
 else {
      memory[RAM_RXFIFO + rxfifo_write_pos++]=data & 0xFF;
      rxfifo_len++;
      if (rxfifo_write_pos == 128) {
        if (DEBUG)         System.out.println(""String_Node_Str"");
        rxfifo_write_pos=0;
      }
      if (rxread == 0) {
        rxlen=(int)data;
        if (DEBUG)         System.out.println(""String_Node_Str"" + rxlen);
        setFIFO(true);
      }
      if (rxread++ == rxlen) {
        memory[RAM_RXFIFO + (rxfifo_write_pos - 2)]=(registers[REG_RSSI]) & 0xff;
        memory[RAM_RXFIFO + (rxfifo_write_pos - 1)]=37 | 0x80;
        setFIFOP(true);
        setSFD(false);
        if (DEBUG)         System.out.println(""String_Node_Str"");
        setState(STATE_RX_WAIT);
      }
    }
  }
}",0.9698375870069604
5720,"public boolean emulateOP(){
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (cycles >= nextEventCycles) {
    executeEvents();
  }
  if (cycles >= nextIOTickCycles) {
    handleIO();
  }
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff) {
    cycles=nextIOTickCycles;
    return false;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return false;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad != AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
cycles+=5;
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
cycles+=3;
}
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
write=false;
updateStatus=false;
break;
case CALL:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as != AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=3;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
break;
}
}
if (dstRegMode) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=dst - src;
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
dst=src ^ dst;
write=true;
break;
case AND:
dst=src & dst;
write=true;
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
}
}
dst&=0xffff;
if (write) {
if (dstRegMode) {
if (!word) dst&=0xff;
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
cpuCycles+=cycles - startCycles;
return true;
}","public boolean emulateOP(){
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (cycles >= nextEventCycles) {
    executeEvents();
  }
  if (cycles >= nextIOTickCycles) {
    handleIO();
  }
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff) {
    cycles=nextIOTickCycles;
    return false;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return false;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad != AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
cycles+=5;
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
cycles+=3;
}
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
write=false;
updateStatus=false;
break;
case CALL:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as != AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=3;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
break;
}
}
if (dstRegMode) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
updateStatus=false;
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=dst - src;
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
dst=src ^ dst;
write=true;
break;
case AND:
dst=src & dst;
write=true;
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
}
}
dst&=0xffff;
if (write) {
if (dstRegMode) {
if (!word) dst&=0xff;
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
cpuCycles+=cycles - startCycles;
return true;
}",0.9986176389272878
5721,"public void write(int dstAddress,int dst,boolean word){
  if (breakPoints[dstAddress] != null) {
    breakPoints[dstAddress].cpuAction(CPUMonitor.MEMORY_WRITE,dstAddress,dst);
  }
  if (dstAddress <= 0x200 && memOut[dstAddress] != null) {
    if (!word)     dst&=0xff;
    memOut[dstAddress].write(dstAddress,dst,word,cycles);
  }
 else {
    memory[dstAddress]=dst & 0xff;
    if (word) {
      memory[dstAddress + 1]=(dst >> 8) & 0xff;
    }
  }
}","public void write(int dstAddress,int dst,boolean word){
  if (breakPoints[dstAddress] != null) {
    breakPoints[dstAddress].cpuAction(CPUMonitor.MEMORY_WRITE,dstAddress,dst);
  }
  if (dstAddress < 0x1ff && memOut[dstAddress] != null) {
    if (!word)     dst&=0xff;
    memOut[dstAddress].write(dstAddress,dst,word,cycles);
  }
 else {
    memory[dstAddress]=dst & 0xff;
    if (word) {
      memory[dstAddress + 1]=(dst >> 8) & 0xff;
    }
  }
}",0.992196209587514
5722,"public int read(int address,boolean word){
  int val=0;
  if (address < 0x200 && memIn[address] != null) {
    val=memIn[address].read(address,word,cycles);
  }
 else {
    address&=0xffff;
    val=memory[address] & 0xff;
    if (word) {
      val|=(memory[(address + 1) & 0xffff] << 8);
    }
  }
  return val;
}","public int read(int address,boolean word){
  int val=0;
  if (address < 0x1ff && memIn[address] != null) {
    val=memIn[address].read(address,word,cycles);
  }
 else {
    address&=0xffff;
    val=memory[address] & 0xff;
    if (word) {
      val|=(memory[(address + 1) & 0xffff] << 8);
    }
  }
  return val;
}",0.9904153354632588
5723,"private void calculateNextEventTime(long cycles){
  long time=nextTimerTrigger;
  int smallest=-1;
  for (int i=0; i < expCaptureTime.length; i++) {
    long ct=expCaptureTime[i];
    if (ct > 0 && ct < time) {
      time=ct;
      smallest=i;
    }
  }
  if (time == 0) {
    time=cycles + 1000;
  }
  if (timerTrigger.scheduledIn == null) {
    core.scheduleCycleEvent(timerTrigger,time);
  }
 else   if (timerTrigger.time > time) {
    core.scheduleCycleEvent(timerTrigger,time);
  }
}","private void calculateNextEventTime(long cycles){
  if (mode == STOP) {
    return;
  }
  long time=nextTimerTrigger;
  int smallest=-1;
  for (int i=0; i < noCompare; i++) {
    long ct=expCaptureTime[i];
    if (ct > 0 && ct < time) {
      time=ct;
      smallest=i;
    }
  }
  if (time == 0) {
    time=cycles + 1000;
  }
  if (timerTrigger.scheduledIn == null) {
    System.out.println(getName() + ""String_Node_Str"" + time+ ""String_Node_Str""+ smallest+ ""String_Node_Str""+ (smallest > 0 ? expCaptureTime[smallest] + ""String_Node_Str"" + expCompare[smallest] : nextTimerTrigger)+ ""String_Node_Str""+ cycles);
    core.scheduleCycleEvent(timerTrigger,time);
  }
 else   if (timerTrigger.time > time) {
    System.out.println(getName() + ""String_Node_Str"" + time+ ""String_Node_Str""+ cycles);
    core.scheduleCycleEvent(timerTrigger,time);
  }
}",0.7021755438859715
5724,"public void triggerInterrupts(){
  boolean trigger=false;
  int tIndex=0;
  for (int i=0, n=noCompare; i < n; i++) {
    boolean newTrigger=(tcctl[i] & CC_TRIGGER_INT) == CC_TRIGGER_INT;
    trigger=trigger | newTrigger;
    if (i == 0) {
      core.flagInterrupt(ccr0Vector,this,trigger);
      if (trigger) {
        lastTIV=0;
        return;
      }
    }
 else {
      if (newTrigger) {
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + (i * 2));
        }
        tIndex=i;
      }
    }
    if (trigger) {
      lastTIV=memory[type == TIMER_A ? TAIV : TBIV]=tIndex * 2;
    }
  }
  if (!trigger) {
    if (interruptEnable && interruptPending) {
      trigger=true;
      lastTIV=memory[type == TIMER_A ? TAIV : TBIV]=timerOverflow;
    }
  }
  core.flagInterrupt(ccr1Vector,this,trigger);
}","public void triggerInterrupts(long cycles){
  boolean trigger=false;
  int tIndex=0;
  for (int i=0, n=noCompare; i < n; i++) {
    boolean newTrigger=(tcctl[i] & CC_TRIGGER_INT) == CC_TRIGGER_INT;
    trigger=trigger | newTrigger;
    if (i == 0) {
      core.flagInterrupt(ccr0Vector,this,trigger);
      if (trigger) {
        lastTIV=0;
        return;
      }
    }
 else {
      if (newTrigger) {
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + (i * 2)+ ""String_Node_Str""+ cycles);
        }
        tIndex=i;
      }
    }
    if (trigger) {
      lastTIV=memory[type == TIMER_A ? TAIV : TBIV]=tIndex * 2;
    }
  }
  if (!trigger) {
    if (interruptEnable && interruptPending) {
      trigger=true;
      lastTIV=memory[type == TIMER_A ? TAIV : TBIV]=timerOverflow;
    }
  }
  core.flagInterrupt(ccr1Vector,this,trigger);
}",0.9775943396226416
5725,"public int read(int address,boolean word,long cycles){
  if (address == TAIV || address == TBIV) {
    int val=lastTIV;
    resetTIV();
    return val;
  }
  int val=0;
  int index=address - offset;
switch (index) {
case TR:
    val=updateCounter(cycles);
  break;
case TCTL:
val=tctl;
if (interruptPending) {
val|=1;
}
 else {
val&=0xfffe;
}
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + name[type]+ ""String_Node_Str""+ inputDivider+ ""String_Node_Str""+ getSourceName(clockSource)+ ""String_Node_Str""+ interruptEnable+ ""String_Node_Str""+ interruptPending+ ""String_Node_Str""+ mode);
break;
case TCCTL0:
case TCCTL1:
case TCCTL2:
case TCCTL3:
case TCCTL4:
case TCCTL5:
case TCCTL6:
int i=(index - TCCTL0) / 2;
val=tcctl[i];
break;
case TCCR0:
case TCCR1:
case TCCR2:
case TCCR3:
case TCCR4:
case TCCR5:
case TCCR6:
i=(index - TCCR0) / 2;
val=tccr[i];
break;
default :
System.out.println(""String_Node_Str"");
}
if (DEBUG && false) {
System.out.println(getName() + ""String_Node_Str"" + getName(address)+ ""String_Node_Str""+ Utils.hex16(address)+ ""String_Node_Str""+ Utils.hex16(val)+ ""String_Node_Str""+ val+ ""String_Node_Str"");
}
return val & 0xffff;
}","public int read(int address,boolean word,long cycles){
  if (address == TAIV || address == TBIV) {
    int val=lastTIV;
    resetTIV(cycles);
    return val;
  }
  int val=0;
  int index=address - offset;
switch (index) {
case TR:
    val=updateCounter(cycles);
  break;
case TCTL:
val=tctl;
if (interruptPending) {
val|=1;
}
 else {
val&=0xfffe;
}
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + name[type]+ ""String_Node_Str""+ inputDivider+ ""String_Node_Str""+ getSourceName(clockSource)+ ""String_Node_Str""+ interruptEnable+ ""String_Node_Str""+ interruptPending+ ""String_Node_Str""+ mode);
break;
case TCCTL0:
case TCCTL1:
case TCCTL2:
case TCCTL3:
case TCCTL4:
case TCCTL5:
case TCCTL6:
int i=(index - TCCTL0) / 2;
val=tcctl[i];
break;
case TCCR0:
case TCCR1:
case TCCR2:
case TCCR3:
case TCCR4:
case TCCR5:
case TCCR6:
i=(index - TCCR0) / 2;
val=tccr[i];
break;
default :
System.out.println(""String_Node_Str"");
}
if (DEBUG && false) {
System.out.println(getName() + ""String_Node_Str"" + getName(address)+ ""String_Node_Str""+ Utils.hex16(address)+ ""String_Node_Str""+ Utils.hex16(val)+ ""String_Node_Str""+ val+ ""String_Node_Str"");
}
return val & 0xffff;
}",0.9974160206718348
5726,"private void resetTIV(){
  if (lastTIV == timerOverflow) {
    interruptPending=false;
    lastTIV=0;
    if (DEBUG) {
      System.out.println(getName() + ""String_Node_Str"");
    }
    triggerInterrupts();
  }
  if (lastTIV / 2 < noCompare) {
    if (DEBUG) {
      System.out.println(getName() + ""String_Node_Str"" + lastTIV);
    }
    tcctl[lastTIV / 2]&=~CC_IFG;
    triggerInterrupts();
  }
}","private void resetTIV(long cycles){
  if (lastTIV == timerOverflow) {
    interruptPending=false;
    lastTIV=0;
    if (DEBUG) {
      System.out.println(getName() + ""String_Node_Str"");
    }
    triggerInterrupts(cycles);
  }
  if (lastTIV / 2 < noCompare) {
    if (DEBUG) {
      System.out.println(getName() + ""String_Node_Str"" + lastTIV);
    }
    tcctl[lastTIV / 2]&=~CC_IFG;
    triggerInterrupts(cycles);
  }
}",0.9718482252141984
5727,"public void reset(int type){
  for (int i=0, n=expCompare.length; i < n; i++) {
    expCompare[i]=-1;
    expCaptureTime[i]=-1;
    expCapInterval[i]=0;
    outMode[i]=0;
    capMode[i]=0;
    inputSel[i]=0;
    inputSrc[i]=0;
    captureOn[i]=false;
  }
  for (int i=0; i < tcctl.length; i++) {
    tcctl[i]=0;
    tccr[i]=0;
  }
  tctl=0;
  lastTIV=0;
  interruptEnable=false;
  interruptPending=false;
  counter=0;
  counterPassed=0;
  counterStart=0;
  clockSource=0;
  cyclesMultiplicator=1;
  mode=STOP;
  nextTimerTrigger=0;
  inputDivider=1;
}","public void reset(int type){
  for (int i=0, n=expCompare.length; i < n; i++) {
    expCompare[i]=-1;
    expCaptureTime[i]=-1;
    expCapInterval[i]=0;
    outMode[i]=0;
    capMode[i]=0;
    inputSel[i]=0;
    inputSrc[i]=0;
    captureOn[i]=false;
  }
  for (int i=0; i < tcctl.length; i++) {
    tcctl[i]=0;
    tccr[i]=0;
  }
  tctl=0;
  lastTIV=0;
  interruptEnable=false;
  interruptPending=false;
  counter=0;
  counterPassed=0;
  counterStart=0;
  initialCounter=0;
  clockSource=0;
  cyclesMultiplicator=1;
  mode=STOP;
  nextTimerTrigger=0;
  inputDivider=1;
}",0.982174688057041
5728,"private void updateTimers(long cycles){
  if (cycles >= nextTimerTrigger) {
    interruptPending=true;
    nextTimerTrigger=(long)(nextTimerTrigger + 0x10000 * cyclesMultiplicator);
  }
  for (int i=0, n=noCompare; i < n; i++) {
    if (expCaptureTime[i] != -1 && cycles >= expCaptureTime[i]) {
      if (DEBUG) {
        System.out.println(getName() + ""String_Node_Str"" + i+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ expCaptureTime[i]+ ""String_Node_Str""+ Utils.hex16(expCompare[i])+ ""String_Node_Str""+ Utils.hex16(updateCounter(cycles)));
      }
      tcctl[i]|=CC_IFG;
      if (captureOn[i]) {
        tccr[i]=expCompare[i];
        expCompare[i]=(expCompare[i] + expCapInterval[i]) & 0xffff;
        expCaptureTime[i]+=expCapInterval[i] * cyclesMultiplicator;
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + expCaptureTime[i]);
        }
      }
 else {
        expCaptureTime[i]=expCaptureTime[i] + (long)(0x10000 * cyclesMultiplicator);
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + expCaptureTime[i]);
        }
      }
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + Utils.hex16(offset + TCCTL0 + i * 2 + 1));
      }
    }
  }
  triggerInterrupts();
  calculateNextEventTime(cycles);
}","private void updateTimers(long cycles){
  if (mode == STOP) {
    System.out.println(""String_Node_Str"");
    return;
  }
  if (cycles >= nextTimerTrigger) {
    interruptPending=true;
    nextTimerTrigger=(long)(nextTimerTrigger + 0x10000 * cyclesMultiplicator);
  }
  for (int i=0, n=noCompare; i < n; i++) {
    if (expCaptureTime[i] != -1 && cycles >= expCaptureTime[i]) {
      if (DEBUG) {
        System.out.println(getName() + (captureOn[i] ? ""String_Node_Str"" : ""String_Node_Str"") + i+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ expCaptureTime[i]+ ""String_Node_Str""+ Utils.hex16(expCompare[i])+ ""String_Node_Str""+ Utils.hex16(updateCounter(cycles)));
      }
      tcctl[i]|=CC_IFG;
      if (captureOn[i]) {
        tccr[i]=expCompare[i];
        expCompare[i]=(expCompare[i] + expCapInterval[i]) & 0xffff;
        expCaptureTime[i]+=expCapInterval[i] * cyclesMultiplicator;
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + expCaptureTime[i]);
        }
      }
 else {
        expCaptureTime[i]=expCaptureTime[i] + (long)(0x10000 * cyclesMultiplicator);
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + expCaptureTime[i]);
        }
      }
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + Utils.hex16(offset + TCCTL0 + i * 2 + 1));
      }
    }
  }
  triggerInterrupts(cycles);
  calculateNextEventTime(cycles);
}",0.9540400296515936
5729,"public void write(int address,int data,boolean word,long cycles){
  int iAddress=address - offset;
switch (iAddress) {
case TR:
    setCounter(data,cycles);
  break;
case TCTL:
if (DEBUG) {
  System.out.println(getName() + ""String_Node_Str"" + Utils.hex16(data));
}
inputDivider=1 << ((data >> 6) & 3);
clockSource=srcMap[(data >> 8) & 3];
cyclesMultiplicator=inputDivider;
if (clockSource == SRC_ACLK) {
cyclesMultiplicator=(cyclesMultiplicator * core.smclkFrq) / core.aclkFrq;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cyclesMultiplicator);
}
}
if ((data & TCLR) != 0) {
counter=0;
counterStart=cycles;
updateCaptures(-1,cycles);
}
int newMode=(data >> 4) & 3;
if (mode == STOP && newMode != STOP) {
updateCounter(cycles);
nextTimerTrigger=(long)(cycles + cyclesMultiplicator * ((0xffff - counter) & 0xffff));
}
mode=newMode;
interruptEnable=(data & 0x02) > 0;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + name[type]+ ""String_Node_Str""+ inputDivider+ ""String_Node_Str""+ getSourceName(clockSource)+ ""String_Node_Str""+ interruptEnable+ ""String_Node_Str""+ interruptPending+ ""String_Node_Str""+ mode+ ((data & TCLR) != 0 ? ""String_Node_Str"" : ""String_Node_Str""));
}
tctl=data;
tctl&=~0x04;
if ((data & 0x01) == 0) {
interruptPending=false;
}
updateCaptures(-1,cycles);
break;
case TCCTL0:
case TCCTL1:
case TCCTL2:
case TCCTL3:
case TCCTL4:
case TCCTL5:
case TCCTL6:
int index=(iAddress - TCCTL0) / 2;
tcctl[index]=data;
outMode[index]=(data >> 5) & 7;
captureOn[index]=(data & 0x100) > 0;
sync[index]=(data & 0x800) > 0;
inputSel[index]=(data >> 12) & 3;
inputSrc[index]=srcMap[4 + index * 4 + inputSel[index]];
capMode[index]=(data >> 14) & 3;
triggerInterrupts();
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ capNames[capMode[index]]+ ""String_Node_Str""+ inputSel[index]+ ""String_Node_Str""+ getSourceName(inputSrc[index])+ ""String_Node_Str""+ captureOn[index]+ ""String_Node_Str""+ ((data & CC_IE) != 0));
}
updateCaptures(index,cycles);
break;
case TCCR0:
case TCCR1:
case TCCR2:
case TCCR3:
case TCCR4:
case TCCR5:
case TCCR6:
index=(iAddress - TCCR0) / 2;
tccr[index]=data;
updateCounter(cycles);
int diff=data - counter;
if (diff < 0) {
diff+=0x10000;
}
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ Utils.hex16(counter)+ ""String_Node_Str""+ Utils.hex16(diff));
}
expCaptureTime[index]=cycles + (long)(cyclesMultiplicator * diff) - counterPassed;
counterPassed=0;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cycles+ ""String_Node_Str""+ index+ ""String_Node_Str""+ expCaptureTime[index]+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ data+ ""String_Node_Str""+ (100 * (cyclesMultiplicator * diff * 1L) / 2500000) / 100.0 + ""String_Node_Str"" + ""String_Node_Str"" + expCaptureTime[index]);
}
calculateNextEventTime(cycles);
}
}","public void write(int address,int data,boolean word,long cycles){
  int iAddress=address - offset;
switch (iAddress) {
case TR:
    setCounter(data,cycles);
  break;
case TCTL:
if (DEBUG) {
  System.out.println(getName() + ""String_Node_Str"" + Utils.hex16(data));
}
inputDivider=1 << ((data >> 6) & 3);
clockSource=srcMap[(data >> 8) & 3];
cyclesMultiplicator=inputDivider;
if (clockSource == SRC_ACLK) {
cyclesMultiplicator=(cyclesMultiplicator * core.smclkFrq) / core.aclkFrq;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cyclesMultiplicator);
}
}
if ((data & TCLR) != 0) {
counter=0;
counterStart=cycles;
updateCaptures(-1,cycles);
}
int newMode=(data >> 4) & 3;
if (mode == STOP && newMode != STOP) {
initialCounter=counter;
counterStart=cycles;
nextTimerTrigger=(long)(cycles + cyclesMultiplicator * ((0xffff - counter) & 0xffff));
if (DEBUG) System.out.println(getName() + ""String_Node_Str"");
recalculateCompares(cycles);
}
mode=newMode;
interruptEnable=(data & 0x02) > 0;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + name[type]+ ""String_Node_Str""+ inputDivider+ ""String_Node_Str""+ getSourceName(clockSource)+ ""String_Node_Str""+ interruptEnable+ ""String_Node_Str""+ interruptPending+ ""String_Node_Str""+ mode+ ((data & TCLR) != 0 ? ""String_Node_Str"" : ""String_Node_Str""));
}
tctl=data;
tctl&=~0x04;
if ((data & 0x01) == 0) {
interruptPending=false;
}
updateCaptures(-1,cycles);
break;
case TCCTL0:
case TCCTL1:
case TCCTL2:
case TCCTL3:
case TCCTL4:
case TCCTL5:
case TCCTL6:
int index=(iAddress - TCCTL0) / 2;
tcctl[index]=data;
outMode[index]=(data >> 5) & 7;
captureOn[index]=(data & 0x100) > 0;
sync[index]=(data & 0x800) > 0;
inputSel[index]=(data >> 12) & 3;
inputSrc[index]=srcMap[4 + index * 4 + inputSel[index]];
capMode[index]=(data >> 14) & 3;
triggerInterrupts(cycles);
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ capNames[capMode[index]]+ ""String_Node_Str""+ inputSel[index]+ ""String_Node_Str""+ getSourceName(inputSrc[index])+ ""String_Node_Str""+ captureOn[index]+ ""String_Node_Str""+ ((data & CC_IE) != 0));
}
updateCaptures(index,cycles);
break;
case TCCR0:
case TCCR1:
case TCCR2:
case TCCR3:
case TCCR4:
case TCCR5:
case TCCR6:
index=(iAddress - TCCR0) / 2;
tccr[index]=data;
updateCounter(cycles);
int diff=data - counter;
if (diff < 0) {
diff+=0x10000;
}
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ Utils.hex16(counter)+ ""String_Node_Str""+ Utils.hex16(diff));
}
expCaptureTime[index]=cycles + (long)(cyclesMultiplicator * diff) - counterPassed;
counterPassed=0;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cycles+ ""String_Node_Str""+ index+ ""String_Node_Str""+ expCaptureTime[index]+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ data+ ""String_Node_Str""+ (100 * (cyclesMultiplicator * diff * 1L) / 2500000) / 100.0 + ""String_Node_Str"" + ""String_Node_Str"" + expCaptureTime[index]);
}
calculateNextEventTime(cycles);
}
}",0.5055786844296419
5730,"private int updateCounter(long cycles){
  double divider=1;
  if (clockSource == SRC_ACLK) {
    divider=1.0 * core.smclkFrq / core.aclkFrq;
  }
  divider=divider * inputDivider;
  long cycctr=cycles - counterStart;
  double tick=cycctr / divider;
  counterPassed=(int)(divider * (tick - (long)(tick)));
switch (mode) {
case CONTIN:
    counter=((int)tick) & 0xffff;
  break;
case UP:
counter=((int)tick) % tccr[0];
break;
case UPDWN:
counter=((int)tick) % (tccr[0] * 2);
if (counter > tccr[0]) {
counter=2 * tccr[0] - counter;
}
}
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cycctr+ ""String_Node_Str""+ divider+ ""String_Node_Str""+ mode+ ""String_Node_Str""+ counter);
}
return counter;
}","private int updateCounter(long cycles){
  if (mode == STOP)   return counter;
  double divider=1;
  if (clockSource == SRC_ACLK) {
    divider=1.0 * core.smclkFrq / core.aclkFrq;
  }
  divider=divider * inputDivider;
  long cycctr=cycles - counterStart;
  double tick=cycctr / divider;
  counterPassed=(int)(divider * (tick - (long)(tick)));
switch (mode) {
case CONTIN:
    counter=((int)tick + initialCounter) & 0xffff;
  break;
case UP:
counter=((int)tick + initialCounter) % tccr[0];
break;
case UPDWN:
counter=((int)tick + initialCounter) % (tccr[0] * 2);
if (counter > tccr[0]) {
counter=2 * tccr[0] - counter;
}
}
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cycctr+ ""String_Node_Str""+ divider+ ""String_Node_Str""+ mode+ ""String_Node_Str""+ counter);
}
return counter;
}",0.9406270847231488
5731,"public boolean emulateOP(){
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (cycles >= nextEventCycles) {
    executeEvents();
  }
  if (cycles >= nextIOTickCycles) {
    handleIO();
  }
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff) {
    cycles=nextIOTickCycles;
    return false;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return false;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad != AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
cycles+=5;
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
cycles+=3;
}
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
write=false;
updateStatus=false;
break;
case CALL:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as != AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=3;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
break;
}
}
if (dstRegMode) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=dst - src;
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
dst=src ^ dst;
write=true;
break;
case AND:
dst=src & dst;
write=true;
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
}
}
dst&=0xffff;
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
cpuCycles+=cycles - startCycles;
return true;
}","public boolean emulateOP(){
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (cycles >= nextEventCycles) {
    executeEvents();
  }
  if (cycles >= nextIOTickCycles) {
    handleIO();
  }
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff) {
    cycles=nextIOTickCycles;
    return false;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return false;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad != AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
cycles+=5;
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
cycles+=3;
}
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
write=false;
updateStatus=false;
break;
case CALL:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as != AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=3;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
break;
}
}
if (dstRegMode) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=dst - src;
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
dst=src ^ dst;
write=true;
break;
case AND:
dst=src & dst;
write=true;
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
}
}
dst&=0xffff;
if (write) {
if (dstRegMode) {
if (!word) dst&=0xff;
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
cpuCycles+=cycles - startCycles;
return true;
}",0.9984749757382504
5732,"public void setupCommands(ComponentRegistry registry,CommandHandler ch){
  final MSP430 cpu=(MSP430)registry.getComponent(MSP430.class);
  final ELF elf=(ELF)registry.getComponent(ELF.class);
  final GenericNode node=(GenericNode)registry.getComponent(""String_Node_Str"");
  if (cpu != null) {
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int address=0;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(address=baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            context.out.println(""String_Node_Str"" + adr);
          }
        }
);
        context.out.println(""String_Node_Str"" + baddr);
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int address=0;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        if (baddr == -1) {
          context.out.println(""String_Node_Str"" + context.getArgument(0));
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          String modeStr=context.getArgument(1);
          if (""String_Node_Str"".equals(modeStr)) {
            mode=1;
          }
        }
        cpu.setBreakPoint(address=baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0) {
              int pc=cpu.readRegister(0);
              String adrStr=getSymOrAddr(context,adr);
              String pcStr=getSymOrAddrELF(elf,pc);
              context.out.println(""String_Node_Str"" + pcStr + ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
            }
 else {
              context.out.print((char)data);
            }
          }
        }
);
        context.out.println(""String_Node_Str"" + baddr);
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
        context.exit(0);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int register=0;
      public int executeCommand(      final CommandContext context){
        register=context.getArgumentAsRegister(0);
        if (register < 0) {
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          String modeStr=context.getArgument(1);
          if (""String_Node_Str"".equals(modeStr)) {
            mode=1;
          }
 else {
            context.err.println(""String_Node_Str"" + modeStr);
            return -1;
          }
        }
        cpu.setRegisterWriteMonitor(register,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0) {
              int pc=cpu.readRegister(0);
              String adrStr=getRegisterName(register);
              String pcStr=getSymOrAddrELF(elf,pc);
              context.out.println(""String_Node_Str"" + pcStr + ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
            }
 else {
              context.out.println(data);
            }
          }
        }
);
        context.out.println(""String_Node_Str"" + getRegisterName(register));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(register);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new Command(){
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(baddr,null);
        return 0;
      }
      public String getArgumentHelp(      String commandName){
        return ""String_Node_Str"";
      }
      public String getCommandHelp(      String commandName){
        return ""String_Node_Str"";
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
      public int executeCommand(      final CommandContext context){
        String regExp=context.getArgument(0);
        MapEntry[] entries=context.getMapTable().getEntries(regExp);
        for (int i=0; i < entries.length; i++) {
          MapEntry mapEntry=entries[i];
          context.out.println(""String_Node_Str"" + mapEntry.getName() + ""String_Node_Str""+ Utils.hex16(mapEntry.getAddress()));
        }
        return 0;
      }
    }
);
    if (node != null) {
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.stop();
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)));
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.start();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int nr=context.getArgumentCount() > 0 ? context.getArgumentAsInt(0) : 1;
          while (nr-- > 0)           node.step();
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)));
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int stackEnd=context.getMapTable().heapStartAddress;
          int stackStart=context.getMapTable().stackStartAddress;
          int current=cpu.readRegister(MSP430Constants.SP);
          context.out.println(""String_Node_Str"" + Utils.hex16(current) + ""String_Node_Str""+ (stackStart - current)+ ""String_Node_Str""+ (stackStart - stackEnd)+ ')');
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int adr=context.getArgumentAsAddress(0);
          if (adr != -1) {
            context.out.println(""String_Node_Str"" + context.getArgument(0) + ""String_Node_Str""+ Utils.hex16(cpu.read(adr,adr >= 0x100)));
          }
 else {
            context.out.println(""String_Node_Str"");
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int register=context.getArgumentAsRegister(0);
          if (register >= 0) {
            context.out.println(context.getArgument(0) + ""String_Node_Str"" + Utils.hex16(cpu.readRegister(register)));
            return 0;
          }
          return -1;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          cpu.reset();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          long time=((long)(cpu.getTimeMillis()));
          context.out.println(""String_Node_Str"" + time + ""String_Node_Str""+ (time - lastCall)+ ""String_Node_Str""+ ""String_Node_Str""+ (System.currentTimeMillis() - lastWall)+ ""String_Node_Str"");
          lastCall=time;
          lastWall=System.currentTimeMillis();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int start=context.getArgumentAsAddress(0);
          int count=context.getArgumentAsInt(1);
          int size=1;
          boolean signed=false;
          if (context.getArgumentCount() > 2) {
            String tS=context.getArgument(2);
            if (""String_Node_Str"".equals(tS)) {
              signed=true;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              signed=true;
              size=2;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              size=2;
            }
          }
          for (int i=0; i < count; i++) {
            int data=0;
            data=cpu.memory[start++];
            if (size == 2) {
              data=data + (cpu.memory[start++] << 8);
            }
            context.out.print(""String_Node_Str"" + data);
          }
          context.out.println();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int adr=context.getArgumentAsAddress(0);
          int val=context.getArgumentAsInt(1);
          boolean word=val > 0xff;
          cpu.write(adr,val,word);
          return 0;
        }
      }
);
    }
  }
}","public void setupCommands(ComponentRegistry registry,CommandHandler ch){
  final MSP430 cpu=(MSP430)registry.getComponent(MSP430.class);
  final ELF elf=(ELF)registry.getComponent(ELF.class);
  final GenericNode node=(GenericNode)registry.getComponent(""String_Node_Str"");
  if (cpu != null) {
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int address=0;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(address=baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            context.out.println(""String_Node_Str"" + adr);
          }
        }
);
        context.out.println(""String_Node_Str"" + baddr);
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int address=0;
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        if (baddr == -1) {
          context.out.println(""String_Node_Str"" + context.getArgument(0));
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          String modeStr=context.getArgument(1);
          if (""String_Node_Str"".equals(modeStr)) {
            mode=1;
          }
 else           if (""String_Node_Str"".equals(modeStr)) {
            mode=2;
          }
        }
        cpu.setBreakPoint(address=baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0 || mode == 2) {
              int pc=cpu.readRegister(0);
              String adrStr=getSymOrAddr(context,adr);
              String pcStr=getSymOrAddrELF(elf,pc);
              String op=""String_Node_Str"";
              if (type == MEMORY_READ) {
                op=""String_Node_Str"";
              }
 else               if (type == MEMORY_WRITE) {
                op=""String_Node_Str"";
              }
              context.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pcStr+ ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
              if (mode == 2) {
                cpu.stop();
              }
            }
 else {
              context.out.print((char)data);
            }
          }
        }
);
        context.out.println(""String_Node_Str"" + baddr);
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(address);
        context.exit(0);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicAsyncCommand(""String_Node_Str"",""String_Node_Str""){
      int mode=0;
      int register=0;
      public int executeCommand(      final CommandContext context){
        register=context.getArgumentAsRegister(0);
        if (register < 0) {
          return -1;
        }
        if (context.getArgumentCount() > 1) {
          String modeStr=context.getArgument(1);
          if (""String_Node_Str"".equals(modeStr)) {
            mode=1;
          }
 else {
            context.err.println(""String_Node_Str"" + modeStr);
            return -1;
          }
        }
        cpu.setRegisterWriteMonitor(register,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            if (mode == 0) {
              int pc=cpu.readRegister(0);
              String adrStr=getRegisterName(register);
              String pcStr=getSymOrAddrELF(elf,pc);
              context.out.println(""String_Node_Str"" + pcStr + ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
            }
 else {
              context.out.println(data);
            }
          }
        }
);
        context.out.println(""String_Node_Str"" + getRegisterName(register));
        return 0;
      }
      public void stopCommand(      CommandContext context){
        cpu.clearBreakPoint(register);
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new Command(){
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(baddr,null);
        return 0;
      }
      public String getArgumentHelp(      String commandName){
        return ""String_Node_Str"";
      }
      public String getCommandHelp(      String commandName){
        return ""String_Node_Str"";
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
      public int executeCommand(      final CommandContext context){
        String regExp=context.getArgument(0);
        MapEntry[] entries=context.getMapTable().getEntries(regExp);
        for (int i=0; i < entries.length; i++) {
          MapEntry mapEntry=entries[i];
          context.out.println(""String_Node_Str"" + mapEntry.getName() + ""String_Node_Str""+ Utils.hex16(mapEntry.getAddress()));
        }
        return 0;
      }
    }
);
    if (node != null) {
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.stop();
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)));
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          node.start();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int nr=context.getArgumentCount() > 0 ? context.getArgumentAsInt(0) : 1;
          long cyc=cpu.cycles;
          node.step(nr);
          context.out.println(""String_Node_Str"" + Utils.hex16(cpu.readRegister(0)) + ""String_Node_Str""+ (cpu.cycles - cyc)+ ""String_Node_Str""+ cpu.cycles+ ""String_Node_Str"");
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int stackEnd=context.getMapTable().heapStartAddress;
          int stackStart=context.getMapTable().stackStartAddress;
          int current=cpu.readRegister(MSP430Constants.SP);
          context.out.println(""String_Node_Str"" + Utils.hex16(current) + ""String_Node_Str""+ (stackStart - current)+ ""String_Node_Str""+ (stackStart - stackEnd)+ ')');
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int adr=context.getArgumentAsAddress(0);
          if (adr != -1) {
            context.out.println(""String_Node_Str"" + context.getArgument(0) + ""String_Node_Str""+ Utils.hex16(cpu.read(adr,adr >= 0x100)));
          }
 else {
            context.out.println(""String_Node_Str"");
          }
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          int register=context.getArgumentAsRegister(0);
          if (register >= 0) {
            context.out.println(context.getArgument(0) + ""String_Node_Str"" + Utils.hex16(cpu.readRegister(register)));
            return 0;
          }
          return -1;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          cpu.reset();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        CommandContext context){
          long time=((long)(cpu.getTimeMillis()));
          context.out.println(""String_Node_Str"" + time + ""String_Node_Str""+ (time - lastCall)+ ""String_Node_Str""+ ""String_Node_Str""+ (System.currentTimeMillis() - lastWall)+ ""String_Node_Str"");
          lastCall=time;
          lastWall=System.currentTimeMillis();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int start=context.getArgumentAsAddress(0);
          int count=context.getArgumentAsInt(1);
          int size=1;
          boolean signed=false;
          if (context.getArgumentCount() > 2) {
            String tS=context.getArgument(2);
            if (""String_Node_Str"".equals(tS)) {
              signed=true;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              signed=true;
              size=2;
            }
 else             if (""String_Node_Str"".equals(tS)) {
              size=2;
            }
          }
          for (int i=0; i < count; i++) {
            int data=0;
            data=cpu.memory[start++];
            if (size == 2) {
              data=data + (cpu.memory[start++] << 8);
            }
            context.out.print(""String_Node_Str"" + data);
          }
          context.out.println();
          return 0;
        }
      }
);
      ch.registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
        public int executeCommand(        final CommandContext context){
          int adr=context.getArgumentAsAddress(0);
          int val=context.getArgumentAsInt(1);
          boolean word=val > 0xff;
          cpu.write(adr,val,word);
          return 0;
        }
      }
);
    }
  }
}",0.9650010324179228
5733,"public void flagInterrupt(int interrupt,IOUnit source,boolean triggerIR){
  if (triggerIR) {
    interruptSource[interrupt]=source;
    if (debugInterrupts) {
      System.out.println(""String_Node_Str"" + source.getName());
    }
    if (interrupt > interruptMax) {
      interruptMax=interrupt;
      if (interruptMax == 15) {
        interruptsEnabled=true;
      }
    }
  }
 else {
    if (interruptSource[interrupt] == source) {
      if (debugInterrupts) {
        System.out.println(""String_Node_Str"" + source.getName());
      }
      interruptSource[interrupt]=null;
    }
  }
}","public void flagInterrupt(int interrupt,IOUnit source,boolean triggerIR){
  if (triggerIR) {
    interruptSource[interrupt]=source;
    if (debugInterrupts) {
      if (source != null) {
        System.out.println(""String_Node_Str"" + source.getName());
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
    if (interrupt > interruptMax) {
      interruptMax=interrupt;
      if (interruptMax == 15) {
        interruptsEnabled=true;
      }
    }
  }
 else {
    if (interruptSource[interrupt] == source) {
      if (debugInterrupts) {
        System.out.println(""String_Node_Str"" + source.getName());
      }
      interruptSource[interrupt]=null;
    }
  }
}",0.9206598586017282
5734,"public int read(int address,boolean word){
  int val=0;
  if (address < 0x1ff && memIn[address] != null) {
    val=memIn[address].read(address,word,cycles);
  }
 else {
    address&=0xffff;
    val=memory[address] & 0xff;
    if (word) {
      val|=(memory[(address + 1) & 0xffff] << 8);
    }
  }
  return val;
}","public int read(int address,boolean word){
  int val=0;
  if (address < 0x1ff && memIn[address] != null) {
    val=memIn[address].read(address,word,cycles);
  }
 else {
    address&=0xffff;
    val=memory[address] & 0xff;
    if (word) {
      val|=(memory[(address + 1) & 0xffff] << 8);
    }
  }
  if (breakPoints[address] != null) {
    breakPoints[address].cpuAction(CPUMonitor.MEMORY_READ,address,val);
  }
  return val;
}",0.8162162162162162
5735,"public boolean emulateOP(){
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (cycles >= nextEventCycles) {
    executeEvents();
  }
  if (cycles >= nextIOTickCycles) {
    handleIO();
  }
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff) {
    cycles=nextIOTickCycles;
    return false;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return false;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad != AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
cycles+=5;
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
cycles+=3;
}
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
write=false;
updateStatus=false;
break;
case CALL:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles++;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as != AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=3;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
break;
}
}
if (dstRegMode) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=dst - src;
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
dst=src ^ dst;
write=true;
break;
case AND:
dst=src & dst;
write=true;
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
}
}
dst&=0xffff;
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
cpuCycles+=cycles - startCycles;
return true;
}","public boolean emulateOP(){
  int pc=readRegister(PC);
  long startCycles=cycles;
  if (cycles >= nextEventCycles) {
    executeEvents();
  }
  if (cycles >= nextIOTickCycles) {
    handleIO();
  }
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (cpuOff) {
    cycles=nextIOTickCycles;
    return false;
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return false;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad != AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
if (dstRegister == PC) {
dstAddress=readRegister(PC);
pc+=2;
writeRegister(PC,pc);
cycles+=5;
}
 else {
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
cycles+=3;
}
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
write=false;
updateStatus=false;
break;
case CALL:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles+=2;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as != AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
cycles+=dstRegMode ? 1 : 4;
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=3;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
break;
}
}
if (dstRegMode) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=dst - src;
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
dst=src ^ dst;
write=true;
break;
case AND:
dst=src & dst;
write=true;
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
}
}
dst&=0xffff;
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
cpuCycles+=cycles - startCycles;
return true;
}",0.9958876420157524
5736,"public void step(){
  if (!cpu.isRunning()) {
    cpu.step();
  }
}","public void step(int nr){
  if (!cpu.isRunning()) {
    cpu.stepInstructions(nr);
  }
}",0.8701298701298701
5737,"public void dataSent(int[] data){
  if (connections.size() > 0) {
    for (int i=0; i < data.length; i++) {
      buf[i]=(byte)data[i];
    }
    ConnectionThread[] cthr=connections.toArray(new ConnectionThread[connections.size()]);
    for (int i=0; i < cthr.length; i++) {
      if (cthr[i].isClosed()) {
        connections.remove(cthr);
      }
 else {
        try {
          cthr[i].output.write((byte)data.length);
          cthr[i].output.write(buf);
          if (DEBUG)           System.out.println(""String_Node_Str"" + data.length + ""String_Node_Str"");
        }
 catch (        IOException e) {
          e.printStackTrace();
          cthr[i].close();
        }
      }
    }
  }
}","public void dataSent(int[] data){
  if (connections.size() > 0) {
    for (int i=0; i < data.length; i++) {
      buf[i]=(byte)data[i];
    }
    ConnectionThread[] cthr=connections.toArray(new ConnectionThread[connections.size()]);
    for (int i=0; i < cthr.length; i++) {
      if (cthr[i].isClosed()) {
        connections.remove(cthr);
      }
 else {
        try {
          cthr[i].output.write((byte)data.length);
          cthr[i].output.write(buf,0,data.length);
          if (DEBUG) {
            System.out.println(""String_Node_Str"" + data.length + ""String_Node_Str"");
            printPacket(buf,data.length);
          }
        }
 catch (        IOException e) {
          e.printStackTrace();
          cthr[i].close();
        }
      }
    }
  }
}",0.9506172839506172
5738,"@Override public void run(){
  if (DEBUG)   System.out.println(""String_Node_Str"");
  while (socket != null) {
    int len;
    try {
      len=input.read();
      if (len > 0) {
        input.readFully(buffer,0,len);
        if (DEBUG)         System.out.println(""String_Node_Str"" + len + ""String_Node_Str"");
        dataReceived(buffer,len);
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
      socket=null;
    }
  }
}","@Override public void run(){
  if (DEBUG)   System.out.println(""String_Node_Str"");
  while (socket != null) {
    int len;
    try {
      len=input.read();
      if (len > 0) {
        input.readFully(buffer,0,len);
        if (DEBUG) {
          System.out.println(""String_Node_Str"" + len + ""String_Node_Str"");
          printPacket(buffer,len);
        }
        dataReceived(buffer,len);
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
      socket=null;
    }
  }
}",0.9475935828877006
5739,"private boolean removePid(int pid){
  for (int i=0; i < currentAsyncCommands.size(); i++) {
    CommandContext[] contexts=currentAsyncCommands.get(i);
    CommandContext cmd=contexts[0];
    if (pid == cmd.getPID()) {
      for (int j=0; j < contexts.length; j++) {
        Command command=contexts[i].getCommand();
        if (command instanceof AsyncCommand && !contexts[i].hasExited()) {
          AsyncCommand ac=(AsyncCommand)command;
          ac.stopCommand(contexts[i]);
        }
      }
      currentAsyncCommands.remove(contexts);
      return true;
    }
  }
  return false;
}","private boolean removePid(int pid){
  CommandContext[] contexts=null;
synchronized (currentAsyncCommands) {
    for (int i=0, n=currentAsyncCommands.size(); i < n; i++) {
      CommandContext[] cntx=currentAsyncCommands.get(i);
      if (pid == cntx[0].getPID()) {
        contexts=cntx;
        currentAsyncCommands.remove(cntx);
        break;
      }
    }
  }
  if (contexts != null) {
    for (int i=0; i < contexts.length; i++) {
      Command command=contexts[i].getCommand();
      if (command instanceof AsyncCommand && !contexts[i].hasExited()) {
        AsyncCommand ac=(AsyncCommand)command;
        ac.stopCommand(contexts[i]);
      }
    }
    return true;
  }
  return false;
}",0.6307572209211554
5740,"public void run(){
  String lastLine=null;
  while (!exit) {
    try {
      out.print(""String_Node_Str"");
      out.flush();
      String line=readLine(inReader);
      if (((char)27 + ""String_Node_Str"").equals(line)) {
        line=lastLine;
      }
      if (line != null && line.length() > 0) {
        lastLine=line;
        String[][] parts;
        try {
          parts=CommandParser.parseCommandLine(line);
        }
 catch (        Exception e) {
          err.println(""String_Node_Str"");
          e.printStackTrace(err);
          parts=null;
        }
        if (parts != null && parts.length > 0 && checkCommands(parts) == 0) {
          CommandContext[] commands=new CommandContext[parts.length];
          boolean error=false;
          int pid=-1;
          for (int i=0; i < parts.length; i++) {
            String[] args=parts[i];
            Command cmd=getCommand(args[0]);
            if (i == 0 && cmd instanceof AsyncCommand) {
              pid=++pidCounter;
            }
            commands[i]=new CommandContext(this,mapTable,line,args,pid,cmd);
            if (i > 0) {
              PrintStream po=new PrintStream(new LineOutputStream((LineListener)commands[i].getCommand()));
              commands[i - 1].setOutput(po,err);
            }
            if (i == parts.length - 1) {
              commands[i].setOutput(out,err);
            }
          }
          for (int i=parts.length - 1; i >= 0; i--) {
            try {
              int code=commands[i].getCommand().executeCommand(commands[i]);
              if (code != 0) {
                err.println(""String_Node_Str"" + commands[i].getCommandName() + ""String_Node_Str""+ code);
                error=true;
              }
            }
 catch (            Exception e) {
              err.println(""String_Node_Str"" + e.getMessage());
              e.printStackTrace(err);
              error=true;
            }
          }
          if (error) {
          }
 else           if (pid >= 0) {
            currentAsyncCommands.add(commands);
          }
        }
      }
    }
 catch (    IOException e) {
      e.printStackTrace(err);
      err.println(""String_Node_Str"");
      exit=true;
    }
  }
}","public void run(){
  String lastLine=null;
  while (!exit) {
    try {
      out.print(""String_Node_Str"");
      out.flush();
      String line=readLine(inReader);
      if (((char)27 + ""String_Node_Str"").equals(line)) {
        line=lastLine;
      }
      if (line != null && line.length() > 0) {
        lastLine=line;
        executeCommand(line);
      }
    }
 catch (    IOException e) {
      e.printStackTrace(err);
      err.println(""String_Node_Str"");
      exit=true;
    }
  }
}",0.3555721207603429
5741,"private void removePid(int pid){
  System.out.println(""String_Node_Str"" + pid);
  for (int i=0; i < currentAsyncCommands.size(); i++) {
    CommandContext[] contexts=currentAsyncCommands.get(i);
    CommandContext cmd=contexts[0];
    if (pid == cmd.getPID()) {
      for (int j=0; j < contexts.length; j++) {
        Command command=contexts[i].getCommand();
        if (command instanceof AsyncCommand && !contexts[i].hasExited()) {
          AsyncCommand ac=(AsyncCommand)command;
          ac.stopCommand(contexts[i]);
        }
      }
      currentAsyncCommands.remove(contexts);
      break;
    }
  }
}","private boolean removePid(int pid){
  for (int i=0; i < currentAsyncCommands.size(); i++) {
    CommandContext[] contexts=currentAsyncCommands.get(i);
    CommandContext cmd=contexts[0];
    if (pid == cmd.getPID()) {
      for (int j=0; j < contexts.length; j++) {
        Command command=contexts[i].getCommand();
        if (command instanceof AsyncCommand && !contexts[i].hasExited()) {
          AsyncCommand ac=(AsyncCommand)command;
          ac.stopCommand(contexts[i]);
        }
      }
      currentAsyncCommands.remove(contexts);
      return true;
    }
  }
  return false;
}",0.9165275459098498
5742,"public int executeCommand(CommandContext context){
  int pid=context.getArgumentAsInt(0);
  removePid(pid);
  return 0;
}","public int executeCommand(CommandContext context){
  int pid=context.getArgumentAsInt(0);
  if (removePid(pid)) {
    return 0;
  }
  context.err.println(""String_Node_Str"");
  return 1;
}",0.7792207792207793
5743,"private void registerCommands(){
  registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      if (context.getArgumentCount() == 0) {
        context.out.println(""String_Node_Str"");
        for (        Map.Entry<String,Command> entry : commands.entrySet()) {
          String name=entry.getKey();
          Command command=entry.getValue();
          String helpText=command.getCommandHelp(name);
          if (helpText != null) {
            String argHelp=command.getArgumentHelp(name);
            String prefix=argHelp != null ? (' ' + name + ' '+ argHelp) : (' ' + name);
            int n;
            if (helpText != null && (n=helpText.indexOf('\n')) > 0) {
              helpText=helpText.substring(0,n);
            }
            context.out.print(prefix);
            if (prefix.length() < 8) {
              context.out.print('\t');
            }
            if (prefix.length() < 16) {
              context.out.print('\t');
            }
            context.out.println(""String_Node_Str"" + helpText);
          }
        }
        return 0;
      }
      String cmd=context.getArgument(0);
      Command command=commands.get(cmd);
      if (command != null) {
        String helpText=command.getCommandHelp(cmd);
        String argHelp=command.getArgumentHelp(cmd);
        context.out.print(cmd);
        if (argHelp != null) {
          context.out.print(' ' + argHelp);
        }
        context.out.println();
        if (helpText != null && helpText.length() > 0) {
          context.out.println(""String_Node_Str"" + helpText);
        }
        return 0;
      }
      context.err.println(""String_Node_Str"" + cmd + '\'');
      return 1;
    }
  }
);
  registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      workaround=true;
      return 0;
    }
  }
);
  registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      for (int i=0; i < currentAsyncCommands.size(); i++) {
        CommandContext cmd=currentAsyncCommands.get(i)[0];
        context.out.println(""String_Node_Str"" + cmd);
      }
      return 0;
    }
  }
);
  registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      int pid=context.getArgumentAsInt(0);
      removePid(pid);
      return 0;
    }
  }
);
}","private void registerCommands(){
  registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      if (context.getArgumentCount() == 0) {
        context.out.println(""String_Node_Str"");
        for (        Map.Entry<String,Command> entry : commands.entrySet()) {
          String name=entry.getKey();
          Command command=entry.getValue();
          String helpText=command.getCommandHelp(name);
          if (helpText != null) {
            String argHelp=command.getArgumentHelp(name);
            String prefix=argHelp != null ? (' ' + name + ' '+ argHelp) : (' ' + name);
            int n;
            if ((n=helpText.indexOf('\n')) > 0) {
              helpText=helpText.substring(0,n);
            }
            context.out.print(prefix);
            if (prefix.length() < 8) {
              context.out.print('\t');
            }
            if (prefix.length() < 16) {
              context.out.print('\t');
            }
            context.out.println(""String_Node_Str"" + helpText);
          }
        }
        return 0;
      }
      String cmd=context.getArgument(0);
      Command command=commands.get(cmd);
      if (command != null) {
        String helpText=command.getCommandHelp(cmd);
        String argHelp=command.getArgumentHelp(cmd);
        context.out.print(cmd);
        if (argHelp != null && argHelp.length() > 0) {
          context.out.print(' ' + argHelp);
        }
        context.out.println();
        if (helpText != null && helpText.length() > 0) {
          context.out.println(""String_Node_Str"" + helpText);
        }
        return 0;
      }
      context.err.println(""String_Node_Str"" + cmd + '\'');
      return 1;
    }
  }
);
  registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      workaround=true;
      return 0;
    }
  }
);
  registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      for (int i=0; i < currentAsyncCommands.size(); i++) {
        CommandContext cmd=currentAsyncCommands.get(i)[0];
        context.out.println(""String_Node_Str"" + cmd);
      }
      return 0;
    }
  }
);
  registerCommand(""String_Node_Str"",new BasicCommand(""String_Node_Str"",""String_Node_Str""){
    public int executeCommand(    CommandContext context){
      int pid=context.getArgumentAsInt(0);
      if (removePid(pid)) {
        return 0;
      }
      context.err.println(""String_Node_Str"");
      return 1;
    }
  }
);
}",0.7141216991963261
5744,"public void setupNode(){
  setupNodePorts();
  if (!config.getPropertyAsBoolean(""String_Node_Str"",false)) {
    gui=new ESBGui(this);
    DataChart dataChart=new DataChart(""String_Node_Str"",""String_Node_Str"");
    DataSourceSampler dss=dataChart.setupChipFrame(cpu);
    dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",TR1001.MODE_RX_ON));
    dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",TR1001.MODE_TXRX_ON));
    dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",MSP430.MODE_ACTIVE));
  }
  stats.addMonitor(this);
  stats.addMonitor(radio);
  stats.addMonitor(cpu);
}","public void setupNode(){
  setupNodePorts();
  stats.addMonitor(this);
  stats.addMonitor(radio);
  stats.addMonitor(cpu);
  if (!config.getPropertyAsBoolean(""String_Node_Str"",false)) {
    gui=new ESBGui(this);
    DataChart dataChart=new DataChart(""String_Node_Str"",""String_Node_Str"");
    DataSourceSampler dss=dataChart.setupChipFrame(cpu);
    dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",TR1001.MODE_RX_ON));
    dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",TR1001.MODE_TXRX_ON));
    dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",MSP430.MODE_ACTIVE));
  }
}",0.8852941176470588
5745,"public void interruptServiced(int vector){
  if (vector == ccr0Vector) {
    core.flagInterrupt(ccr0Vector,this,false);
  }
  if (MSP430Core.debugInterrupts) {
    System.out.println(""String_Node_Str"");
  }
}","public void interruptServiced(int vector){
  if (vector == ccr0Vector) {
    core.flagInterrupt(ccr0Vector,this,false);
    tcctl[0]&=~CC_IFG;
  }
  if (MSP430Core.debugInterrupts) {
    System.out.println(""String_Node_Str"");
  }
}",0.9476082004555808
5746,"public void write(int address,int data,boolean word,long cycles){
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ data+ ""String_Node_Str""+ word);
  }
  if (MSP430Constants.DEBUGGING_LEVEL > 0) {
    System.out.println(""String_Node_Str"" + Integer.toString(address,16) + ""String_Node_Str""+ data);
  }
switch (address) {
case MPY:
    mpy=data;
  if (DEBUG)   System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
break;
case MPYS:
mpys=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
break;
case MAC:
mac=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
break;
case MACS:
macs=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
break;
case RESLO:
resLo=data;
break;
case RESHI:
resHi=data;
break;
case OP2:
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
sumext=0;
op2=data;
int o1=mpy;
boolean signMode=false;
boolean sum=false;
if (lastWriteOP == MPYS) {
o1=mpys;
signMode=true;
}
 else if (lastWriteOP == MAC) {
o1=mac;
sum=true;
}
 else if (lastWriteOP == MACS) {
o1=macs;
signMode=true;
sum=true;
}
if (signMode) {
if (((o1 ^ op2) & 0x8000) > 0) {
sumext=0xffff;
}
}
long res=o1 * op2;
System.out.println(""String_Node_Str"" + o1 + ""String_Node_Str""+ op2+ ""String_Node_Str""+ res);
if (sum) {
currentSum=(resHi << 16) + resLo;
currentSum+=res;
res=currentSum;
}
resHi=(int)((res >> 16) & 0xffff);
resLo=(int)(res & 0xffff);
if (DEBUG) System.out.println(""String_Node_Str"" + res);
break;
}
}","public void write(int address,int data,boolean word,long cycles){
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ data+ ""String_Node_Str""+ word);
  }
  if (MSP430Constants.DEBUGGING_LEVEL > 0) {
    System.out.println(""String_Node_Str"" + Integer.toString(address,16) + ""String_Node_Str""+ data);
  }
switch (address) {
case MPY:
    op1=mpy=data;
  if (DEBUG)   System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
signed=false;
accumulating=false;
break;
case MPYS:
op1=mpys=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
signed=true;
accumulating=false;
break;
case MAC:
op1=mac=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
signed=false;
accumulating=true;
break;
case MACS:
op1=macs=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
signed=true;
accumulating=true;
break;
case RESLO:
resLo=data;
break;
case RESHI:
resHi=data;
break;
case OP2:
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
sumext=0;
op2=data;
if (signed) {
if (!word) {
if (op1 > 0x80) op1=op1 | 0xff00;
if (op2 > 0x80) op2=op2 | 0xff00;
}
op1=op1 > 0x8000 ? op1 - 0x10000 : op1;
op2=op2 > 0x8000 ? op2 - 0x10000 : op2;
}
long res=op1 * op2;
if (DEBUG) System.out.println(""String_Node_Str"" + op1 + ""String_Node_Str""+ op2+ ""String_Node_Str""+ res);
if (signed) {
sumext=res < 0 ? 0xffff : 0;
}
if (accumulating) {
res+=(resHi << 16) + resLo;
if (!signed && res > 0xffffffff) {
sumext=1;
}
}
resHi=(int)((res >> 16) & 0xffff);
resLo=(int)(res & 0xffff);
if (DEBUG) System.out.println(""String_Node_Str"" + res);
break;
}
}",0.6694436179708421
5747,"public void interruptServiced(int vector){
  if (MSP430Core.debugInterrupts) {
    System.out.println(""String_Node_Str"");
  }
}","public void interruptServiced(int vector){
  if (vector == ccr0Vector) {
    core.flagInterrupt(ccr0Vector,this,false);
  }
  if (MSP430Core.debugInterrupts) {
    System.out.println(""String_Node_Str"");
  }
}",0.7582089552238805
5748,"private void calculateNextEventTime(long cycles){
  long time=nextTimerTrigger;
  for (int i=0; i < expCaptureTime.length; i++) {
    long ct=expCaptureTime[i];
    if (ct > 0 && ct < time) {
      time=ct;
    }
  }
  if (time == 0) {
    time=cycles + 1000;
  }
  if (!timerTrigger.scheduled) {
    core.scheduleCycleEvent(timerTrigger,time);
  }
 else   if (timerTrigger.time > time) {
    core.scheduleCycleEvent(timerTrigger,time);
  }
}","private void calculateNextEventTime(long cycles){
  long time=nextTimerTrigger;
  int smallest=-1;
  for (int i=0; i < expCaptureTime.length; i++) {
    long ct=expCaptureTime[i];
    if (ct > 0 && ct < time) {
      time=ct;
      smallest=i;
    }
  }
  if (time == 0) {
    time=cycles + 1000;
  }
  if (!timerTrigger.scheduled) {
    core.scheduleCycleEvent(timerTrigger,time);
  }
 else   if (timerTrigger.time > time) {
    core.scheduleCycleEvent(timerTrigger,time);
  }
}",0.9598262757871878
5749,"public void triggerInterrupts(){
  boolean trigger=false;
  int tIndex=0;
  for (int i=0, n=noCompare; i < n; i++) {
    boolean newTrigger=(tcctl[i] & CC_TRIGGER_INT) == CC_TRIGGER_INT;
    trigger=trigger | newTrigger;
    if (i == 0) {
      core.flagInterrupt(type == TIMER_A ? TACCR0_VECTOR : TBCCR0_VECTOR,this,trigger);
      if (trigger) {
        lastTIV=memory[type == TIMER_A ? TAIV : TBIV]=0;
        return;
      }
    }
 else {
      if (newTrigger) {
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + (i * 2));
        }
        tIndex=i;
      }
    }
    if (trigger) {
      lastTIV=memory[type == TIMER_A ? TAIV : TBIV]=tIndex * 2;
    }
  }
  if (!trigger) {
    if (interruptEnable && interruptPending) {
      trigger=true;
      lastTIV=memory[type == TIMER_A ? TAIV : TBIV]=timerOverflow;
    }
  }
  core.flagInterrupt(type == TIMER_A ? TACCR1_VECTOR : TBCCR1_VECTOR,this,trigger);
}","public void triggerInterrupts(){
  boolean trigger=false;
  int tIndex=0;
  for (int i=0, n=noCompare; i < n; i++) {
    boolean newTrigger=(tcctl[i] & CC_TRIGGER_INT) == CC_TRIGGER_INT;
    trigger=trigger | newTrigger;
    if (i == 0) {
      core.flagInterrupt(ccr0Vector,this,trigger);
      if (trigger) {
        lastTIV=memory[type == TIMER_A ? TAIV : TBIV]=0;
        return;
      }
    }
 else {
      if (newTrigger) {
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + (i * 2));
        }
        tIndex=i;
      }
    }
    if (trigger) {
      lastTIV=memory[type == TIMER_A ? TAIV : TBIV]=tIndex * 2;
    }
  }
  if (!trigger) {
    if (interruptEnable && interruptPending) {
      trigger=true;
      lastTIV=memory[type == TIMER_A ? TAIV : TBIV]=timerOverflow;
    }
  }
  core.flagInterrupt(ccr1Vector,this,trigger);
}",0.5088495575221239
5750,"/** 
 * Creates a new <code>Timer</code> instance.
 */
public Timer(MSP430Core core,int[] srcMap,int[] memory,int offset){
  super(memory,offset);
  this.srcMap=srcMap;
  this.core=core;
  noCompare=(srcMap.length / 4) - 1;
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + noCompare);
  }
  if (srcMap == TIMER_Ax149) {
    type=TIMER_A;
    timerOverflow=0x0a;
  }
 else {
    type=TIMER_B;
    timerOverflow=0x0e;
  }
  reset();
}","/** 
 * Creates a new <code>Timer</code> instance.
 */
public Timer(MSP430Core core,int[] srcMap,int[] memory,int offset){
  super(memory,offset);
  this.srcMap=srcMap;
  this.core=core;
  noCompare=(srcMap.length / 4) - 1;
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + noCompare);
  }
  if (srcMap == TIMER_Ax149) {
    type=TIMER_A;
    timerOverflow=0x0a;
  }
 else {
    type=TIMER_B;
    timerOverflow=0x0e;
  }
  ccr0Vector=type == TIMER_A ? TACCR0_VECTOR : TBCCR0_VECTOR;
  ccr1Vector=type == TIMER_A ? TACCR1_VECTOR : TBCCR1_VECTOR;
  reset();
}",0.8767395626242545
5751,"public void addEvent(TimeEvent event){
  if (event.scheduled) {
    removeEvent(event);
  }
  eventCount++;
  if (first == null) {
    first=event;
  }
 else {
    TimeEvent pos=first;
    TimeEvent lastPos=first;
    while (pos != null && pos.time < event.time) {
      lastPos=pos;
      pos=pos.nextEvent;
    }
    if (pos == first) {
      event.nextEvent=pos;
      first=event;
    }
 else {
      event.nextEvent=pos;
      lastPos.nextEvent=event;
    }
  }
  if (first != null) {
    nextTime=first.time;
  }
 else {
    nextTime=0;
  }
  event.scheduled=true;
}","public void addEvent(TimeEvent event){
  if (event.scheduled) {
    removeEvent(event);
  }
  if (first == null) {
    first=event;
  }
 else {
    TimeEvent pos=first;
    TimeEvent lastPos=first;
    while (pos != null && pos.time < event.time) {
      lastPos=pos;
      pos=pos.nextEvent;
    }
    if (pos == first) {
      event.nextEvent=pos;
      first=event;
    }
 else {
      event.nextEvent=pos;
      lastPos.nextEvent=event;
    }
  }
  if (first != null) {
    nextTime=first.time;
  }
 else {
    nextTime=0;
  }
  event.scheduled=true;
  eventCount++;
}",0.1888111888111888
5752,"public TimeEvent popFirst(){
  TimeEvent tmp=first;
  if (tmp != null) {
    first=tmp.nextEvent;
    tmp.nextEvent=null;
  }
  if (first != null) {
    nextTime=first.time;
  }
 else {
    nextTime=0;
  }
  tmp.scheduled=false;
  return tmp;
}","public TimeEvent popFirst(){
  TimeEvent tmp=first;
  if (tmp != null) {
    first=tmp.nextEvent;
    tmp.nextEvent=null;
  }
  if (first != null) {
    nextTime=first.time;
  }
 else {
    nextTime=0;
  }
  tmp.scheduled=false;
  eventCount--;
  return tmp;
}",0.9166666666666666
5753,"public void write(int address,int data,boolean word,long cycles){
  memory[address]=data & 0xff;
  if (word) {
    memory[address + 1]=(data >> 8) & 0xff;
  }
  int iAddress=address - offset;
switch (iAddress) {
case TR:
    setCounter(data,cycles);
  break;
case TCTL:
if (DEBUG) {
  System.out.println(getName() + ""String_Node_Str"" + Utils.hex16(data));
}
inputDivider=1 << ((data >> 6) & 3);
clockSource=srcMap[(data >> 8) & 3];
cyclesMultiplicator=inputDivider;
if (clockSource == SRC_ACLK) {
cyclesMultiplicator=(cyclesMultiplicator * core.smclkFrq) / core.aclkFrq;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cyclesMultiplicator);
}
}
if ((data & TCLR) != 0) {
counter=0;
counterStart=cycles;
countDirection=1;
}
int newMode=(data >> 4) & 3;
if (mode == STOP && newMode != STOP) {
updateCounter(cycles);
nextTimerTrigger=(long)(cycles + cyclesMultiplicator * ((0xffff - counter) & 0xffff));
}
mode=newMode;
interruptEnable=(data & 0x02) > 0;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + name[type]+ ""String_Node_Str""+ inputDivider+ ""String_Node_Str""+ getSourceName(clockSource)+ ""String_Node_Str""+ interruptEnable+ ""String_Node_Str""+ interruptPending+ ""String_Node_Str""+ mode+ ((data & TCLR) != 0 ? ""String_Node_Str"" : ""String_Node_Str""));
}
tctl=data;
tctl&=~0x04;
if ((data & 0x01) == 0) {
interruptPending=false;
}
updateCaptures(-1,cycles);
break;
case TCCTL0:
case TCCTL1:
case TCCTL2:
case TCCTL3:
case TCCTL4:
case TCCTL5:
case TCCTL6:
int index=(iAddress - TCCTL0) / 2;
tcctl[index]=data;
outMode[index]=(data >> 5) & 7;
captureOn[index]=(data & 0x100) > 0;
sync[index]=(data & 0x800) > 0;
inputSel[index]=(data >> 12) & 3;
inputSrc[index]=srcMap[4 + index * 4 + inputSel[index]];
capMode[index]=(data >> 14) & 3;
triggerInterrupts();
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ capNames[capMode[index]]+ ""String_Node_Str""+ inputSel[index]+ ""String_Node_Str""+ getSourceName(inputSrc[index])+ ""String_Node_Str""+ captureOn[index]+ ""String_Node_Str""+ ((data & CC_IE) != 0));
}
updateCaptures(index,cycles);
break;
case TCCR0:
case TCCR1:
case TCCR2:
case TCCR3:
case TCCR4:
case TCCR5:
case TCCR6:
index=(iAddress - TCCR0) / 2;
tccr[index]=data;
updateCounter(cycles);
int diff=data - counter;
if (diff < 0) {
diff+=0x10000;
}
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ Utils.hex16(counter)+ ""String_Node_Str""+ Utils.hex16(diff));
}
expCaptureTime[index]=cycles + (long)(cyclesMultiplicator * diff) - counterPassed;
counterPassed=0;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cycles+ ""String_Node_Str""+ index+ ""String_Node_Str""+ expCaptureTime[index]+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ data+ ""String_Node_Str""+ (100 * (cyclesMultiplicator * diff * 1L) / 2500000) / 100.0 + ""String_Node_Str"" + ""String_Node_Str"" + expCaptureTime[index]);
}
calculateNextEventTime(cycles);
}
}","public void write(int address,int data,boolean word,long cycles){
  memory[address]=data & 0xff;
  if (word) {
    memory[address + 1]=(data >> 8) & 0xff;
  }
  int iAddress=address - offset;
switch (iAddress) {
case TR:
    setCounter(data,cycles);
  break;
case TCTL:
if (DEBUG) {
  System.out.println(getName() + ""String_Node_Str"" + Utils.hex16(data));
}
inputDivider=1 << ((data >> 6) & 3);
clockSource=srcMap[(data >> 8) & 3];
cyclesMultiplicator=inputDivider;
if (clockSource == SRC_ACLK) {
cyclesMultiplicator=(cyclesMultiplicator * core.smclkFrq) / core.aclkFrq;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cyclesMultiplicator);
}
}
if ((data & TCLR) != 0) {
counter=0;
counterStart=cycles;
}
int newMode=(data >> 4) & 3;
if (mode == STOP && newMode != STOP) {
updateCounter(cycles);
nextTimerTrigger=(long)(cycles + cyclesMultiplicator * ((0xffff - counter) & 0xffff));
}
mode=newMode;
interruptEnable=(data & 0x02) > 0;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + name[type]+ ""String_Node_Str""+ inputDivider+ ""String_Node_Str""+ getSourceName(clockSource)+ ""String_Node_Str""+ interruptEnable+ ""String_Node_Str""+ interruptPending+ ""String_Node_Str""+ mode+ ((data & TCLR) != 0 ? ""String_Node_Str"" : ""String_Node_Str""));
}
tctl=data;
tctl&=~0x04;
if ((data & 0x01) == 0) {
interruptPending=false;
}
updateCaptures(-1,cycles);
break;
case TCCTL0:
case TCCTL1:
case TCCTL2:
case TCCTL3:
case TCCTL4:
case TCCTL5:
case TCCTL6:
int index=(iAddress - TCCTL0) / 2;
tcctl[index]=data;
outMode[index]=(data >> 5) & 7;
captureOn[index]=(data & 0x100) > 0;
sync[index]=(data & 0x800) > 0;
inputSel[index]=(data >> 12) & 3;
inputSrc[index]=srcMap[4 + index * 4 + inputSel[index]];
capMode[index]=(data >> 14) & 3;
triggerInterrupts();
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ capNames[capMode[index]]+ ""String_Node_Str""+ inputSel[index]+ ""String_Node_Str""+ getSourceName(inputSrc[index])+ ""String_Node_Str""+ captureOn[index]+ ""String_Node_Str""+ ((data & CC_IE) != 0));
}
updateCaptures(index,cycles);
break;
case TCCR0:
case TCCR1:
case TCCR2:
case TCCR3:
case TCCR4:
case TCCR5:
case TCCR6:
index=(iAddress - TCCR0) / 2;
tccr[index]=data;
updateCounter(cycles);
int diff=data - counter;
if (diff < 0) {
diff+=0x10000;
}
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ Utils.hex16(counter)+ ""String_Node_Str""+ Utils.hex16(diff));
}
expCaptureTime[index]=cycles + (long)(cyclesMultiplicator * diff) - counterPassed;
counterPassed=0;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cycles+ ""String_Node_Str""+ index+ ""String_Node_Str""+ expCaptureTime[index]+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ data+ ""String_Node_Str""+ (100 * (cyclesMultiplicator * diff * 1L) / 2500000) / 100.0 + ""String_Node_Str"" + ""String_Node_Str"" + expCaptureTime[index]);
}
calculateNextEventTime(cycles);
}
}",0.9970178926441352
5754,"public void setupNode(){
  String fileName=firmwareFile;
  int ix=fileName.lastIndexOf('.');
  if (ix > 0) {
    fileName=fileName.substring(0,ix);
  }
  fileName=fileName + ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + fileName);
  this.flashFile=flashFile;
  setupNodePorts();
  stats.addMonitor(this);
  stats.addMonitor(radio);
  stats.addMonitor(cpu);
  cpu.scheduleCycleEvent(new TimeEvent(0){
    public void execute(    long t){
      System.out.println(""String_Node_Str"" + t + ""String_Node_Str""+ SkyNode.this.cpu.getTimeMillis());
      SkyNode.this.cpu.scheduleCycleEvent(this,time + 1000000);
    }
  }
,1000000);
  radio.setPacketListener(new PacketListener(){
    public void transmissionEnded(    int[] receivedData){
      System.out.println(getName() + ""String_Node_Str"" + SkyNode.this.cpu.getTimeMillis());
    }
    public void transmissionStarted(){
      System.out.println(getName() + ""String_Node_Str"" + SkyNode.this.cpu.getTimeMillis());
    }
  }
);
  gui=new SkyGui(this);
  DataChart dataChart=new DataChart(""String_Node_Str"",""String_Node_Str"");
  DataSourceSampler dss=dataChart.setupChipFrame(cpu);
  dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",0,OperatingModeStatistics.OP_INVERT));
  dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",CC2420.MODE_RX_ON));
  dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",CC2420.MODE_TXRX_ON));
  dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",MSP430.MODE_ACTIVE));
}","public void setupNode(){
  String fileName=firmwareFile;
  int ix=fileName.lastIndexOf('.');
  if (ix > 0) {
    fileName=fileName.substring(0,ix);
  }
  fileName=fileName + ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + fileName);
  this.flashFile=flashFile;
  setupNodePorts();
  stats.addMonitor(this);
  stats.addMonitor(radio);
  stats.addMonitor(cpu);
  radio.setPacketListener(new PacketListener(){
    public void transmissionEnded(    int[] receivedData){
      System.out.println(getName() + ""String_Node_Str"" + SkyNode.this.cpu.getTimeMillis());
    }
    public void transmissionStarted(){
      System.out.println(getName() + ""String_Node_Str"" + SkyNode.this.cpu.getTimeMillis());
    }
  }
);
  gui=new SkyGui(this);
  DataChart dataChart=new DataChart(""String_Node_Str"",""String_Node_Str"");
  DataSourceSampler dss=dataChart.setupChipFrame(cpu);
  dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",0,OperatingModeStatistics.OP_INVERT));
  dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",CC2420.MODE_RX_ON));
  dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",CC2420.MODE_TXRX_ON));
  dataChart.addDataSource(dss,""String_Node_Str"",stats.getDataSource(""String_Node_Str"",MSP430.MODE_ACTIVE));
}",0.9080301990391216
5755,"public void setIncomingPacket(int[] packet){
  int adr=RAM_RXFIFO;
  memory[adr++]=packet.length + 2;
  for (int i=0, n=packet.length; i < n; i++) {
    memory[adr++]=packet[i] & 0xff;
  }
  memory[adr++]=(202) & 0xff;
  memory[adr++]=(37) | 0x80;
  rxPacket=true;
  rxCursor=0;
  rxLen=adr;
  updateFifopPin();
}","public void setIncomingPacket(int[] packet){
  int adr=RAM_RXFIFO;
  memory[adr++]=packet.length + 2;
  for (  int element : packet) {
    memory[adr++]=element & 0xff;
  }
  memory[adr++]=(202) & 0xff;
  memory[adr++]=(37) | 0x80;
  rxPacket=true;
  rxCursor=0;
  rxLen=adr;
  updateFifopPin();
}",0.8786885245901639
5756,"private void flushRX(){
  if (DEBUG)   System.out.println(""String_Node_Str"" + rxPacket + ""String_Node_Str""+ rxLen);
  rxPacket=false;
  rxCursor=0;
  rxLen=0;
  updateFifopPin();
}","private void flushRX(){
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + rxPacket + ""String_Node_Str""+ rxLen);
  }
  rxPacket=false;
  rxCursor=0;
  rxLen=0;
  updateFifopPin();
}",0.9782608695652174
5757,"public void dataReceived(USART source,int data){
  if (on && chipSelect) {
    if (DEBUG)     System.out.println(""String_Node_Str"" + Utils.hex8(data) + '\''+ (char)data+ '\''+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ state);
switch (state) {
case WAITING:
      state=WRITE_REGISTER;
    if ((data & FLAG_READ) != 0) {
      state=READ_REGISTER;
    }
  if ((data & FLAG_RAM) != 0) {
    state=RAM_ACCESS;
    address=data & 0x7f;
  }
 else {
    address=data & 0x3f;
    if (address == REG_RXFIFO) {
      state=READ_RXFIFO;
    }
 else     if (address == REG_TXFIFO) {
      state=WRITE_TXFIFO;
    }
  }
if (data < 0x0f) {
  strobe(data);
}
pos=0;
source.byteReceived(status);
break;
case WRITE_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
registers[address]=registers[address] & 0xff | (data << 8);
}
 else {
source.byteReceived(registers[address] & 0xff);
registers[address]=registers[address] & 0xff00 | data;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
break;
case READ_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
}
 else {
source.byteReceived(registers[address] & 0xff);
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
break;
case READ_RXFIFO:
source.byteReceived(memory[RAM_RXFIFO + rxCursor++]);
if (rxCursor >= 128) rxCursor=0;
if (rxPacket) {
rxPacket=false;
updateFifopPin();
}
break;
case WRITE_TXFIFO:
memory[RAM_TXFIFO + txCursor++]=data & 0xff;
break;
case RAM_ACCESS:
if (pos == 0) {
address=address | (data << 1) & 0x180;
ramRead=(data & 0x20) != 0;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ ramRead);
pos++;
}
 else {
if (!ramRead) {
memory[address++]=data;
if (DEBUG && address == RAM_PANID + 2) {
System.out.println(""String_Node_Str"" + Utils.hex8(memory[RAM_PANID]) + Utils.hex8(memory[RAM_PANID + 1]));
}
}
}
break;
}
}
}","public void dataReceived(USART source,int data){
  if (on && chipSelect) {
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + Utils.hex8(data) + '\''+ (char)data+ '\''+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ state);
    }
switch (state) {
case WAITING:
      state=WRITE_REGISTER;
    if ((data & FLAG_READ) != 0) {
      state=READ_REGISTER;
    }
  if ((data & FLAG_RAM) != 0) {
    state=RAM_ACCESS;
    address=data & 0x7f;
  }
 else {
    address=data & 0x3f;
    if (address == REG_RXFIFO) {
      state=READ_RXFIFO;
    }
 else     if (address == REG_TXFIFO) {
      state=WRITE_TXFIFO;
    }
  }
if (data < 0x0f) {
  strobe(data);
}
pos=0;
source.byteReceived(status);
break;
case WRITE_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
registers[address]=registers[address] & 0xff | (data << 8);
}
 else {
source.byteReceived(registers[address] & 0xff);
registers[address]=registers[address] & 0xff00 | data;
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
}
pos++;
break;
case READ_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
}
 else {
source.byteReceived(registers[address] & 0xff);
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
}
pos++;
break;
case READ_RXFIFO:
source.byteReceived(memory[RAM_RXFIFO + rxCursor++]);
if (rxCursor >= 128) {
rxCursor=0;
}
if (rxPacket) {
rxPacket=false;
updateFifopPin();
}
break;
case WRITE_TXFIFO:
memory[RAM_TXFIFO + txCursor++]=data & 0xff;
break;
case RAM_ACCESS:
if (pos == 0) {
address=address | (data << 1) & 0x180;
ramRead=(data & 0x20) != 0;
if (DEBUG) {
System.out.println(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ ramRead);
}
pos++;
}
 else {
if (!ramRead) {
memory[address++]=data;
if (DEBUG && address == RAM_PANID + 2) {
System.out.println(""String_Node_Str"" + Utils.hex8(memory[RAM_PANID]) + Utils.hex8(memory[RAM_PANID + 1]));
}
}
}
break;
}
}
}",0.9900695134061568
5758,"public void execute(long t){
  if (DEBUG)   System.out.println(getName() + ""String_Node_Str"");
  if (packetListener != null) {
    int len=memory[RAM_TXFIFO];
    int[] data=new int[len];
    System.arraycopy(memory,RAM_TXFIFO + 1,data,0,len);
    packetListener.transmissionEnded(data);
  }
}","public void execute(long t){
  if (DEBUG) {
    System.out.println(getName() + ""String_Node_Str"");
  }
  if (packetListener != null) {
    int len=memory[RAM_TXFIFO];
    int[] data=new int[len];
    System.arraycopy(memory,RAM_TXFIFO + 1,data,0,len);
    packetListener.transmissionEnded(data);
  }
}",0.9865319865319864
5759,"private void strobe(int data){
  if (DEBUG)   System.out.println(""String_Node_Str"" + Utils.hex8(data));
switch (data) {
case REG_SRXON:
    if (DEBUG)     System.out.println(""String_Node_Str"");
  setMode(MODE_RX_ON);
break;
case REG_SRFOFF:
if (DEBUG) System.out.println(""String_Node_Str"");
setMode(MODE_TXRX_OFF);
break;
case REG_STXON:
if (DEBUG) System.out.println(""String_Node_Str"");
setMode(MODE_TXRX_ON);
transmitPacket();
break;
case REG_STXONCCA:
if (DEBUG) System.out.println(""String_Node_Str"");
setMode(MODE_TXRX_ON);
transmitPacket();
break;
case REG_SFLUSHRX:
flushRX();
break;
case REG_SFLUSHTX:
flushTX();
break;
}
}","private void strobe(int data){
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + Utils.hex8(data));
  }
switch (data) {
case REG_SRXON:
    setActiveFrequency(registers[REG_FSCTRL]);
  if (DEBUG) {
    System.out.println(""String_Node_Str"");
  }
setMode(MODE_RX_ON);
break;
case REG_SRFOFF:
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
setMode(MODE_TXRX_OFF);
break;
case REG_STXON:
setActiveFrequency(registers[REG_FSCTRL]);
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
setMode(MODE_TXRX_ON);
transmitPacket();
break;
case REG_STXONCCA:
setActiveFrequency(registers[REG_FSCTRL]);
if (DEBUG) {
System.out.println(""String_Node_Str"");
}
setMode(MODE_TXRX_ON);
transmitPacket();
break;
case REG_SFLUSHRX:
flushRX();
break;
case REG_SFLUSHTX:
flushTX();
break;
default :
if (DEBUG) {
System.out.println(""String_Node_Str"" + data);
}
}
}",0.847913862718708
5760,"public void setChipSelect(boolean select){
  chipSelect=select;
  if (!chipSelect)   state=WAITING;
  if (DEBUG)   System.out.println(""String_Node_Str"" + chipSelect);
}","public void setChipSelect(boolean select){
  chipSelect=select;
  if (!chipSelect) {
    state=WAITING;
  }
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + chipSelect);
  }
}",0.9545454545454546
5761,"private void transmitPacket(){
  int len=memory[RAM_TXFIFO];
  int kBps=250000 / 8;
  double time=1.0 * len / kBps;
  if (DEBUG)   System.out.println(getName() + ""String_Node_Str"" + len+ ""String_Node_Str""+ time+ ""String_Node_Str"");
  if (packetListener != null) {
    packetListener.transmissionStarted();
    cpu.scheduleTimeEventMillis(transmissionEvent,1000 * time);
  }
}","private void transmitPacket(){
  int len=memory[RAM_TXFIFO];
  int kBps=250000 / 8;
  double time=1.0 * len / kBps;
  if (DEBUG) {
    System.out.println(getName() + ""String_Node_Str"" + len+ ""String_Node_Str""+ time+ ""String_Node_Str"");
  }
  if (packetListener != null) {
    packetListener.transmissionStarted();
    cpu.scheduleTimeEventMillis(transmissionEvent,1000 * time);
  }
}",0.9894459102902374
5762,"public void run(){
  while (!exit) {
    try {
      out.print(""String_Node_Str"");
      String line=inReader.readLine();
      if (line != null && line.length() > 0) {
        String[] parts=line.split(""String_Node_Str"");
        Command cmd=commands.get(parts[0]);
        if (cmd == null) {
          out.println(""String_Node_Str"" + parts[0]);
        }
 else {
          CommandContext cc=new CommandContext(mapTable,parts,in,out,err);
          try {
            cmd.executeCommand(cc);
          }
 catch (          Exception e) {
            err.println(""String_Node_Str"" + e.getMessage());
            e.printStackTrace(err);
          }
        }
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
      err.println(""String_Node_Str"");
      exit=true;
    }
  }
}","public void run(){
  while (!exit) {
    try {
      out.print(""String_Node_Str"");
      out.flush();
      String line=readLine(inReader);
      if (line != null && line.length() > 0) {
        String[] parts=line.split(""String_Node_Str"");
        Command cmd=commands.get(parts[0]);
        if (cmd == null) {
          out.println(""String_Node_Str"" + parts[0]);
        }
 else {
          CommandContext cc=new CommandContext(mapTable,parts,in,out,err);
          try {
            cmd.executeCommand(cc);
          }
 catch (          Exception e) {
            err.println(""String_Node_Str"" + e.getMessage());
            e.printStackTrace(err);
          }
        }
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
      err.println(""String_Node_Str"");
      exit=true;
    }
  }
}",0.976279650436954
5763,"public void setupCommands(ComponentRegistry registry,CommandHandler ch){
  final MSP430 cpu=(MSP430)registry.getComponent(MSP430.class);
  if (cpu != null) {
    ch.registerCommand(""String_Node_Str"",new Command(){
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            context.out.println(""String_Node_Str"" + adr);
          }
        }
);
        context.out.println(""String_Node_Str"" + baddr);
        return 0;
      }
      public String getArgumentHelp(      CommandContext context){
        return ""String_Node_Str"";
      }
      public String getCommandHelp(      CommandContext context){
        return ""String_Node_Str"";
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new Command(){
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            context.out.println(""String_Node_Str"" + adr + ""String_Node_Str""+ data);
          }
        }
);
        context.out.println(""String_Node_Str"" + baddr);
        return 0;
      }
      public String getArgumentHelp(      CommandContext context){
        return ""String_Node_Str"";
      }
      public String getCommandHelp(      CommandContext context){
        return ""String_Node_Str"";
      }
    }
);
  }
}","public void setupCommands(ComponentRegistry registry,CommandHandler ch){
  final MSP430 cpu=(MSP430)registry.getComponent(MSP430.class);
  final ELF elf=(ELF)registry.getComponent(ELF.class);
  if (cpu != null) {
    ch.registerCommand(""String_Node_Str"",new Command(){
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            context.out.println(""String_Node_Str"" + adr);
          }
        }
);
        context.out.println(""String_Node_Str"" + baddr);
        return 0;
      }
      public String getArgumentHelp(      CommandContext context){
        return ""String_Node_Str"";
      }
      public String getCommandHelp(      CommandContext context){
        return ""String_Node_Str"";
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new Command(){
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        if (baddr == -1) {
          context.out.println(""String_Node_Str"" + context.getArgument(0));
          return -1;
        }
        cpu.setBreakPoint(baddr,new CPUMonitor(){
          public void cpuAction(          int type,          int adr,          int data){
            int pc=cpu.readRegister(0);
            String adrStr=getSymOrAddr(context,adr);
            String pcStr=getSymOrAddrELF(elf,pc);
            context.out.println(""String_Node_Str"" + pcStr + ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
          }
        }
);
        context.out.println(""String_Node_Str"" + baddr);
        return 0;
      }
      public String getArgumentHelp(      CommandContext context){
        return ""String_Node_Str"";
      }
      public String getCommandHelp(      CommandContext context){
        return ""String_Node_Str"";
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new Command(){
      public int executeCommand(      final CommandContext context){
        int baddr=context.getArgumentAsAddress(0);
        cpu.setBreakPoint(baddr,null);
        return 0;
      }
      public String getArgumentHelp(      CommandContext context){
        return ""String_Node_Str"";
      }
      public String getCommandHelp(      CommandContext context){
        return ""String_Node_Str"";
      }
    }
);
    ch.registerCommand(""String_Node_Str"",new Command(){
      public int executeCommand(      final CommandContext context){
        String regExp=context.getArgument(0);
        MapEntry[] entries=context.getMapTable().getEntries(regExp);
        for (int i=0; i < entries.length; i++) {
          MapEntry mapEntry=entries[i];
          context.out.println(""String_Node_Str"" + mapEntry.getName() + ""String_Node_Str""+ Utils.hex16(mapEntry.getAddress()));
        }
        return 0;
      }
      public String getArgumentHelp(      CommandContext context){
        return ""String_Node_Str"";
      }
      public String getCommandHelp(      CommandContext context){
        return ""String_Node_Str"";
      }
    }
);
  }
}",0.6739633761313407
5764,"public void cpuAction(int type,int adr,int data){
  context.out.println(""String_Node_Str"" + adr + ""String_Node_Str""+ data);
}","public void cpuAction(int type,int adr,int data){
  int pc=cpu.readRegister(0);
  String adrStr=getSymOrAddr(context,adr);
  String pcStr=getSymOrAddrELF(elf,pc);
  context.out.println(""String_Node_Str"" + pcStr + ""String_Node_Str""+ adrStr+ ""String_Node_Str""+ data);
}",0.6275510204081632
5765,"public int executeCommand(final CommandContext context){
  int baddr=context.getArgumentAsAddress(0);
  cpu.setBreakPoint(baddr,new CPUMonitor(){
    public void cpuAction(    int type,    int adr,    int data){
      context.out.println(""String_Node_Str"" + adr + ""String_Node_Str""+ data);
    }
  }
);
  context.out.println(""String_Node_Str"" + baddr);
  return 0;
}","public int executeCommand(final CommandContext context){
  String regExp=context.getArgument(0);
  MapEntry[] entries=context.getMapTable().getEntries(regExp);
  for (int i=0; i < entries.length; i++) {
    MapEntry mapEntry=entries[i];
    context.out.println(""String_Node_Str"" + mapEntry.getName() + ""String_Node_Str""+ Utils.hex16(mapEntry.getAddress()));
  }
  return 0;
}",0.3670715249662618
5766,"public MapTable getMap(){
  MapTable map=new MapTable();
  ELFSection name=sections[symTable.link];
  int len=symTable.size;
  int count=len / symTable.entSize;
  int addr=symTable.offset;
  String currentFile=""String_Node_Str"";
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + count);
  }
  int currentAddress=0;
  for (int i=0, n=count; i < n; i++) {
    pos=addr;
    int nI=readElf32();
    String sn=name.getName(nI);
    int sAddr=readElf32();
    int size=readElf32();
    int info=readElf8();
    int bind=info >> 4;
    int type=info & 0xf;
    if (type == 0 && ""String_Node_Str"".equals(sn)) {
      if (currentFile != null) {
        System.out.println(""String_Node_Str"" + currentFile + ""String_Node_Str""+ Utils.hex16(currentAddress)+ ""String_Node_Str""+ Utils.hex16(sAddr));
        files.add(new FileInfo(currentFile,currentAddress,sAddr));
        currentAddress=sAddr;
      }
    }
    if (type == ELFSection.SYMTYPE_FILE) {
      currentFile=sn;
    }
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + sn + ""String_Node_Str""+ Integer.toString(sAddr,16)+ ""String_Node_Str""+ bind+ ""String_Node_Str""+ type+ ""String_Node_Str""+ size);
    }
    if (sAddr > 0 && sAddr < 0x10000) {
      String symbolName=sn;
      if (""String_Node_Str"".equals(symbolName)) {
        map.setHeapStart(sAddr);
      }
 else       if (""String_Node_Str"".equals(symbolName)) {
        map.setStackStart(sAddr);
      }
      if (type == ELFSection.SYMTYPE_FUNCTION) {
        String file=lookupFile(sAddr);
        if (file == null)         file=currentFile;
        map.setEntry(new MapEntry(MapEntry.TYPE.function,sAddr,symbolName,file,bind == ELFSection.SYMBIND_LOCAL));
      }
 else       if (type == ELFSection.SYMTYPE_OBJECT) {
        String file=lookupFile(sAddr);
        if (file == null)         file=currentFile;
        map.setEntry(new MapEntry(MapEntry.TYPE.variable,sAddr,symbolName,file,bind == ELFSection.SYMBIND_LOCAL));
      }
 else {
        if (DEBUG) {
          System.out.println(""String_Node_Str"" + symbolName + ""String_Node_Str""+ Integer.toString(sAddr,16)+ ""String_Node_Str""+ currentFile+ ""String_Node_Str"");
        }
      }
    }
    addr+=symTable.entSize;
  }
  return map;
}","public MapTable getMap(){
  MapTable map=new MapTable();
  ELFSection name=sections[symTable.link];
  int len=symTable.size;
  int count=len / symTable.entSize;
  int addr=symTable.offset;
  String currentFile=""String_Node_Str"";
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + count);
  }
  int currentAddress=0;
  for (int i=0, n=count; i < n; i++) {
    pos=addr;
    int nI=readElf32();
    String sn=name.getName(nI);
    int sAddr=readElf32();
    int size=readElf32();
    int info=readElf8();
    int bind=info >> 4;
    int type=info & 0xf;
    if (type == ELFSection.SYMTYPE_NONE && sn != null) {
      if (""String_Node_Str"".equals(sn)) {
        if (currentFile != null) {
          System.out.println(""String_Node_Str"" + currentFile + ""String_Node_Str""+ Utils.hex16(currentAddress)+ ""String_Node_Str""+ Utils.hex16(sAddr));
          files.add(new FileInfo(currentFile,currentAddress,sAddr));
          currentAddress=sAddr;
        }
      }
 else       if (!sn.startsWith(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + sn + ""String_Node_Str""+ sAddr);
        map.setEntry(new MapEntry(MapEntry.TYPE.variable,sAddr,sn,currentFile,false));
      }
    }
    if (type == ELFSection.SYMTYPE_FILE) {
      currentFile=sn;
    }
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + sn + ""String_Node_Str""+ Integer.toString(sAddr,16)+ ""String_Node_Str""+ bind+ ""String_Node_Str""+ type+ ""String_Node_Str""+ size);
    }
    if (sAddr > 0 && sAddr < 0x10000) {
      String symbolName=sn;
      if (""String_Node_Str"".equals(symbolName)) {
        map.setHeapStart(sAddr);
      }
 else       if (""String_Node_Str"".equals(symbolName)) {
        map.setStackStart(sAddr);
      }
      if (type == ELFSection.SYMTYPE_FUNCTION) {
        String file=lookupFile(sAddr);
        if (file == null)         file=currentFile;
        map.setEntry(new MapEntry(MapEntry.TYPE.function,sAddr,symbolName,file,bind == ELFSection.SYMBIND_LOCAL));
      }
 else       if (type == ELFSection.SYMTYPE_OBJECT) {
        String file=lookupFile(sAddr);
        if (file == null)         file=currentFile;
        map.setEntry(new MapEntry(MapEntry.TYPE.variable,sAddr,symbolName,file,bind == ELFSection.SYMBIND_LOCAL));
      }
 else {
        if (DEBUG) {
          System.out.println(""String_Node_Str"" + symbolName + ""String_Node_Str""+ Integer.toString(sAddr,16)+ ""String_Node_Str""+ currentFile+ ""String_Node_Str"");
        }
      }
    }
    addr+=symTable.entSize;
  }
  return map;
}",0.9380680617205664
5767,"public ArrayList<MapEntry> getAllEntries(){
  ArrayList<MapEntry> allEntries=new ArrayList<MapEntry>();
  for (int address=0; address < entries.length; address++) {
    MapEntry entry=getEntry(address);
    if (entry != null) {
      allEntries.add(entry);
    }
  }
  return allEntries;
}","public MapEntry[] getAllEntries(){
  ArrayList<MapEntry> allEntries=new ArrayList<MapEntry>();
  for (int address=0; address < entries.length; address++) {
    MapEntry entry=getEntry(address);
    if (entry != null) {
      allEntries.add(entry);
    }
  }
  return allEntries.toArray(new MapEntry[allEntries.size()]);
}",0.8852459016393442
5768,"private void writeBack(int address,byte[] data){
  try {
    if (DEBUG)     System.out.println(""String_Node_Str"" + Integer.toHexString(address));
    file.seek(address & 0xfff00);
    file.write(data);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","private void writeBack(int address,byte[] data){
  try {
    byte[] tmp=new byte[data.length];
    if (DEBUG)     System.out.println(""String_Node_Str"" + Integer.toHexString(address));
    file.seek(address & 0xfff00);
    for (int i=0; i < data.length; i++) {
      tmp[i]=(byte)(~data[i] & 0xff);
    }
    file.write(tmp);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.7981510015408321
5769,"private void ensureLoaded(int address){
  if (loadedAddress < 0 || ((loadedAddress & 0xfff00) != (address & 0xfff00))) {
    try {
      if (DEBUG)       System.out.println(""String_Node_Str"" + (address & 0xfff00));
      file.seek(address & 0xfff00);
      file.readFully(readMemory);
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    loadedAddress=address & 0xfff00;
  }
}","private void ensureLoaded(int address){
  if (loadedAddress < 0 || ((loadedAddress & 0xfff00) != (address & 0xfff00))) {
    try {
      if (DEBUG)       System.out.println(""String_Node_Str"" + (address & 0xfff00));
      file.seek(address & 0xfff00);
      file.readFully(readMemory);
      for (int i=0; i < readMemory.length; i++) {
        readMemory[i]=(byte)(~readMemory[i] & 0xff);
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    loadedAddress=address & 0xfff00;
  }
}",0.876803551609323
5770,"public void write(int address,int data,boolean word,long cycles){
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ data+ ""String_Node_Str""+ word);
  }
  if (MSP430Constants.DEBUGGING_LEVEL > 0) {
    System.out.println(""String_Node_Str"" + Integer.toString(address,16) + ""String_Node_Str""+ data);
  }
switch (address) {
case MPY:
    mpy=data;
  if (DEBUG)   System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
break;
case MPYS:
mpys=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
break;
case MAC:
mac=data;
currentSum=0;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
break;
case MACS:
macs=data;
currentSum=0;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
break;
case OP2:
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
sumext=0;
op2=data;
int o1=mpy;
boolean signMode=false;
boolean sum=false;
if (lastWriteOP == MPYS) {
o1=MPYS;
signMode=true;
}
 else if (lastWriteOP == MAC) {
o1=mac;
sum=true;
}
 else if (lastWriteOP == MACS) {
o1=macs;
signMode=true;
sum=true;
}
if (signMode) {
if (((o1 ^ op2) & 0x8000) > 0) {
sumext=0xffff;
}
}
int res=o1 * op2;
if (sum) {
currentSum+=res;
res=currentSum;
}
resHi=(res >> 16) & 0xffff;
resLo=res & 0xffff;
if (DEBUG) System.out.println(""String_Node_Str"" + res);
break;
}
}","public void write(int address,int data,boolean word,long cycles){
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ data+ ""String_Node_Str""+ word);
  }
  if (MSP430Constants.DEBUGGING_LEVEL > 0) {
    System.out.println(""String_Node_Str"" + Integer.toString(address,16) + ""String_Node_Str""+ data);
  }
switch (address) {
case MPY:
    mpy=data;
  if (DEBUG)   System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
break;
case MPYS:
mpys=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
break;
case MAC:
mac=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
break;
case MACS:
macs=data;
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
lastWriteOP=address;
break;
case RESLO:
resLo=data;
break;
case RESHI:
resHi=data;
break;
case OP2:
if (DEBUG) System.out.println(getName() + ""String_Node_Str"" + data);
sumext=0;
op2=data;
int o1=mpy;
boolean signMode=false;
boolean sum=false;
if (lastWriteOP == MPYS) {
o1=mpys;
signMode=true;
}
 else if (lastWriteOP == MAC) {
o1=mac;
sum=true;
}
 else if (lastWriteOP == MACS) {
o1=macs;
signMode=true;
sum=true;
}
if (signMode) {
if (((o1 ^ op2) & 0x8000) > 0) {
sumext=0xffff;
}
}
long res=o1 * op2;
System.out.println(""String_Node_Str"" + o1 + ""String_Node_Str""+ op2+ ""String_Node_Str""+ res);
if (sum) {
currentSum=(resHi << 16) + resLo;
currentSum+=res;
res=currentSum;
}
resHi=(int)((res >> 16) & 0xffff);
resLo=(int)(res & 0xffff);
if (DEBUG) System.out.println(""String_Node_Str"" + res);
break;
}
}",0.92012987012987
5771,"public static void main(String[] args) throws Exception {
  ELF elf=readELF(args[0]);
  if (args.length < 2) {
    for (int i=0, n=elf.shnum; i < n; i++) {
      System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ elf.sections[i]);
      if (""String_Node_Str"".equals(elf.sections[i].getSectionName()) || ""String_Node_Str"".equals(elf.sections[i].getSectionName())) {
        int adr=elf.sections[i].offset;
        System.out.println(""String_Node_Str"");
        for (int j=0, m=2000; j < m; j++) {
          System.out.print((char)elf.elfData[adr++]);
          if (i % 20 == 19) {
            System.out.println(""String_Node_Str"");
          }
        }
      }
      System.out.println(""String_Node_Str"");
    }
  }
  elf.getMap();
  if (args.length > 1) {
    DebugInfo dbg=elf.getDebugInfo(Integer.parseInt(args[1]));
    if (dbg != null) {
      System.out.println(""String_Node_Str"" + dbg.getFile());
      System.out.println(""String_Node_Str"" + dbg.getFunction());
      System.out.println(""String_Node_Str"" + dbg.getLine());
    }
  }
}","public static void main(String[] args) throws Exception {
  ELF elf=readELF(args[0]);
  if (args.length < 2) {
    for (int i=0, n=elf.shnum; i < n; i++) {
      System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ elf.sections[i]);
      if (""String_Node_Str"".equals(elf.sections[i].getSectionName()) || ""String_Node_Str"".equals(elf.sections[i].getSectionName())) {
        int adr=elf.sections[i].offset;
        System.out.println(""String_Node_Str"");
        for (int j=0, m=2000; j < m; j++) {
          System.out.print((char)elf.elfData[adr++]);
          if (i % 20 == 19) {
            System.out.println();
          }
        }
      }
      System.out.println();
    }
  }
  elf.getMap();
  if (args.length > 1) {
    DebugInfo dbg=elf.getDebugInfo(Integer.parseInt(args[1]));
    if (dbg != null) {
      System.out.println(""String_Node_Str"" + dbg.getFile());
      System.out.println(""String_Node_Str"" + dbg.getFunction());
      System.out.println(""String_Node_Str"" + dbg.getLine());
    }
  }
}",0.9835748792270532
5772,"public MapTable getMap(){
  MapTable map=new MapTable();
  ELFSection name=sections[symTable.link];
  int len=symTable.size;
  int count=len / symTable.entSize;
  int addr=symTable.offset;
  String currentFile=""String_Node_Str"";
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + count);
  }
  for (int i=0, n=count; i < n; i++) {
    pos=addr;
    int nI=readElf32();
    String sn=name.getName(nI);
    int sAddr=readElf32();
    int size=readElf32();
    int info=readElf8();
    int bind=info >> 4;
    int type=info & 0xf;
    if (type == ELFSection.SYMTYPE_FILE) {
      currentFile=sn;
    }
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + sn + ""String_Node_Str""+ Integer.toString(sAddr,16)+ ""String_Node_Str""+ bind+ ""String_Node_Str""+ type+ ""String_Node_Str""+ size);
    }
    if (sAddr > 0 && sAddr < 0x10000) {
      String symbolName=sn;
      if (""String_Node_Str"".equals(symbolName)) {
        map.setHeapStart(sAddr);
      }
 else       if (""String_Node_Str"".equals(symbolName)) {
        map.setStackStart(sAddr);
      }
      if (type == ELFSection.SYMTYPE_FUNCTION) {
        map.setEntry(new MapEntry(MapEntry.TYPE.function,sAddr,symbolName,currentFile,bind == ELFSection.SYMBIND_LOCAL));
      }
 else       if (type == ELFSection.SYMTYPE_OBJECT) {
        map.setEntry(new MapEntry(MapEntry.TYPE.variable,sAddr,symbolName,currentFile,bind == ELFSection.SYMBIND_LOCAL));
      }
 else {
        if (DEBUG) {
          System.out.println(""String_Node_Str"" + symbolName + ""String_Node_Str""+ Integer.toString(sAddr,16)+ ""String_Node_Str""+ currentFile+ ""String_Node_Str"");
        }
      }
    }
    addr+=symTable.entSize;
  }
  return map;
}","public MapTable getMap(){
  MapTable map=new MapTable();
  ELFSection name=sections[symTable.link];
  int len=symTable.size;
  int count=len / symTable.entSize;
  int addr=symTable.offset;
  String currentFile=""String_Node_Str"";
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + count);
  }
  int currentAddress=0;
  for (int i=0, n=count; i < n; i++) {
    pos=addr;
    int nI=readElf32();
    String sn=name.getName(nI);
    int sAddr=readElf32();
    int size=readElf32();
    int info=readElf8();
    int bind=info >> 4;
    int type=info & 0xf;
    if (type == 0 && ""String_Node_Str"".equals(sn)) {
      if (currentFile != null) {
        System.out.println(""String_Node_Str"" + currentFile + ""String_Node_Str""+ Utils.hex16(currentAddress)+ ""String_Node_Str""+ Utils.hex16(sAddr));
        files.add(new FileInfo(currentFile,currentAddress,sAddr));
        currentAddress=sAddr;
      }
    }
    if (type == ELFSection.SYMTYPE_FILE) {
      currentFile=sn;
    }
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + sn + ""String_Node_Str""+ Integer.toString(sAddr,16)+ ""String_Node_Str""+ bind+ ""String_Node_Str""+ type+ ""String_Node_Str""+ size);
    }
    if (sAddr > 0 && sAddr < 0x10000) {
      String symbolName=sn;
      if (""String_Node_Str"".equals(symbolName)) {
        map.setHeapStart(sAddr);
      }
 else       if (""String_Node_Str"".equals(symbolName)) {
        map.setStackStart(sAddr);
      }
      if (type == ELFSection.SYMTYPE_FUNCTION) {
        String file=lookupFile(sAddr);
        if (file == null)         file=currentFile;
        map.setEntry(new MapEntry(MapEntry.TYPE.function,sAddr,symbolName,file,bind == ELFSection.SYMBIND_LOCAL));
      }
 else       if (type == ELFSection.SYMTYPE_OBJECT) {
        String file=lookupFile(sAddr);
        if (file == null)         file=currentFile;
        map.setEntry(new MapEntry(MapEntry.TYPE.variable,sAddr,symbolName,file,bind == ELFSection.SYMBIND_LOCAL));
      }
 else {
        if (DEBUG) {
          System.out.println(""String_Node_Str"" + symbolName + ""String_Node_Str""+ Integer.toString(sAddr,16)+ ""String_Node_Str""+ currentFile+ ""String_Node_Str"");
        }
      }
    }
    addr+=symTable.entSize;
  }
  return map;
}",0.8539210661199385
5773,"public void dataReceived(USART source,int data){
  if (chipSelect) {
    if (DEBUG)     System.out.println(""String_Node_Str"" + Utils.hex8(data) + '\''+ (char)data+ '\''+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ state);
switch (state) {
case WAITING:
      state=WRITE_REGISTER;
    if ((data & FLAG_READ) != 0) {
      state=READ_REGISTER;
    }
  if ((data & FLAG_RAM) != 0) {
    state=RAM_ACCESS;
    address=data & 0x7f;
  }
 else {
    address=data & 0x3f;
    if (address == REG_RXFIFO) {
      state=READ_RXFIFO;
    }
 else     if (address == REG_TXFIFO) {
      state=WRITE_TXFIFO;
    }
  }
if (data < 0x0f) {
  strobe(data);
}
pos=0;
source.byteReceived(status);
break;
case WRITE_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
registers[address]=registers[address] & 0xff | (data << 8);
}
 else {
source.byteReceived(registers[address] & 0xff);
registers[address]=registers[address] & 0xff00 | data;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
break;
case READ_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
}
 else {
source.byteReceived(registers[address] & 0xff);
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
break;
case READ_RXFIFO:
source.byteReceived(memory[RAM_RXFIFO + rxCursor++]);
if (rxCursor >= 128) rxCursor=0;
if (rxPacket) {
rxPacket=false;
updateFifopPin();
}
break;
case WRITE_TXFIFO:
memory[RAM_TXFIFO + txCursor++]=data & 0xff;
break;
case RAM_ACCESS:
if (pos == 0) {
address=address | (data << 1) & 0x180;
ramRead=(data & 0x20) != 0;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ ramRead);
pos++;
}
 else {
if (!ramRead) {
memory[address++]=data;
if (DEBUG && address == RAM_PANID + 2) {
System.out.println(""String_Node_Str"" + Utils.hex8(memory[RAM_PANID]) + Utils.hex8(memory[RAM_PANID + 1]));
}
}
}
break;
}
}
}","public void dataReceived(USART source,int data){
  if (on && chipSelect) {
    if (DEBUG)     System.out.println(""String_Node_Str"" + Utils.hex8(data) + '\''+ (char)data+ '\''+ ""String_Node_Str""+ chipSelect+ ""String_Node_Str""+ state);
switch (state) {
case WAITING:
      state=WRITE_REGISTER;
    if ((data & FLAG_READ) != 0) {
      state=READ_REGISTER;
    }
  if ((data & FLAG_RAM) != 0) {
    state=RAM_ACCESS;
    address=data & 0x7f;
  }
 else {
    address=data & 0x3f;
    if (address == REG_RXFIFO) {
      state=READ_RXFIFO;
    }
 else     if (address == REG_TXFIFO) {
      state=WRITE_TXFIFO;
    }
  }
if (data < 0x0f) {
  strobe(data);
}
pos=0;
source.byteReceived(status);
break;
case WRITE_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
registers[address]=registers[address] & 0xff | (data << 8);
}
 else {
source.byteReceived(registers[address] & 0xff);
registers[address]=registers[address] & 0xff00 | data;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
break;
case READ_REGISTER:
if (pos == 0) {
source.byteReceived(registers[address] >> 8);
}
 else {
source.byteReceived(registers[address] & 0xff);
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex8(address) + ""String_Node_Str""+ registers[address]);
}
break;
case READ_RXFIFO:
source.byteReceived(memory[RAM_RXFIFO + rxCursor++]);
if (rxCursor >= 128) rxCursor=0;
if (rxPacket) {
rxPacket=false;
updateFifopPin();
}
break;
case WRITE_TXFIFO:
memory[RAM_TXFIFO + txCursor++]=data & 0xff;
break;
case RAM_ACCESS:
if (pos == 0) {
address=address | (data << 1) & 0x180;
ramRead=(data & 0x20) != 0;
if (DEBUG) System.out.println(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ ramRead);
pos++;
}
 else {
if (!ramRead) {
memory[address++]=data;
if (DEBUG && address == RAM_PANID + 2) {
System.out.println(""String_Node_Str"" + Utils.hex8(memory[RAM_PANID]) + Utils.hex8(memory[RAM_PANID + 1]));
}
}
}
break;
}
}
}",0.9984932194876946
5774,"public void execute(long t){
  System.out.println(getName() + ""String_Node_Str"");
  if (packetListener != null) {
    int len=memory[RAM_TXFIFO];
    int[] data=new int[len];
    System.arraycopy(memory,RAM_TXFIFO + 1,data,0,len);
    packetListener.transmissionEnded(data);
  }
}","public void execute(long t){
  if (DEBUG)   System.out.println(getName() + ""String_Node_Str"");
  if (packetListener != null) {
    int len=memory[RAM_TXFIFO];
    int[] data=new int[len];
    System.arraycopy(memory,RAM_TXFIFO + 1,data,0,len);
    packetListener.transmissionEnded(data);
  }
}",0.9773123909249564
5775,"private void strobe(int data){
  if (DEBUG)   System.out.println(""String_Node_Str"" + Utils.hex8(data));
switch (data) {
case REG_SRXON:
    setMode(MODE_RX_ON);
  break;
case REG_SRFOFF:
setMode(MODE_TXRX_OFF);
break;
case REG_STXON:
setMode(MODE_TXRX_ON);
transmitPacket();
break;
case REG_STXONCCA:
setMode(MODE_TXRX_ON);
transmitPacket();
break;
case REG_SFLUSHRX:
flushRX();
break;
case REG_SFLUSHTX:
flushTX();
break;
}
}","private void strobe(int data){
  if (DEBUG)   System.out.println(""String_Node_Str"" + Utils.hex8(data));
switch (data) {
case REG_SRXON:
    if (DEBUG)     System.out.println(""String_Node_Str"");
  setMode(MODE_RX_ON);
break;
case REG_SRFOFF:
if (DEBUG) System.out.println(""String_Node_Str"");
setMode(MODE_TXRX_OFF);
break;
case REG_STXON:
if (DEBUG) System.out.println(""String_Node_Str"");
setMode(MODE_TXRX_ON);
transmitPacket();
break;
case REG_STXONCCA:
if (DEBUG) System.out.println(""String_Node_Str"");
setMode(MODE_TXRX_ON);
transmitPacket();
break;
case REG_SFLUSHRX:
flushRX();
break;
case REG_SFLUSHTX:
flushTX();
break;
}
}",0.7632575757575758
5776,"public void setChipSelect(boolean select){
  chipSelect=select;
  if (!chipSelect)   state=WAITING;
}","public void setChipSelect(boolean select){
  chipSelect=select;
  if (!chipSelect)   state=WAITING;
  if (DEBUG)   System.out.println(""String_Node_Str"" + chipSelect);
}",0.7509293680297398
5777,"private void transmitPacket(){
  int len=memory[RAM_TXFIFO];
  int kBps=250000 / 8;
  double time=1.0 * len / kBps;
  System.out.println(getName() + ""String_Node_Str"" + len+ ""String_Node_Str""+ time+ ""String_Node_Str"");
  if (packetListener != null) {
    packetListener.transmissionStarted();
    cpu.scheduleTimeEventMillis(transmissionEvent,1000 * time);
  }
}","private void transmitPacket(){
  int len=memory[RAM_TXFIFO];
  int kBps=250000 / 8;
  double time=1.0 * len / kBps;
  if (DEBUG)   System.out.println(getName() + ""String_Node_Str"" + len+ ""String_Node_Str""+ time+ ""String_Node_Str"");
  if (packetListener != null) {
    packetListener.transmissionStarted();
    cpu.scheduleTimeEventMillis(transmissionEvent,1000 * time);
  }
}",0.98236092265943
5778,"public static void main(String[] args) throws IOException {
  if (args.length == 0) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  ComponentRegistry registry=new ComponentRegistry();
  final MSP430 cpu=new MSP430(0);
  CommandHandler ch=new CommandHandler();
  registry.registerComponent(""String_Node_Str"",cpu);
  registry.registerComponent(""String_Node_Str"",ch);
  registry.registerComponent(""String_Node_Str"",new DebugCommands());
  cpu.setMonitorExec(true);
  ELF elf=null;
  int[] memory=cpu.getMemory();
  if (args[0].endsWith(""String_Node_Str"")) {
    IHexReader reader=new IHexReader();
    reader.readFile(memory,args[0]);
  }
 else {
    elf=ELF.readELF(args[0]);
    elf.loadPrograms(memory);
    MapTable map=elf.getMap();
    cpu.getDisAsm().setMap(map);
    cpu.setMap(map);
    registry.registerComponent(""String_Node_Str"",map);
  }
  String fileName=args[0];
  int ix=fileName.lastIndexOf('.');
  if (ix > 0) {
    fileName=fileName.substring(0,ix);
  }
  fileName=fileName + ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + fileName);
  cpu.reset();
  SkyNode node=new SkyNode(cpu,fileName);
  node.gui=new SkyGui(node);
  ControlUI control=new ControlUI(cpu,elf);
  HighlightSourceViewer sourceViewer=new HighlightSourceViewer();
  sourceViewer.addSearchPath(new File(""String_Node_Str""));
  control.setSourceViewer(sourceViewer);
  if (args.length > 1) {
    MapTable map=new MapTable(args[1]);
    cpu.getDisAsm().setMap(map);
    registry.registerComponent(""String_Node_Str"",map);
  }
  DataChart dataChart=new DataChart(""String_Node_Str"",""String_Node_Str"");
  dataChart.setupChipFrame(node.stats,cpu);
  registry.start();
  cpu.cpuloop();
}","public static void main(String[] args) throws IOException {
  if (args.length == 0) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  ComponentRegistry registry=new ComponentRegistry();
  final MSP430 cpu=new MSP430(0);
  CommandHandler ch=new CommandHandler();
  registry.registerComponent(""String_Node_Str"",cpu);
  registry.registerComponent(""String_Node_Str"",ch);
  registry.registerComponent(""String_Node_Str"",new DebugCommands());
  cpu.setMonitorExec(true);
  ELF elf=null;
  int[] memory=cpu.getMemory();
  if (args[0].endsWith(""String_Node_Str"")) {
    IHexReader reader=new IHexReader();
    reader.readFile(memory,args[0]);
  }
 else {
    elf=ELF.readELF(args[0]);
    elf.loadPrograms(memory);
    MapTable map=elf.getMap();
    cpu.getDisAsm().setMap(map);
    cpu.setMap(map);
    registry.registerComponent(""String_Node_Str"",map);
  }
  String fileName=args[0];
  int ix=fileName.lastIndexOf('.');
  if (ix > 0) {
    fileName=fileName.substring(0,ix);
  }
  fileName=fileName + ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + fileName);
  cpu.reset();
  SkyNode node=new SkyNode(cpu,fileName);
  node.elf=elf;
  node.gui=new SkyGui(node);
  ControlUI control=new ControlUI(cpu,elf);
  HighlightSourceViewer sourceViewer=new HighlightSourceViewer();
  sourceViewer.addSearchPath(new File(""String_Node_Str""));
  control.setSourceViewer(sourceViewer);
  if (args.length > 1) {
    MapTable map=new MapTable(args[1]);
    cpu.getDisAsm().setMap(map);
    registry.registerComponent(""String_Node_Str"",map);
  }
  DataChart dataChart=new DataChart(""String_Node_Str"",""String_Node_Str"");
  dataChart.setupChipFrame(node.stats,cpu);
  registry.start();
  cpu.cpuloop();
}",0.995302407516148
5779,"public void portWrite(IOPort source,int data){
  if (source == port5) {
    redLed=(data & RED_LED) == 0;
    blueLed=(data & BLUE_LED) == 0;
    greenLed=(data & GREEN_LED) == 0;
    int newMode=(redLed ? 1 : 0) + (greenLed ? 1 : 0) + (blueLed ? 1 : 0);
    if (mode != newMode) {
      mode=newMode;
      modeChanged(mode);
    }
    if (gui != null) {
      gui.repaint();
    }
  }
 else   if (source == port4) {
    radio.setChipSelect((data & CC2420_CHIP_SELECT) == 0);
    flash.portWrite(source,data);
  }
}","public void portWrite(IOPort source,int data){
  if (source == port5) {
    redLed=(data & RED_LED) == 0;
    blueLed=(data & BLUE_LED) == 0;
    greenLed=(data & GREEN_LED) == 0;
    int newMode=(redLed ? 1 : 0) + (greenLed ? 1 : 0) + (blueLed ? 1 : 0);
    if (mode != newMode) {
      mode=newMode;
      modeChanged(mode);
    }
    if (gui != null) {
      gui.repaint();
    }
  }
 else   if (source == port4) {
    radio.setChipSelect((data & CC2420_CHIP_SELECT) == 0);
    radio.setVRegOn((data & CC2420_VREG) != 0);
    flash.portWrite(source,data);
  }
}",0.9555555555555556
5780,"private void sectorErase(int address){
  int sectorAddress=address & 0xf0000;
  for (int i=0; i < buffer.length; i++) {
    buffer[i]=(byte)0xff;
  }
  blockWriteAddress=sectorAddress;
  for (int i=0; i < 0x100; i++) {
    if (DEBUG)     System.out.println(""String_Node_Str"" + Integer.toHexString(blockWriteAddress));
    writeBack(blockWriteAddress,buffer);
    blockWriteAddress+=0x100;
  }
}","private void sectorErase(int address){
  int sectorAddress=address & 0xf0000;
  loadedAddress=-1;
  for (int i=0; i < buffer.length; i++) {
    buffer[i]=(byte)0xff;
  }
  blockWriteAddress=sectorAddress;
  for (int i=0; i < 0x100; i++) {
    if (DEBUG)     System.out.println(""String_Node_Str"" + Integer.toHexString(blockWriteAddress));
    writeBack(blockWriteAddress,buffer);
    blockWriteAddress+=0x100;
  }
}",0.9752475247524752
5781,"private void ensureLoaded(int address){
  if (!((loadedAddress & 0xfff00) == (address & 0xfff00))) {
    try {
      if (DEBUG)       System.out.println(""String_Node_Str"" + (address & 0xfff00));
      file.seek(address & 0xfff00);
      file.readFully(readMemory);
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    loadedAddress=address & 0xfff00;
  }
}","private void ensureLoaded(int address){
  if (loadedAddress < 0 || ((loadedAddress & 0xfff00) != (address & 0xfff00))) {
    try {
      if (DEBUG)       System.out.println(""String_Node_Str"" + (address & 0xfff00));
      file.seek(address & 0xfff00);
      file.readFully(readMemory);
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    loadedAddress=address & 0xfff00;
  }
}",0.9012987012987012
5782,"public long getTime(){
  long diff=cycles - lastTime;
  currentTime+=(long)(diff * currentDCOFactor);
  return 0;
}","public long getTime(){
  long diff=cycles - lastTime;
  currentTime+=(long)(diff * currentDCOFactor);
  return currentTime;
}",0.95
5783,"public void triggerInterrupts(){
  boolean trigger=false;
  int tIndex=0;
  for (int i=0, n=noCompare; i < n; i++) {
    boolean newTrigger=(tcctl[i] & CC_TRIGGER_INT) == CC_TRIGGER_INT;
    trigger=trigger | newTrigger;
    if (i == 0) {
      core.flagInterrupt(type == TIMER_A ? TACCR0_VECTOR : TBCCR0_VECTOR,this,trigger);
      if (trigger) {
        lastTIV=memory[type == TIMER_A ? TAIV : TBIV]=0;
        trigger=false;
      }
    }
 else {
      if (newTrigger) {
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + (i * 2));
        }
        tIndex=i;
      }
    }
  }
  core.flagInterrupt(type == TIMER_A ? TACCR1_VECTOR : TBCCR1_VECTOR,this,trigger);
  if (trigger) {
    lastTIV=memory[type == TIMER_A ? TAIV : TBIV]=tIndex * 2;
  }
}","public void triggerInterrupts(){
  boolean trigger=false;
  int tIndex=0;
  for (int i=0, n=noCompare; i < n; i++) {
    boolean newTrigger=(tcctl[i] & CC_TRIGGER_INT) == CC_TRIGGER_INT;
    trigger=trigger | newTrigger;
    if (i == 0) {
      core.flagInterrupt(type == TIMER_A ? TACCR0_VECTOR : TBCCR0_VECTOR,this,trigger);
      if (trigger) {
        lastTIV=memory[type == TIMER_A ? TAIV : TBIV]=0;
        return;
      }
    }
 else {
      if (newTrigger) {
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + (i * 2));
        }
        tIndex=i;
      }
    }
    if (trigger) {
      lastTIV=memory[type == TIMER_A ? TAIV : TBIV]=tIndex * 2;
    }
  }
  if (!trigger) {
    if (interruptEnable && interruptPending) {
      trigger=true;
      lastTIV=memory[type == TIMER_A ? TAIV : TBIV]=timerOverflow;
    }
  }
  core.flagInterrupt(type == TIMER_A ? TACCR1_VECTOR : TBCCR1_VECTOR,this,trigger);
}",0.7948866937826845
5784,"public int read(int address,boolean word,long cycles){
  int val=memory[address];
  if (word) {
    val|=memory[(address + 1) & 0xffff] << 8;
  }
  if (address == TAIV || address == TBIV) {
    resetTIV();
  }
  if (address != 0x166) {
    if (DEBUG && false) {
      System.out.println(""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str""+ Utils.hex16(memory[address] + (memory[address + 1] << 8))+ ""String_Node_Str""+ (memory[address] + (memory[address + 1] << 8))+ ""String_Node_Str"");
    }
  }
  int index=address - offset;
switch (index) {
case TR:
    return updateCounter(cycles);
case TCCTL0:
case TCCTL1:
case TCCTL2:
case TCCTL3:
case TCCTL4:
case TCCTL5:
case TCCTL6:
  int i=(index - TCCTL0) / 2;
return tcctl[i];
case TCCR0:
case TCCR1:
case TCCR2:
case TCCR3:
case TCCR4:
case TCCR5:
case TCCR6:
i=(index - TCCR0) / 2;
return tccr[i];
}
return val;
}","public int read(int address,boolean word,long cycles){
  int val=memory[address];
  if (word) {
    val|=memory[(address + 1) & 0xffff] << 8;
  }
  if (address == TAIV || address == TBIV) {
    resetTIV();
  }
  int index=address - offset;
switch (index) {
case TR:
    val=updateCounter(cycles);
  break;
case TCTL:
val=tctl;
if (interruptPending) {
val|=1;
}
 else {
val&=0xfffe;
}
System.out.println(getName() + ""String_Node_Str"" + name[type]+ ""String_Node_Str""+ inputDivider+ ""String_Node_Str""+ getSourceName(clockSource)+ ""String_Node_Str""+ interruptEnable+ ""String_Node_Str""+ interruptPending+ ""String_Node_Str""+ mode);
break;
case TCCTL0:
case TCCTL1:
case TCCTL2:
case TCCTL3:
case TCCTL4:
case TCCTL5:
case TCCTL6:
int i=(index - TCCTL0) / 2;
val=tcctl[i];
break;
case TCCR0:
case TCCR1:
case TCCR2:
case TCCR3:
case TCCR4:
case TCCR5:
case TCCR6:
i=(index - TCCR0) / 2;
val=tccr[i];
break;
}
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + getName(address)+ ""String_Node_Str""+ Utils.hex16(address)+ ""String_Node_Str""+ Utils.hex16(val)+ ""String_Node_Str""+ val+ ""String_Node_Str"");
}
return val & 0xffff;
}",0.3078460769615192
5785,"public String getName(){
  return ""String_Node_Str"" + name[type];
}","public String getName(int address){
  int reg=address - offset;
  if (reg == 0)   return ""String_Node_Str"";
  if (reg < 0x10)   return ""String_Node_Str"" + (reg - 2) / 2;
  if (reg == 0x10)   return ""String_Node_Str"";
  if (reg < 0x20)   return ""String_Node_Str"" + (reg - 0x12) / 2;
  return ""String_Node_Str"" + Utils.hex16(address) + ""String_Node_Str"";
}",0.2755344418052256
5786,"private void resetTIV(){
  if (lastTIV / 2 < noCompare) {
    if (DEBUG) {
      System.out.println(getName() + ""String_Node_Str"" + lastTIV);
    }
    tcctl[lastTIV / 2]&=~CC_IFG;
    triggerInterrupts();
  }
}","private void resetTIV(){
  if (lastTIV == timerOverflow) {
    interruptPending=false;
    lastTIV=0;
    if (DEBUG) {
      System.out.println(getName() + ""String_Node_Str"");
    }
    triggerInterrupts();
  }
  if (lastTIV / 2 < noCompare) {
    if (DEBUG) {
      System.out.println(getName() + ""String_Node_Str"" + lastTIV);
    }
    tcctl[lastTIV / 2]&=~CC_IFG;
    triggerInterrupts();
  }
}",0.6348684210526315
5787,"private void updateCaptures(int index,long cycles){
  int low=0;
  int hi=noCompare;
  if (index != -1) {
    low=index;
    hi=index + 1;
  }
  for (int i=0, n=hi; i < n; i++) {
    int divisor=1;
    int frqClk=1;
    if (clockSource == SRC_SMCLK) {
      frqClk=core.smclkFrq / inputDivider;
    }
 else     if (clockSource == SRC_ACLK) {
      frqClk=core.aclkFrq / inputDivider;
    }
    if (captureOn[i]) {
      if (inputSrc[i] == SRC_ACLK) {
        divisor=core.aclkFrq;
      }
      if (DEBUG) {
        System.out.println(getName() + ""String_Node_Str"" + i+ ""String_Node_Str""+ frqClk+ ""String_Node_Str""+ divisor);
      }
      expCapInterval[i]=frqClk / divisor;
      expCompare[i]=(counter + expCapInterval[i]) & 0xffff;
      expCaptureTime[i]=cycles + expCapInterval[i] * cyclesMultiplicator;
      if (DEBUG) {
        System.out.println(getName() + ""String_Node_Str"" + i+ ""String_Node_Str""+ expCompare[i]);
        System.out.println(getName() + ""String_Node_Str"" + expCaptureTime[i]);
        System.out.println(""String_Node_Str"" + captureOn[i]);
      }
    }
  }
}","private void updateCaptures(int index,long cycles){
  int low=0;
  int hi=noCompare;
  if (index != -1) {
    low=index;
    hi=index + 1;
  }
  for (int i=0, n=hi; i < n; i++) {
    int divisor=1;
    int frqClk=1;
    if (clockSource == SRC_SMCLK) {
      frqClk=core.smclkFrq / inputDivider;
    }
 else     if (clockSource == SRC_ACLK) {
      frqClk=core.aclkFrq / inputDivider;
    }
    if (captureOn[i]) {
      if (inputSrc[i] == SRC_ACLK) {
        divisor=core.aclkFrq;
      }
      if (DEBUG) {
        System.out.println(getName() + ""String_Node_Str"" + i+ ""String_Node_Str""+ frqClk+ ""String_Node_Str""+ divisor);
      }
      expCapInterval[i]=frqClk / divisor;
      expCompare[i]=(counter + expCapInterval[i]) & 0xffff;
      expCaptureTime[i]=cycles + (long)(expCapInterval[i] * cyclesMultiplicator);
      if (DEBUG) {
        System.out.println(getName() + ""String_Node_Str"" + i+ ""String_Node_Str""+ expCompare[i]);
        System.out.println(getName() + ""String_Node_Str"" + expCaptureTime[i]);
        System.out.println(""String_Node_Str"" + captureOn[i]);
      }
    }
  }
}",0.9963302752293578
5788,"public long ioTick(long cycles){
  for (int i=0, n=noCompare; i < n; i++) {
    if (expCaptureTime[i] != -1 && cycles > expCaptureTime[i]) {
      if (DEBUG) {
        System.out.println(getName() + ""String_Node_Str"" + i+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ expCaptureTime[i]+ ""String_Node_Str""+ Utils.hex16(expCompare[i])+ ""String_Node_Str""+ Utils.hex16(updateCounter(cycles)));
      }
      tcctl[i]|=CC_IFG;
      if (captureOn[i]) {
        tccr[i]=expCompare[i];
        expCompare[i]=(expCompare[i] + expCapInterval[i]) & 0xffff;
        expCaptureTime[i]+=expCapInterval[i] * cyclesMultiplicator;
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + expCaptureTime[i]);
        }
      }
 else {
        expCaptureTime[i]=expCaptureTime[i] + 0x10000 * cyclesMultiplicator;
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + expCaptureTime[i]);
        }
      }
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + Utils.hex16(offset + TCCTL0 + i * 2 + 1));
      }
    }
  }
  triggerInterrupts();
  return 1000 + cycles;
}","public long ioTick(long cycles){
  if (cycles > nextTimerTrigger) {
    interruptPending=true;
    nextTimerTrigger=(long)(nextTimerTrigger + 0x10000 * cyclesMultiplicator);
  }
  for (int i=0, n=noCompare; i < n; i++) {
    if (expCaptureTime[i] != -1 && cycles > expCaptureTime[i]) {
      if (DEBUG) {
        System.out.println(getName() + ""String_Node_Str"" + i+ ""String_Node_Str""+ cycles+ ""String_Node_Str""+ expCaptureTime[i]+ ""String_Node_Str""+ Utils.hex16(expCompare[i])+ ""String_Node_Str""+ Utils.hex16(updateCounter(cycles)));
      }
      tcctl[i]|=CC_IFG;
      if (captureOn[i]) {
        tccr[i]=expCompare[i];
        expCompare[i]=(expCompare[i] + expCapInterval[i]) & 0xffff;
        expCaptureTime[i]+=expCapInterval[i] * cyclesMultiplicator;
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + expCaptureTime[i]);
        }
      }
 else {
        expCaptureTime[i]=expCaptureTime[i] + (long)(0x10000 * cyclesMultiplicator);
        if (DEBUG) {
          System.out.println(getName() + ""String_Node_Str"" + expCaptureTime[i]);
        }
      }
      if (DEBUG) {
        System.out.println(""String_Node_Str"" + Utils.hex16(offset + TCCTL0 + i * 2 + 1));
      }
    }
  }
  triggerInterrupts();
  return 1000 + cycles;
}",0.9357952161141418
5789,"/** 
 * Creates a new <code>Timer</code> instance.
 */
public Timer(MSP430Core core,int[] srcMap,int[] memory,int offset){
  super(memory,offset);
  this.srcMap=srcMap;
  this.core=core;
  noCompare=(srcMap.length / 4) - 1;
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + noCompare);
  }
  if (srcMap == TIMER_Ax149) {
    type=TIMER_A;
  }
 else {
    type=TIMER_B;
  }
  reset();
}","/** 
 * Creates a new <code>Timer</code> instance.
 */
public Timer(MSP430Core core,int[] srcMap,int[] memory,int offset){
  super(memory,offset);
  this.srcMap=srcMap;
  this.core=core;
  noCompare=(srcMap.length / 4) - 1;
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + noCompare);
  }
  if (srcMap == TIMER_Ax149) {
    type=TIMER_A;
    timerOverflow=0x0a;
  }
 else {
    type=TIMER_B;
    timerOverflow=0x0e;
  }
  reset();
}",0.9424460431654677
5790,"public void write(int address,int data,boolean word,long cycles){
  memory[address]=data & 0xff;
  if (word) {
    memory[address + 1]=(data >> 8) & 0xff;
  }
  int iAddress=address - offset;
switch (iAddress) {
case TR:
    setCounter(data,cycles);
  break;
case TCTL:
if (DEBUG) {
  System.out.println(getName() + ""String_Node_Str"" + data);
}
inputDivider=1 << ((data >> 6) & 3);
clockSource=srcMap[(data >> 8) & 3];
cyclesMultiplicator=inputDivider;
if (clockSource == SRC_ACLK) {
cyclesMultiplicator=(cyclesMultiplicator * core.smclkFrq) / core.aclkFrq;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cyclesMultiplicator);
}
}
mode=(data >> 4) & 3;
if ((data & TCLR) != 0) {
counter=0;
counterStart=cycles;
countDirection=1;
memory[address]&=~4;
}
interruptEnable=(data & 1) > 0;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + name[type]+ ""String_Node_Str""+ inputDivider+ ""String_Node_Str""+ getSourceName(clockSource)+ ""String_Node_Str""+ interruptEnable+ ""String_Node_Str""+ interruptPending+ ""String_Node_Str""+ mode+ ((data & TCLR) != 0 ? ""String_Node_Str"" : ""String_Node_Str""));
}
if (interruptPending) {
memory[address]|=1;
}
 else {
memory[address]&=0xfe;
}
updateCaptures(-1,cycles);
break;
case TCCTL0:
case TCCTL1:
case TCCTL2:
case TCCTL3:
case TCCTL4:
case TCCTL5:
case TCCTL6:
int index=(iAddress - TCCTL0) / 2;
tcctl[index]=data;
outMode[index]=(data >> 5) & 7;
captureOn[index]=(data & 0x100) > 0;
sync[index]=(data & 0x800) > 0;
inputSel[index]=(data >> 12) & 3;
inputSrc[index]=srcMap[4 + index * 4 + inputSel[index]];
capMode[index]=(data >> 14) & 3;
triggerInterrupts();
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ capNames[capMode[index]]+ ""String_Node_Str""+ inputSel[index]+ ""String_Node_Str""+ getSourceName(inputSrc[index])+ ""String_Node_Str""+ captureOn[index]+ ""String_Node_Str""+ ((data & CC_IE) != 0));
}
updateCaptures(index,cycles);
break;
case TCCR0:
case TCCR1:
case TCCR2:
case TCCR3:
case TCCR4:
case TCCR5:
case TCCR6:
index=(iAddress - TCCR0) / 2;
tccr[index]=data;
updateCounter(cycles);
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ Utils.hex16(counter));
}
int diff=data - counter;
if (diff < 0) {
diff+=0x10000;
}
expCaptureTime[index]=cycles + cyclesMultiplicator * diff;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cycles+ ""String_Node_Str""+ index+ ""String_Node_Str""+ expCaptureTime[index]+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ data+ ""String_Node_Str""+ (100 * (cyclesMultiplicator * diff * 1L) / 2500000) / 100.0 + ""String_Node_Str"");
}
}
}","public void write(int address,int data,boolean word,long cycles){
  memory[address]=data & 0xff;
  if (word) {
    memory[address + 1]=(data >> 8) & 0xff;
  }
  int iAddress=address - offset;
switch (iAddress) {
case TR:
    setCounter(data,cycles);
  break;
case TCTL:
if (DEBUG) {
  System.out.println(getName() + ""String_Node_Str"" + Utils.hex16(data));
}
inputDivider=1 << ((data >> 6) & 3);
clockSource=srcMap[(data >> 8) & 3];
cyclesMultiplicator=inputDivider;
if (clockSource == SRC_ACLK) {
cyclesMultiplicator=(cyclesMultiplicator * core.smclkFrq) / core.aclkFrq;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cyclesMultiplicator);
}
}
if ((data & TCLR) != 0) {
counter=0;
counterStart=cycles;
countDirection=1;
}
int newMode=(data >> 4) & 3;
if (mode == STOP && newMode != STOP) {
updateCounter(cycles);
nextTimerTrigger=(long)(cycles + cyclesMultiplicator * ((0xffff - counter) & 0xffff));
}
mode=newMode;
interruptEnable=(data & 0x02) > 0;
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + name[type]+ ""String_Node_Str""+ inputDivider+ ""String_Node_Str""+ getSourceName(clockSource)+ ""String_Node_Str""+ interruptEnable+ ""String_Node_Str""+ interruptPending+ ""String_Node_Str""+ mode+ ((data & TCLR) != 0 ? ""String_Node_Str"" : ""String_Node_Str""));
}
tctl=data;
tctl&=~0x04;
if ((data & 0x01) == 0) {
interruptPending=false;
}
updateCaptures(-1,cycles);
break;
case TCCTL0:
case TCCTL1:
case TCCTL2:
case TCCTL3:
case TCCTL4:
case TCCTL5:
case TCCTL6:
int index=(iAddress - TCCTL0) / 2;
tcctl[index]=data;
outMode[index]=(data >> 5) & 7;
captureOn[index]=(data & 0x100) > 0;
sync[index]=(data & 0x800) > 0;
inputSel[index]=(data >> 12) & 3;
inputSrc[index]=srcMap[4 + index * 4 + inputSel[index]];
capMode[index]=(data >> 14) & 3;
triggerInterrupts();
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ capNames[capMode[index]]+ ""String_Node_Str""+ inputSel[index]+ ""String_Node_Str""+ getSourceName(inputSrc[index])+ ""String_Node_Str""+ captureOn[index]+ ""String_Node_Str""+ ((data & CC_IE) != 0));
}
updateCaptures(index,cycles);
break;
case TCCR0:
case TCCR1:
case TCCR2:
case TCCR3:
case TCCR4:
case TCCR5:
case TCCR6:
index=(iAddress - TCCR0) / 2;
tccr[index]=data;
updateCounter(cycles);
int diff=data - counter;
if (diff < 0) {
diff+=0x10000;
}
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + index+ ""String_Node_Str""+ Utils.hex16(data)+ ""String_Node_Str""+ Utils.hex16(counter)+ ""String_Node_Str""+ Utils.hex16(diff));
}
expCaptureTime[index]=cycles + (long)(cyclesMultiplicator * diff);
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cycles+ ""String_Node_Str""+ index+ ""String_Node_Str""+ expCaptureTime[index]+ ""String_Node_Str""+ counter+ ""String_Node_Str""+ data+ ""String_Node_Str""+ (100 * (cyclesMultiplicator * diff * 1L) / 2500000) / 100.0 + ""String_Node_Str"");
}
}
}",0.8844649840028439
5791,"private int updateCounter(long cycles){
  double divider=1;
  if (clockSource == SRC_ACLK) {
    divider=1.0 * core.smclkFrq / core.aclkFrq;
  }
  divider=divider * inputDivider;
  long cycctr=cycles - counterStart;
switch (mode) {
case CONTIN:
    counter=((int)(cycctr / divider)) & 0xffff;
  break;
case UP:
counter=((int)(cycctr / divider)) % tccr[0];
break;
case UPDWN:
counter=((int)(cycctr / divider)) % (tccr[0] * 2);
if (counter > tccr[0]) {
counter=2 * tccr[0] - counter;
}
}
return counter;
}","private int updateCounter(long cycles){
  double divider=1;
  if (clockSource == SRC_ACLK) {
    divider=1.0 * core.smclkFrq / core.aclkFrq;
  }
  divider=divider * inputDivider;
  long cycctr=cycles - counterStart;
switch (mode) {
case CONTIN:
    counter=((int)(cycctr / divider)) & 0xffff;
  break;
case UP:
counter=((int)(cycctr / divider)) % tccr[0];
break;
case UPDWN:
counter=((int)(cycctr / divider)) % (tccr[0] * 2);
if (counter > tccr[0]) {
counter=2 * tccr[0] - counter;
}
}
if (DEBUG) {
System.out.println(getName() + ""String_Node_Str"" + cycctr+ ""String_Node_Str""+ divider+ ""String_Node_Str""+ mode+ ""String_Node_Str""+ counter);
}
return counter;
}",0.8416523235800344
5792,"public ControlUI(MSP430 cpu,ELF elf){
  super(new GridLayout(0,1));
  this.cpu=cpu;
  this.stackUI=new StackUI(cpu);
  stackWindow=new JFrame(""String_Node_Str"");
  stackWindow.add(this.stackUI);
  WindowUtils.restoreWindowBounds(""String_Node_Str"",stackWindow);
  WindowUtils.addSaveOnShutdown(""String_Node_Str"",stackWindow);
  stackWindow.setVisible(true);
  window=new JFrame(TITLE);
  window.setLayout(new BorderLayout());
  window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  window.add(this,BorderLayout.WEST);
  window.add(dui=new DebugUI(cpu),BorderLayout.CENTER);
  createButton(""String_Node_Str"");
  createButton(""String_Node_Str"");
  stepAction=new AbstractAction(""String_Node_Str""){
    public void actionPerformed(    ActionEvent e){
      ControlUI.this.cpu.step();
      dui.repaint();
      if (elfData != null && sourceViewer != null && sourceViewer.isVisible()) {
        int pc=ControlUI.this.cpu.readRegister(MSP430Constants.PC);
        DebugInfo dbg=elfData.getDebugInfo(pc);
        if (dbg != null) {
          if (ControlUI.this.cpu.getDebug()) {
            System.out.println(""String_Node_Str"" + Integer.toString(pc,16) + ""String_Node_Str""+ dbg.getFile()+ ':'+ dbg.getLine());
          }
          sourceViewer.viewFile(dbg.getPath(),dbg.getFile());
          sourceViewer.viewLine(dbg.getLine());
        }
      }
    }
  }
;
  stepAction.putValue(Action.MNEMONIC_KEY,new Integer(KeyEvent.VK_S));
  stepAction.setEnabled(false);
  JButton stepButton=new JButton(stepAction);
  add(stepButton);
  if (elf != null) {
    createButton(""String_Node_Str"");
  }
  createButton(""String_Node_Str"");
  stepButton.getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_S,InputEvent.CTRL_MASK),""String_Node_Str"");
  stepButton.getActionMap().put(""String_Node_Str"",stepAction);
  WindowUtils.restoreWindowBounds(""String_Node_Str"",window);
  WindowUtils.addSaveOnShutdown(""String_Node_Str"",window);
  window.setVisible(true);
  elfData=elf;
}","public ControlUI(MSP430 cpu,ELF elf){
  super(new GridLayout(0,1));
  this.cpu=cpu;
  this.stackUI=new StackUI(cpu);
  stackWindow=new JFrame(""String_Node_Str"");
  stackWindow.add(this.stackUI);
  WindowUtils.restoreWindowBounds(""String_Node_Str"",stackWindow);
  WindowUtils.addSaveOnShutdown(""String_Node_Str"",stackWindow);
  stackWindow.setVisible(true);
  window=new JFrame(TITLE);
  window.setLayout(new BorderLayout());
  window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  window.add(this,BorderLayout.WEST);
  window.add(dui=new DebugUI(cpu),BorderLayout.CENTER);
  createButton(""String_Node_Str"");
  createButton(""String_Node_Str"");
  stepAction=new AbstractAction(""String_Node_Str""){
    public void actionPerformed(    ActionEvent e){
      ControlUI.this.cpu.step();
      dui.updateRegs();
      dui.repaint();
      if (elfData != null && sourceViewer != null && sourceViewer.isVisible()) {
        int pc=ControlUI.this.cpu.readRegister(MSP430Constants.PC);
        DebugInfo dbg=elfData.getDebugInfo(pc);
        if (dbg != null) {
          if (ControlUI.this.cpu.getDebug()) {
            System.out.println(""String_Node_Str"" + Integer.toString(pc,16) + ""String_Node_Str""+ dbg.getFile()+ ':'+ dbg.getLine());
          }
          sourceViewer.viewFile(dbg.getPath(),dbg.getFile());
          sourceViewer.viewLine(dbg.getLine());
        }
      }
    }
  }
;
  stepAction.putValue(Action.MNEMONIC_KEY,new Integer(KeyEvent.VK_S));
  stepAction.setEnabled(false);
  JButton stepButton=new JButton(stepAction);
  add(stepButton);
  if (elf != null) {
    createButton(""String_Node_Str"");
  }
  createButton(""String_Node_Str"");
  stepButton.getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_S,InputEvent.CTRL_MASK),""String_Node_Str"");
  stepButton.getActionMap().put(""String_Node_Str"",stepAction);
  WindowUtils.restoreWindowBounds(""String_Node_Str"",window);
  WindowUtils.addSaveOnShutdown(""String_Node_Str"",window);
  window.setVisible(true);
  elfData=elf;
}",0.9939819458375124
5793,"public void updateRegs(){
  if (regsLabel != null) {
    for (int i=0, n=16; i < n; i++) {
      regsLabel[i].setText(""String_Node_Str"" + Utils.hex16(cpu.reg[i]));
    }
  }
}","public void updateRegs(){
  if (regsLabel != null) {
    for (int i=0, n=16; i < n; i++) {
      regsLabel[i].setText(""String_Node_Str"" + Utils.hex16(cpu.reg[i]));
    }
  }
  repaint();
}",0.9641873278236914
5794,"public static void main(String[] args) throws IOException {
  final MSP430 cpu=new MSP430(0);
  cpu.setMonitorExec(true);
  int[] memory=cpu.getMemory();
  if (args[0].endsWith(""String_Node_Str"")) {
    IHexReader reader=new IHexReader();
    reader.readFile(memory,args[0]);
  }
 else {
    ELF elf=ELF.readELF(args[0]);
    elf.loadPrograms(memory);
    MapTable map=elf.getMap();
    cpu.getDisAsm().setMap(map);
    cpu.setMap(map);
  }
  cpu.reset();
  SkyNode node=new SkyNode(cpu);
  node.gui=new SkyGui(node);
  ControlUI control=new ControlUI(cpu);
  if (args.length > 1) {
    MapTable map=new MapTable(args[1]);
    cpu.getDisAsm().setMap(map);
  }
  cpu.cpuloop();
}","public static void main(String[] args) throws IOException {
  final MSP430 cpu=new MSP430(0);
  cpu.setMonitorExec(true);
  ELF elf=null;
  int[] memory=cpu.getMemory();
  if (args[0].endsWith(""String_Node_Str"")) {
    IHexReader reader=new IHexReader();
    reader.readFile(memory,args[0]);
  }
 else {
    elf=ELF.readELF(args[0]);
    elf.loadPrograms(memory);
    MapTable map=elf.getMap();
    cpu.getDisAsm().setMap(map);
    cpu.setMap(map);
  }
  cpu.reset();
  SkyNode node=new SkyNode(cpu);
  node.gui=new SkyGui(node);
  ControlUI control=new ControlUI(cpu,elf);
  if (args.length > 1) {
    MapTable map=new MapTable(args[1]);
    cpu.getDisAsm().setMap(map);
  }
  cpu.cpuloop();
}",0.9693877551020408
5795,"public void actionPerformed(ActionEvent ae){
  String cmd=ae.getActionCommand();
  updateCPUPercent();
  if (""String_Node_Str"".equals(cmd)) {
    cpu.setDebug(true);
    ((JButton)ae.getSource()).setText(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    cpu.setDebug(false);
    ((JButton)ae.getSource()).setText(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    new Thread(new Runnable(){
      public void run(){
        cpu.cpuloop();
      }
    }
).start();
    ((JButton)ae.getSource()).setText(""String_Node_Str"");
    stepAction.setEnabled(false);
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    cpu.stop();
    ((JButton)ae.getSource()).setText(""String_Node_Str"");
    stepAction.setEnabled(true);
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    if (cpu.getProfiler() != null) {
      cpu.getProfiler().printProfile();
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    int pc=cpu.readRegister(cpu.PC);
    if (sourceViewer != null) {
      DebugInfo dbg=elfData.getDebugInfo(pc);
      if (dbg != null) {
        if (sourceViewer != null) {
          sourceViewer.viewFile(dbg.getFile());
          sourceViewer.viewLine(dbg.getLine());
        }
 else {
          System.out.println(""String_Node_Str"" + dbg.getFile());
          System.out.println(""String_Node_Str"" + dbg.getLine());
        }
      }
    }
  }
  dui.updateRegs();
}","public void actionPerformed(ActionEvent ae){
  String cmd=ae.getActionCommand();
  updateCPUPercent();
  if (""String_Node_Str"".equals(cmd)) {
    cpu.setDebug(true);
    ((JButton)ae.getSource()).setText(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    cpu.setDebug(false);
    ((JButton)ae.getSource()).setText(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    new Thread(new Runnable(){
      public void run(){
        cpu.cpuloop();
      }
    }
).start();
    ((JButton)ae.getSource()).setText(""String_Node_Str"");
    stepAction.setEnabled(false);
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    cpu.stop();
    ((JButton)ae.getSource()).setText(""String_Node_Str"");
    stepAction.setEnabled(true);
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    if (cpu.getProfiler() != null) {
      cpu.getProfiler().printProfile();
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    int pc=cpu.readRegister(cpu.PC);
    if (elfData != null) {
      DebugInfo dbg=elfData.getDebugInfo(pc);
      if (dbg != null) {
        if (sourceViewer != null) {
          sourceViewer.viewFile(dbg.getFile());
          sourceViewer.viewLine(dbg.getLine());
        }
 else {
          System.out.println(""String_Node_Str"" + dbg.getFile());
          System.out.println(""String_Node_Str"" + dbg.getLine());
        }
      }
    }
  }
  dui.updateRegs();
}",0.9935087119918004
5796,"public void emulateOP(){
  int pc=readRegister(PC);
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  if (cycles > nextIOTickCycles) {
    handleIO();
  }
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad != AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
cycles+=3;
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
write=false;
updateStatus=false;
break;
case CALL:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles++;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as != AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=3;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
break;
}
}
if (dstRegMode) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=dst - src;
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
if (dst != 0) {
sr|=CARRY;
}
sr&=~OVERFLOW;
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
dst=src ^ dst;
write=true;
break;
case AND:
dst=src & dst;
write=true;
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
}
}
dst&=0xffff;
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
}","public void emulateOP(){
  int pc=readRegister(PC);
  if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
    pc=serviceInterrupt(pc);
  }
  if (breakPoints[pc] != null) {
    if (breakpointActive) {
      breakPoints[pc].cpuAction(CPUMonitor.BREAK,pc,0);
      breakpointActive=false;
      return;
    }
 else {
      breakpointActive=true;
    }
  }
  instruction=memory[pc] + (memory[pc + 1] << 8);
  op=instruction >> 12;
  int sp=0;
  int sr=0;
  boolean word=(instruction & 0x40) == 0;
  int dstRegister=0;
  int dstAddress=-1;
  boolean dstRegMode=false;
  int dst=0;
  boolean write=false;
  boolean updateStatus=true;
  if (cycles > nextIOTickCycles) {
    handleIO();
  }
  pc+=2;
  writeRegister(PC,pc);
switch (op) {
case 1:
{
      dstRegister=instruction & 0xf;
      int ad=(instruction >> 4) & 3;
      int nxtCarry=0;
      op=instruction & 0xff80;
      if (op == PUSH) {
        sp=readRegister(SP) - 2;
        writeRegister(SP,sp);
      }
      if ((dstRegister == CG1 && ad != AM_INDEX) || dstRegister == CG2) {
        dstRegMode=true;
        cycles++;
      }
 else {
switch (ad) {
case AM_REG:
          dstRegMode=true;
        cycles++;
      break;
case AM_INDEX:
    dstAddress=readRegisterCG(dstRegister,ad) + memory[pc] + (memory[pc + 1] << 8);
  pc+=2;
writeRegister(PC,pc);
cycles+=4;
break;
case AM_IND_REG:
dstAddress=readRegister(dstRegister);
cycles+=3;
break;
case AM_IND_AUTOINC:
dstAddress=readRegister(dstRegister);
writeRegister(dstRegister,dstAddress + (word ? 2 : 1));
cycles+=3;
break;
}
}
if (dstRegMode) {
dst=readRegisterCG(dstRegister,ad);
if (!word) {
dst&=0xff;
}
}
 else {
dst=read(dstAddress,word);
}
switch (op) {
case RRC:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
dst=dst >> 1;
if (word) {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x8000 : 0;
}
 else {
dst|=(readRegister(SR) & CARRY) > 0 ? 0x80 : 0;
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SWPB:
int tmp=dst;
dst=((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
write=true;
break;
case RRA:
nxtCarry=(dst & 1) > 0 ? CARRY : 0;
if (word) {
dst=(dst & 0x8000) | (dst >> 1);
}
 else {
dst=(dst & 0x80) | (dst >> 1);
}
write=true;
writeRegister(SR,(readRegister(SR) & ~CARRY) | nxtCarry);
break;
case SXT:
dst=(dst & 0x80) > 0 ? dst | 0xff00 : dst & 0x7f;
write=true;
break;
case PUSH:
if (word) {
memory[sp]=dst & 0xff;
memory[sp + 1]=dst >> 8;
}
 else {
memory[sp]=dst & 0xff;
memory[sp + 1]=0;
}
write=false;
updateStatus=false;
break;
case CALL:
sp=readRegister(SP) - 2;
writeRegister(SP,sp);
pc=readRegister(PC);
memory[sp]=pc & 0xff;
memory[sp + 1]=pc >> 8;
writeRegister(PC,dst);
write=false;
updateStatus=false;
break;
case RETI:
sp=readRegister(SP);
writeRegister(SR,memory[sp++] + (memory[sp++] << 8));
writeRegister(PC,memory[sp++] + (memory[sp++] << 8));
writeRegister(SP,sp);
write=false;
updateStatus=false;
if (debugInterrupts) {
System.out.println(""String_Node_Str"" + pc + ""String_Node_Str""+ reg[PC]+ ""String_Node_Str""+ reg[SP]);
}
handlePendingInterrupts();
break;
default :
System.out.println(""String_Node_Str"" + instruction);
}
}
break;
case 2:
case 3:
int jmpOffset=instruction & 0x3ff;
jmpOffset=(jmpOffset & 0x200) == 0 ? 2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
boolean jump=false;
cycles++;
sr=readRegister(SR);
switch (instruction & 0xfc00) {
case JNE:
jump=(sr & ZERO) == 0;
break;
case JEQ:
jump=(sr & ZERO) > 0;
break;
case JNC:
jump=(sr & CARRY) == 0;
break;
case JC:
jump=(sr & CARRY) > 0;
break;
case JN:
jump=(sr & NEGATIVE) > 0;
break;
case JGE:
jump=(sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
break;
case JL:
jump=(sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
break;
case JMP:
jump=true;
break;
default :
System.out.println(""String_Node_Str"" + Utils.binary16(instruction));
}
if (jump) {
writeRegister(PC,pc + jmpOffset);
}
break;
default :
dstRegister=instruction & 0xf;
int srcRegister=(instruction >> 8) & 0xf;
int as=(instruction >> 4) & 3;
dstRegMode=((instruction >> 7) & 1) == 0;
dstAddress=-1;
int srcAddress=-1;
int src=0;
if ((srcRegister == CG1 && as != AM_INDEX) || srcRegister == CG2) {
src=CREG_VALUES[srcRegister - 2][as];
if (!word) {
src&=0xff;
}
}
 else {
switch (as) {
case AM_REG:
src=readRegister(srcRegister);
if (!word) {
src&=0xff;
}
break;
case AM_INDEX:
srcAddress=readRegisterCG(srcRegister,as) + memory[pc] + (memory[pc + 1] << 8);
incRegister(PC,2);
cycles+=dstRegMode ? 3 : 6;
break;
case AM_IND_REG:
srcAddress=readRegister(srcRegister);
cycles+=dstRegMode ? 2 : 5;
break;
case AM_IND_AUTOINC:
if (srcRegister == PC) {
srcAddress=readRegister(PC);
pc+=2;
incRegister(PC,2);
cycles+=3;
}
 else {
srcAddress=readRegister(srcRegister);
incRegister(srcRegister,word ? 2 : 1);
cycles+=dstRegMode ? 2 : 5;
}
break;
}
}
if (dstRegMode) {
dst=readRegister(dstRegister);
if (!word) {
dst&=0xff;
}
}
 else {
pc=readRegister(PC);
if (dstRegister == 2) {
dstAddress=memory[pc] + (memory[pc + 1] << 8);
}
 else {
dstAddress=readRegister(dstRegister) + memory[pc] + (memory[pc + 1] << 8);
}
dst=read(dstAddress,word);
pc+=2;
incRegister(PC,2);
}
if (srcAddress != -1) {
srcAddress=srcAddress & 0xffff;
src=read(srcAddress,word);
}
int tmp=0;
int tmpAdd=0;
switch (op) {
case MOV:
dst=src;
write=true;
break;
case SUB:
tmpAdd=1;
case SUBC:
src=(src ^ 0xffff) & 0xffff;
case ADDC:
if (op == ADDC || op == SUBC) tmpAdd=((readRegister(SR) & CARRY) > 0) ? 1 : 0;
case ADD:
sr=readRegister(SR);
sr&=~(OVERFLOW | CARRY);
tmp=(src ^ dst) & (word ? 0x8000 : 0x80);
dst=dst + src + tmpAdd;
if (dst > (word ? 0xffff : 0xff)) {
sr|=CARRY;
}
if (tmp == 0 && ((src ^ dst) & (word ? 0x8000 : 0x80)) != 0) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
write=true;
break;
case CMP:
int b=word ? 0x8000 : 0x80;
sr=readRegister(SR);
sr=(sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);
tmp=dst - src;
if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
sr|=OVERFLOW;
}
writeRegister(SR,sr);
dst=tmp;
break;
case DADD:
if (DEBUG) System.out.println(""String_Node_Str"");
dst=dst + src + ((readRegister(SR) & CARRY) > 0 ? 1 : 0);
write=true;
break;
case BIT:
dst=src & dst;
sr=readRegister(SR);
sr=sr & ~(CARRY | OVERFLOW);
if (dst != 0) {
sr|=CARRY;
}
writeRegister(SR,sr);
break;
case BIC:
dst=(~src) & dst;
write=true;
updateStatus=false;
break;
case BIS:
dst=src | dst;
write=true;
updateStatus=false;
break;
case XOR:
dst=src ^ dst;
write=true;
break;
case AND:
dst=src & dst;
write=true;
break;
default :
System.out.println(""String_Node_Str"" + op + ""String_Node_Str""+ pc);
}
}
dst&=0xffff;
if (write) {
if (dstRegMode) {
writeRegister(dstRegister,dst);
}
 else {
dstAddress&=0xffff;
write(dstAddress,dst,word);
}
}
if (updateStatus) {
sr=readRegister(SR);
sr=(sr & ~(ZERO | NEGATIVE)) | ((dst == 0) ? ZERO : 0) | (word ? ((dst & 0x8000) > 0 ? NEGATIVE : 0) : ((dst & 0x80) > 0 ? NEGATIVE : 0));
writeRegister(SR,sr);
}
}",0.9939900322486076
5797,"public static OfficeFinder getFinder(final MsOfficeType contentType){
  OsEnum os=OsEnum.getOS(System.getProperty(""String_Node_Str""));
switch (os) {
case WINDOWS_XP:
case WINDOWS_VISTA:
case WINDOWS_SEVEN:
    if (contentType.isMsOfficeCompatible()) {
      return new MsOfficeRegistryHelper();
    }
  return new WindowsOpenOfficeFinder();
case LINUX:
return new WhereisHelper();
case MAC_OSX:
return new MacOsOfficeFinder();
default :
return new WhereisHelper();
}
}","public static OfficeFinder getFinder(final MsOfficeType contentType){
  OsEnum os=OsEnum.getOS(System.getProperty(""String_Node_Str""));
switch (os) {
case WINDOWS_XP:
case WINDOWS_VISTA:
case WINDOWS_SEVEN:
case WINDOWS_8:
    if (contentType.isMsOfficeCompatible()) {
      return new MsOfficeRegistryHelper();
    }
  return new WindowsOpenOfficeFinder();
case LINUX:
return new WhereisHelper();
case MAC_OSX:
return new MacOsOfficeFinder();
default :
return new WhereisHelper();
}
}",0.9831932773109244
5798,"/** 
 * Launch document edition
 * @param path path to editor
 * @param url document url
 * @param modeDisconnected disconnected mode.
 * @param auth authentication info
 * @return status
 * @throws IOException
 * @throws InterruptedException
 */
protected static int launch(MsOfficeType type,String path,String url,boolean modeDisconnected,AuthenticationInfo auth) throws IOException, InterruptedException {
  logger.log(Level.INFO,""String_Node_Str"",path);
  logger.log(Level.INFO,""String_Node_Str"",url);
  logger.log(Level.INFO,""String_Node_Str"",new Object[]{path,url});
  if (modeDisconnected) {
    try {
      String webdavUrl=url;
      final FileWebDavAccessManager webdavAccessManager=new FileWebDavAccessManager(auth);
      if ('""' == url.charAt(0)) {
        webdavUrl=url.substring(1,url.length() - 1);
      }
      String tmpFilePath=webdavAccessManager.retrieveFile(webdavUrl);
      logger.log(Level.INFO,""String_Node_Str"",new Object[]{path,tmpFilePath});
      Process process=Runtime.getRuntime().exec(path + ' ' + tmpFilePath);
      process.waitFor();
      webdavAccessManager.pushFile(tmpFilePath,url);
      MessageDisplayer.displayMessage(MessageUtil.getMessage(""String_Node_Str""));
      return 0;
    }
 catch (    HttpException ex) {
      logger.log(Level.SEVERE,null,ex);
      throw new IOException(ex);
    }
catch (    IOException ex) {
      logger.log(Level.SEVERE,null,ex);
      throw ex;
    }
  }
 else {
    String webdavUrl=url;
    if (OsEnum.getOS() == OsEnum.WINDOWS_XP || (OsEnum.isWindows() && MsOfficeVersion.isOldOffice(type))) {
      webdavUrl=webdavUrl.replace(""String_Node_Str"",""String_Node_Str"");
    }
    logger.log(Level.INFO,""String_Node_Str"",new Object[]{path,webdavUrl});
    Process process=Runtime.getRuntime().exec(path + ' ' + webdavUrl);
    return process.waitFor();
  }
}","/** 
 * Launch document edition
 * @param path path to editor
 * @param url document url
 * @param modeDisconnected disconnected mode.
 * @param auth authentication info
 * @return status
 * @throws IOException
 * @throws InterruptedException
 */
protected static int launch(MsOfficeType type,String path,String url,boolean modeDisconnected,AuthenticationInfo auth) throws IOException, InterruptedException {
  logger.log(Level.INFO,""String_Node_Str"",path);
  logger.log(Level.INFO,""String_Node_Str"",url);
  if (modeDisconnected) {
    try {
      String webdavUrl=url;
      final FileWebDavAccessManager webdavAccessManager=new FileWebDavAccessManager(auth);
      if ('""' == url.charAt(0)) {
        webdavUrl=url.substring(1,url.length() - 1);
      }
      String tmpFilePath=webdavAccessManager.retrieveFile(webdavUrl);
      logger.log(Level.INFO,""String_Node_Str"",new Object[]{path,tmpFilePath});
      Process process=Runtime.getRuntime().exec(path + ' ' + tmpFilePath);
      process.waitFor();
      webdavAccessManager.pushFile(tmpFilePath,url);
      MessageDisplayer.displayMessage(MessageUtil.getMessage(""String_Node_Str""));
      return 0;
    }
 catch (    HttpException ex) {
      logger.log(Level.SEVERE,null,ex);
      throw new IOException(ex);
    }
catch (    IOException ex) {
      logger.log(Level.SEVERE,null,ex);
      throw ex;
    }
  }
 else {
    logger.log(Level.INFO,""String_Node_Str"",new Object[]{path,url});
    Process process=Runtime.getRuntime().exec(path + ' ' + url);
    return process.waitFor();
  }
}",0.9127477077787636
5799,"/** 
 * Launch document edition
 * @param path path to editor
 * @param url document url
 * @param modeDisconnected disconnected mode.
 * @param auth authentication info
 * @return status
 * @throws IOException
 * @throws InterruptedException
 */
protected static int launch(MsOfficeType type,String path,String url,boolean modeDisconnected,AuthenticationInfo auth) throws IOException, InterruptedException {
  logger.log(Level.INFO,""String_Node_Str"",path);
  logger.log(Level.INFO,""String_Node_Str"",url);
  logger.log(Level.INFO,""String_Node_Str"",new Object[]{path,url});
  if (modeDisconnected) {
    try {
      String webdavUrl=url;
      final FileWebDavAccessManager webdavAccessManager=new FileWebDavAccessManager(auth);
      if ('""' == url.charAt(0)) {
        webdavUrl=url.substring(1,url.length() - 1);
      }
      String tmpFilePath=webdavAccessManager.retrieveFile(webdavUrl);
      logger.log(Level.INFO,""String_Node_Str"",new Object[]{path,tmpFilePath});
      Process process=Runtime.getRuntime().exec(path + ' ' + tmpFilePath);
      process.waitFor();
      webdavAccessManager.pushFile(tmpFilePath,url);
      MessageDisplayer.displayMessage(MessageUtil.getMessage(""String_Node_Str""));
      return 0;
    }
 catch (    HttpException ex) {
      logger.log(Level.SEVERE,null,ex);
      throw new IOException(ex);
    }
catch (    IOException ex) {
      logger.log(Level.SEVERE,null,ex);
      throw ex;
    }
  }
 else {
    String webdavUrl=url;
    if (OsEnum.isWindows() && MsOfficeVersion.isOldOffice(type)) {
      webdavUrl=webdavUrl.replace(""String_Node_Str"",""String_Node_Str"");
    }
    logger.log(Level.INFO,""String_Node_Str"",new Object[]{path,webdavUrl});
    Process process=Runtime.getRuntime().exec(path + ' ' + webdavUrl);
    return process.waitFor();
  }
}","/** 
 * Launch document edition
 * @param path path to editor
 * @param url document url
 * @param modeDisconnected disconnected mode.
 * @param auth authentication info
 * @return status
 * @throws IOException
 * @throws InterruptedException
 */
protected static int launch(MsOfficeType type,String path,String url,boolean modeDisconnected,AuthenticationInfo auth) throws IOException, InterruptedException {
  logger.log(Level.INFO,""String_Node_Str"",path);
  logger.log(Level.INFO,""String_Node_Str"",url);
  logger.log(Level.INFO,""String_Node_Str"",new Object[]{path,url});
  if (modeDisconnected) {
    try {
      String webdavUrl=url;
      final FileWebDavAccessManager webdavAccessManager=new FileWebDavAccessManager(auth);
      if ('""' == url.charAt(0)) {
        webdavUrl=url.substring(1,url.length() - 1);
      }
      String tmpFilePath=webdavAccessManager.retrieveFile(webdavUrl);
      logger.log(Level.INFO,""String_Node_Str"",new Object[]{path,tmpFilePath});
      Process process=Runtime.getRuntime().exec(path + ' ' + tmpFilePath);
      process.waitFor();
      webdavAccessManager.pushFile(tmpFilePath,url);
      MessageDisplayer.displayMessage(MessageUtil.getMessage(""String_Node_Str""));
      return 0;
    }
 catch (    HttpException ex) {
      logger.log(Level.SEVERE,null,ex);
      throw new IOException(ex);
    }
catch (    IOException ex) {
      logger.log(Level.SEVERE,null,ex);
      throw ex;
    }
  }
 else {
    String webdavUrl=url;
    if (OsEnum.getOS() == OsEnum.WINDOWS_XP || (OsEnum.isWindows() && MsOfficeVersion.isOldOffice(type))) {
      webdavUrl=webdavUrl.replace(""String_Node_Str"",""String_Node_Str"");
    }
    logger.log(Level.INFO,""String_Node_Str"",new Object[]{path,webdavUrl});
    Process process=Runtime.getRuntime().exec(path + ' ' + webdavUrl);
    return process.waitFor();
  }
}",0.9887083448085928
5800,"protected String getPath(RegistryApplicationKey type){
  String clsid=getClsid(type);
  if (clsid != null) {
    String path=RegistryKeyReader.readKey(BASE_KEY_CLSID + clsid + ""String_Node_Str"");
    if (path == null) {
      path=RegistryKeyReader.readKey(BASE_KEY_64_CLSID + clsid + ""String_Node_Str"");
    }
    if (path != null) {
      String extractedPath=extractPath(path);
      if (!extractedPath.startsWith(""String_Node_Str"")) {
        extractedPath='""' + extractedPath + '""';
      }
      return extractedPath;
    }
  }
  return null;
}","protected String getPath(RegistryApplicationKey type){
  String clsid=getClsid(type);
  if (clsid != null) {
    String path=RegistryKeyReader.readKey(BASE_KEY_CLSID + clsid + ""String_Node_Str"");
    if (path == null) {
      path=RegistryKeyReader.readKey(BASE_KEY_64_CLSID + clsid + ""String_Node_Str"");
    }
    if (path != null) {
      String extractedPath=extractPath(path).trim();
      if (!extractedPath.startsWith(""String_Node_Str"")) {
        extractedPath='""' + extractedPath + '""';
      }
      return extractedPath;
    }
  }
  return null;
}",0.993676603432701
5801,"private static MsOfficeType getContentType(String url) throws MalformedURLException {
  String fileName=new URL(url).getFile();
  String contentType=mimeTypes.getContentType(fileName);
  return MsOfficeType.valueOfMimeType(contentType);
}","protected static MsOfficeType getContentType(String url) throws MalformedURLException {
  String fileName=new URL(url).getFile();
  String contentType=mimeTypes.getContentType(fileName.toLowerCase());
  return MsOfficeType.valueOfMimeType(contentType);
}",0.9471544715447154
5802,"public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
  if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    msg=true;
    curMessage=new Message();
    for (int i=0; i < attributes.getLength(); i++) {
      curMessage.addParam(attributes.getLocalName(i),attributes.getValue(i));
    }
    return;
  }
  String enabledStr=attributes.getValue(""String_Node_Str"");
  if (enabledStr != null) {
    if (enabledStr.equalsIgnoreCase(""String_Node_Str"") || enabledStr.equalsIgnoreCase(""String_Node_Str"")) {
      enabled=false;
    }
 else {
      enabled=true;
    }
  }
  if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    conf=true;
    enabled=true;
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    queue=true;
    DataSource.enableQueue=enabled;
    if (enabled) {
      String mpm=attributes.getValue(""String_Node_Str"");
      String hold=attributes.getValue(""String_Node_Str"");
      if (mpm != null) {
        try {
          int mpmi=Integer.parseInt(mpm);
          if (mpmi > 0) {
            DataSource.mpm=mpmi;
          }
 else {
            log.warning(ServerEvents.configFile + ""String_Node_Str"");
          }
        }
 catch (        Exception e) {
          log.warning(ServerEvents.configFile + ""String_Node_Str"");
        }
      }
      if (hold != null) {
        try {
          int holdi=Integer.parseInt(hold);
          if (holdi > 0) {
            DataSource.hold=holdi;
          }
 else {
            log.warning(ServerEvents.configFile + ""String_Node_Str"");
          }
        }
 catch (        Exception e) {
          log.warning(ServerEvents.configFile + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    file=true;
    if (enabled) {
      String tmpUri=attributes.getValue(""String_Node_Str"");
      String tmpKeep=attributes.getValue(""String_Node_Str"");
      String finalUri=""String_Node_Str"" + File.separatorChar + ""String_Node_Str"";
      int finalKeep=5;
      if (tmpUri == null || tmpUri.equals(""String_Node_Str"")) {
        log.warning(ServerEvents.configFile + ""String_Node_Str"");
      }
      if (tmpKeep == null || tmpKeep.equals(""String_Node_Str"")) {
        log.warning(ServerEvents.configFile + ""String_Node_Str"");
      }
 else {
        try {
          int keep=Integer.parseInt(tmpKeep);
          if (keep > 0) {
          }
 else {
            log.warning(ServerEvents.configFile + ""String_Node_Str"");
          }
        }
 catch (        Exception e) {
          log.warning(ServerEvents.configFile + ""String_Node_Str"");
        }
      }
      DataSource.addFileDataSource(finalUri,finalKeep);
    }
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    twitter=true;
    if (enabled) {
      int rate=350;
      String rate_limit=attributes.getValue(""String_Node_Str"");
      try {
        rate=Integer.parseInt(rate_limit);
        if (rate <= 0) {
          rate=350;
          log.warning(ServerEvents.configFile + ""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        log.warning(ServerEvents.configFile + ""String_Node_Str"");
      }
      DataSource.addTwitterDataSource(attributes.getValue(""String_Node_Str""),attributes.getValue(""String_Node_Str""),rate);
    }
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    database=true;
    if (enabled) {
      DataSource.addDatabaseDataSource(attributes.getValue(""String_Node_Str""),attributes.getValue(""String_Node_Str""),attributes.getValue(""String_Node_Str""),attributes.getValue(""String_Node_Str""),attributes.getValue(""String_Node_Str""));
    }
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    chat=true;
    if (enabled) {
      DataSource.addChatDataSource(plugin,attributes.getValue(""String_Node_Str""),attributes.getValue(""String_Node_Str""),attributes.getValue(""String_Node_Str""));
    }
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    random=true;
    try {
      int delay=Integer.parseInt(attributes.getValue(""String_Node_Str""));
      if (delay < 60000) {
        Messages.randomDelay=60000;
      }
 else {
        Messages.randomDelay=delay;
      }
    }
 catch (    Exception e) {
    }
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    join=true;
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    quit=true;
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    ban=true;
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    kick=true;
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    command=true;
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    death=true;
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    block=true;
  }
}","public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
  if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    msg=true;
    curMessage=new Message();
    for (int i=0; i < attributes.getLength(); i++) {
      curMessage.addParam(attributes.getLocalName(i),attributes.getValue(i));
    }
    return;
  }
  String enabledStr=attributes.getValue(""String_Node_Str"");
  if (enabledStr != null) {
    if (enabledStr.equalsIgnoreCase(""String_Node_Str"") || enabledStr.equalsIgnoreCase(""String_Node_Str"")) {
      enabled=false;
    }
 else {
      enabled=true;
    }
  }
  if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    conf=true;
    enabled=true;
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    queue=true;
    DataSource.enableQueue=enabled;
    if (enabled) {
      String mpm=attributes.getValue(""String_Node_Str"");
      String hold=attributes.getValue(""String_Node_Str"");
      if (mpm != null) {
        try {
          int mpmi=Integer.parseInt(mpm);
          if (mpmi > 0) {
            DataSource.mpm=mpmi;
          }
 else {
            log.warning(ServerEvents.configFile + ""String_Node_Str"");
          }
        }
 catch (        Exception e) {
          log.warning(ServerEvents.configFile + ""String_Node_Str"");
        }
      }
      if (hold != null) {
        try {
          int holdi=Integer.parseInt(hold);
          if (holdi > 0) {
            DataSource.hold=holdi;
          }
 else {
            log.warning(ServerEvents.configFile + ""String_Node_Str"");
          }
        }
 catch (        Exception e) {
          log.warning(ServerEvents.configFile + ""String_Node_Str"");
        }
      }
    }
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    file=true;
    if (enabled) {
      String tmpUri=attributes.getValue(""String_Node_Str"");
      String tmpKeep=attributes.getValue(""String_Node_Str"");
      String finalUri=""String_Node_Str"" + File.separatorChar + ""String_Node_Str"";
      int finalKeep=5;
      if (tmpUri == null || tmpUri.equals(""String_Node_Str"")) {
        log.warning(ServerEvents.configFile + ""String_Node_Str"");
      }
      if (tmpKeep == null || tmpKeep.equals(""String_Node_Str"")) {
        log.warning(ServerEvents.configFile + ""String_Node_Str"");
      }
 else {
        try {
          int keep=Integer.parseInt(tmpKeep);
          if (keep > 0) {
            finalKeep=keep;
          }
 else {
            log.warning(ServerEvents.configFile + ""String_Node_Str"");
          }
        }
 catch (        Exception e) {
          log.warning(ServerEvents.configFile + ""String_Node_Str"");
        }
      }
      DataSource.addFileDataSource(finalUri,finalKeep);
    }
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    twitter=true;
    if (enabled) {
      int rate=350;
      String rate_limit=attributes.getValue(""String_Node_Str"");
      try {
        rate=Integer.parseInt(rate_limit);
        if (rate <= 0) {
          rate=350;
          log.warning(ServerEvents.configFile + ""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        log.warning(ServerEvents.configFile + ""String_Node_Str"");
      }
      DataSource.addTwitterDataSource(attributes.getValue(""String_Node_Str""),attributes.getValue(""String_Node_Str""),rate);
    }
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    database=true;
    if (enabled) {
      DataSource.addDatabaseDataSource(attributes.getValue(""String_Node_Str""),attributes.getValue(""String_Node_Str""),attributes.getValue(""String_Node_Str""),attributes.getValue(""String_Node_Str""),attributes.getValue(""String_Node_Str""));
    }
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    chat=true;
    if (enabled) {
      DataSource.addChatDataSource(plugin,attributes.getValue(""String_Node_Str""),attributes.getValue(""String_Node_Str""),attributes.getValue(""String_Node_Str""));
    }
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    random=true;
    try {
      int delay=Integer.parseInt(attributes.getValue(""String_Node_Str""));
      if (delay < 60000) {
        Messages.randomDelay=60000;
      }
 else {
        Messages.randomDelay=delay;
      }
    }
 catch (    Exception e) {
    }
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    join=true;
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    quit=true;
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    ban=true;
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    kick=true;
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    command=true;
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    death=true;
  }
 else   if (qName.equalsIgnoreCase(""String_Node_Str"")) {
    block=true;
  }
}",0.9970631424375918
5803,"private void completeView(){
  List<TChar> tChars=currentWord.getChars();
  for (  TChar tChar : tChars) {
    Button charView=new Button(context);
    styleView(charView,tChar.getChar(),20,0xFF000000);
    LinearLayout.LayoutParams layoutParams=new LinearLayout.LayoutParams(50,50,1);
    charView.setLayoutParams(layoutParams);
    charView.setBackgroundResource(R.layout.completed_bg);
    charLayout.addView(charView);
    words.removeFirst();
  }
  if (!words.isEmpty()) {
    nextButton.setVisibility(VISIBLE);
    jumbleButton.setVisibility(INVISIBLE);
  }
 else   finishActivity.endGame();
}","private void completeView(){
  List<TChar> tChars=currentWord.getChars();
  for (  TChar tChar : tChars) {
    Button charView=new Button(context);
    styleView(charView,tChar.getChar(),20,0xFF000000);
    LinearLayout.LayoutParams layoutParams=new LinearLayout.LayoutParams(50,50,1);
    charView.setLayoutParams(layoutParams);
    charView.setBackgroundResource(R.layout.completed_bg);
    charLayout.addView(charView);
  }
  words.removeFirst();
  if (!words.isEmpty()) {
    nextButton.setVisibility(VISIBLE);
    jumbleButton.setVisibility(INVISIBLE);
  }
 else   finishActivity.endGame();
}",0.9949832775919732
5804,"public boolean onCommand(CommandSender sender,Command command,String label,String[] args){
  boolean isPlayer=(sender instanceof Player);
  if (!isPlayer) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  String sendername=((Player)sender).getName();
  if (label.equalsIgnoreCase(""String_Node_Str"")) {
    if (!plugin.playerPermission((Player)sender,PermissionNodes.ACCESS)) {
      sender.sendMessage(ChatColor.DARK_RED + ""String_Node_Str"");
      return true;
    }
    if (plugin.settings.Areas) {
      CommandList foundCommand=CommandList.valueOf(args[0].toUpperCase());
      if (foundCommand != null) {
        if (foundCommand.getRequireArea() && !plugin.inArea(((Player)sender).getWorld().getName(),((Player)sender).getLocation())) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
      }
    }
    if (args.length > 0) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.OPEN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (plugin.font.stringWidth(args[1]) > 150) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
        if (plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else {
          String players=""String_Node_Str"";
          players+=sendername;
          if (args.length >= 3) {
            for (int i=3; i <= args.length; i++) {
              players+=""String_Node_Str"" + args[i - 1];
            }
          }
          if (plugin.openAccount(args[1],players,sendername)) {
            plugin.addTransaction(sendername,args[1],TransactionTypes.OPEN,0.00);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + args[1]+ ""String_Node_Str"");
            players=""String_Node_Str"";
            players+=sendername;
            if (args.length >= 3) {
              for (int i=3; i <= args.length; i++) {
                players+=""String_Node_Str"" + args[i - 1];
              }
            }
            sender.sendMessage(ChatColor.WHITE + ""String_Node_Str"" + ChatColor.GREEN+ players);
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.OPEN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else {
          if (plugin.accessAccount(args[1],(Player)sender,false)) {
            sender.sendMessage(""String_Node_Str"" + args[1] + ""String_Node_Str""+ ChatColor.GREEN+ plugin.Method.format(plugin.getBalance(args[1])));
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.OPEN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else {
          if (plugin.accessAccount(args[1],(Player)sender,false)) {
            sender.sendMessage(""String_Node_Str"" + args[1] + ""String_Node_Str""+ ChatColor.GREEN+ plugin.Method.format(plugin.getBalance(args[1])));
            sender.sendMessage(ChatColor.WHITE + ""String_Node_Str"" + ChatColor.GREEN+ plugin.getOwners(args[1]));
            sender.sendMessage(ChatColor.WHITE + ""String_Node_Str"" + ChatColor.GREEN+ plugin.getUsers(args[1]));
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.LIST)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        List<String> accounts=plugin.accountList((Player)sender);
        int tmpWidth=0;
        String output=""String_Node_Str"";
        for (        String account : accounts) {
          plugin.console.info(account);
          if (tmpWidth == 0) {
            tmpWidth=plugin.font.stringWidth(account);
            output=account;
          }
 else {
            while (tmpWidth < 160) {
              output+=""String_Node_Str"";
              tmpWidth+=plugin.font.stringWidth(""String_Node_Str"");
            }
            output+=account;
            sender.sendMessage(output);
            tmpWidth=0;
            output=""String_Node_Str"";
          }
        }
        if (output != ""String_Node_Str"") {
          sender.sendMessage(output);
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 3) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.USER)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else         if (plugin.accessAccount(args[1],(Player)sender,true)) {
          if (plugin.addUser(args[1],args[2])) {
            plugin.addTransaction(sendername,args[1],TransactionTypes.USER_ADD,0.00);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + args[2]+ ""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 3) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.USER)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else         if (plugin.accessAccount(args[1],(Player)sender,true)) {
          if (plugin.removeUser(args[1],args[2])) {
            plugin.addTransaction(sendername,args[1],TransactionTypes.USER_REMOVE,0.00);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + args[2]+ ""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 3) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.USER)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else         if (plugin.accessAccount(args[1],(Player)sender,true)) {
          if (plugin.addOwner(args[1],args[2])) {
            plugin.addTransaction(sendername,args[1],TransactionTypes.OWNER_ADD,0.00);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + args[2]+ ""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 3) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.USER)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else         if (plugin.accessAccount(args[1],(Player)sender,true)) {
          if (plugin.removeOwner(args[1],args[2])) {
            plugin.addTransaction(sendername,args[1],TransactionTypes.OWNER_REMOVE,0.00);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + args[2]+ ""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.PASSWORD)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else         if (plugin.accessAccount(args[1],(Player)sender,true)) {
          String password=""String_Node_Str"";
          if (args.length >= 3) {
            password=args[2];
          }
          password=plugin.PasswordSystem.passwordCrypt(password);
          if (!password.equalsIgnoreCase(""String_Node_Str"")) {
            if (plugin.setPassword(args[1],password)) {
              plugin.addTransaction(sendername,args[1],TransactionTypes.PASSWORD,0.00);
              sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + ""String_Node_Str"");
            }
 else {
              sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
            }
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 3) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.DEPOSIT)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else         if (plugin.accessAccount(args[1],(Player)sender,false) || plugin.settings.DepositAll) {
          if (Double.parseDouble(args[2]) <= 0.00) {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
            return true;
          }
          if (plugin.ATM(args[1],sendername,""String_Node_Str"",Double.parseDouble(args[2]),""String_Node_Str"")) {
            plugin.addTransaction(sendername,args[1],TransactionTypes.DEPOSIT,Double.parseDouble(args[2]));
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + plugin.Method.format(Double.parseDouble(args[2]))+ ""String_Node_Str""+ args[1]);
          }
 else {
            plugin.addTransaction(sendername,args[1],TransactionTypes.TRANSACTION_CANCELED,Double.parseDouble(args[2]));
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 3) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.WITHDRAW)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (plugin.accessAccount(args[1],(Player)sender,true)) {
          if (Double.parseDouble(args[2]) <= 0.00) {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
            return true;
          }
          String password=""String_Node_Str"";
          if (args.length >= 4) {
            password=args[3];
          }
          if (plugin.ATM(args[1],sendername,""String_Node_Str"",Double.parseDouble(args[2]),password)) {
            plugin.addTransaction(sendername,args[1],TransactionTypes.WITHDRAW,Double.parseDouble(args[2]));
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + plugin.Method.format(Double.parseDouble(args[2]))+ ""String_Node_Str""+ args[1]);
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 4) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.TRANSFER)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (plugin.accessAccount(args[1],(Player)sender,true)) {
          if (Double.parseDouble(args[3]) <= 0.00) {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
            return true;
          }
          if (plugin.accountExists(args[2])) {
            String password=""String_Node_Str"";
            if (args.length >= 5) {
              password=args[4];
            }
            if (plugin.ATM(args[1],args[2],""String_Node_Str"",Double.parseDouble(args[3]),password)) {
              plugin.addTransaction(sendername,args[1],TransactionTypes.TRANSFER_WITHDRAW,Double.parseDouble(args[3]));
              plugin.addTransaction(""String_Node_Str"",args[2],TransactionTypes.TRANSFER_DEPOSIT,Double.parseDouble(args[3]));
              sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + plugin.Method.format(Double.parseDouble(args[3]))+ ""String_Node_Str""+ args[1]+ ""String_Node_Str""+ args[2]);
            }
 else {
              plugin.addTransaction(sendername,args[1],TransactionTypes.TRANSACTION_CANCELED,Double.parseDouble(args[3]));
              sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
            }
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.LOAN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.LoanSystem.LoanActive) {
          sender.sendMessage(""String_Node_Str"");
        }
        if (!plugin.LoanSystem.haveLoan(sendername) && plugin.getSaved(sendername).getBounty() == 0.00) {
          plugin.addTransaction(sendername,null,TransactionTypes.LOAN_START,Double.parseDouble(args[1]));
          if (plugin.LoanSystem.addLoan(sendername,Double.parseDouble(args[1]))) {
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + plugin.Method.format(Double.parseDouble(args[1]))+ ""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else         if (plugin.getSaved(sendername).getBounty() > 0.00) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length == 1) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.LOAN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.LoanSystem.LoanActive) {
          sender.sendMessage(""String_Node_Str"");
        }
        if (plugin.LoanSystem.haveLoan(sendername)) {
          Loan playerLoan=plugin.LoanSystem.getLoan(sendername);
          sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + ""String_Node_Str"");
          sender.sendMessage(ChatColor.GOLD + ""String_Node_Str"" + ChatColor.WHITE+ plugin.Method.format(playerLoan.totalamount));
          sender.sendMessage(ChatColor.GOLD + ""String_Node_Str"" + ChatColor.WHITE+ plugin.Method.format(playerLoan.remaining));
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.LOAN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.LoanSystem.LoanActive) {
          sender.sendMessage(""String_Node_Str"");
        }
        if (plugin.LoanSystem.haveLoan(sendername)) {
          double paid=plugin.LoanSystem.payment(sendername,Double.parseDouble(args[1]));
          if (paid > 0.00) {
            plugin.addTransaction(sendername,null,TransactionTypes.LOAN_PAYMENT,paid);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + plugin.Method.format(paid)+ ""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.CLOSE)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (plugin.accessAccount(args[1],(Player)sender,true)) {
          String password=""String_Node_Str"";
          if (args.length >= 3) {
            password=args[2];
          }
          double money=plugin.getBalance(args[1]);
          if (plugin.closeAccount(args[1],sendername,password)) {
            if (money > 0) {
              plugin.addTransaction(sendername,args[1],TransactionTypes.WITHDRAW,money);
              sender.sendMessage(""String_Node_Str"" + plugin.Method.format(money) + ""String_Node_Str"");
            }
            plugin.addTransaction(sendername,args[1],TransactionTypes.CLOSE,0.00);
            sender.sendMessage(""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.ADMIN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
 else {
          UserSaves mySave=plugin.getSaved(sendername);
          if (mySave.isSelecting()) {
            mySave.isSelecting(false);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + ""String_Node_Str"");
          }
 else {
            mySave.isSelecting(true);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + ""String_Node_Str"");
          }
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.ADMIN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
 else {
          UserSaves mySave=plugin.getSaved(sendername);
          if (mySave.getPosition(1) != null && mySave.getPosition(2) != null) {
            if (plugin.setArea(args[1],mySave.getPosition(1),mySave.getPosition(2),((Player)sender).getWorld().getName())) {
              sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + ""String_Node_Str"");
            }
 else {
              sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
            }
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.ADMIN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
 else {
          if (plugin.removeArea(args[1])) {
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + ""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 1) {
        if (args.length >= 2) {
          showHelp(sender,Integer.parseInt(args[1]));
        }
 else {
          showHelp(sender,1);
        }
      }
 else {
        showHelp(sender,1);
      }
    }
 else {
      showHelp(sender,1);
    }
    return true;
  }
  return false;
}","public boolean onCommand(CommandSender sender,Command command,String label,String[] args){
  boolean isPlayer=(sender instanceof Player);
  if (!isPlayer) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  String sendername=((Player)sender).getName();
  if (label.equalsIgnoreCase(""String_Node_Str"")) {
    if (!plugin.playerPermission((Player)sender,PermissionNodes.ACCESS)) {
      sender.sendMessage(ChatColor.DARK_RED + ""String_Node_Str"");
      return true;
    }
    if (plugin.settings.Areas) {
      CommandList foundCommand=CommandList.valueOf(args[0].toUpperCase());
      if (foundCommand != null) {
        if (foundCommand.getRequireArea() && !plugin.inArea(((Player)sender).getWorld().getName(),((Player)sender).getLocation())) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
      }
    }
    if (args.length > 0) {
      if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.OPEN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (plugin.font.stringWidth(args[1]) > 150) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
        if (plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else {
          String players=""String_Node_Str"";
          players+=sendername;
          if (args.length >= 3) {
            for (int i=3; i <= args.length; i++) {
              players+=""String_Node_Str"" + args[i - 1];
            }
          }
          if (plugin.openAccount(args[1],players,sendername)) {
            plugin.addTransaction(sendername,args[1],TransactionTypes.OPEN,0.00);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + args[1]+ ""String_Node_Str"");
            players=""String_Node_Str"";
            players+=sendername;
            if (args.length >= 3) {
              for (int i=3; i <= args.length; i++) {
                players+=""String_Node_Str"" + args[i - 1];
              }
            }
            sender.sendMessage(ChatColor.WHITE + ""String_Node_Str"" + ChatColor.GREEN+ players);
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.OPEN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else {
          if (plugin.accessAccount(args[1],(Player)sender,false)) {
            sender.sendMessage(""String_Node_Str"" + args[1] + ""String_Node_Str""+ ChatColor.GREEN+ plugin.Method.format(plugin.getBalance(args[1])));
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.OPEN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else {
          if (plugin.accessAccount(args[1],(Player)sender,false)) {
            sender.sendMessage(""String_Node_Str"" + args[1] + ""String_Node_Str""+ ChatColor.GREEN+ plugin.Method.format(plugin.getBalance(args[1])));
            sender.sendMessage(ChatColor.WHITE + ""String_Node_Str"" + ChatColor.GREEN+ plugin.getOwners(args[1]));
            sender.sendMessage(ChatColor.WHITE + ""String_Node_Str"" + ChatColor.GREEN+ plugin.getUsers(args[1]));
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.LIST)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        List<String> accounts=plugin.accountList((Player)sender);
        if (accounts.size() > 0) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.BLUE + accounts.size()+ ChatColor.WHITE+ ""String_Node_Str""+ (accounts.size() == 1 ? ""String_Node_Str"" : ""String_Node_Str""));
        }
        int tmpWidth=0;
        String output=""String_Node_Str"";
        for (        String account : accounts) {
          if (tmpWidth == 0) {
            tmpWidth=plugin.font.stringWidth(account);
            output=account;
          }
 else {
            while (tmpWidth < 160) {
              output+=""String_Node_Str"";
              tmpWidth+=plugin.font.stringWidth(""String_Node_Str"");
            }
            output+=account;
            sender.sendMessage(output);
            tmpWidth=0;
            output=""String_Node_Str"";
          }
        }
        if (output != ""String_Node_Str"") {
          sender.sendMessage(output);
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 3) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.USER)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else         if (plugin.accessAccount(args[1],(Player)sender,true)) {
          if (plugin.addUser(args[1],args[2])) {
            plugin.addTransaction(sendername,args[1],TransactionTypes.USER_ADD,0.00);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + args[2]+ ""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 3) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.USER)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else         if (plugin.accessAccount(args[1],(Player)sender,true)) {
          if (plugin.removeUser(args[1],args[2])) {
            plugin.addTransaction(sendername,args[1],TransactionTypes.USER_REMOVE,0.00);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + args[2]+ ""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 3) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.USER)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else         if (plugin.accessAccount(args[1],(Player)sender,true)) {
          if (plugin.addOwner(args[1],args[2])) {
            plugin.addTransaction(sendername,args[1],TransactionTypes.OWNER_ADD,0.00);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + args[2]+ ""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 3) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.USER)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else         if (plugin.accessAccount(args[1],(Player)sender,true)) {
          if (plugin.removeOwner(args[1],args[2])) {
            plugin.addTransaction(sendername,args[1],TransactionTypes.OWNER_REMOVE,0.00);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + args[2]+ ""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.PASSWORD)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else         if (plugin.accessAccount(args[1],(Player)sender,true)) {
          String password=""String_Node_Str"";
          if (args.length >= 3) {
            password=args[2];
          }
          password=plugin.PasswordSystem.passwordCrypt(password);
          if (!password.equalsIgnoreCase(""String_Node_Str"")) {
            if (plugin.setPassword(args[1],password)) {
              plugin.addTransaction(sendername,args[1],TransactionTypes.PASSWORD,0.00);
              sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + ""String_Node_Str"");
            }
 else {
              sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
            }
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 3) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.DEPOSIT)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.accountExists(args[1])) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else         if (plugin.accessAccount(args[1],(Player)sender,false) || plugin.settings.DepositAll) {
          if (Double.parseDouble(args[2]) <= 0.00) {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
            return true;
          }
          if (plugin.ATM(args[1],sendername,""String_Node_Str"",Double.parseDouble(args[2]),""String_Node_Str"")) {
            plugin.addTransaction(sendername,args[1],TransactionTypes.DEPOSIT,Double.parseDouble(args[2]));
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + plugin.Method.format(Double.parseDouble(args[2]))+ ""String_Node_Str""+ args[1]);
          }
 else {
            plugin.addTransaction(sendername,args[1],TransactionTypes.TRANSACTION_CANCELED,Double.parseDouble(args[2]));
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 3) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.WITHDRAW)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (plugin.accessAccount(args[1],(Player)sender,true)) {
          if (Double.parseDouble(args[2]) <= 0.00) {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
            return true;
          }
          String password=""String_Node_Str"";
          if (args.length >= 4) {
            password=args[3];
          }
          if (plugin.ATM(args[1],sendername,""String_Node_Str"",Double.parseDouble(args[2]),password)) {
            plugin.addTransaction(sendername,args[1],TransactionTypes.WITHDRAW,Double.parseDouble(args[2]));
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + plugin.Method.format(Double.parseDouble(args[2]))+ ""String_Node_Str""+ args[1]);
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 4) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.TRANSFER)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (plugin.accessAccount(args[1],(Player)sender,true)) {
          if (Double.parseDouble(args[3]) <= 0.00) {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
            return true;
          }
          if (plugin.accountExists(args[2])) {
            String password=""String_Node_Str"";
            if (args.length >= 5) {
              password=args[4];
            }
            if (plugin.ATM(args[1],args[2],""String_Node_Str"",Double.parseDouble(args[3]),password)) {
              plugin.addTransaction(sendername,args[1],TransactionTypes.TRANSFER_WITHDRAW,Double.parseDouble(args[3]));
              plugin.addTransaction(""String_Node_Str"",args[2],TransactionTypes.TRANSFER_DEPOSIT,Double.parseDouble(args[3]));
              sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + plugin.Method.format(Double.parseDouble(args[3]))+ ""String_Node_Str""+ args[1]+ ""String_Node_Str""+ args[2]);
            }
 else {
              plugin.addTransaction(sendername,args[1],TransactionTypes.TRANSACTION_CANCELED,Double.parseDouble(args[3]));
              sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
            }
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.LOAN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.LoanSystem.LoanActive) {
          sender.sendMessage(""String_Node_Str"");
        }
        if (!plugin.LoanSystem.haveLoan(sendername) && plugin.getSaved(sendername).getBounty() == 0.00) {
          plugin.addTransaction(sendername,null,TransactionTypes.LOAN_START,Double.parseDouble(args[1]));
          if (plugin.LoanSystem.addLoan(sendername,Double.parseDouble(args[1]))) {
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + plugin.Method.format(Double.parseDouble(args[1]))+ ""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else         if (plugin.getSaved(sendername).getBounty() > 0.00) {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length == 1) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.LOAN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.LoanSystem.LoanActive) {
          sender.sendMessage(""String_Node_Str"");
        }
        if (plugin.LoanSystem.haveLoan(sendername)) {
          Loan playerLoan=plugin.LoanSystem.getLoan(sendername);
          sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + ""String_Node_Str"");
          sender.sendMessage(ChatColor.GOLD + ""String_Node_Str"" + ChatColor.WHITE+ plugin.Method.format(playerLoan.totalamount));
          sender.sendMessage(ChatColor.GOLD + ""String_Node_Str"" + ChatColor.WHITE+ plugin.Method.format(playerLoan.remaining));
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.LOAN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (!plugin.LoanSystem.LoanActive) {
          sender.sendMessage(""String_Node_Str"");
        }
        if (plugin.LoanSystem.haveLoan(sendername)) {
          double paid=plugin.LoanSystem.payment(sendername,Double.parseDouble(args[1]));
          if (paid > 0.00) {
            plugin.addTransaction(sendername,null,TransactionTypes.LOAN_PAYMENT,paid);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + plugin.Method.format(paid)+ ""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.CLOSE)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
        if (plugin.accessAccount(args[1],(Player)sender,true)) {
          String password=""String_Node_Str"";
          if (args.length >= 3) {
            password=args[2];
          }
          double money=plugin.getBalance(args[1]);
          if (plugin.closeAccount(args[1],sendername,password)) {
            if (money > 0) {
              plugin.addTransaction(sendername,args[1],TransactionTypes.WITHDRAW,money);
              sender.sendMessage(""String_Node_Str"" + plugin.Method.format(money) + ""String_Node_Str"");
            }
            plugin.addTransaction(sendername,args[1],TransactionTypes.CLOSE,0.00);
            sender.sendMessage(""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"");
          }
        }
 else {
          sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.ADMIN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
 else {
          UserSaves mySave=plugin.getSaved(sendername);
          if (mySave.isSelecting()) {
            mySave.isSelecting(false);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + ""String_Node_Str"");
          }
 else {
            mySave.isSelecting(true);
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + ""String_Node_Str"");
          }
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.ADMIN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
 else {
          UserSaves mySave=plugin.getSaved(sendername);
          if (mySave.getPosition(1) != null && mySave.getPosition(2) != null) {
            if (plugin.setArea(args[1],mySave.getPosition(1),mySave.getPosition(2),((Player)sender).getWorld().getName())) {
              sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + ""String_Node_Str"");
            }
 else {
              sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
            }
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 2) {
        if (!plugin.playerPermission((Player)sender,PermissionNodes.ADMIN)) {
          sender.sendMessage(""String_Node_Str"");
          return true;
        }
 else {
          if (plugin.removeArea(args[1])) {
            sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + ""String_Node_Str"");
          }
 else {
            sender.sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str"");
          }
        }
      }
 else       if (args[0].equalsIgnoreCase(""String_Node_Str"") && args.length >= 1) {
        if (args.length >= 2) {
          showHelp(sender,Integer.parseInt(args[1]));
        }
 else {
          showHelp(sender,1);
        }
      }
 else {
        showHelp(sender,1);
      }
    }
 else {
      showHelp(sender,1);
    }
    return true;
  }
  return false;
}",0.9936178794277444
5805,"@SuppressWarnings(""String_Node_Str"") boolean loadConfiguration(){
  config=new Configuration(new File(plugin.getDataFolder(),""String_Node_Str""));
  config.load();
  Transactions=config.getBoolean(""String_Node_Str"",false);
  UseMySQL=config.getBoolean(""String_Node_Str"",false);
  MySQL_host=config.getString(""String_Node_Str"",""String_Node_Str"");
  MySQL_port=config.getString(""String_Node_Str"",""String_Node_Str"");
  MySQL_username=config.getString(""String_Node_Str"",""String_Node_Str"");
  MySQL_password=config.getString(""String_Node_Str"",""String_Node_Str"");
  MySQL_database=config.getString(""String_Node_Str"",""String_Node_Str"");
  SQL_account_table=config.getString(""String_Node_Str"",""String_Node_Str"");
  SQL_area_table=config.getString(""String_Node_Str"",""String_Node_Str"");
  SQL_loan_table=config.getString(""String_Node_Str"",""String_Node_Str"");
  SQL_transaction_table=config.getString(""String_Node_Str"",""String_Node_Str"");
  SQL_banks_table=config.getString(""String_Node_Str"",""String_Node_Str"");
  UseOP=config.getBoolean(""String_Node_Str"",true);
  UsePermissions=config.getBoolean(""String_Node_Str"",false);
  UseGroupManager=config.getBoolean(""String_Node_Str"",false);
  SuperAdmins=config.getBoolean(""String_Node_Str"",false);
  DepositAll=config.getBoolean(""String_Node_Str"",false);
  interestAmount=config.getDouble(""String_Node_Str"",0);
  interestOfflineAmount=config.getDouble(""String_Node_Str"",0);
  interestTime=config.getInt(""String_Node_Str"",0);
  Areas=config.getBoolean(""String_Node_Str"",false);
  AreaWandId=config.getInt(""String_Node_Str"",339);
  plugin.LoanSystem.LoanActive=config.getBoolean(""String_Node_Str"",false);
  plugin.LoanSystem.Fixed_rate=config.getDouble(""String_Node_Str"",0);
  plugin.LoanSystem.Rates=(Map<Double,Double>)config.getProperty(""String_Node_Str"");
  plugin.LoanSystem.Max_amount=config.getDouble(""String_Node_Str"",200);
  plugin.LoanSystem.PaymentTime=config.getInt(""String_Node_Str"",60);
  plugin.LoanSystem.PaymentParts=config.getInt(""String_Node_Str"",3);
  Fee_Mode=stringToType(config.getString(""String_Node_Str"",""String_Node_Str""));
  Fee_Percentage=config.getDouble(""String_Node_Str"",0);
  Fee_Static=config.getDouble(""String_Node_Str"",0);
  StartAmount_Active=config.getBoolean(""String_Node_Str"",false);
  StartAmount_Fee=config.getDouble(""String_Node_Str"",0);
  StartAmount_Static=config.getDouble(""String_Node_Str"",0);
  MaxAmount=config.getDouble(""String_Node_Str"",0);
  Debug_Interest=config.getBoolean(""String_Node_Str"",true);
  Debug_Loan=config.getBoolean(""String_Node_Str"",true);
  plugin.console.info(""String_Node_Str"");
  try {
    if (UseMySQL) {
      Class.forName(""String_Node_Str"");
    }
 else {
      Class.forName(""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e2) {
    e2.printStackTrace();
  }
  try {
    if (UseMySQL) {
      con=DriverManager.getConnection(""String_Node_Str"" + MySQL_host + ""String_Node_Str""+ MySQL_port+ ""String_Node_Str""+ MySQL_database,MySQL_username,MySQL_password);
    }
 else {
      con=DriverManager.getConnection(""String_Node_Str"" + plugin.myFolder.getAbsolutePath() + ""String_Node_Str"");
    }
    try {
      if (UseMySQL) {
        stmt=con.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);
        plugin.console.info(""String_Node_Str"");
      }
 else {
        stmt=con.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY);
        plugin.console.info(""String_Node_Str"");
      }
      boolean checkAccount=false;
      boolean checkArea=false;
      boolean checkLoan=false;
      boolean checkTransaction=false;
      try {
        ResultSet tables=con.getMetaData().getTables(null,null,null,null);
        while (tables.next()) {
          String tablename=tables.getString(""String_Node_Str"");
          if (tablename.equalsIgnoreCase(SQL_account_table)) {
            checkAccount=true;
          }
 else           if (tablename.equalsIgnoreCase(SQL_area_table)) {
            checkArea=true;
          }
 else           if (tablename.equalsIgnoreCase(SQL_loan_table)) {
            checkLoan=true;
          }
 else           if (tablename.equalsIgnoreCase(SQL_transaction_table)) {
            checkTransaction=true;
          }
 else           if (tablename.equalsIgnoreCase(SQL_banks_table)) {
          }
        }
      }
 catch (      SQLException e3) {
        plugin.console.warning(""String_Node_Str"");
        plugin.console.warning(e3.toString());
      }
      try {
        if (!checkAccount) {
          String query=""String_Node_Str"" + SQL_account_table + ""String_Node_Str"";
          if (UseMySQL) {
            plugin.console.warning(""String_Node_Str"" + SQL_account_table);
            query=""String_Node_Str"" + SQL_account_table + ""String_Node_Str"";
          }
          stmt.execute(query);
        }
        if (!checkArea && Areas) {
          String query=""String_Node_Str"" + SQL_area_table + ""String_Node_Str"";
          if (UseMySQL) {
            plugin.console.warning(""String_Node_Str"" + SQL_area_table);
            query=""String_Node_Str"" + SQL_area_table + ""String_Node_Str"";
          }
          stmt.execute(query);
        }
        if (!checkLoan && plugin.LoanSystem.LoanActive) {
          String query=""String_Node_Str"" + SQL_loan_table + ""String_Node_Str"";
          if (UseMySQL) {
            plugin.console.warning(""String_Node_Str"" + SQL_loan_table);
            query=""String_Node_Str"" + SQL_loan_table + ""String_Node_Str"";
          }
          stmt.execute(query);
        }
        if (!checkTransaction && Transactions) {
          String query=""String_Node_Str"" + SQL_transaction_table + ""String_Node_Str"";
          if (UseMySQL) {
            plugin.console.warning(""String_Node_Str"" + SQL_transaction_table);
            query=""String_Node_Str"" + SQL_transaction_table + ""String_Node_Str"";
          }
          stmt.execute(query);
        }
        new Upgrade(plugin,UseMySQL);
      }
 catch (      SQLException e3) {
        if (!checkAccount) {
          plugin.console.warning(""String_Node_Str"" + SQL_account_table);
        }
        if (!checkArea && Areas) {
          plugin.console.warning(""String_Node_Str"" + SQL_area_table);
          plugin.console.info(""String_Node_Str"");
          Areas=false;
        }
        if (!checkLoan && plugin.LoanSystem.LoanActive) {
          plugin.console.warning(""String_Node_Str"" + SQL_loan_table);
          plugin.console.info(""String_Node_Str"");
          plugin.LoanSystem.LoanActive=false;
          if (plugin.LoanSystem.running) {
            plugin.LoanSystem.shutdownRunner();
          }
        }
        if (!checkTransaction && Transactions) {
          plugin.console.warning(""String_Node_Str"" + SQL_transaction_table);
          plugin.console.info(""String_Node_Str"");
          Transactions=false;
        }
        plugin.console.warning(e3.toString());
        plugin.console.info(""String_Node_Str"");
        plugin.getServer().getPluginManager().disablePlugin(plugin);
        return false;
      }
    }
 catch (    SQLException e2) {
      if (UseMySQL) {
        plugin.console.warning(""String_Node_Str"");
      }
 else {
        plugin.console.warning(""String_Node_Str"");
      }
      plugin.console.warning(e2.toString());
      plugin.console.info(""String_Node_Str"");
      plugin.getServer().getPluginManager().disablePlugin(plugin);
      return false;
    }
  }
 catch (  SQLException e1) {
    if (UseMySQL) {
      plugin.console.warning(""String_Node_Str"");
    }
 else {
      plugin.console.warning(""String_Node_Str"");
    }
    plugin.console.warning(e1.toString());
    plugin.console.info(""String_Node_Str"");
    plugin.getServer().getPluginManager().disablePlugin(plugin);
    return false;
  }
  return true;
}","@SuppressWarnings(""String_Node_Str"") boolean loadConfiguration(){
  config=new Configuration(new File(plugin.getDataFolder(),""String_Node_Str""));
  config.load();
  Transactions=config.getBoolean(""String_Node_Str"",false);
  UseMySQL=config.getBoolean(""String_Node_Str"",false);
  MySQL_host=config.getString(""String_Node_Str"",""String_Node_Str"");
  MySQL_port=config.getString(""String_Node_Str"",""String_Node_Str"");
  MySQL_username=config.getString(""String_Node_Str"",""String_Node_Str"");
  MySQL_password=config.getString(""String_Node_Str"",""String_Node_Str"");
  MySQL_database=config.getString(""String_Node_Str"",""String_Node_Str"");
  SQL_account_table=config.getString(""String_Node_Str"",""String_Node_Str"");
  SQL_area_table=config.getString(""String_Node_Str"",""String_Node_Str"");
  SQL_loan_table=config.getString(""String_Node_Str"",""String_Node_Str"");
  SQL_transaction_table=config.getString(""String_Node_Str"",""String_Node_Str"");
  SQL_banks_table=config.getString(""String_Node_Str"",""String_Node_Str"");
  UseOP=config.getBoolean(""String_Node_Str"",true);
  UsePermissions=config.getBoolean(""String_Node_Str"",false);
  UseGroupManager=config.getBoolean(""String_Node_Str"",false);
  SuperAdmins=config.getBoolean(""String_Node_Str"",false);
  DepositAll=config.getBoolean(""String_Node_Str"",false);
  interestAmount=config.getDouble(""String_Node_Str"",0);
  interestOfflineAmount=config.getDouble(""String_Node_Str"",0);
  interestTime=config.getInt(""String_Node_Str"",0);
  Areas=config.getBoolean(""String_Node_Str"",false);
  AreaWandId=config.getInt(""String_Node_Str"",339);
  plugin.LoanSystem.LoanActive=config.getBoolean(""String_Node_Str"",false);
  plugin.LoanSystem.Fixed_rate=config.getDouble(""String_Node_Str"",0);
  plugin.LoanSystem.Rates=(Map<Double,Double>)config.getProperty(""String_Node_Str"");
  plugin.LoanSystem.Max_amount=config.getDouble(""String_Node_Str"",200);
  plugin.LoanSystem.PaymentTime=config.getInt(""String_Node_Str"",60);
  plugin.LoanSystem.PaymentParts=config.getInt(""String_Node_Str"",3);
  Fee_Mode=stringToType(config.getString(""String_Node_Str"",""String_Node_Str""));
  Fee_Percentage=config.getDouble(""String_Node_Str"",0);
  Fee_Static=config.getDouble(""String_Node_Str"",0);
  StartAmount_Active=config.getBoolean(""String_Node_Str"",false);
  StartAmount_Fee=config.getDouble(""String_Node_Str"",0);
  StartAmount_Static=config.getDouble(""String_Node_Str"",0);
  MaxAmount=config.getDouble(""String_Node_Str"",0);
  Debug_Interest=config.getBoolean(""String_Node_Str"",true);
  Debug_Loan=config.getBoolean(""String_Node_Str"",true);
  plugin.console.info(""String_Node_Str"");
  try {
    if (UseMySQL) {
      Class.forName(""String_Node_Str"");
    }
 else {
      Class.forName(""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e2) {
    e2.printStackTrace();
  }
  try {
    if (UseMySQL) {
      con=DriverManager.getConnection(""String_Node_Str"" + MySQL_host + ""String_Node_Str""+ MySQL_port+ ""String_Node_Str""+ MySQL_database,MySQL_username,MySQL_password);
    }
 else {
      con=DriverManager.getConnection(""String_Node_Str"" + plugin.myFolder.getAbsolutePath() + ""String_Node_Str"");
    }
    try {
      if (UseMySQL) {
        selectStmt=con.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);
        updateStmt=con.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);
        stmt=con.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);
        plugin.console.info(""String_Node_Str"");
      }
 else {
        selectStmt=con.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY);
        updateStmt=con.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY);
        stmt=con.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY);
        plugin.console.info(""String_Node_Str"");
      }
      boolean checkAccount=false;
      boolean checkArea=false;
      boolean checkLoan=false;
      boolean checkTransaction=false;
      try {
        ResultSet tables=con.getMetaData().getTables(null,null,null,null);
        while (tables.next()) {
          String tablename=tables.getString(""String_Node_Str"");
          if (tablename.equalsIgnoreCase(SQL_account_table)) {
            checkAccount=true;
          }
 else           if (tablename.equalsIgnoreCase(SQL_area_table)) {
            checkArea=true;
          }
 else           if (tablename.equalsIgnoreCase(SQL_loan_table)) {
            checkLoan=true;
          }
 else           if (tablename.equalsIgnoreCase(SQL_transaction_table)) {
            checkTransaction=true;
          }
 else           if (tablename.equalsIgnoreCase(SQL_banks_table)) {
          }
        }
      }
 catch (      SQLException e3) {
        plugin.console.warning(""String_Node_Str"");
        plugin.console.warning(e3.toString());
      }
      try {
        if (!checkAccount) {
          String query=""String_Node_Str"" + SQL_account_table + ""String_Node_Str"";
          if (UseMySQL) {
            plugin.console.warning(""String_Node_Str"" + SQL_account_table);
            query=""String_Node_Str"" + SQL_account_table + ""String_Node_Str"";
          }
          stmt.execute(query);
        }
        if (!checkArea && Areas) {
          String query=""String_Node_Str"" + SQL_area_table + ""String_Node_Str"";
          if (UseMySQL) {
            plugin.console.warning(""String_Node_Str"" + SQL_area_table);
            query=""String_Node_Str"" + SQL_area_table + ""String_Node_Str"";
          }
          stmt.execute(query);
        }
        if (!checkLoan && plugin.LoanSystem.LoanActive) {
          String query=""String_Node_Str"" + SQL_loan_table + ""String_Node_Str"";
          if (UseMySQL) {
            plugin.console.warning(""String_Node_Str"" + SQL_loan_table);
            query=""String_Node_Str"" + SQL_loan_table + ""String_Node_Str"";
          }
          stmt.execute(query);
        }
        if (!checkTransaction && Transactions) {
          String query=""String_Node_Str"" + SQL_transaction_table + ""String_Node_Str"";
          if (UseMySQL) {
            plugin.console.warning(""String_Node_Str"" + SQL_transaction_table);
            query=""String_Node_Str"" + SQL_transaction_table + ""String_Node_Str"";
          }
          stmt.execute(query);
        }
        new Upgrade(plugin,UseMySQL);
      }
 catch (      SQLException e3) {
        if (!checkAccount) {
          plugin.console.warning(""String_Node_Str"" + SQL_account_table);
        }
        if (!checkArea && Areas) {
          plugin.console.warning(""String_Node_Str"" + SQL_area_table);
          plugin.console.info(""String_Node_Str"");
          Areas=false;
        }
        if (!checkLoan && plugin.LoanSystem.LoanActive) {
          plugin.console.warning(""String_Node_Str"" + SQL_loan_table);
          plugin.console.info(""String_Node_Str"");
          plugin.LoanSystem.LoanActive=false;
          if (plugin.LoanSystem.running) {
            plugin.LoanSystem.shutdownRunner();
          }
        }
        if (!checkTransaction && Transactions) {
          plugin.console.warning(""String_Node_Str"" + SQL_transaction_table);
          plugin.console.info(""String_Node_Str"");
          Transactions=false;
        }
        plugin.console.warning(e3.toString());
        plugin.console.info(""String_Node_Str"");
        plugin.getServer().getPluginManager().disablePlugin(plugin);
        return false;
      }
    }
 catch (    SQLException e2) {
      if (UseMySQL) {
        plugin.console.warning(""String_Node_Str"");
      }
 else {
        plugin.console.warning(""String_Node_Str"");
      }
      plugin.console.warning(e2.toString());
      plugin.console.info(""String_Node_Str"");
      plugin.getServer().getPluginManager().disablePlugin(plugin);
      return false;
    }
  }
 catch (  SQLException e1) {
    if (UseMySQL) {
      plugin.console.warning(""String_Node_Str"");
    }
 else {
      plugin.console.warning(""String_Node_Str"");
    }
    plugin.console.warning(e1.toString());
    plugin.console.info(""String_Node_Str"");
    plugin.getServer().getPluginManager().disablePlugin(plugin);
    return false;
  }
  return true;
}",0.967644084934277
5806,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void removeEntity(String name,final Player player,JavaPlugin plugin){
  server.getServer().getScheduler().callSyncMethod(plugin,new Callable(){
    public Object call() throws Exception {
      Location loc=player.getLocation();
      CraftWorld craftWorld=(CraftWorld)player.getWorld();
      CraftPlayer craftPlayer=(CraftPlayer)player;
      double x=loc.getX() + 0.5;
      double y=loc.getY() + 0.5;
      double z=loc.getZ() + 0.5;
      double radius=10;
      List<Entity> entities=new ArrayList();
      AxisAlignedBB bb=AxisAlignedBB.a(x - radius,y - radius,z - radius,x + radius,y + radius,z + radius);
      entities=craftWorld.getHandle().b(craftPlayer.getHandle(),bb);
      for (      Entity o : entities) {
        if (!(o instanceof EntityPlayer)) {
          o.getBukkitEntity().remove();
        }
      }
      return null;
    }
  }
);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void removeEntity(String name,final Player player,BankAccount plugin){
  server.getServer().getScheduler().callSyncMethod(plugin,new Callable(){
    public Object call() throws Exception {
      Location loc=player.getLocation();
      CraftWorld craftWorld=(CraftWorld)player.getWorld();
      CraftPlayer craftPlayer=(CraftPlayer)player;
      double x=loc.getX() + 0.5;
      double y=loc.getY() + 0.5;
      double z=loc.getZ() + 0.5;
      double radius=10;
      List<Entity> entities=new ArrayList();
      AxisAlignedBB bb=AxisAlignedBB.a(x - radius,y - radius,z - radius,x + radius,y + radius,z + radius);
      entities=craftWorld.getHandle().b(craftPlayer.getHandle(),bb);
      for (      Entity o : entities) {
        if (!(o instanceof EntityPlayer)) {
          o.getBukkitEntity().remove();
        }
      }
      return null;
    }
  }
);
}",0.9886178861788618
5807,"public void onEnable(){
  getDataFolder().mkdir();
  getCommand(""String_Node_Str"").setExecutor(cmdExecutor);
  getCommand(""String_Node_Str"").setUsage(""String_Node_Str"");
  PlayerListener rightClickListener=new PlayerListener(){
    @Override public void onPlayerInteract(    PlayerInteractEvent event){
      if (event.getAction() == Action.RIGHT_CLICK_BLOCK) {
        UserSaves mySave=getSaved(event.getPlayer().getName());
        if (event.getPlayer().getItemInHand().getTypeId() == AreaWandId && mySave.isSelecting()) {
          Location pos=event.getClickedBlock().getLocation();
          if (mySave.setPosition(pos) == 2) {
            event.getPlayer().sendMessage(""String_Node_Str"");
          }
 else {
            event.getPlayer().sendMessage(""String_Node_Str"");
          }
        }
      }
    }
  }
;
  EntityListener entityListener=new EntityListener(){
    public void onEntityDamageByEntity(    EntityDamageByEntityEvent event){
      Entity attacker=event.getDamager();
      Entity defender=event.getEntity();
      if (defender instanceof Player) {
        Player player=(Player)defender;
        if (player.getHealth() - event.getDamage() <= 0) {
          if (attacker != null && attacker instanceof Player) {
            double bounty=getSaved(((Player)attacker).getName()).getBounty();
            if (bounty > 0.00) {
              Account attackerAccount=com.nijiko.coelho.iConomy.iConomy.getBank().getAccount(((Player)attacker).getName());
              attackerAccount.add(bounty);
              getSaved(((Player)attacker).getName()).setBounty(0.00);
            }
          }
        }
      }
    }
    public void onEntityDamageByProjectile(    EntityDamageByProjectileEvent event){
      Entity defender=event.getEntity();
      Entity attacker=event.getDamager();
      if (defender instanceof Player) {
        Player player=(Player)defender;
        if (player.getHealth() - event.getDamage() <= 0) {
          if (attacker != null && attacker instanceof Player) {
            double bounty=getSaved(((Player)attacker).getName()).getBounty();
            if (bounty > 0.00) {
              Account attackerAccount=com.nijiko.coelho.iConomy.iConomy.getBank().getAccount(((Player)attacker).getName());
              attackerAccount.add(bounty);
              getSaved(((Player)attacker).getName()).setBounty(0.00);
            }
          }
        }
      }
    }
    @Override public void onEntityDamage(    EntityDamageEvent event){
      if (event instanceof EntityDamageByProjectileEvent) {
        this.onEntityDamageByProjectile((EntityDamageByProjectileEvent)event);
        return;
      }
 else       if (event instanceof EntityDamageByEntityEvent) {
        this.onEntityDamageByEntity((EntityDamageByEntityEvent)event);
        return;
      }
    }
  }
;
  ServerListener pluginListener=new ServerListener(){
    Plugin checkPlugin(    String pluginname){
      return getServer().getPluginManager().getPlugin(pluginname);
    }
    @Override public void onPluginEnable(    PluginEnableEvent event){
      String plugin=event.getPlugin().getDescription().getName();
      if (iConomy == null && plugin.equalsIgnoreCase(""String_Node_Str"")) {
        Plugin test=checkPlugin(""String_Node_Str"");
        if (test != null) {
          iConomy=(iConomy)test;
          foundiConomy();
        }
      }
      if (Permissions == null && plugin.equalsIgnoreCase(""String_Node_Str"") && UsePermissions) {
        Plugin test=checkPlugin(""String_Node_Str"");
        if (test != null) {
          ((Permissions)test).getDatabase();
          Permissions=((Permissions)test).getHandler();
          consoleInfo(""String_Node_Str"" + plugin + ""String_Node_Str"");
        }
      }
      if (GroupManager == null && plugin.equalsIgnoreCase(""String_Node_Str"") && UseGroupManager) {
        Plugin test=checkPlugin(""String_Node_Str"");
        if (test != null) {
          GroupManager=(GroupManager)test;
          consoleInfo(""String_Node_Str"" + plugin + ""String_Node_Str"");
          if (checkJobId > 0) {
            getServer().getScheduler().cancelTask(checkJobId);
          }
        }
      }
    }
    @Override public void onPluginDisable(    PluginDisableEvent event){
      String plugin=event.getPlugin().getDescription().getName();
      if (iConomy != null && plugin.equalsIgnoreCase(""String_Node_Str"")) {
        iConomy=null;
        if (LoanSystem.LoanActive && LoanSystem.running) {
          LoanSystem.shutdownRunner();
        }
        consoleWarning(""String_Node_Str"" + plugin + ""String_Node_Str"");
        consoleWarning(""String_Node_Str"");
        getServer().getPluginManager().disablePlugin(thisPlugin);
      }
      if (Permissions != null && plugin.equalsIgnoreCase(""String_Node_Str"")) {
        Permissions=null;
        consoleWarning(""String_Node_Str"" + plugin + ""String_Node_Str"");
      }
      if (GroupManager != null && plugin.equalsIgnoreCase(""String_Node_Str"")) {
        GroupManager=null;
        consoleWarning(""String_Node_Str"" + plugin + ""String_Node_Str"");
      }
    }
  }
;
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Type.PLAYER_INTERACT,rightClickListener,Priority.Normal,this);
  pm.registerEvent(Type.ENTITY_DAMAGE,entityListener,Priority.Normal,this);
  pm.registerEvent(Type.PLUGIN_ENABLE,pluginListener,Priority.Low,this);
  pm.registerEvent(Type.PLUGIN_DISABLE,pluginListener,Priority.Low,this);
  pdfFile=this.getDescription();
  log.info(pdfFile.getName() + ""String_Node_Str"" + pdfFile.getVersion()+ ""String_Node_Str"");
  myFolder=getDataFolder();
  if (!myFolder.exists()) {
    consoleInfo(""String_Node_Str"");
    myFolder.mkdir();
    consoleInfo(""String_Node_Str"");
  }
  checkJobId=this.getServer().getScheduler().scheduleSyncDelayedTask(thisPlugin,new Runnable(){
    public void run(){
      if (iConomy == null) {
        consoleWarning(""String_Node_Str"");
        getServer().getPluginManager().disablePlugin(thisPlugin);
        checkJobId=0;
      }
    }
  }
,20 * 60);
  createDefaultConfiguration();
  loadConfiguration();
  loadFontWidth();
  if (iConomy == null) {
    Plugin test=getServer().getPluginManager().getPlugin(""String_Node_Str"");
    if (test != null) {
      if (test.isEnabled()) {
        iConomy=(iConomy)test;
        foundiConomy();
      }
    }
  }
  if (Permissions == null && UsePermissions) {
    Plugin test=getServer().getPluginManager().getPlugin(""String_Node_Str"");
    if (test != null) {
      if (test.isEnabled()) {
        Permissions=((Permissions)test).getHandler();
        consoleInfo(""String_Node_Str"");
      }
    }
  }
  if (GroupManager == null && UseGroupManager) {
    Plugin test=getServer().getPluginManager().getPlugin(""String_Node_Str"");
    if (test != null) {
      if (test.isEnabled()) {
        GroupManager=(GroupManager)test;
        consoleInfo(""String_Node_Str"");
      }
    }
  }
}","public void onEnable(){
  getDataFolder().mkdir();
  getCommand(""String_Node_Str"").setExecutor(cmdExecutor);
  getCommand(""String_Node_Str"").setUsage(""String_Node_Str"");
  PlayerListener rightClickListener=new PlayerListener(){
    @Override public void onPlayerInteract(    PlayerInteractEvent event){
      if (event.getAction() == Action.RIGHT_CLICK_BLOCK) {
        UserSaves mySave=getSaved(event.getPlayer().getName());
        if (event.getPlayer().getItemInHand().getTypeId() == AreaWandId && mySave.isSelecting()) {
          Location pos=event.getClickedBlock().getLocation();
          if (mySave.setPosition(pos) == 2) {
            event.getPlayer().sendMessage(""String_Node_Str"");
          }
 else {
            event.getPlayer().sendMessage(""String_Node_Str"");
          }
        }
      }
    }
  }
;
  EntityListener entityListener=new EntityListener(){
    public void onEntityDamageByEntity(    EntityDamageByEntityEvent event){
      Entity attacker=event.getDamager();
      Entity defender=event.getEntity();
      if (defender instanceof Player) {
        Player player=(Player)defender;
        if (player.getHealth() - event.getDamage() <= 0) {
          if (attacker != null && attacker instanceof Player) {
            double bounty=getSaved(((Player)attacker).getName()).getBounty();
            if (bounty > 0.00) {
              Account attackerAccount=com.nijiko.coelho.iConomy.iConomy.getBank().getAccount(((Player)attacker).getName());
              attackerAccount.add(bounty);
              getSaved(((Player)attacker).getName()).setBounty(0.00);
            }
          }
        }
      }
    }
    public void onEntityDamageByProjectile(    EntityDamageByProjectileEvent event){
      Entity defender=event.getEntity();
      Entity attacker=event.getDamager();
      if (defender instanceof Player) {
        Player player=(Player)defender;
        if (player.getHealth() - event.getDamage() <= 0) {
          if (attacker != null && attacker instanceof Player) {
            double bounty=getSaved(((Player)attacker).getName()).getBounty();
            if (bounty > 0.00) {
              Account attackerAccount=com.nijiko.coelho.iConomy.iConomy.getBank().getAccount(((Player)attacker).getName());
              attackerAccount.add(bounty);
              getSaved(((Player)attacker).getName()).setBounty(0.00);
            }
          }
        }
      }
    }
    @Override public void onEntityDamage(    EntityDamageEvent event){
      if (event instanceof EntityDamageByProjectileEvent) {
        this.onEntityDamageByProjectile((EntityDamageByProjectileEvent)event);
        return;
      }
 else       if (event instanceof EntityDamageByEntityEvent) {
        this.onEntityDamageByEntity((EntityDamageByEntityEvent)event);
        return;
      }
    }
  }
;
  ServerListener pluginListener=new ServerListener(){
    Plugin checkPlugin(    String pluginname){
      return getServer().getPluginManager().getPlugin(pluginname);
    }
    @Override public void onPluginEnable(    PluginEnableEvent event){
      String plugin=event.getPlugin().getDescription().getName();
      if (iConomy == null && plugin.equalsIgnoreCase(""String_Node_Str"")) {
        Plugin test=checkPlugin(""String_Node_Str"");
        if (test != null) {
          iConomy=(iConomy)test;
          foundiConomy();
        }
      }
      if (Permissions == null && plugin.equalsIgnoreCase(""String_Node_Str"") && UsePermissions) {
        Plugin test=checkPlugin(""String_Node_Str"");
        if (test != null) {
          ((Permissions)test).getDatabase();
          Permissions=((Permissions)test).getHandler();
          consoleInfo(""String_Node_Str"" + plugin + ""String_Node_Str"");
        }
      }
      if (GroupManager == null && plugin.equalsIgnoreCase(""String_Node_Str"") && UseGroupManager) {
        Plugin test=checkPlugin(""String_Node_Str"");
        if (test != null) {
          GroupManager=(GroupManager)test;
          consoleInfo(""String_Node_Str"" + plugin + ""String_Node_Str"");
          if (checkJobId > 0) {
            getServer().getScheduler().cancelTask(checkJobId);
          }
        }
      }
    }
    @Override public void onPluginDisable(    PluginDisableEvent event){
      String plugin=event.getPlugin().getDescription().getName();
      if (iConomy != null && plugin.equalsIgnoreCase(""String_Node_Str"")) {
        iConomy=null;
        if (LoanSystem.LoanActive && LoanSystem.running) {
          LoanSystem.shutdownRunner();
        }
        consoleWarning(""String_Node_Str"" + plugin + ""String_Node_Str"");
        consoleWarning(""String_Node_Str"");
        getServer().getPluginManager().disablePlugin(thisPlugin);
      }
      if (Permissions != null && plugin.equalsIgnoreCase(""String_Node_Str"")) {
        Permissions=null;
        consoleWarning(""String_Node_Str"" + plugin + ""String_Node_Str"");
      }
      if (GroupManager != null && plugin.equalsIgnoreCase(""String_Node_Str"")) {
        GroupManager=null;
        consoleWarning(""String_Node_Str"" + plugin + ""String_Node_Str"");
      }
    }
  }
;
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Type.PLAYER_INTERACT,rightClickListener,Priority.Normal,this);
  pm.registerEvent(Type.ENTITY_DAMAGE,entityListener,Priority.Normal,this);
  pm.registerEvent(Type.PLUGIN_ENABLE,pluginListener,Priority.Low,this);
  pm.registerEvent(Type.PLUGIN_DISABLE,pluginListener,Priority.Low,this);
  pdfFile=this.getDescription();
  log.info(pdfFile.getName() + ""String_Node_Str"" + pdfFile.getVersion()+ ""String_Node_Str"");
  myFolder=getDataFolder();
  if (!myFolder.exists()) {
    consoleInfo(""String_Node_Str"");
    myFolder.mkdir();
    consoleInfo(""String_Node_Str"");
  }
  checkJobId=this.getServer().getScheduler().scheduleSyncDelayedTask(thisPlugin,new Runnable(){
    public void run(){
      if (iConomy == null) {
        consoleWarning(""String_Node_Str"");
        getServer().getPluginManager().disablePlugin(thisPlugin);
        checkJobId=0;
      }
    }
  }
,20 * 20);
  createDefaultConfiguration();
  loadConfiguration();
  loadFontWidth();
  if (iConomy == null) {
    Plugin test=getServer().getPluginManager().getPlugin(""String_Node_Str"");
    if (test != null) {
      if (test.isEnabled()) {
        iConomy=(iConomy)test;
        foundiConomy();
      }
    }
  }
  if (Permissions == null && UsePermissions) {
    Plugin test=getServer().getPluginManager().getPlugin(""String_Node_Str"");
    if (test != null) {
      if (test.isEnabled()) {
        Permissions=((Permissions)test).getHandler();
        consoleInfo(""String_Node_Str"");
      }
    }
  }
  if (GroupManager == null && UseGroupManager) {
    Plugin test=getServer().getPluginManager().getPlugin(""String_Node_Str"");
    if (test != null) {
      if (test.isEnabled()) {
        GroupManager=(GroupManager)test;
        consoleInfo(""String_Node_Str"");
      }
    }
  }
}",0.9998545242944428
5808,"boolean checkPermission(Player player,PermissionNodes node,boolean extraLookup){
  if (player != null) {
    if (UsePermissions) {
      if (Permissions.has(player,node.getNode())) {
        return true;
      }
    }
    if (UseGroupManager) {
      if (GroupManager.getWorldsHolder().getWorldPermissions(player).has(player,node.getNode())) {
        return true;
      }
    }
    if (UseOP) {
      if (player.isOp()) {
        return true;
      }
    }
    if (node != PermissionNodes.ACCESS && !extraLookup) {
      if (node != PermissionNodes.ADMIN) {
        if (checkPermission(player,PermissionNodes.ADMIN,true)) {
          return true;
        }
      }
      if (node != PermissionNodes.EXTENDED) {
        if (checkPermission(player,PermissionNodes.EXTENDED,true)) {
          return true;
        }
      }
      if (node == PermissionNodes.OPEN || node == PermissionNodes.DEPOSIT || node == PermissionNodes.WITHDRAW) {
        if (checkPermission(player,PermissionNodes.BASIC,true))         return true;
      }
    }
  }
  return false;
}","private boolean checkPermission(Player player,PermissionNodes node,boolean extraLookup){
  if (player != null) {
    if (UsePermissions) {
      if (Permissions.has(player,node.getNode())) {
        return true;
      }
    }
    if (UseGroupManager) {
      if (GroupManager.getWorldsHolder().getWorldPermissions(player).has(player,node.getNode())) {
        return true;
      }
    }
    if (UseOP) {
      if (player.isOp()) {
        return true;
      }
    }
    if (node != PermissionNodes.ACCESS && !extraLookup) {
      if (node != PermissionNodes.ADMIN) {
        if (checkPermission(player,PermissionNodes.ADMIN,true)) {
          return true;
        }
      }
      if (node != PermissionNodes.EXTENDED) {
        if (checkPermission(player,PermissionNodes.EXTENDED,true)) {
          return true;
        }
      }
      if (node == PermissionNodes.OPEN || node == PermissionNodes.DEPOSIT || node == PermissionNodes.WITHDRAW) {
        if (checkPermission(player,PermissionNodes.BASIC,true))         return true;
      }
    }
  }
  return false;
}",0.996222851746931
5809,"/** 
 * Check for a permission
 * @param player - The player
 * @param node - The PermissionNode (dk.earthgame.TAT.BankAccount.System.PermissionNodes)
 * @return boolean - If the player have the permission
 */
public boolean playerPermission(Player player,PermissionNodes node){
  return checkPermission(player,node,false);
}","/** 
 * Check for a permission
 * @param player - The player
 * @param node - The PermissionNode (dk.earthgame.TAT.BankAccount.System.PermissionNodes)
 * @since 0.5
 * @return boolean - If the player have the permission
 */
public boolean playerPermission(Player player,PermissionNodes node){
  return checkPermission(player,node,false);
}",0.9789156626506024
5810,"public int dy(){
  return pieceMove.piece.dx(pieceMove.move.rotation);
}","public int dy(){
  return pieceMove.piece.dy(pieceMove.move.rotation);
}",0.9861111111111112
5811,"/** 
 * @param fromMovement the position and orientation we are coming from
 * @param movement position and orientation of current piece
 * @param startDrop true if the action ""drop piece"" has started
 */
private void calculateValidMoves(Movement fromMovement,Movement movement,boolean startDrop){
  while (visitedPieceMoves.isUnvisited(movement) && movement.isPieceInsideBoard()) {
    markAsVisited(fromMovement,movement);
    if (isSlidingOn || !startDrop) {
      calculateValidMoves(movement,movement.rotate(rotationDirection,visitedPieceMoves),startDrop);
      calculateValidMoves(movement,movement.left(visitedPieceMoves),startDrop);
      calculateValidMoves(movement,movement.right(visitedPieceMoves),startDrop);
    }
    if (!isSlidingOn && !startDrop) {
      startDrop=movement.canRotate(rotationDirection,visitedPieceMoves);
    }
    calculateValidMoves(movement,movement.down(visitedPieceMoves),startDrop);
  }
}","/** 
 * Calculate all valid moves on an empty board recursively.
 * @param fromMovement the position and orientation we are coming from
 * @param movement position and orientation of current piece
 * @param startDrop true if the action ""drop piece"" has started
 */
private void calculateValidMoves(Movement fromMovement,Movement movement,boolean startDrop){
  while (visitedPieceMoves.isUnvisited(movement) && movement.isPieceInsideBoard()) {
    markAsVisited(fromMovement,movement);
    if (isSlidingOn || !startDrop) {
      calculateValidMoves(movement,movement.rotate(rotationDirection,visitedPieceMoves),startDrop);
      calculateValidMoves(movement,movement.left(visitedPieceMoves),startDrop);
      calculateValidMoves(movement,movement.right(visitedPieceMoves),startDrop);
    }
    if (!isSlidingOn && !startDrop) {
      startDrop=movement.canRotate(rotationDirection,visitedPieceMoves);
    }
    calculateValidMoves(movement,movement.down(visitedPieceMoves),startDrop);
  }
}",0.9687174139728884
5812,"public StandardGameSettings(int boardWidth,int boardHeight,boolean sliding){
  super(boardWidth,boardHeight,startX(boardWidth,3),-1,sliding);
}","public StandardGameSettings(int boardWidth,int boardHeight,boolean sliding){
  super(boardWidth,boardHeight,startX(boardWidth,3),0,sliding);
}",0.9894736842105264
5813,"public boolean isSlidingEnabled(){
  return slidingEnabled;
}","@Override public boolean isSlidingEnabled(){
  return slidingEnabled;
}",0.9242424242424242
5814,"@Override protected PieceShape[] shapes(){
  return new PieceShape[]{new PieceShape(new Point(0,0),new Point(1,0),new Point(2,0),new Point(2,1)),new PieceShape(new Point(0,0),new Point(1,1),new Point(0,1),new Point(0,2)),new PieceShape(new Point(0,0),new Point(0,1),new Point(1,1),new Point(2,1)),new PieceShape(new Point(1,0),new Point(1,1),new Point(0,2),new Point(1,2))};
}","@Override protected PieceShape[] shapes(){
  return new PieceShape[]{new PieceShape(new Point(0,0),new Point(1,0),new Point(2,0),new Point(2,1)),new PieceShape(new Point(0,0),new Point(1,0),new Point(0,1),new Point(0,2)),new PieceShape(new Point(0,0),new Point(0,1),new Point(1,1),new Point(2,1)),new PieceShape(new Point(1,0),new Point(1,1),new Point(0,2),new Point(1,2))};
}",0.9973404255319148
5815,"private void acceptConnections(){
  while (run) {
    try {
      Socket client=listenerSocket.accept();
      if (client != null) {
        clientHolder.add(new TelnetListener(client,mcserv,this));
        System.out.print(""String_Node_Str"" + client.getInetAddress().toString());
      }
      for (int i=0; i < clientHolder.size(); i++) {
        TelnetListener thisListener=clientHolder.get(i);
        if (thisListener.isAlive() == false)         clientHolder.remove(i);
      }
    }
 catch (    IOException ex) {
      run=false;
    }
  }
  Logger.getLogger(""String_Node_Str"").log(Level.INFO,""String_Node_Str"");
  for (int i=0; i < clientHolder.size(); i++) {
    TelnetListener temp=clientHolder.get(i);
    temp.killClient();
  }
  listenerSocket=null;
  mcserv=null;
  clientHolder.clear();
  clientHolder=null;
  this.setEnabled(false);
}","private void acceptConnections(){
  while (run) {
    try {
      Socket client=listenerSocket.accept();
      if (client != null) {
        clientHolder.add(new TelnetListener(client,this));
        System.out.print(""String_Node_Str"" + client.getInetAddress().toString());
      }
      for (int i=0; i < clientHolder.size(); i++) {
        TelnetListener thisListener=clientHolder.get(i);
        if (thisListener.isAlive() == false)         clientHolder.remove(i);
      }
    }
 catch (    IOException ex) {
      run=false;
    }
  }
  Logger.getLogger(""String_Node_Str"").log(Level.INFO,""String_Node_Str"");
  for (int i=0; i < clientHolder.size(); i++) {
    TelnetListener temp=clientHolder.get(i);
    temp.killClient();
  }
  listenerSocket=null;
  clientHolder.clear();
  clientHolder=null;
  this.setEnabled(false);
}",0.9439140811455848
5816,"public void onEnable(){
  try {
    Logger.getLogger(""String_Node_Str"").log(Level.INFO,""String_Node_Str"" + this.getDescription().getVersion() + ""String_Node_Str"");
    run=true;
    this.getConfiguration().load();
    testConfig();
    if (this.getConfiguration().getBoolean(""String_Node_Str"",false))     encryptPasswords();
    port=this.getConfiguration().getInt(""String_Node_Str"",port);
    try {
      String address=this.getConfiguration().getString(""String_Node_Str"",null);
      if (address != null)       listenAddress=InetAddress.getByName(address);
    }
 catch (    Exception ex) {
      System.out.println(""String_Node_Str"" + ex.getMessage());
    }
    if (listenAddress != null) {
      listenerSocket=new java.net.ServerSocket(port,10,listenAddress);
    }
 else {
      listenerSocket=new java.net.ServerSocket(port,10);
    }
    clientHolder=new ArrayList<TelnetListener>();
    listenerThread=new Thread(new Runnable(){
      public void run(){
        acceptConnections();
      }
    }
);
    listenerThread.start();
    Field cfield=CraftServer.class.getDeclaredField(""String_Node_Str"");
    cfield.setAccessible(true);
    mcserv=(MinecraftServer)cfield.get((CraftServer)getServer());
    Logger.getLogger(""String_Node_Str"").log(Level.INFO,""String_Node_Str"" + listenerSocket.getInetAddress().getHostAddress() + ""String_Node_Str""+ port);
  }
 catch (  Exception ex) {
    Logger.getLogger(""String_Node_Str"").log(Level.SEVERE,""String_Node_Str"" + ex.getMessage());
    this.setEnabled(false);
  }
}","public void onEnable(){
  try {
    Logger.getLogger(""String_Node_Str"").log(Level.INFO,""String_Node_Str"" + this.getDescription().getVersion() + ""String_Node_Str"");
    run=true;
    this.getConfiguration().load();
    testConfig();
    if (this.getConfiguration().getBoolean(""String_Node_Str"",false))     encryptPasswords();
    port=this.getConfiguration().getInt(""String_Node_Str"",port);
    try {
      String address=this.getConfiguration().getString(""String_Node_Str"",null);
      if (address != null)       listenAddress=InetAddress.getByName(address);
    }
 catch (    Exception ex) {
      System.out.println(""String_Node_Str"" + ex.getMessage());
    }
    if (listenAddress != null) {
      listenerSocket=new java.net.ServerSocket(port,10,listenAddress);
    }
 else {
      listenerSocket=new java.net.ServerSocket(port,10);
    }
    clientHolder=new ArrayList<TelnetListener>();
    listenerThread=new Thread(new Runnable(){
      public void run(){
        acceptConnections();
      }
    }
);
    listenerThread.start();
    Field cfield=CraftServer.class.getDeclaredField(""String_Node_Str"");
    cfield.setAccessible(true);
    Logger.getLogger(""String_Node_Str"").log(Level.INFO,""String_Node_Str"" + listenerSocket.getInetAddress().getHostAddress() + ""String_Node_Str""+ port);
  }
 catch (  Exception ex) {
    Logger.getLogger(""String_Node_Str"").log(Level.SEVERE,""String_Node_Str"" + ex.getMessage());
    this.setEnabled(false);
  }
}",0.9777777777777776
5817,"public void sendMessage(String string){
  if (clientSocket.isConnected()) {
    try {
      outstream.write(string + ""String_Node_Str"");
      outstream.flush();
    }
 catch (    IOException ex) {
    }
  }
}","public void sendMessage(String string){
  if (clientSocket.isConnected()) {
    try {
      string=ChatColor.stripColor(string);
      outstream.write(string + ""String_Node_Str"");
      outstream.flush();
    }
 catch (    IOException ex) {
    }
  }
}",0.9067245119305856
5818,"public TelnetListener(Socket inSock,MinecraftServer imcserv,MCTelnet iparent){
  run=true;
  mcserv=imcserv;
  clientSocket=inSock;
  parent=iparent;
  passRegex=parent.getConfiguration().getString(""String_Node_Str"",passRegex);
  commandRegex=parent.getConfiguration().getString(""String_Node_Str"",commandRegex);
  ip=clientSocket.getInetAddress().toString();
  listenThread=new Thread(new Runnable(){
    public void run(){
      mainLoop();
    }
  }
);
  listenThread.start();
}","public TelnetListener(Socket inSock,MCTelnet iparent){
  run=true;
  clientSocket=inSock;
  parent=iparent;
  passRegex=parent.getConfiguration().getString(""String_Node_Str"",passRegex);
  commandRegex=parent.getConfiguration().getString(""String_Node_Str"",commandRegex);
  ip=clientSocket.getInetAddress().toString();
  listenThread=new Thread(new Runnable(){
    public void run(){
      mainLoop();
    }
  }
);
  listenThread.start();
}",0.954248366013072
5819,"@Override public void publish(LogRecord record){
  try {
    if (!clientSocket.isClosed()) {
      outstream.write(record.getMessage() + ""String_Node_Str"");
      outstream.flush();
    }
  }
 catch (  IOException ex) {
  }
}","@Override public void publish(LogRecord record){
  try {
    if (!clientSocket.isClosed()) {
      outstream.write(ChatColor.stripColor(record.getMessage()) + ""String_Node_Str"");
      outstream.flush();
    }
  }
 catch (  IOException ex) {
  }
}",0.9533898305084746
5820,"public boolean isInitialized(Object object){
  if (object instanceof LazyableCollection)   return !((LazyableCollection)object).isInitialized();
  return persistence.isInitialized(object);
}","public boolean isInitialized(Object object){
  return persistence.isInitialized(object);
}",0.6428571428571429
5821,"private boolean isSameExt(Object val1,Object val2){
  if (val1 == null && isEmpty(val2))   return true;
 else   if (val2 == null && isEmpty(val1))   return true;
 else   if (ObjectUtil.isSimple(val1) && ObjectUtil.isSimple(val2))   return val1.equals(val2);
 else   if (val1 instanceof byte[] && val2 instanceof byte[])   return Arrays.equals((byte[])val1,(byte[])val2);
 else   if ((val1 instanceof Value && val2 instanceof Value) || (val1 instanceof Enum && val2 instanceof Enum))   return val1.equals(val2);
 else   if (val1 != null && val1.getClass().isArray() && val2 != null && val2.getClass().isArray()) {
    if (Array.getLength(val1) != Array.getLength(val2))     return false;
    for (int idx=0; idx < Array.getLength(val1); idx++) {
      if (!isSameExt(Array.get(val1,idx),Array.get(val2,idx)))       return false;
    }
    return true;
  }
 else   if (val1 instanceof Set<?> && val2 instanceof Set<?>) {
    if ((val1 instanceof LazyableCollection && !((LazyableCollection)val1).isInitialized()) || (val2 instanceof LazyableCollection && !((LazyableCollection)val2).isInitialized()))     return false;
    Collection<?> coll1=(Collection<?>)val1;
    Collection<?> coll2=(Collection<?>)val2;
    if (coll1.size() != coll2.size())     return false;
    for (    Object e : coll1) {
      boolean found=false;
      for (      Object f : coll2) {
        if (isSameExt(e,f)) {
          found=true;
          break;
        }
      }
      if (!found)       return false;
    }
    for (    Object e : coll2) {
      boolean found=false;
      for (      Object f : coll1) {
        if (isSameExt(e,f)) {
          found=true;
          break;
        }
      }
      if (!found)       return false;
    }
    return true;
  }
 else   if (val1 instanceof List<?> && val2 instanceof List<?>) {
    if ((val1 instanceof LazyableCollection && !((LazyableCollection)val1).isInitialized()) || (val2 instanceof LazyableCollection && !((LazyableCollection)val2).isInitialized()))     return false;
    List<?> list1=(List<?>)val1;
    List<?> list2=(List<?>)val2;
    if (list1.size() != list2.size())     return false;
    for (int idx=0; idx < list1.size(); idx++) {
      if (!isSameExt(list1.get(idx),list2.get(idx)))       return false;
    }
    return true;
  }
 else   if (val1 instanceof Map<?,?> && val2 instanceof Map<?,?>) {
    if ((val1 instanceof LazyableCollection && !((LazyableCollection)val1).isInitialized()) || (val2 instanceof LazyableCollection && !((LazyableCollection)val2).isInitialized()))     return false;
    Map<?,?> map1=(Map<?,?>)val1;
    Map<?,?> map2=(Map<?,?>)val2;
    if (map1.size() != map2.size())     return false;
    for (    Object e : map1.keySet()) {
      Object key=null;
      for (      Object f : map2.keySet()) {
        if (isSameExt(e,f)) {
          key=f;
          break;
        }
      }
      if (key == null)       return false;
      if (!isSameExt(map1.get(e),map2.get(key)))       return false;
    }
    for (    Object f : map2.keySet()) {
      Object key=null;
      for (      Object e : map1.keySet()) {
        if (isSameExt(e,f)) {
          key=e;
          break;
        }
      }
      if (key == null)       return false;
      if (!isSameExt(map1.get(key),map2.get(f)))       return false;
    }
    return true;
  }
  Object n=val1 instanceof Wrapper ? ((Wrapper)val1).getWrappedObject() : val1;
  Object o=val2 instanceof Wrapper ? ((Wrapper)val2).getWrappedObject() : val2;
  if (isEntity(n) && isEntity(o))   return dataManager.getUid(n).equals(dataManager.getUid(o));
  return n == o;
}","private boolean isSameExt(Object val1,Object val2){
  if (val1 == null && isEmpty(val2))   return true;
 else   if (val2 == null && isEmpty(val1))   return true;
 else   if (ObjectUtil.isSimple(val1) && ObjectUtil.isSimple(val2))   return val1.equals(val2);
 else   if (val1 instanceof byte[] && val2 instanceof byte[])   return Arrays.equals((byte[])val1,(byte[])val2);
 else   if ((val1 instanceof Value && val2 instanceof Value) || (val1 instanceof Enum && val2 instanceof Enum))   return val1.equals(val2);
 else   if (val1 != null && val1.getClass().isArray() && val2 != null && val2.getClass().isArray()) {
    if (Array.getLength(val1) != Array.getLength(val2))     return false;
    for (int idx=0; idx < Array.getLength(val1); idx++) {
      if (!isSameExt(Array.get(val1,idx),Array.get(val2,idx)))       return false;
    }
    return true;
  }
 else   if (val1 instanceof Set<?> && val2 instanceof Set<?>) {
    if ((val1 instanceof PersistentCollection && !((PersistentCollection)val1).wasInitialized()) || (val2 instanceof PersistentCollection && !((PersistentCollection)val2).wasInitialized()))     return false;
    Collection<?> coll1=(Collection<?>)val1;
    Collection<?> coll2=(Collection<?>)val2;
    if (coll1.size() != coll2.size())     return false;
    for (    Object e : coll1) {
      boolean found=false;
      for (      Object f : coll2) {
        if (isSameExt(e,f)) {
          found=true;
          break;
        }
      }
      if (!found)       return false;
    }
    for (    Object e : coll2) {
      boolean found=false;
      for (      Object f : coll1) {
        if (isSameExt(e,f)) {
          found=true;
          break;
        }
      }
      if (!found)       return false;
    }
    return true;
  }
 else   if (val1 instanceof List<?> && val2 instanceof List<?>) {
    if ((val1 instanceof PersistentCollection && !((PersistentCollection)val1).wasInitialized()) || (val2 instanceof PersistentCollection && !((PersistentCollection)val2).wasInitialized()))     return false;
    List<?> list1=(List<?>)val1;
    List<?> list2=(List<?>)val2;
    if (list1.size() != list2.size())     return false;
    for (int idx=0; idx < list1.size(); idx++) {
      if (!isSameExt(list1.get(idx),list2.get(idx)))       return false;
    }
    return true;
  }
 else   if (val1 instanceof Map<?,?> && val2 instanceof Map<?,?>) {
    if ((val1 instanceof PersistentCollection && !((PersistentCollection)val1).wasInitialized()) || (val2 instanceof PersistentCollection && !((PersistentCollection)val2).wasInitialized()))     return false;
    Map<?,?> map1=(Map<?,?>)val1;
    Map<?,?> map2=(Map<?,?>)val2;
    if (map1.size() != map2.size())     return false;
    for (    Object e : map1.keySet()) {
      Object key=null;
      for (      Object f : map2.keySet()) {
        if (isSameExt(e,f)) {
          key=f;
          break;
        }
      }
      if (key == null)       return false;
      if (!isSameExt(map1.get(e),map2.get(key)))       return false;
    }
    for (    Object f : map2.keySet()) {
      Object key=null;
      for (      Object e : map1.keySet()) {
        if (isSameExt(e,f)) {
          key=e;
          break;
        }
      }
      if (key == null)       return false;
      if (!isSameExt(map1.get(key),map2.get(f)))       return false;
    }
    return true;
  }
  Object n=val1 instanceof Wrapper ? ((Wrapper)val1).getWrappedObject() : val1;
  Object o=val2 instanceof Wrapper ? ((Wrapper)val2).getWrappedObject() : val2;
  if (isEntity(n) && isEntity(o))   return dataManager.getUid(n).equals(dataManager.getUid(o));
  return n == o;
}",0.9674185463659148
5822,"/** 
 * @private Check if dirty properties of an object are the same than those of another entity When they are the same, unmark the dirty flag
 * @param entity merged entity
 * @param source source entity
 * @param owner owner entity for embedded objects
 * @return true if the entity is still dirty after comparing with incoming object
 */
public boolean checkAndMarkNotDirty(MergeContext mergeContext,Object entity,Object source,Object parent){
  if (entity != null)   unsavedEntities.remove(entity);
  Map<String,Object> save=savedProperties.get(entity);
  if (save == null)   return false;
  Object owner=isEntity(entity) ? entity : parent;
  boolean oldDirty=isDirty();
  boolean oldDirtyEntity=isEntityChanged(owner);
  List<String> merged=new ArrayList<String>();
  String versionPropertyName=dataManager.getVersionPropertyName(owner);
  if (isEntity(source) && versionPropertyName != null)   save.put(versionPropertyName,dataManager.getVersion(source));
  Map<String,Object> pval=dataManager.getPropertyValues(entity,false,false);
  for (  String propName : pval.keySet()) {
    if (propName.equals(versionPropertyName) || propName.equals(""String_Node_Str""))     continue;
    Object localValue=pval.get(propName);
    if (localValue instanceof PropertyHolder)     localValue=((PropertyHolder)localValue).getObject();
    Object sourceValue=dataManager.getPropertyValue(source,propName);
    if (isSameExt(sourceValue,localValue)) {
      merged.add(propName);
      continue;
    }
    if (sourceValue == null || ObjectUtil.isSimple(sourceValue) || sourceValue instanceof Value || sourceValue instanceof Enum) {
      save.put(propName,sourceValue);
    }
 else     if (isEntity(sourceValue)) {
      save.put(propName,mergeContext.getFromCache(sourceValue));
    }
 else     if (sourceValue instanceof Collection<?> && !(sourceValue instanceof LazyableCollection && !((LazyableCollection)sourceValue).isInitialized())) {
      List<Object> snapshot=new ArrayList<Object>((Collection<?>)sourceValue);
      save.put(propName,snapshot);
    }
 else     if (sourceValue instanceof Map<?,?> && !(sourceValue instanceof LazyableCollection && !((LazyableCollection)sourceValue).isInitialized())) {
      Map<?,?> map=(Map<?,?>)sourceValue;
      List<Object[]> snapshot=new ArrayList<Object[]>(map.size());
      for (      Entry<?,?> entry : map.entrySet())       snapshot.add(new Object[]{entry.getKey(),entry.getValue()});
      save.put(propName,snapshot);
    }
  }
  for (  String propName : merged)   save.remove(propName);
  int count=0;
  for (  String propName : save.keySet()) {
    if (!propName.equals(versionPropertyName))     count++;
  }
  if (count == 0) {
    savedProperties.remove(entity);
    dirtyCount--;
  }
  boolean newDirtyEntity=notifyEntityDirtyChange(owner,oldDirtyEntity);
  notifyDirtyChange(oldDirty);
  return newDirtyEntity;
}","/** 
 * @private Check if dirty properties of an object are the same than those of another entity When they are the same, unmark the dirty flag
 * @param entity merged entity
 * @param source source entity
 * @param owner owner entity for embedded objects
 * @return true if the entity is still dirty after comparing with incoming object
 */
public boolean checkAndMarkNotDirty(MergeContext mergeContext,Object entity,Object source,Object parent){
  if (entity != null)   unsavedEntities.remove(entity);
  Map<String,Object> save=savedProperties.get(entity);
  if (save == null)   return false;
  Object owner=isEntity(entity) ? entity : parent;
  boolean oldDirty=isDirty();
  boolean oldDirtyEntity=isEntityChanged(owner);
  List<String> merged=new ArrayList<String>();
  String versionPropertyName=dataManager.getVersionPropertyName(owner);
  if (isEntity(source) && versionPropertyName != null)   save.put(versionPropertyName,dataManager.getVersion(source));
  Map<String,Object> pval=dataManager.getPropertyValues(entity,false,false);
  for (  String propName : pval.keySet()) {
    if (propName.equals(versionPropertyName) || propName.equals(""String_Node_Str""))     continue;
    Object localValue=pval.get(propName);
    if (localValue instanceof PropertyHolder)     localValue=((PropertyHolder)localValue).getObject();
    Object sourceValue=dataManager.getPropertyValue(source,propName);
    if (isSameExt(sourceValue,localValue)) {
      merged.add(propName);
      continue;
    }
    if (sourceValue == null || ObjectUtil.isSimple(sourceValue) || sourceValue instanceof Value || sourceValue instanceof Enum) {
      save.put(propName,sourceValue);
    }
 else     if (isEntity(sourceValue)) {
      save.put(propName,mergeContext.getFromCache(sourceValue));
    }
 else     if (sourceValue instanceof Collection<?> && !(sourceValue instanceof PersistentCollection && !((PersistentCollection)sourceValue).wasInitialized())) {
      List<Object> snapshot=new ArrayList<Object>((Collection<?>)sourceValue);
      save.put(propName,snapshot);
    }
 else     if (sourceValue instanceof Map<?,?> && !(sourceValue instanceof PersistentCollection && !((PersistentCollection)sourceValue).wasInitialized())) {
      Map<?,?> map=(Map<?,?>)sourceValue;
      List<Object[]> snapshot=new ArrayList<Object[]>(map.size());
      for (      Entry<?,?> entry : map.entrySet())       snapshot.add(new Object[]{entry.getKey(),entry.getValue()});
      save.put(propName,snapshot);
    }
  }
  for (  String propName : merged)   save.remove(propName);
  int count=0;
  for (  String propName : save.keySet()) {
    if (!propName.equals(versionPropertyName))     count++;
  }
  if (count == 0) {
    savedProperties.remove(entity);
    dirtyCount--;
  }
  boolean newDirtyEntity=notifyEntityDirtyChange(owner,oldDirtyEntity);
  notifyDirtyChange(oldDirty);
  return newDirtyEntity;
}",0.9864158829676072
5823,"private boolean isEntityDeepChanged(Object entity,Object embedded,IdentityHashMap<Object,Boolean> cache){
  if (cache == null)   cache=new IdentityHashMap<Object,Boolean>();
  if (cache.containsKey(entity))   return false;
  cache.put(entity,true);
  boolean saveTracking=trackingContext.isEnabled();
  try {
    trackingContext.setEnabled(false);
    Map<String,Object> pval=dataManager.getPropertyValues(entity,true,false);
    if (embedded == null)     embedded=entity;
    Map<String,Object> save=savedProperties.get(entity);
    for (    String p : pval.keySet()) {
      Object val=pval.get(p);
      Object saveval=save != null ? save.get(p) : null;
      if (save != null && ((val != null && (ObjectUtil.isSimple(val) || val instanceof byte[])) || (saveval != null && (ObjectUtil.isSimple(saveval) || saveval instanceof byte[])))) {
        return true;
      }
 else       if (save != null && (val instanceof Value || saveval instanceof Value || val instanceof Enum|| saveval instanceof Enum)) {
        if (saveval != null && ((val == null && saveval != null) || !val.equals(saveval))) {
          return true;
        }
      }
 else       if (save != null && (isEntity(val) || isEntity(saveval))) {
        if (saveval != null && val != save.get(p))         return true;
        if (isEntityDeepChanged(val,null,cache))         return true;
      }
 else       if (val instanceof List<?> || val instanceof Map<?,?>) {
        if (!dataManager.isInitialized(val))         return false;
        @SuppressWarnings(""String_Node_Str"") List<Change> savedArray=(List<Change>)saveval;
        if (savedArray != null && !savedArray.isEmpty())         return true;
        if (val instanceof List<?>) {
          for (          Object elt : (List<?>)val) {
            if (isEntityDeepChanged(elt,null,cache))             return true;
          }
        }
 else         if (val instanceof Map<?,?>) {
          for (          Entry<?,?> me : ((Map<?,?>)val).entrySet()) {
            if (isEntityDeepChanged(me.getKey(),null,cache))             return true;
            if (isEntityDeepChanged(me.getValue(),null,cache))             return true;
          }
        }
      }
 else       if (val != null && !(isEntity(val) || ObjectUtil.isSimple(val) || val instanceof Enum|| val instanceof Value|| val instanceof byte[]) && isEntityDeepChanged(val,embedded,cache)) {
        return true;
      }
    }
  }
  finally {
    trackingContext.setEnabled(saveTracking);
  }
  return false;
}","private boolean isEntityDeepChanged(Object entity,Object embedded,IdentityHashMap<Object,Boolean> cache){
  if (cache == null)   cache=new IdentityHashMap<Object,Boolean>();
  if (cache.containsKey(entity))   return false;
  cache.put(entity,true);
  if (!dataManager.isInitialized(entity))   return false;
  boolean saveTracking=trackingContext.isEnabled();
  try {
    trackingContext.setEnabled(false);
    Map<String,Object> pval=dataManager.getPropertyValues(entity,true,false);
    if (embedded == null)     embedded=entity;
    Map<String,Object> save=savedProperties.get(entity);
    for (    String p : pval.keySet()) {
      Object val=pval.get(p);
      Object saveval=save != null ? save.get(p) : null;
      if (save != null && ((val != null && (ObjectUtil.isSimple(val) || val instanceof byte[])) || (saveval != null && (ObjectUtil.isSimple(saveval) || saveval instanceof byte[])))) {
        return true;
      }
 else       if (save != null && (val instanceof Value || saveval instanceof Value || val instanceof Enum|| saveval instanceof Enum)) {
        if (saveval != null && ((val == null && saveval != null) || !val.equals(saveval))) {
          return true;
        }
      }
 else       if (save != null && (isEntity(val) || isEntity(saveval))) {
        if (saveval != null && val != save.get(p))         return true;
        if (isEntityDeepChanged(val,null,cache))         return true;
      }
 else       if (val instanceof List<?> || val instanceof Map<?,?>) {
        if (!dataManager.isInitialized(val))         continue;
        @SuppressWarnings(""String_Node_Str"") List<Change> savedArray=(List<Change>)saveval;
        if (savedArray != null && !savedArray.isEmpty())         return true;
        if (val instanceof List<?>) {
          for (          Object elt : (List<?>)val) {
            if (isEntityDeepChanged(elt,null,cache))             return true;
          }
        }
 else         if (val instanceof Map<?,?>) {
          for (          Entry<?,?> me : ((Map<?,?>)val).entrySet()) {
            if (isEntityDeepChanged(me.getKey(),null,cache))             return true;
            if (isEntityDeepChanged(me.getValue(),null,cache))             return true;
          }
        }
      }
 else       if (val != null && !(isEntity(val) || ObjectUtil.isSimple(val) || val instanceof Enum|| val instanceof Value|| val instanceof byte[]) && isEntityDeepChanged(val,embedded,cache)) {
        return true;
      }
    }
  }
  finally {
    trackingContext.setEnabled(saveTracking);
  }
  return false;
}",0.9848966613672496
5824,"/** 
 * Check if entity has changed since last save point
 * @param entity entity to check
 * @param propName property name
 * @param value
 * @return entity is dirty
 */
@SuppressWarnings(""String_Node_Str"") public boolean isEntityChanged(Object entity,Object embedded,String propName,Object value){
  boolean saveTracking=trackingContext.isEnabled();
  try {
    trackingContext.setEnabled(false);
    boolean dirty=false;
    Map<String,Object> pval=dataManager.getPropertyValues(entity,true,false);
    Map<String,Object> save=savedProperties.get(entity);
    if (embedded == null)     embedded=entity;
    for (    String p : pval.keySet()) {
      Object val=(entity == embedded && p.equals(propName)) ? value : pval.get(p);
      Object saveval=save != null ? save.get(p) : null;
      if (save != null && ((val != null && (ObjectUtil.isSimple(val) || val instanceof byte[])) || (saveval != null && (ObjectUtil.isSimple(saveval) || saveval instanceof byte[])))) {
        dirty=true;
        break;
      }
 else       if (save != null && (val instanceof Value || saveval instanceof Value || val instanceof Enum|| saveval instanceof Enum)) {
        if (saveval != null && ((val == null && saveval != null) || !val.equals(saveval))) {
          dirty=true;
          break;
        }
      }
 else       if (save != null && (isEntity(val) || isEntity(saveval))) {
        if (saveval != null && val != save.get(p)) {
          dirty=true;
          break;
        }
      }
 else       if ((val instanceof List<?> || val instanceof Map<?,?>) && !(val instanceof LazyableCollection && !((LazyableCollection)val).isInitialized())) {
        List<Change> savedArray=(List<Change>)saveval;
        if (savedArray != null && !savedArray.isEmpty()) {
          dirty=true;
          break;
        }
      }
 else       if (val != null && !(isEntity(val) || ObjectUtil.isSimple(val) || val instanceof Enum|| val instanceof Value|| val instanceof byte[]) && isEntityChanged(val)) {
        dirty=true;
        break;
      }
    }
    return dirty;
  }
  finally {
    trackingContext.setEnabled(saveTracking);
  }
}","/** 
 * Check if entity has changed since last save point
 * @param entity entity to check
 * @param propName property name
 * @param value
 * @return entity is dirty
 */
@SuppressWarnings(""String_Node_Str"") public boolean isEntityChanged(Object entity,Object embedded,String propName,Object value){
  if (!dataManager.isInitialized(entity))   return false;
  boolean saveTracking=trackingContext.isEnabled();
  try {
    trackingContext.setEnabled(false);
    boolean dirty=false;
    Map<String,Object> pval=dataManager.getPropertyValues(entity,true,false);
    Map<String,Object> save=savedProperties.get(entity);
    if (embedded == null)     embedded=entity;
    for (    String p : pval.keySet()) {
      Object val=(entity == embedded && p.equals(propName)) ? value : pval.get(p);
      Object saveval=save != null ? save.get(p) : null;
      if (save != null && ((val != null && (ObjectUtil.isSimple(val) || val instanceof byte[])) || (saveval != null && (ObjectUtil.isSimple(saveval) || saveval instanceof byte[])))) {
        dirty=true;
        break;
      }
 else       if (save != null && (val instanceof Value || saveval instanceof Value || val instanceof Enum|| saveval instanceof Enum)) {
        if (saveval != null && ((val == null && saveval != null) || !val.equals(saveval))) {
          dirty=true;
          break;
        }
      }
 else       if (save != null && (isEntity(val) || isEntity(saveval))) {
        if (saveval != null && val != save.get(p)) {
          dirty=true;
          break;
        }
      }
 else       if ((val instanceof List<?> || val instanceof Map<?,?>)) {
        if (!dataManager.isInitialized(val))         continue;
        List<Change> savedArray=(List<Change>)saveval;
        if (savedArray != null && !savedArray.isEmpty()) {
          dirty=true;
          break;
        }
      }
 else       if (val != null && !(isEntity(val) || ObjectUtil.isSimple(val) || val instanceof Enum|| val instanceof Value|| val instanceof byte[]) && isEntityChanged(val)) {
        dirty=true;
        break;
      }
    }
    return dirty;
  }
  finally {
    trackingContext.setEnabled(saveTracking);
  }
}",0.9509964830011725
5825,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public <T>Future<T> invoke(Context context,Component component,String operation,Object[] args,TideResponder<T> tideResponder,boolean withContext,ComponentListener.Handler<T> handler){
  log.debug(""String_Node_Str"",context.getContextId(),component.getName() != null ? component.getName() : component.getClass().getName(),operation);
  ComponentListener.Handler h=handler != null ? handler : new ComponentListener.Handler<T>(){
    @Override public Runnable result(    Context context,    ResultEvent event,    Object info,    String componentName,    String operation,    TideResponder<T> tideResponder,    ComponentListener<T> componentListener){
      return new ResultHandler(serverSession,context,componentName,operation,event,info,tideResponder,componentListener);
    }
    @Override public Runnable fault(    Context context,    FaultEvent event,    Object info,    String componentName,    String operation,    TideResponder<T> tideResponder,    ComponentListener<T> componentListener){
      return new FaultHandler(serverSession,context,componentName,operation,event,info,tideResponder,componentListener);
    }
  }
;
  ComponentListener<T> componentListener=new ComponentListenerImpl<T>(context,h,component,operation,args,null,tideResponder);
  InvocationInterceptor[] interceptors=context.allByType(InvocationInterceptor.class);
  if (interceptors != null) {
    for (    InvocationInterceptor interceptor : interceptors)     interceptor.beforeInvocation(context,component,operation,args,componentListener);
  }
  context.getContextManager().destroyFinishedContexts();
  Object[] call=new Object[5];
  call[0]=componentListener.getComponent().getName();
  String componentClassName=null;
  if (componentListener.getComponent().getClass() != ComponentImpl.class) {
    RemoteClass remoteClass=componentListener.getComponent().getClass().getAnnotation(RemoteClass.class);
    componentClassName=remoteClass != null ? remoteClass.value() : componentListener.getComponent().getClass().getName();
  }
  call[1]=componentClassName;
  call[2]=componentListener.getOperation();
  call[3]=componentListener.getArgs();
  call[4]=new InvocationCall();
  RemoteService ro=serverSession.getRemoteService();
  ResponseMessageFuture rmf=ro.newInvocation(""String_Node_Str"",call).addListener(componentListener).invoke();
  serverSession.checkWaitForLogout();
  return new FutureResult<T>(rmf,componentListener);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public <T>Future<T> invoke(Context context,Component component,String operation,Object[] args,TideResponder<T> tideResponder,boolean withContext,ComponentListener.Handler<T> handler){
  log.debug(""String_Node_Str"",context.getContextId(),component.getName() != null ? component.getName() : component.getClass().getName(),operation);
  ComponentListener.Handler h=handler != null ? handler : new ComponentListener.Handler<T>(){
    @Override public Runnable result(    Context context,    ResultEvent event,    Object info,    String componentName,    String operation,    TideResponder<T> tideResponder,    ComponentListener<T> componentListener){
      return new ResultHandler(serverSession,context,componentName,operation,event,info,tideResponder,componentListener);
    }
    @Override public Runnable fault(    Context context,    FaultEvent event,    Object info,    String componentName,    String operation,    TideResponder<T> tideResponder,    ComponentListener<T> componentListener){
      return new FaultHandler(serverSession,context,componentName,operation,event,info,tideResponder,componentListener);
    }
    @Override public Runnable issue(    Context context,    IssueEvent event,    Object info,    String componentName,    String operation,    TideResponder<T> tideResponder,    ComponentListener<T> componentListener){
      return new FaultHandler(serverSession,context,componentName,operation,event,info,tideResponder,componentListener);
    }
  }
;
  ComponentListener<T> componentListener=new ComponentListenerImpl<T>(context,h,component,operation,args,null,tideResponder);
  InvocationInterceptor[] interceptors=context.allByType(InvocationInterceptor.class);
  if (interceptors != null) {
    for (    InvocationInterceptor interceptor : interceptors)     interceptor.beforeInvocation(context,component,operation,args,componentListener);
  }
  context.getContextManager().destroyFinishedContexts();
  return componentListener.invoke(serverSession);
}",0.7389951089373055
5826,"@Override public void onCancelled(CancelledEvent event){
synchronized (this) {
    exception=new InterruptedException(""String_Node_Str"");
    if (waiting)     notifyAll();
  }
}","@Override public void onCancelled(CancelledEvent event){
  Runnable h=handler.issue(sourceContext,event,info,componentName,operation,tideResponder,this);
synchronized (this) {
    exception=new InterruptedException(""String_Node_Str"");
    if (waiting)     notifyAll();
 else     sourceContext.callLater(h);
  }
}",0.7239263803680982
5827,"@Override public void onFailure(final FailureEvent event){
synchronized (this) {
    exception=new ExecutionException(event.getCause());
    if (waiting)     notifyAll();
  }
}","@Override public void onFailure(final FailureEvent event){
  Runnable h=handler.issue(sourceContext,event,info,componentName,operation,tideResponder,this);
synchronized (this) {
    exception=new ExecutionException(event.getCause());
    if (waiting)     notifyAll();
 else     sourceContext.callLater(h);
  }
}",0.7227926078028748
5828,"@Override public void onTimeout(TimeoutEvent event){
synchronized (this) {
    exception=new InterruptedException(""String_Node_Str"");
    if (waiting)     notifyAll();
  }
}","@Override public void onTimeout(TimeoutEvent event){
  Runnable h=handler.issue(sourceContext,event,info,componentName,operation,tideResponder,this);
synchronized (this) {
    exception=new InterruptedException(""String_Node_Str"");
    if (waiting)     notifyAll();
 else     sourceContext.callLater(h);
  }
}",0.7193347193347194
5829,"public void run(){
  if (executed)   return;
  executed=true;
  log.error(""String_Node_Str"",event.toString());
  Context context=sourceContext.getContextManager().retrieveContext(sourceContext,null,false,false);
  FaultMessage emsg=event.getMessage();
  FaultMessage m=emsg;
  Map<String,Object> extendedData=emsg != null ? emsg.getExtended() : null;
  do {
    if (m != null && m.getCode() != null && m.isSecurityFault()) {
      emsg=m;
      extendedData=emsg != null ? emsg.getExtended() : null;
      break;
    }
    if (m != null && m.getCause() instanceof FaultEvent)     m=(FaultMessage)((FaultEvent)m.getCause()).getCause();
 else     if (m.getCause() instanceof FaultMessage)     m=(FaultMessage)m.getCause();
 else     m=null;
  }
 while (m != null);
  serverSession.handleFaultEvent(event,emsg);
  serverSession.handleFault(context,componentName,operation,emsg);
  boolean handled=false;
  Fault fault=new Fault(emsg.getCode(),emsg.getDescription(),emsg.getDetails());
  fault.setContent(event.getMessage());
  fault.setCause(event.getCause());
  TideFaultEvent faultEvent=new TideFaultEvent(context,serverSession,componentResponder,fault,extendedData);
  if (tideResponder != null) {
    tideResponder.fault(faultEvent);
    if (faultEvent.isDefaultPrevented())     handled=true;
  }
  if (!handled) {
    ExceptionHandler[] exceptionHandlers=context.getContextManager().getContext(null).allByType(ExceptionHandler.class);
    if (exceptionHandlers != null && emsg != null) {
      for (      ExceptionHandler handler : exceptionHandlers) {
        if (handler.accepts(emsg)) {
          handler.handle(context,emsg,faultEvent);
          handled=true;
          break;
        }
      }
      if (!handled)       log.error(""String_Node_Str"" + emsg.getCode() + ""String_Node_Str""+ emsg.getDescription());
    }
 else     if (exceptionHandlers != null && exceptionHandlers.length > 0 && event.getMessage() instanceof FaultMessage) {
      exceptionHandlers[0].handle(context,(FaultMessage)event.getMessage(),faultEvent);
    }
 else {
      log.error(""String_Node_Str"" + event.toString());
    }
  }
  if (!handled && !serverSession.isLogoutInProgress())   context.getEventBus().raiseEvent(context,ServerSession.CONTEXT_FAULT,event.getMessage());
  serverSession.tryLogout();
}","public void run(){
  if (executed)   return;
  executed=true;
  log.error(""String_Node_Str"",event.toString());
  Context context=sourceContext.getContextManager().retrieveContext(sourceContext,null,false,false);
  FaultMessage emsg=null;
  Map<String,Object> extendedData=null;
  if (event instanceof FaultEvent) {
    emsg=((FaultEvent)event).getMessage();
    FaultMessage m=emsg;
    extendedData=emsg != null ? emsg.getExtended() : null;
    do {
      if (m != null && m.getCode() != null && m.isSecurityFault()) {
        emsg=m;
        extendedData=emsg != null ? emsg.getExtended() : null;
        break;
      }
      if (m != null && m.getCause() instanceof FaultEvent)       m=(FaultMessage)((FaultEvent)m.getCause()).getCause();
 else       if (m.getCause() instanceof FaultMessage)       m=(FaultMessage)m.getCause();
 else       m=null;
    }
 while (m != null);
    serverSession.handleFaultEvent((FaultEvent)event,emsg);
  }
 else   serverSession.handleIssueEvent((IssueEvent)event);
  serverSession.handleFault(context,componentName,operation,emsg);
  boolean handled=false;
  Fault fault=null;
  if (event instanceof FaultEvent) {
    fault=new Fault(emsg.getCode(),emsg.getDescription(),emsg.getDetails());
    fault.setContent(((FaultEvent)event).getMessage());
    fault.setCause(((FaultEvent)event).getCause());
  }
 else   if (event.getType() == Type.FAILURE) {
    fault=new Fault(Code.CLIENT_CALL_FAILED,null,((FailureEvent)event).getCause() != null ? ((FailureEvent)event).getCause().getMessage() : null);
  }
 else   if (event.getType() == Type.TIMEOUT) {
    fault=new Fault(Code.CLIENT_CALL_TIMED_OUT,null,String.valueOf(((TimeoutEvent)event).getTime()));
  }
 else   if (event.getType() == Type.CANCELLED) {
    fault=new Fault(Code.CLIENT_CALL_CANCELLED,null,null);
  }
  TideFaultEvent faultEvent=new TideFaultEvent(context,serverSession,componentResponder,fault,extendedData);
  if (tideResponder != null) {
    tideResponder.fault(faultEvent);
    if (faultEvent.isDefaultPrevented())     handled=true;
  }
  if (!handled) {
    ExceptionHandler[] exceptionHandlers=context.getContextManager().getContext(null).allByType(ExceptionHandler.class);
    if (exceptionHandlers != null && emsg != null) {
      for (      ExceptionHandler handler : exceptionHandlers) {
        if (handler.accepts(emsg)) {
          handler.handle(context,emsg,faultEvent);
          handled=true;
          break;
        }
      }
      if (!handled)       log.error(""String_Node_Str"" + emsg.getCode() + ""String_Node_Str""+ emsg.getDescription());
    }
 else     if (exceptionHandlers != null && exceptionHandlers.length > 0 && event instanceof FaultEvent && ((FaultEvent)event).getMessage() instanceof FaultMessage) {
      exceptionHandlers[0].handle(context,(FaultMessage)((FaultEvent)event).getMessage(),faultEvent);
    }
 else {
      log.error(""String_Node_Str"" + event.toString());
    }
  }
  if (!handled && !serverSession.isLogoutInProgress())   context.getEventBus().raiseEvent(context,ServerSession.CONTEXT_FAULT,event instanceof FaultEvent ? ((FaultEvent)event).getMessage() : null);
  serverSession.tryLogout();
}",0.7997054491899853
5830,"public FaultHandler(ServerSession serverSession,Context sourceContext,String componentName,String operation,FaultEvent event,Object info,TideResponder<T> tideResponder,ComponentListener<T> componentResponder){
  this.serverSession=serverSession;
  this.sourceContext=sourceContext;
  this.componentName=componentName;
  this.operation=operation;
  this.event=event;
  this.info=info;
  this.tideResponder=tideResponder;
  this.componentResponder=componentResponder;
}","public FaultHandler(ServerSession serverSession,Context sourceContext,String componentName,String operation,Event event,Object info,TideResponder<T> tideResponder,ComponentListener<T> componentResponder){
  this.serverSession=serverSession;
  this.sourceContext=sourceContext;
  this.componentName=componentName;
  this.operation=operation;
  this.event=event;
  this.info=info;
  this.tideResponder=tideResponder;
  this.componentResponder=componentResponder;
}",0.9946178686759956
5831,"public static Object load(String url,final Object controller) throws IOException {
  InputStream fxmlStream=null;
  try {
    fxmlStream=controller.getClass().getResourceAsStream(url);
    FXMLLoader loader=new FXMLLoader();
    loader.setControllerFactory(new Callback<Class<?>,Object>(){
      @Override public Object call(      Class<?> type){
        if (type.isInstance(controller))         return controller;
        try {
          return type.newInstance();
        }
 catch (        Exception e) {
          throw new RuntimeException(""String_Node_Str"" + type);
        }
      }
    }
);
    return loader.load(fxmlStream);
  }
  finally {
    if (fxmlStream != null) {
      fxmlStream.close();
    }
  }
}","public static Object load(String url,final Object controller) throws IOException {
  InputStream fxmlStream=null;
  try {
    fxmlStream=controller.getClass().getResourceAsStream(url);
    FXMLLoader loader=new FXMLLoader();
    loader.setLocation(controller.getClass().getResource(url));
    loader.setControllerFactory(new Callback<Class<?>,Object>(){
      @Override public Object call(      Class<?> type){
        if (type.isInstance(controller))         return controller;
        try {
          return type.newInstance();
        }
 catch (        Exception e) {
          throw new RuntimeException(""String_Node_Str"" + type);
        }
      }
    }
);
    return loader.load(fxmlStream);
  }
  finally {
    if (fxmlStream != null) {
      fxmlStream.close();
    }
  }
}",0.9572763684913218
5832,"/** 
 * @private Retrives an entity in the cache from its uid
 * @param object an entity
 * @param nullIfAbsent return null if entity not cached in context
 */
public Object getCachedObject(Object object,boolean nullIfAbsent){
  Object entity=null;
  if (object instanceof Identifiable) {
    entity=entitiesByUid.get(object.getClass().getName() + ""String_Node_Str"" + ((Identifiable)object).getUid());
  }
 else   if (object instanceof EntityRef) {
    entity=entitiesByUid.get(((EntityRef)object).getClassName() + ""String_Node_Str"" + ((EntityRef)object).getUid());
  }
  if (entity != null)   return entity;
  if (nullIfAbsent)   return null;
  return object;
}","/** 
 * @private Retrives an entity in the cache from its uid
 * @param object an entity
 * @param nullIfAbsent return null if entity not cached in context
 */
public Object getCachedObject(Object object,boolean nullIfAbsent){
  Object entity=null;
  if (object instanceof Identifiable) {
    entity=entitiesByUid.get(object.getClass().getName() + ""String_Node_Str"" + getUid((Identifiable)object));
  }
 else   if (object instanceof EntityRef) {
    entity=entitiesByUid.get(((EntityRef)object).getClassName() + ""String_Node_Str"" + ((EntityRef)object).getUid());
  }
  if (entity != null)   return entity;
  if (nullIfAbsent)   return null;
  return object;
}",0.9886449659348978
5833,"/** 
 * @private Merge an entity coming from the server in the context
 * @param obj external entity
 * @param previous previously existing object in the context (null if no existing object)
 * @param expr current path from the context
 * @param parent parent object for collections
 * @param propertyName propertyName from the owner object
 * @return merged entity (=== previous when previous not null)
 */
private Object mergeEntity(MergeContext mergeContext,final Object obj,Object previous,Expression expr,Object parent,String propertyName){
  if (obj != null || previous != null)   log.debug(""String_Node_Str"",ObjectUtil.toString(obj),ObjectUtil.toString(previous),obj == previous ? ""String_Node_Str"" : ""String_Node_Str"");
  Object dest=obj;
  Object p=null;
  if (obj instanceof Lazyable && !((Lazyable)obj).isInitialized()) {
    final EntityDescriptor desc=dataManager.getEntityDescriptor(obj);
    if (desc.getIdPropertyName() != null) {
      p=entitiesByUid.find(new Matcher(){
        public boolean match(        Object o){
          return o.getClass().getName().equals(obj.getClass().getName()) && dataManager.getProperty(obj,desc.getIdPropertyName()).equals(dataManager.getProperty(o,desc.getIdPropertyName()));
        }
      }
);
      if (p != null) {
        previous=p;
        dest=previous;
      }
    }
  }
 else   if (obj instanceof Identifiable) {
    p=entitiesByUid.get(obj.getClass().getName() + ""String_Node_Str"" + ((Identifiable)obj).getUid());
    if (p != null) {
      if (obj == p)       return obj;
      previous=p;
      dest=previous;
    }
  }
  dataManager.stopTracking(previous,parent);
  if (dest != previous && previous != null && (ObjectUtil.objectEquals(dataManager,previous,obj) || (parent != null && !(previous instanceof Identifiable))))   dest=previous;
  if (dest == obj && p == null && obj != null && mergeContext.getSourceEntityManager() != null) {
    try {
      dest=TypeUtil.newInstance(obj.getClass(),Object.class);
      if (obj instanceof Identifiable)       ((Identifiable)dest).setUid(((Identifiable)obj).getUid());
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + obj.getClass(),e);
    }
  }
  if (obj instanceof Lazyable && !((Lazyable)obj).isInitialized() && ObjectUtil.objectEquals(dataManager,previous,obj)) {
    EntityDescriptor desc=dataManager.getEntityDescriptor(obj);
    if (desc.getVersionPropertyName() != null) {
      log.debug(""String_Node_Str"");
      dirtyCheckContext.markNotDirty(previous,null);
      return previous;
    }
  }
  if (dest instanceof Lazyable && !((Lazyable)dest).isInitialized())   log.debug(""String_Node_Str"",dest.toString());
  if (dest != null && dest instanceof Identifiable && dest == obj) {
    log.debug(""String_Node_Str"",obj.toString(),this.id);
  }
  boolean fromCache=(p != null && dest == p);
  if (!fromCache && dest instanceof Identifiable)   entitiesByUid.put((Identifiable)dest);
  mergeContext.putInCache(obj,dest);
  boolean ignore=false;
  if (dest instanceof Identifiable) {
    EntityDescriptor desc=dataManager.getEntityDescriptor(dest);
    if (mergeContext.isUninitializing() && parent instanceof Identifiable && propertyName != null) {
      if (desc.getVersionPropertyName() != null && dataManager.getProperty(obj,desc.getVersionPropertyName()) != null && dataManager.getEntityDescriptor(parent).isLazy(propertyName)) {
        if (defineProxy(desc,dest,obj))         return dest;
      }
    }
    attachEntity((Identifiable)dest,false);
    if (previous != null && dest == previous) {
      if (desc.getVersionPropertyName() != null && !mergeContext.isResolvingConflict()) {
        Number newVersion=(Number)dataManager.getProperty(obj,desc.getVersionPropertyName());
        Number oldVersion=(Number)dataManager.getProperty(dest,desc.getVersionPropertyName());
        if ((newVersion != null && oldVersion != null && newVersion.longValue() < oldVersion.longValue() || (newVersion == null && oldVersion != null))) {
          log.warn(""String_Node_Str"",dest.toString(),oldVersion,newVersion);
          ignore=true;
        }
 else         if ((newVersion != null && oldVersion != null && newVersion.longValue() > oldVersion.longValue()) || (newVersion != null && oldVersion == null)) {
          mergeContext.markVersionChanged(dest);
          if (mergeContext.getExternalDataSessionId() != null && dirtyCheckContext.isEntityChanged((Identifiable)dest)) {
            log.error(""String_Node_Str"",dest.toString(),oldVersion,newVersion);
            if (dirtyCheckContext.checkAndMarkNotDirty((Identifiable)dest,(Identifiable)obj)) {
              mergeContext.addConflict((Identifiable)dest,(Identifiable)obj);
              ignore=true;
            }
 else             mergeContext.setMergeUpdate(true);
          }
 else           mergeContext.setMergeUpdate(true);
        }
 else {
          if (dirtyCheckContext.isEntityChanged((Identifiable)dest))           mergeContext.setMergeUpdate(false);
 else           mergeContext.setMergeUpdate(true);
        }
      }
 else       if (!mergeContext.isResolvingConflict())       mergeContext.markVersionChanged(dest);
    }
 else     mergeContext.markVersionChanged(dest);
    if (!ignore)     defaultMerge(mergeContext,obj,dest,expr,parent,propertyName);
  }
 else   defaultMerge(mergeContext,obj,dest,expr,parent,propertyName);
  if (dest != null && !ignore && !mergeContext.isResolvingConflict()) {
    if (mergeContext.isMergeUpdate() && ((dest instanceof Identifiable && mergeContext.hasVersionChanged(dest)) || (!(dest instanceof Identifiable) && parent instanceof Identifiable && mergeContext.hasVersionChanged(parent))))     dirtyCheckContext.markNotDirty(dest,dest instanceof Identifiable ? null : (Identifiable)parent);
 else     if (dest instanceof Identifiable && obj instanceof Identifiable)     dirtyCheckContext.checkAndMarkNotDirty((Identifiable)dest,(Identifiable)obj);
  }
  if (dest != null)   log.debug(""String_Node_Str"",dest.toString());
  dataManager.startTracking(dest,parent);
  return dest;
}","/** 
 * @private Merge an entity coming from the server in the context
 * @param obj external entity
 * @param previous previously existing object in the context (null if no existing object)
 * @param expr current path from the context
 * @param parent parent object for collections
 * @param propertyName propertyName from the owner object
 * @return merged entity (=== previous when previous not null)
 */
private Object mergeEntity(MergeContext mergeContext,final Object obj,Object previous,Expression expr,Object parent,String propertyName){
  if (obj != null || previous != null)   log.debug(""String_Node_Str"",ObjectUtil.toString(obj),ObjectUtil.toString(previous),obj == previous ? ""String_Node_Str"" : ""String_Node_Str"");
  Object dest=obj;
  Object p=null;
  if (obj instanceof Lazyable && !((Lazyable)obj).isInitialized()) {
    final EntityDescriptor desc=dataManager.getEntityDescriptor(obj);
    if (desc.getIdPropertyName() != null) {
      p=entitiesByUid.find(new Matcher(){
        public boolean match(        Object o){
          return o.getClass().getName().equals(obj.getClass().getName()) && dataManager.getProperty(obj,desc.getIdPropertyName()).equals(dataManager.getProperty(o,desc.getIdPropertyName()));
        }
      }
);
      if (p != null) {
        previous=p;
        dest=previous;
      }
    }
  }
 else   if (obj instanceof Identifiable) {
    p=entitiesByUid.get(obj.getClass().getName() + ""String_Node_Str"" + getUid((Identifiable)obj));
    if (p != null) {
      if (obj == p)       return obj;
      previous=p;
      dest=previous;
    }
  }
  dataManager.stopTracking(previous,parent);
  if (dest != previous && previous != null && (ObjectUtil.objectEquals(dataManager,previous,obj) || (parent != null && !(previous instanceof Identifiable))))   dest=previous;
  if (dest == obj && p == null && obj != null && mergeContext.getSourceEntityManager() != null) {
    try {
      dest=TypeUtil.newInstance(obj.getClass(),Object.class);
      if (obj instanceof Identifiable)       ((Identifiable)dest).setUid(((Identifiable)obj).getUid());
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + obj.getClass(),e);
    }
  }
  if (obj instanceof Lazyable && !((Lazyable)obj).isInitialized() && ObjectUtil.objectEquals(dataManager,previous,obj)) {
    EntityDescriptor desc=dataManager.getEntityDescriptor(obj);
    if (desc.getVersionPropertyName() != null) {
      log.debug(""String_Node_Str"");
      dirtyCheckContext.markNotDirty(previous,null);
      return previous;
    }
  }
  if (dest instanceof Lazyable && !((Lazyable)dest).isInitialized())   log.debug(""String_Node_Str"",dest.toString());
  if (dest != null && dest instanceof Identifiable && dest == obj) {
    log.debug(""String_Node_Str"",obj.toString(),this.id);
  }
  boolean fromCache=(p != null && dest == p);
  if (!fromCache && dest instanceof Identifiable)   entitiesByUid.put((Identifiable)dest);
  mergeContext.putInCache(obj,dest);
  boolean ignore=false;
  if (dest instanceof Identifiable) {
    EntityDescriptor desc=dataManager.getEntityDescriptor(dest);
    if (mergeContext.isUninitializing() && parent instanceof Identifiable && propertyName != null) {
      if (desc.getVersionPropertyName() != null && dataManager.getProperty(obj,desc.getVersionPropertyName()) != null && dataManager.getEntityDescriptor(parent).isLazy(propertyName)) {
        if (defineProxy(desc,dest,obj))         return dest;
      }
    }
    attachEntity((Identifiable)dest,false);
    if (previous != null && dest == previous) {
      if (desc.getVersionPropertyName() != null && !mergeContext.isResolvingConflict()) {
        Number newVersion=(Number)dataManager.getProperty(obj,desc.getVersionPropertyName());
        Number oldVersion=(Number)dataManager.getProperty(dest,desc.getVersionPropertyName());
        if ((newVersion != null && oldVersion != null && newVersion.longValue() < oldVersion.longValue() || (newVersion == null && oldVersion != null))) {
          log.warn(""String_Node_Str"",dest.toString(),oldVersion,newVersion);
          ignore=true;
        }
 else         if ((newVersion != null && oldVersion != null && newVersion.longValue() > oldVersion.longValue()) || (newVersion != null && oldVersion == null)) {
          mergeContext.markVersionChanged(dest);
          if (mergeContext.getExternalDataSessionId() != null && dirtyCheckContext.isEntityChanged((Identifiable)dest)) {
            log.error(""String_Node_Str"",dest.toString(),oldVersion,newVersion);
            if (dirtyCheckContext.checkAndMarkNotDirty((Identifiable)dest,(Identifiable)obj)) {
              mergeContext.addConflict((Identifiable)dest,(Identifiable)obj);
              ignore=true;
            }
 else             mergeContext.setMergeUpdate(true);
          }
 else           mergeContext.setMergeUpdate(true);
        }
 else {
          if (dirtyCheckContext.isEntityChanged((Identifiable)dest))           mergeContext.setMergeUpdate(false);
 else           mergeContext.setMergeUpdate(true);
        }
      }
 else       if (!mergeContext.isResolvingConflict())       mergeContext.markVersionChanged(dest);
    }
 else     mergeContext.markVersionChanged(dest);
    if (!ignore)     defaultMerge(mergeContext,obj,dest,expr,parent,propertyName);
  }
 else   defaultMerge(mergeContext,obj,dest,expr,parent,propertyName);
  if (dest != null && !ignore && !mergeContext.isResolvingConflict()) {
    if (mergeContext.isMergeUpdate() && ((dest instanceof Identifiable && mergeContext.hasVersionChanged(dest)) || (!(dest instanceof Identifiable) && parent instanceof Identifiable && mergeContext.hasVersionChanged(parent))))     dirtyCheckContext.markNotDirty(dest,dest instanceof Identifiable ? null : (Identifiable)parent);
 else     if (dest instanceof Identifiable && obj instanceof Identifiable)     dirtyCheckContext.checkAndMarkNotDirty((Identifiable)dest,(Identifiable)obj);
  }
  if (dest != null)   log.debug(""String_Node_Str"",dest.toString());
  dataManager.startTracking(dest,parent);
  return dest;
}",0.9987577639751553
5834,"/** 
 * Subscribe the data topic
 */
public void subscribe(){
  consumer.addMessageListener(new MessageListenerImpl());
  consumer.subscribe(subscriptionListener);
  serverSession.checkWaitForLogout();
}","/** 
 * Subscribe the data topic
 */
public void subscribe(){
  consumer.addMessageListener(messageListener);
  consumer.subscribe(subscriptionListener);
  serverSession.checkWaitForLogout();
}",0.9696969696969696
5835,"public void unsubscribe(){
  consumer.unsubscribe(unsubscriptionListener);
  consumer.removeMessageListener(messageListener);
  serverSession.checkWaitForLogout();
}","public void unsubscribe(){
  if (consumer.isSubscribed()) {
    consumer.removeMessageListener(messageListener);
    consumer.unsubscribe(unsubscriptionListener);
    serverSession.checkWaitForLogout();
  }
}",0.6380697050938338
5836,"public boolean removeMessageListener(MessageListener listener){
  return listeners.remove(listener);
}","public boolean removeMessageListener(MessageListener listener){
  return listeners.remove(listener) != null;
}",0.9622641509433962
5837,"/** 
 * @private Internal implementation of entity reset
 */
@SuppressWarnings(""String_Node_Str"") public void resetEntity(MergeContext mergeContext,Object entity,Identifiable parent,Set<Object> cache){
  if (entity instanceof Lazyable && !((Lazyable)entity).isInitialized())   return;
  if (cache.contains(entity))   return;
  cache.add(entity);
  Map<String,Object> save=savedProperties.get(entity);
  EntityDescriptor desc=PersistenceManager.getEntityDescriptor(entity);
  Map<String,Object> pval=dataManager.getPropertyValues(entity,false,false);
  for (  String p : pval.keySet()) {
    if (p.equals(desc.getVersionPropertyName()))     continue;
    List<Object> removed=null;
    Object val=dataManager.getProperty(entity,p);
    if (val instanceof List<?> && !(val instanceof LazyableCollection && !((LazyableCollection)val).isInitialized())) {
      List<Object> list=(List<Object>)val;
      List<Change> savedArray=save != null ? (List<Change>)save.get(p) : null;
      if (savedArray != null) {
        for (int a=savedArray.size() - 1; a >= 0; a--) {
          if (a >= savedArray.size()) {
            log.debug(""String_Node_Str"",list);
            break;
          }
          Change ce=savedArray.get(a);
          if (ce.getKind() == ChangeKind.ADD) {
            if (removed == null)             removed=new ArrayList<Object>();
            for (int z=0; z < ce.getItems().length; z++) {
              if (ce.getLocation() < list.size())               removed.add(list.remove(ce.getLocation()));
 else               log.debug(""String_Node_Str"",list,ce.getLocation());
            }
          }
 else           if (ce.getKind() == ChangeKind.REMOVE) {
            for (int z=0; z < ce.getItems().length; z++) {
              if (ce.getLocation() + z <= list.size())               list.add(ce.getLocation() + z,ce.getItems()[z]);
 else               log.debug(""String_Node_Str"",list,ce.getLocation() + z);
            }
          }
 else           if (ce.getKind() == ChangeKind.REPLACE) {
            if (removed == null)             removed=new ArrayList<Object>();
            for (int z=0; z < ce.getItems().length; z++) {
              if (ce.getLocation() + z < list.size())               removed.add(list.set(ce.getLocation() + z,((Object[])ce.getItems()[z])[0]));
 else               log.debug(""String_Node_Str"",list,ce.getLocation() + z);
            }
          }
        }
        markNotDirty(val,parent);
      }
      for (      Object o : list) {
        if (o instanceof Identifiable)         resetEntity(mergeContext,o,(Identifiable)o,cache);
      }
      if (removed != null) {
        for (        Object o : removed) {
          if (o instanceof Identifiable)           resetEntity(mergeContext,o,(Identifiable)o,cache);
        }
      }
    }
 else     if (val instanceof Map<?,?> && !(val instanceof LazyableCollection && !((LazyableCollection)val).isInitialized())) {
      Map<Object,Object> map=(Map<Object,Object>)val;
      List<Change> savedArray=save != null ? (List<Change>)save.get(p) : null;
      if (savedArray != null) {
        for (int a=savedArray.size() - 1; a >= 0; a--) {
          Change ce=savedArray.get(a);
          if (ce.getKind() == ChangeKind.ADD) {
            if (removed == null)             removed=new ArrayList<Object>();
            for (int z=0; z < ce.getItems().length; z++) {
              removed.add(map.remove(((Object[])ce.getItems()[z])[0]));
              removed.add(((Object[])ce.getItems()[z])[0]);
            }
          }
 else           if (ce.getKind() == ChangeKind.REMOVE) {
            for (int z=0; z < ce.getItems().length; z++)             map.put(((Object[])ce.getItems()[z])[0],((Object[])ce.getItems()[z])[1]);
          }
 else           if (ce.getKind() == ChangeKind.REPLACE) {
            if (removed == null)             removed=new ArrayList<Object>();
            for (int z=0; z < ce.getItems().length; z++) {
              removed.add(map.put(((Object[])ce.getItems()[z])[0],((Object[])ce.getItems()[z])[1]));
            }
          }
        }
        markNotDirty(val,parent);
      }
      for (      Entry<Object,Object> me : map.entrySet()) {
        if (me.getKey() instanceof Identifiable)         resetEntity(mergeContext,me.getKey(),(Identifiable)me.getKey(),cache);
        if (me.getValue() instanceof Identifiable)         resetEntity(mergeContext,me.getValue(),(Identifiable)me.getValue(),cache);
      }
      if (removed != null) {
        for (        Object o : removed) {
          if (o instanceof Identifiable)           resetEntity(mergeContext,o,(Identifiable)o,cache);
        }
      }
    }
 else     if (save != null && (ObjectUtil.isSimple(val) || ObjectUtil.isSimple(save.get(p)))) {
      if (save.containsKey(p))       dataManager.setInternalProperty(entity,p,save.get(p));
    }
 else     if (save != null && (val instanceof Enum || save.get(p) instanceof Enum || val instanceof Value|| save.get(p) instanceof Value)) {
      if (save.containsKey(p))       dataManager.setInternalProperty(entity,p,save.get(p));
    }
 else     if (save != null && save.containsKey(p)) {
      if (!PersistenceManager.objectEquals(dataManager,val,save.get(p)))       dataManager.setInternalProperty(entity,p,save.get(p));
    }
 else     if (val instanceof Identifiable)     resetEntity(mergeContext,val,(Identifiable)val,cache);
 else     if (val != null && parent != null)     resetEntity(mergeContext,val,parent,cache);
  }
  markNotDirty(entity,null);
}","/** 
 * @private Internal implementation of entity reset
 */
@SuppressWarnings(""String_Node_Str"") public void resetEntity(MergeContext mergeContext,Object entity,Identifiable parent,Set<Object> cache){
  if (entity instanceof Lazyable && !((Lazyable)entity).isInitialized())   return;
  if (cache.contains(entity))   return;
  cache.add(entity);
  Map<String,Object> save=savedProperties.get(entity);
  EntityDescriptor desc=PersistenceManager.getEntityDescriptor(entity);
  Map<String,Object> pval=dataManager.getPropertyValues(entity,false,false);
  for (  String p : pval.keySet()) {
    if (p.equals(desc.getVersionPropertyName()))     continue;
    List<Object> removed=null;
    Object val=dataManager.getProperty(entity,p);
    if (val instanceof List<?> && !(val instanceof LazyableCollection && !((LazyableCollection)val).isInitialized())) {
      List<Object> list=(List<Object>)val;
      List<Change> savedArray=save != null ? (List<Change>)save.get(p) : null;
      if (savedArray != null) {
        for (int a=savedArray.size() - 1; a >= 0; a--) {
          if (a >= savedArray.size()) {
            log.debug(""String_Node_Str"",list);
            break;
          }
          Change ce=savedArray.get(a);
          if (ce.getKind() == ChangeKind.ADD) {
            if (removed == null)             removed=new ArrayList<Object>();
            for (int z=0; z < ce.getItems().length; z++) {
              if (ce.getLocation() < list.size())               removed.add(list.remove(ce.getLocation()));
 else               log.debug(""String_Node_Str"",list,ce.getLocation());
            }
          }
 else           if (ce.getKind() == ChangeKind.REMOVE) {
            for (int z=0; z < ce.getItems().length; z++) {
              if (ce.getLocation() + z <= list.size())               list.add(ce.getLocation() + z,ce.getItems()[z]);
 else               log.debug(""String_Node_Str"",list,ce.getLocation() + z);
            }
          }
 else           if (ce.getKind() == ChangeKind.REPLACE) {
            if (removed == null)             removed=new ArrayList<Object>();
            for (int z=0; z < ce.getItems().length; z++) {
              if (ce.getLocation() + z < list.size())               removed.add(list.set(ce.getLocation() + z,((Object[])ce.getItems()[z])[0]));
 else               log.debug(""String_Node_Str"",list,ce.getLocation() + z);
            }
          }
        }
        markNotDirty(val,parent);
      }
      for (      Object o : list) {
        if (o instanceof Identifiable)         resetEntity(mergeContext,o,(Identifiable)o,cache);
      }
      if (removed != null) {
        for (        Object o : removed) {
          if (o instanceof Identifiable)           resetEntity(mergeContext,o,(Identifiable)o,cache);
        }
      }
    }
 else     if (val instanceof Map<?,?> && !(val instanceof LazyableCollection && !((LazyableCollection)val).isInitialized())) {
      Map<Object,Object> map=(Map<Object,Object>)val;
      List<Change> savedArray=save != null ? (List<Change>)save.get(p) : null;
      if (savedArray != null) {
        for (int a=savedArray.size() - 1; a >= 0; a--) {
          Change ce=savedArray.get(a);
          if (ce.getKind() == ChangeKind.ADD) {
            if (removed == null)             removed=new ArrayList<Object>();
            for (int z=0; z < ce.getItems().length; z++) {
              removed.add(map.remove(((Object[])ce.getItems()[z])[0]));
              removed.add(((Object[])ce.getItems()[z])[0]);
            }
          }
 else           if (ce.getKind() == ChangeKind.REMOVE) {
            for (int z=0; z < ce.getItems().length; z++)             map.put(((Object[])ce.getItems()[z])[0],((Object[])ce.getItems()[z])[1]);
          }
 else           if (ce.getKind() == ChangeKind.REPLACE) {
            if (removed == null)             removed=new ArrayList<Object>();
            for (int z=0; z < ce.getItems().length; z++) {
              removed.add(map.put(((Object[])ce.getItems()[z])[0],((Object[])ce.getItems()[z])[1]));
            }
          }
        }
        markNotDirty(val,parent);
      }
      for (      Entry<Object,Object> me : map.entrySet()) {
        if (me.getKey() instanceof Identifiable)         resetEntity(mergeContext,me.getKey(),(Identifiable)me.getKey(),cache);
        if (me.getValue() instanceof Identifiable)         resetEntity(mergeContext,me.getValue(),(Identifiable)me.getValue(),cache);
      }
      if (removed != null) {
        for (        Object o : removed) {
          if (o instanceof Identifiable)           resetEntity(mergeContext,o,(Identifiable)o,cache);
        }
      }
    }
 else     if (save != null && (ObjectUtil.isSimple(val) || ObjectUtil.isSimple(save.get(p)))) {
      if (save.containsKey(p))       dataManager.setInternalProperty(entity,p,save.get(p));
    }
 else     if (save != null && (val instanceof Enum || save.get(p) instanceof Enum || val instanceof Value|| save.get(p) instanceof Value)) {
      if (save.containsKey(p))       dataManager.setInternalProperty(entity,p,save.get(p));
    }
 else     if (save != null && save.containsKey(p)) {
      if (!PersistenceManager.objectEquals(dataManager,val,save.get(p)))       dataManager.setInternalProperty(entity,p,save.get(p));
    }
 else     if (val instanceof Identifiable)     resetEntity(mergeContext,val,(Identifiable)val,cache);
 else     if (val != null && parent != null && !ObjectUtil.isSimple(val))     resetEntity(mergeContext,val,parent,cache);
  }
  markNotDirty(entity,null);
}",0.9973614775725592
5838,"/** 
 * Merge an object coming from the server in the context
 * @param obj external object
 * @param previous previously existing object in the context (null if no existing object)
 * @param expr current path from the context
 * @param parent parent object for collections
 * @param propertyName property name of the current object in the parent object
 * @param setter setter function to update the private property
 * @param forceUpdate force update of property (used for externalized properties)
 * @return merged object (should === previous when previous not null)
 */
@SuppressWarnings(""String_Node_Str"") public Object mergeExternal(final MergeContext mergeContext,Object obj,Object previous,Expression expr,Object parent,String propertyName,String setter,boolean forceUpdate){
  mergeContext.initMerge();
  boolean saveMergeUpdate=mergeContext.isMergeUpdate();
  boolean saveMerging=mergeContext.isMerging();
  try {
    mergeContext.setMerging(true);
    boolean addRef=false;
    boolean fromCache=false;
    Object prev=mergeContext.getFromCache(obj);
    Object next=obj;
    if (prev != null) {
      next=prev;
      fromCache=true;
    }
 else {
      dataManager.stopTracking(previous,parent);
      if (obj == null) {
        next=null;
      }
 else       if (((obj instanceof LazyableCollection && !((LazyableCollection)obj).isInitialized()) || (obj instanceof LazyableCollection && !(previous instanceof LazyableCollection))) && parent instanceof Identifiable && propertyName != null) {
        next=mergePersistentCollection(mergeContext,(LazyableCollection)obj,previous,null,(Identifiable)parent,propertyName);
        addRef=true;
      }
 else       if (obj instanceof List<?>) {
        next=mergeCollection(mergeContext,(List<Object>)obj,previous,parent == null ? expr : null,parent,propertyName);
        addRef=true;
      }
 else       if (obj instanceof Map<?,?>) {
        next=mergeMap(mergeContext,(Map<Object,Object>)obj,previous,parent == null ? expr : null,parent,propertyName);
        addRef=true;
      }
 else       if (obj instanceof Identifiable) {
        next=mergeEntity(mergeContext,obj,previous,expr,parent,propertyName);
        addRef=true;
      }
 else {
        boolean merged=false;
        if (customMergers != null) {
          for (          DataMerger merger : customMergers) {
            if (merger.accepts(obj)) {
              next=merger.merge(mergeContext,obj,previous,parent == null ? expr : null,parent,propertyName);
              dataManager.startTracking(previous,parent);
              merged=true;
              addRef=true;
            }
          }
        }
        if (!merged && !ObjectUtil.isSimple(obj) && !(obj instanceof Value || obj instanceof byte[])) {
          next=mergeEntity(mergeContext,obj,previous,expr,parent,propertyName);
          addRef=true;
        }
      }
    }
    if (next != null && !fromCache && addRef && (expr != null || (prev == null && parent != null))) {
      addReference(next,parent,propertyName,expr);
    }
    mergeContext.setMergeUpdate(saveMergeUpdate);
    if ((mergeContext.isMergeUpdate() || forceUpdate) && setter != null && parent != null && propertyName != null && parent instanceof Identifiable) {
      if (!mergeContext.isResolvingConflict() || !propertyName.equals(PersistenceManager.getEntityDescriptor(parent).getVersionPropertyName())) {
        dataManager.setProperty(parent,propertyName,previous,next);
      }
    }
    if (entityManagerPropagation != null && (mergeContext.isMergeUpdate() || forceUpdate) && !fromCache && obj instanceof Identifiable) {
      entityManagerPropagation.propagate((Identifiable)obj,new Function(){
        public void execute(        EntityManager entityManager,        Identifiable entity){
          if (entityManager == mergeContext.getSourceEntityManager())           return;
          if (entityManager.getCachedObject(entity,true) != null)           entityManager.mergeFromEntityManager(entityManager,entity,mergeContext.getExternalDataSessionId(),mergeContext.isUninitializing());
        }
      }
);
    }
    return next;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
 finally {
    mergeContext.setMerging(saveMerging);
  }
}","/** 
 * Merge an object coming from the server in the context
 * @param obj external object
 * @param previous previously existing object in the context (null if no existing object)
 * @param expr current path from the context
 * @param parent parent object for collections
 * @param propertyName property name of the current object in the parent object
 * @param setter setter function to update the private property
 * @param forceUpdate force update of property (used for externalized properties)
 * @return merged object (should === previous when previous not null)
 */
@SuppressWarnings(""String_Node_Str"") public Object mergeExternal(final MergeContext mergeContext,Object obj,Object previous,Expression expr,Object parent,String propertyName,String setter,boolean forceUpdate){
  mergeContext.initMerge();
  boolean saveMergeUpdate=mergeContext.isMergeUpdate();
  boolean saveMerging=mergeContext.isMerging();
  try {
    mergeContext.setMerging(true);
    boolean addRef=false;
    boolean fromCache=false;
    Object prev=mergeContext.getFromCache(obj);
    Object next=obj;
    if (prev != null) {
      next=prev;
      fromCache=true;
    }
 else {
      dataManager.stopTracking(previous,parent);
      if (obj == null) {
        next=null;
      }
 else       if (((obj instanceof LazyableCollection && !((LazyableCollection)obj).isInitialized()) || (obj instanceof LazyableCollection && !(previous instanceof LazyableCollection))) && parent instanceof Identifiable && propertyName != null) {
        next=mergePersistentCollection(mergeContext,(LazyableCollection)obj,previous,null,(Identifiable)parent,propertyName);
        addRef=true;
      }
 else       if (obj instanceof List<?>) {
        next=mergeCollection(mergeContext,(List<Object>)obj,previous,parent == null ? expr : null,parent,propertyName);
        addRef=true;
      }
 else       if (obj instanceof Map<?,?>) {
        next=mergeMap(mergeContext,(Map<Object,Object>)obj,previous,parent == null ? expr : null,parent,propertyName);
        addRef=true;
      }
 else       if (obj instanceof Identifiable) {
        next=mergeEntity(mergeContext,obj,previous,expr,parent,propertyName);
        addRef=true;
      }
 else {
        boolean merged=false;
        if (customMergers != null) {
          for (          DataMerger merger : customMergers) {
            if (merger.accepts(obj)) {
              next=merger.merge(mergeContext,obj,previous,parent == null ? expr : null,parent,propertyName);
              dataManager.startTracking(previous,parent);
              merged=true;
              addRef=true;
            }
          }
        }
        if (!merged && !ObjectUtil.isSimple(obj) && !(obj instanceof Value || obj instanceof byte[])) {
          next=mergeEntity(mergeContext,obj,previous,expr,parent,propertyName);
          addRef=true;
        }
      }
    }
    if (next != null && !fromCache && addRef && (expr != null || (prev == null && parent != null))) {
      addReference(next,parent,propertyName,expr);
    }
    mergeContext.setMergeUpdate(saveMergeUpdate);
    if ((mergeContext.isMergeUpdate() || forceUpdate) && setter != null && parent != null && propertyName != null && parent instanceof Identifiable && next != previous) {
      if (!mergeContext.isResolvingConflict() || !propertyName.equals(PersistenceManager.getEntityDescriptor(parent).getVersionPropertyName())) {
        dataManager.setProperty(parent,propertyName,previous,next);
      }
    }
    if (entityManagerPropagation != null && (mergeContext.isMergeUpdate() || forceUpdate) && !fromCache && obj instanceof Identifiable) {
      entityManagerPropagation.propagate((Identifiable)obj,new Function(){
        public void execute(        EntityManager entityManager,        Identifiable entity){
          if (entityManager == mergeContext.getSourceEntityManager())           return;
          if (entityManager.getCachedObject(entity,true) != null)           entityManager.mergeFromEntityManager(entityManager,entity,mergeContext.getExternalDataSessionId(),mergeContext.isUninitializing());
        }
      }
);
    }
    return next;
  }
 catch (  Exception e) {
    log.error(e,""String_Node_Str"");
    return null;
  }
 finally {
    mergeContext.setMerging(saveMerging);
  }
}",0.9928142301802332
5839,"/** 
 * @private Merge an entity coming from the server in the context
 * @param obj external entity
 * @param previous previously existing object in the context (null if no existing object)
 * @param expr current path from the context
 * @param parent parent object for collections
 * @param propertyName propertyName from the owner object
 * @return merged entity (=== previous when previous not null)
 */
private Object mergeEntity(MergeContext mergeContext,final Object obj,Object previous,Expression expr,Object parent,String propertyName){
  if (obj != null || previous != null)   log.debug(""String_Node_Str"",ObjectUtil.toString(obj),ObjectUtil.toString(previous),obj == previous ? ""String_Node_Str"" : ""String_Node_Str"");
  Object dest=obj;
  Object p=null;
  if (obj instanceof Lazyable && !((Lazyable)obj).isInitialized()) {
    final EntityDescriptor desc=PersistenceManager.getEntityDescriptor(obj);
    if (desc.getIdPropertyName() != null) {
      p=entitiesByUid.find(new Matcher(){
        public boolean match(        Object o){
          return o.getClass().getName().equals(obj.getClass().getName()) && dataManager.getProperty(obj,desc.getIdPropertyName()).equals(dataManager.getProperty(o,desc.getIdPropertyName()));
        }
      }
);
      if (p != null) {
        previous=p;
        dest=previous;
      }
    }
  }
 else   if (obj instanceof Identifiable) {
    p=entitiesByUid.get(obj.getClass().getName() + ""String_Node_Str"" + ((Identifiable)obj).getUid());
    if (p != null) {
      if (obj == p)       return obj;
      previous=p;
      dest=previous;
    }
  }
  if (dest != previous && previous != null && (PersistenceManager.objectEquals(dataManager,previous,obj) || (parent != null && !(previous instanceof Identifiable))))   dest=previous;
  if (dest == obj && p == null && obj != null && mergeContext.getSourceEntityManager() != null) {
    try {
      dest=ClassUtil.newInstance(obj.getClass(),Object.class);
      if (obj instanceof Identifiable)       ((Identifiable)dest).setUid(((Identifiable)obj).getUid());
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + obj.getClass(),e);
    }
  }
  if (obj instanceof Lazyable && !((Lazyable)obj).isInitialized() && PersistenceManager.objectEquals(dataManager,previous,obj)) {
    EntityDescriptor desc=PersistenceManager.getEntityDescriptor(obj);
    if (desc.getVersionPropertyName() != null) {
      log.debug(""String_Node_Str"");
      dirtyCheckContext.markNotDirty(previous,null);
      return previous;
    }
  }
  if (dest instanceof Lazyable && !((Lazyable)dest).isInitialized())   log.debug(""String_Node_Str"",dest.toString());
  if (dest != null && dest instanceof Identifiable && dest == obj) {
    log.debug(""String_Node_Str"",obj.toString(),this.id);
  }
  boolean fromCache=(p != null && dest == p);
  if (!fromCache && dest instanceof Identifiable)   entitiesByUid.put((Identifiable)dest);
  mergeContext.putInCache(obj,dest);
  boolean ignore=false;
  if (dest instanceof Identifiable) {
    EntityDescriptor desc=PersistenceManager.getEntityDescriptor(dest);
    if (mergeContext.isUninitializing() && parent instanceof Identifiable && propertyName != null) {
      if (desc.getVersionPropertyName() != null && dataManager.getProperty(obj,desc.getVersionPropertyName()) != null && PersistenceManager.getEntityDescriptor(parent).isLazy(propertyName)) {
        if (defineProxy(desc,dest,obj))         return dest;
      }
    }
    attachEntity((Identifiable)dest,false);
    if (previous != null && dest == previous) {
      if (desc.getVersionPropertyName() != null && !mergeContext.isResolvingConflict()) {
        Number newVersion=(Number)dataManager.getProperty(obj,desc.getVersionPropertyName());
        Number oldVersion=(Number)dataManager.getProperty(dest,desc.getVersionPropertyName());
        if ((newVersion != null && oldVersion != null && newVersion.longValue() < oldVersion.longValue() || (newVersion == null && oldVersion != null))) {
          log.warn(""String_Node_Str"",dest.toString(),oldVersion,newVersion);
          ignore=true;
        }
 else         if ((newVersion != null && oldVersion != null && newVersion.longValue() > oldVersion.longValue()) || (newVersion != null && oldVersion == null)) {
          mergeContext.markVersionChanged(dest);
          if (mergeContext.getExternalDataSessionId() != null && dirtyCheckContext.isEntityChanged((Identifiable)dest)) {
            log.error(""String_Node_Str"",dest.toString(),oldVersion,newVersion);
            if (dirtyCheckContext.checkAndMarkNotDirty((Identifiable)dest,(Identifiable)obj)) {
              mergeContext.addConflict((Identifiable)dest,(Identifiable)obj);
              ignore=true;
            }
 else             mergeContext.setMergeUpdate(true);
          }
 else           mergeContext.setMergeUpdate(true);
        }
 else {
          if (dirtyCheckContext.isEntityChanged((Identifiable)dest))           mergeContext.setMergeUpdate(false);
 else           mergeContext.setMergeUpdate(true);
        }
      }
 else       if (!mergeContext.isResolvingConflict())       mergeContext.markVersionChanged(dest);
    }
 else     mergeContext.markVersionChanged(dest);
    if (!ignore)     defaultMerge(mergeContext,obj,dest,expr,parent,propertyName);
  }
 else   defaultMerge(mergeContext,obj,dest,expr,parent,propertyName);
  if (dest != null && !ignore && !mergeContext.isResolvingConflict()) {
    if (mergeContext.isMergeUpdate() && mergeContext.hasVersionChanged(dest))     dirtyCheckContext.markNotDirty(dest,null);
 else     if (dest instanceof Identifiable && obj instanceof Identifiable)     dirtyCheckContext.checkAndMarkNotDirty((Identifiable)dest,(Identifiable)obj);
  }
  if (dest != null)   log.debug(""String_Node_Str"",dest.toString());
  dataManager.startTracking(dest,parent);
  return dest;
}","/** 
 * @private Merge an entity coming from the server in the context
 * @param obj external entity
 * @param previous previously existing object in the context (null if no existing object)
 * @param expr current path from the context
 * @param parent parent object for collections
 * @param propertyName propertyName from the owner object
 * @return merged entity (=== previous when previous not null)
 */
private Object mergeEntity(MergeContext mergeContext,final Object obj,Object previous,Expression expr,Object parent,String propertyName){
  if (obj != null || previous != null)   log.debug(""String_Node_Str"",ObjectUtil.toString(obj),ObjectUtil.toString(previous),obj == previous ? ""String_Node_Str"" : ""String_Node_Str"");
  Object dest=obj;
  Object p=null;
  if (obj instanceof Lazyable && !((Lazyable)obj).isInitialized()) {
    final EntityDescriptor desc=PersistenceManager.getEntityDescriptor(obj);
    if (desc.getIdPropertyName() != null) {
      p=entitiesByUid.find(new Matcher(){
        public boolean match(        Object o){
          return o.getClass().getName().equals(obj.getClass().getName()) && dataManager.getProperty(obj,desc.getIdPropertyName()).equals(dataManager.getProperty(o,desc.getIdPropertyName()));
        }
      }
);
      if (p != null) {
        previous=p;
        dest=previous;
      }
    }
  }
 else   if (obj instanceof Identifiable) {
    p=entitiesByUid.get(obj.getClass().getName() + ""String_Node_Str"" + ((Identifiable)obj).getUid());
    if (p != null) {
      if (obj == p)       return obj;
      previous=p;
      dest=previous;
    }
  }
  if (dest != previous && previous != null && (PersistenceManager.objectEquals(dataManager,previous,obj) || (parent != null && !(previous instanceof Identifiable))))   dest=previous;
  if (dest == obj && p == null && obj != null && mergeContext.getSourceEntityManager() != null) {
    try {
      dest=ClassUtil.newInstance(obj.getClass(),Object.class);
      if (obj instanceof Identifiable)       ((Identifiable)dest).setUid(((Identifiable)obj).getUid());
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + obj.getClass(),e);
    }
  }
  if (obj instanceof Lazyable && !((Lazyable)obj).isInitialized() && PersistenceManager.objectEquals(dataManager,previous,obj)) {
    EntityDescriptor desc=PersistenceManager.getEntityDescriptor(obj);
    if (desc.getVersionPropertyName() != null) {
      log.debug(""String_Node_Str"");
      dirtyCheckContext.markNotDirty(previous,null);
      return previous;
    }
  }
  if (dest instanceof Lazyable && !((Lazyable)dest).isInitialized())   log.debug(""String_Node_Str"",dest.toString());
  if (dest != null && dest instanceof Identifiable && dest == obj) {
    log.debug(""String_Node_Str"",obj.toString(),this.id);
  }
  boolean fromCache=(p != null && dest == p);
  if (!fromCache && dest instanceof Identifiable)   entitiesByUid.put((Identifiable)dest);
  mergeContext.putInCache(obj,dest);
  boolean ignore=false;
  if (dest instanceof Identifiable) {
    EntityDescriptor desc=PersistenceManager.getEntityDescriptor(dest);
    if (mergeContext.isUninitializing() && parent instanceof Identifiable && propertyName != null) {
      if (desc.getVersionPropertyName() != null && dataManager.getProperty(obj,desc.getVersionPropertyName()) != null && PersistenceManager.getEntityDescriptor(parent).isLazy(propertyName)) {
        if (defineProxy(desc,dest,obj))         return dest;
      }
    }
    attachEntity((Identifiable)dest,false);
    if (previous != null && dest == previous) {
      if (desc.getVersionPropertyName() != null && !mergeContext.isResolvingConflict()) {
        Number newVersion=(Number)dataManager.getProperty(obj,desc.getVersionPropertyName());
        Number oldVersion=(Number)dataManager.getProperty(dest,desc.getVersionPropertyName());
        if ((newVersion != null && oldVersion != null && newVersion.longValue() < oldVersion.longValue() || (newVersion == null && oldVersion != null))) {
          log.warn(""String_Node_Str"",dest.toString(),oldVersion,newVersion);
          ignore=true;
        }
 else         if ((newVersion != null && oldVersion != null && newVersion.longValue() > oldVersion.longValue()) || (newVersion != null && oldVersion == null)) {
          mergeContext.markVersionChanged(dest);
          if (mergeContext.getExternalDataSessionId() != null && dirtyCheckContext.isEntityChanged((Identifiable)dest)) {
            log.error(""String_Node_Str"",dest.toString(),oldVersion,newVersion);
            if (dirtyCheckContext.checkAndMarkNotDirty((Identifiable)dest,(Identifiable)obj)) {
              mergeContext.addConflict((Identifiable)dest,(Identifiable)obj);
              ignore=true;
            }
 else             mergeContext.setMergeUpdate(true);
          }
 else           mergeContext.setMergeUpdate(true);
        }
 else {
          if (dirtyCheckContext.isEntityChanged((Identifiable)dest))           mergeContext.setMergeUpdate(false);
 else           mergeContext.setMergeUpdate(true);
        }
      }
 else       if (!mergeContext.isResolvingConflict())       mergeContext.markVersionChanged(dest);
    }
 else     mergeContext.markVersionChanged(dest);
    if (!ignore)     defaultMerge(mergeContext,obj,dest,expr,parent,propertyName);
  }
 else   defaultMerge(mergeContext,obj,dest,expr,parent,propertyName);
  if (dest != null && !ignore && !mergeContext.isResolvingConflict()) {
    if (mergeContext.isMergeUpdate() && ((dest instanceof Identifiable && mergeContext.hasVersionChanged(dest)) || (!(dest instanceof Identifiable) && parent instanceof Identifiable && mergeContext.hasVersionChanged(parent))))     dirtyCheckContext.markNotDirty(dest,dest instanceof Identifiable ? null : (Identifiable)parent);
 else     if (dest instanceof Identifiable && obj instanceof Identifiable)     dirtyCheckContext.checkAndMarkNotDirty((Identifiable)dest,(Identifiable)obj);
  }
  if (dest != null)   log.debug(""String_Node_Str"",dest.toString());
  dataManager.startTracking(dest,parent);
  return dest;
}",0.9822315789473683
5840,"public BooleanProperty dirtyProperty(){
  return dirty;
}","public ReadOnlyBooleanProperty dirtyProperty(){
  return dirty;
}",0.9344262295081968
5841,"public void configure(Object instance){
  if (instance instanceof ServerSession)   ((ServerSession)instance).setStatus(serverSessionStatus);
}","@Override public void configure(GraniteConfig graniteConfig){
  graniteConfig.registerClassAlias(PersistentSet.class);
  graniteConfig.registerClassAlias(PersistentBag.class);
  graniteConfig.registerClassAlias(PersistentList.class);
  graniteConfig.registerClassAlias(PersistentMap.class);
}",0.1566820276497695
5842,"public void removeListener(ListChangeListener<? super T> listener){
  ListChangeListener<? super T> listenerWrapper=listenerWrappers.remove(listener);
  oset.removeListener(listenerWrapper);
}","public void removeListener(ListChangeListener<? super T> listener){
  ListChangeListener<? super T> listenerWrapper=listenerWrappers.remove(listener);
  if (listenerWrapper != null)   oset.removeListener(listenerWrapper);
}",0.9253012048192772
5843,"public void removeListener(ListChangeListener<? super T> listener){
  ListChangeListener<? super T> listenerWrapper=listenerWrappers.remove(listener);
  oset.removeListener(listenerWrapper);
}","public void removeListener(ListChangeListener<? super T> listener){
  ListChangeListener<? super T> listenerWrapper=listenerWrappers.remove(listener);
  if (listenerWrapper != null)   oset.removeListener(listenerWrapper);
}",0.9253012048192772
5844,"public void removeListener(MapChangeListener<? super K,? super V> listener){
  MapChangeListener<? super K,? super V> listenerWrapper=listenerWrappers.remove(listener);
  omap.removeListener(listenerWrapper);
}","public void removeListener(MapChangeListener<? super K,? super V> listener){
  MapChangeListener<? super K,? super V> listenerWrapper=listenerWrappers.remove(listener);
  if (listenerWrapper != null)   omap.removeListener(listenerWrapper);
}",0.9312638580931264
5845,"public void removeListener(ListChangeListener<? super T> listener){
  ListChangeListener<? super T> listenerWrapper=listenerWrappers.remove(listener);
  oset.removeListener(listenerWrapper);
}","public void removeListener(ListChangeListener<? super T> listener){
  ListChangeListener<? super T> listenerWrapper=listenerWrappers.remove(listener);
  if (listenerWrapper != null)   oset.removeListener(listenerWrapper);
}",0.9253012048192772
5846,"public static Object load(final Context context,String url,Class<?> controllerClass) throws IOException {
  InputStream fxmlStream=null;
  try {
    fxmlStream=controllerClass.getResourceAsStream(url);
    FXMLLoader loader=new FXMLLoader();
    loader.setControllerFactory(new Callback<Class<?>,Object>(){
      @Override public Object call(      Class<?> type){
        return context.byType(type);
      }
    }
);
    loader.getNamespace().put(""String_Node_Str"",context);
    for (    String name : context.allNames())     loader.getNamespace().put(name,context.byName(name));
    return loader.load(fxmlStream);
  }
  finally {
    if (fxmlStream != null) {
      fxmlStream.close();
    }
  }
}","public static Object load(final Context context,String url,Class<?> controllerClass) throws IOException {
  InputStream fxmlStream=null;
  try {
    fxmlStream=controllerClass.getResourceAsStream(url);
    FXMLLoader loader=new FXMLLoader();
    loader.setControllerFactory(new Callback<Class<?>,Object>(){
      @Override public Object call(      Class<?> type){
        return context.byType(type);
      }
    }
);
    for (    String name : context.allNames())     loader.getNamespace().put(name,context.byName(name));
    return loader.load(fxmlStream);
  }
  finally {
    if (fxmlStream != null) {
      fxmlStream.close();
    }
  }
}",0.9567809239940388
5847,"@Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
}","@Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
  beanFactory.registerSingleton(""String_Node_Str"",getContext(null));
  beanFactory.registerSingleton(""String_Node_Str"",getContext(null).getEntityManager());
  beanFactory.registerSingleton(""String_Node_Str"",getContext(null).getDataManager());
}",0.4862579281183932
5848,"public static boolean getFileFromServer(String path,Bundle params,OutputStream fos){
  byte[] bf=new byte[FILE_BUFFER_SIZE];
  int current=0;
  InputStream is=null;
  HttpURLConnection connect=null;
  BufferedInputStream bis=null;
  try {
    if (params != null) {
      StringBuilder sb=new StringBuilder();
      boolean first=true;
      for (      String key : params.keySet()) {
        if (first) {
          first=false;
        }
 else {
          sb.append(""String_Node_Str"");
        }
        sb.append(URLEncoder.encode(key) + ""String_Node_Str"" + URLEncoder.encode(params.getString(key)));
      }
      path=path + ""String_Node_Str"" + sb.toString();
    }
    URL url=new URL(path);
    connect=(HttpURLConnection)url.openConnection();
    connect.setDoInput(true);
    connect.setConnectTimeout(CONNECTION_TIME_OUT);
    connect.setReadTimeout(SOCKET_TIME_OUT);
    int code=connect.getResponseCode();
    if (code == HttpURLConnection.HTTP_OK) {
      is=connect.getInputStream();
      bis=new BufferedInputStream(is);
      while ((current=bis.read(bf)) != FILE_END) {
        fos.write(bf,0,current);
      }
    }
    return true;
  }
 catch (  MalformedURLException e) {
    LogUtils.logD(e.getMessage());
    return false;
  }
catch (  IOException e) {
    LogUtils.logD(e.getMessage());
    return false;
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
    return false;
  }
 finally {
    try {
      if (is != null) {
        is.close();
      }
      if (fos != null) {
        fos.close();
      }
      if (connect != null) {
        connect.disconnect();
      }
      if (bis != null) {
        bis.close();
      }
    }
 catch (    Exception e) {
      LogUtils.logD(e.getMessage());
    }
  }
}","public static void getFileFromServer(String path,Bundle params,String filePath){
  byte[] bf=new byte[FILE_BUFFER_SIZE];
  int current=0;
  InputStream is=null;
  HttpURLConnection connect=null;
  BufferedInputStream bis=null;
  OutputStream fos=null;
  try {
    fos=new FileOutputStream(filePath);
    String completePath=null;
    if (params != null) {
      StringBuilder sb=new StringBuilder();
      sb.append(path).append('?');
      boolean first=true;
      for (      String key : params.keySet()) {
        if (!first) {
          sb.append('&');
        }
 else {
          first=false;
        }
        sb.append(URLEncoder.encode(key)).append('=').append(URLEncoder.encode(params.getString(key)));
      }
      completePath=sb.toString();
    }
    URL url=new URL(completePath);
    connect=(HttpURLConnection)url.openConnection();
    connect.setDoInput(true);
    connect.setConnectTimeout(CONNECTION_TIME_OUT);
    connect.setReadTimeout(SOCKET_TIME_OUT);
    int code=connect.getResponseCode();
    if (code == HttpURLConnection.HTTP_OK) {
      is=connect.getInputStream();
      bis=new BufferedInputStream(is);
      while ((current=bis.read(bf)) != FILE_END) {
        fos.write(bf,0,current);
      }
    }
  }
 catch (  MalformedURLException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  IOException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
 finally {
    try {
      if (bis != null) {
        bis.close();
      }
      if (is != null) {
        is.close();
      }
      if (fos != null) {
        fos.close();
      }
      if (connect != null) {
        connect.disconnect();
      }
    }
 catch (    IOException e) {
      LogUtils.logD(e.getMessage());
    }
  }
}",0.8602334187304298
5849,"public static String doRequestGet(String url,Bundle params){
  if (params != null) {
    StringBuilder sb=new StringBuilder();
    boolean first=true;
    for (    String key : params.keySet()) {
      if (first) {
        first=false;
      }
 else {
        sb.append(""String_Node_Str"");
      }
      sb.append(URLEncoder.encode(key) + ""String_Node_Str"" + URLEncoder.encode(params.getString(key)));
    }
    url=url + ""String_Node_Str"" + sb.toString();
  }
  HttpParams httpParameters=new BasicHttpParams();
  HttpConnectionParams.setConnectionTimeout(httpParameters,CONNECTION_TIME_OUT);
  HttpConnectionParams.setSoTimeout(httpParameters,SOCKET_TIME_OUT);
  try {
    HttpGet httpRequest=new HttpGet(url);
    HttpResponse httpResponse=new DefaultHttpClient(httpParameters).execute(httpRequest);
    if (httpResponse.getStatusLine().getStatusCode() == SUCCESS_STATUS) {
      String strResult=EntityUtils.toString(httpResponse.getEntity());
      return strResult;
    }
 else {
      LogUtils.logD(""String_Node_Str"");
      return null;
    }
  }
 catch (  Exception e) {
    LogUtils.logD(e.getMessage());
    return null;
  }
}","public static String doRequestGet(String url,Bundle params){
  String newUrl=null;
  if (params != null) {
    StringBuilder sb=new StringBuilder();
    sb.append(url).append('?');
    boolean first=true;
    for (    String key : params.keySet()) {
      if (!first) {
        sb.append('&');
      }
 else {
        first=false;
      }
      sb.append(URLEncoder.encode(key)).append('=').append(URLEncoder.encode(params.getString(key)));
    }
    newUrl=sb.toString();
  }
  HttpParams httpParameters=new BasicHttpParams();
  HttpConnectionParams.setConnectionTimeout(httpParameters,CONNECTION_TIME_OUT);
  HttpConnectionParams.setSoTimeout(httpParameters,SOCKET_TIME_OUT);
  try {
    HttpGet httpRequest=new HttpGet(newUrl);
    HttpResponse httpResponse=new DefaultHttpClient(httpParameters).execute(httpRequest);
    if (httpResponse.getStatusLine().getStatusCode() == SUCCESS_STATUS) {
      return EntityUtils.toString(httpResponse.getEntity());
    }
 else {
      LogUtils.logD(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return null;
}",0.853309481216458
5850,"public static void getFileFromServer(String path,Bundle params,String filePath){
  byte[] bf=new byte[FILE_BUFFER_SIZE];
  int current=0;
  InputStream is=null;
  HttpURLConnection connect=null;
  BufferedInputStream bis=null;
  OutputStream fos=null;
  try {
    fos=new FileOutputStream(filePath);
    String completePath=null;
    if (params != null) {
      StringBuilder sb=new StringBuilder();
      sb.append(path).append('?');
      boolean first=true;
      for (      String key : params.keySet()) {
        if (!first) {
          sb.append('&');
        }
 else {
          first=false;
        }
        sb.append(URLEncoder.encode(key)).append('=').append(URLEncoder.encode(params.getString(key)));
      }
      completePath=sb.toString();
    }
    URL url=new URL(completePath);
    connect=(HttpURLConnection)url.openConnection();
    connect.setDoInput(true);
    connect.setConnectTimeout(CONNECTION_TIME_OUT);
    connect.setReadTimeout(SOCKET_TIME_OUT);
    int code=connect.getResponseCode();
    if (code == HttpURLConnection.HTTP_OK) {
      is=connect.getInputStream();
      bis=new BufferedInputStream(is);
      while ((current=bis.read(bf)) != FILE_END) {
        fos.write(bf,0,current);
      }
    }
  }
 catch (  MalformedURLException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  IOException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
 finally {
    try {
      if (bis != null) {
        bis.close();
      }
      if (is != null) {
        is.close();
      }
      if (fos != null) {
        fos.close();
      }
      if (connect != null) {
        connect.disconnect();
      }
    }
 catch (    IOException e) {
      LogUtils.logD(e.getMessage());
    }
  }
}","public static void getFileFromServer(String path,Bundle params,String filePath){
  byte[] bf=new byte[FILE_BUFFER_SIZE];
  int current=0;
  InputStream is=null;
  HttpURLConnection connect=null;
  BufferedInputStream bis=null;
  OutputStream fos=null;
  try {
    fos=new FileOutputStream(filePath);
    String completePath=path;
    if (params != null && !params.isEmpty()) {
      StringBuilder sb=new StringBuilder();
      sb.append(path).append('?');
      boolean first=true;
      for (      String key : params.keySet()) {
        if (!first) {
          sb.append('&');
        }
 else {
          first=false;
        }
        sb.append(URLEncoder.encode(key)).append('=').append(URLEncoder.encode(params.getString(key)));
      }
      completePath=sb.toString();
    }
    URL url=new URL(completePath);
    connect=(HttpURLConnection)url.openConnection();
    connect.setDoInput(true);
    connect.setConnectTimeout(CONNECTION_TIME_OUT);
    connect.setReadTimeout(SOCKET_TIME_OUT);
    int code=connect.getResponseCode();
    if (code == HttpURLConnection.HTTP_OK) {
      is=connect.getInputStream();
      bis=new BufferedInputStream(is);
      while ((current=bis.read(bf)) != FILE_END) {
        fos.write(bf,0,current);
      }
    }
  }
 catch (  MalformedURLException e) {
    LogUtils.logE(e.getMessage());
  }
catch (  IOException e) {
    LogUtils.logE(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logE(e.getMessage());
  }
 finally {
    try {
      if (bis != null) {
        bis.close();
      }
      if (is != null) {
        is.close();
      }
      if (fos != null) {
        fos.close();
      }
      if (connect != null) {
        connect.disconnect();
      }
    }
 catch (    IOException e) {
      LogUtils.logE(e.getMessage());
    }
  }
}",0.9896213183730715
5851,"public static String doRequestGet(String url,Bundle params){
  String newUrl=null;
  if (params != null) {
    StringBuilder sb=new StringBuilder();
    sb.append(url).append('?');
    boolean first=true;
    for (    String key : params.keySet()) {
      if (!first) {
        sb.append('&');
      }
 else {
        first=false;
      }
      sb.append(URLEncoder.encode(key)).append('=').append(URLEncoder.encode(params.getString(key)));
    }
    newUrl=sb.toString();
  }
  HttpParams httpParameters=new BasicHttpParams();
  HttpConnectionParams.setConnectionTimeout(httpParameters,CONNECTION_TIME_OUT);
  HttpConnectionParams.setSoTimeout(httpParameters,SOCKET_TIME_OUT);
  try {
    HttpGet httpRequest=new HttpGet(newUrl);
    HttpResponse httpResponse=new DefaultHttpClient(httpParameters).execute(httpRequest);
    if (httpResponse.getStatusLine().getStatusCode() == SUCCESS_STATUS) {
      return EntityUtils.toString(httpResponse.getEntity());
    }
 else {
      LogUtils.logD(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return null;
}","public static String doRequestGet(String url,Bundle params){
  String newUrl=null;
  if (params != null) {
    StringBuilder sb=new StringBuilder();
    sb.append(url).append('?');
    boolean first=true;
    for (    String key : params.keySet()) {
      if (!first) {
        sb.append('&');
      }
 else {
        first=false;
      }
      sb.append(URLEncoder.encode(key)).append('=').append(URLEncoder.encode(params.getString(key)));
    }
    newUrl=sb.toString();
  }
  HttpParams httpParameters=new BasicHttpParams();
  HttpConnectionParams.setConnectionTimeout(httpParameters,CONNECTION_TIME_OUT);
  HttpConnectionParams.setSoTimeout(httpParameters,SOCKET_TIME_OUT);
  try {
    HttpGet httpRequest=new HttpGet(newUrl);
    HttpResponse httpResponse=new DefaultHttpClient(httpParameters).execute(httpRequest);
    if (httpResponse.getStatusLine().getStatusCode() == SUCCESS_STATUS) {
      return EntityUtils.toString(httpResponse.getEntity());
    }
 else {
      LogUtils.logD(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    LogUtils.logE(e.getMessage());
  }
  return null;
}",0.9990909090909093
5852,"public static String doRequestPost(String url,Bundle params){
  ArrayList<BasicNameValuePair> paramsList=new ArrayList<BasicNameValuePair>();
  BasicNameValuePair paramPair;
  if (params != null) {
    for (    String key : params.keySet()) {
      paramPair=new BasicNameValuePair(key,params.getString(key));
      paramsList.add(paramPair);
    }
  }
  HttpParams httpParameters=new BasicHttpParams();
  HttpConnectionParams.setConnectionTimeout(httpParameters,CONNECTION_TIME_OUT);
  HttpConnectionParams.setSoTimeout(httpParameters,SOCKET_TIME_OUT);
  try {
    HttpPost httpRequest=new HttpPost(url);
    httpRequest.setEntity(new UrlEncodedFormEntity(paramsList,HTTP.UTF_8));
    HttpResponse httpResponse=new DefaultHttpClient(httpParameters).execute(httpRequest);
    if (httpResponse.getStatusLine().getStatusCode() == SUCCESS_STATUS) {
      String strResult=EntityUtils.toString(httpResponse.getEntity());
      return strResult;
    }
 else {
      LogUtils.logD(""String_Node_Str"");
      return null;
    }
  }
 catch (  Exception e) {
    LogUtils.logD(e.getMessage());
    return null;
  }
}","public static String doRequestPost(String url,Bundle params){
  ArrayList<BasicNameValuePair> paramsList=new ArrayList<BasicNameValuePair>();
  BasicNameValuePair paramPair;
  if (params != null) {
    for (    String key : params.keySet()) {
      paramPair=new BasicNameValuePair(key,params.getString(key));
      paramsList.add(paramPair);
    }
  }
  HttpParams httpParameters=new BasicHttpParams();
  HttpConnectionParams.setConnectionTimeout(httpParameters,CONNECTION_TIME_OUT);
  HttpConnectionParams.setSoTimeout(httpParameters,SOCKET_TIME_OUT);
  try {
    HttpPost httpRequest=new HttpPost(url);
    httpRequest.setEntity(new UrlEncodedFormEntity(paramsList,HTTP.UTF_8));
    HttpResponse httpResponse=new DefaultHttpClient(httpParameters).execute(httpRequest);
    if (httpResponse.getStatusLine().getStatusCode() == SUCCESS_STATUS) {
      String strResult=EntityUtils.toString(httpResponse.getEntity());
      return strResult;
    }
 else {
      LogUtils.logD(""String_Node_Str"");
      return null;
    }
  }
 catch (  Exception e) {
    LogUtils.logE(e.getMessage());
    return null;
  }
}",0.9990958408679927
5853,"void executeCommand(int commandType,Intent intent){
  boolean opSymbol=true;
  if (commandType == COMMAND_SYNC_DINING_TABLE) {
    HashMap<String,ArrayList<DiningTable>> diningTableMap=new HashMap<String,ArrayList<DiningTable>>();
    ArrayList<DiningTable> diningTableList=ServiceHelper.getDiningTables();
    if (diningTableList != null) {
      diningTableMap.put(DINING_TABLE_KEY,diningTableList);
      sendDiningTableMsg(SYNC_DINING_TABLE,EXECUTE_DINING_TABLE_SUCCESS,diningTableMap);
    }
 else {
      sendMsg(SYNC_DINING_TABLE,EXECUTE_ERROR);
    }
  }
 else   if (commandType == COMMAND_SYNC_ORDER) {
    ArrayList<Order> orderList=ServiceHelper.getFreeOrders();
    ArrayList<OrderDetail> orderDetailList=ServiceHelper.getOrderDetailByOrderIds();
    if (orderList != null && orderDetailList != null) {
      HashMap<Long,ArrayList<OrderItem>> orderItemMap=new HashMap<Long,ArrayList<OrderItem>>();
      HashMap<Long,Long> orderTableMap=new HashMap<Long,Long>();
      for (      OrderDetail orderDetail : orderDetailList) {
        long orderId=orderDetail.getOrderId();
        long dishId=orderDetail.getDishId();
        long tableId=orderDetail.getTableId();
        int number=orderDetail.getNumber();
        OrderItem orderItem=new OrderItem();
        orderItem.setAmount(number);
        orderItem.setDish(dbHelper.getDishById(dishId));
        ArrayList<OrderItem> eachOrderItemList=(ArrayList<OrderItem>)orderItemMap.get(orderId);
        if (null == eachOrderItemList) {
          eachOrderItemList=new ArrayList<OrderItem>();
          eachOrderItemList.add(orderItem);
          orderItemMap.put(orderId,eachOrderItemList);
        }
 else {
          eachOrderItemList.add(orderItem);
        }
        orderTableMap.put(orderId,tableId);
      }
      for (      Order order : orderList) {
        long orderId=order.getOrderId();
        ArrayList<OrderItem> eachOrderItemList=(ArrayList<OrderItem>)orderItemMap.get(orderId);
        order.setOrderItems(eachOrderItemList);
        Long tableId=orderTableMap.get(orderId);
        if (tableId != null) {
          order.setTableId(tableId);
        }
      }
      HashMap<String,ArrayList<Order>> orderMap=new HashMap<String,ArrayList<Order>>();
      orderMap.put(ORDER_KEY,orderList);
      sendHistoryOrdersMsg(SYNC_HISTORY_ORDER,EXECUTE_ORDER_SUCCESS,orderMap);
    }
 else {
      sendMsg(SYNC_HISTORY_ORDER,EXECUTE_ERROR);
    }
  }
 else   if (commandType == COMMAND_SYNC_OTHER) {
    try {
      dbHelper.deleteAllTableDatas();
      opSymbol=syncCategories();
      opSymbol=opSymbol ? syncDishCategory() : false;
      opSymbol=opSymbol ? syncDishesAndImages() : false;
    }
 catch (    Exception e) {
      LogUtils.logD(""String_Node_Str"" + e.getMessage());
      opSymbol=false;
    }
    sendMsg(null,opSymbol == true ? EXECUTE_OTHER_SUCCESS : EXECUTE_ERROR);
  }
 else   if (commandType == COMMAND_SUBMIT_ORDER) {
    Order order=(Order)intent.getSerializableExtra(SUBMIT_ORDER_KEY);
    @SuppressWarnings(""String_Node_Str"") ArrayList<OrderDetail> orderDetailList=(ArrayList<OrderDetail>)intent.getSerializableExtra(SUBMIT_ORDER_DETAIL_KEY);
    opSymbol=submitOrder(order,orderDetailList);
    sendMsg(SUBMIT_ORDER,opSymbol == true ? EXECUTE_SUBMIT_ORDER_SUCCESS : EXECUTE_ERROR);
  }
 else {
    sendMsg(null,EXECUTE_NONE);
  }
}","void executeCommand(int commandType,Intent intent){
  boolean opSymbol=true;
  if (commandType == COMMAND_SYNC_DINING_TABLE) {
    HashMap<String,ArrayList<DiningTable>> diningTableMap=new HashMap<String,ArrayList<DiningTable>>();
    ArrayList<DiningTable> diningTableList=ServiceHelper.getDiningTables();
    if (diningTableList != null) {
      diningTableMap.put(DINING_TABLE_KEY,diningTableList);
      sendDiningTableMsg(SYNC_DINING_TABLE,EXECUTE_DINING_TABLE_SUCCESS,diningTableMap);
    }
 else {
      sendMsg(SYNC_DINING_TABLE,EXECUTE_ERROR);
    }
  }
 else   if (commandType == COMMAND_SYNC_ORDER) {
    ArrayList<Order> orderList=ServiceHelper.getFreeOrders();
    ArrayList<OrderDetail> orderDetailList=ServiceHelper.getOrderDetailByOrderIds();
    if (orderList != null && orderDetailList != null) {
      HashMap<Long,ArrayList<OrderItem>> orderItemMap=new HashMap<Long,ArrayList<OrderItem>>();
      HashMap<Long,Long> orderTableMap=new HashMap<Long,Long>();
      for (      OrderDetail orderDetail : orderDetailList) {
        long orderId=orderDetail.getOrderId();
        long dishId=orderDetail.getDishId();
        long tableId=orderDetail.getTableId();
        int number=orderDetail.getNumber();
        OrderItem orderItem=new OrderItem();
        orderItem.setAmount(number);
        orderItem.setDish(dbHelper.getDishById(dishId));
        ArrayList<OrderItem> eachOrderItemList=(ArrayList<OrderItem>)orderItemMap.get(orderId);
        if (null == eachOrderItemList) {
          eachOrderItemList=new ArrayList<OrderItem>();
          eachOrderItemList.add(orderItem);
          orderItemMap.put(orderId,eachOrderItemList);
        }
 else {
          eachOrderItemList.add(orderItem);
        }
        orderTableMap.put(orderId,tableId);
      }
      for (      Order order : orderList) {
        long orderId=order.getOrderId();
        ArrayList<OrderItem> eachOrderItemList=(ArrayList<OrderItem>)orderItemMap.get(orderId);
        order.setOrderItems(eachOrderItemList);
        Long tableId=orderTableMap.get(orderId);
        if (tableId != null) {
          order.setTableId(tableId);
        }
      }
      HashMap<String,ArrayList<Order>> orderMap=new HashMap<String,ArrayList<Order>>();
      orderMap.put(ORDER_KEY,orderList);
      sendHistoryOrdersMsg(SYNC_HISTORY_ORDER,EXECUTE_ORDER_SUCCESS,orderMap);
    }
 else {
      sendMsg(SYNC_HISTORY_ORDER,EXECUTE_ERROR);
    }
  }
 else   if (commandType == COMMAND_SYNC_OTHER) {
    try {
      dbHelper.deleteAllTableDatas();
      opSymbol=syncCategories();
      opSymbol=opSymbol ? syncDishCategory() : false;
      opSymbol=opSymbol ? syncDishesAndImages() : false;
    }
 catch (    Exception e) {
      LogUtils.logE(""String_Node_Str"" + e.getMessage());
      opSymbol=false;
    }
    sendMsg(null,opSymbol == true ? EXECUTE_OTHER_SUCCESS : EXECUTE_ERROR);
  }
 else   if (commandType == COMMAND_SUBMIT_ORDER) {
    Order order=(Order)intent.getSerializableExtra(SUBMIT_ORDER_KEY);
    @SuppressWarnings(""String_Node_Str"") ArrayList<OrderDetail> orderDetailList=(ArrayList<OrderDetail>)intent.getSerializableExtra(SUBMIT_ORDER_DETAIL_KEY);
    opSymbol=submitOrder(order,orderDetailList);
    sendMsg(SUBMIT_ORDER,opSymbol == true ? EXECUTE_SUBMIT_ORDER_SUCCESS : EXECUTE_ERROR);
  }
 else {
    sendMsg(null,EXECUTE_NONE);
  }
}",0.9996995192307692
5854,"@Override public void onStart(Intent intent,int startId){
  super.onStart(intent,startId);
  Bundle taskParams=new Bundle();
  taskParams.putParcelable(PARAM_INTENT_KEY,intent);
  new AsyncTask<Bundle,Void,Void>(){
    @Override protected Void doInBackground(    Bundle... objs){
      try {
        Intent executeParamIntent=objs[0].getParcelable(PARAM_INTENT_KEY);
        int commandType=executeParamIntent.getIntExtra(SERVICE_COMMAND_KEY,COMMAND_BLANK);
        executeCommand(commandType,executeParamIntent);
      }
 catch (      Exception e) {
        LogUtils.logD(e.getMessage());
      }
      return null;
    }
  }
.execute(new Bundle[]{taskParams});
}","@Override public void onStart(Intent intent,int startId){
  super.onStart(intent,startId);
  Bundle taskParams=new Bundle();
  taskParams.putParcelable(PARAM_INTENT_KEY,intent);
  new AsyncTask<Bundle,Void,Void>(){
    @Override protected Void doInBackground(    Bundle... objs){
      try {
        Intent executeParamIntent=objs[0].getParcelable(PARAM_INTENT_KEY);
        int commandType=executeParamIntent.getIntExtra(SERVICE_COMMAND_KEY,COMMAND_BLANK);
        executeCommand(commandType,executeParamIntent);
      }
 catch (      Exception e) {
        LogUtils.logE(e.getMessage());
      }
      return null;
    }
  }
.execute(new Bundle[]{taskParams});
}",0.9984939759036144
5855,"@Override protected Void doInBackground(Bundle... objs){
  try {
    Intent executeParamIntent=objs[0].getParcelable(PARAM_INTENT_KEY);
    int commandType=executeParamIntent.getIntExtra(SERVICE_COMMAND_KEY,COMMAND_BLANK);
    executeCommand(commandType,executeParamIntent);
  }
 catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return null;
}","@Override protected Void doInBackground(Bundle... objs){
  try {
    Intent executeParamIntent=objs[0].getParcelable(PARAM_INTENT_KEY);
    int commandType=executeParamIntent.getIntExtra(SERVICE_COMMAND_KEY,COMMAND_BLANK);
    executeCommand(commandType,executeParamIntent);
  }
 catch (  Exception e) {
    LogUtils.logE(e.getMessage());
  }
  return null;
}",0.9972144846796658
5856,"private boolean submitOrder(Order order,List<OrderDetail> orderDetailList){
  try {
    StringBuilder submitStr=new StringBuilder(""String_Node_Str"");
    submitStr.append(""String_Node_Str"");
    submitStr.append(order.getOrderTotal() + ""String_Node_Str"");
    submitStr.append(""String_Node_Str"");
    for (    OrderDetail eachOrderDetail : orderDetailList) {
      submitStr.append(""String_Node_Str"");
      submitStr.append(""String_Node_Str"" + eachOrderDetail.getTableId() + ""String_Node_Str"");
      submitStr.append(""String_Node_Str"" + eachOrderDetail.getDishId() + ""String_Node_Str"");
      submitStr.append(""String_Node_Str"" + eachOrderDetail.getNumber());
      submitStr.append(""String_Node_Str"");
    }
    submitStr.deleteCharAt(submitStr.length() - 1);
    submitStr.append(""String_Node_Str"");
    ServiceHelper.submitOrderToServer(submitStr.toString());
  }
 catch (  Exception e) {
    LogUtils.logD(""String_Node_Str"" + e.getMessage());
    return false;
  }
  return true;
}","private boolean submitOrder(Order order,List<OrderDetail> orderDetailList){
  try {
    StringBuilder submitStr=new StringBuilder(""String_Node_Str"");
    submitStr.append(""String_Node_Str"");
    submitStr.append(order.getOrderTotal() + ""String_Node_Str"");
    submitStr.append(""String_Node_Str"");
    for (    OrderDetail eachOrderDetail : orderDetailList) {
      submitStr.append(""String_Node_Str"");
      submitStr.append(""String_Node_Str"" + eachOrderDetail.getTableId() + ""String_Node_Str"");
      submitStr.append(""String_Node_Str"" + eachOrderDetail.getDishId() + ""String_Node_Str"");
      submitStr.append(""String_Node_Str"" + eachOrderDetail.getNumber());
      submitStr.append(""String_Node_Str"");
    }
    submitStr.deleteCharAt(submitStr.length() - 1);
    submitStr.append(""String_Node_Str"");
    ServiceHelper.submitOrderToServer(submitStr.toString());
  }
 catch (  Exception e) {
    LogUtils.logE(""String_Node_Str"" + e.getMessage());
    return false;
  }
  return true;
}",0.9989868287740628
5857,"private boolean syncDishesAndImages(){
  ArrayList<Dish> dishList=ServiceHelper.getDishes();
  if (dishList == null) {
    return false;
  }
 else {
    boolean result=ServiceHelper.syncDishImage(dishList);
    for (    Dish dish : dishList) {
      dbHelper.addDish(dish);
    }
    return result;
  }
}","private boolean syncDishesAndImages(){
  ArrayList<Dish> dishList=ServiceHelper.getDishes();
  if (dishList == null) {
    return false;
  }
 else {
    ServiceHelper.syncDishImage(dishList);
    for (    Dish dish : dishList) {
      dbHelper.addDish(dish);
    }
    return true;
  }
}",0.934010152284264
5858,"public static ArrayList<DishCategory> getDishCategory(){
  String reqUrl=getRequestUrl(null,DISH_CATEGORY_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseDishCategory(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return null;
}","public static ArrayList<DishCategory> getDishCategory(){
  String reqUrl=getRequestUrl(null,DISH_CATEGORY_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseDishCategory(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logE(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logE(e.getMessage());
  }
  return null;
}",0.9948051948051948
5859,"public static boolean syncDishImage(ArrayList<Dish> dishList){
  if (dishList == null) {
    return true;
  }
  for (  Dish dish : dishList) {
    String imgUrl=getRequestUrl(null,dish.getImageServer());
    String imgName=dish.getImageServer().split(""String_Node_Str"",2)[1];
    String filePath=getLocalFileStorageUrl(""String_Node_Str"",imgName);
    RequestHelper.getFileFromServer(imgUrl,null,filePath);
    dish.setImageLocal(filePath);
  }
  return true;
}","public static void syncDishImage(ArrayList<Dish> dishList){
  if (dishList == null) {
    return;
  }
  for (  Dish dish : dishList) {
    String imgUrl=getRequestUrl(null,dish.getImageServer());
    String imgName=dish.getImageServer().split(""String_Node_Str"",2)[1];
    String filePath=getLocalFileStorageUrl(""String_Node_Str"",imgName);
    RequestHelper.getFileFromServer(imgUrl,null,filePath);
    dish.setImageLocal(filePath);
  }
}",0.9654403567447044
5860,"public static ArrayList<Config> getConfigs(){
  String reqUrl=getRequestUrl(null,CONFIG_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseConfigs(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return null;
}","public static ArrayList<Config> getConfigs(){
  String reqUrl=getRequestUrl(null,CONFIG_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseConfigs(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logE(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logE(e.getMessage());
  }
  return null;
}",0.994475138121547
5861,"public static String getLocalFileStorageUrl(String dir,String fileName){
  if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
    if (fileName == null) {
      return null;
    }
    if (dir == null || dir.equals(""String_Node_Str"")) {
      dir=""String_Node_Str"";
    }
 else {
      dir=dir + '/';
    }
    return Environment.getExternalStorageDirectory() + ""String_Node_Str"" + dir+ fileName;
  }
 else {
    LogUtils.logD(""String_Node_Str"");
  }
  return null;
}","public static String getLocalFileStorageUrl(String dir,String fileName){
  if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
    if (fileName == null) {
      return null;
    }
    if (dir == null || dir.equals(""String_Node_Str"")) {
      return Environment.getExternalStorageDirectory() + ('/' + IMAGE_STORAGE_DEFAULT_DIR + '/'+ fileName);
    }
 else {
      return Environment.getExternalStorageDirectory() + ('/' + dir + '/'+ fileName);
    }
  }
 else {
    LogUtils.logE(""String_Node_Str"");
  }
  return null;
}",0.575
5862,"public static ArrayList<Dish> getDishes(){
  String reqUrl=getRequestUrl(null,DISH_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseDishes(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return null;
}","public static ArrayList<Dish> getDishes(){
  String reqUrl=getRequestUrl(null,DISH_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseDishes(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logE(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logE(e.getMessage());
  }
  return null;
}",0.99438202247191
5863,"public static ArrayList<Order> getFreeOrders(){
  String reqUrl=getRequestUrl(null,ORDER_PAGE);
  Bundle params=new Bundle();
  params.putString(ORDER_QUERY_KEY,ORDER_STATUS_FREE);
  String respStr=RequestHelper.doRequestPost(reqUrl,params);
  try {
    return ResponseParser.parseOrders(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return null;
}","public static ArrayList<Order> getFreeOrders(){
  String reqUrl=getRequestUrl(null,ORDER_PAGE);
  Bundle params=new Bundle();
  params.putString(ORDER_QUERY_KEY,ORDER_STATUS_FREE);
  String respStr=RequestHelper.doRequestPost(reqUrl,params);
  try {
    return ResponseParser.parseOrders(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logE(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logE(e.getMessage());
  }
  return null;
}",0.9955456570155902
5864,"public static ArrayList<Order> getOrders(){
  String reqUrl=getRequestUrl(null,ORDER_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseOrders(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return null;
}","public static ArrayList<Order> getOrders(){
  String reqUrl=getRequestUrl(null,ORDER_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseOrders(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logE(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logE(e.getMessage());
  }
  return null;
}",0.994413407821229
5865,"public static ArrayList<OrderDetail> getOrderDetail(){
  String reqUrl=getRequestUrl(null,ORDER_DETAIL_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseOrderDetail(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return null;
}","public static ArrayList<OrderDetail> getOrderDetail(){
  String reqUrl=getRequestUrl(null,ORDER_DETAIL_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseOrderDetail(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logE(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logE(e.getMessage());
  }
  return null;
}",0.994750656167979
5866,"public static ArrayList<Category> getCategories(){
  String reqUrl=getRequestUrl(null,CATEGORY_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseCategories(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return null;
}","public static ArrayList<Category> getCategories(){
  String reqUrl=getRequestUrl(null,CATEGORY_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseCategories(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logE(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logE(e.getMessage());
  }
  return null;
}",0.9946236559139784
5867,"public static ArrayList<DiningTable> getDiningTables(){
  String reqUrl=getRequestUrl(null,DINING_TABLE_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseDiningTables(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return null;
}","public static ArrayList<DiningTable> getDiningTables(){
  String reqUrl=getRequestUrl(null,DINING_TABLE_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseDiningTables(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logE(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logE(e.getMessage());
  }
  return null;
}",0.9947780678851176
5868,"public static ArrayList<OrderDetail> getOrderDetailByOrderIds(){
  String reqUrl=getRequestUrl(null,ORDER_DETAIL_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseOrderDetail(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return null;
}","public static ArrayList<OrderDetail> getOrderDetailByOrderIds(){
  String reqUrl=getRequestUrl(null,ORDER_DETAIL_PAGE);
  String respStr=RequestHelper.doRequestPost(reqUrl,null);
  try {
    return ResponseParser.parseOrderDetail(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logE(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logE(e.getMessage());
  }
  return null;
}",0.9948849104859336
5869,"private void syncTablesStatus(){
  IntentFilter filter=new IntentFilter(DiningService.SYNC_DINING_TABLE);
  if (mReceiver == null) {
    mReceiver=new SyncReceiver();
  }
  registerReceiver(mReceiver,filter);
  Intent service=new Intent(SelectTableActivity.this,DiningService.class);
  service.putExtra(DiningService.SERVICE_COMMAND_KEY,DiningService.COMMAND_SYNC_DINING_TABLE);
  startService(service);
  showDialog(DIALOG_SYNC_DATA);
}","private void syncTablesStatus(){
  IntentFilter filter=new IntentFilter(DiningService.SYNC_DINING_TABLE);
  if (mReceiver == null) {
    mReceiver=new SyncReceiver();
    registerReceiver(mReceiver,filter);
  }
  Intent service=new Intent(SelectTableActivity.this,DiningService.class);
  service.putExtra(DiningService.SERVICE_COMMAND_KEY,DiningService.COMMAND_SYNC_DINING_TABLE);
  startService(service);
  showDialog(DIALOG_SYNC_DATA);
}",0.9931506849315068
5870,"@Override public void onResume(){
  super.onResume();
  asyncInitUi();
}","@Override public void onResume(){
  super.onResume();
  asyncInitGallery();
}",0.9395973154362416
5871,"@Override protected void onPostExecute(Void result){
  initUi();
}","@Override protected void onPostExecute(Void result){
  initMainUi();
  initGallery();
}",0.8627450980392157
5872,"@Override protected void onStop(){
  super.onStop();
  clearDishImageCache();
}","@Override protected void onStop(){
  super.onStop();
  LinearLayout galleryFrame=(LinearLayout)findViewById(R.id.gallery_frame);
  galleryFrame.removeAllViews();
}",0.5371900826446281
5873,"/** 
 * Get sequenced dish_ids list This list was ordered by Table Category' sort_order and category_id ASC, Table DishCategory dish_id ASC
 * @param db
 * @return
 */
public static List<Long> getSequencedDishIds(final SQLiteDatabase db){
  long b=System.currentTimeMillis();
  final Cursor c=db.rawQuery(""String_Node_Str"" + DISH_ID + ""String_Node_Str""+ TABLE_NAME+ ""String_Node_Str""+ CategoryTable.TABLE_NAME+ ""String_Node_Str""+ CATEGORY_ID+ ""String_Node_Str""+ CategoryTable.CATEGORY_ID+ ""String_Node_Str""+ CategoryTable.SORT_ORDER+ ""String_Node_Str""+ CategoryTable.CATEGORY_ID+ ""String_Node_Str""+ DISH_ID,null);
  if (c != null) {
    try {
      List<Long> list=new ArrayList<Long>();
      while (c.moveToNext()) {
        list.add(c.getLong(c.getColumnIndex(DISH_ID)));
      }
      System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - b));
      return list;
    }
  finally {
      c.close();
    }
  }
  return Collections.emptyList();
}","/** 
 * Get sequenced dish_ids list This list was ordered by Table Category' sort_order and category_id ASC, Table DishCategory dish_id ASC
 * @param db
 * @return
 */
public static List<Long> getSequencedDishIds(final SQLiteDatabase db){
  final Cursor c=db.rawQuery(""String_Node_Str"" + DISH_ID + ""String_Node_Str""+ TABLE_NAME+ ""String_Node_Str""+ CategoryTable.TABLE_NAME+ ""String_Node_Str""+ CATEGORY_ID+ ""String_Node_Str""+ CategoryTable.CATEGORY_ID+ ""String_Node_Str""+ CategoryTable.SORT_ORDER+ ""String_Node_Str""+ CategoryTable.CATEGORY_ID+ ""String_Node_Str""+ DISH_ID,null);
  if (c != null) {
    try {
      List<Long> list=new ArrayList<Long>();
      while (c.moveToNext()) {
        list.add(c.getLong(c.getColumnIndex(DISH_ID)));
      }
      return list;
    }
  finally {
      c.close();
    }
  }
  return Collections.emptyList();
}",0.935251798561151
5874,"public static List<Dish> parseDishes(String dishesRespStr) throws JSONException {
  if (dishesRespStr == null) {
    return null;
  }
  List<Dish> resultList=null;
  JSONObject dishes=new JSONObject(dishesRespStr);
  resultList=new ArrayList<Dish>();
  Dish tempDish=null;
  JSONArray dishArray=dishes.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempDish=new Dish();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempDish.setId(dishObj.getInt(""String_Node_Str""));
    tempDish.setName(dishObj.getString(""String_Node_Str""));
    tempDish.setPrice(dishObj.getInt(""String_Node_Str""));
    tempDish.setDescription(dishObj.getString(""String_Node_Str""));
    tempDish.setImageServer(dishObj.getString(""String_Node_Str""));
    long createTimeValue=dishObj.getLong(""String_Node_Str"");
    long updateTimeValue=dishObj.getLong(""String_Node_Str"");
    Date createTime=new Date();
    Date updateTime=new Date();
    createTime.setTime(createTimeValue);
    updateTime.setTime(updateTimeValue);
    tempDish.setCreateTime(createTime);
    tempDish.setUpdateTime(updateTime);
    resultList.add(tempDish);
  }
  return resultList;
}","public static ArrayList<Dish> parseDishes(String dishesRespStr) throws JSONException {
  if (dishesRespStr == null) {
    return null;
  }
  ArrayList<Dish> resultList=null;
  JSONObject dishes=new JSONObject(dishesRespStr);
  resultList=new ArrayList<Dish>();
  JSONArray dishArray=dishes.getJSONArray(""String_Node_Str"");
  int length=dishArray.length();
  for (int i=0; i < length; i++) {
    Dish dish=new Dish();
    JSONObject dishObj=dishArray.getJSONObject(i);
    dish.setDishId(dishObj.getLong(""String_Node_Str""));
    dish.setName(dishObj.getString(""String_Node_Str""));
    dish.setPrice(dishObj.getInt(""String_Node_Str""));
    dish.setDescription(dishObj.getString(""String_Node_Str""));
    dish.setImageServer(dishObj.getString(""String_Node_Str""));
    long createTimeValue=dishObj.getLong(""String_Node_Str"");
    long updateTimeValue=dishObj.getLong(""String_Node_Str"");
    Date createTime=new Date(createTimeValue);
    Date updateTime=new Date(updateTimeValue);
    dish.setCreateTime(createTime);
    dish.setUpdateTime(updateTime);
    resultList.add(dish);
  }
  return resultList;
}",0.6134861172322609
5875,"public static List<Order> parseOrders(String orderRespStr) throws JSONException {
  if (orderRespStr == null) {
    return null;
  }
  List<Order> resultList=null;
  JSONObject orders=new JSONObject(orderRespStr);
  resultList=new ArrayList<Order>();
  Order tempOrder=null;
  JSONArray dishArray=orders.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempOrder=new Order();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempOrder.setId(dishObj.getInt(""String_Node_Str""));
    tempOrder.setStatus(dishObj.getInt(""String_Node_Str""));
    tempOrder.setOrderTotal(dishObj.getInt(""String_Node_Str""));
    long createTimeValue=dishObj.getLong(""String_Node_Str"");
    long payTimeValue=dishObj.getLong(""String_Node_Str"");
    Date createTime=new Date();
    Date payTime=new Date();
    createTime.setTime(createTimeValue);
    payTime.setTime(payTimeValue);
    tempOrder.setCreateTime(createTime);
    tempOrder.setPayTime(payTime);
    resultList.add(tempOrder);
  }
  return resultList;
}","public static ArrayList<Order> parseOrders(String orderRespStr) throws JSONException {
  if (orderRespStr == null) {
    return null;
  }
  ArrayList<Order> resultList=null;
  JSONObject orders=new JSONObject(orderRespStr);
  resultList=new ArrayList<Order>();
  JSONArray orderArray=orders.getJSONArray(""String_Node_Str"");
  int length=orderArray.length();
  for (int i=0; i < length; i++) {
    Order order=new Order();
    JSONObject orderObj=orderArray.getJSONObject(i);
    order.setOrderId(orderObj.getLong(""String_Node_Str""));
    order.setStatus(orderObj.getInt(""String_Node_Str""));
    order.setOrderTotal(orderObj.getInt(""String_Node_Str""));
    long createTimeValue=orderObj.getLong(""String_Node_Str"");
    long payTimeValue=orderObj.getLong(""String_Node_Str"");
    Date createTime=new Date(createTimeValue);
    Date payTime=new Date(payTimeValue);
    order.setCreateTime(createTime);
    order.setPayTime(payTime);
    resultList.add(order);
  }
  return resultList;
}",0.3258817685047193
5876,"public static List<OrderDetail> parseOrderDetail(String orderDetailRespStr) throws JSONException {
  if (orderDetailRespStr == null) {
    return null;
  }
  List<OrderDetail> resultList=null;
  JSONObject orderDetail=new JSONObject(orderDetailRespStr);
  resultList=new ArrayList<OrderDetail>();
  OrderDetail tempOrderDetail=null;
  JSONArray dishArray=orderDetail.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempOrderDetail=new OrderDetail();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempOrderDetail.setId(dishObj.getInt(""String_Node_Str""));
    tempOrderDetail.setOrderId(dishObj.getInt(""String_Node_Str""));
    tempOrderDetail.setTableId(dishObj.getInt(""String_Node_Str""));
    tempOrderDetail.setDishId(dishObj.getInt(""String_Node_Str""));
    tempOrderDetail.setNumber(dishObj.getInt(""String_Node_Str""));
    resultList.add(tempOrderDetail);
  }
  return resultList;
}","public static ArrayList<OrderDetail> parseOrderDetail(String orderDetailRespStr) throws JSONException {
  if (orderDetailRespStr == null) {
    return null;
  }
  ArrayList<OrderDetail> resultList=null;
  JSONObject orderDetails=new JSONObject(orderDetailRespStr);
  resultList=new ArrayList<OrderDetail>();
  JSONArray orderDetailArray=orderDetails.getJSONArray(""String_Node_Str"");
  int length=orderDetailArray.length();
  for (int i=0; i < length; i++) {
    OrderDetail orderDetail=new OrderDetail();
    JSONObject orderDetailObj=orderDetailArray.getJSONObject(i);
    orderDetail.setOrderItemId(orderDetailObj.getLong(""String_Node_Str""));
    orderDetail.setOrderId(orderDetailObj.getLong(""String_Node_Str""));
    orderDetail.setTableId(orderDetailObj.getLong(""String_Node_Str""));
    orderDetail.setDishId(orderDetailObj.getLong(""String_Node_Str""));
    orderDetail.setNumber(orderDetailObj.getInt(""String_Node_Str""));
    resultList.add(orderDetail);
  }
  return resultList;
}",0.6178776790381599
5877,"public static List<DishCategory> parseDishCategory(String dishCategoryRespStr) throws JSONException {
  if (dishCategoryRespStr == null) {
    return null;
  }
  List<DishCategory> resultList=null;
  JSONObject dishCategory=new JSONObject(dishCategoryRespStr);
  resultList=new ArrayList<DishCategory>();
  DishCategory tempDishCategory=null;
  JSONArray dishArray=dishCategory.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempDishCategory=new DishCategory();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempDishCategory.setDishId(dishObj.getInt(""String_Node_Str""));
    tempDishCategory.setCategoryId(dishObj.getInt(""String_Node_Str""));
    resultList.add(tempDishCategory);
  }
  return resultList;
}","public static ArrayList<DishCategory> parseDishCategory(String dishCategoryRespStr) throws JSONException {
  if (dishCategoryRespStr == null) {
    return null;
  }
  ArrayList<DishCategory> resultList=null;
  JSONObject dishCategories=new JSONObject(dishCategoryRespStr);
  resultList=new ArrayList<DishCategory>();
  JSONArray dishCategoryArray=dishCategories.getJSONArray(""String_Node_Str"");
  int length=dishCategoryArray.length();
  for (int i=0; i < length; i++) {
    DishCategory dishCategory=new DishCategory();
    JSONObject dishCategoryObj=dishCategoryArray.getJSONObject(i);
    dishCategory.setDishId(dishCategoryObj.getLong(""String_Node_Str""));
    dishCategory.setCategoryId(dishCategoryObj.getLong(""String_Node_Str""));
    resultList.add(dishCategory);
  }
  return resultList;
}",0.7739018087855297
5878,"public static List<DiningTable> parseDiningTables(String diningTablesRespStr) throws JSONException {
  if (diningTablesRespStr == null) {
    return null;
  }
  List<DiningTable> resultList=null;
  JSONObject diningTables=new JSONObject(diningTablesRespStr);
  resultList=new ArrayList<DiningTable>();
  DiningTable tempDiningTable=null;
  JSONArray dishArray=diningTables.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempDiningTable=new DiningTable();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempDiningTable.setId(dishObj.getInt(""String_Node_Str""));
    tempDiningTable.setName(dishObj.getString(""String_Node_Str""));
    tempDiningTable.setMaxPeople(dishObj.getInt(""String_Node_Str""));
    int free=dishObj.getInt(""String_Node_Str"");
    tempDiningTable.setFree(free == 0 ? true : false);
    resultList.add(tempDiningTable);
  }
  return resultList;
}","public static ArrayList<DiningTable> parseDiningTables(String diningTablesRespStr) throws JSONException {
  if (diningTablesRespStr == null) {
    return null;
  }
  ArrayList<DiningTable> resultList=null;
  JSONObject diningTables=new JSONObject(diningTablesRespStr);
  resultList=new ArrayList<DiningTable>();
  JSONArray diningArray=diningTables.getJSONArray(""String_Node_Str"");
  int length=diningArray.length();
  for (int i=0; i < length; i++) {
    DiningTable diningTable=new DiningTable();
    JSONObject diningTableObj=diningArray.getJSONObject(i);
    diningTable.setDiningTableId(diningTableObj.getLong(""String_Node_Str""));
    diningTable.setName(diningTableObj.getString(""String_Node_Str""));
    diningTable.setMaxPeople(diningTableObj.getInt(""String_Node_Str""));
    int free=diningTableObj.getInt(""String_Node_Str"");
    diningTable.setFree(free == 0 ? true : false);
    resultList.add(diningTable);
  }
  return resultList;
}",0.6497297297297298
5879,"public static List<Config> parseConfigs(String configsRespStr) throws JSONException {
  if (configsRespStr == null) {
    return null;
  }
  List<Config> resultList=null;
  JSONObject configs=new JSONObject(configsRespStr);
  resultList=new ArrayList<Config>();
  Config tempConfig=null;
  JSONArray dishArray=configs.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempConfig=new Config();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempConfig.setId(dishObj.getInt(""String_Node_Str""));
    tempConfig.setName(dishObj.getString(""String_Node_Str""));
    tempConfig.setValue(dishObj.getString(""String_Node_Str""));
    tempConfig.setDescription(dishObj.getString(""String_Node_Str""));
    resultList.add(tempConfig);
  }
  return resultList;
}","public static ArrayList<Config> parseConfigs(String configsRespStr) throws JSONException {
  if (configsRespStr == null) {
    return null;
  }
  ArrayList<Config> resultList=null;
  JSONObject configs=new JSONObject(configsRespStr);
  resultList=new ArrayList<Config>();
  JSONArray configArray=configs.getJSONArray(""String_Node_Str"");
  int length=configArray.length();
  for (int i=0; i < length; i++) {
    Config config=new Config();
    JSONObject configObj=configArray.getJSONObject(i);
    config.setConfigId(configObj.getLong(""String_Node_Str""));
    config.setName(configObj.getString(""String_Node_Str""));
    config.setValue(configObj.getString(""String_Node_Str""));
    config.setDescription(configObj.getString(""String_Node_Str""));
    resultList.add(config);
  }
  return resultList;
}",0.6397476340694006
5880,"public static List<Category> parseCategories(String categoryRespStr) throws JSONException {
  if (categoryRespStr == null) {
    return null;
  }
  List<Category> resultList=null;
  JSONObject categories=new JSONObject(categoryRespStr);
  resultList=new ArrayList<Category>();
  Category tempCategory=null;
  JSONArray dishArray=categories.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempCategory=new Category();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempCategory.setId(dishObj.getInt(""String_Node_Str""));
    tempCategory.setName(dishObj.getString(""String_Node_Str""));
    tempCategory.setDescription(dishObj.getString(""String_Node_Str""));
    tempCategory.setSortOrder(dishObj.getInt(""String_Node_Str""));
    resultList.add(tempCategory);
  }
  return resultList;
}","public static ArrayList<Category> parseCategories(String categoryRespStr) throws JSONException {
  if (categoryRespStr == null) {
    return null;
  }
  ArrayList<Category> resultList=null;
  JSONObject categories=new JSONObject(categoryRespStr);
  resultList=new ArrayList<Category>();
  JSONArray categoryArray=categories.getJSONArray(""String_Node_Str"");
  int length=categoryArray.length();
  for (int i=0; i < length; i++) {
    Category category=new Category();
    JSONObject categoryObj=categoryArray.getJSONObject(i);
    category.setCategoryId(categoryObj.getLong(""String_Node_Str""));
    category.setName(categoryObj.getString(""String_Node_Str""));
    category.setDescription(categoryObj.getString(""String_Node_Str""));
    category.setSortOrder(categoryObj.getInt(""String_Node_Str""));
    resultList.add(category);
  }
  return resultList;
}",0.6459701492537313
5881,"private boolean synCategories(){
  boolean result=true;
  List<Category> categoryList=serviceHelper.getCategories();
  for (  Category category : categoryList) {
    dbHelper.addCategory(category);
  }
  return result;
}","private boolean synCategories(){
  boolean result=true;
  List<Category> categoryList=serviceHelper.getCategories();
  if (categoryList == null) {
    result=false;
  }
 else {
    for (    Category category : categoryList) {
      dbHelper.addCategory(category);
    }
  }
  return result;
}",0.765625
5882,"private boolean synDishCategory(){
  boolean result=true;
  List<DishCategory> dishCategoryList=serviceHelper.getDishCategory();
  for (  DishCategory dishCategory : dishCategoryList) {
    dbHelper.addDishCategory(dishCategory);
  }
  return result;
}","private boolean synDishCategory(){
  boolean result=true;
  List<DishCategory> dishCategoryList=serviceHelper.getDishCategory();
  if (dishCategoryList == null) {
    result=false;
  }
 else {
    for (    DishCategory dishCategory : dishCategoryList) {
      dbHelper.addDishCategory(dishCategory);
    }
  }
  return result;
}",0.803448275862069
5883,"private boolean synConfigs(){
  boolean result=true;
  List<Config> configList=serviceHelper.getConfigs();
  for (  Config config : configList) {
    dbHelper.addConfig(config);
  }
  return result;
}","private boolean synConfigs(){
  boolean result=true;
  List<Config> configList=serviceHelper.getConfigs();
  if (configList == null) {
    result=false;
  }
 else {
    for (    Config config : configList) {
      dbHelper.addConfig(config);
    }
  }
  return result;
}",0.7446808510638298
5884,"private void executeCommand(int commandType,Intent intent){
  boolean opSymbol=true;
  if (commandType == COMMAND_SYNC_DINING_TABLE) {
    HashMap diningTableMap=new HashMap();
    List<DiningTable> diningTableList=serviceHelper.getDiningTables();
    if (diningTableList != null) {
      diningTableMap.put(DINING_TABLE_KEY,diningTableList);
      sendMsg(SYNC_DINING_TABLE,EXECUTE_DINING_TABLE_SUCCESS,diningTableMap);
    }
 else {
      sendMsg(SYNC_DINING_TABLE,EXECUTE_ERROR,null);
    }
  }
 else   if (commandType == COMMAND_SYNC_ORDER) {
    List<Order> orderList=serviceHelper.getOrders();
    List<OrderDetail> detailList=serviceHelper.getOrderDetail();
    if (orderList != null && detailList != null) {
      HashMap orderMap=new HashMap();
      orderMap.put(ORDER_KEY,orderList);
      for (      OrderDetail orderDetail : detailList) {
        int orderId=orderDetail.getOrderId();
        String key=""String_Node_Str"" + orderId;
        List eachDetailList=(List)orderMap.get(key);
        if (null == eachDetailList) {
          eachDetailList=new ArrayList();
          eachDetailList.add(orderDetail);
          orderMap.put(key,eachDetailList);
        }
 else {
          eachDetailList.add(orderDetail);
        }
      }
      sendMsg(SYNC_HISTORY_ORDER,EXECUTE_ORDER_SUCCESS,orderMap);
    }
 else {
      sendMsg(SYNC_HISTORY_ORDER,EXECUTE_ERROR,null);
    }
  }
 else   if (commandType == COMMAND_SYNC_OTHER) {
    if (dbHelper == null) {
      DatabaseHelper.init(this.getApplicationContext());
      dbHelper=DatabaseHelper.getInstance();
    }
    opSymbol=(opSymbol == true ? synCategories() : false);
    opSymbol=(opSymbol == true ? synDishes() : false);
    opSymbol=(opSymbol == true ? synDishCategory() : false);
    sendMsg(null,opSymbol == true ? EXECUTE_OTHER_SUCCESS : EXECUTE_ERROR,null);
  }
 else   if (commandType == COMMAND_SUBMIT_ORDER) {
    HashMap submitOrderMap=(HashMap)intent.getSerializableExtra(SUBMIT_KEY);
    opSymbol=submitOrder(submitOrderMap);
    sendMsg(SUBMIT_ORDER,opSymbol == true ? EXECUTE_SUBMIT_ORDER_SUCCESS : EXECUTE_ERROR,null);
  }
 else {
    sendMsg(null,EXECUTE_NONE,null);
  }
}","private void executeCommand(int commandType,Intent intent){
  boolean opSymbol=true;
  if (commandType == COMMAND_SYNC_DINING_TABLE) {
    HashMap diningTableMap=new HashMap();
    List<DiningTable> diningTableList=serviceHelper.getDiningTables();
    if (diningTableList != null) {
      diningTableMap.put(DINING_TABLE_KEY,diningTableList);
      sendMsg(SYNC_DINING_TABLE,EXECUTE_DINING_TABLE_SUCCESS,diningTableMap);
    }
 else {
      sendMsg(SYNC_DINING_TABLE,EXECUTE_ERROR,null);
    }
  }
 else   if (commandType == COMMAND_SYNC_ORDER) {
    List<Order> orderList=serviceHelper.getOrders();
    List<OrderDetail> detailList=serviceHelper.getOrderDetail();
    if (orderList != null && detailList != null) {
      HashMap orderMap=new HashMap();
      orderMap.put(ORDER_KEY,orderList);
      for (      OrderDetail orderDetail : detailList) {
        int orderId=orderDetail.getOrderId();
        String key=""String_Node_Str"" + orderId;
        List eachDetailList=(List)orderMap.get(key);
        if (null == eachDetailList) {
          eachDetailList=new ArrayList();
          eachDetailList.add(orderDetail);
          orderMap.put(key,eachDetailList);
        }
 else {
          eachDetailList.add(orderDetail);
        }
      }
      sendMsg(SYNC_HISTORY_ORDER,EXECUTE_ORDER_SUCCESS,orderMap);
    }
 else {
      sendMsg(SYNC_HISTORY_ORDER,EXECUTE_ERROR,null);
    }
  }
 else   if (commandType == COMMAND_SYNC_OTHER) {
    try {
      if (dbHelper == null) {
        DatabaseHelper.init(this.getApplicationContext());
        dbHelper=DatabaseHelper.getInstance();
      }
      opSymbol=(opSymbol == true ? synCategories() : false);
      opSymbol=(opSymbol == true ? synDishCategory() : false);
      opSymbol=(opSymbol == true ? synDishesAndImages() : false);
    }
 catch (    Exception e) {
      LogUtils.logD(""String_Node_Str"" + e.getMessage());
      opSymbol=false;
    }
    sendMsg(null,opSymbol == true ? EXECUTE_OTHER_SUCCESS : EXECUTE_ERROR,null);
  }
 else   if (commandType == COMMAND_SUBMIT_ORDER) {
    HashMap submitOrderMap=(HashMap)intent.getSerializableExtra(SUBMIT_KEY);
    opSymbol=submitOrder(submitOrderMap);
    sendMsg(SUBMIT_ORDER,opSymbol == true ? EXECUTE_SUBMIT_ORDER_SUCCESS : EXECUTE_ERROR,null);
  }
 else {
    sendMsg(null,EXECUTE_NONE,null);
  }
}",0.9616505943036556
5885,"public List<DishCategory> getDishCategory(){
  List<DishCategory> dishCategoryList=null;
  String reqUrl=getRequestUrl(null,DISH_CATEGORY_PAGE);
  String respStr=reqHelper.doPost(reqUrl,null);
  try {
    dishCategoryList=reqParser.parseDishCategory(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
  return dishCategoryList;
}","public List<DishCategory> getDishCategory(){
  List<DishCategory> dishCategoryList=null;
  String reqUrl=getRequestUrl(null,DISH_CATEGORY_PAGE);
  String respStr=reqHelper.doPost(reqUrl,null);
  try {
    dishCategoryList=reqParser.parseDishCategory(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return dishCategoryList;
}",0.9195402298850576
5886,"public boolean syncDishImage(List<Dish> dishList){
  boolean result=true;
  if (dishList == null) {
    return result;
  }
  try {
    for (    Dish dish : dishList) {
      String imgUrl=DEFAULT_URL + dish.getImageServer();
      String imgName=dish.getImageServer().split(""String_Node_Str"",2)[1];
      String filePath=getLocalFileStorageUrl(""String_Node_Str"",imgName);
      OutputStream fos=new FileOutputStream(filePath);
      reqHelper.getFileFromServer(imgUrl,null,fos);
    }
  }
 catch (  IOException e) {
    LogUtils.logD(""String_Node_Str"");
    result=false;
  }
  return result;
}","public boolean syncDishImage(List<Dish> dishList){
  boolean result=true;
  if (dishList == null) {
    return result;
  }
  try {
    for (    Dish dish : dishList) {
      String imgUrl=getRequestUrl(null,dish.getImageServer());
      String imgName=dish.getImageServer().split(""String_Node_Str"",2)[1];
      String filePath=getLocalFileStorageUrl(""String_Node_Str"",imgName);
      OutputStream fos=new FileOutputStream(filePath);
      reqHelper.getFileFromServer(imgUrl,null,fos);
    }
  }
 catch (  IOException e) {
    LogUtils.logD(""String_Node_Str"");
    result=false;
  }
  return result;
}",0.9731993299832497
5887,"public List<Config> getConfigs(){
  List<Config> configList=null;
  String reqUrl=getRequestUrl(null,CONFIG_PAGE);
  String respStr=reqHelper.doPost(reqUrl,null);
  try {
    configList=reqParser.parseConfigs(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
  return configList;
}","public List<Config> getConfigs(){
  List<Config> configList=null;
  String reqUrl=getRequestUrl(null,CONFIG_PAGE);
  String respStr=reqHelper.doPost(reqUrl,null);
  try {
    configList=reqParser.parseConfigs(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return configList;
}",0.8476052249637155
5888,"public List<Dish> getDishes(){
  List<Dish> dishList=null;
  String reqUrl=getRequestUrl(null,DISH_PAGE);
  String respStr=reqHelper.doPost(reqUrl,null);
  try {
    dishList=reqParser.parseDishes(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
  return dishList;
}","public List<Dish> getDishes(){
  List<Dish> dishList=null;
  String reqUrl=getRequestUrl(null,DISH_PAGE);
  String respStr=reqHelper.doPost(reqUrl,null);
  try {
    dishList=reqParser.parseDishes(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return dishList;
}",0.9046898638426626
5889,"public List<Order> getOrders(){
  List<Order> orderList=null;
  String reqUrl=getRequestUrl(null,ORDER_PAGE);
  String respStr=reqHelper.doPost(reqUrl,null);
  try {
    orderList=reqParser.parseOrders(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
  return orderList;
}","public List<Order> getOrders(){
  List<Order> orderList=null;
  String reqUrl=getRequestUrl(null,ORDER_PAGE);
  String respStr=reqHelper.doPost(reqUrl,null);
  try {
    orderList=reqParser.parseOrders(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return orderList;
}",0.8469539375928677
5890,"public List<OrderDetail> getOrderDetail(){
  List<OrderDetail> orderDetailList=null;
  String reqUrl=getRequestUrl(null,ORDER_DETAIL_PAGE);
  String respStr=reqHelper.doPost(reqUrl,null);
  try {
    orderDetailList=reqParser.parseOrderDetail(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
  return orderDetailList;
}","public List<OrderDetail> getOrderDetail(){
  List<OrderDetail> orderDetailList=null;
  String reqUrl=getRequestUrl(null,ORDER_DETAIL_PAGE);
  String respStr=reqHelper.doPost(reqUrl,null);
  try {
    orderDetailList=reqParser.parseOrderDetail(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return orderDetailList;
}",0.8500651890482399
5891,"public List<Category> getCategories(){
  List<Category> categoryList=null;
  String reqUrl=getRequestUrl(null,CATEGORY_PAGE);
  String respStr=reqHelper.doPost(reqUrl,null);
  try {
    categoryList=reqParser.parseCategories(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
  return categoryList;
}","public List<Category> getCategories(){
  List<Category> categoryList=null;
  String reqUrl=getRequestUrl(null,CATEGORY_PAGE);
  String respStr=reqHelper.doPost(reqUrl,null);
  try {
    categoryList=reqParser.parseCategories(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return categoryList;
}",0.8496551724137931
5892,"public List<DiningTable> getDiningTables(){
  List<DiningTable> tableList=null;
  String reqUrl=getRequestUrl(null,DINING_TABLE_PAGE);
  String respStr=reqHelper.doPost(reqUrl,null);
  try {
    tableList=reqParser.parseDiningTables(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
  return tableList;
}","public List<DiningTable> getDiningTables(){
  List<DiningTable> tableList=null;
  String reqUrl=getRequestUrl(null,DINING_TABLE_PAGE);
  String respStr=reqHelper.doPost(reqUrl,null);
  try {
    tableList=reqParser.parseDiningTables(respStr);
  }
 catch (  JSONException e) {
    LogUtils.logD(e.getMessage());
  }
catch (  Exception e) {
    LogUtils.logD(e.getMessage());
  }
  return tableList;
}",0.8598639455782313
5893,"public boolean getFileFromServer(String path,Bundle params,OutputStream fos){
  byte[] bf=new byte[1024];
  int current=0;
  try {
    if (params != null) {
      StringBuilder sb=new StringBuilder();
      boolean first=true;
      for (      String key : params.keySet()) {
        if (first) {
          first=false;
        }
 else {
          sb.append(""String_Node_Str"");
        }
        sb.append(URLEncoder.encode(key) + ""String_Node_Str"" + URLEncoder.encode(params.getString(key)));
      }
      path=path + ""String_Node_Str"" + sb.toString();
    }
    URL url=new URL(path);
    HttpURLConnection connect=(HttpURLConnection)url.openConnection();
    connect.setDoInput(true);
    connect.setConnectTimeout(5 * 1000);
    connect.setReadTimeout(30 * 1000);
    int code=connect.getResponseCode();
    if (code == HttpURLConnection.HTTP_OK) {
      InputStream is=connect.getInputStream();
      BufferedInputStream bis=new BufferedInputStream(is);
      while ((current=bis.read(bf)) != FILE_END) {
        fos.write(bf,0,current);
      }
      bis.close();
      fos.close();
      connect.disconnect();
    }
    return true;
  }
 catch (  MalformedURLException e) {
    LogUtils.logD(e.getMessage());
    return false;
  }
catch (  IOException e) {
    LogUtils.logD(e.getMessage());
    return false;
  }
}","public static boolean getFileFromServer(String path,Bundle params,OutputStream fos){
  byte[] bf=new byte[FILE_BUFFER_SIZE];
  int current=0;
  try {
    if (params != null) {
      StringBuilder sb=new StringBuilder();
      boolean first=true;
      for (      String key : params.keySet()) {
        if (first) {
          first=false;
        }
 else {
          sb.append(""String_Node_Str"");
        }
        sb.append(URLEncoder.encode(key) + ""String_Node_Str"" + URLEncoder.encode(params.getString(key)));
      }
      path=path + ""String_Node_Str"" + sb.toString();
    }
    URL url=new URL(path);
    HttpURLConnection connect=(HttpURLConnection)url.openConnection();
    connect.setDoInput(true);
    connect.setConnectTimeout(CONNECTION_TIME_OUT);
    connect.setReadTimeout(SOCKET_TIME_OUT);
    int code=connect.getResponseCode();
    if (code == HttpURLConnection.HTTP_OK) {
      InputStream is=connect.getInputStream();
      BufferedInputStream bis=new BufferedInputStream(is);
      while ((current=bis.read(bf)) != FILE_END) {
        fos.write(bf,0,current);
      }
      bis.close();
      fos.close();
      connect.disconnect();
    }
    return true;
  }
 catch (  MalformedURLException e) {
    LogUtils.logD(e.getMessage());
    return false;
  }
catch (  IOException e) {
    LogUtils.logD(e.getMessage());
    return false;
  }
}",0.970917225950783
5894,"public String doPost(String url,Bundle params){
  HttpPost httpRequest=new HttpPost(url);
  List paramsList=new ArrayList();
  BasicNameValuePair paramPair;
  if (params != null) {
    for (    String key : params.keySet()) {
      paramPair=new BasicNameValuePair(key,params.getString(key));
      paramsList.add(paramPair);
    }
  }
  HttpParams httpParameters=new BasicHttpParams();
  HttpConnectionParams.setConnectionTimeout(httpParameters,CONNECTION_TIME_OUT);
  HttpConnectionParams.setSoTimeout(httpParameters,SOCKET_TIME_OUT);
  try {
    httpRequest.setEntity(new UrlEncodedFormEntity(paramsList,HTTP.UTF_8));
    HttpResponse httpResponse=new DefaultHttpClient(httpParameters).execute(httpRequest);
    if (httpResponse.getStatusLine().getStatusCode() == SUCCESS_STATUS) {
      String strResult=EntityUtils.toString(httpResponse.getEntity());
      return strResult;
    }
 else {
      LogUtils.logD(""String_Node_Str"");
      return null;
    }
  }
 catch (  Exception e) {
    LogUtils.logD(e.getMessage());
    return null;
  }
}","public static String doPost(String url,Bundle params){
  HttpPost httpRequest=new HttpPost(url);
  List paramsList=new ArrayList();
  BasicNameValuePair paramPair;
  if (params != null) {
    for (    String key : params.keySet()) {
      paramPair=new BasicNameValuePair(key,params.getString(key));
      paramsList.add(paramPair);
    }
  }
  HttpParams httpParameters=new BasicHttpParams();
  HttpConnectionParams.setConnectionTimeout(httpParameters,CONNECTION_TIME_OUT);
  HttpConnectionParams.setSoTimeout(httpParameters,SOCKET_TIME_OUT);
  try {
    httpRequest.setEntity(new UrlEncodedFormEntity(paramsList,HTTP.UTF_8));
    HttpResponse httpResponse=new DefaultHttpClient(httpParameters).execute(httpRequest);
    if (httpResponse.getStatusLine().getStatusCode() == SUCCESS_STATUS) {
      String strResult=EntityUtils.toString(httpResponse.getEntity());
      return strResult;
    }
 else {
      LogUtils.logD(""String_Node_Str"");
      return null;
    }
  }
 catch (  Exception e) {
    LogUtils.logD(e.getMessage());
    return null;
  }
}",0.9966618979494516
5895,"public String doGet(String url,Bundle params){
  if (params != null) {
    StringBuilder sb=new StringBuilder();
    boolean first=true;
    for (    String key : params.keySet()) {
      if (first) {
        first=false;
      }
 else {
        sb.append(""String_Node_Str"");
      }
      sb.append(URLEncoder.encode(key) + ""String_Node_Str"" + URLEncoder.encode(params.getString(key)));
    }
    url=url + ""String_Node_Str"" + sb.toString();
  }
  HttpGet httpRequest=new HttpGet(url);
  HttpParams httpParameters=new BasicHttpParams();
  HttpConnectionParams.setConnectionTimeout(httpParameters,CONNECTION_TIME_OUT);
  HttpConnectionParams.setSoTimeout(httpParameters,SOCKET_TIME_OUT);
  try {
    HttpResponse httpResponse=new DefaultHttpClient(httpParameters).execute(httpRequest);
    if (httpResponse.getStatusLine().getStatusCode() == SUCCESS_STATUS) {
      String strResult=EntityUtils.toString(httpResponse.getEntity());
      return strResult;
    }
 else {
      LogUtils.logD(""String_Node_Str"");
      return null;
    }
  }
 catch (  Exception e) {
    LogUtils.logD(e.getMessage());
    return null;
  }
}","public static String doGet(String url,Bundle params){
  if (params != null) {
    StringBuilder sb=new StringBuilder();
    boolean first=true;
    for (    String key : params.keySet()) {
      if (first) {
        first=false;
      }
 else {
        sb.append(""String_Node_Str"");
      }
      sb.append(URLEncoder.encode(key) + ""String_Node_Str"" + URLEncoder.encode(params.getString(key)));
    }
    url=url + ""String_Node_Str"" + sb.toString();
  }
  HttpGet httpRequest=new HttpGet(url);
  HttpParams httpParameters=new BasicHttpParams();
  HttpConnectionParams.setConnectionTimeout(httpParameters,CONNECTION_TIME_OUT);
  HttpConnectionParams.setSoTimeout(httpParameters,SOCKET_TIME_OUT);
  try {
    HttpResponse httpResponse=new DefaultHttpClient(httpParameters).execute(httpRequest);
    if (httpResponse.getStatusLine().getStatusCode() == SUCCESS_STATUS) {
      String strResult=EntityUtils.toString(httpResponse.getEntity());
      return strResult;
    }
 else {
      LogUtils.logD(""String_Node_Str"");
      return null;
    }
  }
 catch (  Exception e) {
    LogUtils.logD(e.getMessage());
    return null;
  }
}",0.9968847352024922
5896,"public List<Dish> parseDishes(String dishesRespStr) throws JSONException {
  List<Dish> resultList=null;
  JSONObject dishes=new JSONObject(dishesRespStr);
  resultList=new ArrayList<Dish>();
  Dish tempDish=null;
  JSONArray dishArray=dishes.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempDish=new Dish();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempDish.setId(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    tempDish.setName(dishObj.getString(""String_Node_Str""));
    tempDish.setPrice(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    tempDish.setDescription(dishObj.getString(""String_Node_Str""));
    tempDish.setImageServer(dishObj.getString(""String_Node_Str""));
    long createTimeValue=Long.parseLong(dishObj.getString(""String_Node_Str""));
    long updateTimeValue=Long.parseLong(dishObj.getString(""String_Node_Str""));
    Date createTime=new Date();
    Date updateTime=new Date();
    createTime.setTime(createTimeValue);
    updateTime.setTime(updateTimeValue);
    tempDish.setCreateTime(createTime);
    tempDish.setUpdateTime(updateTime);
    resultList.add(tempDish);
  }
  return resultList;
}","public static List<Dish> parseDishes(String dishesRespStr) throws JSONException {
  if (dishesRespStr == null) {
    return null;
  }
  List<Dish> resultList=null;
  JSONObject dishes=new JSONObject(dishesRespStr);
  resultList=new ArrayList<Dish>();
  Dish tempDish=null;
  JSONArray dishArray=dishes.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempDish=new Dish();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempDish.setId(dishObj.getInt(""String_Node_Str""));
    tempDish.setName(dishObj.getString(""String_Node_Str""));
    tempDish.setPrice(dishObj.getInt(""String_Node_Str""));
    tempDish.setDescription(dishObj.getString(""String_Node_Str""));
    tempDish.setImageServer(dishObj.getString(""String_Node_Str""));
    long createTimeValue=dishObj.getLong(""String_Node_Str"");
    long updateTimeValue=dishObj.getLong(""String_Node_Str"");
    Date createTime=new Date();
    Date updateTime=new Date();
    createTime.setTime(createTimeValue);
    updateTime.setTime(updateTimeValue);
    tempDish.setCreateTime(createTime);
    tempDish.setUpdateTime(updateTime);
    resultList.add(tempDish);
  }
  return resultList;
}",0.4633008061094611
5897,"public List<Order> parseOrders(String orderRespStr) throws JSONException {
  List<Order> resultList=null;
  JSONObject orders=new JSONObject(orderRespStr);
  resultList=new ArrayList<Order>();
  Order tempOrder=null;
  JSONArray dishArray=orders.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempOrder=new Order();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempOrder.setId(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    tempOrder.setStatus(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    tempOrder.setOrderTotal(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    long createTimeValue=Long.parseLong(dishObj.getString(""String_Node_Str""));
    long payTimeValue=Long.parseLong(dishObj.getString(""String_Node_Str""));
    Date createTime=new Date();
    Date payTime=new Date();
    createTime.setTime(createTimeValue);
    payTime.setTime(payTimeValue);
    tempOrder.setCreateTime(createTime);
    tempOrder.setPayTime(payTime);
    resultList.add(tempOrder);
  }
  return resultList;
}","public static List<Order> parseOrders(String orderRespStr) throws JSONException {
  if (orderRespStr == null) {
    return null;
  }
  List<Order> resultList=null;
  JSONObject orders=new JSONObject(orderRespStr);
  resultList=new ArrayList<Order>();
  Order tempOrder=null;
  JSONArray dishArray=orders.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempOrder=new Order();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempOrder.setId(dishObj.getInt(""String_Node_Str""));
    tempOrder.setStatus(dishObj.getInt(""String_Node_Str""));
    tempOrder.setOrderTotal(dishObj.getInt(""String_Node_Str""));
    long createTimeValue=dishObj.getLong(""String_Node_Str"");
    long payTimeValue=dishObj.getLong(""String_Node_Str"");
    Date createTime=new Date();
    Date payTime=new Date();
    createTime.setTime(createTimeValue);
    payTime.setTime(payTimeValue);
    tempOrder.setCreateTime(createTime);
    tempOrder.setPayTime(payTime);
    resultList.add(tempOrder);
  }
  return resultList;
}",0.7741321921065145
5898,"public List<OrderDetail> parseOrderDetail(String orderDetailRespStr) throws JSONException {
  List<OrderDetail> resultList=null;
  JSONObject orderDetail=new JSONObject(orderDetailRespStr);
  resultList=new ArrayList<OrderDetail>();
  OrderDetail tempOrderDetail=null;
  JSONArray dishArray=orderDetail.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempOrderDetail=new OrderDetail();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempOrderDetail.setId(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    tempOrderDetail.setOrderId(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    tempOrderDetail.setTableId(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    tempOrderDetail.setDishId(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    tempOrderDetail.setNumber(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    resultList.add(tempOrderDetail);
  }
  return resultList;
}","public static List<OrderDetail> parseOrderDetail(String orderDetailRespStr) throws JSONException {
  if (orderDetailRespStr == null) {
    return null;
  }
  List<OrderDetail> resultList=null;
  JSONObject orderDetail=new JSONObject(orderDetailRespStr);
  resultList=new ArrayList<OrderDetail>();
  OrderDetail tempOrderDetail=null;
  JSONArray dishArray=orderDetail.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempOrderDetail=new OrderDetail();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempOrderDetail.setId(dishObj.getInt(""String_Node_Str""));
    tempOrderDetail.setOrderId(dishObj.getInt(""String_Node_Str""));
    tempOrderDetail.setTableId(dishObj.getInt(""String_Node_Str""));
    tempOrderDetail.setDishId(dishObj.getInt(""String_Node_Str""));
    tempOrderDetail.setNumber(dishObj.getInt(""String_Node_Str""));
    resultList.add(tempOrderDetail);
  }
  return resultList;
}",0.6494464944649446
5899,"public List<DishCategory> parseDishCategory(String dishCategoryRespStr) throws JSONException {
  List<DishCategory> resultList=null;
  JSONObject dishCategory=new JSONObject(dishCategoryRespStr);
  resultList=new ArrayList<DishCategory>();
  DishCategory tempDishCategory=null;
  JSONArray dishArray=dishCategory.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempDishCategory=new DishCategory();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempDishCategory.setDishId(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    tempDishCategory.setCategoryId(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    resultList.add(tempDishCategory);
  }
  return resultList;
}","public static List<DishCategory> parseDishCategory(String dishCategoryRespStr) throws JSONException {
  if (dishCategoryRespStr == null) {
    return null;
  }
  List<DishCategory> resultList=null;
  JSONObject dishCategory=new JSONObject(dishCategoryRespStr);
  resultList=new ArrayList<DishCategory>();
  DishCategory tempDishCategory=null;
  JSONArray dishArray=dishCategory.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempDishCategory=new DishCategory();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempDishCategory.setDishId(dishObj.getInt(""String_Node_Str""));
    tempDishCategory.setCategoryId(dishObj.getInt(""String_Node_Str""));
    resultList.add(tempDishCategory);
  }
  return resultList;
}",0.9196488858879136
5900,"public List<DiningTable> parseDiningTables(String diningTablesRespStr) throws JSONException {
  List<DiningTable> resultList=null;
  JSONObject diningTables=new JSONObject(diningTablesRespStr);
  resultList=new ArrayList<DiningTable>();
  DiningTable tempDiningTable=null;
  JSONArray dishArray=diningTables.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempDiningTable=new DiningTable();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempDiningTable.setId(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    tempDiningTable.setName(dishObj.getString(""String_Node_Str""));
    tempDiningTable.setMaxPeople(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    int free=Integer.parseInt(dishObj.getString(""String_Node_Str""));
    tempDiningTable.setFree(free == 0 ? true : false);
    resultList.add(tempDiningTable);
  }
  return resultList;
}","public static List<DiningTable> parseDiningTables(String diningTablesRespStr) throws JSONException {
  if (diningTablesRespStr == null) {
    return null;
  }
  List<DiningTable> resultList=null;
  JSONObject diningTables=new JSONObject(diningTablesRespStr);
  resultList=new ArrayList<DiningTable>();
  DiningTable tempDiningTable=null;
  JSONArray dishArray=diningTables.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempDiningTable=new DiningTable();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempDiningTable.setId(dishObj.getInt(""String_Node_Str""));
    tempDiningTable.setName(dishObj.getString(""String_Node_Str""));
    tempDiningTable.setMaxPeople(dishObj.getInt(""String_Node_Str""));
    int free=dishObj.getInt(""String_Node_Str"");
    tempDiningTable.setFree(free == 0 ? true : false);
    resultList.add(tempDiningTable);
  }
  return resultList;
}",0.7560706401766004
5901,"public List<Config> parseConfigs(String configsRespStr) throws JSONException {
  List<Config> resultList=null;
  JSONObject configs=new JSONObject(configsRespStr);
  resultList=new ArrayList<Config>();
  Config tempConfig=null;
  JSONArray dishArray=configs.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempConfig=new Config();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempConfig.setId(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    tempConfig.setName(dishObj.getString(""String_Node_Str""));
    tempConfig.setValue(dishObj.getString(""String_Node_Str""));
    tempConfig.setDescription(dishObj.getString(""String_Node_Str""));
    resultList.add(tempConfig);
  }
  return resultList;
}","public static List<Config> parseConfigs(String configsRespStr) throws JSONException {
  if (configsRespStr == null) {
    return null;
  }
  List<Config> resultList=null;
  JSONObject configs=new JSONObject(configsRespStr);
  resultList=new ArrayList<Config>();
  Config tempConfig=null;
  JSONArray dishArray=configs.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempConfig=new Config();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempConfig.setId(dishObj.getInt(""String_Node_Str""));
    tempConfig.setName(dishObj.getString(""String_Node_Str""));
    tempConfig.setValue(dishObj.getString(""String_Node_Str""));
    tempConfig.setDescription(dishObj.getString(""String_Node_Str""));
    resultList.add(tempConfig);
  }
  return resultList;
}",0.9094462540716612
5902,"public List<Category> parseCategories(String categoryRespStr) throws JSONException {
  List<Category> resultList=null;
  JSONObject categories=new JSONObject(categoryRespStr);
  resultList=new ArrayList<Category>();
  Category tempCategory=null;
  JSONArray dishArray=categories.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempCategory=new Category();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempCategory.setId(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    tempCategory.setName(dishObj.getString(""String_Node_Str""));
    tempCategory.setDescription(dishObj.getString(""String_Node_Str""));
    tempCategory.setSortOrder(Integer.parseInt(dishObj.getString(""String_Node_Str"")));
    resultList.add(tempCategory);
  }
  return resultList;
}","public static List<Category> parseCategories(String categoryRespStr) throws JSONException {
  if (categoryRespStr == null) {
    return null;
  }
  List<Category> resultList=null;
  JSONObject categories=new JSONObject(categoryRespStr);
  resultList=new ArrayList<Category>();
  Category tempCategory=null;
  JSONArray dishArray=categories.getJSONArray(""String_Node_Str"");
  for (int i=0; i < dishArray.length(); i++) {
    tempCategory=new Category();
    JSONObject dishObj=dishArray.getJSONObject(i);
    tempCategory.setId(dishObj.getInt(""String_Node_Str""));
    tempCategory.setName(dishObj.getString(""String_Node_Str""));
    tempCategory.setDescription(dishObj.getString(""String_Node_Str""));
    tempCategory.setSortOrder(dishObj.getInt(""String_Node_Str""));
    resultList.add(tempCategory);
  }
  return resultList;
}",0.6101903007980356
5903,"@Override public EntityManagerFactory createEntityManagerFactory(String emName,Map map){
  try {
    Map integration=map == null ? CollectionHelper.EMPTY_MAP : Collections.unmodifiableMap(map);
    Enumeration<URL> persistenceXml=Thread.currentThread().getContextClassLoader().getResources(""String_Node_Str"");
    if (!persistenceXml.hasMoreElements()) {
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + (emName != null ? emName : ""String_Node_Str""));
    }
    while (persistenceXml.hasMoreElements()) {
      URL url=persistenceXml.nextElement();
      List<PersistenceMetadata> metadataFiles=PersistenceXmlLoader.deploy(url,integration,new EJB3DTDEntityResolver(),PersistenceUnitTransactionType.RESOURCE_LOCAL);
      for (      PersistenceMetadata metadata : metadataFiles) {
        if (metadata.getProvider() == null || IMPLEMENTATION_NAME.equalsIgnoreCase(metadata.getProvider())) {
          Map<Object,Object> protectiveCopy=new HashMap<Object,Object>(map);
          enforceOgmConfig(protectiveCopy);
          protectiveCopy.put(HibernatePersistence.PROVIDER,delegate.getClass().getName());
          return delegate.createEntityManagerFactory(emName,protectiveCopy);
        }
      }
    }
    return null;
  }
 catch (  Exception e) {
    if (e instanceof PersistenceException) {
      throw (PersistenceException)e;
    }
 else {
      throw new PersistenceException(""String_Node_Str"",e);
    }
  }
}","@Override public EntityManagerFactory createEntityManagerFactory(String emName,Map map){
  try {
    Map integration=map == null ? CollectionHelper.EMPTY_MAP : Collections.unmodifiableMap(map);
    Enumeration<URL> persistenceXml=Thread.currentThread().getContextClassLoader().getResources(""String_Node_Str"");
    if (!persistenceXml.hasMoreElements()) {
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + (emName != null ? emName : ""String_Node_Str""));
    }
    while (persistenceXml.hasMoreElements()) {
      URL url=persistenceXml.nextElement();
      List<PersistenceMetadata> metadataFiles=PersistenceXmlLoader.deploy(url,integration,new EJB3DTDEntityResolver(),PersistenceUnitTransactionType.RESOURCE_LOCAL);
      for (      PersistenceMetadata metadata : metadataFiles) {
        if (metadata.getProvider() == null || IMPLEMENTATION_NAME.equalsIgnoreCase(metadata.getProvider())) {
          Map<Object,Object> protectiveCopy=new HashMap<Object,Object>(integration);
          enforceOgmConfig(protectiveCopy);
          protectiveCopy.put(HibernatePersistence.PROVIDER,delegate.getClass().getName());
          return delegate.createEntityManagerFactory(emName,protectiveCopy);
        }
      }
    }
    return null;
  }
 catch (  Exception e) {
    if (e instanceof PersistenceException) {
      throw (PersistenceException)e;
    }
 else {
      throw new PersistenceException(""String_Node_Str"",e);
    }
  }
}",0.9950877192982456
5904,"private void enforceOgmConfig(Map<Object,Object> map){
  map.put(AvailableSettings.SESSION_FACTORY_OBSERVER,GridMetadataManager.class.getName());
  map.put(AvailableSettings.NAMING_STRATEGY,OgmNamingStrategy.class.getName());
  map.put(Environment.CONNECTION_PROVIDER,NoopConnectionProvider.class);
  map.put(Environment.DIALECT,NoopDialect.class);
}","private void enforceOgmConfig(Map<Object,Object> map){
  map.put(AvailableSettings.SESSION_FACTORY_OBSERVER,GridMetadataManager.class.getName());
  map.put(AvailableSettings.NAMING_STRATEGY,OgmNamingStrategy.class.getName());
  map.put(Environment.CONNECTION_PROVIDER,NoopConnectionProvider.class.getName());
  map.put(Environment.DIALECT,NoopDialect.class.getName());
}",0.9722222222222222
5905,"@Test public void doTest() throws Exception {
  getTransactionManager().begin();
  final EntityManager em=getFactory().createEntityManager();
  Poem poem=new Poem();
  poem.setName(""String_Node_Str"");
  em.persist(poem);
  getTransactionManager().commit();
  em.clear();
  getTransactionManager().begin();
  poem=em.find(Poem.class,poem.getId());
  assertThat(poem).isNotNull();
  assertThat(poem.getName()).isEqualTo(""String_Node_Str"");
  em.remove(poem);
  getTransactionManager().commit();
}","@Test public void doTest() throws Exception {
  getTransactionManager().begin();
  final EntityManager em=getFactory().createEntityManager();
  Poem poem=new Poem();
  poem.setName(""String_Node_Str"");
  em.persist(poem);
  getTransactionManager().commit();
  em.clear();
  getTransactionManager().begin();
  poem=em.find(Poem.class,poem.getId());
  assertThat(poem).isNotNull();
  assertThat(poem.getName()).isEqualTo(""String_Node_Str"");
  em.remove(poem);
  getTransactionManager().commit();
  em.close();
}",0.9860279441117764
5906,"@Before public void createFactory() throws MalformedURLException {
  GetterPersistenceUnitInfo info=new GetterPersistenceUnitInfo();
  info.setClassLoader(Thread.currentThread().getContextClassLoader());
  info.setExcludeUnlistedClasses(true);
  info.setJtaDataSource(null);
  List<String> classNames=new ArrayList<String>();
  for (  Class<?> clazz : getEntities()) {
    classNames.add(clazz.getName());
  }
  info.setManagedClassNames(classNames);
  info.setNonJtaDataSource(null);
  info.setPersistenceProviderClassName(HibernateOgmPersistence.class.getName());
  info.setPersistenceUnitName(""String_Node_Str"");
  final URL persistenceUnitRootUrl=new File(""String_Node_Str"").toURI().toURL();
  info.setPersistenceUnitRootUrl(persistenceUnitRootUrl);
  info.setPersistenceXMLSchemaVersion(""String_Node_Str"");
  info.setProperties(new Properties());
  info.setSharedCacheMode(SharedCacheMode.ENABLE_SELECTIVE);
  info.setTransactionType(PersistenceUnitTransactionType.JTA);
  info.setValidationMode(ValidationMode.AUTO);
  info.getProperties().setProperty(Environment.TRANSACTION_MANAGER_STRATEGY,JBossTSStandaloneTransactionManagerLookup.class.getName());
  factory=new HibernateOgmPersistence().createContainerEntityManagerFactory(info,Collections.EMPTY_MAP);
  transactionManager=new JBossTSStandaloneTransactionManagerLookup().getTransactionManager(null);
}","@Before public void createFactory() throws MalformedURLException {
  arjPropertyManager.getCoordinatorEnvironmentBean().setActionStore(VolatileStore.class.getName());
  transactionManager=new JBossTSStandaloneTransactionManagerLookup().getTransactionManager(null);
  GetterPersistenceUnitInfo info=new GetterPersistenceUnitInfo();
  info.setClassLoader(Thread.currentThread().getContextClassLoader());
  info.setExcludeUnlistedClasses(true);
  info.setJtaDataSource(null);
  List<String> classNames=new ArrayList<String>();
  for (  Class<?> clazz : getEntities()) {
    classNames.add(clazz.getName());
  }
  info.setManagedClassNames(classNames);
  info.setNonJtaDataSource(null);
  info.setPersistenceProviderClassName(HibernateOgmPersistence.class.getName());
  info.setPersistenceUnitName(""String_Node_Str"");
  final URL persistenceUnitRootUrl=new File(""String_Node_Str"").toURI().toURL();
  info.setPersistenceUnitRootUrl(persistenceUnitRootUrl);
  info.setPersistenceXMLSchemaVersion(""String_Node_Str"");
  info.setProperties(new Properties());
  info.setSharedCacheMode(SharedCacheMode.ENABLE_SELECTIVE);
  info.setTransactionType(PersistenceUnitTransactionType.JTA);
  info.setValidationMode(ValidationMode.AUTO);
  info.getProperties().setProperty(Environment.TRANSACTION_MANAGER_STRATEGY,JBossTSStandaloneTransactionManagerLookup.class.getName());
  factory=new HibernateOgmPersistence().createContainerEntityManagerFactory(info,Collections.EMPTY_MAP);
}",0.8952583156404812
5907,"public void testUnidirectionalCollection() throws Exception {
  final Session session=openSession();
  Transaction transaction=session.beginTransaction();
  SnowFlake sf=new SnowFlake();
  sf.setDescription(""String_Node_Str"");
  session.save(sf);
  SnowFlake sf2=new SnowFlake();
  sf.setDescription(""String_Node_Str"");
  session.save(sf2);
  Cloud cloud=new Cloud();
  cloud.setLength(23);
  cloud.getProducedSnowFlakes().add(sf);
  cloud.getProducedSnowFlakes().add(sf2);
  session.persist(cloud);
  transaction.commit();
  session.clear();
  transaction=session.beginTransaction();
  cloud=(Cloud)session.get(Cloud.class,cloud.getId());
  assertNotNull(cloud.getProducedSnowFlakes());
  assertEquals(2,cloud.getProducedSnowFlakes().size());
  final SnowFlake removedSf=cloud.getProducedSnowFlakes().iterator().next();
  SnowFlake sf3=new SnowFlake();
  sf3.setDescription(""String_Node_Str"");
  session.persist(sf3);
  cloud.getProducedSnowFlakes().remove(removedSf);
  cloud.getProducedSnowFlakes().add(sf3);
  transaction.commit();
  session.clear();
  transaction=session.beginTransaction();
  cloud=(Cloud)session.get(Cloud.class,cloud.getId());
  assertNotNull(cloud.getProducedSnowFlakes());
  assertEquals(2,cloud.getProducedSnowFlakes().size());
  boolean present=false;
  for (  SnowFlake current : cloud.getProducedSnowFlakes()) {
    if (current.getDescription().equals(removedSf.getDescription())) {
      present=true;
    }
  }
  assertFalse(""String_Node_Str"",present);
  for (  SnowFlake current : cloud.getProducedSnowFlakes()) {
    session.delete(current);
  }
  session.delete(session.load(SnowFlake.class,removedSf.getId()));
  cloud.getProducedSnowFlakes().clear();
  transaction.commit();
  session.clear();
  transaction=session.beginTransaction();
  cloud=(Cloud)session.get(Cloud.class,cloud.getId());
  assertNotNull(cloud.getProducedSnowFlakes());
  assertEquals(0,cloud.getProducedSnowFlakes().size());
  session.delete(cloud);
  transaction.commit();
  session.close();
}","public void testUnidirectionalCollection() throws Exception {
  final Session session=openSession();
  Transaction transaction=session.beginTransaction();
  SnowFlake sf=new SnowFlake();
  sf.setDescription(""String_Node_Str"");
  session.save(sf);
  SnowFlake sf2=new SnowFlake();
  sf2.setDescription(""String_Node_Str"");
  session.save(sf2);
  Cloud cloud=new Cloud();
  cloud.setLength(23);
  cloud.getProducedSnowFlakes().add(sf);
  cloud.getProducedSnowFlakes().add(sf2);
  session.persist(cloud);
  transaction.commit();
  session.clear();
  transaction=session.beginTransaction();
  cloud=(Cloud)session.get(Cloud.class,cloud.getId());
  assertNotNull(cloud.getProducedSnowFlakes());
  assertEquals(2,cloud.getProducedSnowFlakes().size());
  final SnowFlake removedSf=cloud.getProducedSnowFlakes().iterator().next();
  SnowFlake sf3=new SnowFlake();
  sf3.setDescription(""String_Node_Str"");
  session.persist(sf3);
  cloud.getProducedSnowFlakes().remove(removedSf);
  cloud.getProducedSnowFlakes().add(sf3);
  transaction.commit();
  session.clear();
  transaction=session.beginTransaction();
  cloud=(Cloud)session.get(Cloud.class,cloud.getId());
  assertNotNull(cloud.getProducedSnowFlakes());
  assertEquals(2,cloud.getProducedSnowFlakes().size());
  boolean present=false;
  for (  SnowFlake current : cloud.getProducedSnowFlakes()) {
    if (current.getDescription().equals(removedSf.getDescription())) {
      present=true;
    }
  }
  assertFalse(""String_Node_Str"",present);
  for (  SnowFlake current : cloud.getProducedSnowFlakes()) {
    session.delete(current);
  }
  session.delete(session.load(SnowFlake.class,removedSf.getId()));
  cloud.getProducedSnowFlakes().clear();
  transaction.commit();
  session.clear();
  transaction=session.beginTransaction();
  cloud=(Cloud)session.get(Cloud.class,cloud.getId());
  assertNotNull(cloud.getProducedSnowFlakes());
  assertEquals(0,cloud.getProducedSnowFlakes().size());
  session.delete(cloud);
  transaction.commit();
  session.close();
}",0.9997503121098626
5908,"/** 
 * copied from Loader#endCollectionLoad
 */
private void endCollectionLoad(final Object resultSetId,final SessionImplementor session,final CollectionPersister collectionPersister){
  session.getPersistenceContext().getLoadContexts().getCollectionLoadContext(null).endLoadingCollections(collectionPersister);
}","/** 
 * copied from Loader#endCollectionLoad
 */
private void endCollectionLoad(final Object resultSetId,final SessionImplementor session,final CollectionPersister collectionPersister){
  session.getPersistenceContext().getLoadContexts().getCollectionLoadContext(resultSetId).endLoadingCollections(collectionPersister);
}",0.9826771653543308
5909,"/** 
 * Execute the physical query and initialize the various entities and collections
 */
private Object doQuery(SessionImplementor session,Serializable id,Type identifierType,Object optionalObject,String optionalEntityName,Serializable optionalId,LockOptions lockOptions,boolean returnProxies){
  int entitySpan=1;
  final List<Object> hydratedObjects=entitySpan == 0 ? null : new ArrayList<Object>(entitySpan * 10);
  TupleAsMapResultSet resultset=getResultSet(id,session);
  QueryParameters qp=new QueryParameters();
  qp.setPositionalParameterTypes(new Type[]{identifierType});
  qp.setPositionalParameterValues(new Object[]{id});
  qp.setOptionalObject(optionalObject);
  qp.setOptionalEntityName(optionalEntityName);
  qp.setOptionalId(optionalId);
  qp.setLockOptions(lockOptions);
  handleEmptyCollections(qp.getCollectionKeys(),resultset,session);
  final org.hibernate.engine.EntityKey[] keys=new org.hibernate.engine.EntityKey[entitySpan];
  Object result=null;
  try {
    while (resultset.next()) {
      result=getRowFromResultSet(resultset,session,qp,optionalId,hydratedObjects,keys,returnProxies);
    }
  }
 catch (  SQLException e) {
  }
  initializeEntitiesAndCollections(hydratedObjects,resultset,session,qp.isReadOnly(session));
  return result;
}","/** 
 * Execute the physical query and initialize the various entities and collections
 */
private Object doQuery(SessionImplementor session,Serializable id,Type identifierType,Object optionalObject,String optionalEntityName,Serializable optionalId,LockOptions lockOptions,boolean returnProxies){
  int entitySpan=entityPersisters.length;
  final List<Object> hydratedObjects=entitySpan == 0 ? null : new ArrayList<Object>(entitySpan * 10);
  TupleAsMapResultSet resultset=getResultSet(id,session);
  QueryParameters qp=new QueryParameters();
  qp.setPositionalParameterTypes(new Type[]{identifierType});
  qp.setPositionalParameterValues(new Object[]{id});
  qp.setOptionalObject(optionalObject);
  qp.setOptionalEntityName(optionalEntityName);
  qp.setOptionalId(optionalId);
  qp.setLockOptions(lockOptions);
  handleEmptyCollections(qp.getCollectionKeys(),resultset,session);
  final org.hibernate.engine.EntityKey[] keys=new org.hibernate.engine.EntityKey[entitySpan];
  Object result=null;
  try {
    while (resultset.next()) {
      result=getRowFromResultSet(resultset,session,qp,optionalId,hydratedObjects,keys,returnProxies);
    }
  }
 catch (  SQLException e) {
  }
  initializeEntitiesAndCollections(hydratedObjects,resultset,session,qp.isReadOnly(session));
  return result;
}",0.990625
5910,"public void dehydrate(){
  if (log.isTraceEnabled()) {
    log.trace(""String_Node_Str"" + MessageHelper.infoString(persister,id,persister.getFactory()));
  }
  final EntityMetamodel entityMetamodel=persister.getEntityMetamodel();
  final boolean[] uniqueness=persister.getPropertyUniqueness();
  final Cache<PropertyKey,List<Serializable>> propertyCache=GridMetadataManagerHelper.getPropertyCache(session.getFactory());
  for (int index=0; index < entityMetamodel.getPropertySpan(); index++) {
    if (persister.isPropertyOfTable(index,tableIndex)) {
      if (removePropertyMetadata) {
        if (uniqueness[index]) {
          Object[] oldColumnValues=Helper.getColumnValuesFromResultset(resultset,index,persister);
          PropertyKey propertyKey=new PropertyKey(persister.getTableName(tableIndex),persister.getPropertyNames()[index],oldColumnValues);
          List<Serializable> propertyValues=propertyCache.get(propertyKey);
          if (propertyValues != null) {
            final boolean lastId=propertyValues.size() == 1 && id.equals(propertyValues.get(0));
            if (lastId) {
              propertyCache.remove(propertyValues);
            }
 else {
              propertyValues.remove(id);
              propertyCache.put(propertyKey,propertyValues);
            }
          }
        }
      }
      if (dehydrate && includeProperties[index]) {
        gridPropertyTypes[index].nullSafeSet(resultset,fields[index],persister.getPropertyColumnNames(index),includeColumns[index],session);
      }
      if (addPropertyMetadata) {
        if (uniqueness[index]) {
          Object[] newColumnValues=Helper.getColumnValuesFromResultset(resultset,index,persister);
          PropertyKey propertyKey=new PropertyKey(persister.getTableName(tableIndex),persister.getPropertyNames()[index],newColumnValues);
          List<Serializable> propertyValues=propertyCache.get(propertyKey);
          if (propertyValues == null) {
            propertyValues=new ArrayList<Serializable>();
          }
          propertyValues.add(id);
          propertyCache.put(propertyKey,propertyValues);
        }
      }
    }
  }
}","public void dehydrate(){
  if (log.isTraceEnabled()) {
    log.trace(""String_Node_Str"" + MessageHelper.infoString(persister,id,persister.getFactory()));
  }
  final EntityMetamodel entityMetamodel=persister.getEntityMetamodel();
  final boolean[] uniqueness=persister.getPropertyUniqueness();
  final Cache<PropertyKey,List<Serializable>> propertyCache=GridMetadataManagerHelper.getPropertyCache(session.getFactory());
  for (int index=0; index < entityMetamodel.getPropertySpan(); index++) {
    if (persister.isPropertyOfTable(index,tableIndex)) {
      if (removePropertyMetadata) {
        if (uniqueness[index]) {
          Object[] oldColumnValues=Helper.getColumnValuesFromResultset(resultset,index,persister);
          PropertyKey propertyKey=new PropertyKey(persister.getTableName(tableIndex),persister.getPropertyNames()[index],oldColumnValues);
          List<Serializable> propertyValues=propertyCache.get(propertyKey);
          if (propertyValues != null) {
            final boolean lastId=propertyValues.size() == 1 && id.equals(propertyValues.get(0));
            if (lastId) {
              propertyCache.remove(propertyKey);
            }
 else {
              propertyValues.remove(id);
              propertyCache.put(propertyKey,propertyValues);
            }
          }
        }
      }
      if (dehydrate && includeProperties[index]) {
        gridPropertyTypes[index].nullSafeSet(resultset,fields[index],persister.getPropertyColumnNames(index),includeColumns[index],session);
      }
      if (addPropertyMetadata) {
        if (uniqueness[index]) {
          Object[] newColumnValues=Helper.getColumnValuesFromResultset(resultset,index,persister);
          PropertyKey propertyKey=new PropertyKey(persister.getTableName(tableIndex),persister.getPropertyNames()[index],newColumnValues);
          List<Serializable> propertyValues=propertyCache.get(propertyKey);
          if (propertyValues == null) {
            propertyValues=new ArrayList<Serializable>();
          }
          propertyValues.add(id);
          propertyCache.put(propertyKey,propertyValues);
        }
      }
    }
  }
}",0.9978818545540128
5911,"@Override public void mutate(final ILoggingEvent event_){
  final SLoggingEvent1 event=(SLoggingEvent1)event_;
  final String application=Strings.emptyToNull(Objects.firstNonNull(this.application,DefaultLoggingEventMutator.defaultApplication));
  final String component=Strings.emptyToNull(Objects.firstNonNull(this.component,DefaultLoggingEventMutator.defaultComponent));
  final String node=Strings.emptyToNull(Objects.firstNonNull(this.node,DefaultLoggingEventMutator.defaultNode));
  long sequence;
synchronized (this) {
    sequence=this.sequence;
    this.sequence++;
  }
  if (event.mdcPropertyMap == null)   event.mdcPropertyMap=new HashMap<String,String>(3);
 else   event.mdcPropertyMap=new HashMap<String,String>(event.mdcPropertyMap);
  if ((application != null) && !event.mdcPropertyMap.containsKey(DefaultLoggingEventMutator.defaultApplicationMdcName))   event.mdcPropertyMap.put(DefaultLoggingEventMutator.defaultApplicationMdcName,application);
  if ((component != null) && !event.mdcPropertyMap.containsKey(DefaultLoggingEventMutator.defaultComponentMdcName))   event.mdcPropertyMap.put(DefaultLoggingEventMutator.defaultComponentMdcName,component);
  if ((node != null) && !event.mdcPropertyMap.containsKey(DefaultLoggingEventMutator.defaultNodeMdcName))   event.mdcPropertyMap.put(DefaultLoggingEventMutator.defaultNodeMdcName,node);
  event.mdcPropertyMap.put(DefaultLoggingEventMutator.defaultSequenceMdcKey,Long.toString(sequence));
}","@Override public void mutate(final ILoggingEvent event_){
  final SLoggingEvent1 event=(SLoggingEvent1)event_;
  final String application=Strings.emptyToNull(Objects.firstNonNull(this.application,DefaultLoggingEventMutator.defaultApplication));
  final String component=Strings.emptyToNull(Objects.firstNonNull(this.component,DefaultLoggingEventMutator.defaultComponent));
  final String node=Strings.emptyToNull(Objects.firstNonNull(this.node,DefaultLoggingEventMutator.defaultNode));
  long sequence;
synchronized (this) {
    sequence=this.sequence;
    this.sequence++;
  }
  if (event.mdcPropertyMap == null)   event.mdcPropertyMap=new HashMap<String,String>(3);
 else   event.mdcPropertyMap=new HashMap<String,String>(event.mdcPropertyMap);
  if ((application != null) && !event.mdcPropertyMap.containsKey(DefaultLoggingEventMutator.defaultApplicationMdcName))   event.mdcPropertyMap.put(DefaultLoggingEventMutator.defaultApplicationMdcName,application);
  if ((component != null) && !event.mdcPropertyMap.containsKey(DefaultLoggingEventMutator.defaultComponentMdcName))   event.mdcPropertyMap.put(DefaultLoggingEventMutator.defaultComponentMdcName,component);
  if ((node != null) && !event.mdcPropertyMap.containsKey(DefaultLoggingEventMutator.defaultNodeMdcName))   event.mdcPropertyMap.put(DefaultLoggingEventMutator.defaultNodeMdcName,node);
  event.mdcPropertyMap.put(DefaultLoggingEventMutator.defaultSequenceMdcKey,Long.toString(sequence));
  final LinkedList<String> mdcInvalidKeys=new LinkedList<String>();
  for (  final String mdcKey : event.mdcPropertyMap.keySet()) {
    final Object mdcValue=event.mdcPropertyMap.get(mdcKey);
    if (!(mdcValue instanceof String))     mdcInvalidKeys.add(mdcKey);
  }
  for (  final String mdcInvalidKey : mdcInvalidKeys)   event.mdcPropertyMap.remove(mdcInvalidKey);
  if (event.argumentArray != null)   for (int index=0; index < event.argumentArray.length; index++)   if ((event.argumentArray[index] != null) && !(event.argumentArray[index] instanceof Serializable))   event.argumentArray[index]=String.valueOf(event.argumentArray[index]);
}",0.8195890796509991
5912,"public SyncableDatastoreBackgroundWorker(final SyncableDatastoreBackgroundWorkerConfiguration configuration){
  super(configuration);
  this.datastore=Preconditions.checkNotNull(configuration.datastore);
  this.syncReadTimeout=Preconditions.checkNotNull((configuration.syncReadTimeout != null) ? configuration.syncReadTimeout.longValue() : SyncableDatastoreBackgroundWorkerConfiguration.defaultSyncReadTimeout);
  Preconditions.checkArgument((this.syncReadTimeout == -1) || (this.syncReadTimeout > 0));
  this.syncWriteTimeout=Preconditions.checkNotNull((configuration.syncWriteTimeout != null) ? configuration.syncWriteTimeout.longValue() : SyncableDatastoreBackgroundWorkerConfiguration.defaultSyncWriteTimeout);
  Preconditions.checkArgument((this.syncWriteTimeout == -1) || (this.syncWriteTimeout > 0));
  if (this.syncReadTimeout != -1)   this.syncReadDatastore=SyncableImmutableDatastore.class.cast(this.datastore);
 else   this.syncReadDatastore=null;
  if (this.syncWriteTimeout != -1)   this.syncWriteDatastore=SyncableMutableDatastore.class.cast(this.datastore);
 else   this.syncWriteDatastore=null;
  this.cancel=false;
  this.gracefull=false;
}","public SyncableDatastoreBackgroundWorker(final SyncableDatastoreBackgroundWorkerConfiguration configuration){
  super(configuration);
  this.datastore=Preconditions.checkNotNull(configuration.datastore);
  this.syncReadTimeout=Preconditions.checkNotNull((configuration.syncReadTimeout != null) ? configuration.syncReadTimeout.longValue() : SyncableDatastoreBackgroundWorkerConfiguration.defaultSyncReadTimeout);
  Preconditions.checkArgument((this.syncReadTimeout == -1) || (this.syncReadTimeout > 0));
  this.syncWriteTimeout=Preconditions.checkNotNull((configuration.syncWriteTimeout != null) ? configuration.syncWriteTimeout.longValue() : SyncableDatastoreBackgroundWorkerConfiguration.defaultSyncWriteTimeout);
  Preconditions.checkArgument((this.syncWriteTimeout == -1) || (this.syncWriteTimeout > 0));
  if (this.syncReadTimeout != -1)   this.syncReadDatastore=SyncableImmutableDatastore.class.cast(this.datastore);
 else   this.syncReadDatastore=null;
  if (this.syncWriteTimeout != -1)   this.syncWriteDatastore=SyncableMutableDatastore.class.cast(this.datastore);
 else   this.syncWriteDatastore=null;
  this.cancel=false;
}",0.9895196506550218
5913,"public final boolean cancel(){
  this.gracefull=true;
  if (this.isCurrentThread()) {
    this.cancel=true;
    return (true);
  }
 else {
    this.requestStop();
    return (this.awaitStop());
  }
}","public final boolean cancel(){
  this.cancel=true;
  if (this.isCurrentThread())   return (true);
 else {
    this.requestStop();
    return (this.awaitStop());
  }
}",0.8986301369863013
5914,"@Override protected final void executeLoop(){
  long lastSyncWriteTimestamp=System.currentTimeMillis();
  long lastSyncReadTimestamp=lastSyncWriteTimestamp;
  while (true) {
    if (this.shouldStopHard())     break;
    if (this.shouldStopSoft()) {
      if (this.gracefull)       break;
 else       this.callbacks.handleLogEvent(Level.WARN,null,""String_Node_Str"");
    }
synchronized (this.monitor) {
      final long currentTimestamp=System.currentTimeMillis();
      if (this.syncWriteDatastore != null) {
        if ((currentTimestamp - lastSyncWriteTimestamp) > this.syncWriteTimeout) {
          this.callbacks.handleLogEvent(Level.DEBUG,null,""String_Node_Str"");
          try {
            if (!this.syncWriteDatastore.syncWrite())             this.callbacks.handleLogEvent(Level.ERROR,null,""String_Node_Str"");
          }
 catch (          final Error exception) {
            this.callbacks.handleException(exception,""String_Node_Str"");
          }
          lastSyncWriteTimestamp=currentTimestamp;
        }
      }
      if (this.syncReadDatastore != null) {
        if ((currentTimestamp - lastSyncReadTimestamp) > this.syncReadTimeout) {
          this.callbacks.handleLogEvent(Level.DEBUG,null,""String_Node_Str"");
          try {
            if (!this.syncReadDatastore.syncRead())             this.callbacks.handleLogEvent(Level.ERROR,null,""String_Node_Str"");
          }
 catch (          final Error exception) {
            this.callbacks.handleException(exception,""String_Node_Str"");
          }
          lastSyncReadTimestamp=currentTimestamp;
        }
      }
    }
    try {
      Thread.sleep(this.waitTimeout);
    }
 catch (    final InterruptedException exception) {
    }
  }
}","@Override protected final void executeLoop(){
  long lastSyncWriteTimestamp=System.currentTimeMillis();
  long lastSyncReadTimestamp=lastSyncWriteTimestamp;
  while (true) {
    if (this.shouldStopHard())     break;
    if (this.shouldStopSoft()) {
      if (this.cancel)       break;
 else       this.callbacks.handleLogEvent(Level.WARN,null,""String_Node_Str"");
    }
synchronized (this.monitor) {
      final long currentTimestamp=System.currentTimeMillis();
      if (this.syncWriteDatastore != null) {
        if ((currentTimestamp - lastSyncWriteTimestamp) > this.syncWriteTimeout) {
          this.callbacks.handleLogEvent(Level.DEBUG,null,""String_Node_Str"");
          try {
            if (!this.syncWriteDatastore.syncWrite())             this.callbacks.handleLogEvent(Level.ERROR,null,""String_Node_Str"");
          }
 catch (          final Error exception) {
            this.callbacks.handleException(exception,""String_Node_Str"");
          }
          lastSyncWriteTimestamp=currentTimestamp;
        }
      }
      if (this.syncReadDatastore != null) {
        if ((currentTimestamp - lastSyncReadTimestamp) > this.syncReadTimeout) {
          this.callbacks.handleLogEvent(Level.DEBUG,null,""String_Node_Str"");
          try {
            if (!this.syncReadDatastore.syncRead())             this.callbacks.handleLogEvent(Level.ERROR,null,""String_Node_Str"");
          }
 catch (          final Error exception) {
            this.callbacks.handleException(exception,""String_Node_Str"");
          }
          lastSyncReadTimestamp=currentTimestamp;
        }
      }
    }
    try {
      Thread.sleep(this.waitTimeout);
    }
 catch (    final InterruptedException exception) {
    }
  }
}",0.9961888009381412
5915,"@Override protected final void finalizeLoop(){
synchronized (this.monitor) {
    this.callbacks.handleLogEvent(Level.DEBUG,null,""String_Node_Str"");
    if (!this.cancel) {
      this.cancel=true;
      this.callbacks.handleLogEvent(Level.WARN,null,""String_Node_Str"");
      if (!this.datastore.close())       this.callbacks.handleLogEvent(Level.ERROR,null,""String_Node_Str"");
    }
    this.callbacks.handleLogEvent(Level.INFO,null,""String_Node_Str"");
  }
}","@Override protected final void finalizeLoop(){
synchronized (this.monitor) {
    this.callbacks.handleLogEvent(Level.DEBUG,null,""String_Node_Str"");
    if (!this.cancel) {
      this.callbacks.handleLogEvent(Level.WARN,null,""String_Node_Str"");
      if (!this.datastore.close())       this.callbacks.handleLogEvent(Level.ERROR,null,""String_Node_Str"");
    }
    this.callbacks.handleLogEvent(Level.INFO,null,""String_Node_Str"");
  }
}",0.9730337078651684
5916,"protected final void disconnect(){
  if (this.connection == null)   throw (new IllegalStateException(""String_Node_Str""));
  this.shouldReconnect=true;
  try {
    try {
      if (this.channel != null)       this.channel.close();
    }
  finally {
      this.connection.close();
    }
  }
 catch (  final Throwable exception) {
    this.exceptionHandler.handleException(""String_Node_Str"",exception);
  }
 finally {
    this.connection=null;
    this.channel=null;
  }
}","protected final void disconnect(){
  if (this.connection == null)   throw (new IllegalStateException(""String_Node_Str""));
  this.callbacks.handleLogEvent(Level.INFO,null,""String_Node_Str"");
  this.shouldReconnect=true;
  try {
    try {
      if (this.channel != null)       this.channel.close();
    }
  finally {
      this.connection.close();
    }
  }
 catch (  final Throwable exception) {
    this.callbacks.handleException(exception,""String_Node_Str"");
  }
 finally {
    this.connection=null;
    this.channel=null;
  }
}",0.4433299899699097
5917,"public final void start(){
synchronized (this) {
    if (this.thread != null)     throw (new IllegalStateException(""String_Node_Str""));
    this.thread=new Thread(new Runnable(){
      public final void run(){
        AmqpAccessor.this.loop();
        if (AmqpAccessor.this.shutdownHook != null)         Runtime.getRuntime().removeShutdownHook(AmqpAccessor.this.shutdownHook);
      }
    }
);
    this.thread.setName(String.format(""String_Node_Str"",this.getClass().getName(),System.identityHashCode(this)));
    this.thread.setDaemon(true);
    this.shutdownHook=new Thread(new Runnable(){
      public final void run(){
        AmqpAccessor.this.shutdownHook=null;
        if (AmqpAccessor.this.isStarted()) {
          AmqpAccessor.this.stop();
          while (AmqpAccessor.this.isStarted())           try {
            Thread.sleep(AmqpAccessor.waitTimeout);
          }
 catch (          final InterruptedException exception) {
            break;
          }
        }
      }
    }
);
    Runtime.getRuntime().addShutdownHook(this.shutdownHook);
    this.shouldStopLoop=false;
    this.thread.start();
  }
}","public final void start(){
synchronized (this) {
    if (this.thread != null)     throw (new IllegalStateException(""String_Node_Str""));
    this.callbacks.handleLogEvent(Level.INFO,null,""String_Node_Str"");
    this.thread=new Thread(new Runnable(){
      public final void run(){
        AmqpAccessor.this.callbacks.handleLogEvent(Level.INFO,null,""String_Node_Str"");
        AmqpAccessor.this.loop();
        if (AmqpAccessor.this.shutdownHook != null)         Runtime.getRuntime().removeShutdownHook(AmqpAccessor.this.shutdownHook);
        AmqpAccessor.this.callbacks.handleLogEvent(Level.INFO,null,""String_Node_Str"");
      }
    }
);
    this.thread.setName(String.format(""String_Node_Str"",this.getClass().getName(),System.identityHashCode(this)));
    this.thread.setDaemon(true);
    this.shutdownHook=new Thread(new Runnable(){
      public final void run(){
        AmqpAccessor.this.shutdownHook=null;
        if (AmqpAccessor.this.isRunning()) {
          if (!AmqpAccessor.this.shouldStopLoop)           AmqpAccessor.this.stop();
          while (AmqpAccessor.this.isRunning())           try {
            Thread.sleep(AmqpAccessor.waitTimeout);
          }
 catch (          final InterruptedException exception) {
            break;
          }
        }
      }
    }
);
    Runtime.getRuntime().addShutdownHook(this.shutdownHook);
    this.shouldStopLoop=false;
    this.thread.start();
  }
}",0.8345894486314954
5918,"public void shutdownCompleted(final ShutdownSignalException exception){
  AmqpAccessor.this.shouldReconnect=true;
  if (!exception.isInitiatedByApplication())   AmqpAccessor.this.exceptionHandler.handleException(""String_Node_Str"",exception);
}","public void shutdownCompleted(final ShutdownSignalException exception){
  AmqpAccessor.this.shouldReconnect=true;
  if (!exception.isInitiatedByApplication()) {
    AmqpAccessor.this.callbacks.handleException(exception,""String_Node_Str"");
    AmqpAccessor.this.disconnect();
  }
}",0.8298279158699808
5919,"public final void run(){
  AmqpAccessor.this.shutdownHook=null;
  if (AmqpAccessor.this.isStarted()) {
    AmqpAccessor.this.stop();
    while (AmqpAccessor.this.isStarted())     try {
      Thread.sleep(AmqpAccessor.waitTimeout);
    }
 catch (    final InterruptedException exception) {
      break;
    }
  }
}","public final void run(){
  AmqpAccessor.this.shutdownHook=null;
  if (AmqpAccessor.this.isRunning()) {
    if (!AmqpAccessor.this.shouldStopLoop)     AmqpAccessor.this.stop();
    while (AmqpAccessor.this.isRunning())     try {
      Thread.sleep(AmqpAccessor.waitTimeout);
    }
 catch (    final InterruptedException exception) {
      break;
    }
  }
}",0.8819133034379671
5920,"protected AmqpAccessor(final String host,final Integer port,final String virtualHost,final String username,final String password,final ExceptionHandler exceptionHandler){
  super();
  this.host=((host != null) && !host.isEmpty()) ? host : ""String_Node_Str"";
  this.port=((port != null) && (port != 0)) ? port : 5672;
  this.virtualHost=((virtualHost != null) && !virtualHost.isEmpty()) ? virtualHost : ""String_Node_Str"";
  this.username=((username != null) && !username.isEmpty()) ? username : ""String_Node_Str"";
  this.password=((password != null) && !password.isEmpty()) ? password : ""String_Node_Str"";
  this.exceptionHandler=exceptionHandler;
  this.thread=null;
  this.shutdownHook=null;
  this.shouldStopLoop=true;
  this.connection=null;
  this.channel=null;
  this.shouldReconnect=true;
}","protected AmqpAccessor(final String host,final Integer port,final String virtualHost,final String username,final String password,final Callbacks callbacks){
  super();
  this.host=((host != null) && !host.isEmpty()) ? host : ""String_Node_Str"";
  this.port=((port != null) && (port != 0)) ? port : 5672;
  this.virtualHost=((virtualHost != null) && !virtualHost.isEmpty()) ? virtualHost : ""String_Node_Str"";
  this.username=((username != null) && !username.isEmpty()) ? username : ""String_Node_Str"";
  this.password=((password != null) && !password.isEmpty()) ? password : ""String_Node_Str"";
  this.callbacks=callbacks;
  this.thread=null;
  this.shutdownHook=null;
  this.shouldStopLoop=true;
  this.connection=null;
  this.channel=null;
  this.shouldReconnect=true;
}",0.887468030690537
5921,"public final void stop(){
synchronized (this) {
    if (this.thread == null)     throw (new IllegalStateException(""String_Node_Str""));
    this.shouldStopLoop=true;
  }
}","public final void stop(){
synchronized (this) {
    if (this.thread == null)     throw (new IllegalStateException(""String_Node_Str""));
    this.callbacks.handleLogEvent(Level.INFO,null,""String_Node_Str"");
    this.shouldStopLoop=true;
  }
}",0.7804878048780488
5922,"protected final boolean connect(){
synchronized (this) {
    if (this.connection != null)     throw (new IllegalStateException(""String_Node_Str""));
    this.shouldReconnect=true;
    final ConnectionFactory connectionFactory=new ConnectionFactory();
    connectionFactory.setHost(this.host);
    connectionFactory.setPort(this.port);
    connectionFactory.setVirtualHost(this.virtualHost);
    connectionFactory.setUsername(this.username);
    connectionFactory.setPassword(this.password);
    try {
      this.connection=connectionFactory.newConnection();
    }
 catch (    final Throwable exception) {
      this.connection=null;
      this.exceptionHandler.handleException(""String_Node_Str"",exception);
    }
    if (this.connection != null)     try {
      this.channel=this.connection.createChannel();
    }
 catch (    final Throwable exception) {
      this.channel=null;
      this.exceptionHandler.handleException(""String_Node_Str"",exception);
    }
    if ((this.connection == null) || (this.channel == null)) {
      if (this.connection != null)       this.disconnect();
    }
    if (this.connection != null) {
      this.connection.addShutdownListener(new ShutdownListener(){
        public void shutdownCompleted(        final ShutdownSignalException exception){
          AmqpAccessor.this.shouldReconnect=true;
          if (!exception.isInitiatedByApplication())           AmqpAccessor.this.exceptionHandler.handleException(""String_Node_Str"",exception);
        }
      }
);
      this.shouldReconnect=false;
    }
    return (this.connection != null);
  }
}","protected final boolean connect(){
synchronized (this) {
    if (this.connection != null)     throw (new IllegalStateException(""String_Node_Str""));
    this.callbacks.handleLogEvent(Level.INFO,null,""String_Node_Str"",this.username,this.host,this.port,this.virtualHost);
    this.shouldReconnect=true;
    final ConnectionFactory connectionFactory=new ConnectionFactory();
    connectionFactory.setHost(this.host);
    connectionFactory.setPort(this.port);
    connectionFactory.setVirtualHost(this.virtualHost);
    connectionFactory.setUsername(this.username);
    connectionFactory.setPassword(this.password);
    try {
      this.connection=connectionFactory.newConnection();
    }
 catch (    final Throwable exception) {
      this.connection=null;
      this.callbacks.handleException(exception,""String_Node_Str"");
    }
    if (this.connection != null)     try {
      this.channel=this.connection.createChannel();
    }
 catch (    final Throwable exception) {
      this.channel=null;
      this.callbacks.handleException(exception,""String_Node_Str"");
    }
    if ((this.connection == null) || (this.channel == null)) {
      if (this.connection != null)       this.disconnect();
    }
    if (this.connection != null) {
      this.connection.addShutdownListener(new ShutdownListener(){
        public void shutdownCompleted(        final ShutdownSignalException exception){
          AmqpAccessor.this.shouldReconnect=true;
          if (!exception.isInitiatedByApplication()) {
            AmqpAccessor.this.callbacks.handleException(exception,""String_Node_Str"");
            AmqpAccessor.this.disconnect();
          }
        }
      }
);
      this.shouldReconnect=false;
      this.callbacks.handleLogEvent(Level.INFO,null,""String_Node_Str"");
    }
    return (this.connection != null);
  }
}",0.4849201655824955
5923,"public final void start(){
  if (this.isStarted())   throw (new IllegalStateException(""String_Node_Str""));
  if (this.publisher != null)   throw (new IllegalStateException(""String_Node_Str""));
  this.exchangeLayout.start();
  this.routingKeyLayout.start();
  this.publisher=new AmqpPublisher(this.host,this.port,this.virtualHost,this.username,this.password,this,this.buffer);
  this.publisher.start();
  super.start();
}","public final void start(){
  if (this.isStarted())   throw (new IllegalStateException(""String_Node_Str""));
  if (this.publisher != null)   throw (new IllegalStateException(""String_Node_Str""));
  this.exchangeLayout.start();
  this.routingKeyLayout.start();
  this.publisher=new AmqpPublisher(this.host,this.port,this.virtualHost,this.username,this.password,new DefaultContextAwareCallbacks(this),this.buffer);
  this.publisher.start();
  super.start();
}",0.9519450800915332
5924,"public final boolean isRunning(){
  final AmqpPublisher publisher=this.publisher;
  return (((publisher != null) && publisher.isStarted()) || super.isStarted());
}","public final boolean isRunning(){
  final AmqpPublisher publisher=this.publisher;
  return (((publisher != null) && publisher.isRunning()) || super.isStarted());
}",0.9570552147239264
5925,"public AmqpPublisher(final String host,final Integer port,final String virtualHost,final String username,final String password,final ExceptionHandler exceptionHandler,final LinkedBlockingDeque<AmqpMessage> source){
  super(host,port,virtualHost,username,password,exceptionHandler);
  this.source=source;
}","public AmqpPublisher(final String host,final Integer port,final String virtualHost,final String username,final String password,final Callbacks callbacks,final LinkedBlockingDeque<AmqpMessage> source){
  super(host,port,virtualHost,username,password,callbacks);
  this.source=source;
}",0.8692699490662139
5926,"protected final void loop(){
  loop:   while (true) {
    while (true) {
synchronized (this) {
        if (this.shouldStopLoop())         break loop;
        if (!this.shouldReconnect())         break;
        if (this.reconnect())         break;
      }
      this.sleep();
    }
    while (true) {
synchronized (this) {
        if (this.shouldStopLoop())         break loop;
        if (this.shouldReconnect())         break;
      }
      final AmqpMessage message;
      try {
        message=this.source.poll(AmqpAccessor.waitTimeout,TimeUnit.MILLISECONDS);
      }
 catch (      final InterruptedException exception) {
        continue;
      }
      if (message == null)       continue;
synchronized (this) {
        if (!this.publish(message))         this.source.addFirst(message);
      }
    }
  }
  if (this.isConnected())   this.disconnect();
}","protected final void loop(){
  loop:   while (true) {
    while (true) {
synchronized (this) {
        if (this.shouldStopLoop())         break loop;
        if (!this.shouldReconnect())         break;
        if (this.reconnect())         break;
      }
      this.sleep();
    }
    this.callbacks.handleLogEvent(Level.INFO,null,""String_Node_Str"");
    while (true) {
synchronized (this) {
        if (this.shouldStopLoop())         break loop;
        if (this.shouldReconnect())         break;
      }
      final AmqpMessage message;
      try {
        message=this.source.poll(AmqpAccessor.waitTimeout,TimeUnit.MILLISECONDS);
      }
 catch (      final InterruptedException exception) {
        continue;
      }
      if (message == null)       continue;
synchronized (this) {
        if (!this.publish(message))         this.source.addFirst(message);
      }
    }
  }
  if (this.isConnected())   this.disconnect();
}",0.9607623318385652
5927,"private final boolean publish(final AmqpMessage message){
  final Channel channel=this.getChannel();
  final AMQP.BasicProperties properties=new AMQP.BasicProperties();
  properties.setContentType(message.contentType);
  properties.setContentEncoding(message.contentEncoding);
  properties.setDeliveryMode(2);
  try {
    channel.basicPublish(message.exchange,message.routingKey,false,false,properties,message.content);
    return (true);
  }
 catch (  final Throwable exception) {
    this.exceptionHandler.handleException(""String_Node_Str"",exception);
    return (false);
  }
}","private final boolean publish(final AmqpMessage message){
  final Channel channel=this.getChannel();
  final AMQP.BasicProperties properties=new AMQP.BasicProperties();
  properties.setContentType(message.contentType);
  properties.setContentEncoding(message.contentEncoding);
  properties.setDeliveryMode(2);
  try {
    channel.basicPublish(message.exchange,message.routingKey,false,false,properties,message.content);
    return (true);
  }
 catch (  final Throwable exception) {
    this.callbacks.handleException(exception,""String_Node_Str"");
    return (false);
  }
}",0.9609035621198956
5928,"public void addProfessor(){
  DialogAddProf dialog=new DialogAddProf(adminMain,true);
  DefaultComboBoxModel model=new DefaultComboBoxModel();
  for (  Specialty s : adminMain.getSelectedFaculty().getSpecialties()) {
    for (    Course c : s.getCourses()) {
      model.addElement(c);
    }
  }
  dialog.setInputCurs(model);
  dialog.pack();
  dialog.setVisible(true);
  Professor prof=new Professor();
  prof.setTitle(dialog.getTitlu());
  prof.setFirstName(dialog.getPrenume());
  prof.setLastName(dialog.getNume());
  prof.setUserName(dialog.getUser());
  prof.setPassword(dialog.getParola());
  prof.addCourse(dialog.getCurs());
  administratorService.addProfesor(prof);
  administratorService.manageProfessors();
  loadProgesoriByFaculta_list(adminMain.getSelectedFaculty());
}","public void addProfessor(){
  DialogAddProf dialog=new DialogAddProf(adminMain,true);
  DefaultComboBoxModel model=new DefaultComboBoxModel();
  for (  Specialty s : adminMain.getSelectedFaculty().getSpecialties()) {
    for (    Course c : s.getCourses()) {
      model.addElement(c);
    }
  }
  dialog.setInputCurs(model);
  dialog.pack();
  dialog.setVisible(true);
  Professor prof=new Professor();
  prof.setTitle(dialog.getTitlu());
  prof.setFirstName(dialog.getPrenume());
  prof.setLastName(dialog.getNume());
  prof.setUserName(dialog.getUser());
  prof.setPassword(dialog.getParola());
  prof.addCourse(dialog.getCurs());
  dialog.getCurs().addProfessor(prof);
  administratorService.addProfesor(prof);
  adminMain.setListProfesori(loadProgesoriByFaculta_list(adminMain.getSelectedFaculty()));
}",0.9371069182389936
5929,"public List<DbObject> toDbObjectListContract(){
  return null;
}","public List<DbObject> toDbObjectListContract() throws SQLException {
  return null;
}",0.8590604026845637
5930,"public List<DbObject> toDbObjectListSS(){
  return null;
}","public List<DbObject> toDbObjectListSS() throws SQLException {
  return null;
}",0.8467153284671532
5931,"public void openAdminFrame(){
  adminMain=new FrameAdminMain(this);
  adminMain.setVisible(true);
  loadFaculties();
  loadAdministrators();
  adminMain.setLabelNumeAdmin(administrator);
  adminMain.setLabelUserAdmin(administrator);
}","public void openAdminFrame(){
  adminMain=new FrameAdminMain(this);
  loadFaculties();
  loadAdministrators();
  adminMain.setLabelNumeAdmin(administrator);
  adminMain.setLabelUserAdmin(administrator);
  adminMain.setVisible(true);
}",0.4230769230769231
5932,"/** 
 * constuctor privat pentru singleton
 */
private AppService(){
  adminRepo=AdministratorRepository.getInstance();
  profRepo=ProfessorRepository.getInstance();
  studRepo=StudentRepository.getInstance();
  facultyReposiitory=FacultyRepository.getInstance();
}","/** 
 * constuctor privat pentru singleton
 */
private AppService(){
  adminRepo=AdministratorRepository.getInstance();
  profRepo=ProfessorRepository.getInstance();
  studRepo=StudentRepository.getInstance();
  facultyReposiitory=FacultyRepository.getInstance();
  groupRepo=GroupRepository.getInstance();
}",0.924956369982548
5933,"private GroupRepository(){
  for (  Specialty s : specRepo.getAll()) {
    l.addAll(s.getGroups());
    for (    Professor p : pr.getAll())     for (    Group grp : p.getGroups())     for (    Group grr : s.getGroups())     if (grp.getGroupName().equals(grr.getGroupName())) {
      grp.setSpecialty(grr.getSpecialty());
    }
  }
}","private GroupRepository(){
  for (  Specialty s : specRepo.getAll()) {
    l.addAll(s.getGroups());
    for (    Professor p : pr.getAll())     for (    Group grp : p.getGroups()) {
      for (      Group grr : s.getGroups())       if (grp.getGroupName().equals(grr.getGroupName())) {
        grp.setSpecialty(grr.getSpecialty());
      }
      System.out.println(p);
    }
  }
}",0.9085794655414908
5934,"private void selectCategoryPanel(String catid){
  try {
    if (!m_categoriesset.contains(catid)) {
      JCatalogTab jcurrTab=new JCatalogTab();
      m_jProducts.add(jcurrTab,catid);
      m_categoriesset.add(catid);
      if (showDiscounts && catid.equals(AppLocal.getIntString(""String_Node_Str""))) {
        java.util.List<DiscountInfo> discounts=(m_dlSales.getDiscountList()).list();
        for (        DiscountInfo d : discounts) {
          jcurrTab.addButton(new ImageIcon(tnbbutton.getThumbNailText(null,d.getName())),new SelectedAction(d));
        }
      }
 else {
        java.util.List<CategoryInfo> categories=m_dlSales.getSubcategories(catid);
        for (        CategoryInfo cat : categories) {
          jcurrTab.addButton(new ImageIcon(tnbbutton.getThumbNailText(cat.getImage(),cat.getName())),new SelectedCategory(cat));
        }
        java.util.List<ProductInfoExt> products=m_dlSales.getProductCatalog(catid);
        for (        ProductInfoExt prod : products) {
          prod.setMatCat(m_dlSales.getProductMatCat(prod.getID()).get(0).getID());
          jcurrTab.addButton(new ImageIcon(tnbbutton.getThumbNailText(prod.getImage(),getProductLabel(prod))),new SelectedAction(prod));
        }
      }
    }
    CardLayout cl=(CardLayout)(m_jProducts.getLayout());
    cl.show(m_jProducts,catid);
  }
 catch (  BasicException e) {
    JMessageDialog.showMessage(this,new MessageInf(MessageInf.SGN_WARNING,AppLocal.getIntString(""String_Node_Str""),e));
  }
}","private void selectCategoryPanel(String catid){
  try {
    if (!m_categoriesset.contains(catid)) {
      JCatalogTab jcurrTab=new JCatalogTab();
      m_jProducts.add(jcurrTab,catid);
      m_categoriesset.add(catid);
      if (showDiscounts && catid.equals(AppLocal.getIntString(""String_Node_Str""))) {
        java.util.List<DiscountInfo> discounts=(m_dlSales.getDiscountList()).list();
        for (        DiscountInfo d : discounts) {
          jcurrTab.addButton(new ImageIcon(tnbbutton.getThumbNailText(null,d.getName())),new SelectedAction(d));
        }
      }
 else {
        java.util.List<CategoryInfo> categories=m_dlSales.getSubcategories(catid);
        for (        CategoryInfo cat : categories) {
          jcurrTab.addButton(new ImageIcon(tnbbutton.getThumbNailText(cat.getImage(),cat.getName())),new SelectedCategory(cat));
        }
        java.util.List<ProductInfoExt> products=m_dlSales.getProductCatalog(catid);
        for (        ProductInfoExt prod : products) {
          prod.setMatCat(m_dlSales.getProductMatCat(prod.getID()).get(0).getMatCatID());
          jcurrTab.addButton(new ImageIcon(tnbbutton.getThumbNailText(prod.getImage(),getProductLabel(prod))),new SelectedAction(prod));
        }
      }
    }
    CardLayout cl=(CardLayout)(m_jProducts.getLayout());
    cl.show(m_jProducts,catid);
  }
 catch (  BasicException e) {
    JMessageDialog.showMessage(this,new MessageInf(MessageInf.SGN_WARNING,AppLocal.getIntString(""String_Node_Str""),e));
  }
}",0.9979852249832102
5935,"public final List<ProdMatCatsInfo> getProductMatCat(String id) throws BasicException {
  return new PreparedSentence(s,""String_Node_Str"",SerializerWriteString.INSTANCE,new SerializerReadClass(ProdMatCatsInfo.class)).list(id);
}","public final List<ProdMatCatsInfo> getProductMatCat(String id) throws BasicException {
  return new PreparedSentence(s,""String_Node_Str"" + ""String_Node_Str"",SerializerWriteString.INSTANCE,new SerializerReadClass(ProdMatCatsInfo.class)).list(id);
}",0.9578059071729956
5936,"public void readValues(DataRead dr) throws BasicException {
  c_ID=dr.getString(0);
}","public void readValues(DataRead dr) throws BasicException {
  c_ID=dr.getString(1);
}",0.9882352941176472
5937,"protected void internalWrite(byte[] data){
  try {
    if (m_out == null) {
      m_PortIdPrinter=CommPortIdentifier.getPortIdentifier(m_sPortPrinter);
      m_CommPortPrinter=m_PortIdPrinter.open(""String_Node_Str"",2000);
      m_out=m_CommPortPrinter.getOutputStream();
      if (m_PortIdPrinter.getPortType() == CommPortIdentifier.PORT_SERIAL) {
        ((SerialPort)m_CommPortPrinter).setSerialPortParams(9600,SerialPort.DATABITS_8,SerialPort.STOPBITS_1,SerialPort.PARITY_NONE);
        ((SerialPort)m_CommPortPrinter).setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_IN);
      }
    }
    m_out.write(data);
  }
 catch (  NoSuchPortException e) {
    System.err.println(e);
  }
catch (  PortInUseException e) {
    System.err.println(e);
  }
catch (  UnsupportedCommOperationException e) {
    System.err.println(e);
  }
catch (  IOException e) {
    System.err.println(e);
  }
}","protected void internalWrite(byte[] data){
  try {
    if (m_out == null) {
      m_PortIdPrinter=CommPortIdentifier.getPortIdentifier(m_sPortPrinter);
      m_CommPortPrinter=m_PortIdPrinter.open(""String_Node_Str"",2000);
      m_out=m_CommPortPrinter.getOutputStream();
      if (m_PortIdPrinter.getPortType() == CommPortIdentifier.PORT_SERIAL) {
        ((SerialPort)m_CommPortPrinter).setSerialPortParams(9600,SerialPort.DATABITS_8,SerialPort.STOPBITS_1,SerialPort.PARITY_NONE);
      }
    }
    m_out.write(data);
  }
 catch (  NoSuchPortException e) {
    System.err.println(e);
  }
catch (  PortInUseException e) {
    System.err.println(e);
  }
catch (  UnsupportedCommOperationException e) {
    System.err.println(e);
  }
catch (  IOException e) {
    System.err.println(e);
  }
}",0.9438470728793308
5938,"public void readValues(DataRead dr) throws BasicException {
  m_sTicket=dr.getString(1);
  m_iLine=dr.getInt(2).intValue();
  productid=dr.getString(3);
  attsetinstid=dr.getString(4);
  multiply=dr.getDouble(5);
  price=dr.getDouble(6);
  tax=new TaxInfo(dr.getString(7),dr.getString(8),dr.getString(9),dr.getTimestamp(10),dr.getString(11),dr.getString(12),dr.getDouble(13),dr.getBoolean(14),dr.getInt(15));
  attributes=new Properties();
  try {
    byte[] img=dr.getBytes(15);
    if (img != null) {
      attributes.loadFromXML(new ByteArrayInputStream(img));
    }
  }
 catch (  IOException e) {
  }
}","public void readValues(DataRead dr) throws BasicException {
  m_sTicket=dr.getString(1);
  m_iLine=dr.getInt(2).intValue();
  productid=dr.getString(3);
  attsetinstid=dr.getString(4);
  multiply=dr.getDouble(5);
  price=dr.getDouble(6);
  tax=new TaxInfo(dr.getString(7),dr.getString(8),dr.getString(9),dr.getTimestamp(10),dr.getString(11),dr.getString(12),dr.getDouble(13),dr.getBoolean(14),dr.getInt(15));
  attributes=new Properties();
  try {
    byte[] img=dr.getBytes(16);
    if (img != null) {
      attributes.loadFromXML(new ByteArrayInputStream(img));
    }
  }
 catch (  IOException e) {
  }
}",0.9983498349834984
5939,"public void execute(PaymentInfoMagcard payinfo){
  StringBuffer sb=new StringBuffer();
  try {
    sb.append(""String_Node_Str"");
    sb.append(m_sCommerceID);
    sb.append(""String_Node_Str"");
    sb.append(m_sCommercePassword);
    sb.append(""String_Node_Str"");
    NumberFormat formatter=new DecimalFormat(""String_Node_Str"");
    String amount=formatter.format(Math.abs(payinfo.getTotal()));
    sb.append(URLEncoder.encode(amount.replace(',','.'),""String_Node_Str""));
    sb.append(""String_Node_Str"");
    sb.append(getCardType(payinfo.getCardNumber()));
    sb.append(""String_Node_Str"");
    sb.append(URLEncoder.encode(payinfo.getCardNumber(),""String_Node_Str""));
    sb.append(""String_Node_Str"");
    String tmp=payinfo.getExpirationDate();
    sb.append(tmp.substring(0,2));
    sb.append(""String_Node_Str"");
    sb.append(tmp.substring(2,tmp.length()));
    String[] cc_name=payinfo.getHolderName().split(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (cc_name.length > 0) {
      sb.append(URLEncoder.encode(cc_name[0],""String_Node_Str""));
    }
    sb.append(""String_Node_Str"");
    if (cc_name.length > 1) {
      sb.append(URLEncoder.encode(cc_name[1],""String_Node_Str""));
    }
    sb.append(""String_Node_Str"");
    sb.append(payinfo.getHolderName());
    if (payinfo.getTrack1(true) != null) {
      sb.append(""String_Node_Str"");
      sb.append(URLEncoder.encode(payinfo.getTrack1(true),""String_Node_Str""));
    }
    if (payinfo.getTotal() >= 0.0) {
      sb.append(""String_Node_Str"");
      sb.append(SALE);
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(REFUND);
    }
    sb.append(""String_Node_Str"");
    URL url=new URL(ENDPOINTADDRESS);
    URLConnection connection=url.openConnection();
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(sb.toString().getBytes());
    out.flush();
    out.close();
    BufferedReader in=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    String returned=""String_Node_Str"", aux;
    while ((aux=in.readLine()) != null) {
      returned+=""String_Node_Str"" + aux;
    }
    payinfo.setReturnMessage(returned);
    in.close();
    Map props=new HashMap();
    StringTokenizer tk=new java.util.StringTokenizer(returned,""String_Node_Str"");
    while (tk.hasMoreTokens()) {
      String sToken=tk.nextToken();
      int i=sToken.indexOf('=');
      if (i >= 0) {
        props.put(URLDecoder.decode(sToken.substring(0,i),""String_Node_Str""),URLDecoder.decode(sToken.substring(i + 1),""String_Node_Str""));
      }
 else {
        props.put(URLDecoder.decode(sToken,""String_Node_Str""),null);
      }
    }
    if (APPROVED.equals(props.get(""String_Node_Str""))) {
      payinfo.paymentOK((String)props.get(""String_Node_Str""),(String)props.get(""String_Node_Str""),returned);
    }
 else {
      String sCode=(String)props.get(""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),sCode);
    }
  }
 catch (  UnsupportedEncodingException eUE) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eUE.getMessage());
  }
catch (  MalformedURLException eMURL) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eMURL.getMessage());
  }
catch (  IOException e) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),e.getMessage());
  }
}","public void execute(PaymentInfoMagcard payinfo){
  StringBuffer sb=new StringBuffer();
  try {
    sb.append(""String_Node_Str"");
    sb.append(m_sCommerceID);
    sb.append(""String_Node_Str"");
    sb.append(m_sCommercePassword);
    sb.append(""String_Node_Str"");
    NumberFormat formatter=new DecimalFormat(""String_Node_Str"");
    String amount=formatter.format(Math.abs(payinfo.getTotal()));
    sb.append(URLEncoder.encode(amount.replace(',','.'),""String_Node_Str""));
    if (payinfo.getTrack1(true) != null) {
      sb.append(""String_Node_Str"");
      sb.append(URLEncoder.encode(payinfo.getTrack1(true),""String_Node_Str""));
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(getCardType(payinfo.getCardNumber()));
      sb.append(""String_Node_Str"");
      sb.append(URLEncoder.encode(payinfo.getCardNumber(),""String_Node_Str""));
      sb.append(""String_Node_Str"");
      String tmp=payinfo.getExpirationDate();
      sb.append(tmp.substring(0,2));
      sb.append(""String_Node_Str"");
      sb.append(tmp.substring(2,tmp.length()));
      String[] cc_name=payinfo.getHolderName().split(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      if (cc_name.length > 0) {
        sb.append(URLEncoder.encode(cc_name[0],""String_Node_Str""));
      }
      sb.append(""String_Node_Str"");
      if (cc_name.length > 1) {
        sb.append(URLEncoder.encode(cc_name[1],""String_Node_Str""));
      }
      sb.append(""String_Node_Str"");
      sb.append(payinfo.getHolderName());
    }
    if (payinfo.getTotal() >= 0.0) {
      sb.append(""String_Node_Str"");
      sb.append(SALE);
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(REFUND);
    }
    sb.append(""String_Node_Str"");
    URL url=new URL(ENDPOINTADDRESS);
    URLConnection connection=url.openConnection();
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(sb.toString().getBytes());
    out.flush();
    out.close();
    BufferedReader in=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    String returned=""String_Node_Str"", aux;
    while ((aux=in.readLine()) != null) {
      returned+=""String_Node_Str"" + aux;
    }
    payinfo.setReturnMessage(returned);
    in.close();
    Map props=new HashMap();
    StringTokenizer tk=new java.util.StringTokenizer(returned,""String_Node_Str"");
    while (tk.hasMoreTokens()) {
      String sToken=tk.nextToken();
      int i=sToken.indexOf('=');
      if (i >= 0) {
        props.put(URLDecoder.decode(sToken.substring(0,i),""String_Node_Str""),URLDecoder.decode(sToken.substring(i + 1),""String_Node_Str""));
      }
 else {
        props.put(URLDecoder.decode(sToken,""String_Node_Str""),null);
      }
    }
    if (APPROVED.equals(props.get(""String_Node_Str""))) {
      payinfo.paymentOK((String)props.get(""String_Node_Str""),(String)props.get(""String_Node_Str""),returned);
    }
 else {
      String sCode=(String)props.get(""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),sCode);
    }
  }
 catch (  UnsupportedEncodingException eUE) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eUE.getMessage());
  }
catch (  MalformedURLException eMURL) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eMURL.getMessage());
  }
catch (  IOException e) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),e.getMessage());
  }
}",0.8474752732951588
5940,"public void beginReceipt(){
  m_ticketcurrent=new BasicTicket();
}","public void beginReceipt(){
  m_ticketcurrent=new BasicTicketForScreen();
}",0.9361702127659576
5941,"public void printImage(BufferedImage image){
  PrintItem pi=new PrintItemImage(image,IMAGE_SCALE);
  m_aCommands.add(pi);
  m_iBodyHeight+=pi.getHeight();
}","public void printImage(BufferedImage image){
  PrintItem pi=new PrintItemImage(image,getImageScale());
  m_aCommands.add(pi);
  m_iBodyHeight+=pi.getHeight();
}",0.930379746835443
5942,"public void printBarCode(String type,String position,String code){
  PrintItem pi=new PrintItemBarcode(type,position,code,IMAGE_SCALE);
  m_aCommands.add(pi);
  m_iBodyHeight+=pi.getHeight();
}","public void printBarCode(String type,String position,String code){
  PrintItem pi=new PrintItemBarcode(type,position,code,getImageScale());
  m_aCommands.add(pi);
  m_iBodyHeight+=pi.getHeight();
}",0.9435897435897436
5943,"public void beginLine(int iTextSize){
  pil=new PrintItemLine(iTextSize,BASEFONT,FONTHEIGHT);
}","public void beginLine(int iTextSize){
  pil=new PrintItemLine(iTextSize,getBaseFont(),getFontHeight());
}",0.81
5944,"public String printHost(){
  return m_sHost;
}","public String printHost(){
  return StringUtils.encodeXML(m_sHost);
}",0.8
5945,"void btnPrintActionPerformed(java.awt.event.ActionEvent evt){
  Thread thread=new Thread(new Runnable(){
    public void run(){
      try {
        btnPrint.setEnabled(false);
        JRViewer300.this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        JasperPrintManager.printReport(jasperPrint,true);
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        JOptionPane.showMessageDialog(JRViewer300.this,getBundleString(""String_Node_Str""));
      }
 finally {
        JRViewer300.this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        btnPrint.setEnabled(true);
      }
    }
  }
);
  thread.start();
}","void btnPrintActionPerformed(java.awt.event.ActionEvent evt){
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      try {
        btnPrint.setEnabled(false);
        JRViewer300.this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        JasperPrintManager.printReport(jasperPrint,true);
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        JOptionPane.showMessageDialog(JRViewer300.this,getBundleString(""String_Node_Str""));
      }
 finally {
        JRViewer300.this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        btnPrint.setEnabled(true);
      }
    }
  }
);
}",0.9493087557603688
5946,"public static boolean checkCC(String cardNumber){
  int sum=0;
  if (!StringUtils.isNumber(cardNumber)) {
    return false;
  }
  for (int i=0; i < cardNumber.length(); i++) {
    int k=Integer.parseInt(cardNumber.substring(i,i + 1));
    if (i % 2 == 0) {
      k*=2;
      if (k > 9) {
        k-=9;
      }
    }
    sum+=k;
  }
  return (sum % 10 == 0);
}","public static boolean checkCC(String cardNumber){
  int sum=0;
  int flip=0;
  if (!StringUtils.isNumber(cardNumber)) {
    return false;
  }
  for (int i=cardNumber.length() - 1; i >= 0; i--) {
    int k=Character.digit(cardNumber.charAt(i),10);
    flip++;
    if (flip % 2 == 0) {
      k*=2;
      if (k > 9) {
        k-=9;
      }
    }
    sum+=k;
  }
  return (sum % 10 == 0);
}",0.4456375838926174
5947,"public String printReason(){
  return m_reason.toString();
}","public String printReason(){
  return StringUtils.encodeXML(m_reason.toString());
}",0.8391608391608392
5948,"public String printLocation(){
  return m_locationOri.toString();
}","public String printLocation(){
  return StringUtils.encodeXML(m_locationOri.toString());
}",0.8535031847133758
5949,"/** 
 * This is the action called from the Struts framework.
 * @param mapping The ActionMapping used to select this instance.
 * @param form The optional ActionForm bean for this request.
 * @param request The HTTP Request we are processing.
 * @param response The HTTP Response we are processing.
 * @throws java.lang.Exception
 * @return
 */
public ActionForward execute(ActionMapping mapping,ActionForm form,HttpServletRequest request,HttpServletResponse response) throws Exception {
  FloorForm floorForm=(FloorForm)form;
  RestaurantManager manager=new RestaurantManager();
  String floorId=(String)floorForm.getFloorId();
  String place=(String)floorForm.getId();
  String str=(String)floorForm.getMode();
  String[] array=null;
  int mode=0;
  if (!str.equals(""String_Node_Str"")) {
    mode=Integer.valueOf(str);
  }
  List<TicketLineInfo> linesList=new ArrayList<TicketLineInfo>();
  List products=new ArrayList<ProductInfoExt>();
  TicketInfo ticket;
switch (mode) {
case 1:
    ticket=manager.findTicket(place);
  linesList=ticket.getM_aLines();
array=floorForm.getParameters();
if (array != null) {
for (int i=0; i < array.length; i++) {
  if (linesList.get(Integer.valueOf(array[i]) - 0).getMultiply() > 0) {
    linesList.get(Integer.valueOf(array[i]) - 0).setMultiply(linesList.get(Integer.valueOf(array[i]) - 0).getMultiply() - 1);
  }
}
}
manager.updateLineFromTicket(place,ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
request.setAttribute(""String_Node_Str"",products.get(0));
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",linesList.get(Integer.valueOf(array[0])));
request.setAttribute(""String_Node_Str"",array[0]);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(UPDATE);
case 4:
ticket=manager.findTicket(place);
linesList=ticket.getM_aLines();
array=floorForm.getParameters();
if (array != null) {
linesList.remove(Integer.parseInt(array[0]));
}
manager.updateLineFromTicket(place,ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
request.setAttribute(""String_Node_Str"",manager.findFloorById(manager.findPlaceById(place).getFloor()).getName());
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",floorId);
request.setAttribute(""String_Node_Str"",linesList);
request.setAttribute(""String_Node_Str"",products);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(SUCCESS);
case 2:
ticket=manager.findTicket(place);
linesList=ticket.getM_aLines();
String[] index=floorForm.getParameters();
linesList.get(Integer.valueOf(index[0])).setMultiply(Double.valueOf(index[1]));
manager.updateLineFromTicket(floorForm.getId(),ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
break;
case 3:
ticket=manager.findTicket(place);
linesList=ticket.getM_aLines();
array=floorForm.getParameters();
if (array != null) {
for (int i=0; i < array.length; i++) {
linesList.get(Integer.valueOf(array[i]) - 0).setMultiply(linesList.get(Integer.valueOf(array[i]) - 0).getMultiply() + 1);
}
}
manager.updateLineFromTicket(place,ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
request.setAttribute(""String_Node_Str"",products.get(0));
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",linesList.get(Integer.valueOf(array[0])));
request.setAttribute(""String_Node_Str"",array[0]);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(UPDATE);
default :
if (manager.findTicket(place) == null) {
manager.initTicket(place);
}
 else {
linesList=manager.findTicketLines(place);
}
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
break;
}
request.setAttribute(""String_Node_Str"",manager.findFloorById(manager.findPlaceById(place).getFloor()).getName());
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",floorId);
request.setAttribute(""String_Node_Str"",linesList);
request.setAttribute(""String_Node_Str"",products);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(SUCCESS);
}","/** 
 * This is the action called from the Struts framework.
 * @param mapping The ActionMapping used to select this instance.
 * @param form The optional ActionForm bean for this request.
 * @param request The HTTP Request we are processing.
 * @param response The HTTP Response we are processing.
 * @throws java.lang.Exception
 * @return
 */
public ActionForward execute(ActionMapping mapping,ActionForm form,HttpServletRequest request,HttpServletResponse response) throws Exception {
  FloorForm floorForm=(FloorForm)form;
  RestaurantManager manager=new RestaurantManager();
  String floorId=(String)floorForm.getFloorId();
  String place=(String)floorForm.getId();
  String str=(String)floorForm.getMode();
  String[] array=null;
  int mode=0;
  if (!str.equals(""String_Node_Str"")) {
    mode=Integer.valueOf(str);
  }
  List<TicketLineInfo> linesList=new ArrayList<TicketLineInfo>();
  List products=new ArrayList<ProductInfoExt>();
  TicketInfo ticket;
switch (mode) {
case 1:
    ticket=manager.findTicket(place);
  linesList=ticket.getM_aLines();
array=floorForm.getParameters();
if (array != null) {
for (int i=0; i < array.length; i++) {
  if (linesList.get(Integer.valueOf(array[i])).getMultiply() > 0) {
    linesList.get(Integer.valueOf(array[i])).setMultiply(linesList.get(Integer.valueOf(array[i])).getMultiply() - 1);
  }
}
}
manager.updateLineFromTicket(place,ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
request.setAttribute(""String_Node_Str"",products.get(0));
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",linesList.get(Integer.valueOf(array[0])));
request.setAttribute(""String_Node_Str"",array[0]);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(UPDATE);
case 4:
ticket=manager.findTicket(place);
linesList=ticket.getM_aLines();
array=floorForm.getParameters();
if (array != null) {
linesList.remove(Integer.parseInt(array[0]));
}
manager.updateLineFromTicket(place,ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
request.setAttribute(""String_Node_Str"",manager.findFloorById(manager.findPlaceById(place).getFloor()).getName());
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",floorId);
request.setAttribute(""String_Node_Str"",linesList);
request.setAttribute(""String_Node_Str"",products);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(SUCCESS);
case 2:
ticket=manager.findTicket(place);
linesList=ticket.getM_aLines();
String[] index=floorForm.getParameters();
linesList.get(Integer.valueOf(index[0])).setMultiply(Double.valueOf(index[1]));
manager.updateLineFromTicket(floorForm.getId(),ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
break;
case 3:
ticket=manager.findTicket(place);
linesList=ticket.getM_aLines();
array=floorForm.getParameters();
if (array != null) {
for (int i=0; i < array.length; i++) {
linesList.get(Integer.valueOf(array[i])).setMultiply(linesList.get(Integer.valueOf(array[i])).getMultiply() + 1);
}
}
manager.updateLineFromTicket(place,ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
request.setAttribute(""String_Node_Str"",products.get(0));
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",linesList.get(Integer.valueOf(array[0])));
request.setAttribute(""String_Node_Str"",array[0]);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(UPDATE);
default :
if (manager.findTicket(place) == null) {
manager.initTicket(place);
}
 else {
linesList=manager.findTicketLines(place);
}
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
break;
}
request.setAttribute(""String_Node_Str"",manager.findFloorById(manager.findPlaceById(place).getFloor()).getName());
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",floorId);
request.setAttribute(""String_Node_Str"",linesList);
request.setAttribute(""String_Node_Str"",products);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(SUCCESS);
}",0.9979338842975206
5950,"/** 
 * This is the action called from the Struts framework.
 * @param mapping The ActionMapping used to select this instance.
 * @param form The optional ActionForm bean for this request.
 * @param request The HTTP Request we are processing.
 * @param response The HTTP Response we are processing.
 * @throws java.lang.Exception
 * @return
 */
public ActionForward execute(ActionMapping mapping,ActionForm form,HttpServletRequest request,HttpServletResponse response) throws Exception {
  DynaActionForm inputFormPlace=(DynaActionForm)form;
  RestaurantManager manager=new RestaurantManager();
  List<CategoryInfo> categories=new ArrayList<CategoryInfo>();
  categories=manager.findAllCategories();
  List products=new ArrayList<ProductInfoExt>();
  products=manager.findProductsByCategory(categories.get(0).getId());
  List subcategories=new ArrayList<CategoryInfo>();
  subcategories=manager.findAllSubcategories(categories.get(0).getId());
  request.setAttribute(""String_Node_Str"",products);
  request.getSession().setAttribute(""String_Node_Str"",(String)inputFormPlace.get(""String_Node_Str""));
  request.setAttribute(""String_Node_Str"",manager.findPlaceNameById((String)inputFormPlace.get(""String_Node_Str"")));
  request.setAttribute(""String_Node_Str"",categories);
  request.setAttribute(""String_Node_Str"",request.getAttribute(""String_Node_Str""));
  request.setAttribute(""String_Node_Str"",subcategories);
  return mapping.findForward(SUCCESS);
}","/** 
 * This is the action called from the Struts framework.
 * @param mapping The ActionMapping used to select this instance.
 * @param form The optional ActionForm bean for this request.
 * @param request The HTTP Request we are processing.
 * @param response The HTTP Response we are processing.
 * @throws java.lang.Exception
 * @return
 */
public ActionForward execute(ActionMapping mapping,ActionForm form,HttpServletRequest request,HttpServletResponse response) throws Exception {
  DynaActionForm inputFormPlace=(DynaActionForm)form;
  RestaurantManager manager=new RestaurantManager();
  List<CategoryInfo> categories=new ArrayList<CategoryInfo>();
  categories=manager.findAllCategories();
  List products=new ArrayList<ProductInfoExt>();
  products=manager.findProductsByCategory(categories.get(0).getId());
  List subcategories=new ArrayList<CategoryInfo>();
  subcategories=manager.findAllSubcategories(categories.get(0).getId());
  request.setAttribute(""String_Node_Str"",products);
  request.getSession().setAttribute(""String_Node_Str"",(String)inputFormPlace.get(""String_Node_Str""));
  request.setAttribute(""String_Node_Str"",manager.findPlaceNameById((String)inputFormPlace.get(""String_Node_Str"")));
  request.setAttribute(""String_Node_Str"",categories);
  request.getSession().setAttribute(""String_Node_Str"",(String)inputFormPlace.get(""String_Node_Str""));
  return mapping.findForward(SUCCESS);
}",0.959412176347096
5951,"private String getCardType(String sCardNumber){
  String c=""String_Node_Str"";
  if (sCardNumber.startsWith(""String_Node_Str"")) {
    c=""String_Node_Str"";
  }
 else   if (sCardNumber.startsWith(""String_Node_Str"")) {
    c=""String_Node_Str"";
  }
 else   if (sCardNumber.startsWith(""String_Node_Str"")) {
    c=""String_Node_Str"";
  }
 else   if (sCardNumber.startsWith(""String_Node_Str"")) {
    c=""String_Node_Str"";
  }
 else   if (sCardNumber.startsWith(""String_Node_Str"") || sCardNumber.startsWith(""String_Node_Str"")) {
    c=""String_Node_Str"";
  }
 else   if (sCardNumber.startsWith(""String_Node_Str"") || sCardNumber.startsWith(""String_Node_Str"")) {
    c=""String_Node_Str"";
  }
  return c;
}","private String getCardType(String sCardNumber){
  String c=""String_Node_Str"";
  if (sCardNumber.startsWith(""String_Node_Str"")) {
    c=""String_Node_Str"";
  }
 else   if (sCardNumber.startsWith(""String_Node_Str"")) {
    c=""String_Node_Str"";
  }
 else   if (sCardNumber.startsWith(""String_Node_Str"")) {
    c=""String_Node_Str"";
  }
 else   if (sCardNumber.startsWith(""String_Node_Str"") || sCardNumber.startsWith(""String_Node_Str"")) {
    c=""String_Node_Str"";
  }
 else   if (sCardNumber.startsWith(""String_Node_Str"") || sCardNumber.startsWith(""String_Node_Str"")) {
    c=""String_Node_Str"";
  }
 else   if (sCardNumber.startsWith(""String_Node_Str"")) {
    c=""String_Node_Str"";
  }
  return c;
}",0.8596237337192475
5952,"/** 
 * This is the action called from the Struts framework.
 * @param mapping The ActionMapping used to select this instance.
 * @param form The optional ActionForm bean for this request.
 * @param request The HTTP Request we are processing.
 * @param response The HTTP Response we are processing.
 * @throws java.lang.Exception
 * @return
 */
public ActionForward execute(ActionMapping mapping,ActionForm form,HttpServletRequest request,HttpServletResponse response) throws Exception {
  FloorForm floorForm=(FloorForm)form;
  RestaurantManager manager=new RestaurantManager();
  String floorId=(String)floorForm.getFloorId();
  String place=(String)floorForm.getId();
  String str=(String)floorForm.getMode();
  String[] array=null;
  int mode=0;
  if (!str.equals(""String_Node_Str"")) {
    mode=Integer.valueOf(str);
  }
  List<TicketLineInfo> linesList=new ArrayList<TicketLineInfo>();
  List products=new ArrayList<ProductInfoExt>();
  TicketInfo ticket;
switch (mode) {
case 1:
    ticket=manager.findTicket(place);
  linesList=ticket.getM_aLines();
array=floorForm.getParameters();
if (array != null) {
for (int i=0; i < array.length; i++) {
  if (linesList.get(Integer.valueOf(array[i])).getMultiply() > 0) {
    linesList.get(Integer.valueOf(array[i])).setMultiply(linesList.get(Integer.valueOf(array[i])).getMultiply() - 1);
  }
}
}
manager.updateLineFromTicket(place,ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
request.setAttribute(""String_Node_Str"",products.get(0));
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",linesList.get(Integer.valueOf(array[0])));
request.setAttribute(""String_Node_Str"",array[0]);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(UPDATE);
case 4:
ticket=manager.findTicket(place);
linesList=ticket.getM_aLines();
array=floorForm.getParameters();
if (array != null) {
linesList.remove(Integer.parseInt(array[0]));
}
manager.updateLineFromTicket(place,ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
request.setAttribute(""String_Node_Str"",manager.findFloorById(manager.findPlaceById(place).getFloor()).getName());
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",floorId);
request.setAttribute(""String_Node_Str"",linesList);
request.setAttribute(""String_Node_Str"",products);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(SUCCESS);
case 2:
ticket=manager.findTicket(place);
linesList=ticket.getM_aLines();
String[] index=floorForm.getParameters();
linesList.get(Integer.valueOf(index[0])).setMultiply(Double.valueOf(index[1]));
manager.updateLineFromTicket(floorForm.getId(),ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
break;
case 3:
ticket=manager.findTicket(place);
linesList=ticket.getM_aLines();
array=floorForm.getParameters();
if (array != null) {
for (int i=0; i < array.length; i++) {
linesList.get(Integer.valueOf(array[i])).setMultiply(linesList.get(Integer.valueOf(array[i])).getMultiply() + 1);
}
}
manager.updateLineFromTicket(place,ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
request.setAttribute(""String_Node_Str"",products.get(0));
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",linesList.get(Integer.valueOf(array[0])));
request.setAttribute(""String_Node_Str"",array[0]);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(UPDATE);
default :
if (manager.findTicket(place) == null) {
manager.initTicket(place);
}
 else {
linesList=manager.findTicketLines(place);
}
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
break;
}
request.setAttribute(""String_Node_Str"",manager.findFloorById(manager.findPlaceById(place).getFloor()).getName());
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",floorId);
request.setAttribute(""String_Node_Str"",linesList);
request.setAttribute(""String_Node_Str"",products);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(SUCCESS);
}","/** 
 * This is the action called from the Struts framework.
 * @param mapping The ActionMapping used to select this instance.
 * @param form The optional ActionForm bean for this request.
 * @param request The HTTP Request we are processing.
 * @param response The HTTP Response we are processing.
 * @throws java.lang.Exception
 * @return
 */
public ActionForward execute(ActionMapping mapping,ActionForm form,HttpServletRequest request,HttpServletResponse response) throws Exception {
  FloorForm floorForm=(FloorForm)form;
  RestaurantManager manager=new RestaurantManager();
  String floorId=(String)floorForm.getFloorId();
  String place=(String)floorForm.getId();
  String str=(String)floorForm.getMode();
  String[] array=null;
  int mode=0;
  if (!str.equals(""String_Node_Str"")) {
    mode=Integer.valueOf(str);
  }
  List<TicketLineInfo> linesList=new ArrayList<TicketLineInfo>();
  List products=new ArrayList<ProductInfoExt>();
  TicketInfo ticket;
switch (mode) {
case 1:
    ticket=manager.findTicket(place);
  linesList=ticket.getM_aLines();
array=floorForm.getParameters();
if (array != null) {
for (int i=0; i < array.length; i++) {
  if (linesList.get(Integer.valueOf(array[i])).getMultiply() > 1) {
    linesList.get(Integer.valueOf(array[i])).setMultiply(linesList.get(Integer.valueOf(array[i])).getMultiply() - 1);
  }
}
}
manager.updateLineFromTicket(place,ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
request.setAttribute(""String_Node_Str"",products.get(0));
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",linesList.get(Integer.valueOf(array[0])));
request.setAttribute(""String_Node_Str"",array[0]);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(UPDATE);
case 4:
ticket=manager.findTicket(place);
linesList=ticket.getM_aLines();
array=floorForm.getParameters();
int var=Integer.parseInt(array[0]);
linesList.remove(var);
if (linesList.size() > var && manager.findProductById(linesList.get(var).getProductid()).isCom()) {
linesList.remove(var);
while (linesList.size() > var && manager.findProductById(linesList.get(var).getProductid()).isCom()) {
linesList.remove(var);
if (linesList.size() == var) {
break;
}
}
}
manager.updateLineFromTicket(place,ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
request.setAttribute(""String_Node_Str"",manager.findFloorById(manager.findPlaceById(place).getFloor()).getName());
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",floorId);
request.setAttribute(""String_Node_Str"",linesList);
request.setAttribute(""String_Node_Str"",products);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(SUCCESS);
case 2:
ticket=manager.findTicket(place);
linesList=ticket.getM_aLines();
String[] index=floorForm.getParameters();
linesList.get(Integer.valueOf(index[0])).setMultiply(Double.valueOf(index[1]));
manager.updateLineFromTicket(floorForm.getId(),ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
break;
case 3:
ticket=manager.findTicket(place);
linesList=ticket.getM_aLines();
array=floorForm.getParameters();
if (array != null) {
for (int i=0; i < array.length; i++) {
linesList.get(Integer.valueOf(array[i])).setMultiply(linesList.get(Integer.valueOf(array[i])).getMultiply() + 1);
}
}
manager.updateLineFromTicket(place,ticket);
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
request.setAttribute(""String_Node_Str"",products.get(0));
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",linesList.get(Integer.valueOf(array[0])));
request.setAttribute(""String_Node_Str"",array[0]);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(UPDATE);
default :
if (manager.findTicket(place) == null) {
manager.initTicket(place);
}
 else {
linesList=manager.findTicketLines(place);
}
for (Object line : linesList) {
TicketLineInfo li=(TicketLineInfo)line;
products.add(manager.findProductById(li.getProductid()));
}
break;
}
request.setAttribute(""String_Node_Str"",manager.findFloorById(manager.findPlaceById(place).getFloor()).getName());
request.setAttribute(""String_Node_Str"",place);
request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
request.setAttribute(""String_Node_Str"",floorId);
request.setAttribute(""String_Node_Str"",linesList);
request.setAttribute(""String_Node_Str"",products);
request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
return mapping.findForward(SUCCESS);
}",0.9636930503872072
5953,"protected Connection getConnection() throws Exception {
  try {
    Class.forName(properties.getDriverName());
    return DriverManager.getConnection(properties.getUrl(),properties.getDBUser(),properties.getDBPassword());
  }
 catch (  SQLException sqlex) {
    sqlex.printStackTrace();
  }
catch (  Exception ex) {
    ex.printStackTrace();
  }
  return null;
}","protected Connection getConnection() throws Exception {
  try {
    Class.forName(properties.getDriverName());
    boolean ju=isPostgre();
    return DriverManager.getConnection(properties.getUrl(),properties.getDBUser(),properties.getDBPassword());
  }
 catch (  SQLException sqlex) {
    sqlex.printStackTrace();
  }
catch (  Exception ex) {
    ex.printStackTrace();
  }
  return null;
}",0.9627659574468084
5954,"public List<ProductInfo> findProductsByCategory(String categoryId){
  Connection con=null;
  PreparedStatement ps=null;
  ResultSet rs=null;
  List<ProductInfo> vos=null;
  String sqlStr=""String_Node_Str"" + ""String_Node_Str"";
  try {
    con=getConnection();
    ps=con.prepareStatement(sqlStr);
    ps.setString(1,categoryId);
    rs=ps.executeQuery();
    vos=transformSet(rs);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
 finally {
    try {
      if (ps != null) {
        ps.close();
      }
      if (con != null) {
        con.close();
      }
    }
 catch (    SQLException sqlee) {
      sqlee.printStackTrace();
    }
  }
  return vos;
}","public List<ProductInfo> findProductsByCategory(String categoryId){
  Connection con=null;
  PreparedStatement ps=null;
  ResultSet rs=null;
  List<ProductInfo> vos=null;
  String sqlStr=isPostgre() ? ""String_Node_Str"" + ""String_Node_Str"" : ""String_Node_Str"" + ""String_Node_Str"";
  try {
    con=getConnection();
    ps=con.prepareStatement(sqlStr);
    ps.setString(1,categoryId);
    rs=ps.executeQuery();
    vos=transformSet(rs);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
 finally {
    try {
      if (ps != null) {
        ps.close();
      }
      if (con != null) {
        con.close();
      }
    }
 catch (    SQLException sqlee) {
      sqlee.printStackTrace();
    }
  }
  return vos;
}",0.9608695652173912
5955,"public String printName(){
  return m_sProdName;
}","public String printName(){
  return StringUtils.encodeXML(m_sProdName);
}",0.8130081300813008
5956,"public List<Place> findAllBusyTable(String floor){
  place=new PlaceDAO();
  return place.findAllBusyPlaceByFloor(floor);
}","public List<Place> findAllBusyTable(String floor){
  place=new PlaceDAO();
  return place.findAllBusyPlacesByFloor(floor);
}",0.9959514170040484
5957,"public String printCardNumber(){
  if (m_sCardNumber.length() > 4) {
    return ""String_Node_Str"" + m_sCardNumber.substring(m_sCardNumber.length() - 4);
  }
 else {
    return ""String_Node_Str"";
  }
}","public String printCardNumber(){
  if (m_sCardNumber.length() > 4) {
    return m_sCardNumber.substring(0,m_sCardNumber.length() - 4).replaceAll(""String_Node_Str"",""String_Node_Str"") + m_sCardNumber.substring(m_sCardNumber.length() - 4);
  }
 else {
    return ""String_Node_Str"";
  }
}",0.8264462809917356
5958,"public void addLineToTicket(String ticketId,String productId){
  ticket=new TicketDAO();
  product=new ProductDAO();
  category=new CategoryDAO();
  tax=new TaxDAO();
  taxesLogic=new TaxesLogic(tax.getTaxList());
  TicketInfo obj=ticket.getTicket(ticketId);
  ProductInfo productObj=null;
  productObj=product.findProductById(productId);
  TicketLineInfo line=new TicketLineInfo(productObj,productObj.getPriceSell(),taxesLogic.getTaxInfo(productObj.getCategoryId()));
  obj.addLine(line);
  ticket.updateTicket(ticketId,obj);
  refreshTax(obj);
}","public void addLineToTicket(String ticketId,String productId){
  ticket=new TicketDAO();
  product=new ProductDAO();
  category=new CategoryDAO();
  tax=new TaxDAO();
  taxesLogic=new TaxesLogic(tax.getTaxList());
  TicketInfo obj=ticket.getTicket(ticketId);
  ProductInfo productObj=product.findProductById(productId);
  TicketLineInfo line=new TicketLineInfo(productObj,productObj.getPriceSell(),taxesLogic.getTaxInfo(productObj.getCategoryId()));
  obj.addLine(line);
  ticket.updateTicket(ticketId,obj);
  refreshTax(obj);
}",0.7795348837209303
5959,"public UserInfo findUser(String login,String password){
  Connection con=null;
  PreparedStatement ps=null;
  ResultSet rs=null;
  UserInfo user=null;
  String sqlStr=""String_Node_Str"";
  try {
    con=getConnection();
    ps=con.prepareStatement(sqlStr);
    ps.setString(1,login);
    if (password.equals(""String_Node_Str"")) {
      ps.setString(2,null);
    }
 else {
      ps.setString(2,StringUtils.hashString(password));
    }
    rs=ps.executeQuery();
    user=map2VO(rs);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
 finally {
    try {
      if (ps != null) {
        ps.close();
      }
      if (con != null) {
        con.close();
      }
    }
 catch (    SQLException sqlee) {
      sqlee.printStackTrace();
    }
  }
  return user;
}","public UserInfo findUser(String login,String password){
  Connection con=null;
  PreparedStatement ps=null;
  ResultSet rs=null;
  UserInfo user=null;
  String sqlStr=""String_Node_Str"";
  String end=""String_Node_Str"";
  if (password.equals(""String_Node_Str"")) {
    end=""String_Node_Str"";
  }
 else {
    end=""String_Node_Str"";
  }
  try {
    con=getConnection();
    ps=con.prepareStatement(sqlStr + end);
    ps.setString(1,login);
    if (!password.equals(""String_Node_Str"")) {
      ps.setString(2,StringUtils.hashString(password));
    }
    rs=ps.executeQuery();
    user=map2VO(rs);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
 finally {
    try {
      if (ps != null) {
        ps.close();
      }
      if (con != null) {
        con.close();
      }
    }
 catch (    SQLException sqlee) {
      sqlee.printStackTrace();
    }
  }
  return user;
}",0.8810250152532032
5960,"@Override protected UserInfo map2VO(ResultSet rs) throws SQLException {
  UserInfo user=new UserInfo();
  rs.next();
  user.setLogin(rs.getString(""String_Node_Str""));
  user.setPassword(rs.getString(""String_Node_Str""));
  return user;
}","@Override protected UserInfo map2VO(ResultSet rs) throws SQLException {
  UserInfo user=new UserInfo();
  rs.next();
  user.setLogin(rs.getString(""String_Node_Str""));
  if (rs.getString(""String_Node_Str"") == null) {
    user.setPassword(""String_Node_Str"");
  }
 else {
    user.setPassword(rs.getString(""String_Node_Str""));
  }
  return user;
}",0.7068965517241379
5961,"public UserInfo findUser(String login,String password){
  Connection con=null;
  PreparedStatement ps=null;
  ResultSet rs=null;
  UserInfo user=null;
  String sqlStr=""String_Node_Str"";
  try {
    con=getConnection();
    ps=con.prepareStatement(sqlStr);
    ps.setString(1,login);
    ps.setString(2,StringUtils.hashString(password));
    rs=ps.executeQuery();
    user=map2VO(rs);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
 finally {
    try {
      if (ps != null) {
        ps.close();
      }
      if (con != null) {
        con.close();
      }
    }
 catch (    SQLException sqlee) {
      sqlee.printStackTrace();
    }
  }
  return user;
}","public UserInfo findUser(String login,String password){
  Connection con=null;
  PreparedStatement ps=null;
  ResultSet rs=null;
  UserInfo user=null;
  String sqlStr=""String_Node_Str"";
  try {
    con=getConnection();
    ps=con.prepareStatement(sqlStr);
    ps.setString(1,login);
    if (password.equals(""String_Node_Str"")) {
      ps.setString(2,null);
    }
 else {
      ps.setString(2,StringUtils.hashString(password));
    }
    rs=ps.executeQuery();
    user=map2VO(rs);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
 finally {
    try {
      if (ps != null) {
        ps.close();
      }
      if (con != null) {
        con.close();
      }
    }
 catch (    SQLException sqlee) {
      sqlee.printStackTrace();
    }
  }
  return user;
}",0.9329608938547486
5962,"/** 
 * This is the action called from the Struts framework.
 * @param mapping The ActionMapping used to select this instance.
 * @param form The optional ActionForm bean for this request.
 * @param request The HTTP Request we are processing.
 * @param response The HTTP Response we are processing.
 * @throws java.lang.Exception
 * @return
 */
public ActionForward execute(ActionMapping mapping,ActionForm form,HttpServletRequest request,HttpServletResponse response) throws Exception {
  DynaActionForm inputFormPlace=(DynaActionForm)form;
  RestaurantManager manager=new RestaurantManager();
  List<CategoryInfo> categories=new ArrayList<CategoryInfo>();
  categories=manager.findAllCategories();
  List products=new ArrayList<ProductInfoExt>();
  products=manager.findProductsByCategory(categories.get(0).getId());
  List subcategories=new ArrayList<CategoryInfo>();
  subcategories=manager.findAllSubcategories(categories.get(0).getId());
  request.setAttribute(""String_Node_Str"",products);
  request.getSession().setAttribute(""String_Node_Str"",(String)inputFormPlace.get(""String_Node_Str""));
  request.setAttribute(""String_Node_Str"",manager.findPlaceNameById((String)inputFormPlace.get(""String_Node_Str"")));
  request.setAttribute(""String_Node_Str"",categories);
  request.getSession().setAttribute(""String_Node_Str"",(String)inputFormPlace.get(""String_Node_Str""));
  return mapping.findForward(SUCCESS);
}","/** 
 * This is the action called from the Struts framework.
 * @param mapping The ActionMapping used to select this instance.
 * @param form The optional ActionForm bean for this request.
 * @param request The HTTP Request we are processing.
 * @param response The HTTP Response we are processing.
 * @throws java.lang.Exception
 * @return
 */
public ActionForward execute(ActionMapping mapping,ActionForm form,HttpServletRequest request,HttpServletResponse response) throws Exception {
  DynaActionForm inputFormPlace=(DynaActionForm)form;
  RestaurantManager manager=new RestaurantManager();
  List<CategoryInfo> categories=new ArrayList<CategoryInfo>();
  categories=manager.findAllCategories();
  List products=new ArrayList<ProductInfoExt>();
  products=manager.findProductsByCategory(categories.get(0).getId());
  List subcategories=new ArrayList<CategoryInfo>();
  subcategories=manager.findAllSubcategories(categories.get(0).getId());
  request.setAttribute(""String_Node_Str"",products);
  request.getSession().setAttribute(""String_Node_Str"",(String)inputFormPlace.get(""String_Node_Str""));
  request.setAttribute(""String_Node_Str"",manager.findPlaceNameById((String)inputFormPlace.get(""String_Node_Str"")));
  request.setAttribute(""String_Node_Str"",categories);
  request.setAttribute(""String_Node_Str"",subcategories);
  request.getSession().setAttribute(""String_Node_Str"",(String)inputFormPlace.get(""String_Node_Str""));
  return mapping.findForward(SUCCESS);
}",0.9801876955161628
5963,"public BigDecimal getTotalOfaTicket(String place){
  double total=0;
  for (  TicketLineInfo line : findTicket(place).getM_aLines()) {
    try {
      total+=line.getMultiply() * (line.getPrice() + line.getPrice() * line.getTax().getRate());
    }
 catch (    NullPointerException e) {
      total+=line.getMultiply() * line.getPrice();
    }
  }
  return BigDecimal.valueOf(total);
}","public BigDecimal getTotalOfaTicket(String place){
  double total=0;
  for (  TicketLineInfo line : findTicket(place).getM_aLines()) {
    total+=line.getMultiply() * line.getPrice();
  }
  return BigDecimal.valueOf(total);
}",0.6338259441707718
5964,"public void addLineToTicket(String ticketId,String productId){
  ticket=new TicketDAO();
  product=new ProductDAO();
  category=new CategoryDAO();
  tax=new TaxDAO();
  taxesLogic=new TaxesLogic(tax.getTaxList());
  TicketInfo obj=ticket.getTicket(ticketId);
  ProductInfo productObj=product.findProductById(productId);
  TicketLineInfo line=new TicketLineInfo(productObj,productObj.getPriceSell(),taxesLogic.getTaxInfo(productObj.getCategoryId()));
  obj.addLine(line);
  ticket.updateTicket(ticketId,obj);
  refreshTax(obj);
}","public void addLineToTicket(String ticketId,String productId){
  ticket=new TicketDAO();
  product=new ProductDAO();
  category=new CategoryDAO();
  tax=new TaxDAO();
  taxesLogic=new TaxesLogic(tax.getTaxList());
  TicketInfo obj=ticket.getTicket(ticketId);
  ProductInfo productObj=product.findProductById(productId);
  TicketLineInfo line=new TicketLineInfo(productObj,productObj.getPriceSell(),taxesLogic.getTaxInfo(productObj.getTaxcat()));
  obj.addLine(line);
  ticket.updateTicket(ticketId,obj);
  refreshTax(obj);
}",0.9847908745247148
5965,"public double getPrice(){
  return price;
}","public double getPrice(){
  try {
    return price + (price * getTax().getRate());
  }
 catch (  NullPointerException ex) {
    return price;
  }
}",0.4526315789473684
5966,"public double getValue(){
  return price * multiply;
}","public double getValue(){
  return getPrice() * multiply;
}",0.9380530973451328
5967,"@Override public void execute(PaymentInfoMagcard payinfo){
  StringBuffer sb=new StringBuffer();
  try {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(URLEncoder.encode(m_sCommerceID,""String_Node_Str""));
    sb.append(""String_Node_Str"");
    sb.append(URLEncoder.encode(m_sCommercePassword,""String_Node_Str""));
    sb.append(""String_Node_Str"");
    NumberFormat formatter=new DecimalFormat(""String_Node_Str"");
    String amount=formatter.format(Math.abs(payinfo.getTotal()));
    sb.append(URLEncoder.encode(amount.replace(',','.'),""String_Node_Str""));
    if (payinfo.getTrack1(true) == null) {
      sb.append(""String_Node_Str"");
      sb.append(URLEncoder.encode(payinfo.getCardNumber(),""String_Node_Str""));
      sb.append(""String_Node_Str"");
      String tmp=payinfo.getExpirationDate();
      sb.append(URLEncoder.encode(tmp,""String_Node_Str""));
      String[] cc_name=payinfo.getHolderName().split(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      if (cc_name.length > 0) {
        sb.append(URLEncoder.encode(cc_name[0],""String_Node_Str""));
      }
      sb.append(""String_Node_Str"");
      if (cc_name.length > 1) {
        sb.append(URLEncoder.encode(cc_name[1],""String_Node_Str""));
      }
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(payinfo.getTrack1(false));
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(m_bTestMode);
    if (payinfo.getTotal() >= 0.0) {
      sb.append(""String_Node_Str"");
      sb.append(OPERATIONVALIDATE);
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(OPERATIONREFUND);
      sb.append(""String_Node_Str"");
      sb.append(payinfo.getTransactionID());
    }
    URL url=new URL(ENDPOINTADDRESS);
    URLConnection connection=url.openConnection();
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(sb.toString().getBytes());
    out.flush();
    out.close();
    BufferedReader in=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    String returned=in.readLine();
    in.close();
    AuthorizeNetParser anp=new AuthorizeNetParser(returned);
    Map props=anp.splitXML();
    if (anp.getResult().equals(LocalRes.getIntString(""String_Node_Str""))) {
      if (APPROVED.equals(props.get(""String_Node_Str""))) {
        payinfo.paymentOK((String)props.get(""String_Node_Str""),(String)props.get(""String_Node_Str""),returned);
      }
 else {
        StringBuilder errorLine=new StringBuilder();
        if (anp.getNumErrors() > 0) {
          for (int i=1; i <= anp.getNumErrors(); i++) {
            errorLine.append(props.get(""String_Node_Str"" + Integer.toString(i)));
            errorLine.append(""String_Node_Str"");
            errorLine.append(props.get(""String_Node_Str"" + Integer.toString(i)));
            errorLine.append(""String_Node_Str"");
          }
        }
        payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),errorLine.toString());
      }
    }
 else {
      payinfo.paymentError(anp.getResult(),""String_Node_Str"");
    }
  }
 catch (  UnsupportedEncodingException eUE) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eUE.getMessage());
  }
catch (  MalformedURLException eMURL) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eMURL.getMessage());
  }
catch (  IOException e) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),e.getMessage());
  }
}","@Override public void execute(PaymentInfoMagcard payinfo){
  StringBuffer sb=new StringBuffer();
  try {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(URLEncoder.encode(m_sCommerceID,""String_Node_Str""));
    sb.append(""String_Node_Str"");
    sb.append(URLEncoder.encode(m_sCommercePassword,""String_Node_Str""));
    sb.append(""String_Node_Str"");
    NumberFormat formatter=new DecimalFormat(""String_Node_Str"");
    String amount=formatter.format(Math.abs(payinfo.getTotal()));
    sb.append(URLEncoder.encode(amount.replace(',','.'),""String_Node_Str""));
    if (payinfo.getTrack1(true) == null) {
      sb.append(""String_Node_Str"");
      sb.append(URLEncoder.encode(payinfo.getCardNumber(),""String_Node_Str""));
      sb.append(""String_Node_Str"");
      String tmp=payinfo.getExpirationDate();
      sb.append(URLEncoder.encode(tmp,""String_Node_Str""));
      String[] cc_name=payinfo.getHolderName().split(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      if (cc_name.length > 0) {
        sb.append(URLEncoder.encode(cc_name[0],""String_Node_Str""));
      }
      sb.append(""String_Node_Str"");
      if (cc_name.length > 1) {
        sb.append(URLEncoder.encode(cc_name[1],""String_Node_Str""));
      }
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(payinfo.getTrack1(false));
      sb.append(""String_Node_Str"");
      sb.append(payinfo.getTrack2(false));
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(m_bTestMode);
    if (payinfo.getTotal() >= 0.0) {
      sb.append(""String_Node_Str"");
      sb.append(OPERATIONVALIDATE);
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(OPERATIONREFUND);
      sb.append(""String_Node_Str"");
      sb.append(payinfo.getTransactionID());
    }
    URL url=new URL(ENDPOINTADDRESS);
    URLConnection connection=url.openConnection();
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(sb.toString().getBytes());
    out.flush();
    out.close();
    BufferedReader in=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    String returned=in.readLine();
    in.close();
    AuthorizeNetParser anp=new AuthorizeNetParser(returned);
    Map props=anp.splitXML();
    if (anp.getResult().equals(LocalRes.getIntString(""String_Node_Str""))) {
      if (APPROVED.equals(props.get(""String_Node_Str""))) {
        payinfo.paymentOK((String)props.get(""String_Node_Str""),(String)props.get(""String_Node_Str""),returned);
      }
 else {
        StringBuilder errorLine=new StringBuilder();
        if (anp.getNumErrors() > 0) {
          for (int i=1; i <= anp.getNumErrors(); i++) {
            errorLine.append(props.get(""String_Node_Str"" + Integer.toString(i)));
            errorLine.append(""String_Node_Str"");
            errorLine.append(props.get(""String_Node_Str"" + Integer.toString(i)));
            errorLine.append(""String_Node_Str"");
          }
        }
        payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),errorLine.toString());
      }
    }
 else {
      payinfo.paymentError(anp.getResult(),""String_Node_Str"");
    }
  }
 catch (  UnsupportedEncodingException eUE) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eUE.getMessage());
  }
catch (  MalformedURLException eMURL) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eMURL.getMessage());
  }
catch (  IOException e) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),e.getMessage());
  }
}",0.9897335932423652
5968,"@Override public void execute(PaymentInfoMagcard payinfo){
  StringBuffer sb=new StringBuffer();
  try {
    sb.append(""String_Node_Str"");
    sb.append(m_sCommerceID);
    sb.append(""String_Node_Str"");
    sb.append(m_sCommercePassword);
    sb.append(""String_Node_Str"");
    NumberFormat formatter=new DecimalFormat(""String_Node_Str"");
    String amount=formatter.format(Math.abs(payinfo.getTotal()));
    sb.append(URLEncoder.encode(amount.replace(',','.'),""String_Node_Str""));
    if (3 == 4) {
      String a=""String_Node_Str"";
      String b=""String_Node_Str"";
      String c=""String_Node_Str"";
      sb.append(""String_Node_Str"" + URLEncoder.encode(a,""String_Node_Str""));
      sb.append(""String_Node_Str"" + URLEncoder.encode(b,""String_Node_Str""));
      sb.append(""String_Node_Str"" + URLEncoder.encode(c,""String_Node_Str""));
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(URLEncoder.encode(payinfo.getCardNumber(),""String_Node_Str""));
      sb.append(""String_Node_Str"");
      sb.append(payinfo.getExpirationDate());
      String[] cc_name=payinfo.getHolderName().split(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      if (cc_name.length > 0) {
        sb.append(URLEncoder.encode(cc_name[0],""String_Node_Str""));
      }
      sb.append(""String_Node_Str"");
      if (cc_name.length > 1) {
        sb.append(URLEncoder.encode(cc_name[1],""String_Node_Str""));
      }
    }
    if (payinfo.getTotal() > 0.0) {
      sb.append(""String_Node_Str"");
      sb.append(OPERATIONVALIDATE);
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(OPERATIONREFUND);
      sb.append(""String_Node_Str"");
      sb.append(payinfo.getTransactionID());
    }
    URL url=new URL(ENDPOINTADDRESS);
    URLConnection connection=url.openConnection();
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    connection.setAllowUserInteraction(false);
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(sb.toString().getBytes());
    out.flush();
    out.close();
    BufferedReader in=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    String returned=in.readLine();
    payinfo.setReturnMessage(returned);
    in.close();
    if (returned == null) {
      payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),""String_Node_Str"");
    }
 else {
      Map props=new HashMap();
      StringTokenizer tk=new StringTokenizer(returned,""String_Node_Str"");
      while (tk.hasMoreTokens()) {
        String sToken=tk.nextToken();
        int i=sToken.indexOf('=');
        if (i >= 0) {
          props.put(URLDecoder.decode(sToken.substring(0,i),""String_Node_Str""),URLDecoder.decode(sToken.substring(i + 1),""String_Node_Str""));
        }
 else {
          props.put(URLDecoder.decode(sToken,""String_Node_Str""),null);
        }
      }
      if (""String_Node_Str"".equals(props.get(""String_Node_Str""))) {
        payinfo.paymentOK((String)props.get(""String_Node_Str""),(String)props.get(""String_Node_Str""),returned);
      }
 else {
        payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),(String)props.get(""String_Node_Str""));
      }
    }
  }
 catch (  UnsupportedEncodingException eUE) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eUE.getMessage());
  }
catch (  MalformedURLException eMURL) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eMURL.getMessage());
  }
catch (  IOException e) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),e.getMessage());
  }
}","@Override public void execute(PaymentInfoMagcard payinfo){
  StringBuffer sb=new StringBuffer();
  try {
    sb.append(""String_Node_Str"");
    sb.append(m_sCommerceID);
    sb.append(""String_Node_Str"");
    sb.append(m_sCommercePassword);
    sb.append(""String_Node_Str"");
    NumberFormat formatter=new DecimalFormat(""String_Node_Str"");
    String amount=formatter.format(Math.abs(payinfo.getTotal()));
    sb.append(URLEncoder.encode(amount.replace(',','.'),""String_Node_Str""));
    if (payinfo.getTrack1(true) == null) {
      sb.append(""String_Node_Str"");
      sb.append(URLEncoder.encode(payinfo.getCardNumber(),""String_Node_Str""));
      sb.append(""String_Node_Str"");
      sb.append(payinfo.getExpirationDate());
      String[] cc_name=payinfo.getHolderName().split(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      if (cc_name.length > 0) {
        sb.append(URLEncoder.encode(cc_name[0],""String_Node_Str""));
      }
      sb.append(""String_Node_Str"");
      if (cc_name.length > 1) {
        sb.append(URLEncoder.encode(cc_name[1],""String_Node_Str""));
      }
    }
 else {
      sb.append(""String_Node_Str"" + URLEncoder.encode(payinfo.getTrack1(true),""String_Node_Str""));
      sb.append(""String_Node_Str"" + URLEncoder.encode(payinfo.getTrack2(true),""String_Node_Str""));
    }
    if (payinfo.getTotal() > 0.0) {
      sb.append(""String_Node_Str"");
      sb.append(OPERATIONVALIDATE);
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(OPERATIONREFUND);
      sb.append(""String_Node_Str"");
      sb.append(payinfo.getTransactionID());
    }
    URL url=new URL(ENDPOINTADDRESS);
    URLConnection connection=url.openConnection();
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    connection.setAllowUserInteraction(false);
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(sb.toString().getBytes());
    out.flush();
    out.close();
    BufferedReader in=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    String returned=in.readLine();
    payinfo.setReturnMessage(returned);
    in.close();
    if (returned == null) {
      payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),""String_Node_Str"");
    }
 else {
      Map props=new HashMap();
      StringTokenizer tk=new StringTokenizer(returned,""String_Node_Str"");
      while (tk.hasMoreTokens()) {
        String sToken=tk.nextToken();
        int i=sToken.indexOf('=');
        if (i >= 0) {
          props.put(URLDecoder.decode(sToken.substring(0,i),""String_Node_Str""),URLDecoder.decode(sToken.substring(i + 1),""String_Node_Str""));
        }
 else {
          props.put(URLDecoder.decode(sToken,""String_Node_Str""),null);
        }
      }
      if (""String_Node_Str"".equals(props.get(""String_Node_Str""))) {
        payinfo.paymentOK((String)props.get(""String_Node_Str""),(String)props.get(""String_Node_Str""),returned);
      }
 else {
        payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),(String)props.get(""String_Node_Str""));
      }
    }
  }
 catch (  UnsupportedEncodingException eUE) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eUE.getMessage());
  }
catch (  MalformedURLException eMURL) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eMURL.getMessage());
  }
catch (  IOException e) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),e.getMessage());
  }
}",0.8426367461430575
5969,"@Override public void execute(PaymentInfoMagcard payinfo){
  String sReturned=""String_Node_Str"";
  URL url;
  System.setProperty(""String_Node_Str"",sClientCertPath);
  System.setProperty(""String_Node_Str"",sPasswordCert);
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  String sTransactionType=(payinfo.getTotal() > 0.0) ? SALE : REFUND;
  try {
    url=new URL(""String_Node_Str"" + HOST + ""String_Node_Str""+ PORT);
    HttpsURLConnection connection=(HttpsURLConnection)url.openConnection();
    connection.setHostnameVerifier(new NullHostNameVerifier());
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    connection.setAllowUserInteraction(false);
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    NumberFormat formatter=new DecimalFormat(""String_Node_Str"");
    String amount=formatter.format(Math.abs(payinfo.getTotal()));
    String tmp=payinfo.getExpirationDate();
    String refundLine=(sTransactionType.equals(""String_Node_Str"")) ? ""String_Node_Str"" + payinfo.getTransactionID() + ""String_Node_Str"" : ""String_Node_Str"";
    String xml=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + sConfigfile + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sTransactionType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ URLEncoder.encode(amount.replace(',','.'),""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ payinfo.getCardNumber()+ ""String_Node_Str""+ ""String_Node_Str""+ tmp.charAt(0)+ ""String_Node_Str""+ tmp.charAt(1)+ ""String_Node_Str""+ ""String_Node_Str""+ tmp.charAt(2)+ ""String_Node_Str""+ tmp.charAt(3)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ refundLine+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(xml.getBytes());
    out.flush();
    BufferedReader in=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    sReturned=in.readLine();
  }
 catch (  IOException exIoe) {
    payinfo.paymentError(LocalRes.getIntString(""String_Node_Str""),exIoe.getMessage());
  }
  LinkPointParser lpp=new LinkPointParser(sReturned);
  Map props=lpp.splitXML();
  if (lpp.getResult().equals(LocalRes.getIntString(""String_Node_Str""))) {
    if (APPROVED.equals(props.get(""String_Node_Str""))) {
      payinfo.paymentOK((String)props.get(""String_Node_Str""),(String)props.get(""String_Node_Str""),sReturned);
    }
 else {
      payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),(String)props.get(""String_Node_Str""));
    }
  }
 else {
    payinfo.paymentError(lpp.getResult(),""String_Node_Str"");
  }
}","@Override public void execute(PaymentInfoMagcard payinfo){
  String sReturned=""String_Node_Str"";
  URL url;
  System.setProperty(""String_Node_Str"",sClientCertPath);
  System.setProperty(""String_Node_Str"",sPasswordCert);
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  try {
    url=new URL(""String_Node_Str"" + HOST + ""String_Node_Str""+ PORT);
    HttpsURLConnection connection=(HttpsURLConnection)url.openConnection();
    connection.setHostnameVerifier(new NullHostNameVerifier());
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    connection.setAllowUserInteraction(false);
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    StringBuilder xml=createOrder(payinfo);
    String a=xml.toString();
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(xml.toString().getBytes());
    out.flush();
    BufferedReader in=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    sReturned=in.readLine();
  }
 catch (  IOException exIoe) {
    payinfo.paymentError(LocalRes.getIntString(""String_Node_Str""),exIoe.getMessage());
  }
  LinkPointParser lpp=new LinkPointParser(sReturned);
  Map props=lpp.splitXML();
  if (lpp.getResult().equals(LocalRes.getIntString(""String_Node_Str""))) {
    if (APPROVED.equals(props.get(""String_Node_Str""))) {
      payinfo.paymentOK((String)props.get(""String_Node_Str""),(String)props.get(""String_Node_Str""),sReturned);
    }
 else {
      payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),(String)props.get(""String_Node_Str""));
    }
  }
 else {
    payinfo.paymentError(lpp.getResult(),""String_Node_Str"");
  }
}",0.6805429864253394
5970,"public void execute(PaymentInfoMagcard payinfo){
  StringBuffer sb=new StringBuffer();
  try {
    sb.append(""String_Node_Str"");
    sb.append(m_sCommerceID);
    sb.append(""String_Node_Str"");
    sb.append(m_sCommercePassword);
    sb.append(""String_Node_Str"");
    NumberFormat formatter=new DecimalFormat(""String_Node_Str"");
    String amount=formatter.format(Math.abs(payinfo.getTotal()));
    sb.append(URLEncoder.encode(amount.replace(',','.'),""String_Node_Str""));
    sb.append(""String_Node_Str"");
    sb.append(getCardType(payinfo.getCardNumber()));
    sb.append(""String_Node_Str"");
    sb.append(URLEncoder.encode(payinfo.getCardNumber(),""String_Node_Str""));
    sb.append(""String_Node_Str"");
    String tmp=payinfo.getExpirationDate();
    sb.append(tmp.substring(0,2));
    sb.append(""String_Node_Str"");
    sb.append(tmp.substring(2,tmp.length()));
    String[] cc_name=payinfo.getHolderName().split(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (cc_name.length > 0) {
      sb.append(URLEncoder.encode(cc_name[0],""String_Node_Str""));
    }
    sb.append(""String_Node_Str"");
    if (cc_name.length > 1) {
      sb.append(URLEncoder.encode(cc_name[1],""String_Node_Str""));
    }
    sb.append(""String_Node_Str"");
    sb.append(payinfo.getHolderName());
    if (payinfo.getTotal() >= 0.0) {
      sb.append(""String_Node_Str"");
      sb.append(SALE);
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(REFUND);
    }
    sb.append(""String_Node_Str"");
    URL url=new URL(ENDPOINTADDRESS);
    URLConnection connection=url.openConnection();
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(sb.toString().getBytes());
    out.flush();
    out.close();
    BufferedReader in=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    String returned=""String_Node_Str"", aux;
    while ((aux=in.readLine()) != null) {
      returned+=""String_Node_Str"" + aux;
    }
    payinfo.setReturnMessage(returned);
    in.close();
    Map props=new HashMap();
    StringTokenizer tk=new java.util.StringTokenizer(returned,""String_Node_Str"");
    while (tk.hasMoreTokens()) {
      String sToken=tk.nextToken();
      int i=sToken.indexOf('=');
      if (i >= 0) {
        props.put(URLDecoder.decode(sToken.substring(0,i),""String_Node_Str""),URLDecoder.decode(sToken.substring(i + 1),""String_Node_Str""));
      }
 else {
        props.put(URLDecoder.decode(sToken,""String_Node_Str""),null);
      }
    }
    if (APPROVED.equals(props.get(""String_Node_Str""))) {
      payinfo.paymentOK((String)props.get(""String_Node_Str""),(String)props.get(""String_Node_Str""),returned);
    }
 else {
      String sCode=(String)props.get(""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),sCode);
    }
  }
 catch (  UnsupportedEncodingException eUE) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eUE.getMessage());
  }
catch (  MalformedURLException eMURL) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eMURL.getMessage());
  }
catch (  IOException e) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),e.getMessage());
  }
}","public void execute(PaymentInfoMagcard payinfo){
  StringBuffer sb=new StringBuffer();
  try {
    sb.append(""String_Node_Str"");
    sb.append(m_sCommerceID);
    sb.append(""String_Node_Str"");
    sb.append(m_sCommercePassword);
    sb.append(""String_Node_Str"");
    NumberFormat formatter=new DecimalFormat(""String_Node_Str"");
    String amount=formatter.format(Math.abs(payinfo.getTotal()));
    sb.append(URLEncoder.encode(amount.replace(',','.'),""String_Node_Str""));
    sb.append(""String_Node_Str"");
    sb.append(getCardType(payinfo.getCardNumber()));
    sb.append(""String_Node_Str"");
    sb.append(URLEncoder.encode(payinfo.getCardNumber(),""String_Node_Str""));
    sb.append(""String_Node_Str"");
    String tmp=payinfo.getExpirationDate();
    sb.append(tmp.substring(0,2));
    sb.append(""String_Node_Str"");
    sb.append(tmp.substring(2,tmp.length()));
    String[] cc_name=payinfo.getHolderName().split(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (cc_name.length > 0) {
      sb.append(URLEncoder.encode(cc_name[0],""String_Node_Str""));
    }
    sb.append(""String_Node_Str"");
    if (cc_name.length > 1) {
      sb.append(URLEncoder.encode(cc_name[1],""String_Node_Str""));
    }
    sb.append(""String_Node_Str"");
    sb.append(payinfo.getHolderName());
    if (payinfo.getTrack1(true) != null) {
      sb.append(""String_Node_Str"");
      sb.append(URLEncoder.encode(payinfo.getTrack1(true),""String_Node_Str""));
    }
    if (payinfo.getTotal() >= 0.0) {
      sb.append(""String_Node_Str"");
      sb.append(SALE);
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(REFUND);
    }
    sb.append(""String_Node_Str"");
    URL url=new URL(ENDPOINTADDRESS);
    URLConnection connection=url.openConnection();
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(sb.toString().getBytes());
    out.flush();
    out.close();
    BufferedReader in=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    String returned=""String_Node_Str"", aux;
    while ((aux=in.readLine()) != null) {
      returned+=""String_Node_Str"" + aux;
    }
    payinfo.setReturnMessage(returned);
    in.close();
    Map props=new HashMap();
    StringTokenizer tk=new java.util.StringTokenizer(returned,""String_Node_Str"");
    while (tk.hasMoreTokens()) {
      String sToken=tk.nextToken();
      int i=sToken.indexOf('=');
      if (i >= 0) {
        props.put(URLDecoder.decode(sToken.substring(0,i),""String_Node_Str""),URLDecoder.decode(sToken.substring(i + 1),""String_Node_Str""));
      }
 else {
        props.put(URLDecoder.decode(sToken,""String_Node_Str""),null);
      }
    }
    if (APPROVED.equals(props.get(""String_Node_Str""))) {
      payinfo.paymentOK((String)props.get(""String_Node_Str""),(String)props.get(""String_Node_Str""),returned);
    }
 else {
      String sCode=(String)props.get(""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      sCode=sCode.replace(""String_Node_Str"",""String_Node_Str"");
      payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),sCode);
    }
  }
 catch (  UnsupportedEncodingException eUE) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eUE.getMessage());
  }
catch (  MalformedURLException eMURL) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eMURL.getMessage());
  }
catch (  IOException e) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),e.getMessage());
  }
}",0.978033753013662
5971,"protected void internalWrite(byte[] data){
  try {
    if (m_out == null) {
      m_PortIdPrinter=CommPortIdentifier.getPortIdentifier(m_sPortPrinter);
      m_CommPortPrinter=m_PortIdPrinter.open(""String_Node_Str"",2000);
      m_out=m_CommPortPrinter.getOutputStream();
      if (m_PortIdPrinter.getPortType() == CommPortIdentifier.PORT_SERIAL) {
        ((SerialPort)m_CommPortPrinter).setSerialPortParams(9600,SerialPort.DATABITS_8,SerialPort.STOPBITS_1,SerialPort.PARITY_NONE);
      }
    }
    m_out.write(data);
  }
 catch (  NoSuchPortException e) {
    System.err.println(e);
  }
catch (  PortInUseException e) {
    System.err.println(e);
  }
catch (  UnsupportedCommOperationException e) {
    System.err.println(e);
  }
catch (  IOException e) {
    System.err.println(e);
  }
}","protected void internalWrite(byte[] data){
  try {
    if (m_out == null) {
      m_PortIdPrinter=CommPortIdentifier.getPortIdentifier(m_sPortPrinter);
      m_CommPortPrinter=m_PortIdPrinter.open(""String_Node_Str"",2000);
      m_out=m_CommPortPrinter.getOutputStream();
      if (m_PortIdPrinter.getPortType() == CommPortIdentifier.PORT_SERIAL) {
        ((SerialPort)m_CommPortPrinter).setSerialPortParams(9600,SerialPort.DATABITS_8,SerialPort.STOPBITS_1,SerialPort.PARITY_NONE);
        ((SerialPort)m_CommPortPrinter).setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_IN);
      }
    }
    m_out.write(data);
  }
 catch (  NoSuchPortException e) {
    System.err.println(e);
  }
catch (  PortInUseException e) {
    System.err.println(e);
  }
catch (  UnsupportedCommOperationException e) {
    System.err.println(e);
  }
catch (  IOException e) {
    System.err.println(e);
  }
}",0.9438470728793308
5972,"protected void paintComponent(Graphics g){
  paintBorder(g);
  Graphics2D g2d=(Graphics2D)g;
  Insets i=getInsets();
  g2d.setPaint(new GradientPaint(getWidth() - i.left - i.right- 100,getHeight() - i.top - i.bottom- 100,getBackground(),getWidth() - i.left - i.right,getHeight() - i.top - i.bottom,new Color(0xf0f0f0),true));
  g2d.fillRect(i.left,i.top,getWidth() - i.left - i.right,getHeight() - i.top - i.bottom);
  g.setColor(getForeground());
  basict.draw(g2d,i.left + H_GAP,i.top + V_GAP,LINEWIDTH);
}","protected void paintComponent(Graphics g){
  paintBorder(g);
  Graphics2D g2d=(Graphics2D)g;
  if (desktophints != null) {
    g2d.addRenderingHints(desktophints);
  }
  Insets i=getInsets();
  g2d.setPaint(new GradientPaint(getWidth() - i.left - i.right- 100,getHeight() - i.top - i.bottom- 100,getBackground(),getWidth() - i.left - i.right,getHeight() - i.top - i.bottom,new Color(0xf0f0f0),true));
  g2d.fillRect(i.left,i.top,getWidth() - i.left - i.right,getHeight() - i.top - i.bottom);
  g.setColor(getForeground());
  basict.draw(g2d,i.left + H_GAP,i.top + V_GAP,LINEWIDTH);
}",0.931255728689276
5973,"/** 
 * Creates new form JTicket 
 */
public JTicket(BasicTicket t){
  basict=t;
  initComponents();
}","/** 
 * Creates new form JTicket 
 */
public JTicket(BasicTicket t){
  basict=t;
  desktophints=(Map)Toolkit.getDefaultToolkit().getDesktopProperty(""String_Node_Str"");
  initComponents();
}",0.7010309278350515
5974,"private void checkTracks(){
  if (m_cCardType != 'B')   return;
  String sCardNumber1=(m_aTrack1 == null || m_aTrack1.size() < 1) ? null : (String)m_aTrack1.get(0);
  String sCardNumber2=(m_aTrack2 == null || m_aTrack2.size() < 1) ? null : (String)m_aTrack2.get(0);
  String sHolderName=(m_aTrack1 == null || m_aTrack1.size() < 2) ? null : (String)m_aTrack1.get(1);
  String sExpDate1=(m_aTrack1 == null || m_aTrack1.size() < 3) ? null : ((String)m_aTrack1.get(2)).substring(0,4);
  String sExpDate2=(m_aTrack2 == null || m_aTrack2.size() < 2) ? null : ((String)m_aTrack2.get(1)).substring(0,4);
  if (!checkCardNumber(sCardNumber1) || (sCardNumber2 != null && !sCardNumber1.equals(sCardNumber2)))   return;
  if (sHolderName == null)   return;
  if ((sExpDate1 != null || !checkExpDate(sExpDate2)) && (!checkExpDate(sExpDate1) || !sExpDate1.equals(sExpDate2)))   return;
  m_sCardNumber=sCardNumber1;
  m_sHolderName=formatHolderName(sHolderName);
  m_sExpirationDate=sExpDate1 == null ? sExpDate2 : sExpDate1;
}","private void checkTracks(){
  if (m_cCardType != 'B')   return;
  String sCardNumber1=(m_aTrack1 == null || m_aTrack1.size() < 1) ? null : (String)m_aTrack1.get(0);
  String sCardNumber2=(m_aTrack2 == null || m_aTrack2.size() < 1) ? null : (String)m_aTrack2.get(0);
  String sHolderName=(m_aTrack1 == null || m_aTrack1.size() < 2) ? null : (String)m_aTrack1.get(1);
  String sExpDate1=(m_aTrack1 == null || m_aTrack1.size() < 3) ? null : ((String)m_aTrack1.get(2)).substring(0,4);
  String sExpDate2=(m_aTrack2 == null || m_aTrack2.size() < 2) ? null : ((String)m_aTrack2.get(1)).substring(0,4);
  if (!checkCardNumber(sCardNumber1) || (sCardNumber2 != null && !sCardNumber1.equals(sCardNumber2)))   return;
  if (sHolderName == null)   return;
  if ((sExpDate1 != null || !checkExpDate(sExpDate2)) && (!checkExpDate(sExpDate1) || !sExpDate1.equals(sExpDate2)))   return;
  m_sCardNumber=sCardNumber1;
  m_sHolderName=formatHolderName(sHolderName);
  String yymm=sExpDate1 == null ? sExpDate2 : sExpDate1;
  m_sExpirationDate=yymm.substring(2,4) + yymm.substring(0,2);
}",0.9332693230916946
5975,"public void writeValues(DataWrite dp) throws BasicException {
  dp.setString(1,m_sTicket);
  dp.setInt(2,new Integer(m_iLine));
  dp.setString(3,productid);
  dp.setDouble(4,new Double(multiply));
  dp.setDouble(5,new Double(price));
  dp.setString(6,tax.getId());
  try {
    ByteArrayOutputStream o=new ByteArrayOutputStream();
    attributes.storeToXML(o,AppLocal.APP_NAME,""String_Node_Str"");
    dp.setBytes(7,o.toByteArray());
  }
 catch (  IOException e) {
    dp.setBytes(7,null);
  }
}","public void writeValues(DataWrite dp) throws BasicException {
  dp.setString(1,m_sTicket);
  dp.setInt(2,new Integer(m_iLine));
  dp.setString(3,productid);
  dp.setString(4,attsetinstid);
  dp.setDouble(5,new Double(multiply));
  dp.setDouble(6,new Double(price));
  dp.setString(7,tax.getId());
  try {
    ByteArrayOutputStream o=new ByteArrayOutputStream();
    attributes.storeToXML(o,AppLocal.APP_NAME,""String_Node_Str"");
    dp.setBytes(8,o.toByteArray());
  }
 catch (  IOException e) {
    dp.setBytes(8,null);
  }
}",0.9587426326129664
5976,"public void readValues(DataRead dr) throws BasicException {
  m_sTicket=dr.getString(1);
  m_iLine=dr.getInt(2).intValue();
  productid=dr.getString(3);
  multiply=dr.getDouble(4);
  price=dr.getDouble(5);
  tax=new TaxInfo(dr.getString(6),dr.getString(7),dr.getString(8),dr.getString(9),dr.getString(10),dr.getDouble(11),dr.getBoolean(12),dr.getInt(13));
  attributes=new Properties();
  try {
    byte[] img=dr.getBytes(14);
    if (img != null) {
      attributes.loadFromXML(new ByteArrayInputStream(img));
    }
  }
 catch (  IOException e) {
  }
}","public void readValues(DataRead dr) throws BasicException {
  m_sTicket=dr.getString(1);
  m_iLine=dr.getInt(2).intValue();
  productid=dr.getString(3);
  attsetinstid=dr.getString(4);
  multiply=dr.getDouble(5);
  price=dr.getDouble(6);
  tax=new TaxInfo(dr.getString(7),dr.getString(8),dr.getString(9),dr.getString(10),dr.getString(11),dr.getDouble(12),dr.getBoolean(13),dr.getInt(14));
  attributes=new Properties();
  try {
    byte[] img=dr.getBytes(15);
    if (img != null) {
      attributes.loadFromXML(new ByteArrayInputStream(img));
    }
  }
 catch (  IOException e) {
  }
}",0.932396839332748
5977,"public final SentenceExec getCatalogCategoryAdd(){
  return new StaticSentence(s,""String_Node_Str"",SerializerWriteString.INSTANCE);
}","public final SentenceExec getCatalogCategoryAdd(){
  return new StaticSentence(s,""String_Node_Str"" + s.DB.INTEGER_NULL() + ""String_Node_Str"",SerializerWriteString.INSTANCE);
}",0.8636363636363636
5978,"private void init(Session s){
  initComponents();
  attsetSave=new PreparedSentence(s,""String_Node_Str"",new SerializerWriteBasic(Datas.STRING,Datas.STRING,Datas.STRING));
  attinstSave=new PreparedSentence(s,""String_Node_Str"",new SerializerWriteBasic(Datas.STRING,Datas.STRING,Datas.STRING,Datas.STRING));
  attsetSent=new PreparedSentence(s,""String_Node_Str"",SerializerWriteString.INSTANCE,new SerializerRead(){
    public Object readValues(    DataRead dr) throws BasicException {
      return new AttributeSetInfo(dr.getString(1),dr.getString(2));
    }
  }
);
  attsetinstExistsSent=new PreparedSentence(s,""String_Node_Str"",new SerializerWriteBasic(Datas.STRING,Datas.STRING),SerializerReadString.INSTANCE);
  attinstSent=new PreparedSentence(s,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",SerializerWriteString.INSTANCE,new SerializerRead(){
    public Object readValues(    DataRead dr) throws BasicException {
      return new AttributeInstInfo(dr.getString(1),dr.getString(2),dr.getString(3),dr.getString(4));
    }
  }
);
  attinstSent2=new PreparedSentence(s,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",new SerializerWriteBasic(Datas.STRING,Datas.STRING),new SerializerRead(){
    public Object readValues(    DataRead dr) throws BasicException {
      return new AttributeInstInfo(dr.getString(1),dr.getString(2),dr.getString(3),dr.getString(4));
    }
  }
);
  attvaluesSent=new PreparedSentence(s,""String_Node_Str"",SerializerWriteString.INSTANCE,SerializerReadString.INSTANCE);
  getRootPane().setDefaultButton(m_jButtonOK);
}","private void init(Session s){
  initComponents();
  attsetSave=new PreparedSentence(s,""String_Node_Str"",new SerializerWriteBasic(Datas.STRING,Datas.STRING,Datas.STRING));
  attinstSave=new PreparedSentence(s,""String_Node_Str"",new SerializerWriteBasic(Datas.STRING,Datas.STRING,Datas.STRING,Datas.STRING));
  attsetSent=new PreparedSentence(s,""String_Node_Str"",SerializerWriteString.INSTANCE,new SerializerRead(){
    public Object readValues(    DataRead dr) throws BasicException {
      return new AttributeSetInfo(dr.getString(1),dr.getString(2));
    }
  }
);
  attsetinstExistsSent=new PreparedSentence(s,""String_Node_Str"",new SerializerWriteBasic(Datas.STRING,Datas.STRING),SerializerReadString.INSTANCE);
  attinstSent=new PreparedSentence(s,""String_Node_Str"" + s.DB.CHAR_NULL() + ""String_Node_Str""+ s.DB.CHAR_NULL()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",SerializerWriteString.INSTANCE,new SerializerRead(){
    public Object readValues(    DataRead dr) throws BasicException {
      return new AttributeInstInfo(dr.getString(1),dr.getString(2),dr.getString(3),dr.getString(4));
    }
  }
);
  attinstSent2=new PreparedSentence(s,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",new SerializerWriteBasic(Datas.STRING,Datas.STRING),new SerializerRead(){
    public Object readValues(    DataRead dr) throws BasicException {
      return new AttributeInstInfo(dr.getString(1),dr.getString(2),dr.getString(3),dr.getString(4));
    }
  }
);
  attvaluesSent=new PreparedSentence(s,""String_Node_Str"",SerializerWriteString.INSTANCE,SerializerReadString.INSTANCE);
  getRootPane().setDefaultButton(m_jButtonOK);
}",0.9664838513101768
5979,"public void fillPermissions(DataLogicSystem dlSystem){
  m_apermissions=new HashSet<String>();
  m_apermissions.add(""String_Node_Str"");
  m_apermissions.add(""String_Node_Str"");
  String sRolePermisions=dlSystem.findRolePermissions(m_sRole);
  if (sRolePermisions != null) {
    try {
      if (m_sp == null) {
        SAXParserFactory spf=SAXParserFactory.newInstance();
        m_sp=spf.newSAXParser();
      }
      m_sp.parse(new InputSource(new StringReader(sRolePermisions)),new ConfigurationHandler());
    }
 catch (    ParserConfigurationException ePC) {
      logger.log(Level.WARNING,""String_Node_Str"",ePC);
    }
catch (    SAXException eSAX) {
      logger.log(Level.WARNING,""String_Node_Str"",eSAX);
    }
catch (    IOException eIO) {
      logger.log(Level.WARNING,""String_Node_Str"",eIO);
    }
  }
}","public void fillPermissions(DataLogicSystem dlSystem){
  m_apermissions=new HashSet<String>();
  m_apermissions.add(""String_Node_Str"");
  m_apermissions.add(""String_Node_Str"");
  String sRolePermisions=dlSystem.findRolePermissions(m_sRole);
  if (sRolePermisions != null) {
    try {
      if (m_sp == null) {
        SAXParserFactory spf=SAXParserFactory.newInstance();
        m_sp=spf.newSAXParser();
      }
      m_sp.parse(new InputSource(new StringReader(sRolePermisions)),new ConfigurationHandler());
    }
 catch (    ParserConfigurationException ePC) {
      logger.log(Level.WARNING,LocalRes.getIntString(""String_Node_Str""),ePC);
    }
catch (    SAXException eSAX) {
      logger.log(Level.WARNING,LocalRes.getIntString(""String_Node_Str""),eSAX);
    }
catch (    IOException eIO) {
      logger.log(Level.WARNING,LocalRes.getIntString(""String_Node_Str""),eIO);
    }
  }
}",0.8992339422510313
5980,"private void m_jEditLineActionPerformed(java.awt.event.ActionEvent evt){
  int i=m_ticketlines.getSelectedIndex();
  if (i < 0) {
    Toolkit.getDefaultToolkit().beep();
  }
 else {
    TicketLineInfo newline=JProductLineEdit.showMessage(this,m_App,m_oTicket.getLine(i));
    if (newline != null) {
      paintTicketLine(i,newline);
    }
  }
}","private void m_jEditLineActionPerformed(java.awt.event.ActionEvent evt){
  int i=m_ticketlines.getSelectedIndex();
  if (i < 0) {
    Toolkit.getDefaultToolkit().beep();
  }
 else {
    try {
      TicketLineInfo newline=JProductLineEdit.showMessage(this,m_App,m_oTicket.getLine(i));
      if (newline != null) {
        paintTicketLine(i,newline);
      }
    }
 catch (    BasicException e) {
      new MessageInf(e).show(this);
    }
  }
}",0.8575063613231552
5981,"private TicketLineInfo init(AppView app,TicketLineInfo oLine){
  initComponents();
  m_oLine=new TicketLineInfo(oLine);
  m_bunitsok=true;
  m_bpriceok=true;
  m_jName.setEnabled(m_oLine.getProductID() == null && app.getAppUserView().getUser().hasPermission(""String_Node_Str""));
  m_jPrice.setEnabled(app.getAppUserView().getUser().hasPermission(""String_Node_Str""));
  m_jPriceTax.setEnabled(app.getAppUserView().getUser().hasPermission(""String_Node_Str""));
  m_jName.setText(m_oLine.getProperty(""String_Node_Str""));
  m_jUnits.setDoubleValue(oLine.getMultiply());
  m_jPrice.setDoubleValue(oLine.getPrice());
  m_jPriceTax.setDoubleValue(oLine.getPriceTax());
  m_jTaxrate.setText(oLine.getTaxInfo().getName());
  m_jName.addPropertyChangeListener(""String_Node_Str"",new RecalculateName());
  m_jUnits.addPropertyChangeListener(""String_Node_Str"",new RecalculateUnits());
  m_jPrice.addPropertyChangeListener(""String_Node_Str"",new RecalculatePrice());
  m_jPriceTax.addPropertyChangeListener(""String_Node_Str"",new RecalculatePriceTax());
  m_jName.addEditorKeys(m_jKeys);
  m_jUnits.addEditorKeys(m_jKeys);
  m_jPrice.addEditorKeys(m_jKeys);
  m_jPriceTax.addEditorKeys(m_jKeys);
  if (m_jName.isEnabled()) {
    m_jName.activate();
  }
 else {
    m_jUnits.activate();
  }
  printTotals();
  getRootPane().setDefaultButton(m_jButtonOK);
  returnLine=null;
  setVisible(true);
  return returnLine;
}","private TicketLineInfo init(AppView app,TicketLineInfo oLine) throws BasicException {
  initComponents();
  if (oLine.getTaxInfo() == null) {
    throw new BasicException(AppLocal.getIntString(""String_Node_Str""));
  }
  m_oLine=new TicketLineInfo(oLine);
  m_bunitsok=true;
  m_bpriceok=true;
  m_jName.setEnabled(m_oLine.getProductID() == null && app.getAppUserView().getUser().hasPermission(""String_Node_Str""));
  m_jPrice.setEnabled(app.getAppUserView().getUser().hasPermission(""String_Node_Str""));
  m_jPriceTax.setEnabled(app.getAppUserView().getUser().hasPermission(""String_Node_Str""));
  m_jName.setText(m_oLine.getProperty(""String_Node_Str""));
  m_jUnits.setDoubleValue(oLine.getMultiply());
  m_jPrice.setDoubleValue(oLine.getPrice());
  m_jPriceTax.setDoubleValue(oLine.getPriceTax());
  m_jTaxrate.setText(oLine.getTaxInfo().getName());
  m_jName.addPropertyChangeListener(""String_Node_Str"",new RecalculateName());
  m_jUnits.addPropertyChangeListener(""String_Node_Str"",new RecalculateUnits());
  m_jPrice.addPropertyChangeListener(""String_Node_Str"",new RecalculatePrice());
  m_jPriceTax.addPropertyChangeListener(""String_Node_Str"",new RecalculatePriceTax());
  m_jName.addEditorKeys(m_jKeys);
  m_jUnits.addEditorKeys(m_jKeys);
  m_jPrice.addEditorKeys(m_jKeys);
  m_jPriceTax.addEditorKeys(m_jKeys);
  if (m_jName.isEnabled()) {
    m_jName.activate();
  }
 else {
    m_jUnits.activate();
  }
  printTotals();
  getRootPane().setDefaultButton(m_jButtonOK);
  returnLine=null;
  setVisible(true);
  return returnLine;
}",0.9539406345957012
5982,"public static TicketLineInfo showMessage(Component parent,AppView app,TicketLineInfo oLine){
  Window window=getWindow(parent);
  JProductLineEdit myMsg;
  if (window instanceof Frame) {
    myMsg=new JProductLineEdit((Frame)window,true);
  }
 else {
    myMsg=new JProductLineEdit((Dialog)window,true);
  }
  return myMsg.init(app,oLine);
}","public static TicketLineInfo showMessage(Component parent,AppView app,TicketLineInfo oLine) throws BasicException {
  Window window=getWindow(parent);
  JProductLineEdit myMsg;
  if (window instanceof Frame) {
    myMsg=new JProductLineEdit((Frame)window,true);
  }
 else {
    myMsg=new JProductLineEdit((Dialog)window,true);
  }
  return myMsg.init(app,oLine);
}",0.9673758865248226
5983,"private String formatDouble(Double dvalue){
  String sNumber=dvalue.toString();
  if (sNumber.endsWith(""String_Node_Str"")) {
    sNumber=sNumber.substring(0,sNumber.length() - 2);
  }
  return sNumber;
}","private String formatDouble(Double value){
  String sNumber=Double.toString(DoubleUtils.fixDecimals(value));
  if (sNumber.endsWith(""String_Node_Str"")) {
    sNumber=sNumber.substring(0,sNumber.length() - 2);
  }
  return sNumber;
}",0.8781609195402299
5984,"public static int getLineMult(int iSize){
switch (iSize) {
case 0:
case 2:
    return 1;
case 1:
case 3:
  return 2;
default :
return 0;
}
}","public static int getLineMult(int iSize){
switch (iSize) {
case 0:
case 2:
    return 1;
case 1:
case 3:
  return 2;
default :
return 1;
}
}",0.9928571428571428
5985,"public Font getFont(Font baseFont,int iStyle){
  Font f;
switch (m_iSize) {
case 0:
    f=baseFont;
  break;
case 2:
f=baseFont.deriveFont(AffineTransform.getScaleInstance(2.0,1.0));
break;
case 1:
f=baseFont.deriveFont(AffineTransform.getScaleInstance(1.0,2.0));
break;
case 3:
f=baseFont.deriveFont(AffineTransform.getScaleInstance(2.0,2.0));
break;
default :
f=baseFont;
break;
}
f=f.deriveFont((iStyle & DevicePrinter.STYLE_BOLD) != 0 ? Font.BOLD : Font.PLAIN);
return f;
}","public Font getFont(Font baseFont,int iStyle){
  Font f;
  AffineTransform a;
switch (m_iSize) {
case 0:
    f=baseFont;
  break;
case 2:
a=AffineTransform.getScaleInstance(2.0,1.0);
a.preConcatenate(baseFont.getTransform());
f=baseFont.deriveFont(a);
break;
case 1:
a=AffineTransform.getScaleInstance(1.0,2.0);
a.preConcatenate(baseFont.getTransform());
f=baseFont.deriveFont(a);
break;
case 3:
a=AffineTransform.getScaleInstance(2.0,2.0);
a.preConcatenate(baseFont.getTransform());
f=baseFont.deriveFont(a);
break;
default :
f=baseFont;
break;
}
f=f.deriveFont((iStyle & DevicePrinter.STYLE_BOLD) != 0 ? Font.BOLD : baseFont.getStyle());
return f;
}",0.7109929078014184
5986,"public BigDecimal getTotalOfaTicket(String place){
  double total=0;
  for (  TicketLineInfo line : findTicket(place).getM_aLines()) {
    total+=line.getPrice() + line.getPrice() * line.getTax().getRate();
  }
  return BigDecimal.valueOf(total);
}","public BigDecimal getTotalOfaTicket(String place){
  double total=0;
  for (  TicketLineInfo line : findTicket(place).getM_aLines()) {
    try {
      total+=line.getMultiply() * (line.getPrice() + line.getPrice() * line.getTax().getRate());
    }
 catch (    NullPointerException e) {
      total+=line.getMultiply() * line.getPrice();
    }
  }
  return BigDecimal.valueOf(total);
}",0.7848101265822784
5987,"public String findPlaceById(String placeId){
  place=new PlaceDAO();
  return place.findPlaceById(placeId).getName();
}","public Place findPlaceById(String placeId){
  place=new PlaceDAO();
  return place.findPlaceById(placeId);
}",0.9074889867841408
5988,"public void addLineToTicket(String ticketId,String aCategory,String productIndex){
  lines=new TicketLineDAO();
  ticket=new TicketDAO();
  product=new ProductDAO();
  category=new CategoryDAO();
  tax=new TaxDAO();
  taxesLogic=new TaxesLogic(tax.getTaxList());
  TicketInfo obj=ticket.getTicket(ticketId);
  ProductInfo productObj=null;
  if (aCategory.equals(""String_Node_Str"")) {
    aCategory=category.findFirstCategory();
  }
  productObj=product.findProductsByCategory(aCategory).get(Integer.valueOf(productIndex));
  TicketLineInfo line=new TicketLineInfo(productObj,productObj.getPriceSell(),taxesLogic.getTaxInfo(productObj.getCategoryID()));
  obj.addLine(line);
  ticket.updateTicket(ticketId,obj);
  refreshTax(obj);
}","public void addLineToTicket(String ticketId,String productId){
  ticket=new TicketDAO();
  product=new ProductDAO();
  category=new CategoryDAO();
  tax=new TaxDAO();
  taxesLogic=new TaxesLogic(tax.getTaxList());
  TicketInfo obj=ticket.getTicket(ticketId);
  ProductInfo productObj=null;
  productObj=product.findProductById(productId);
  TicketLineInfo line=new TicketLineInfo(productObj,productObj.getPriceSell(),taxesLogic.getTaxInfo(productObj.getCategoryId()));
  obj.addLine(line);
  ticket.updateTicket(ticketId,obj);
  refreshTax(obj);
}",0.6369327073552425
5989,"public String findFloorById(String floorId){
  floor=new FloorDAO();
  return floor.findFloorById(floorId).getName();
}","public Floor findFloorById(String floorId){
  floor=new FloorDAO();
  return floor.findFloorById(floorId);
}",0.9162995594713657
5990,"@Override protected ProductInfo map2VO(ResultSet rs) throws SQLException {
  ProductInfo product=new ProductInfo();
  product.setId(rs.getString(""String_Node_Str""));
  product.setRef(rs.getString(""String_Node_Str""));
  product.setCode(rs.getString(""String_Node_Str""));
  product.setName(rs.getString(""String_Node_Str""));
  product.setPriceBuy(rs.getDouble(""String_Node_Str""));
  product.setPriceSell(rs.getDouble(""String_Node_Str""));
  product.setCategoryID(rs.getString(""String_Node_Str""));
  product.setTaxcat(rs.getString(""String_Node_Str""));
  product.setCom(rs.getBoolean(""String_Node_Str""));
  product.setScale(rs.getBoolean(""String_Node_Str""));
  return product;
}","@Override protected ProductInfo map2VO(ResultSet rs) throws SQLException {
  ProductInfo product=new ProductInfo();
  product.setId(rs.getString(""String_Node_Str""));
  product.setRef(rs.getString(""String_Node_Str""));
  product.setCode(rs.getString(""String_Node_Str""));
  product.setName(rs.getString(""String_Node_Str""));
  product.setPriceBuy(rs.getDouble(""String_Node_Str""));
  product.setPriceSell(rs.getDouble(""String_Node_Str""));
  product.setCategoryId(rs.getString(""String_Node_Str""));
  product.setTaxcat(rs.getString(""String_Node_Str""));
  product.setCom(rs.getBoolean(""String_Node_Str""));
  product.setScale(rs.getBoolean(""String_Node_Str""));
  return product;
}",0.9985096870342772
5991,"public TicketInfo getTicket(String id){
  Connection con=null;
  PreparedStatement ps=null;
  ResultSet rs=null;
  String sqlStr=""String_Node_Str"";
  TicketInfo ticket=new TicketInfo();
  try {
    con=getConnection();
    ps=con.prepareStatement(sqlStr);
    ps.setString(1,id);
    rs=ps.executeQuery();
    rs.next();
    ObjectInputStream in=new ObjectInputStream(new BufferedInputStream(rs.getBinaryStream(1)));
    ticket=(TicketInfo)in.readObject();
  }
 catch (  Exception ex) {
    Logger.getLogger(TicketDAO.class.getName()).log(Level.SEVERE,null,ex);
    return null;
  }
  return ticket;
}","public TicketInfo getTicket(String id){
  Connection con=null;
  PreparedStatement ps=null;
  ResultSet rs=null;
  String sqlStr=""String_Node_Str"";
  TicketInfo ticket=new TicketInfo();
  try {
    con=getConnection();
    ps=con.prepareStatement(sqlStr);
    ps.setString(1,id);
    rs=ps.executeQuery();
    rs.next();
    ObjectInputStream in=new ObjectInputStream(new BufferedInputStream(rs.getBinaryStream(1)));
    ticket=(TicketInfo)in.readObject();
  }
 catch (  Exception ex) {
    return null;
  }
  return ticket;
}",0.9334516415261755
5992,"/** 
 * This is the action called from the Struts framework.
 * @param mapping The ActionMapping used to select this instance.
 * @param form The optional ActionForm bean for this request.
 * @param request The HTTP Request we are processing.
 * @param response The HTTP Response we are processing.
 * @throws java.lang.Exception
 * @return
 */
public ActionForward execute(ActionMapping mapping,ActionForm form,HttpServletRequest request,HttpServletResponse response) throws Exception {
  FloorForm aForm=(FloorForm)form;
  RestaurantManager manager=new RestaurantManager();
  TicketInfo ticket=manager.findTicket(aForm.getId());
  List<TicketLineInfo> list=ticket.getM_aLines();
  String[] array=aForm.getParameters();
  list.get(Integer.valueOf(aForm.getLine())).setMultiply(Double.valueOf(array[0]));
  manager.updateLineFromTicket(aForm.getId(),ticket);
  request.setAttribute(""String_Node_Str"",aForm.getLine());
  request.setAttribute(""String_Node_Str"",ticket.getName());
  return mapping.findForward(SUCCESS);
}","/** 
 * This is the action called from the Struts framework.
 * @param mapping The ActionMapping used to select this instance.
 * @param form The optional ActionForm bean for this request.
 * @param request The HTTP Request we are processing.
 * @param response The HTTP Response we are processing.
 * @throws java.lang.Exception
 * @return
 */
public ActionForward execute(ActionMapping mapping,ActionForm form,HttpServletRequest request,HttpServletResponse response) throws Exception {
  FloorForm floorForm=(FloorForm)form;
  RestaurantManager manager=new RestaurantManager();
  String floorId=(String)floorForm.getFloorId();
  String place=(String)floorForm.getId();
  String str=(String)floorForm.getMode();
  String[] array=floorForm.getParameters();
  List<TicketLineInfo> linesList=new ArrayList<TicketLineInfo>();
  List products=new ArrayList<ProductInfoExt>();
  TicketInfo ticket=manager.findTicket(place);
  linesList=ticket.getM_aLines();
  if (array != null) {
    for (int i=0; i < array.length; i++) {
      linesList.get(Integer.valueOf(array[i]) - 0).setMultiply(linesList.get(Integer.valueOf(array[i]) - 0).getMultiply() + 1);
    }
  }
  manager.updateLineFromTicket(floorForm.getId(),ticket);
  for (  Object line : linesList) {
    TicketLineInfo li=(TicketLineInfo)line;
    products.add(manager.findProductById(li.getProductid()));
  }
  request.setAttribute(""String_Node_Str"",manager.findFloorById(manager.findPlaceById(place).getFloor()).getName());
  request.setAttribute(""String_Node_Str"",place);
  request.setAttribute(""String_Node_Str"",manager.findPlaceNameById(place));
  request.setAttribute(""String_Node_Str"",floorId);
  request.setAttribute(""String_Node_Str"",linesList);
  request.setAttribute(""String_Node_Str"",products);
  request.setAttribute(""String_Node_Str"",manager.getTotalOfaTicket(place));
  return mapping.findForward(SUCCESS);
}",0.6065006915629322
5993,"public byte[] transImage(BufferedImage image){
  CenteredImage centeredimage=new CenteredImage(image,IMAGE_WIDTH);
  int iWidth=(centeredimage.getWidth() + 7) / 8;
  int iHeight=centeredimage.getHeight();
  byte[] bData=new byte[getImageHeader().length + 4 + iWidth * iHeight];
  System.arraycopy(getImageHeader(),0,bData,0,getImageHeader().length);
  int index=getImageHeader().length;
  bData[index++]=(byte)(iWidth % 256);
  bData[index++]=(byte)(iWidth / 256);
  bData[index++]=(byte)(iHeight % 256);
  bData[index++]=(byte)(iHeight / 256);
  int iRGB;
  int p;
  for (int i=0; i < centeredimage.getHeight(); i++) {
    for (int j=0; j < centeredimage.getWidth(); j=j + 8) {
      p=0x00;
      for (int d=0; d < 8; d++) {
        p=p << 1;
        if (centeredimage.isBlack(j + d,i)) {
          p=p | 0x01;
        }
      }
      bData[index++]=(byte)p;
    }
  }
  return bData;
}","public byte[] transImage(BufferedImage image){
  CenteredImage centeredimage=new CenteredImage(image,getImageWidth());
  int iWidth=(centeredimage.getWidth() + 7) / 8;
  int iHeight=centeredimage.getHeight();
  byte[] bData=new byte[getImageHeader().length + 4 + iWidth * iHeight];
  System.arraycopy(getImageHeader(),0,bData,0,getImageHeader().length);
  int index=getImageHeader().length;
  bData[index++]=(byte)(iWidth % 256);
  bData[index++]=(byte)(iWidth / 256);
  bData[index++]=(byte)(iHeight % 256);
  bData[index++]=(byte)(iHeight / 256);
  int iRGB;
  int p;
  for (int i=0; i < centeredimage.getHeight(); i++) {
    for (int j=0; j < centeredimage.getWidth(); j=j + 8) {
      p=0x00;
      for (int d=0; d < 8; d++) {
        p=p << 1;
        if (centeredimage.isBlack(j + d,i)) {
          p=p | 0x01;
        }
      }
      bData[index++]=(byte)p;
    }
  }
  return bData;
}",0.9876404494382024
5994,"@Override public byte[] transImage(BufferedImage image){
  CenteredImage centeredimage=new CenteredImage(image,IMAGE_WIDTH);
  int iWidth=centeredimage.getWidth();
  int iHeight=(centeredimage.getHeight() + 7) / 8;
  byte[] bData=new byte[IMAGE_BEGIN.length + (getImageHeader().length + 2 + iWidth+ getNewLine().length) * iHeight + IMAGE_END.length];
  int index=0;
  System.arraycopy(IMAGE_BEGIN,0,bData,index,IMAGE_BEGIN.length);
  index+=IMAGE_BEGIN.length;
  int p;
  for (int i=0; i < centeredimage.getHeight(); i+=8) {
    System.arraycopy(getImageHeader(),0,bData,index,getImageHeader().length);
    index+=getImageHeader().length;
    bData[index++]=(byte)(iWidth % 256);
    bData[index++]=(byte)(iWidth / 256);
    for (int j=0; j < centeredimage.getWidth(); j++) {
      p=0x00;
      for (int d=0; d < 8; d++) {
        p=p << 1;
        if (centeredimage.isBlack(j,i + d)) {
          p=p | 0x01;
        }
      }
      bData[index++]=(byte)p;
    }
    System.arraycopy(getNewLine(),0,bData,index,getNewLine().length);
    index+=getNewLine().length;
  }
  System.arraycopy(IMAGE_END,0,bData,index,IMAGE_END.length);
  index+=IMAGE_END.length;
  return bData;
}","@Override public byte[] transImage(BufferedImage image){
  CenteredImage centeredimage=new CenteredImage(image,getImageWidth());
  int iWidth=centeredimage.getWidth();
  int iHeight=(centeredimage.getHeight() + 7) / 8;
  byte[] bData=new byte[IMAGE_BEGIN.length + (getImageHeader().length + 2 + iWidth+ getNewLine().length) * iHeight + IMAGE_END.length];
  int index=0;
  System.arraycopy(IMAGE_BEGIN,0,bData,index,IMAGE_BEGIN.length);
  index+=IMAGE_BEGIN.length;
  int p;
  for (int i=0; i < centeredimage.getHeight(); i+=8) {
    System.arraycopy(getImageHeader(),0,bData,index,getImageHeader().length);
    index+=getImageHeader().length;
    bData[index++]=(byte)(iWidth % 256);
    bData[index++]=(byte)(iWidth / 256);
    for (int j=0; j < centeredimage.getWidth(); j++) {
      p=0x00;
      for (int d=0; d < 8; d++) {
        p=p << 1;
        if (centeredimage.isBlack(j,i + d)) {
          p=p | 0x01;
        }
      }
      bData[index++]=(byte)p;
    }
    System.arraycopy(getNewLine(),0,bData,index,getNewLine().length);
    index+=getNewLine().length;
  }
  System.arraycopy(IMAGE_END,0,bData,index,IMAGE_END.length);
  index+=IMAGE_END.length;
  return bData;
}",0.1765704584040747
5995,"protected void internalWrite(byte[] data){
  try {
    if (m_out == null) {
      m_PortIdPrinter=CommPortIdentifier.getPortIdentifier(m_sPortPrinter);
      m_CommPortPrinter=m_PortIdPrinter.open(""String_Node_Str"",2000);
      m_out=m_CommPortPrinter.getOutputStream();
      if (m_PortIdPrinter.getPortType() == CommPortIdentifier.PORT_SERIAL) {
        ((SerialPort)m_CommPortPrinter).setSerialPortParams(9600,SerialPort.DATABITS_8,SerialPort.STOPBITS_1,SerialPort.PARITY_NONE);
      }
 else       if (m_PortIdPrinter.getPortType() == CommPortIdentifier.PORT_PARALLEL) {
        ((ParallelPort)m_CommPortPrinter).setMode(1);
      }
    }
    m_out.write(data);
  }
 catch (  NoSuchPortException e) {
    System.err.println(e);
  }
catch (  PortInUseException e) {
    System.err.println(e);
  }
catch (  UnsupportedCommOperationException e) {
    System.err.println(e);
  }
catch (  IOException e) {
    System.err.println(e);
  }
}","protected void internalWrite(byte[] data){
  try {
    if (m_out == null) {
      m_PortIdPrinter=CommPortIdentifier.getPortIdentifier(m_sPortPrinter);
      m_CommPortPrinter=m_PortIdPrinter.open(""String_Node_Str"",2000);
      m_out=m_CommPortPrinter.getOutputStream();
      if (m_PortIdPrinter.getPortType() == CommPortIdentifier.PORT_SERIAL) {
        ((SerialPort)m_CommPortPrinter).setSerialPortParams(9600,SerialPort.DATABITS_8,SerialPort.STOPBITS_1,SerialPort.PARITY_NONE);
      }
    }
    m_out.write(data);
  }
 catch (  NoSuchPortException e) {
    System.err.println(e);
  }
catch (  PortInUseException e) {
    System.err.println(e);
  }
catch (  UnsupportedCommOperationException e) {
    System.err.println(e);
  }
catch (  IOException e) {
    System.err.println(e);
  }
}",0.914881297046902
5996,"@Override public void execute(PaymentInfoMagcard payinfo){
  StringBuffer sb=new StringBuffer();
  try {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(URLEncoder.encode(m_sCommerceID,""String_Node_Str""));
    sb.append(""String_Node_Str"");
    sb.append(URLEncoder.encode(m_sCommercePassword,""String_Node_Str""));
    sb.append(""String_Node_Str"");
    NumberFormat formatter=new DecimalFormat(""String_Node_Str"");
    String amount=formatter.format(Math.abs(payinfo.getTotal()));
    sb.append(URLEncoder.encode(amount.replace(',','.'),""String_Node_Str""));
    if (payinfo.getTrack1(true) == null && payinfo.getTrack2(true) == null && payinfo.getTrack3(true) == null) {
      sb.append(""String_Node_Str"");
      sb.append(URLEncoder.encode(payinfo.getCardNumber(),""String_Node_Str""));
      sb.append(""String_Node_Str"");
      String tmp=payinfo.getExpirationDate();
      sb.append(URLEncoder.encode(tmp,""String_Node_Str""));
      String[] cc_name=payinfo.getHolderName().split(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      if (cc_name.length > 0) {
        sb.append(URLEncoder.encode(cc_name[0],""String_Node_Str""));
      }
      sb.append(""String_Node_Str"");
      if (cc_name.length > 1) {
        sb.append(URLEncoder.encode(cc_name[1],""String_Node_Str""));
      }
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(payinfo.getTrack1(false));
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(m_bTestMode);
    if (payinfo.getTotal() >= 0.0) {
      sb.append(""String_Node_Str"");
      sb.append(OPERATIONVALIDATE);
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(OPERATIONREFUND);
      sb.append(""String_Node_Str"");
      sb.append(payinfo.getTransactionID());
    }
    URL url=new URL(ENDPOINTADDRESS);
    URLConnection connection=url.openConnection();
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(sb.toString().getBytes());
    out.flush();
    out.close();
    BufferedReader in=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    String returned=in.readLine();
    in.close();
    AuthorizeNetParser anp=new AuthorizeNetParser(returned);
    Map props=anp.splitXML();
    if (anp.getResult().equals(LocalRes.getIntString(""String_Node_Str""))) {
      if (APPROVED.equals(props.get(""String_Node_Str""))) {
        payinfo.paymentOK((String)props.get(""String_Node_Str""),(String)props.get(""String_Node_Str""),returned);
      }
 else {
        StringBuilder errorLine=new StringBuilder();
        if (anp.getNumErrors() > 0) {
          for (int i=1; i <= anp.getNumErrors(); i++) {
            errorLine.append(props.get(""String_Node_Str"" + Integer.toString(i)));
            errorLine.append(""String_Node_Str"");
            errorLine.append(props.get(""String_Node_Str"" + Integer.toString(i)));
            errorLine.append(""String_Node_Str"");
          }
        }
        payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),errorLine.toString());
      }
    }
 else {
      payinfo.paymentError(anp.getResult(),""String_Node_Str"");
    }
  }
 catch (  UnsupportedEncodingException eUE) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eUE.getMessage());
  }
catch (  MalformedURLException eMURL) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eMURL.getMessage());
  }
catch (  IOException e) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),e.getMessage());
  }
}","@Override public void execute(PaymentInfoMagcard payinfo){
  StringBuffer sb=new StringBuffer();
  try {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(URLEncoder.encode(m_sCommerceID,""String_Node_Str""));
    sb.append(""String_Node_Str"");
    sb.append(URLEncoder.encode(m_sCommercePassword,""String_Node_Str""));
    sb.append(""String_Node_Str"");
    NumberFormat formatter=new DecimalFormat(""String_Node_Str"");
    String amount=formatter.format(Math.abs(payinfo.getTotal()));
    sb.append(URLEncoder.encode(amount.replace(',','.'),""String_Node_Str""));
    if (payinfo.getTrack1(true) == null) {
      sb.append(""String_Node_Str"");
      sb.append(URLEncoder.encode(payinfo.getCardNumber(),""String_Node_Str""));
      sb.append(""String_Node_Str"");
      String tmp=payinfo.getExpirationDate();
      sb.append(URLEncoder.encode(tmp,""String_Node_Str""));
      String[] cc_name=payinfo.getHolderName().split(""String_Node_Str"");
      sb.append(""String_Node_Str"");
      if (cc_name.length > 0) {
        sb.append(URLEncoder.encode(cc_name[0],""String_Node_Str""));
      }
      sb.append(""String_Node_Str"");
      if (cc_name.length > 1) {
        sb.append(URLEncoder.encode(cc_name[1],""String_Node_Str""));
      }
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(payinfo.getTrack1(false));
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(m_bTestMode);
    if (payinfo.getTotal() >= 0.0) {
      sb.append(""String_Node_Str"");
      sb.append(OPERATIONVALIDATE);
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(OPERATIONREFUND);
      sb.append(""String_Node_Str"");
      sb.append(payinfo.getTransactionID());
    }
    URL url=new URL(ENDPOINTADDRESS);
    URLConnection connection=url.openConnection();
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    DataOutputStream out=new DataOutputStream(connection.getOutputStream());
    out.write(sb.toString().getBytes());
    out.flush();
    out.close();
    BufferedReader in=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    String returned=in.readLine();
    in.close();
    AuthorizeNetParser anp=new AuthorizeNetParser(returned);
    Map props=anp.splitXML();
    if (anp.getResult().equals(LocalRes.getIntString(""String_Node_Str""))) {
      if (APPROVED.equals(props.get(""String_Node_Str""))) {
        payinfo.paymentOK((String)props.get(""String_Node_Str""),(String)props.get(""String_Node_Str""),returned);
      }
 else {
        StringBuilder errorLine=new StringBuilder();
        if (anp.getNumErrors() > 0) {
          for (int i=1; i <= anp.getNumErrors(); i++) {
            errorLine.append(props.get(""String_Node_Str"" + Integer.toString(i)));
            errorLine.append(""String_Node_Str"");
            errorLine.append(props.get(""String_Node_Str"" + Integer.toString(i)));
            errorLine.append(""String_Node_Str"");
          }
        }
        payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),errorLine.toString());
      }
    }
 else {
      payinfo.paymentError(anp.getResult(),""String_Node_Str"");
    }
  }
 catch (  UnsupportedEncodingException eUE) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eUE.getMessage());
  }
catch (  MalformedURLException eMURL) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),eMURL.getMessage());
  }
catch (  IOException e) {
    payinfo.paymentError(AppLocal.getIntString(""String_Node_Str""),e.getMessage());
  }
}",0.9908925318761383
5997,"public TicketLineInfo copyTicketLine(){
  TicketLineInfo l=new TicketLineInfo();
  l.productid=productid;
  l.multiply=multiply;
  l.price=price;
  l.tax=tax;
  l.attributes=(Properties)attributes.clone();
  return l;
}","public TicketLineInfo copyTicketLine(){
  TicketLineInfo l=new TicketLineInfo();
  l.productid=productid;
  l.attsetinstid=attsetinstid;
  l.multiply=multiply;
  l.price=price;
  l.tax=tax;
  l.attributes=(Properties)attributes.clone();
  return l;
}",0.9339019189765458
5998,"private void init(String productid,double dMultiply,double dPrice,TaxInfo tax,Properties attributes){
  this.productid=productid;
  attsetinstid=null;
  multiply=dMultiply;
  price=dPrice;
  this.tax=tax;
  this.attributes=attributes;
  m_sTicket=null;
  m_iLine=-1;
}","private void init(String productid,String attsetinstid,double dMultiply,double dPrice,TaxInfo tax,Properties attributes){
  this.productid=productid;
  this.attsetinstid=attsetinstid;
  multiply=dMultiply;
  price=dPrice;
  this.tax=tax;
  this.attributes=attributes;
  m_sTicket=null;
  m_iLine=-1;
}",0.8822495606326889
5999,"public TicketLineInfo(TicketLineInfo line){
  init(line.productid,line.multiply,line.price,line.tax,(Properties)line.attributes.clone());
}","public TicketLineInfo(TicketLineInfo line){
  init(line.productid,line.attsetinstid,line.multiply,line.price,line.tax,(Properties)line.attributes.clone());
}",0.9391891891891893
6000,"public void saveProperties(AppConfig config){
  config.setProperty(""String_Node_Str"",uniqueinstance);
  config.setProperty(""String_Node_Str"",jtxtMachineHostname.getText());
  LAFInfo laf=(LAFInfo)jcboLAF.getSelectedItem();
  config.setProperty(""String_Node_Str"",laf == null ? System.getProperty(""String_Node_Str"",""String_Node_Str"") : laf.getClassName());
  config.setProperty(""String_Node_Str"",comboValue(jcboMachineScreenmode.getSelectedItem()));
  config.setProperty(""String_Node_Str"",comboValue(jcboTicketsBag.getSelectedItem()));
  String sMachinePrinter=comboValue(jcboMachinePrinter.getSelectedItem());
  if (""String_Node_Str"".equals(sMachinePrinter) || ""String_Node_Str"".equals(sMachinePrinter) || ""String_Node_Str"".equals(sMachinePrinter)|| ""String_Node_Str"".equals(sMachinePrinter)|| ""String_Node_Str"".equals(sMachinePrinter)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter + ""String_Node_Str"" + comboValue(jcboConnPrinter.getSelectedItem())+ ""String_Node_Str""+ comboValue(jcboSerialPrinter.getSelectedItem()));
  }
 else   if (""String_Node_Str"".equals(sMachinePrinter)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter + ""String_Node_Str"" + m_jtxtJPOSPrinter.getText()+ ""String_Node_Str""+ m_jtxtJPOSDrawer.getText());
  }
 else   if (""String_Node_Str"".equals(sMachinePrinter)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter + ""String_Node_Str"" + printer1printerparams.getParameters());
  }
 else {
    config.setProperty(""String_Node_Str"",sMachinePrinter);
  }
  String sMachinePrinter2=comboValue(jcboMachinePrinter2.getSelectedItem());
  if (""String_Node_Str"".equals(sMachinePrinter2) || ""String_Node_Str"".equals(sMachinePrinter2) || ""String_Node_Str"".equals(sMachinePrinter2)|| ""String_Node_Str"".equals(sMachinePrinter2)|| ""String_Node_Str"".equals(sMachinePrinter2)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter2 + ""String_Node_Str"" + comboValue(jcboConnPrinter2.getSelectedItem())+ ""String_Node_Str""+ comboValue(jcboSerialPrinter2.getSelectedItem()));
  }
 else   if (""String_Node_Str"".equals(sMachinePrinter2)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter2 + ""String_Node_Str"" + m_jtxtJPOSPrinter2.getText()+ ""String_Node_Str""+ m_jtxtJPOSDrawer2.getText());
  }
 else   if (""String_Node_Str"".equals(sMachinePrinter2)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter2 + ""String_Node_Str"" + printer2printerparams.getParameters());
  }
 else {
    config.setProperty(""String_Node_Str"",sMachinePrinter2);
  }
  String sMachinePrinter3=comboValue(jcboMachinePrinter3.getSelectedItem());
  if (""String_Node_Str"".equals(sMachinePrinter3) || ""String_Node_Str"".equals(sMachinePrinter3) || ""String_Node_Str"".equals(sMachinePrinter3)|| ""String_Node_Str"".equals(sMachinePrinter3)|| ""String_Node_Str"".equals(sMachinePrinter3)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter3 + ""String_Node_Str"" + comboValue(jcboConnPrinter3.getSelectedItem())+ ""String_Node_Str""+ comboValue(jcboSerialPrinter3.getSelectedItem()));
  }
 else   if (""String_Node_Str"".equals(sMachinePrinter3)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter3 + ""String_Node_Str"" + m_jtxtJPOSPrinter3.getText()+ ""String_Node_Str""+ m_jtxtJPOSDrawer3.getText());
  }
 else   if (""String_Node_Str"".equals(sMachinePrinter3)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter3 + ""String_Node_Str"" + printer3printerparams.getParameters());
  }
 else {
    config.setProperty(""String_Node_Str"",sMachinePrinter3);
  }
  String sMachineDisplay=comboValue(jcboMachineDisplay.getSelectedItem());
  if (""String_Node_Str"".equals(sMachineDisplay) || ""String_Node_Str"".equals(sMachineDisplay) || ""String_Node_Str"".equals(sMachineDisplay)) {
    config.setProperty(""String_Node_Str"",sMachineDisplay + ""String_Node_Str"" + comboValue(jcboConnDisplay.getSelectedItem())+ ""String_Node_Str""+ comboValue(jcboSerialDisplay.getSelectedItem()));
  }
 else   if (""String_Node_Str"".equals(sMachineDisplay)) {
    config.setProperty(""String_Node_Str"",sMachineDisplay + ""String_Node_Str"" + m_jtxtJPOSName.getText());
  }
 else {
    config.setProperty(""String_Node_Str"",sMachineDisplay);
  }
  String sMachineScale=comboValue(jcboMachineScale.getSelectedItem());
  if (""String_Node_Str"".equals(sMachineScale) || ""String_Node_Str"".equals(sMachineScale)) {
    config.setProperty(""String_Node_Str"",sMachineScale + ""String_Node_Str"" + comboValue(jcboSerialScale.getSelectedItem()));
  }
 else {
    config.setProperty(""String_Node_Str"",sMachineScale);
  }
  String sMachineScanner=comboValue(jcboMachineScanner.getSelectedItem());
  if (""String_Node_Str"".equals(sMachineScanner)) {
    config.setProperty(""String_Node_Str"",sMachineScanner + ""String_Node_Str"" + comboValue(jcboSerialScanner.getSelectedItem()));
  }
 else {
    config.setProperty(""String_Node_Str"",sMachineScanner);
  }
  config.setProperty(""String_Node_Str"",comboValue(cboPrinters.getSelectedItem()));
  dirty.setDirty(false);
}","public void saveProperties(AppConfig config){
  config.setProperty(""String_Node_Str"",jtxtMachineHostname.getText());
  LAFInfo laf=(LAFInfo)jcboLAF.getSelectedItem();
  config.setProperty(""String_Node_Str"",laf == null ? System.getProperty(""String_Node_Str"",""String_Node_Str"") : laf.getClassName());
  config.setProperty(""String_Node_Str"",comboValue(jcboMachineScreenmode.getSelectedItem()));
  config.setProperty(""String_Node_Str"",comboValue(jcboTicketsBag.getSelectedItem()));
  String sMachinePrinter=comboValue(jcboMachinePrinter.getSelectedItem());
  if (""String_Node_Str"".equals(sMachinePrinter) || ""String_Node_Str"".equals(sMachinePrinter) || ""String_Node_Str"".equals(sMachinePrinter)|| ""String_Node_Str"".equals(sMachinePrinter)|| ""String_Node_Str"".equals(sMachinePrinter)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter + ""String_Node_Str"" + comboValue(jcboConnPrinter.getSelectedItem())+ ""String_Node_Str""+ comboValue(jcboSerialPrinter.getSelectedItem()));
  }
 else   if (""String_Node_Str"".equals(sMachinePrinter)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter + ""String_Node_Str"" + m_jtxtJPOSPrinter.getText()+ ""String_Node_Str""+ m_jtxtJPOSDrawer.getText());
  }
 else   if (""String_Node_Str"".equals(sMachinePrinter)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter + ""String_Node_Str"" + printer1printerparams.getParameters());
  }
 else {
    config.setProperty(""String_Node_Str"",sMachinePrinter);
  }
  String sMachinePrinter2=comboValue(jcboMachinePrinter2.getSelectedItem());
  if (""String_Node_Str"".equals(sMachinePrinter2) || ""String_Node_Str"".equals(sMachinePrinter2) || ""String_Node_Str"".equals(sMachinePrinter2)|| ""String_Node_Str"".equals(sMachinePrinter2)|| ""String_Node_Str"".equals(sMachinePrinter2)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter2 + ""String_Node_Str"" + comboValue(jcboConnPrinter2.getSelectedItem())+ ""String_Node_Str""+ comboValue(jcboSerialPrinter2.getSelectedItem()));
  }
 else   if (""String_Node_Str"".equals(sMachinePrinter2)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter2 + ""String_Node_Str"" + m_jtxtJPOSPrinter2.getText()+ ""String_Node_Str""+ m_jtxtJPOSDrawer2.getText());
  }
 else   if (""String_Node_Str"".equals(sMachinePrinter2)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter2 + ""String_Node_Str"" + printer2printerparams.getParameters());
  }
 else {
    config.setProperty(""String_Node_Str"",sMachinePrinter2);
  }
  String sMachinePrinter3=comboValue(jcboMachinePrinter3.getSelectedItem());
  if (""String_Node_Str"".equals(sMachinePrinter3) || ""String_Node_Str"".equals(sMachinePrinter3) || ""String_Node_Str"".equals(sMachinePrinter3)|| ""String_Node_Str"".equals(sMachinePrinter3)|| ""String_Node_Str"".equals(sMachinePrinter3)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter3 + ""String_Node_Str"" + comboValue(jcboConnPrinter3.getSelectedItem())+ ""String_Node_Str""+ comboValue(jcboSerialPrinter3.getSelectedItem()));
  }
 else   if (""String_Node_Str"".equals(sMachinePrinter3)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter3 + ""String_Node_Str"" + m_jtxtJPOSPrinter3.getText()+ ""String_Node_Str""+ m_jtxtJPOSDrawer3.getText());
  }
 else   if (""String_Node_Str"".equals(sMachinePrinter3)) {
    config.setProperty(""String_Node_Str"",sMachinePrinter3 + ""String_Node_Str"" + printer3printerparams.getParameters());
  }
 else {
    config.setProperty(""String_Node_Str"",sMachinePrinter3);
  }
  String sMachineDisplay=comboValue(jcboMachineDisplay.getSelectedItem());
  if (""String_Node_Str"".equals(sMachineDisplay) || ""String_Node_Str"".equals(sMachineDisplay) || ""String_Node_Str"".equals(sMachineDisplay)) {
    config.setProperty(""String_Node_Str"",sMachineDisplay + ""String_Node_Str"" + comboValue(jcboConnDisplay.getSelectedItem())+ ""String_Node_Str""+ comboValue(jcboSerialDisplay.getSelectedItem()));
  }
 else   if (""String_Node_Str"".equals(sMachineDisplay)) {
    config.setProperty(""String_Node_Str"",sMachineDisplay + ""String_Node_Str"" + m_jtxtJPOSName.getText());
  }
 else {
    config.setProperty(""String_Node_Str"",sMachineDisplay);
  }
  String sMachineScale=comboValue(jcboMachineScale.getSelectedItem());
  if (""String_Node_Str"".equals(sMachineScale) || ""String_Node_Str"".equals(sMachineScale)) {
    config.setProperty(""String_Node_Str"",sMachineScale + ""String_Node_Str"" + comboValue(jcboSerialScale.getSelectedItem()));
  }
 else {
    config.setProperty(""String_Node_Str"",sMachineScale);
  }
  String sMachineScanner=comboValue(jcboMachineScanner.getSelectedItem());
  if (""String_Node_Str"".equals(sMachineScanner)) {
    config.setProperty(""String_Node_Str"",sMachineScanner + ""String_Node_Str"" + comboValue(jcboSerialScanner.getSelectedItem()));
  }
 else {
    config.setProperty(""String_Node_Str"",sMachineScanner);
  }
  config.setProperty(""String_Node_Str"",comboValue(cboPrinters.getSelectedItem()));
  dirty.setDirty(false);
}",0.9942927028128822
